--[=[
 o-----------------------------------------------------------------------------o
 |
 | Twiss tests
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide regression test suites for the twiss module.

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local assertNotNil, assertEquals, assertAlmostEquals, assertAllAlmostEquals,
      assertStrContains, assertErrorMsgContains                  in MAD.utest

local sequence, beam, track, twiss, plot, option, filesys        in MAD
local sin, frac                                                  in MAD.gmath
local fnone, ftrue, ffalse                                       in MAD.gfunc
local marker, drift, quadrupole, multipole                       in MAD.element
local eps, pi                                                    in MAD.constant
local openfile                                                   in MAD.utility
local deferred                                                   in MAD.typeid

local refdir = \s -> 'twiss_ref/'..(s or '')
local rundir = \s -> 'twiss_run/'..(s or '')

-- helpers --------------------------------------------------------------------o

local doplot ! = true

if doplot then
  local pause, atexit in MAD.utility
  atexit(pause, true)
end

local function plottw (mtbl, seq)
  if not doplot then return end
  MAD.plot { table=mtbl, title=mtbl.title, sequence=seq,
             x1y1 = { s={'beta11','beta22'} },
             x1y2 = { s={'mu1'   ,'mu2'   } } }
end

local tbl_col = {'name','s','l','slc','beta11','beta22'}
local tbl_hdr = {'title','type','origin','date','time'}

local srvcol = {'name','kind','s','l','x','y','z'}
local trkcol = {'name','kind','s','l','x','px','y','py','t','pt'}
local twscol = {'name','s','l','beta1','alfa1','mu1','beta2','alfa2','mu2','disp1','disp2'}
local trkcolre = {'name','kind','s','l','x','px','y','py','t','pt',
                  're11','re12','re13','re14','re15','re16',
                  're21','re22','re23','re24','re25','re26',
                  're31','re32','re33','re34','re35','re36',
                  're41','re42','re43','re44','re45','re46',
                  're51','re52','re53','re54','re55','re56',
                  're61','re62','re63','re64','re65','re66' }

-- Tests ----------------------------------------------------------------------o

TestTwiss = {}

function TestTwiss:setUp ()
  filesys.mkdir(rundir())
  self.optfmt = option.format
  self.nochrg = option.nocharge
  option.format = "%-.10g"
  option.nocharge = true
end

function TestTwiss:tearDown ()
  option.format   = self.optfmt
  option.nocharge = self.nochrg
end

function TestTwiss:testTwissThinFODO ()
  local nsl = 10 -- 10 -- for madx row by row compatibility
  local nth = 10
  local dl  = 1/nth
  local X0  = { 0, 1e-6, 0, 5e-7, 0, 0 }
  local k1l = 0.3037241107
  local mk1 = marker    'mk1' {}
  local mk2 = marker    'mk2' {}
  local df1 = drift     'df1' { l=4, nslice=nsl }
  local df2 = drift     'df2' { l=4, nslice=nsl }
  local mq1 = multipole 'mq1' { knl := {0,  k1l/nth} }
  local mq2 = multipole 'mq2' { knl := {0, -k1l/nth} }
  local seq = sequence  'seq' { l=10, refer='entry', -- dir=-1,
                mq1 {at=0+dl/2              },
      (nth/2-1)*mq1 {at=dl    , from='prev' },
                mk1 {at=0+dl/2, from='prev' },
                mq1 {at=0+dl/2, from='prev' },
      (nth/2-1)*mq1 {at=dl    , from='prev' },
                df1 {at=1}, -- for madx row by row compatibility

                mq2 {at=5+dl/2              },
      (nth/2-1)*mq2 {at=dl    , from='prev' },
                mk2 {at=0+dl/2, from='prev' },
                mq2 {at=0+dl/2, from='prev' },
      (nth/2-1)*mq2 {at=dl    , from='prev' },
                df2 {at=6}, -- for madx row by row compatibility
  }

  -- seq:dumpseq()

  local mtbl, mflw = MAD.twiss{sequence=seq, beam=beam, X0=X0,
                              -- atslice=ftrue} -- for madx row by row compatibility
                               atslice=ftrue, atexit=ffalse}

  plottw(mtbl, seq)
  mtbl:write(rundir('thinfodotwiss'), tbl_col, tbl_hdr)

  -- TODO: 6D case
  assertEquals(mflw.__twdat.ofun.rank, 6)
--  assertEquals(iter, 2)
--  assertEquals(type, "4D")
--  assertAllAlmostEquals(mflw.X[1]:totable(), 0, eps)
end

function TestTwiss:testTwissFODO ()
  local k1l = 0.3037241107 -- TODO: match the strength...
  local df  = drift      'df'  { l=4 }
  local mqf = quadrupole 'mqf' { l=1, k1 :=  k1l }
  local mqd = quadrupole 'mqd' { l=1, k1 := -k1l }
  local seq = sequence 'seq' {
    l=10, refer='entry', -- dir=-1,
    mqf 'mq1' {at=0}, df  'df1' {at=1},
    mqd 'mq2' {at=5}, df  'df2' {at=6},
  }

  -- seq:dumpseq()
  local X0  = { 0, 1e-6, 0, 5e-7, 0, 0 }

  local mtbl, mflw = twiss{sequence=seq, beam=beam, X0=X0, nslice=10, atslice=ftrue}

  plottw(mtbl, seq)
  mtbl:write(rundir('fodotwiss'), tbl_col, tbl_hdr)

  -- TODO: 6D case
  assertEquals(mflw.__twdat.ofun.rank, 6)
--  assertEquals(iter, 2)
--  assertEquals(type, "4D")
--  assertAllAlmostEquals(mflw.X[1]:totable(), 0, eps)
end

-- from MAD-X course, src_4.1 and src_5.1
function TestTwiss:testTwissSimpleRing ()
  !! import
  local beam, sequence, element, survey, track, cofind, twiss in MAD
  local drift, marker, sbend, quadrupole, sextupole, hkicker, vkicker,
        monitor, bline in element

  !! vars, knobs
  local l , n  = deferred {}, deferred {}
  local k1, k2 = deferred {}, deferred {}

  !! context (note: Setup sets option.nocharge=true)
  local beam = beam { particle='electron', energy=20 }

  !! constants
  l.sequ = 240 ! length of the machine
  l.ssec = 20  ! length of the straight sections
  n.ssec = 2   ! number of straight sections
  n.bend = 4   ! number of bends per cell

  !! lengths
  l.mb=3.3 ; l.mq=0.8 ; l.ms=0.4 ; l.mk=0.25 ; l.bp=0.25
  l.de = 0.3 ; l.df = 0.5
  l.cell =\ 2*(l.mb+l.bp+l.mk+l.mq+l.ms+l.mb +4*l.de +l.df)
  n.cell =\ 1*(l.sequ/n.ssec - l.ssec)/l.cell
  print('l.cell=', l.cell, 'n.cell=', n.cell)

  !! classes
  local df = drift      'df' {}
  local mb = sbend      'mb' { l := l.mb }
  local mq = quadrupole 'mq' { l := l.mq }
  local ms = sextupole  'ms' { l := l.ms }
  local hk = hkicker    'hk' { l := l.mk }
  local vk = vkicker    'vk' { l := l.mk }
  local bp = monitor    'bp' { l := l.bp }
  local mk = marker     'mk' {}

  !! families
  local qf = mq 'qf' { k1 := k1.qf }
  local qd = mq 'qd' { k1 := k1.qd }
  local sf = ms 'sf' { k2 := k2.sf }
  local sd = ms 'sd' { k2 := k2.sd }
  local d0 = df 'd0' { l  := l.ssec/2 }
  local d1 = df 'd1' { l  := l.df/2 }
  local d2 = df 'd2' { l  := l.de }
  local mkf , mkd     = mk 'mkf' {}, mk 'mkd' {}
  local mkl , mkr, ip = mk 'mkl' {}, mk 'mkr' {}, mk 'ip' {}

  !! lattice
  local cellf = bline    'cellf' {mkf,d1,mb,d2,bp,hk,d2,qf,d2,sf,d2,mb,d1}
  local celld = bline    'celld' {mkd,d1,mb,d2,bp,vk,d2,qd,d2,sd,d2,mb,d1}
  local cell  = bline    'cell'  {cellf,celld}
  local ssec  = bline    'ssec'  {mkl,d0,ip,d0,mkr}
  local arc   = sequence 'arc'   {5*cell}
  local sequ  = sequence 'sequ'  {arc,ssec,arc,ssec}

  -- arc:dumpseq()

  !! angle
  n.mb = n.ssec*n.cell*n.bend
  mb.angle =\ 2*pi/n.mb
  print('n.mb=', n.mb, 'mb.angle=', mb.angle)

  !! survey
  local srv = survey { sequence=sequ, implicit=true, atslice=ftrue }
  srv:write(rundir('sr_survey'), srvcol)

  !! plot survey
  if doplot then
    plot {
      sequence = sequ,
      laypos   = "in",
      layonly  = false,
      x1y1     = { x = 'z' },
      styles   = 'lines',
    --  prolog   = 'set xrange [] reverse',
      xlabel   = "x [m]",
      ylabel   = "z [m]",
      fontsize = 14,
    }
  end

  !! thick_approx
  local u_cell = pi/2
  local f_cell = l.cell/(4*sin(u_cell/2))
  local k_cell = 1/(f_cell * l.mq)
  k1.qf = k_cell ; k1.qd = -k_cell
  print('qf.k1=', qf.k1, 'qd.k1=', qd.k1)
  print('qf.k1_f=', qf.k1*beam.brho, 'mb.k0_f=', mb.angle*beam.brho/mb.l)

  !! track
  local trk = track { sequence=arc, beam=beam, mapdef=true, save=true, mapsave=true, observe=false }
  print("#trk=", #trk)
  for i=1,6 do for j=1,6 do
    trk:addcol('re'..i..j, \r -> trk.M[r][i]:get(j+1))
  end end
  trk:write(rundir('sr_track_arc'), trkcolre)

--  !! cofind
--  local X, R, rnk, typ, itr = cofind { sequence=arc, beam=beam }
--  print('itr=', itr, 'rnk=', rnk, 'typ=', typ)
--  X:print('X=')
--  R:print('R=')

--[[
Started on Wed Feb 20 16:08:26 2019
    TestTwiss.testTwissSimpleRing ... l.cell= 20  n.cell= 5
n.mb= 40  mb.angle= 0.15707963267949
qf.k1=  0.17677669529664  qd.k1=  -0.17677669529664
qf.k1_f=  11.793271679899 mb.k0_f=  3.1755227594964
itr=  1 rnk=  4 typ=  4D
X=[6x1] =
  0
  0
  0
  0
  0
  0
R=[6x6] =
  -1.648112459   8.698705172    -7.63197244e-12   -6.248129947e-10  0              9.339706654
  -0.1331900412  0.09617672986  -3.466669589e-12  -2.768537976e-10  0              0.9570117197
   0             0               1.63899531       15.00130722       0              0
   0             0              -0.1879900437     -1.110495185      0              0
   0.3334443832 -7.426412818     0                 0                1.000000083  -13.97240545
   0             0               0                 0                0              1
Ok
--]]

  !! twiss
--  local tws = twiss { sequence=arc, beam=beam, implicit=true }
--  local mux = 360*frac(tws.q1[1])/n.cell
--  local muy = 360*frac(tws.q2[1])/n.cell
--  print('mux=', mux, 'muy=', muy)
end

-- end ------------------------------------------------------------------------o
