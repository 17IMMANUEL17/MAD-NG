--[=[
 o-----------------------------------------------------------------------------o
 |
 | Twiss tests
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide regression test suites for the twiss module.

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local assertNotNil, assertEquals, assertAlmostEquals, assertAllAlmostEquals,
      assertStrContains, assertErrorMsgContains                  in MAD.utest

local sequence, beam, track, cofind, twiss, plot, matrix,
      option, filesys                                            in MAD
local sin, frac                                                  in MAD.gmath
local make_symp                                                  in MAD.gphys
local fnone, ftrue, ffalse                                       in MAD.gfunc
local marker, drift, quadrupole, multipole                       in MAD.element
local eps, pi                                                    in MAD.constant
local openfile, pause, atexit                                    in MAD.utility
local deferred                                                   in MAD.typeid

local refdir = \s -> 'twiss_ref/'..(s or '')
local rundir = \s -> 'twiss_run/'..(s or '')

-- helpers --------------------------------------------------------------------o

local doplot != true

if doplot then atexit(pause, true) end

local function plottw (mtbl, seq)
  if not doplot then return end
  MAD.plot { table=mtbl, title=mtbl.title, sequence=seq,
             x1y1 = { s={'beta11','beta22'} },
             x1y2 = { s={'mu1'   ,'mu2'   } } }
end

local tbl_col  = {'name','s','l','slc','beta11','beta22'}
local tbl_hdr  = {'title','type','origin','date','time'}

local srvcol   = {'name','kind','s','l','x','y','z'}
local trkcol   = {'name','kind','s','l','x','px','y','py','t','pt'}
local twscol   = {'name','s','l','beta11','alfa11','mu1','beta22','alfa22','mu2','disp1','disp2'}
local trkcolre = {'name','kind','s','l','x','px','y','py','t','pt',
                  're11','re12','re13','re14','re15','re16',
                  're21','re22','re23','re24','re25','re26',
                  're31','re32','re33','re34','re35','re36',
                  're41','re42','re43','re44','re45','re46',
                  're51','re52','re53','re54','re55','re56',
                  're61','re62','re63','re64','re65','re66' }
local twscolre = {'name','s','l','beta11','alfa11','mu1','beta22','alfa22','mu2','disp1','disp2',
                  're11','re12','re13','re14','re15','re16',
                  're21','re22','re23','re24','re25','re26',
                  're31','re32','re33','re34','re35','re36',
                  're41','re42','re43','re44','re45','re46',
                  're51','re52','re53','re54','re55','re56',
                  're61','re62','re63','re64','re65','re66' }

local tw_col = {'name','s','l','slc','beta11','beta22'}
local sv_col = {'name', 'kind', 's', 'l', 'angle', 'x', 'y', 'z', 'theta', 'phi', 'psi', 'globaltilt', 'slc'}

-- Tests ----------------------------------------------------------------------o

TestTwiss = {}

function TestTwiss:setUp ()
  filesys.mkdir(rundir())
  self.optfmt = option.format
  self.nochrg = option.nocharge
  option.format = "%-.10g"
  option.nocharge = true
end

function TestTwiss:tearDown ()
  option.format   = self.optfmt
  option.nocharge = self.nochrg
end

function TestTwiss:testTwissFODO ()
  local k1f = 0.3039540091
  local seq = sequence 'seq' { l=10, refer='entry', -- dir=-1,
    quadrupole 'mq1' { at=0, l=1, k1 :=  k1f },
    quadrupole 'mq2' { at=5, l=1, k1 := -k1f },
  }
!  print("k1f*beam->brho=", k1f*beam.brho) -- 1.013881308
!  seq:dumpseq()
  local X0  = { 1e-3, -1e-4, -1e-3, 1e-4, 0, 0 }
  local mtbl, mflw = twiss {sequence=seq, beam=beam, X0=X0, nslice=10, implicit=true, atslice=ftrue}

  plottw(mtbl, seq)
  mtbl:write(rundir('fodotwiss'), tbl_col, tbl_hdr)
!  local A1 = matrix{{ 1.1332157434651435e-09,3.9295066179412479e+00,  0,0,  0,0},
!                    {-2.5448487470377923e-01,6.0495884810043310e-01,  0,0,  0,0},
!                    { 0,0,  5.2509407932888053e-10, 1.8207987353842947e+00, 0,0},
!                    { 0,0, -5.4920952039084892e-01,-3.5931415510671921e-01, 0,0},
!                    { 0,0,  0,0,  1,2.6111999104627692e-06},
!                    { 0,0,  0,0,  0,1}}

  local A1 = matrix{
    { 1.1332144389530896e-09,  3.9295065791160799e+00,  2.5775946787052681e-04,  4.8855663695518544e-04, 0.0000000000000000e+00, -1.2084296585430578e-08},
    {-2.5448487218936183e-01,  6.0495884212318674e-01,  8.0426372054568346e-06,  9.1907860536268491e-05, 0.0000000000000000e+00, -1.3835712920988444e-09},
    { 1.1622256552874927e-19, -2.5869444925926292e-19,  5.2509385728427560e-10,  1.8207987353842947e+00, 0.0000000000000000e+00,  1.2956541170460780e-09},
    { 1.9903962431533337e-19, -2.2924086051343227e-20, -5.4920952039084836e-01, -3.5931415510671921e-01, 0.0000000000000000e+00,  7.1434004166884475e-10},
    { 2.0952620737609752e-09, -1.5394900178676199e-09, -6.2317637965297676e-10, -1.2487910454498165e-09, 1.0000000000000000e+00,  2.6111999104627692e-06},
    { 0.0000000000000000e+00,  0.0000000000000000e+00,  0.0000000000000000e+00,  0.0000000000000000e+00, 0.0000000000000000e+00,  1.0000000000000000e+00}}

  assertEquals(mflw.__twdat.ofun[1].rank, 4)
mflw[1]:get0():print('E')
MAD.option.format = "%.16e"
mflw[1]:get1():print('R')
  assertAllAlmostEquals( mflw[1]:get0():totable(), 0, cofind.cotol)
  assertAllAlmostEquals((mflw[1]:get1()-A1):totable(true), 0, eps)
end

function TestTwiss:testTwissThinFODO ()
  local nsl = 10 -- 10 -- for madx row by row compatibility
  local nth = 10
  local dl  = 1/nth
  local X0  = { 1e-3, -1e-4, -1e-3, 1e-4, 0, 0 }
  local k1l = 0.3039540091
  local mk1 = marker    'mk1' {}
  local mk2 = marker    'mk2' {}
  local df1 = drift     'df1' { l=4, nslice=nsl }
  local df2 = drift     'df2' { l=4, nslice=nsl }
  local mq1 = multipole 'mq1' { knl := {0,  k1l/nth} }
  local mq2 = multipole 'mq2' { knl := {0, -k1l/nth} }
  local seq = sequence  'seq' { l=10, refer='entry', -- dir=-1,
                mq1 {at=0+dl/2              },
      (nth/2-1)*mq1 {at=dl    , from='prev' },
                mk1 {at=0+dl/2, from='prev' },
                mq1 {at=0+dl/2, from='prev' },
      (nth/2-1)*mq1 {at=dl    , from='prev' },
                df1 {at=1}, -- for madx row by row compatibility

                mq2 {at=5+dl/2              },
      (nth/2-1)*mq2 {at=dl    , from='prev' },
                mk2 {at=0+dl/2, from='prev' },
                mq2 {at=0+dl/2, from='prev' },
      (nth/2-1)*mq2 {at=dl    , from='prev' },
                df2 {at=6}, -- for madx row by row compatibility
  }

  -- seq:dumpseq()

  local mtbl, mflw = twiss{sequence=seq, beam=beam, X0=X0,
                           atslice=ftrue, atexit=ffalse}

  plottw(mtbl, seq)
  mtbl:write(rundir('thinfodotwiss'), tbl_col, tbl_hdr)

  -- TODO: 6D case
  assertEquals(mflw.__twdat.ofun[1].rank, 6)
--  assertEquals(iter, 2)
--  assertEquals(type, "4D")
--  assertAllAlmostEquals(mflw.X[1]:totable(), 0, eps)
end

function TestTwiss:testTwissSimpleRing ()
  local beam, sequence, element, survey, twiss, vector in MAD
  local sbend, quadrupole in element

  local mb = sbend      { l=2, k0 =\s s.angle/s.l, kill_ent_fringe=true, kill_exi_fringe=true }
  local mq = quadrupole { l=1 }
  local k1f, k1d, ang = 0.296004765416, -0.302420662794, 2*pi/50
  local cell =\a -> sequence { l=10, refer='entry',
      mq 'mq1' { at=0, k1=k1f  },
      mb 'mb1' { at=2, angle=a },
      mq 'mq2' { at=5, k1=k1d  },
      mb 'mb2' { at=7, angle=a },
    }
  local seq1 = sequence 'seq1' { 25*cell(ang), beam=beam }
  assertEquals(seq1.l, 250)

  local sv1 = survey { sequence=seq1, mapsave=true, nslice=5, implicit=true, atslice=ftrue }
  sv1:write(rundir('survey_seq1'))--, sv_col, tbl_hdr)

  local X0 = {-1e-3,1e-4,-1e-4,1e-3,0,0}
  local tw1,tw1m = twiss { sequence=seq1, beam=beam, X0=X0, nslice=5, implicit=true, atslice=ftrue } !, chrom=false, deltap=1e-6 }
  tw1:write(rundir('twiss_seq1'))--, tw_col, tbl_hdr)
!  tw1m:show()
!  print("b11=", type(tw1.beta11))

  if doplot then
    local round in MAD.gmath
    local bet11 = { x=vector(#sv1), z=vector(#sv1) }
    local v, scl = vector(3), round(tw1.beta11:max()/5)
    for i=1,#sv1 do
      v:fill {3+tw1.beta11[i]/scl, 0, 0}
      sv1.W[i]:mul(v, v)
      bet11.x[i], bet11.z[i] = v[1], v[3]
    end
    bet11.x = bet11.x+sv1.x
    bet11.z = bet11.z+sv1.z

    plot {
      sequence = seq1,
      laypos   = "in",
      layonly  = false,
      title    = "Layout in plot with \u{03b2}_x",
      data     = { x=bet11.x, z=bet11.z },
      x1y1     = { x = 'z' },
      styles   = 'lines',
    --  prolog   = 'set xrange [] reverse',
      xlabel   = "x [m]",
      ylabel   = "z [m]",
      legend   = { z = '\u{03b2}_x/'..scl },
      fontsize = 14,
    }
  end
end

-- from MAD-X course, src_4.1 and src_5.1
function TestTwiss:testTwissSingleRing ()
  !! import
  local beam, sequence, element, survey, twiss in MAD
  local drift, marker, sbend, quadrupole, sextupole, hkicker, vkicker,
        monitor, bline in element

  !! context (note: Setup sets option.nocharge=true)
  local beam = beam { particle='electron', energy=20 }

  !! constants
  local l , n  = deferred {}, deferred {}
  l.sequ = 240 ! length of the machine
  l.ssec = 20  ! length of the straight sections
  n.ssec = 2   ! number of straight sections
  n.bend = 4   ! number of bends per cell

  !! lengths
  ! lengths of bends, quads, sexts, kickers, monitors
  l.mb=3.3 ; l.mq=0.8 ; l.ms=0.4 ; l.mk=0.25 ; l.bp=0.25
  ! lengths of drifts between magnets and fo-do
  l.de = 0.3 ; l.df = 0.5
  ! length of cells (20m)
  l.cell =\ 2*(l.mb+l.bp+l.mk+l.mq+l.ms+l.mb +4*l.de +l.df)
  ! number of cells per arc
  n.cell =\ 1*(l.sequ/n.ssec - l.ssec)/l.cell
! print('l.cell=', l.cell, 'n.cell=', n.cell)

  !! classes
  local df = drift      'df' {}
  local mb = sbend      'mb' { l := l.mb } !, kill_ent_fringe=true,  kill_exi_fringe=true }
  local mq = quadrupole 'mq' { l := l.mq }
  local ms = sextupole  'ms' { l := l.ms }
  local hk = hkicker    'hk' { l := l.mk }
  local vk = vkicker    'vk' { l := l.mk }
  local bp = monitor    'bp' { l := l.bp }
  local mk = marker     'mk' {}

  !! families
  local k1, k2 = deferred {}, deferred {}
  local qf = mq 'qf' { k1 := k1.qf }
  local qd = mq 'qd' { k1 := k1.qd }
  local sf = ms 'sf' { k2 := k2.sf }
  local sd = ms 'sd' { k2 := k2.sd }
  local d0 = df 'd0' { l  := l.ssec/2 }
  local d1 = df 'd1' { l  := l.df/2 }
  local d2 = df 'd2' { l  := l.de }
  local mkf , mkd     = mk 'mkf' {}, mk 'mkd' {}
  local mkl , mkr, ip = mk 'mkl' {}, mk 'mkr' {}, mk 'ip' {}

  !! lattice
  local cellf = bline    'cellf' {mkf,d1,mb,d2,bp,hk,d2,qf,d2,sf,d2,mb,d1}
  local celld = bline    'celld' {mkd,d1,mb,d2,bp,vk,d2,qd,d2,sd,d2,mb,d1}
  local cell  = bline    'cell'  {cellf,celld}
  local ssec  = bline    'ssec'  {mkl,d0,ip,d0,mkr}
  local arc   = sequence 'arc'   {5*cell}
  local sequ  = sequence 'sequ'  {arc,ssec,arc,ssec}

  !! angle
  n.mb = n.ssec*n.cell*n.bend
  mb.angle =\ 2*pi/n.mb
! print('n.mb=', n.mb, 'mb.angle=', mb.angle)

  !! survey
  local srv = survey { sequence=sequ, nslice=5, implicit=true, atslice=ftrue }
  srv:write(rundir('sr_survey'), srvcol)

  !! plot survey
  if doplot then
    plot {
      sequence = sequ,
      laypos   = "in",
      layonly  = false,
      x1y1     = { x = 'z' },
      styles   = 'lines',
    --  prolog   = 'set xrange [] reverse',
      xlabel   = "x [m]",
      ylabel   = "z [m]",
      fontsize = 14,
    }
    pause()
  end

  !! thick_approx
  local u_cell = pi/2
  local f_cell = l.cell/(4*sin(u_cell/2))
  local k_cell = 1/(f_cell * l.mq)
  k1.qf = k_cell ; k1.qd = -k_cell
! print('qf.k1=', qf.k1, 'qd.k1=', qd.k1)
! print('qf.k1_f=', qf.k1*beam.brho, 'mb.k0_f=', mb.angle*beam.brho/mb.l)

  !! twiss
  local tws, mfw = twiss { sequence=arc, beam=beam, mapsave=true }
! print("#tws=", #tws)
  for i=1,6 do for j=1,6 do
    tws:addcol('re'..i..j, \r -> tws.M[r][i]:get(j+1))
  end end
  tws:write(rundir('sr_track_arc.txt'), twscolre)

! print('q1=', tws.q1[1]) -- =1.391381980, madx=1.279802923
! print('q2=', tws.q2[1]) -- =1.207437789, madx=1.232679934

  local mux = 360*frac(tws.q1[1])/n.cell
  local muy = 360*frac(tws.q2[1])/n.cell
! print('mux=', mux, 'muy=', muy)

--  local tws = twiss { sequence=arc, beam=beam, implicit=true }
--  local mux = 360*frac(tws.q1[1])/n.cell
--  local muy = 360*frac(tws.q2[1])/n.cell
--  print('mux=', mux, 'muy=', muy)
end

-- end ------------------------------------------------------------------------o
