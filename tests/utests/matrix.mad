--[=[
 o-----------------------------------------------------------------------------o
 |
 | Matrix module regression tests
 |
 | Methodical Accelerator Design - Copyright CERN 2015+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: A.Z. Teska, aleksandra.teska at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide regression test suites for the matrix module.

 o-----------------------------------------------------------------------------o
]=]

local assertEquals, assertAlmostEquals, assertTrue, assertFalse,
      assertErrorMsgContains, assertNil, assertNaN, assertIsString, assertInf
      in require 'luaunit'

local vector, cvector, matrix, cmatrix, is_vector, is_matrix, is_cvector,
      is_cmatrix, isa_vector, isa_matrix, linspace, logspace in MAD

local complex, infi, tiny, eps, huge, inf, nan, pi, Pi, randomseed, log,
      is_complex, range, nrange, is_cdata in MAD

-- regression test suite ------------------------------------------------------o

TestMatrix  = {}
TestCMatrix = {}

--local  mat =  matrix(20,20):random()-- *** Error in `./mad': free(): corrupted unsorted chunks: 0x000000000104ae70 ***
--local cmat = cmatrix(10,10):random()

local values = {
  num = { tiny, 2^-64, 2^-63, 2^-53, eps, 2^-52, 2*eps, 2^-32, 2^-31, 1e-9,
          0.1-eps, 0.1, 0.1+eps, 0.5, 0.7-eps, 0.7, 0.7+eps, 1-eps, 1, 1+eps,
          1.1, 1.7, 2, 10, 1e2, 1e3, 1e6, 1e9, 2^31, 2^32, 2^52, 2^53,
          2^63, 2^64, huge },
}

local mth = \f,s,... s[f](s,...)

function TestMatrix:testCtorMatrix()
  local mat, vec = {}, {}
  local msg = {
  "invalid argument #1 or #2 (nrow[,ncol] >=1 or table [of tables] expected)",
  "bad argument #1 to 'malloc' (cannot convert 'nil' to 'uint64_t')" ,
  }
  assertErrorMsgContains( msg[1], matrix, ''   )
  assertErrorMsgContains( msg[1], matrix, nil  )
  assertErrorMsgContains( msg[1], matrix, 0    )
  assertErrorMsgContains( msg[1], matrix, tiny )
  assertErrorMsgContains( msg[1], matrix, eps  )
  assertErrorMsgContains( msg[1], matrix, 1..2 )
  assertErrorMsgContains( msg[1], matrix, infi )
  assertErrorMsgContains( msg[1], matrix, nan  )
  assertErrorMsgContains( msg[1], matrix,-1    )
  assertErrorMsgContains( msg[1], matrix,-tiny )
  assertErrorMsgContains( msg[2], matrix, inf  )
  assertErrorMsgContains( msg[2], matrix, huge )
  for i=1,3 do mat [i] = matrix(  i,  i)
               vec [i] = vector(  i,  i) end

  for i,v in ipairs(vec) do
    assertTrue  ( is_matrix(v) )
    assertTrue  ( is_vector(v) )
    assertEquals( v.nr, i )
    assertEquals( v.nc, 1 )
  end

  for i,m in ipairs(mat) do
    assertTrue  ( is_matrix(m) )
    assertEquals( m.nr, i )
    assertEquals( m.nc, i )
  end
end

function TestMatrix:testCtorCMatrix()
  local cmat, cvec = {}, {}
  local msg = {
  "invalid argument #1 or #2 (nrow[,ncol] >=1 or table [of tables] expected)",
  "bad argument #1 to 'malloc' (cannot convert 'nil' to 'uint64_t')" ,
  }
  assertErrorMsgContains( msg[1], cmatrix, ''   )
  assertErrorMsgContains( msg[1], cmatrix, nil  )
  assertErrorMsgContains( msg[1], cmatrix, 0    )
  assertErrorMsgContains( msg[1], cmatrix, tiny )
  assertErrorMsgContains( msg[1], cmatrix, eps  )
  assertErrorMsgContains( msg[1], cmatrix,-1    )
  assertErrorMsgContains( msg[1], cmatrix,-tiny )
  assertErrorMsgContains( msg[1], cmatrix, 1..2 )
  assertErrorMsgContains( msg[1], cmatrix, infi )
  assertErrorMsgContains( msg[1], cmatrix,-infi )
  assertErrorMsgContains( msg[1], cmatrix, nan  )
  assertErrorMsgContains( msg[1], cmatrix,-inf  )
  assertErrorMsgContains( msg[2], cmatrix, inf  )
  for i=1,3 do cmat [i] = cmatrix(  i,  i)
               cvec [i] = cvector(  i,  i) end

  for i,cv in ipairs(cvec) do
    assertTrue  ( is_cmatrix(cv) )
    assertTrue  ( is_cvector(cv) )
    assertEquals( cv.nr, i )
    assertEquals( cv.nc, 1 )
  end

  for i,cm in ipairs(cmat) do
    assertTrue  ( is_cmatrix(cm) )
    assertEquals( cm.nr, i )
    assertEquals( cm.nc, i )
  end
end

function TestMatrix:testMalloc()
  local m, cm
  --m  =  matrix (16,16)
  --cm = cmatrix (12,12)
end

--indeirect matrix allocations tests

function TestMatrix:testIs_matrix()
  assertTrue ( is_matrix( matrix(2,2)) )
  assertFalse( is_matrix(cmatrix(2,2)) )
  assertTrue ( is_matrix( vector(1)  ) )
  assertFalse( is_matrix(cvector(1)  ) )
end

function TestMatrix:testIs_cmatrix()
  assertFalse( is_cmatrix( matrix(2,2)) )
  assertTrue ( is_cmatrix(cmatrix(2,2)) )
  assertFalse( is_cmatrix( vector(1)  ) )
  assertTrue ( is_cmatrix(cvector(1)  ) )
end

function TestMatrix:testIs_vector()
  assertFalse( is_vector( matrix(2,2)) )
  assertFalse( is_vector(cmatrix(2,2)) )
  assertTrue ( is_vector( vector(1)  ) )
  assertFalse( is_vector(cvector(1)  ) )
end

function TestMatrix:testIs_cvector()
  assertFalse( is_cvector( matrix(2,2)) )
  assertFalse( is_cvector(cmatrix(2,2)) )
  assertFalse( is_cvector( vector(1)  ) )
  assertTrue ( is_cvector(cvector(1)  ) )
end

function TestMatrix:testIsa_vector()
  assertFalse( isa_vector( matrix(2,2)) )
  assertFalse( isa_vector(cmatrix(2,2)) )
  assertTrue ( isa_vector( vector(1)  ) )
  assertTrue ( isa_vector(cvector(1)  ) )
end

function TestMatrix:testIsa_matrix()
  assertTrue ( isa_matrix( matrix(2,2)) )
  assertTrue ( isa_matrix(cmatrix(2,2)) )
  assertTrue ( isa_matrix( vector(1)  ) )
  assertTrue ( isa_matrix(cvector(1)  ) )
end

-- get, set -------------------------------------------------------------------o

local refT =
  {
  { 0.9286338430918031, 0.7981905327208816, 0.2918908989053144, 1 },
  {-0.3540043171200369, 0.8020336034136235, 0.2751589695263197, 1 },
  { 0.4426082303008909, 0.6793722299415492,-0.4718603395451262, 1 },
  { 0.9370700019205285,-0.657495562826343 , 0.9678081932273772, 1 },
  { 0.6563040282125301, 0.7689912808655879, 0.1214582415972276, 1 },
  }
local resM  =  matrix(refT)
local resCM = cmatrix(refT)

local incrM = matrix( { {1,2,3}, {4,5,6}, {7,8,9} } )

function TestMatrix:testGeti0()
  local msg, m = {
    "attempt to compare nil with number",
    }
  assertErrorMsgContains( msg[1], mth, 'geti0', matrix(2,2), nil )

  assertNil   (  matrix(2,2):geti0( inf  )    )
  assertNil   (  matrix(2,2):geti0( nan  )    )
  assertNil   ( cmatrix(2,2):geti0( nan  )    )
  assertNil   (  matrix(2,2):geti0(-1    )    )
  assertEquals(  matrix(2,2):geti0( 0    ), 0 )
  assertNil   (  matrix(2,2):geti0( 0-eps)    )
  assertEquals(  matrix(2,2):geti0( 3    ), 0 )
  assertEquals(  matrix(2,2):geti0( 3+eps), 0 )
  assertNil   (  matrix(2,2):geti0( 4    )    )
  assertNil   (  matrix(2,2):geti0( 4-eps)    )
  assertNil   ( cmatrix(2,2):geti0(-1    )    )
  assertNil   ( cmatrix(2,2):geti0( 4    )    )
  assertEquals( resM :geti0(0.1  ), resM :geti0( 0) )
  assertEquals( resM :geti0(1-eps), resM :geti0( 0) )

  m = matrix(5,5)
  for i = 1,25 do assertEquals( m    :geti0(i-1), 0 ) end
  for i = 1,9  do assertEquals( incrM:geti0(i-1), i ) end

  for j = 1,4 do
  for i = 1,4 do
    assertEquals(  resM:geti0( ((j-1)*4 )+i-1 ), refT[j][i] )
  end end
end

function TestMatrix:testGeti()
local msg, m = {
    "attempt to compare nil with number",
    }
  assertErrorMsgContains( msg[1], mth, 'geti', matrix(2,2), nil )
  assertNil   (  matrix(2,2):geti( inf  )    )
  assertNil   (  matrix(2,2):geti( nan  )    )
  assertNil   ( cmatrix(2,2):geti( nan  )    )
  assertNil   (  matrix(2,2):geti( 0    )    )
  assertEquals(  matrix(2,2):geti( 1    ), 0 )
  assertNil   (  matrix(2,2):geti( 1-eps)    )
  assertEquals(  matrix(2,2):geti( 4    ), 0 )
  assertEquals(  matrix(2,2):geti( 4+eps), 0 )
  assertNil   (  matrix(2,2):geti( 5    )    )
  assertNil   (  matrix(2,2):geti( 5-eps)    )
  assertNil   ( cmatrix(2,2):geti( 0    )    )
  assertNil   ( cmatrix(2,2):geti( 5    )    )
  assertEquals( resM:geti( 1.1 ), resM:geti( 1) )

  m = matrix(5,5)
  for i = 1,25 do assertEquals( m    :geti(i), 0 ) end
  for i = 1,9  do assertEquals( incrM:geti(i), i ) end

  for j = 1,4 do
  for i = 1,4 do
    assertEquals( resM:geti( ((j-1)*4 )+i ),  refT[j][i] )
  end end
end

function TestMatrix:testGet0()
  local msg, m = {
    "attempt to compare nil with number",
    }
  assertErrorMsgContains( msg[1], mth, 'get0', matrix(2,2), 0  , nil )
  assertErrorMsgContains( msg[1], mth, 'get0', matrix(2,2), nil, 0   )

  assertNil   (  matrix(2,2):get0( nan  , 0)    )
  assertNil   ( cmatrix(2,2):get0( nan  , 0)    )
  assertNil   (  matrix(2,2):get0(-1    , 0)    )

  assertEquals(  matrix(2,2):get0( 0    , 0), 0 )
  assertNil   (  matrix(2,2):get0( 0-eps, 0)    )
  assertEquals(  matrix(2,2):get0( 1    , 1), 0 )
  assertEquals(  matrix(2,2):get0( 1+eps, 1), 0 )
  assertNil   (  matrix(2,2):get0( 2    , 2)    )
  assertNil   (  matrix(2,2):get0( 2-eps, 2)    )
  assertNil   ( cmatrix(2,2):get0(-1    , 0)    )
  assertNil   ( cmatrix(2,2):get0( 2    , 0)    )

  m = matrix(5,5)
  for i = 1,5 do  for j = 1,5 do assertEquals( m   :get0(i-1,j-1), 0          ) end end
  for j = 1,4 do  for i = 1,4 do assertEquals( resM:get0(j-1,i-1), refT[j][i] ) end end
end

function TestMatrix:testGet()
  local msg, m = {
    "attempt to compare nil with number",
    }
  assertErrorMsgContains( msg[1], mth, 'get0', matrix(2,2), 1  , nil )
  assertErrorMsgContains( msg[1], mth, 'get0', matrix(2,2), nil, 1   )

  assertNil   (  matrix(2,2):get( nan  , 1)    )
  assertNil   ( cmatrix(2,2):get( nan  , 1)    )
  assertNil   (  matrix(2,2):get(-1    , 0)    )
  assertEquals(  matrix(2,2):get( 1    , 1), 0 )
  assertNil   (  matrix(2,2):get( 1-eps, 1)    )
  assertEquals(  matrix(2,2):get( 2    , 2), 0 )
  assertEquals(  matrix(2,2):get( 2+eps, 2), 0 )
  assertNil   (  matrix(2,2):get( 3    , 3)    )
  assertNil   (  matrix(2,2):get( 3-eps, 3)    )
  assertNil   ( cmatrix(2,2):get( 0    , 0)    )
  assertNil   ( cmatrix(2,2):get( 3    , 0)    )

  m  = matrix(5,5)
  for i = 1,5 do for j = 1,5 do assertEquals( m   :get(i,j), 0          ) end end
  for j = 1,4 do for i = 1,4 do assertEquals( resM:get(j,i), refT[j][i] ) end end
end

function TestMatrix:testSeti0()
  local msg, m = {
    "0-index out of bounds",
    "attempt to compare nil with number",
    }
  assertErrorMsgContains( msg[1], mth, 'seti0', matrix(2,2), nan, 1 )
  assertErrorMsgContains( msg[2], mth, 'seti0', matrix(2,2), nil, 1 )
  assertErrorMsgContains( msg[1], mth, 'seti0', matrix(2,2),-1  , 1 )
  assertErrorMsgContains( msg[1], mth, 'seti0', matrix(2,2),-eps, 1 )
  assertErrorMsgContains( msg[1], mth, 'seti0', matrix(2,2), 5  , 1 )
  assertErrorMsgContains( msg[1], mth, 'seti0', matrix(2,2), 5-eps  , 1 )

  m = matrix(4,4)
  for j = 1,4 do
  for i = 1,4 do
    m:seti0( ((j-1)*4 )+i-1, refT[j][i] )
    assertEquals( m:geti0( ((j-1)*4 )+i-1 ), refT[j][i] )
  end end

  m = matrix(5,5)
  for i = 1,25 do
    m:seti0( i-1, i )
    assertEquals( m:geti0(i-1), i )
  end
end

function TestMatrix:testSeti()
  local msg, m = {
    "1-index out of bounds",
    "attempt to compare nil with number",
    }
  assertErrorMsgContains( msg[1], mth, 'seti', matrix(2,2), 0   , 1 )
  assertErrorMsgContains( msg[1], mth, 'seti', matrix(2,2), 0.1 , 1 )
  assertErrorMsgContains( msg[1], mth, 'seti', matrix(2,2),-1   , 1 )
  assertErrorMsgContains( msg[1], mth, 'seti', matrix(2,2), inf , 1 )
  assertErrorMsgContains( msg[1], mth, 'seti', matrix(2,2), nan , 1 )
  assertErrorMsgContains( msg[2], mth, 'seti', matrix(2,2), nil , 1 )

  m = matrix(4,4)
  for j = 1,4 do
  for i = 1,4 do
    m:seti( ((j-1)*4 )+i, refT[j][i] )
    assertEquals( m:geti( ((j-1)*4 )+i ), refT[j][i] )
  end end

  m = matrix(5,5)
  for i = 1,25 do
    m:seti( i, i )
    assertEquals( m:geti(i), i )
  end
end

function TestMatrix:testSet0()
  local msg, m = {
    "0-index out of bounds",
    "attempt to compare nil with number",
    }
  assertErrorMsgContains( msg[1], mth, 'set0', matrix(2,2), nan , 1, 1 )
  assertErrorMsgContains( msg[2], mth, 'set0', matrix(2,2), nil , 1, 1 )
  assertErrorMsgContains( msg[1], mth, 'set0', matrix(2,2),-1   , 1, 1 )
  assertErrorMsgContains( msg[1], mth, 'set0', matrix(2,2), 3   , 1, 1 )

  m = matrix(4,4)
  for j = 1,4 do
  for i = 1,4 do
    m:set0( i-1, j-1, refT[j][i] )
    assertEquals( m:get0(i-1,j-1), refT[j][i] )
  end end

  m = matrix(5,5)
  for i = 1,5 do
  for j = 1,5 do
    m:set0( i-1, j-1, i+j )
    assertEquals( m:get0(i-1,j-1), i+j )
  end end
end

function TestMatrix:testSet()
  local msg, m = {
    "1-index out of bounds",
    "attempt to compare nil with number",
    }
  assertErrorMsgContains( msg[1], mth, 'set', matrix(2,2), 0   , 1, 1 )
  assertErrorMsgContains( msg[1], mth, 'set', matrix(2,2), 0.1 , 1, 1 )
  assertErrorMsgContains( msg[1], mth, 'set', matrix(2,2),-1   , 1, 1 )
  assertErrorMsgContains( msg[1], mth, 'set', matrix(2,2), inf , 1, 1 )
  assertErrorMsgContains( msg[1], mth, 'set', matrix(2,2), nan , 1, 1 )
  assertErrorMsgContains( msg[2], mth, 'set', matrix(2,2), nil , 1, 1 )

  m = matrix(4,4)
  for j = 1,4 do
  for i = 1,4 do
    m:set( i, j, refT[j][i] )
    assertEquals( m:get(i,j), refT[j][i] )
  end end

  m = matrix(5,5)
  for i = 1,5 do
  for j = 1,5 do
    m:set( i, j, i+j )
    assertEquals( m:get(i,j), i+j )
  end end

end

-- both linspance and logspace need normal values check, closer look to special cases
function TestMatrix:testLinspace()
  local msg, l, r = {
    "attempt to perform arithmetic on local 'start'",
    "attempt to perform arithmetic on local 'stop' ",
    "invalid argument #3 (size expected)"           ,
    "bad argument #1 to 'malloc' (cannot convert 'nil' to 'uint64_t')",
  }
  assertErrorMsgContains( msg[1], linspace, nil, 1   )
  assertErrorMsgContains( msg[1], linspace, '' , 1   )
  assertErrorMsgContains( msg[2], linspace, 1  , nil )
  assertErrorMsgContains( msg[2], linspace, 1  , ''  )

  assertErrorMsgContains( msg[3], linspace, 2  , 2  , 0   )
  assertErrorMsgContains( msg[3], linspace, 2  , 2  ,-1   )
  assertErrorMsgContains( msg[3], linspace, 2  , 2  , nan )
  assertErrorMsgContains( msg[3], linspace, 2  , 2  ,-inf )
  assertErrorMsgContains( msg[4], linspace, 2  , 2  , inf )
  assertErrorMsgContains( msg[3], linspace, 2  , 2  , ''  )

  assertTrue  ( is_cdata (linspace(1,1)) )
  assertTrue  ( is_vector(linspace(1,1)) )
  assertEquals( #linspace( 2, 2, nil)     , 100 )
  assertEquals(  linspace( 2, 2, nil)[1]  , 2   )
  assertEquals(  linspace( 2, 2, nil)[100], 2   )

  l = linspace( 2  ,-inf)  for i = 2, #l do assertInf( l[i] ) end assertNaN( l[1] )
  l = linspace( 2  , inf)  for i = 2, #l do assertInf( l[i] ) end assertNaN( l[1] )
  l = linspace( inf, 2  )  for i = 1, #l do assertNaN( l[i] ) end
  l = linspace(-inf, 2  )  for i = 1, #l do assertNaN( l[i] ) end
  l = linspace( 2  , nan)  for i = 1, #l do assertNaN( l[i] ) end
  l = linspace( nan, 2  )  for i = 1, #l do assertNaN( l[i] ) end

  local nrng = {
          { 1  , 100, 100}, { 1, 100, 10 }   , { 100, 1 , 10 }, { 1,-100, 10 },
          { 100,-1  , 10 }, {-1, 100, 10 }   , {-100, 1 , 10 }, {-1,-100, 10 },
          {-100,-1  , 10 }, -- { 1, 0  , 1/eps }, { 0.5, 1 , 1/eps }, replace with uint64 biggest
          }

  for _,v in ipairs(nrng) do
    nr = nrange  ( v[1], v[2], v[3] )
    l  = linspace( v[1], v[2], v[3] )
    for i=1,#nr do
      assertEquals( l[i] - nr[i], 0 )
    end
  end

  local r, s
  for _,v in ipairs(values.num) do
    r = range( 1, 100, v )
    s = r:size()
    if s < 20 then
      l = linspace( 1, 100, s)
      for i=1,#r do
        --assertEquals( l[i] - r[i], 0 )
        --print( l[i] - r[i] )
      end
    end
  end

end

function TestMatrix:testLogspace()
  local msg, l = {
    "attempt to index local 'x' "        ,
    "attempt to call method 'log' "      ,
    "invalid argument #3 (size expected)",
    "invalid argument #1 or #2 (nrow[,ncol] >=1 or table [of tables] expected)",
    "bad argument #1 to 'malloc' (cannot convert 'nil' to 'uint64_t')"         ,
    }
  assertErrorMsgContains( msg[1], logspace, nil, 1   )
  assertErrorMsgContains( msg[2], logspace, '' , 1   )
  assertErrorMsgContains( msg[1], logspace, 1  , nil )
  assertErrorMsgContains( msg[2], logspace, 1  , ''  )

  assertErrorMsgContains( msg[4], logspace, 2  ,2   , eps)
  assertErrorMsgContains( msg[3], logspace, 2  ,2   ,-1  )
  assertErrorMsgContains( msg[3], logspace, 2  ,2   , 0  )
  assertErrorMsgContains( msg[3], logspace, 2  ,2   , nan)
  assertErrorMsgContains( msg[3], logspace, 2  ,2   ,-inf)
  assertErrorMsgContains( msg[5], logspace, 2  ,2   , inf)

  assertEquals( #logspace( 2, 2, nil)     , 100 )
  assertEquals(  logspace( 2, 2, nil)[1]  , 2   )
  assertEquals(  logspace( 2, 2, nil)[100], 2   )

  l = logspace( 2  ,-inf)  for i = 1, #l do assertNaN( l[i] ) end
  l = logspace( 2  , inf)  for i = 2, #l do assertInf( l[i] ) end assertNaN( l[1] )
  l = logspace( inf, 2  )  for i = 1, #l do assertNaN( l[i] ) end
  l = logspace(-inf, 2  )  for i = 1, #l do assertNaN( l[i] ) end
  l = logspace( 2  , nan)  for i = 1, #l do assertNaN( l[i] ) end
  l = logspace( nan, 2  )  for i = 1, #l do assertNaN( l[i] ) end

end

function TestMatrix:testSame()
  local m, cm =  matrix(3,3):random(), cmatrix(3,3):random()
  local msg, s = {
    "invalid argument #2 (scalar expected)",
    "invalid argument #1 or #2 (nrow[,ncol] >=1 or table [of tables] expected)",
    }
  assertErrorMsgContains( msg[1], mth, 'same', matrix(2,2), ''      )
  assertErrorMsgContains( msg[1], mth, 'same', matrix(2,2), {}      )
  assertErrorMsgContains( msg[1], mth, 'same', matrix(2,2), 1..2    )
  assertErrorMsgContains( msg[2], mth, 'same', matrix(2,2), 1, ''   )
  assertErrorMsgContains( msg[2], mth, 'same', matrix(2,2), 1, {}   )
  assertErrorMsgContains( msg[2], mth, 'same', matrix(2,2), 1, 1..2 )
  assertErrorMsgContains( msg[2], mth, 'same', matrix(2,2), 1, nan  )

  s = m:same( nan)  assertEquals( s:get(1,1), 0 )
  s = m:same( inf)  assertEquals( s:get(1,1), 0 )
  s = m:same( 0  )  assertEquals( s:get(1,1), 0 )

  -- no input
  for i = 1,3 do for j = 1,3 do  assertEquals( s:get(i,j), 0 ) end end
  s = cm:same( )   assertFalse( is_matrix(s) ) assertTrue ( is_cmatrix(s) ) assertEquals( {s.nr,s.nc}, {m.nr, m.nc} )
  s =  m:same( )   assertTrue ( is_matrix(s) ) assertFalse( is_cmatrix(s) ) assertEquals( {s.nr,s.nc}, {m.nr, m.nc} )

  -- one arg: e_
  s =  m:same(complex(1,1)) assertFalse( is_matrix(s) ) assertTrue ( is_cmatrix(s) ) assertEquals( {s.nr,s.nc}, {m.nr,m.nc} )
  s = cm:same(1)            assertTrue ( is_matrix(s) ) assertFalse( is_cmatrix(s) ) assertEquals( {s.nr,s.nc}, {m.nr,m.nc} )
  for i = 1,3 do for j = 1,3 do  assertEquals( s:get(i,j), 0 ) end end

  -- two arg: nr, nc
  s = cm:same(2,2) assertFalse( is_matrix(s) ) assertTrue ( is_cmatrix(s) ) assertEquals( {s.nr,s.nc}, {2,2} )
  s = cm:same(4,4) assertFalse( is_matrix(s) ) assertTrue ( is_cmatrix(s) ) assertEquals( {s.nr,s.nc}, {4,4} )
  s =  m:same(2,2) assertTrue ( is_matrix(s) ) assertFalse( is_cmatrix(s) ) assertEquals( {s.nr,s.nc}, {2,2} )
  s =  m:same(4,4) assertTrue ( is_matrix(s) ) assertFalse( is_cmatrix(s) ) assertEquals( {s.nr,s.nc}, {4,4} )
  for i = 1,4 do for j = 1,4 do  assertEquals( s:get(i,j), 0 ) end end

  -- three arg: e_, nr, nc
  s = m:same(complex(1,1), 2, 2) assertFalse( is_matrix(s) ) assertTrue ( is_cmatrix(s) ) assertEquals( {s.nr,s.nc}, {2,2} )
  s = m:same(complex(1,1), 5, 5) assertFalse( is_matrix(s) ) assertTrue ( is_cmatrix(s) ) assertEquals( {s.nr,s.nc}, {5,5} )
  s = cm:same(1, 2, 2)           assertTrue ( is_matrix(s) ) assertFalse( is_cmatrix(s) ) assertEquals( {s.nr,s.nc}, {2,2} )
  s = cm:same(1, 5, 5)           assertTrue ( is_matrix(s) ) assertFalse( is_cmatrix(s) ) assertEquals( {s.nr,s.nc}, {5,5} )
  for i = 1,5 do for j = 1,5 do  assertEquals( s:get(i,j), 0 ) end end

end

function TestMatrix:testGetsub()
  local msg, m = {
    "invalid argument #2 (iterable expected)", --is_iterable(ir) --has iparis or number ir -> iterable: number or range or table
    "invalid argument #3 (iterable expected)", --is_iterable(jc) --has iparis or number jr -> iterable: number or range or table
    "invalid argument #4 (iterable expected)", --is_iterable(r ) --has iparis           r_ -> scalar or iterable:
    "invalid range member '1'",
    }
  assertErrorMsgContains( msg[1], mth, 'getsub', matrix(2,2), ''  , 0   , 1  )
  assertErrorMsgContains( msg[3], mth, 'getsub', matrix(2,2), 0   , 0   , 1  )
  assertErrorMsgContains( msg[4], mth, 'getsub', matrix(2,2), 1..2, 1..2, 1..4 )

  m = matrix(2,2)
  --print( matrix(3,3):getsub(1..2, 1..2, m) )
  --print( "\n" )
  --print( matrix(3,3):getsub(linspace(1,2,2), 1..2, m) )

  --print( matrix(3,3):getsub(1..2, 1..2, {}     ) )
  --print( matrix(3,3):getsub(1..2, 1..2, {{}}   ) )
  --print( matrix(3,3):getsub(1..2, 1..2, {1i}   ) )
  --print( matrix(3,3):getsub(1..2, 1..2, {false}) )
  --print( matrix(3,3):getsub(1..2, 1..2, {''}   ) )
end

-- size, same -----------------------------------------------------------------o

local subM, subCM = {}, {}
for j=1,10 do subM [j] =  matrix(10,10):random():getsub(1..10, 1..j)
              subCM[j] = cmatrix(10,10):random():getsub(1..10, 1..j)
end

local  mat,  vec = {}, {}
for j=1,10 do mat [j] =  matrix(j,j) end
for j=1,10 do vec [j] =  vector(j)   end

function TestMatrix:testNrow()
  assertEquals(  matrix(1   ):nrow(), 1 )
  assertEquals( cmatrix(1   ):nrow(), 1 )

  for i, m in ipairs(mat  ) do  assertEquals(  m:nrow(), i  ) end
  for i, v in ipairs(vec  ) do  assertEquals(  v:nrow(), i  ) end
  for i, m in ipairs(subM ) do  assertEquals(  m:nrow(), 10 ) end
  for i,cm in ipairs(subCM) do  assertEquals( cm:nrow(), 10 ) end
end

function TestMatrix:testNcol()
  assertEquals(  matrix(1   ):ncol(), 1 )
  assertEquals( cmatrix(1   ):ncol(), 1 )

  for i, m in ipairs(mat  ) do assertEquals(  m:ncol(), i ) end
  for i, v in ipairs(vec  ) do assertEquals(  v:ncol(), 1 ) end
  for i, m in ipairs(subM ) do assertEquals(  m:ncol(), i ) end
  for i,cm in ipairs(subCM) do assertEquals( cm:ncol(), i ) end
end

function TestMatrix:testSize()
  assertEquals(  matrix(1   ):size(), 1^2 )
  assertEquals( cmatrix(1   ):size(), 1^2 )
  assertEquals(  matrix(2   ):size(), 2^2 )

  for i, m in ipairs(mat  ) do assertEquals(  m:size(), i *i ) end
  for i, v in ipairs(vec  ) do assertEquals(  v:size(), i *1 ) end
  for i, m in ipairs(subM ) do assertEquals(  m:size(), 10*i ) end
  for i,cm in ipairs(subCM) do assertEquals( cm:size(), 10*i ) end
end

function TestMatrix:testSizes()
  assertEquals( { matrix(1   ):sizes()}, {1,1} )
  assertEquals( {cmatrix(1   ):sizes()}, {1,1} )
  assertEquals( { matrix(2   ):sizes()}, {2,2} )

  for i, m in ipairs(mat  ) do assertEquals( {  m:sizes() }, {i ,i} ) end
  for i, v in ipairs(vec  ) do assertEquals( {  v:sizes() }, {i ,1} ) end
  for i, m in ipairs(subM ) do assertEquals( {  m:sizes() }, {10,i} ) end
  for i,cm in ipairs(subCM) do assertEquals( { cm:sizes() }, {10,i} ) end
end

function TestMatrix:testTsizes()
  assertEquals( { matrix(1   ,2):tsizes()}, {2,1} )
  assertEquals( {cmatrix(1   ,2):tsizes()}, {2,1} )

  for i, m in ipairs(mat  ) do assertEquals( {  m:tsizes() }, {i ,i} ) end
  for i, v in ipairs(vec  ) do assertEquals( {  v:tsizes() }, {1 ,i} ) end
  for i, m in ipairs(subM ) do assertEquals( {  m:tsizes() }, {i,10} ) end
  for i,cm in ipairs(subCM) do assertEquals( { cm:tsizes() }, {i,10} ) end
end

function TestMatrix:testRandom() -- uses seti0, size
  local m1, m2 = matrix(2,2)
  local msg = {
    "invalid argument #2 (callable expected)",
    }
  assertErrorMsgContains( msg[1], mth,'random', m1, nan )
  assertErrorMsgContains( msg[1], mth,'random', m1, 100 )

  randomseed(os.clock()*2^52)
  local oldVal, val = {},{}
  for i=1,2 do
    m1 = matrix(2,2):random()
    for i = 1,m1:size() do
      val[i] = m1:geti(i)
      assertTrue( val[i] <  1    )
      assertTrue( val[i] >= 0    )
      assertTrue( val[i] <= 2^52 )
      assertFalse( val[i] == oldVal[i] )
      oldVal[i] = val[i]
    end
  end
end

function TestMatrix:testFill() --uses: sizes, set, get
  local msg = {
    "invalid argument #2 (scalar, callable or indexable expected)",
    }
end

--[[
function TestMatrix:testCopy()
  local msg = {
    "invalid argument #1 (matrix with compatible size expected"),}
end

function TestCMatrix:testCopy()
  local msg = {
    "invalid argument #1 (matrix with compatible size expected"),}
end

function TestMatrix:testZeros() end
function TestCMatrix:testZeros() end

function TestMatrix:testOnes() end
function TestMatrix:testEye() end

function TestMatrix:testSymp()
  local msg = {
    "invalid argument #1 (2n matrix expected)",}
end
function TestMatrix:testCirc()
  local msg = {
    "invalid argument #2 (iterable expected)",}
end

function TestMatrix:testVshape() end
function TestMatrix:testReshape()
  local msg = {
    "invalid matrix new sizes",
    }
end
-- conversion -----------------------------------------------------------------o

function TestMatrix:testTosting() end
function TestMatrix:testTotable() end

-- getx, setx -----------------------------------------------------------------o

function TestMatrix:testGetv() end
function TestMatrix:testSetv() end
function TestMatrix:testGetdiag() end
function TestMatrix:testSetdiag() end

function TestMatrix:testGetrow() end
function TestMatrix:testSetrow() end

function TestMatrix:testGetcol() end
function TestMatrix:testSetcol() end

function TestMatrix:testGetsub() end
function TestMatrix:testSetsub() end

-- foreach, filter, map, fold, scan -------------------------------------------o

function TestMatrix:testForeach() end
function TestMatrix:testFilter() end
function TestMatrix:testMapat() end
function TestMatrix:testMap() end
function TestMatrix:testMap2() end
function TestMatrix:testMap3() end

function TestMatrix:testFoldl() end
function TestMatrix:testFoldr() end

function TestMatrix:testScanl() end
function TestMatrix:testScanr() end

-- special maps ---------------------------------------------------------------o

function TestMatrix:testCeil () end
function TestMatrix:testFloor() end
function TestMatrix:testFrac () end
function TestMatrix:testTrunc() end
function TestMatrix:testRound() end

function TestMatrix:testAbs  () end
function TestMatrix:testSqrt () end
function TestMatrix:testExp  () end
function TestMatrix:testLog  () end
function TestMatrix:testLog10() end

function TestMatrix:testSin () end
function TestMatrix:testCos () end
function TestMatrix:testTan () end
function TestMatrix:testSinh() end
function TestMatrix:testCosh() end
function TestMatrix:testTanh() end

function TestMatrix:testAsin () end
function TestMatrix:testAcos () end
function TestMatrix:testAtan () end
function TestMatrix:testAsinh() end
function TestMatrix:testAcosh() end
function TestMatrix:testAtanh() end

function TestMatrix:testErf   () end
function TestMatrix:testTgamma() end
function TestMatrix:testLgamma() end

function TestMatrix:testCarg () end
function TestMatrix:testReal () end
function TestMatrix:testImag () end
function TestMatrix:testConj () end
function TestMatrix:testProj () end
function TestMatrix:testRect () end
function TestMatrix:testPolar() end

-- special folds --------------------------------------------------------------o

function TestMatrix:testMin() end
function TestMatrix:testMax() end
function TestMatrix:testSum() end
function TestMatrix:testSumabs() end
function TestMatrix:testSumsqr() end
function TestMatrix:testProduct() end
function TestMatrix:testAll() end
function TestMatrix:testAny() end

-- conjugate, transpose -------------------------------------------------------o

function TestMatrix:testTranspose() end
function TestCMatrix:testTranspose() end

function TestMatrix:testTrace() end

-- symplectic matrix ----------------------------------------------------------o

function TestMatrix:testSympinv() end
function TestCMatrix:testSympinv() end

function TestMatrix:testSymperr() end
function TestCMatrix:testSymperr() end

-- inner, cross, mixed, outer -------------------------------------------------o

function TestMatrix:testInner() end
function TestCMatrix:testInner() end

function TestMatrix:testCross() end
function TestMatrix:testMixed() end
function TestMatrix:testOuter() end

-- norm, unit, center, angle (in place) ---------------------------------------o

function TestMatrix:testNorm() end
function TestCMatrix:testNorm() end

function TestMatrix:testDistance() end
function TestCMatrix:testDistance() end

function TestMatrix:testUnit() end
function TestCMatrix:testUnit() end

function TestMatrix:testCenter() end
function TestCMatrix:testCenter() end

function TestMatrix:testAngle() end

-- operators ------------------------------------------------------------------o

function TestMatrix:testEq() end

function TestMatrix:testAddCPx() end
function TestMatrix:testAdd() end
function TestCMatrix:testAddCPx() end
function TestCMatrix:testAdd() end

function TestMatrix:testSubCPx() end
function TestMatrix:testSub() end
function TestCMatrix:testSubCPx() end
function TestCMatrix:testSub() end

function TestMatrix:testMulCPx() end
function TestMatrix:testMul() end
function TestCMatrix:testMulCPx() end
function TestCMatrix:testMul() end

function TestMatrix:testTmul() end
function TestCMatrix:testTmul() end

function TestMatrix:testDivCPx() end
function TestMatrix:testDiv() end
function TestCMatrix:testDivCPx() end
function TestCMatrix:testDiv() end

function TestMatrix:testEmul() end
function TestCMatrix:testEmul() end
function TestMatrix:testEdiv() end
function TestCMatrix:testEdiv() end

-- linear algebra -------------------------------------------------------------o

function TestMatrix:testSolve() end
function TestMatrix:testSvd() end
function TestCMatrix:testSvd() end

function TestMatrix:testEigen() end
function TestCMatrix:testEigen() end

-- FFT, convolution, correlation, covrariance ---------------------------------o

function TestMatrix:testFft() end
function TestMatrix:testIfft() end
function TestMatrix:testRfft() end
function TestMatrix:testIrfft() end

 -- convolution theorem
function TestMatrix:testConv() end
function TestCMatrix:testConv() end

 -- correlation theorem
function TestMatrix:testCorr() end
function TestCMatrix:testCorr() end
function TestMatrix:testCovar() end

-- concatenation --------------------------------------------------------------o

function TestMatrix:testConcat() end
]]

-- end ------------------------------------------------------------------------o
