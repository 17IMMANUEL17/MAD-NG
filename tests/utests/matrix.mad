--[=[
 o-----------------------------------------------------------------------------o
 |
 | Matrix module regression tests - real matrices
 |
 | Methodical Accelerator Design - Copyright CERN 2015+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: A.Z. Teska, aleksandra.teska at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide regression test suites for the matrix module.

 o-----------------------------------------------------------------------------o
]=]

local assertEquals, assertAlmostEquals, assertInf, assertFalse, assertNotEquals,
      assertErrorMsgContains, assertNil, assertNaN, assertIsString, assertTrue
      in require 'luaunit'

local vector, cvector, matrix, cmatrix, is_vector, is_matrix, is_cvector,
      is_cmatrix, isa_vector, isa_matrix, linspace, logspace in MAD

local complex, range, nrange, nlogrange,infi, tiny, eps, huge, inf, nan, pi, Pi,
      randomseed, abs, log, min, totable, is_complex, is_cdata, is_table,
      is_nil, is_string in MAD

-- locals ---------------------------------------------------------------------o

local mth = \f,s,... s[f](s,...)

local values = {
  num = { tiny, 2^-64, 2^-63, 2^-53, eps, 2^-52, 2*eps, 2^-32, 2^-31, 1e-9,
          0.1-eps, 0.1, 0.1+eps, 0.5, 0.7-eps, 0.7, 0.7+eps, 1-eps, 1, 1+eps,
          1.1, 1.7, 2, 10, 1e2, 1e3, 1e6, 1e9, 2^31, 2^32, 2^52, 2^53,
          2^63, 2^64, huge },
}

local errMat = matrix(2)

local g = {}
g.mat   = {}
g.size  = {}
g.empty = {}
for nr=1,5 do
  for nc=1,5 do
    g.mat  [(nr-1)*5+nc] = matrix(nr,nc):fill(1..nr*nc)
    g.empty[(nr-1)*5+nc] = matrix(nr,nc)
    g.size [(nr-1)*5+nc] = {nr,nc}
  end
end

-- regression test suites -----------------------------------------------------o

TestMatrix    = {}
TestMatrixErr = {}

TestMatrixGet = {}
TestMatrixSet = {}

TestMatrixInPlace = {}
TestMatrixFun     = {}

TestMatrixSMaps  = {}
TestMatrixSFolds = {}
TestMatrixSScans = {}

TestMatrixSympl  = {}
TestMatrixLinAlg = {}
TestMatrixOps    = {}
TestMatrixLapack = {}
TestMatrixFFT    = {}
TestMatrixConv   = {}

function TestMatrixErr:testCtor()
    local msg = {
  "invalid argument #1 or #2 (nrow[,ncol] >=1 or table [of tables] expected)",
   "matrix too large",
  }
  assertErrorMsgContains( msg[1], matrix, ''     )
  assertErrorMsgContains( msg[1], matrix, nil    )
  assertErrorMsgContains( msg[1], matrix, 0      )
  assertErrorMsgContains( msg[1], matrix, tiny   )
  assertErrorMsgContains( msg[1], matrix, eps    )
  assertErrorMsgContains( msg[1], matrix, 1..2   )
  assertErrorMsgContains( msg[1], matrix, infi   )
  assertErrorMsgContains( msg[1], matrix, nan    )
  assertErrorMsgContains( msg[1], matrix,-1      )
  assertErrorMsgContains( msg[1], matrix,-eps    )
  assertErrorMsgContains( msg[2], matrix, inf    )
  assertErrorMsgContains( msg[2], matrix, huge   )
  assertErrorMsgContains( msg[2], matrix, 2^15+1 )
  assertErrorMsgContains( msg[2], vector, 2^30+1 )
end

function TestMatrix:testCtor()
  local nr, nc
  assertTrue( is_matrix( vector(2^30)) )
  assertTrue( is_matrix( matrix(2^15)) )
  for i,m in ipairs(g.mat) do
    nr, nc = m:sizes()
    assertTrue  ( is_matrix(m) )
    if nc==1 then
      assertTrue  ( is_vector(m) )
      assertEquals( nc, 1 )
    else
    assertEquals( nr, g.size[i][1] )
    assertEquals( nc, g.size[i][2] )
    end
  end
end

function TestMatrixErr:testCtorFromtable()
  local msg = {
  "invalid argument #1 (non-empty table expected)",
  "cannot convert 'string' to 'double'"           ,
  "cannot convert 'string' to 'complex'"          ,
  }
  assertErrorMsgContains( msg[1],  matrix, {nil} )
  assertErrorMsgContains( msg[2],  matrix, {''}  )
end

function TestMatrix:testCtorFromtable() --TODO
  assertTrue  ( is_matrix ( matrix{2}      ) )
  assertTrue  ( is_vector ( matrix{2}      ) )

  assertTrue  ( is_matrix ( matrix{complex(0,0)} ) )
  assertFalse ( is_cmatrix( matrix{complex(0,0)} ) )
  assertEquals( matrix{complex(0,0)},  matrix(1) ) -- complex/real matrix
  --assertNotEquals( matrix{complex(0,0)}, cmatrix(1) )
  --print( matrix{complex(0,0)}== matrix(1) )
  --print( matrix{complex(0,0)}==cmatrix(1) )
  --print( matrix(1)==cmatrix(1) )
end

function TestMatrix:testCdataType()
  local m, v = matrix(2), vector(2)
  assertTrue ( is_matrix ( m ) )
  assertTrue ( is_matrix ( v ) )
  assertFalse( is_vector ( m ) )
  assertTrue ( is_vector ( v ) )
  assertFalse( is_cmatrix( m ) )
  assertFalse( is_cmatrix( v ) )
  assertFalse( is_cvector( m ) )
  assertFalse( is_cvector( v ) )
  assertFalse( isa_vector( m ) )
  assertTrue ( isa_vector( v ) )
  assertTrue ( isa_matrix( m ) )
  assertTrue ( isa_matrix( v ) )
end

function TestMatrixErr:testLinspace()
  local msg = {
    "invalid argument #1 (finite scalar expected)"  ,
    "invalid argument #2 (finite scalar expected)"  ,
    "invalid argument #3 (positive number expected)",
    "bad argument #1 to 'ceil'"                     ,
    "matrix too large"                              ,
  }
  assertErrorMsgContains( msg[1], linspace, nil       )
  assertErrorMsgContains( msg[1], linspace, nil, 2    )
  assertErrorMsgContains( msg[1], linspace, '' , 2    )
  assertErrorMsgContains( msg[1], linspace, nan, 2    )
  assertErrorMsgContains( msg[1], linspace, inf, 2    )
  assertErrorMsgContains( msg[1], linspace,-inf, 2    )
  assertErrorMsgContains( msg[2], linspace, 2  , ''   )
  assertErrorMsgContains( msg[2], linspace, 2  , 1..2 )
  assertErrorMsgContains( msg[2], linspace, 2  , nan  )
  assertErrorMsgContains( msg[2], linspace, 2  , inf  )
  assertErrorMsgContains( msg[2], linspace, 2  ,-inf  )
  assertErrorMsgContains( msg[2], linspace, 2  , 1..2 )
  assertErrorMsgContains( msg[3], linspace, 2  , 2  , 0    )
  assertErrorMsgContains( msg[3], linspace, 2  , 2  ,-1    )
  assertErrorMsgContains( msg[3], linspace, 2  , 2  , nan  )
  assertErrorMsgContains( msg[5], linspace, 2  , 2  , inf  )
  assertErrorMsgContains( msg[3], linspace, 2  , 2  ,-inf  )
  assertErrorMsgContains( msg[4], linspace, 2  , 2  , ''   )
  assertErrorMsgContains( msg[4], linspace, 2  , 2  , 1..2 )
end

function TestMatrix:testLinspace()
  local nrng, l, nr = {
        { 1 , 10, 100}, { 1, 10, 100}, { 10, 1 , 10}, { 1,-10, 10},
        { 10,-1 , 100}, {-1, 10, 100}, {-10, 1 , 10}, {-1,-10, 10},
        {-10,-1 , 100},
        }
  assertTrue  (  is_vector (linspace(1,1))          )
  assertTrue  (  is_cvector(linspace(complex(1,1))) )
  assertEquals(  linspace( 1 )           [1]  , 0   )
  assertEquals(  linspace( 1 )           [100], 1   )
  assertEquals(  linspace( 2, 2, nil)    [1]  , 2   )
  assertEquals(  linspace( 2, 2, nil)    [100], 2   )
  assertEquals( #linspace( 2, 2, nil)         , 100 )
  assertEquals(  linspace( complex(1,1) )[100], complex(1,1) )
  assertEquals(  linspace( complex(1,1) )[1]  , complex(0,0) )
  nr = nrange  ( 0.5, 1 , 1000 )
  l  = linspace( 0.5, 1 , 1000 )
  assertEquals ( l[1]   , nr[1]    )
  assertEquals ( l[1000], nr[1000] )

  for _,v in ipairs(nrng) do
    nr = nrange  ( v[1], v[2], v[3] )
    l  = linspace( v[1], v[2], v[3] )
    for i=1,#nr do
      assertEquals( l[i] - nr[i], 0 )
    end
    nr = nrange  ( v[1], v[2], v[3] )
    l  = linspace( complex(v[1],v[1]), complex(v[2],v[2]), v[3] )
    for i=1,#nr do
      assertAlmostEquals( l[i].re - complex(nr[i],nr[i]).re , 0, eps )
      assertAlmostEquals( l[i].im - complex(nr[i],nr[i]).im , 0, eps )
    end
  end
end

function TestMatrixErr:testLogspace()
  local msg = {
    "invalid argument #1 (positive finite number expected)",
    "invalid argument #2 (positive finite number expected)",
    "invalid argument #3 (positive number expected)"       ,
    "bad argument #1 to 'ceil'"                            ,
  }
  assertErrorMsgContains( msg[1], logspace, 0          )
  assertErrorMsgContains( msg[1], logspace, nil        )
  assertErrorMsgContains( msg[1], logspace, nil , 1    )
  assertErrorMsgContains( msg[1], logspace, ''  , 1    )
  assertErrorMsgContains( msg[1], logspace, 1..2, 2    )
  assertErrorMsgContains( msg[1], logspace, nan , 2    )
  assertErrorMsgContains( msg[1], logspace, inf , 2    )
  assertErrorMsgContains( msg[1], logspace,-inf , 2    )
  assertErrorMsgContains( msg[2], logspace, 1   , ''   )
  assertErrorMsgContains( msg[2], logspace, 2   , 1..2 )
  assertErrorMsgContains( msg[2], logspace, 2   , nan  )
  assertErrorMsgContains( msg[2], logspace, 2   , inf  )
  assertErrorMsgContains( msg[2], logspace, 2   ,-inf  )
  assertErrorMsgContains( msg[3], logspace, 2   , 2  ,-1    )
  assertErrorMsgContains( msg[3], logspace, 2   , 2  , 0    )
  assertErrorMsgContains( msg[3], logspace, 2   , 2  , nan  )
  assertErrorMsgContains( msg[3], logspace, 2   , 2  ,-inf  )
  assertErrorMsgContains( msg[4], logspace, 2   , 2  , ''   )
  assertErrorMsgContains( msg[4], logspace, 2   , 2  , 1..2 )
end

function TestMatrix:testLogspace()
  local nlrng, nr, l =  { { 10^5, 1, 100 }, { 1, 10^5, 100 }, { 1, 10^-5, 100 }, }
  assertTrue  ( is_vector (logspace(1,1))          )
  assertTrue  ( is_cvector(logspace(complex(1,1))) )
  assertEquals( logspace( 1 )           [1]  , 1   )
  assertEquals( logspace( 1 )           [100], 1   )
  assertEquals( logspace( 2, 2, nil)    [1]  , 2   )
  assertEquals( logspace( 2, 2, nil)    [100], 2   )
  assertEquals(#logspace( 2, 2, nil)         , 100 )
  assertAlmostEquals( logspace( 0.1 )         [100] - 0.1, 0, eps )
  assertAlmostEquals( logspace( complex(1,1) )[100].re - complex(1,1).re, 0, eps )
  assertAlmostEquals( logspace( complex(1,1) )[100].im - complex(1,1).im, 0, eps )

  for _,v in ipairs(nlrng) do
    nr = nlogrange  ( v[1], v[2], v[3] )
    l  = logspace( v[1], v[2], v[3] )
    for i=1,#nr do
      assertEquals( l[i] - nr[i], 0 )
    end
    nr = nrange  ( v[1], v[2], v[3] )
    l  = linspace( complex(v[1],v[1]), complex(v[2],v[2]), v[3] )
    for i=1,#nr do
      assertAlmostEquals( l[i].re - complex(nr[i],nr[i]).re , 0, eps )
      assertAlmostEquals( l[i].im - complex(nr[i],nr[i]).im , 0, eps )
    end
  end
end

-- get, set -------------------------------------------------------------------o

function TestMatrixSet:setUp()
  self.mat   = {}
  self.empty = {}
  for nr=1,5 do
    for nc=1,5 do
      self.mat  [(nr-1)*5+nc] = matrix(nr,nc):fill(1..nr*nc)
      self.empty[(nr-1)*5+nc] = matrix(nr,nc)
    end
  end
end

local ref = \i,j,nc ( (i-1)*nc+j )

function TestMatrixErr:testGeti0()
  local msg = {
    "attempt to compare nil with number",
    }
  assertErrorMsgContains( msg[1], mth, 'geti0', errMat, nil )
end

function TestMatrixGet:testGeti0()
  for _,m in ipairs(g.mat) do
    for i=1,m:size() do assertEquals( m:geti0(i-1), i ) end
  end
end

function TestMatrixErr:testGeti()
local msg = {
    "attempt to compare nil with number",
    }
  assertErrorMsgContains( msg[1], mth, 'geti', errMat, nil )
end

function TestMatrixGet:testGeti()
  for _,m in ipairs(g.mat) do
    for i=1,m:size() do assertEquals( m:geti(i), i ) end
  end
end

function TestMatrixErr:testGet0()
  local msg = {
    "attempt to compare nil with number",
    }
  assertErrorMsgContains( msg[1], mth, 'get0', errMat, 0  , nil )
  assertErrorMsgContains( msg[1], mth, 'get0', errMat, nil, 0   )
end

function TestMatrixGet:testGet0()
  local nr, nc
  for _,m in ipairs(g.mat) do
    nr, nc = m:sizes()
    for i=1,nr do
    for j=1,nc do
      assertEquals( m:get0(i-1,j-1), ref(i,j,nc) )
    end end
  end
end

function TestMatrixErr:testGet()
  local msg = {
    "attempt to compare nil with number",
    }
  assertErrorMsgContains( msg[1], mth, 'get0', errMat, 1  , nil )
  assertErrorMsgContains( msg[1], mth, 'get0', errMat, nil, 1   )
end

function TestMatrixGet:testGet()
  local nr, nc
  for _,m in ipairs(g.mat) do
    nr, nc = m:sizes()
    for i=1,nr do
    for j=1,nc do
      assertEquals( m:get(i,j), ref(i,j,nc) )
    end end
  end
end

function TestMatrixErr:testSeti0()
  local msg = {
    "0-index out of bounds"             ,
    "attempt to compare nil with number",
    }
  assertErrorMsgContains( msg[1], mth, 'seti0', errMat, nan  , 1 )
  assertErrorMsgContains( msg[1], mth, 'seti0', errMat,-1    , 1 )
  assertErrorMsgContains( msg[1], mth, 'seti0', errMat,-eps  , 1 )
  assertErrorMsgContains( msg[1], mth, 'seti0', errMat, 4    , 1 )
  assertErrorMsgContains( msg[2], mth, 'seti0', errMat, nil  , 1 )
end
function TestMatrixSet:testSeti0()
  for _,m in ipairs(self.empty) do
    for i=1,m:size() do
      m:seti0((i-1), i)
      assertEquals( m:geti0(i-1), i )
    end
  end
end

function TestMatrixErr:testSeti()
  local msg = {
    "1-index out of bounds"             ,
    "attempt to compare nil with number",
    }
  assertErrorMsgContains( msg[1], mth, 'seti', errMat, nan  , 1 )
  assertErrorMsgContains( msg[1], mth, 'seti', errMat, 0    , 1 )
  assertErrorMsgContains( msg[1], mth, 'seti', errMat, 1-eps, 1 )
  assertErrorMsgContains( msg[1], mth, 'seti', errMat, 5    , 1 )
  assertErrorMsgContains( msg[2], mth, 'seti', errMat, nil  , 1 )
end

function TestMatrixSet:testSeti()
  for _,m in ipairs(self.empty) do
    for i=1,m:size() do
      m:seti((i), i)
      assertEquals( m:geti(i), i )
    end
  end
end

function TestMatrixErr:testSet0()
  local msg = {
    "0-index out of bounds"             ,
    "attempt to compare nil with number",
    }
  assertErrorMsgContains( msg[1], mth, 'set0', errMat, nan  , 1    , 1 )
  assertErrorMsgContains( msg[1], mth, 'set0', errMat,-1    , 0    , 1 )
  assertErrorMsgContains( msg[1], mth, 'set0', errMat,-1+eps, 0    , 1 )
  assertErrorMsgContains( msg[1], mth, 'set0', errMat, 0    ,-1+eps, 1 )
  assertErrorMsgContains( msg[1], mth, 'set0', errMat, 2    , 1    , 1 )
  assertErrorMsgContains( msg[1], mth, 'set0', errMat, 1    , 2    , 1 )
  assertErrorMsgContains( msg[2], mth, 'set0', errMat, nil  , 1    , 1 )
  assertErrorMsgContains( msg[2], mth, 'set0', errMat, 1    , nil  , 1 )
end

function TestMatrixSet:testSet0()
  local nr, nc
  for _,m in ipairs(self.empty) do
    nr, nc = m:sizes()
    for i=1,nr do
    for j=1,nc do
      m:set0(i-1,j-1, ref(i,j,nc) )
      assertEquals( m:get0(i-1,j-1), ref(i,j,nc) )
    end end
  end
end

function TestMatrixErr:testSet()
  local msg = {
    "1-index out of bounds"             ,
    "attempt to compare nil with number",
    }
  assertErrorMsgContains( msg[1], mth, 'set', errMat, nan  , 1    , 1 )
  assertErrorMsgContains( msg[1], mth, 'set', errMat, 0    , 1    , 1 )
  assertErrorMsgContains( msg[1], mth, 'set', errMat, 1    , 0    , 1 )
  assertErrorMsgContains( msg[1], mth, 'set', errMat, 1-eps, 1    , 1 )
  assertErrorMsgContains( msg[1], mth, 'set', errMat, 1    , 1-eps, 1 )
  assertErrorMsgContains( msg[2], mth, 'set', errMat, nil  , 1    , 1 )
end

function TestMatrixSet:testSet()
  local nr, nc
  for _,m in ipairs(self.empty) do
    nr, nc = m:sizes()
    for i=1,nr do
    for j=1,nc do
      m:set(i, j, ref(i,j,nc) )
      assertEquals( m:get(i,j), ref(i,j,nc) )
    end end
  end
end

function TestMatrixErr:testSame()
  local msg, s = {
    "invalid argument #1 or #2 (nrow[,ncol] >=1 or table [of tables] expected)",
    "invalid argument #1 (non-empty table expected)"                           ,
    "invalid argument #2 (nil or scalar expected)"                             ,
  }
  assertErrorMsgContains( msg[1], mth, 'same', errMat, 1   , ''   )
  assertErrorMsgContains( msg[1], mth, 'same', errMat, 1   , 1..2 )
  assertErrorMsgContains( msg[1], mth, 'same', errMat, 1   , nan  )
  assertErrorMsgContains( msg[2], mth, 'same', errMat, 1   , {}   )
  assertErrorMsgContains( msg[3], mth, 'same', errMat, ''  , 2, 2 )
  assertErrorMsgContains( msg[3], mth, 'same', errMat, 1..2, 2, 2 )
end

function TestMatrixSet:testSame()
  local s
  s = m:same( nan)          assertEquals( s:get(1,1), 0 )
  s = m:same( inf)          assertEquals( s:get(1,1), 0 )
  s = m:same( 0  )          assertEquals( s:get(1,1), 0 )

  for _,m in ipairs(g.mat) do
    -- no input
    s = m:same()    assertEquals( s, matrix(m:sizes()) )
    -- two arg: nr, nc
    s = m:same(2  ,2  ) assertEquals( s, matrix(2) )
    s = m:same(6  ,6  ) assertEquals( s, matrix(6) )
    s = m:same(nil,2,2) assertEquals( s, matrix(2) )
    -- three arg: e_, nr, nc
    s = m:same(complex(1,1), 2, 2) assertEquals( {s:sizes()}, {2,2} ) assertFalse( is_matrix(s) )
    s = m:same(1, 2, 2)            assertEquals( {s:sizes()}, {2,2} ) assertTrue ( is_matrix(s) )
  end
end

-- getx, setx -----------------------------------------------------------------o

function TestMatrixErr:testGetsub()
  local msg = {
    "invalid argument #2 (iterable expected)",
    "invalid argument #3 (iterable expected)",
    "invalid argument #4 (iterable expected)",
    "invalid range member '1'"               ,
    "cannot convert 'nil' to 'double'"       ,
    }
  assertErrorMsgContains( msg[1], mth, 'getsub', errMat, nil          )
  assertErrorMsgContains( msg[1], mth, 'getsub', errMat, ''           )
  assertErrorMsgContains( msg[1], mth, 'getsub', errMat, \x x         )
  assertErrorMsgContains( msg[1], mth, 'getsub', errMat, complex(1,1) )
  assertErrorMsgContains( msg[2], mth, 'getsub', errMat, 1   , nil    )
  assertErrorMsgContains( msg[2], mth, 'getsub', errMat, 1   , ''     )
  assertErrorMsgContains( msg[2], mth, 'getsub', errMat, 1   , \x x   )
  assertErrorMsgContains( msg[5], mth, 'getsub', errMat, 0   , 0      )
  assertErrorMsgContains( msg[5], mth, 'getsub', errMat, 3   , 1      )
  assertErrorMsgContains( msg[5], mth, 'getsub', errMat, 1   , 3      )
  assertErrorMsgContains( msg[5], mth, 'getsub', errMat, 0   , 1      )
  assertErrorMsgContains( msg[5], mth, 'getsub', errMat, 1   , 0      )
  assertErrorMsgContains( msg[3], mth, 'getsub', errMat, 0   , 0   , 1    )
  assertErrorMsgContains( msg[3], mth, 'getsub', errMat, 1   , 1   , \x x )
  assertErrorMsgContains( msg[4], mth, 'getsub', errMat, 1   , 1   , 1..4 )
end

function TestMatrixGet:testGetsub() end

function TestMatrixErr:testSetsub()
  local msg = {
    "invalid argument #2 (iterable expected)"          ,
    "invalid argument #3 (iterable expected)"          ,
    "invalid argument #4 (scalar or iterable expected)",
    "1-index out of bounds"                            ,
  }
  assertErrorMsgContains( msg[1], mth, 'setsub', errMat, nil , 1  , 1  )
  assertErrorMsgContains( msg[1], mth, 'setsub', errMat, ''  , 1  , 1  )
  assertErrorMsgContains( msg[1], mth, 'setsub', errMat, NaN , 1  , 1  )
  assertErrorMsgContains( msg[1], mth, 'setsub', errMat, \x x, 1  , 1  )
  assertErrorMsgContains( msg[2], mth, 'setsub', errMat, 1             )
  assertErrorMsgContains( msg[2], mth, 'setsub', errMat, 1   , nil, 1  )
  assertErrorMsgContains( msg[2], mth, 'setsub', errMat, 1   , '' , 1  )
  assertErrorMsgContains( msg[2], mth, 'setsub', errMat, 1   , NaN, 1  )
  assertErrorMsgContains( msg[3], mth, 'setsub', errMat, 1   , 1 , nil )
  assertErrorMsgContains( msg[3], mth, 'setsub', errMat, 1   , 1 , ''  )
  assertErrorMsgContains( msg[3], mth, 'setsub', errMat, 1   , 1 , NaN )
  assertErrorMsgContains( msg[4], mth, 'setsub', errMat, 0   , 1 , 1   )
  assertErrorMsgContains( msg[4], mth, 'setsub', errMat, 1   , 0 , 1   )
  assertErrorMsgContains( msg[1], mth, 'setsub', errMat, complex(1,1), 1 , 1 )
  assertErrorMsgContains( msg[2], mth, 'setsub', errMat, 1 , complex(1,1), 1 )
end
function TestMatrixSet:testSetsub() end

function TestMatrixErr:testGetv()
  local msg = {
    "invalid argument #2 (iterable expected)",
    "invalid argument #3 (iterable expected)",
    "cannot convert 'nil' to 'double"        ,
    "invalid range member '1'"               ,
  }
  assertErrorMsgContains( msg[1], mth, 'getv', errMat, nil )
  assertErrorMsgContains( msg[1], mth, 'getv', errMat, ''  )
  assertErrorMsgContains( msg[1], mth, 'getv', errMat, NaN )
  assertErrorMsgContains( msg[2], mth, 'getv', errMat, 1  , ''   )
  assertErrorMsgContains( msg[2], mth, 'getv', errMat, 1  , 1    )
  assertErrorMsgContains( msg[2], mth, 'getv', errMat, 1  , \x x )
  assertErrorMsgContains( msg[3], mth, 'getv', errMat, 0         )
  assertErrorMsgContains( msg[3], mth, 'getv', errMat, matrix(2) )
  assertErrorMsgContains( msg[4], mth, 'getv', errMat, 1  , 1..2 )
end

function TestMatrixGet:testGetv()
  for _,m in ipairs(g.mat) do
    for i = 1,m:size() do
      assertEquals( m:getv( i   )         , vector({i})          )
      assertEquals( m:getv( 1..i)         , vector(i):fill(1..i) )
      assertEquals( m:getv({1,i})         , vector({1,i})        )
      assertEquals( m:getv( i    ,{})     , {i}                  )
      assertEquals( m:getv({1,i} ,{})     , {1,i}                )
      assertEquals( m:getv( 1..i ,{})     , totable(1..i)        )
      assertEquals( m:getv( i    , matrix(2)), matrix{{i,0},{0,0}}  )
      assertEquals( m:getv({1,i} , matrix(2)), matrix{{1,i},{0,0}}  )
    end
  end
  m = matrix(4):fill(1..16)
  m:getv(1..5,'in')
  assertEquals( m, matrix(4):fill(1..16) ) -- same output, info in documentation
end

function TestMatrixErr:testSetv()
  local msg = {
    "invalid argument #2 (iterable expected)"          ,
    "invalid argument #3 (scalar or iterable expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'setv', errMat, nil , 0    )
  assertErrorMsgContains( msg[1], mth, 'setv', errMat, ''  , 0    )
  assertErrorMsgContains( msg[1], mth, 'setv', errMat, NaN , 0    )
  assertErrorMsgContains( msg[1], mth, 'setv', errMat, \x x, 0    )
  assertErrorMsgContains( msg[2], mth, 'setv', errMat, 1   , ''   )
  assertErrorMsgContains( msg[2], mth, 'setv', errMat, 1   , nil  )
  assertErrorMsgContains( msg[2], mth, 'setv', errMat, 1   , NaN  )
  assertErrorMsgContains( msg[2], mth, 'setv', errMat, 1   , \x x )
end
function TestMatrixSet:testSetv() end

function TestMatrixErr:testGetdiag()
  local msg = {
    "invalid argument #2 (iterable expected)",
    "invalid range member '1'"               ,
  }
  assertErrorMsgContains( msg[1], mth, 'getdiag', errMat, ''   )
  assertErrorMsgContains( msg[1], mth, 'getdiag', errMat, \x x )
  assertErrorMsgContains( msg[1], mth, 'getdiag', errMat, 1    )
  assertErrorMsgContains( msg[2], mth, 'getdiag', errMat, 1..2 )
end

function TestMatrixGet:testGetdiag()
  local m, n, diag, nr, nc = matrix(2)
  for _,m in ipairs(g.mat) do
    nr, nc = m:sizes()
    diag = {} for i = 1,min(nr,nc) do  diag[i] = (1+(i-1)*nc+i-1) end
    assertEquals( m:getdiag()  , vector(diag) )
    assertEquals( m:getdiag({}), diag         )
  end
end

function TestMatrixErr:testSetdiag()
  local msg = {
    "invalid argument #2 (scalar or iterable expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'setdiag', errMat, nil  )
  assertErrorMsgContains( msg[1], mth, 'setdiag', errMat, ''   )
  assertErrorMsgContains( msg[1], mth, 'setdiag', errMat, \x x )
end

function TestMatrixSet:testSetdiag()
  local m, n, diag, nr, nc = matrix(2)
    for _,m in ipairs(self.mat) do
    diag, ref = {}, {}
    nr, nc = m:sizes()
    n = min(nr, nc)
    for i = 1,n do  diag[i] = (1+(i-1)*nc+i-1) end
    for i = 1,n do if i<=3 then ref[i] = i
                   else         ref[i] = diag[i]  end end
    m:setdiag(1)            assertEquals( m:getdiag(), vector(n):fill(1)    )
    m:setdiag(1..n)         assertEquals( m:getdiag(), vector(n):fill(1..n) )
    m:setdiag(diag)         assertEquals( m:getdiag(), vector(diag)         )
    m:setdiag({1,2,3})      assertEquals( m:getdiag(), vector(ref)          )
    m:setdiag(complex(0,1)) assertEquals( m:getdiag(), vector(n)            )
  end
end

function TestMatrixErr:testGetrow()
  local msg = {
    "invalid argument #2 (iterable expected)",
    "invalid argument #3 (iterable expected)",
    "cannot convert 'nil' to 'double'"       ,
    "invalid range member '1'"               ,
    "1-index out of bounds"                  ,
    }
  assertErrorMsgContains( msg[1], mth, 'getrow', errMat, ''         )
  assertErrorMsgContains( msg[1], mth, 'getrow', errMat, nil        )
  assertErrorMsgContains( msg[1], mth, 'getrow', errMat, NaN        )
  assertErrorMsgContains( msg[1], mth, 'getrow', errMat, \x x       )
  assertErrorMsgContains( msg[2], mth, 'getrow', errMat, 1   , ''   )
  assertErrorMsgContains( msg[2], mth, 'getrow', errMat, 1   , 1    )
  assertErrorMsgContains( msg[3], mth, 'getrow', errMat, 0          )
  assertErrorMsgContains( msg[3], mth, 'getrow', errMat, 5          )
  assertErrorMsgContains( msg[4], mth, 'getrow', errMat, 1   , 1..2 )
  assertErrorMsgContains( msg[5], mth, 'getrow', errMat, 1   , vector(1) )
end
function TestMatrixGet:testGetrow()end

function TestMatrixErr:testSetrow()
  local m = matrix(3)
  local msg = {
    "invalid argument #2 (iterable expected)"          ,
    "invalid argument #3 (scalar or iterable expected)",
    "1-index out of bounds"                            ,
    "cannot convert 'nil' to 'double'"                 ,
  }
  assertErrorMsgContains( msg[1], mth, 'setrow', errMat, ''        )
  assertErrorMsgContains( msg[1], mth, 'setrow', errMat, nil       )
  assertErrorMsgContains( msg[1], mth, 'setrow', errMat, NaN       )
  assertErrorMsgContains( msg[1], mth, 'setrow', errMat, \x x      )
  assertErrorMsgContains( msg[2], mth, 'setrow', errMat, 1   , nil )
  assertErrorMsgContains( msg[2], mth, 'setrow', errMat, 1   , ''  )
  assertErrorMsgContains( msg[3], mth, 'setrow', errMat, 0   , 1   )
  assertErrorMsgContains( msg[3], mth, 'setrow', errMat, 3   , 1   )
  assertErrorMsgContains( msg[4], mth, 'setrow', errMat, 1   , matrix(1) )
  assertErrorMsgContains( msg[4], mth, 'setrow', m     , 1 ,1..2  )   --CHECK FOR BETTER SOLUTION
  assertErrorMsgContains( msg[4], mth, 'setrow', m     , 1 ,{1,2} )   --CHECK
end
function TestMatrixSet:testSetrow()end

function TestMatrixErr:testGetcol()
  local msg = {
    "invalid argument #2 (iterable expected)",
    "invalid argument #3 (iterable expected)",
    "cannot convert 'nil' to 'double'"       ,
    "invalid range member '1'"               ,
    "1-index out of bounds"                  ,
  }
  assertErrorMsgContains( msg[1], mth, 'getcol', errMat, ''   )
  assertErrorMsgContains( msg[1], mth, 'getcol', errMat, nil  )
  assertErrorMsgContains( msg[1], mth, 'getcol', errMat, NaN  )
  assertErrorMsgContains( msg[1], mth, 'getcol', errMat, \x x )
  assertErrorMsgContains( msg[2], mth, 'getcol', errMat, 1   , ''   )
  assertErrorMsgContains( msg[2], mth, 'getcol', errMat, 1   , 1    )
  assertErrorMsgContains( msg[3], mth, 'getcol', errMat, 0          )
  assertErrorMsgContains( msg[3], mth, 'getcol', errMat, 3          )
  assertErrorMsgContains( msg[4], mth, 'getcol', errMat, 1   , 1..2 )
  assertErrorMsgContains( msg[5], mth, 'getcol', errMat, 1   , vector(1) )
end
function TestMatrixGet:testGetcol()end

function TestMatrixErr:testSetcol()
  local m = matrix(3)
  local msg = {
    "invalid argument #2 (iterable expected)"          ,
    "invalid argument #3 (scalar or iterable expected)",
    "1-index out of bounds"                            ,
    "cannot convert 'nil' to 'double'"                 ,
  }
  assertErrorMsgContains( msg[1], mth, 'setcol', errMat, ''         )
  assertErrorMsgContains( msg[1], mth, 'setcol', errMat, nil        )
  assertErrorMsgContains( msg[1], mth, 'setcol', errMat, NaN        )
  assertErrorMsgContains( msg[1], mth, 'setcol', errMat, \x x       )
  assertErrorMsgContains( msg[2], mth, 'setcol', errMat, 1   ,  ''  )
  assertErrorMsgContains( msg[2], mth, 'setcol', errMat, 1   ,  nil )
  assertErrorMsgContains( msg[3], mth, 'setcol', errMat, 0   ,  1   )
  assertErrorMsgContains( msg[3], mth, 'setcol', errMat, 3   ,  1   )
  assertErrorMsgContains( msg[4], mth, 'setcol', errMat, 1   ,  matrix(1) )
  assertErrorMsgContains( msg[4], mth, 'setcol', m     , 1,  1..2  ) --CHECK
  assertErrorMsgContains( msg[4], mth, 'setcol', m     , 1,  {1,2} ) --CHECK
end
function TestMatrixSet:testSetcol() end

-- size, same -----------------------------------------------------------------o

function TestMatrix:testNrow()
  for i,m in ipairs(g.mat) do
    assertEquals( m:nrow(), g.size[i][1] )
  end
end

function TestMatrix:testNcol()
  for i,m in ipairs(g.mat) do
    assertEquals( m:ncol(), g.size[i][2] )
  end
end

function TestMatrix:testSize()
  for i,m in ipairs(g.mat) do
    assertEquals( m:size(), g.size[i][1]*g.size[i][2] )
  end
end

function TestMatrix:testSizes()
  for i,m in ipairs(g.mat) do
    assertEquals( {m:sizes()}, g.size[i] )
  end
end

function TestMatrix:testTsizes()
  for i,m in ipairs(g.mat) do
    assertEquals( {m:tsizes()}, {g.size[i][2], g.size[i][1]} )
  end
end

-- in place -------------------------------------------------------------------o

function TestMatrixInPlace:setUp()
  self.mat   = {}
  for nr=1,5 do
    for nc=1,5 do
      self.mat  [(nr-1)*5+nc] = matrix(nr,nc):fill(1..nr*nc)
    end
  end
end

function TestMatrixErr:testRandom()
  local msg, s = {
    "invalid argument #1 or #2 (nrow[,ncol] >=1 or table [of tables] expected)",
    "invalid argument #1 (non-empty table expected)"                           ,
  }
  assertErrorMsgContains( msg[1], mth, 'same', errMat, 1, ''   )
  assertErrorMsgContains( msg[1], mth, 'same', errMat, 1, 1..2 )
  assertErrorMsgContains( msg[1], mth, 'same', errMat, 1, nan  )
  assertErrorMsgContains( msg[2], mth, 'same', errMat, 1, {}   )
end

function TestMatrixInPlace:testRandom()
  local oldVal, val = {}, {}
  for _,m in ipairs(self.mat) do
    m:random()
    for i = 1,m:size() do
      val[i] = m:geti(i)
      assertTrue ( val[i] <  1    )
      assertTrue ( val[i] >= 0    )
      assertFalse( val[i] == oldVal[i] )
      oldVal[i] =  val[i]
    end
  end
end

function TestMatrixErr:testFill()
  local msg = {
    "invalid argument #2 (scalar, callable or indexable expected)",
    "incompatible container size"                                 ,
    "invalid container (iterable expected)"                       ,
    }
  assertErrorMsgContains( msg[1], mth,'fill', errMat, nil  )
  assertErrorMsgContains( msg[1], mth,'fill', errMat, true )
  assertErrorMsgContains( msg[2], mth,'fill', errMat, {}   )
end
function TestMatrixInPlace:testFill()
  for _,m in ipairs(self.mat) do
    --scalar
    m:fill(nan)               for i=1,m:size() do assertNaN   ( m:geti(i)      ) end
    m:fill(inf)               for i=1,m:size() do assertInf   ( m:geti(i)      ) end
    m:fill(1  )               for i=1,m:size() do assertEquals( m:geti(i), 1   ) end
    m:fill(complex(1,1))      for i=1,m:size() do assertEquals( m:geti(i), 1   ) end
    --generator
    m:fill(1..#m)             for i=1,m:size() do assertEquals( m:geti(i), i   ) end
    m:fill\x x^2              for i=1,m:size() do assertEquals( m:geti(i), i^2 ) end
    --2D container
    m:fill( m:same() )        for i=1,m:size() do assertEquals( m:geti(i), 0   ) end
    --1D container
    t={} for i=1,m :size() do t[i]=i end
    m:fill(t)                 for i=1,m:size() do assertEquals( m:geti(i), i   ) end
    m:fill(vector(m :size())) for i=1,m:size() do assertEquals( m:geti(i), 0   ) end
  end
  local m, t = matrix(5), {}
  for i=1,5 do t[i] = {}      for j=1,5 do t[i][j]=(i-1)*5+j end end
  m :fill(t)                  for i=1,m :size() do assertEquals( m :geti(i), i ) end
  assertTrue( is_matrix ( matrix(5,5):fill(complex(1,1))) )  --check of types change
end

function TestMatrixErr:testCopy()
  local msg = {
    "invalid argument #1 (matrix expected",
  }
  assertErrorMsgContains( msg[1], mth,'copy', errMat,  1 )
end

function TestMatrix:testCopy() --think about puting in one of test-suits
  for i,m in ipairs(g.mat) do
    mcopy = g.empty[i]
    mcopy:copy(m)
    for i=1,m:size() do assertEquals( m:geti(i), mcopy:geti(i) ) end
  end
end

function TestMatrixInPlace:testZeros()
  local m1
  for _,m in ipairs(self.mat) do
    m1 = m:zeros()
    for i=1,m:size() do assertEquals( m1:geti(i), 0 ) end
  end
end

function TestMatrixInPlace:testOnes()
  for _,m in ipairs(self.mat) do
    m:ones()
    for i=1,m:size() do assertEquals( m:geti(i), 1 ) end
  end
end

function TestMatrixInPlace:testEye()
  local nr, nc
  for i,m in ipairs(self.mat) do
    nr, nc = m:sizes()
    m:eye()
    for i=1,nr do
    for j=1,nc do
      if i==j then assertEquals( m:get(i,j), 1 )
      else         assertEquals( m:get(i,j), 0 ) end
    end end
  end
end

function TestMatrixErr:testSymp()
  local msg = {
    "invalid argument #1 (2n matrix expected)",
  }
  assertErrorMsgContains( msg[1], mth,'symp',  matrix(3)   ) --CHECK
  assertErrorMsgContains( msg[1], mth,'symp',  vector(2)   ) --CHECK
  assertErrorMsgContains( msg[1], mth,'symp',  matrix(4,3) ) --CHECK
end

function TestMatrix:testSymp() end

function TestMatrixErr:testCirc()
  local msg = {
    "invalid argument #2 (iterable expected)",
  }
  assertErrorMsgContains( msg[1], mth,'circ', errMat, nil  )
  assertErrorMsgContains( msg[1], mth,'circ', errMat, 1    )
  assertErrorMsgContains( msg[1], mth,'circ', errMat, \x x )
end

function TestMatrix:testCirc() end

function TestMatrixErr:testReshape()
  local msg, m, s = {
    "invalid matrix new sizes",
    }
  assertErrorMsgContains( msg[1], mth,'reshape', errMat, 3, 3  )
  assertErrorMsgContains( msg[1], mth,'reshape', errMat, 1, 5  )
  assertErrorMsgContains( msg[1], mth,'reshape', errMat, 0, 2  )
  assertErrorMsgContains( msg[1], mth,'reshape', errMat, 1, 0  )
end

function TestMatrixInPlace:testReshape() end

-- foreach, filter, map, fold, scan -------------------------------------------o

function TestMatrixFun:setUp()
  self.mat   = {}
  for nr=1,5 do
    for nc=1,5 do
      self.mat  [(nr-1)*5+nc] = matrix(nr,nc):fill(1..nr*nc)
    end
  end
end

function TestMatrixErr:testForeach()
  local msg = {
    "invalid argument #2 (callable expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'foreach', errMat, nil       )
  assertErrorMsgContains( msg[1], mth, 'foreach', errMat, ''        )
  assertErrorMsgContains( msg[1], mth, 'foreach', errMat, 1         )
  assertErrorMsgContains( msg[1], mth, 'foreach', errMat, 1..2      )
  assertErrorMsgContains( msg[1], mth, 'foreach', errMat, matrix(1) )
  assertErrorMsgContains( msg[1], mth, 'foreach', errMat, { }       )
end

function TestMatrixFun:testForeach() -- for test need of filled table
  local nr, nc, f, t
  f = \x,i,j => t[i][j]=x  end

  for _,m in ipairs(self.mat) do
    nr, nc = m:sizes()
    t  = table.new(nr, nc)
    for i=0,nr-1 do local c = t[i+1] or table.new(nc,0); t[i+1] = c end
    m:foreach(f)

    for i=1,nr do for j=1,nc do assertEquals( t[i][j], (i-1)*nc+j ) end end
  end
end

function TestMatrixErr:testMap()
  local msg = {
    "invalid argument #2 (callable expected)"                 ,
    "invalid argument #3 (iterable expected)"                 ,
    "invalid range member '1'"                                ,
    "attempt to perform arithmetic on local 'x' (a nil value)",
  }
  assertErrorMsgContains( msg[1], mth, 'map', errMat, ''           )
  assertErrorMsgContains( msg[1], mth, 'map', errMat, 1..2         )
  assertErrorMsgContains( msg[1], mth, 'map', errMat, 1            )
  assertErrorMsgContains( msg[1], mth, 'map', errMat, matrix(1)    )
  assertErrorMsgContains( msg[1], mth, 'map', errMat, { }          )
  assertErrorMsgContains( msg[2], mth, 'map', errMat, \x x+1, ''   )
  assertErrorMsgContains( msg[2], mth, 'map', errMat, \x x+1, 1    )
  assertErrorMsgContains( msg[3], mth, 'map', errMat, \x x+1, 1..2 )
end

function TestMatrixFun:testMap() end

function TestMatrixErr:testMap2()
  local msg = {
    "invalid argument #2 (scalar or iterable expected)"       ,
    "invalid argument #3 (callable expected)"                 ,
    "invalid argument #4 (iterable expected)"                 ,
    "invalid range member '1'"                                ,
    "attempt to perform arithmetic on local 'y' (a nil value)",
  }
  assertErrorMsgContains( msg[1], mth, 'map2', errMat, nil  )
  assertErrorMsgContains( msg[1], mth, 'map2', errMat, ''   )
  assertErrorMsgContains( msg[1], mth, 'map2', errMat, NaN  )
  assertErrorMsgContains( msg[1], mth, 'map2', errMat, \x x )
  assertErrorMsgContains( msg[2], mth, 'map2', errMat, matrix(1), nil  )
  assertErrorMsgContains( msg[2], mth, 'map2', errMat, matrix(1), 1..2 )
  assertErrorMsgContains( msg[2], mth, 'map2', errMat, matrix(1), 1    )
  assertErrorMsgContains( msg[3], mth, 'map2', errMat, matrix(1), \x x, 1    )
  assertErrorMsgContains( msg[4], mth, 'map2', errMat, matrix(1), \x x, 1..2 )
  assertErrorMsgContains( msg[5], mth, 'map2', errMat, matrix(1), \x,y  x+y  )
end

function TestMatrixFun:testMap2() end

function TestMatrixErr:testMap3()
  local m = matrix(1)
  local msg = {
    "invalid argument #2 (scalar or iterable expected)"       ,
    "invalid argument #3 (scalar or iterable expected)"       ,
    "invalid argument #4 (callable expected)"                 ,
    "invalid argument #5 (iterable expected)"                 ,
    "invalid range member '1'"                                ,
    "attempt to perform arithmetic on local 'y' (a nil value)",
    "attempt to perform arithmetic on local 'z' (a nil value)",
  }
  assertErrorMsgContains( msg[1], mth, 'map3', errMat, ''   )
  assertErrorMsgContains( msg[1], mth, 'map3', errMat, NaN  )
  assertErrorMsgContains( msg[1], mth, 'map3', errMat, \x x )
  assertErrorMsgContains( msg[2], mth, 'map3', errMat, errMat, ''   )
  assertErrorMsgContains( msg[2], mth, 'map3', errMat, errMat, NaN  )
  assertErrorMsgContains( msg[2], mth, 'map3', errMat, errMat, \x x )
  assertErrorMsgContains( msg[3], mth, 'map3', errMat, errMat, errMat, nil  )
  assertErrorMsgContains( msg[3], mth, 'map3', errMat, errMat, errMat, 1..2 )
  assertErrorMsgContains( msg[3], mth, 'map3', errMat, errMat, errMat, 1    )
  assertErrorMsgContains( msg[4], mth, 'map3', errMat, errMat, errMat, \x x, 1    )
  assertErrorMsgContains( msg[5], mth, 'map3', errMat, errMat, errMat, \x x, 1..2 )
  assertErrorMsgContains( msg[6], mth, 'map3', errMat, m     , errMat, \x,y,z x+y+z )
  assertErrorMsgContains( msg[6], mth, 'map3', errMat, m     , m     , \x,y,z x+y+z )
  assertErrorMsgContains( msg[7], mth, 'map3', errMat, errMat, m     , \x,y,z x+y+z )
end

function TestMatrixFun:testMap3() end

function TestMatrixErr:testMapij()
  local msg = {
    "invalid argument #2 (callable expected)",
    "invalid argument #3 (iterable expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'mapij', errMat, nil       )
  assertErrorMsgContains( msg[1], mth, 'mapij', errMat, ''        )
  assertErrorMsgContains( msg[1], mth, 'mapij', errMat, 1..2      )
  assertErrorMsgContains( msg[1], mth, 'mapij', errMat, 1         )
  assertErrorMsgContains( msg[1], mth, 'mapij', errMat, matrix(1) )
  assertErrorMsgContains( msg[1], mth, 'mapij', errMat, { }       )
  assertErrorMsgContains( msg[2], mth, 'mapij', errMat, \x x+1  , ''   )
  assertErrorMsgContains( msg[2], mth, 'mapij', errMat, \x x+1  , \x x )
end

function TestMatrixFun:testMapij() end

function TestMatrixErr:testMapat()
  local msg = {
    "invalid argument #2 (callable expected)",
    "invalid argument #3 (iterable expected)",
    "invalid argument #4 (iterable expected)",
    "invalid range member '1'"               ,
    "attempt to perform arithmetic on local 'x' (a nil value)",
  }
  assertErrorMsgContains( msg[1], mth, 'mapat', errMat, nil       )
  assertErrorMsgContains( msg[1], mth, 'mapat', errMat, ''        )
  assertErrorMsgContains( msg[1], mth, 'mapat', errMat, 1..2      )
  assertErrorMsgContains( msg[1], mth, 'mapat', errMat, 1         )
  assertErrorMsgContains( msg[1], mth, 'mapat', errMat, matrix(1) )
  assertErrorMsgContains( msg[1], mth, 'mapat', errMat, { }       )
  assertErrorMsgContains( msg[2], mth, 'mapat', errMat, \x x+1  , ''   )
  assertErrorMsgContains( msg[2], mth, 'mapat', errMat, \x x+1  , nil  )
  assertErrorMsgContains( msg[2], mth, 'mapat', errMat, \x x+1  , NaN  )
  assertErrorMsgContains( msg[2], mth, 'mapat', errMat, \x x+1  , \x x )
  assertErrorMsgContains( msg[3], mth, 'mapat', errMat, \x x+1  , 1    , ''   )
  assertErrorMsgContains( msg[3], mth, 'mapat', errMat, \x x+1  , 1    , \x x )
  assertErrorMsgContains( msg[4], mth, 'mapat', errMat, \x x+1  , 1    , 1..2 )
  assertErrorMsgContains( msg[5], mth, 'mapat', errMat, \x x+1  , 0    )
  assertErrorMsgContains( msg[5], mth, 'mapat', errMat, \x x+1  , 5    )
end

function TestMatrixFun:testMapat() end

function TestMatrixErr:testFoldl()
  local msg = {
    "invalid argument #2 (callable expected)"                    ,
    "invalid argument #5 (iterable expected)"                    ,
    "invalid argument #4 (string 'vec', 'row' or 'col' expected)",
    "invalid range member '1'"                                   ,
  }
  m, cm = matrix(2), cmatrix(2)
  assertErrorMsgContains( msg[1], mth, 'foldl', errMat, nil  )
  assertErrorMsgContains( msg[1], mth, 'foldl', errMat, NaN  )
  assertErrorMsgContains( msg[1], mth, 'foldl', errMat, ''   )
  assertErrorMsgContains( msg[1], mth, 'foldl', errMat, {}   )
  assertErrorMsgContains( msg[1], mth, 'foldl', errMat, 1    )
  assertErrorMsgContains( msg[1], mth, 'foldl', errMat, 1..2 )
  assertErrorMsgContains( msg[1], mth, 'foldl', errMat, m    )
  assertErrorMsgContains( msg[1], mth, 'foldl', errMat, cm   )
  assertErrorMsgContains( msg[3], mth, 'foldl', errMat, \x x, '')
  assertErrorMsgContains( msg[3], mth, 'foldl', errMat, \x x, 1 , {}   , {}   )
  assertErrorMsgContains( msg[3], mth, 'foldl', errMat, \x x, 1 , 1..2 , {}   )
  assertErrorMsgContains( msg[3], mth, 'foldl', errMat, \x x, 1 , m    , {}   )
  assertErrorMsgContains( msg[3], mth, 'foldl', errMat, \x x, 1 , cm   , {}   )
  assertErrorMsgContains( msg[3], mth, 'foldl', errMat, \x x, 1 , ''   , {}   )
  assertErrorMsgContains( msg[2], mth, 'foldl', errMat, \x x, 1 , "vec", ''   )
  assertErrorMsgContains( msg[2], mth, 'foldl', errMat, \x x, 1 , "vec", 1    )
  assertErrorMsgContains( msg[2], mth, 'foldl', errMat, \x x, 1 , "vec", \x x )
end

function TestMatrixFun:testFoldl() end

function TestMatrixErr:testFoldr()
  local msg = {
    "invalid argument #2 (callable expected)"                    ,
    "invalid argument #5 (iterable expected)"                    ,
    "invalid argument #4 (string 'vec', 'row' or 'col' expected)",
    "invalid range member '1'"                                   ,
  }
  m, cm = matrix(2), cmatrix(2)
  assertErrorMsgContains( msg[1], mth, 'foldr', errMat, nil  )
  assertErrorMsgContains( msg[1], mth, 'foldr', errMat, NaN  )
  assertErrorMsgContains( msg[1], mth, 'foldr', errMat, ''   )
  assertErrorMsgContains( msg[1], mth, 'foldr', errMat, {}   )
  assertErrorMsgContains( msg[1], mth, 'foldr', errMat, 1    )
  assertErrorMsgContains( msg[1], mth, 'foldr', errMat, 1..2 )
  assertErrorMsgContains( msg[1], mth, 'foldr', errMat, m    )
  assertErrorMsgContains( msg[1], mth, 'foldr', errMat, cm   )
  assertErrorMsgContains( msg[3], mth, 'foldr', errMat, \x x, '')
  assertErrorMsgContains( msg[3], mth, 'foldr', errMat, \x x, 1 , {}   , {}   )
  assertErrorMsgContains( msg[3], mth, 'foldr', errMat, \x x, 1 , 1..2 , {}   )
  assertErrorMsgContains( msg[3], mth, 'foldr', errMat, \x x, 1 , m    , {}   )
  assertErrorMsgContains( msg[3], mth, 'foldr', errMat, \x x, 1 , cm   , {}   )
  assertErrorMsgContains( msg[3], mth, 'foldr', errMat, \x x, 1 , ''   , {}   )
  assertErrorMsgContains( msg[2], mth, 'foldr', errMat, \x x, 1 , "vec", ''   )
  assertErrorMsgContains( msg[2], mth, 'foldr', errMat, \x x, 1 , "vec", 1    )
  assertErrorMsgContains( msg[2], mth, 'foldr', errMat, \x x, 1 , "vec", \x x )
end

function TestMatrixFun:testFoldr() end

function TestMatrixErr:testScanl()
  local msg = {
    "invalid argument #2 (callable expected)"                    ,
    "invalid argument #5 (iterable expected)"                    ,
    "invalid argument #4 (string 'vec', 'row' or 'col' expected)",
    "invalid range member '1'"                                   ,
  }
  m, cm = matrix(2), cmatrix(2)
  assertErrorMsgContains( msg[1], mth, 'scanl', errMat, nil  )
  assertErrorMsgContains( msg[1], mth, 'scanl', errMat, NaN  )
  assertErrorMsgContains( msg[1], mth, 'scanl', errMat, ''   )
  assertErrorMsgContains( msg[1], mth, 'scanl', errMat, {}   )
  assertErrorMsgContains( msg[1], mth, 'scanl', errMat, 1    )
  assertErrorMsgContains( msg[1], mth, 'scanl', errMat, 1..2 )
  assertErrorMsgContains( msg[1], mth, 'scanl', errMat, m    )
  assertErrorMsgContains( msg[1], mth, 'scanl', errMat, cm   )
  assertErrorMsgContains( msg[3], mth, 'scanl', errMat, \x x, '')
  assertErrorMsgContains( msg[3], mth, 'scanl', errMat, \x x, 1 , {}   , {}   )
  assertErrorMsgContains( msg[3], mth, 'scanl', errMat, \x x, 1 , 1..2 , {}   )
  assertErrorMsgContains( msg[3], mth, 'scanl', errMat, \x x, 1 , m    , {}   )
  assertErrorMsgContains( msg[3], mth, 'scanl', errMat, \x x, 1 , cm   , {}   )
  assertErrorMsgContains( msg[3], mth, 'scanl', errMat, \x x, 1 , ''   , {}   )
  assertErrorMsgContains( msg[2], mth, 'scanl', errMat, \x x, 1 , "vec", ''   )
  assertErrorMsgContains( msg[2], mth, 'scanl', errMat, \x x, 1 , "vec", 1    )
  assertErrorMsgContains( msg[2], mth, 'scanl', errMat, \x x, 1 , "vec", \x x )
end

function TestMatrixFun:testScanl() end

function TestMatrixErr:testScanr()
  local msg = {
    "invalid argument #2 (callable expected)"                    ,
    "invalid argument #5 (iterable expected)"                    ,
    "invalid argument #4 (string 'vec', 'row' or 'col' expected)",
    "invalid range member '1'"                                   ,
  }
  m, cm = matrix(2), cmatrix(2)
  assertErrorMsgContains( msg[1], mth, 'scanr', errMat, nil  )
  assertErrorMsgContains( msg[1], mth, 'scanr', errMat, NaN  )
  assertErrorMsgContains( msg[1], mth, 'scanr', errMat, ''   )
  assertErrorMsgContains( msg[1], mth, 'scanr', errMat, {}   )
  assertErrorMsgContains( msg[1], mth, 'scanr', errMat, 1    )
  assertErrorMsgContains( msg[1], mth, 'scanr', errMat, 1..2 )
  assertErrorMsgContains( msg[1], mth, 'scanr', errMat, m    )
  assertErrorMsgContains( msg[1], mth, 'scanr', errMat, cm   )
  assertErrorMsgContains( msg[3], mth, 'scanr', errMat, \x x, '')
  assertErrorMsgContains( msg[3], mth, 'scanr', errMat, \x x, 1 , {}   , {}   )
  assertErrorMsgContains( msg[3], mth, 'scanr', errMat, \x x, 1 , 1..2 , {}   )
  assertErrorMsgContains( msg[3], mth, 'scanr', errMat, \x x, 1 , m    , {}   )
  assertErrorMsgContains( msg[3], mth, 'scanr', errMat, \x x, 1 , cm   , {}   )
  assertErrorMsgContains( msg[3], mth, 'scanr', errMat, \x x, 1 , ''   , {}   )
  assertErrorMsgContains( msg[2], mth, 'scanr', errMat, \x x, 1 , "vec", ''   )
  assertErrorMsgContains( msg[2], mth, 'scanr', errMat, \x x, 1 , "vec", 1    )
  assertErrorMsgContains( msg[2], mth, 'scanr', errMat, \x x, 1 , "vec", \x x )
end

function TestMatrixFun:testScanr() end

function TestMatrixErr:testFilter()
  local msg = {
    "invalid argument #2 (callable expected)",
    "invalid argument #3 (iterable expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'filter', errMat, nil       )
  assertErrorMsgContains( msg[1], mth, 'filter', errMat, ''        )
  assertErrorMsgContains( msg[1], mth, 'filter', errMat, 1..2      )
  assertErrorMsgContains( msg[1], mth, 'filter', errMat, 1         )
  assertErrorMsgContains( msg[1], mth, 'filter', errMat, matrix(1) )
  assertErrorMsgContains( msg[1], mth, 'filter', errMat, { }       )
  assertErrorMsgContains( msg[2], mth, 'filter', errMat, \x x     , ''   )
  assertErrorMsgContains( msg[2], mth, 'filter', errMat, \x x     , 1    )
  assertErrorMsgContains( msg[2], mth, 'filter', errMat, \x x     , \x x )
end

function TestMatrixFun:testFilter() end

function TestMatrixErr:testFilter_out()
  local msg = {
    "invalid argument #2 (callable expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'filter_out', errMat, nil       )
  assertErrorMsgContains( msg[1], mth, 'filter_out', errMat, ''        )
  assertErrorMsgContains( msg[1], mth, 'filter_out', errMat, 1..2      )
  assertErrorMsgContains( msg[1], mth, 'filter_out', errMat, 1         )
  assertErrorMsgContains( msg[1], mth, 'filter_out', errMat, matrix(1) )
  assertErrorMsgContains( msg[1], mth, 'filter_out', errMat, { }       )
end

function TestMatrixErr:testFilter_out() end

-- special maps ---------------------------------------------------------------o

function TestMatrixSMaps:testCeil () end
function TestMatrixSMaps:testFloor() end
function TestMatrixSMaps:testFrac () end
function TestMatrixSMaps:testTrunc() end
function TestMatrixSMaps:testRound() end
function TestMatrixSMaps:testAbs  () end
function TestMatrixSMaps:testSqrt () end
function TestMatrixSMaps:testExp  () end
function TestMatrixSMaps:testLog  () end
function TestMatrixSMaps:testLog10() end
function TestMatrixSMaps:testSin () end
function TestMatrixSMaps:testCos () end
function TestMatrixSMaps:testTan () end
function TestMatrixSMaps:testSinh() end
function TestMatrixSMaps:testCosh() end
function TestMatrixSMaps:testTanh() end
function TestMatrixSMaps:testAsin () end
function TestMatrixSMaps:testAcos () end
function TestMatrixSMaps:testAtan () end
function TestMatrixSMaps:testAsinh() end
function TestMatrixSMaps:testAcosh() end
function TestMatrixSMaps:testAtanh() end
function TestMatrixSMaps:testErf   () end
function TestMatrixSMaps:testTgamma() end
function TestMatrixSMaps:testLgamma() end
function TestMatrixSMaps:testCarg () end
function TestMatrixSMaps:testReal () end
function TestMatrixSMaps:testImag () end
function TestMatrixSMaps:testConj () end
function TestMatrixSMaps:testProj () end
function TestMatrixSMaps:testRect () end
function TestMatrixSMaps:testPolar() end

-- special scans --------------------------------------------------------------o

function TestMatrixSScans:testAccmin    () end
function TestMatrixSScans:testAccmax    () end
function TestMatrixSScans:testAccsum    () end
function TestMatrixSScans:testAccsumabs () end
function TestMatrixSScans:testAccsumsqr () end
function TestMatrixSScans:testAccprod   () end
function TestMatrixSScans:testAccsum    () end
function TestMatrixSScans:testRaccmin   () end
function TestMatrixSScans:testRaccmax   () end
function TestMatrixSScans:testRaccsum   () end
function TestMatrixSScans:testRaccsumabs() end
function TestMatrixSScans:testRaccsumsqr() end
function TestMatrixSScans:testRaccprod  () end

-- special folds --------------------------------------------------------------o

function TestMatrixSFolds:testMin()
  local mref, nr, nc
  for i,m in ipairs(g.mat) do
    nr, nc = m:sizes()
    assertEquals( m:min()     , 1 )
    assertEquals( m:min("vec"), 1 )
    assertEquals( m:min("col"), matrix(1,nc):fill(1..nc) )
    mref = vector(nr) for i=1,nr do mref:seti( i, m:geti((i-1)*nc+1)) end
    assertEquals( m:min("row"), mref )
  end
end

function TestMatrixSFolds:testMax()
  local mref, nr, nc
  for i,m in ipairs(g.mat) do
    nr, nc = m:sizes()
    assertEquals( m:max()     , m:size() )
    assertEquals( m:max("vec"), m:size() )
    assertEquals( m:max("col"), matrix(1,nc):fill((nr-1)*nc+1..m:size()) )
    mref = vector(nr) for i=1,nr do mref:seti( i, m:geti(i*nc) ) end
    assertEquals( m:max("row"), mref )
  end
end

function TestMatrixSFolds:testSum()
  local mref, x, nr, nc
  for i,m in ipairs(g.mat) do
    nr, nc = m:sizes()

    mref = 0 for i=1,m:size() do mref = mref + i end
    assertEquals( m:sum()     , mref )
    mref = vector(nr)   for i=1,nr do x=0 for j=1,nc do x=(i-1)*nc+j + x end mref:seti(i, x) end
    assertEquals( m:sum("row"), mref )
    mref = matrix(1,nc) for i=1,nc do x=0 for j=1,nr do x=(j-1)*nc+i + x end mref:seti(i, x) end
    assertEquals( m:sum("col"), mref )
  end
end

function TestMatrixSFolds:testSumabs()
  local mref, x, nr, nc
  for i,m in ipairs(g.mat) do
    nr, nc = m:sizes()

    mref = 0 for i=1,m:size() do do mref = mref + i end end
    assertEquals( m :sumabs()     ,  mref )
    assertEquals( m :sumabs('vec'),  mref )
    mref = matrix(1,nc) for j=1,nc do x=0; for i=1,nr do x=x+(i-1)*nc+j end mref:seti(j,x) end
    assertEquals( m :sumabs('col'),  mref )
    mref = vector(nr)   for i=1,nr do x=0; for j=1,nc do x=x+(i-1)*nc+j end mref:seti(i,x) end
    assertEquals( m :sumabs('row'),  mref )
  end
end

function TestMatrixSFolds:testSumsqr()
  local mref, x, nr, nc
  for i,m in ipairs(g.mat) do
    nr, nc = m:sizes()

    mref = 0 for i=1,m:size() do mref=i*i+mref end
    assertEquals( m :sumsqr()     ,  mref )
    assertEquals( m :sumsqr('vec'),  mref )
    mref = matrix(1,nc) for j=1,nc do x=0; for i=1,nr do x=x+((i-1)*nc+j)^2 end mref:seti(j,x) end
    assertEquals( m :sumsqr('col'),  mref )
    mref = vector(nr)   for i=1,nr do x=0; for j=1,nc do x=x+((i-1)*nc+j)^2 end mref:seti(i,x) end
    assertEquals( m :sumsqr('row'),  mref )
  end
end

function TestMatrixSFolds:testProduct()
  local mref, x
  for i,m in ipairs(g.mat) do
    nr, nc = m:sizes()
    mref = 1 for i=1,m:size() do mref=i*mref end
    assertEquals( m:product()     , mref )
    assertEquals( m:product('vec'), mref )
    mref = matrix(1,nc) for j=1,nc do x=1; for i=1,nr do x=x*((i-1)*nc+j) end mref:seti(j,x) end
    assertEquals( m :product('col'),  mref )
    mref = vector(nr)   for i=1,nr do x=1; for j=1,nc do x=x*((i-1)*nc+j) end mref:seti(i,x) end
    assertEquals( m :product('row'),  mref )

    if not (nr==5 and nc==5) then
      m    = m:same():fill(m:size()..1..-1 )
      mref = 1 for i=1,m:size() do mref = mref * i end
      assertAlmostEquals( m:product() - mref, 0, eps )
    end
  end
end

function TestMatrixErr:testAll()
  local msg = {
    "invalid argument #2 (callable expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'all', errMat, nil    )
  assertErrorMsgContains( msg[1], mth, 'all', errMat, ''     )
  assertErrorMsgContains( msg[1], mth, 'all', errMat, 1..2   )
  assertErrorMsgContains( msg[1], mth, 'all', errMat, 1      )
  assertErrorMsgContains( msg[1], mth, 'all', errMat, errMat )
  assertErrorMsgContains( msg[1], mth, 'all', errMat, { }    )
end

function TestMatrixSFolds:testAll()
  for i,m in ipairs(g.mat) do
    nr, nc = m:sizes()
    assertFalse ( m:all  \x x> m:size()   )
    assertTrue  ( m:all  \x x< m:size()+1 )
    assertEquals( m:all( \x x>(m:size())/2, 'vec'), m:all \x x>(m:size())/2 )
    assertEquals( m:all( \x x< m:size()+1 , 'vec'), m:all \x x< m:size()+1  )
    if nr>1 then
      assertEquals( m:all( \x x>(m:size())/2, 'col'), matrix(1,nc) )
    else
      mref = matrix(1,nc)
      for i=1,#mref do  if m:geti(i)>(m:size())/2    then mref:seti(i,1) end end
      assertEquals( m:all( \x x>(m:size())/2, 'col'), mref )
    end
    assertEquals( m:all( \x x<m:size()+1  , 'col'), matrix(1,nc):fill(1) )
    mref = vector(nr)
    for i=1,nr do if m:geti((i-1)*nc+1)>(m:size())/2 then mref:seti(i,1) end end
    assertEquals( m:all( \x x>(m:size())/2, 'row'), mref )
    assertEquals( m:all( \x x< m:size()+1 , 'row'), vector(nr):fill(1) )
  end
end

function TestMatrixErr:testAny()
    local msg = {
    "invalid argument #2 (callable expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'any', errMat, nil    )
  assertErrorMsgContains( msg[1], mth, 'any', errMat, ''     )
  assertErrorMsgContains( msg[1], mth, 'any', errMat, 1..2   )
  assertErrorMsgContains( msg[1], mth, 'any', errMat, 1      )
  assertErrorMsgContains( msg[1], mth, 'any', errMat, errMat )
  assertErrorMsgContains( msg[1], mth, 'any', errMat, { }    )
end

function TestMatrixSFolds:testAny() end

-- symplectic matrix ----------------------------------------------------------o

function TestMatrixSympl:testSympinv() end
function TestMatrixSympl:testSymperr() end

-- conjugate, transpose -------------------------------------------------------o

function TestMatrixLinAlg:testTranspose() end
function TestMatrixLinAlg:testTrace() end

-- inner, cross, mixed, outer -------------------------------------------------o

function TestMatrixLinAlg:testInner() end
function TestMatrixLinAlg:testCross() end
function TestMatrixLinAlg:testMixed() end
function TestMatrixLinAlg:testOuter() end

function TestMatrixErr:testInner()
  local msg = {
    "invalid argument #2 (matrix expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'inner', errMat, nil  )
  assertErrorMsgContains( msg[1], mth, 'inner', errMat, ''   )
  assertErrorMsgContains( msg[1], mth, 'inner', errMat, 1    )
  assertErrorMsgContains( msg[1], mth, 'inner', errMat, 1..2 )
  assertErrorMsgContains( msg[1], mth, 'inner', errMat, {}   )
end

function TestMatrixErr:testCross() --TODO: check input(expected size!)
  local m = matrix(3)
  local msg = {
    "invalid argument #2 (matrix expected)",
    "invalid matrix sizes"                 ,
  }
  assertErrorMsgContains( msg[1], mth, 'cross', m     , nil  )
  assertErrorMsgContains( msg[1], mth, 'cross', m     , ''   )
  assertErrorMsgContains( msg[1], mth, 'cross', m     , 1    )
  assertErrorMsgContains( msg[1], mth, 'cross', m     , 1..2 )
  assertErrorMsgContains( msg[1], mth, 'cross', m     , {}   )
  assertErrorMsgContains( msg[2], mth, 'cross', errMat, m    )
end

function TestMatrixErr:testMixed() --TODO: check input(expected size!)
  local msg = {
    "invalid argument #2 (matrix expected)",
    "invalid argument #3 (matrix expected)",
    "invalid matrix sizes"                 ,
    "incompatible matrix sizes"            ,
  }
  local m1 = matrix(3,1)
  assertErrorMsgContains( msg[1], mth, 'mixed', m1, nil  )
  assertErrorMsgContains( msg[1], mth, 'mixed', m1, ''   )
  assertErrorMsgContains( msg[1], mth, 'mixed', m1, 1    )
  assertErrorMsgContains( msg[1], mth, 'mixed', m1, 1..2 )
  assertErrorMsgContains( msg[1], mth, 'mixed', m1, {}   )
  assertErrorMsgContains( msg[2], mth, 'mixed', m1, m1  , nil  )
  assertErrorMsgContains( msg[2], mth, 'mixed', m1, m1  , ''   )
  assertErrorMsgContains( msg[2], mth, 'mixed', m1, m1  , 1    )
  assertErrorMsgContains( msg[2], mth, 'mixed', m1, m1  , 1..2 )
  assertErrorMsgContains( msg[2], mth, 'mixed', m1, m1  , {}   )
  assertErrorMsgContains( msg[3], mth, 'mixed', matrix(2,1), m1, m1 )
  assertErrorMsgContains( msg[4], mth, 'mixed', matrix(3,2), m1, m1 )
  assertErrorMsgContains( msg[4], mth, 'mixed', m1, matrix(2,1), m1 )
  assertErrorMsgContains( msg[4], mth, 'mixed', m1, matrix(3,2), m1 )
  assertErrorMsgContains( msg[4], mth, 'mixed', m1, m1 ,matrix(2,1) )
  assertErrorMsgContains( msg[4], mth, 'mixed', m1, m1 ,matrix(3,2) )
end

function TestMatrixErr:testOuter() --TODO: check input(expected size!)
  local m = matrix(2,1)
  local msg = {
    "invalid argument #2 (matrix expected)",
    "incompatible matrix sizes",
  }
  assertErrorMsgContains( msg[1], mth, 'outer', m          , nil  )
  assertErrorMsgContains( msg[1], mth, 'outer', m          , ''   )
  assertErrorMsgContains( msg[1], mth, 'outer', m          , {}   )
  assertErrorMsgContains( msg[1], mth, 'outer', m          , 1    )
  assertErrorMsgContains( msg[1], mth, 'outer', m          , 1..2 )
  assertErrorMsgContains( msg[2], mth, 'outer', matrix(1,2), matrix(2,2) )
end

-- norm, unit, center, angle (in place) ---------------------------------------o

function TestMatrixLinAlg:testNorm() end
function TestMatrixLinAlg:testDistance() end
function TestMatrixLinAlg:testUnit() end
function TestMatrixLinAlg:testCenter() end
function TestMatrixLinAlg:testAngle() end

function TestMatrixErr:testDistance()
  local msg = {
    "invalid argument #2 (matrix expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'distance', errMat, nil  )
  assertErrorMsgContains( msg[1], mth, 'distance', errMat, 1..2 )
  assertErrorMsgContains( msg[1], mth, 'distance', errMat, ''   )
  assertErrorMsgContains( msg[1], mth, 'distance', errMat, {}   )
end

function TestMatrixErr:testUnit()
  local msg = {
    "null matrix norm",
  }
end

function TestMatrixErr:testAngle()
  local msg = {
    "null vector norm",
  }
end

-- operators ------------------------------------------------------------------o

function TestMatrixOps:testEq() end

function TestMatrixOps:testAddCPx() end

function TestMatrixErr:testAdd()
  local msg = {
    "invalid arguments (unsupported matrix operation)",
  }
end
function TestMatrixOps:testAdd() end

function TestMatrixOps:testSubCPx() end

function TestMatrixErr:testSub()
  local msg = {
    "invalid arguments (unsupported matrix operation)",
  }
end
function TestMatrixOps:testSub() end

function TestMatrixOps:testMulCPx() end

function TestMatrixErr:testMul()
  local msg = {
    "invalid arguments (unsupported matrix operation)",
  }
end
function TestMatrixOps:testMul() end

function TestMatrixErr:testTmul()
  local msg = {
    "invalid arguments (unsupported matrix operation)",
  }
end
function TestMatrixOps:testTmul() end

function TestMatrixOps:testDivCPx() end

function TestMatrixErr:testDiv()
  local msg = {
    "invalid arguments (unsupported matrix operation)",
  }
end
function TestMatrixOps:testDiv() end

function TestMatrixErr:testEmul()
  local msg = {
    "invalid argument #2 (matrix expected)",
  }
end
function TestMatrixOps:testEmul() end

function TestMatrixErr:testEdiv()
  local msg = {
    "invalid argument #2 (matrix expected)",
  }
end
function TestMatrixOps:tetEdiv() end

-- linear algebra -------------------------------------------------------------o

function TestMatrixLapack:testSolve() end
function TestMatrixLapack:testSvd() end

function TestMatrixLapack:testEigen() end
function TestMatrixErr:testEigen()
  local msg = {
    "matrix must be square",
  }
end

-- FFT, convolution, correlation, covrariance ---------------------------------o

function TestMatrixFFT:testFft() end
function TestMatrixFFT:testIfft() end

function TestMatrixErr:testRfft()
  local msg = {
    "incompatible matrix sizes",
  }
end
function TestMatrixFFT:testRfft() end

function TestMatrixErr:testIrfft()
  local msg = {
    "result matrix must be real",
    "incompatible matrix sizes" ,
  }
end
function TestMatrixFFT:testIrfft() end

 -- convolution theorem
function TestMatrixFFT:testConv() end

 -- correlation theorem
function TestMatrixFFT:testCorr() end
function TestMatrixFFT:testCovar() end

-- conversion -----------------------------------------------------------------o

function TestMatrixConv:testTosting()
  local tostring in MAD
  local m, c, r, nr, nc = matrix(2)
  assertTrue( is_string(tostring(m      )) )
  assertTrue( is_string(tostring(m, ''  )) )
  assertTrue( is_string(tostring(m, "\n")) )

  for i,m in ipairs(g.mat) do
    nr, nc = m:sizes()
    c, r = {}, {}
    for i=1,nr do for j=1,nc do c[j]=tostring((i-1)*nc+j) end r[i]=table.concat(c, ' ')  end
    assertEquals( tostring(m      ), table.concat(r, '\n') )
    for i=1,nr do for j=1,nc do c[j]=tostring((i-1)*nc+j) end r[i]=table.concat(c)       end
    assertEquals( tostring(m, ''  ), table.concat(r, '\n') )
    for i=1,nr do for j=1,nc do c[j]=tostring((i-1)*nc+j) end r[i]=table.concat(c, "\n") end
    assertEquals( tostring(m, '\n'), table.concat(r, '\n') )
  end
end

function TestMatrixErr:testTotable()
  local msg = {
    "invalid argument #2 (table expected)"          ,
    "invalid argument #2 (table of tables expected)",
  }
  assertErrorMsgContains( msg[1], totable, errMat, ''     )
  assertErrorMsgContains( msg[1], totable, errMat, 1      )
  assertErrorMsgContains( msg[1], totable, errMat, true   )
  assertErrorMsgContains( msg[1], totable, errMat, 1..2   )
  assertErrorMsgContains( msg[1], totable, errMat, errMat )
  assertErrorMsgContains( msg[2], totable, errMat, {{},5} )
end

function TestMatrixConv:testTotable() -- to be done with foldl
  local m, tref, nr, nc
  assertTrue( is_table(totable( matrix(2))) )

  for i,m in ipairs(g.mat) do
    tref = {}
    nr, nc = m:sizes()
    if  nc ~=1 then
      for i=1,nr do tref[i]={} for j=1,nc do  tref[i][j]=(i-1)*nc+j end end
    else
      for i=1,nr do tref[i]=(i-1)*nc+1 end
    end
    assertEquals( totable( m)        , tref )
    assertEquals( matrix(totable(m )), m    )
  end
end

-- concatenation --------------------------------------------------------------o

function TestMatrixErr:testConcat()
  local msg = {
    "invalid argument #1 (matrix expected)"               ,
    "invalid argument #2 (matrix expected)"               ,
    "incompatible matrix sizes"                           ,
    "invalid argument #3 (string 'row' or 'col' expected)",
  }
end
function TestMatrix:testConcat() end

-- end ------------------------------------------------------------------------o
