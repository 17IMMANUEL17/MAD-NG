--[=[
 o-----------------------------------------------------------------------------o
 |
 | Matrix module regression tests - real matrices
 |
 | Methodical Accelerator Design - Copyright CERN 2015+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: A.Z. Teska, aleksandra.teska at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide regression test suites for the matrix module.

 o-----------------------------------------------------------------------------o
]=]

local assertEquals, assertAlmostEquals, assertTrue, assertFalse,
      assertErrorMsgContains, assertNil, assertNaN, assertIsString, assertInf
      in require 'luaunit'

local vector, cvector, matrix, cmatrix, is_vector, is_matrix, is_cvector,
      is_cmatrix, isa_vector, isa_matrix, linspace, logspace in MAD

local complex, range, nrange, nlogrange,infi, tiny, eps, huge, inf, nan, pi, Pi,
      randomseed, abs, log, min, totable, is_complex, is_cdata, is_table,
      is_nil, is_string in MAD

-- locals ---------------------------------------------------------------------o

local mth = \f,s,... s[f](s,...)

local values = {
  num = { tiny, 2^-64, 2^-63, 2^-53, eps, 2^-52, 2*eps, 2^-32, 2^-31, 1e-9,
          0.1-eps, 0.1, 0.1+eps, 0.5, 0.7-eps, 0.7, 0.7+eps, 1-eps, 1, 1+eps,
          1.1, 1.7, 2, 10, 1e2, 1e3, 1e6, 1e9, 2^31, 2^32, 2^52, 2^53,
          2^63, 2^64, huge },
}

local s = {}

s.mat   = {}
s.size  = {}
s.empty = {}
for nr=1,5 do
  for nc=1,5 do
    s.mat  [(nr-1)*5+nc] = matrix(nr,nc):fill(1..nr*nc)
    s.empty[(nr-1)*5+nc] = matrix(nr,nc)
    s.size [(nr-1)*5+nc] = {nr,nc}
  end
end

-- regression test suites -----------------------------------------------------o

TestMatrix    = {}
TestMatrixErr = {}

TestMatrixGet = {}
TestMatrixSet = {}

TestMatrixInPlace = {}
TestMatrixFun     = {}

TestMatrixSMaps  = {}
TestMatrixSFolds = {}
TestMatrixSScans = {}

TestMatrixSympl  = {}
TestMatrixLinAlg = {}
TestMatrixOp     = {}
TestMatrixLapack = {}
TestMatrixFFT    = {}


function TestMatrixErr:setUp()
  self.m  = matrix(2)
end

function TestMatrixErr:testCtor()
    local msg = {
  "invalid argument #1 or #2 (nrow[,ncol] >=1 or table [of tables] expected)",
   "matrix too large",
  }
  assertErrorMsgContains( msg[1], matrix, ''     )
  assertErrorMsgContains( msg[1], matrix, nil    )
  assertErrorMsgContains( msg[1], matrix, 0      )
  assertErrorMsgContains( msg[1], matrix, tiny   )
  assertErrorMsgContains( msg[1], matrix, eps    )
  assertErrorMsgContains( msg[1], matrix, 1..2   )
  assertErrorMsgContains( msg[1], matrix, infi   )
  assertErrorMsgContains( msg[1], matrix, nan    )
  assertErrorMsgContains( msg[1], matrix,-1      )
  assertErrorMsgContains( msg[1], matrix,-eps    )
  assertErrorMsgContains( msg[2], matrix, inf    )
  assertErrorMsgContains( msg[2], matrix, huge   )
  assertErrorMsgContains( msg[2], matrix, 2^15+1 )
  assertErrorMsgContains( msg[2], vector, 2^30+1 )
  --assertTrue( is_matrix( vector(2^30)) )
  --assertTrue( is_matrix( matrix(2^15)) )
end

function TestMatrix:testCtor()
end

function TestMatrixErr:testCtorFromtable()
  local msg = {
  "invalid argument #1 (non-empty table expected)",
  "cannot convert 'string' to 'double'"           ,
  "cannot convert 'string' to 'complex'"          ,
  }
  assertErrorMsgContains( msg[1],  matrix, {nil} )
  assertErrorMsgContains( msg[2],  matrix, {''}  )
end

function TestMatrix:testCtorFromtable() --TODO
end

function TestMatrix:testCdataType()
  local m, v, m1 = matrix(2), vector(2), matrix(1)
  assertTrue ( is_matrix ( m ) )
  assertTrue ( is_matrix ( v ) )
  assertFalse( is_vector ( m ) )
  assertTrue ( is_vector ( v ) )
  assertFalse( is_cmatrix( m ) )
  assertFalse( is_cmatrix( v ) )
  assertFalse( is_cvector( m ) )
  assertFalse( is_cvector( v ) )
  assertFalse( isa_vector( m ) )
  assertTrue ( isa_vector( v ) )
  assertTrue ( isa_matrix( m ) )
  assertTrue ( isa_matrix( v ) )
end

function TestMatrixErr:testLinspace()
  local msg = {
    "invalid argument #1 (finite scalar expected)"  ,
    "invalid argument #2 (finite scalar expected)"  ,
    "invalid argument #3 (positive number expected)",
    "bad argument #1 to 'ceil'"                     ,
    "matrix too large"                              ,
  }
  assertErrorMsgContains( msg[1], linspace, nil       )
  assertErrorMsgContains( msg[1], linspace, nil, 2    )
  assertErrorMsgContains( msg[1], linspace, '' , 2    )
  assertErrorMsgContains( msg[1], linspace, nan, 2    )
  assertErrorMsgContains( msg[1], linspace, inf, 2    )
  assertErrorMsgContains( msg[1], linspace,-inf, 2    )
  assertErrorMsgContains( msg[2], linspace, 2  , ''   )
  assertErrorMsgContains( msg[2], linspace, 2  , 1..2 )
  assertErrorMsgContains( msg[2], linspace, 2  , nan  )
  assertErrorMsgContains( msg[2], linspace, 2  , inf  )
  assertErrorMsgContains( msg[2], linspace, 2  ,-inf  )
  assertErrorMsgContains( msg[2], linspace, 2  , 1..2 )
  assertErrorMsgContains( msg[3], linspace, 2  , 2  , 0    )
  assertErrorMsgContains( msg[3], linspace, 2  , 2  ,-1    )
  assertErrorMsgContains( msg[3], linspace, 2  , 2  , nan  )
  assertErrorMsgContains( msg[5], linspace, 2  , 2  , inf  )
  assertErrorMsgContains( msg[3], linspace, 2  , 2  ,-inf  )
  assertErrorMsgContains( msg[4], linspace, 2  , 2  , ''   )
  assertErrorMsgContains( msg[4], linspace, 2  , 2  , 1..2 )
end

function TestMatrix:testLinspace() end

function TestMatrixErr:testLogspace()
  local msg = {
    "invalid argument #1 (positive finite number expected)",
    "invalid argument #2 (positive finite number expected)",
    "invalid argument #3 (positive number expected)"       ,
    "bad argument #1 to 'ceil'"                            ,
  }
  assertErrorMsgContains( msg[1], logspace, 0          )
  assertErrorMsgContains( msg[1], logspace, nil        )
  assertErrorMsgContains( msg[1], logspace, nil , 1    )
  assertErrorMsgContains( msg[1], logspace, ''  , 1    )
  assertErrorMsgContains( msg[1], logspace, 1..2, 2    )
  assertErrorMsgContains( msg[1], logspace, nan , 2    )
  assertErrorMsgContains( msg[1], logspace, inf , 2    )
  assertErrorMsgContains( msg[1], logspace,-inf , 2    )
  assertErrorMsgContains( msg[2], logspace, 1   , ''   )
  assertErrorMsgContains( msg[2], logspace, 2   , 1..2 )
  assertErrorMsgContains( msg[2], logspace, 2   , nan  )
  assertErrorMsgContains( msg[2], logspace, 2   , inf  )
  assertErrorMsgContains( msg[2], logspace, 2   ,-inf  )
  assertErrorMsgContains( msg[3], logspace, 2   , 2  ,-1    )
  assertErrorMsgContains( msg[3], logspace, 2   , 2  , 0    )
  assertErrorMsgContains( msg[3], logspace, 2   , 2  , nan  )
  assertErrorMsgContains( msg[3], logspace, 2   , 2  ,-inf  )
  assertErrorMsgContains( msg[4], logspace, 2   , 2  , ''   )
  assertErrorMsgContains( msg[4], logspace, 2   , 2  , 1..2 )
end

function TestMatrix:testLogspace() end

function TestMatrixErr:testSame()
  local msg, s = {
    "invalid argument #1 or #2 (nrow[,ncol] >=1 or table [of tables] expected)",
    "invalid argument #1 (non-empty table expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'same', self.m, 1, ''   )
  assertErrorMsgContains( msg[1], mth, 'same', self.m, 1, 1..2 )
  assertErrorMsgContains( msg[1], mth, 'same', self.m, 1, nan  )
  assertErrorMsgContains( msg[2], mth, 'same', self.m, 1, {}   )
end

function TestMatrix:testSame() end

function TestMatrix:testTosting()
  local tostring in MAD
  local c, r
  assertTrue( is_string(tostring(matrix(2)       )) )
  assertTrue( is_string(tostring(matrix(2) , ''  )) )
  assertTrue( is_string(tostring(matrix(2) , "\n")) )

  for i,m in ipairs(s.mat) do
    c, r = {}, {}
    for i=1,m.nr do for j=1,m.nc do c[j]=tostring((i-1)*m.nc+j) end r[i]=table.concat(c, ' ')  end
    assertEquals( tostring(m      ), table.concat(r, '\n') )
    for i=1,m.nr do for j=1,m.nc do c[j]=tostring((i-1)*m.nc+j) end r[i]=table.concat(c)       end
    assertEquals( tostring(m, ''  ), table.concat(r, '\n') )
    for i=1,m.nr do for j=1,m.nc do c[j]=tostring((i-1)*m.nc+j) end r[i]=table.concat(c, "\n") end
    assertEquals( tostring(m, '\n'), table.concat(r, '\n') )
  end
end

-- conversion -----------------------------------------------------------------o

function TestMatrixErr:testTotable()
  local msg = {
    "invalid argument #2 (table expected)"          ,
    "invalid argument #2 (table of tables expected)",
  }
  assertErrorMsgContains( msg[1], totable, self.m, ''     )
  assertErrorMsgContains( msg[1], totable, self.m, 1      )
  assertErrorMsgContains( msg[1], totable, self.m, true   )
  assertErrorMsgContains( msg[1], totable, self.m, 1..2   )
  assertErrorMsgContains( msg[1], totable, self.m, self.m )
  assertErrorMsgContains( msg[2], totable, self.m, {{},5} )
end

function TestMatrix:testTotable()
  local m, tref
  assertTrue( is_table(totable( matrix(2))) )

  for i,m in ipairs(s.mat) do
    tref = {}
    if  m.nc ~=1 then
      for i=1,m.nr do tref[i]={} for j=1,m.nc do  tref[i][j]=(i-1)*m.nc+j end end
    else
      for i=1,m.nr do tref[i]=(i-1)*m.nc+1 end
    end
    assertEquals( totable( m)        , tref )
    assertEquals( matrix(totable(m )), m    )
  end
end

-- get, set -------------------------------------------------------------------o

function TestMatrixSet:setUp()
  self.mat   = {}
  self.empty = {}
  for nr=1,5 do
    for nc=1,5 do
      self.mat  [(nr-1)*5+nc] = matrix(nr,nc):fill(1..nr*nc)
      self.empty[(nr-1)*5+nc] = matrix(nr,nc)
    end
  end
end

function TestMatrixErr:testGeti0()
  local msg = {
    "attempt to compare nil with number",
    }
  assertErrorMsgContains( msg[1], mth, 'geti0', self.m, nil )
end
function TestMatrixGet:testGeti0() end


function TestMatrixErr:testGeti()
local msg = {
    "attempt to compare nil with number",
    }
  assertErrorMsgContains( msg[1], mth, 'geti', self.m, nil )
end
function TestMatrixGet:testGeti()    end

function TestMatrixErr:testGet0()
  local msg = {
    "attempt to compare nil with number",
    }
  assertErrorMsgContains( msg[1], mth, 'get0', self.m, 0  , nil )
  assertErrorMsgContains( msg[1], mth, 'get0', self.m, nil, 0   )
end
function TestMatrixGet:testGet0()    end

function TestMatrixErr:testGet()
  local msg = {
    "attempt to compare nil with number",
    }
  assertErrorMsgContains( msg[1], mth, 'get0', self.m, 1  , nil )
  assertErrorMsgContains( msg[1], mth, 'get0', self.m, nil, 1   )
end
function TestMatrixGet:testGet()    end

function TestMatrixErr:testSeti0()
  local msg = {
    "0-index out of bounds"             ,
    "attempt to compare nil with number",
    }
  assertErrorMsgContains( msg[1], mth, 'seti0', self.m, nan  , 1 )
  assertErrorMsgContains( msg[1], mth, 'seti0', self.m,-1    , 1 )
  assertErrorMsgContains( msg[1], mth, 'seti0', self.m,-eps  , 1 )
  assertErrorMsgContains( msg[1], mth, 'seti0', self.m, 4    , 1 )
  assertErrorMsgContains( msg[2], mth, 'seti0', self.m, nil  , 1 )
end
function TestMatrixSet:testSeti0() end

function TestMatrixErr:testSeti()
  local msg = {
    "1-index out of bounds"             ,
    "attempt to compare nil with number",
    }
  assertErrorMsgContains( msg[1], mth, 'seti', self.m, nan  , 1 )
  assertErrorMsgContains( msg[1], mth, 'seti', self.m, 0    , 1 )
  assertErrorMsgContains( msg[1], mth, 'seti', self.m, 1-eps, 1 )
  assertErrorMsgContains( msg[1], mth, 'seti', self.m, 5    , 1 )
  assertErrorMsgContains( msg[2], mth, 'seti', self.m, nil  , 1 )
end
function TestMatrixSet:testSeti() end

function TestMatrixErr:testSet0()
  local msg = {
    "0-index out of bounds"             ,
    "attempt to compare nil with number",
    }
  assertErrorMsgContains( msg[1], mth, 'set0', self.m, nan  , 1    , 1 )
  assertErrorMsgContains( msg[1], mth, 'set0', self.m,-1    , 0    , 1 )
  assertErrorMsgContains( msg[1], mth, 'set0', self.m,-1+eps, 0    , 1 )
  assertErrorMsgContains( msg[1], mth, 'set0', self.m, 0    ,-1+eps, 1 )
  assertErrorMsgContains( msg[1], mth, 'set0', self.m, 2    , 1    , 1 )
  assertErrorMsgContains( msg[1], mth, 'set0', self.m, 1    , 2    , 1 )
  assertErrorMsgContains( msg[2], mth, 'set0', self.m, nil  , 1    , 1 )
  assertErrorMsgContains( msg[2], mth, 'set0', self.m, 1    , nil  , 1 )
end
function TestMatrixSet:testSet0() end

function TestMatrixErr:testSet()
  local msg = {
    "1-index out of bounds"             ,
    "attempt to compare nil with number",
    }
  assertErrorMsgContains( msg[1], mth, 'set', self.m, nan  , 1    , 1 )
  assertErrorMsgContains( msg[1], mth, 'set', self.m, 0    , 1    , 1 )
  assertErrorMsgContains( msg[1], mth, 'set', self.m, 1    , 0    , 1 )
  assertErrorMsgContains( msg[1], mth, 'set', self.m, 1-eps, 1    , 1 )
  assertErrorMsgContains( msg[1], mth, 'set', self.m, 1    , 1-eps, 1 )
  assertErrorMsgContains( msg[2], mth, 'set', self.m, nil  , 1    , 1 )
end
function TestMatrixSet:testSet() end

-- getx, setx -----------------------------------------------------------------o

function TestMatrixErr:testGetsub()
  local msg = {
    "invalid argument #2 (iterable expected)"   ,
    "invalid argument #3 (iterable expected)"   ,
    "invalid argument #4 (iterable expected)"   ,
    "invalid range member '1'"                  ,
    "cannot convert 'nil' to 'double'"          ,
    }
  assertErrorMsgContains( msg[1], mth, 'getsub', self.m, nil          )
  assertErrorMsgContains( msg[1], mth, 'getsub', self.m, ''           )
  assertErrorMsgContains( msg[1], mth, 'getsub', self.m, \x x         )
  assertErrorMsgContains( msg[1], mth, 'getsub', self.m, complex(1,1) )
  assertErrorMsgContains( msg[2], mth, 'getsub', self.m, 1   , nil    )
  assertErrorMsgContains( msg[2], mth, 'getsub', self.m, 1   , ''     )
  assertErrorMsgContains( msg[2], mth, 'getsub', self.m, 1   , \x x   )
  assertErrorMsgContains( msg[5], mth, 'getsub', self.m, 0   , 0      )
  assertErrorMsgContains( msg[5], mth, 'getsub', self.m, 3   , 1      )
  assertErrorMsgContains( msg[5], mth, 'getsub', self.m, 1   , 3      )
  assertErrorMsgContains( msg[5], mth, 'getsub', self.m, 0   , 1      )
  assertErrorMsgContains( msg[5], mth, 'getsub', self.m, 1   , 0      )
  assertErrorMsgContains( msg[3], mth, 'getsub', self.m, 0   , 0   , 1    )
  assertErrorMsgContains( msg[3], mth, 'getsub', self.m, 1   , 1   , \x x )
  assertErrorMsgContains( msg[4], mth, 'getsub', self.m, 1   , 1   , 1..4 )
end
function TestMatrixGet:testGetsub() end

function TestMatrixErr:testSetsub()
  local msg = {
    "invalid argument #2 (iterable expected)"          ,
    "invalid argument #3 (iterable expected)"          ,
    "invalid argument #4 (scalar or iterable expected)",
    "1-index out of bounds"                            ,
  }
  assertErrorMsgContains( msg[1], mth, 'setsub', self.m, nil , 1  , 1  )
  assertErrorMsgContains( msg[1], mth, 'setsub', self.m, ''  , 1  , 1  )
  assertErrorMsgContains( msg[1], mth, 'setsub', self.m, NaN , 1  , 1  )
  assertErrorMsgContains( msg[1], mth, 'setsub', self.m, \x x, 1  , 1  )
  assertErrorMsgContains( msg[2], mth, 'setsub', self.m, 1             )
  assertErrorMsgContains( msg[2], mth, 'setsub', self.m, 1   , nil, 1  )
  assertErrorMsgContains( msg[2], mth, 'setsub', self.m, 1   , '' , 1  )
  assertErrorMsgContains( msg[2], mth, 'setsub', self.m, 1   , NaN, 1  )
  assertErrorMsgContains( msg[3], mth, 'setsub', self.m, 1   , 1 , nil )
  assertErrorMsgContains( msg[3], mth, 'setsub', self.m, 1   , 1 , ''  )
  assertErrorMsgContains( msg[3], mth, 'setsub', self.m, 1   , 1 , NaN )
  assertErrorMsgContains( msg[4], mth, 'setsub', self.m, 0   , 1 , 1   )
  assertErrorMsgContains( msg[4], mth, 'setsub', self.m, 1   , 0 , 1   )
  assertErrorMsgContains( msg[1], mth, 'setsub', self.m, complex(1,1), 1 , 1 )
  assertErrorMsgContains( msg[2], mth, 'setsub', self.m, 1 , complex(1,1), 1 )
end
function TestMatrixSet:testSetsub() end

function TestMatrixErr:testGetv()
  local msg = {
    "invalid argument #2 (iterable expected)",
    "invalid argument #3 (iterable expected)",
    "cannot convert 'nil' to 'double"        ,
    "invalid range member '1'"               ,
  }
  assertErrorMsgContains( msg[1], mth, 'getv', self.m, nil )
  assertErrorMsgContains( msg[1], mth, 'getv', self.m, ''  )
  assertErrorMsgContains( msg[1], mth, 'getv', self.m, NaN )
  assertErrorMsgContains( msg[2], mth, 'getv', self.m, 1  , ''   )
  assertErrorMsgContains( msg[2], mth, 'getv', self.m, 1  , 1    )
  assertErrorMsgContains( msg[2], mth, 'getv', self.m, 1  , \x x )
  assertErrorMsgContains( msg[3], mth, 'getv', self.m, 0         )
  assertErrorMsgContains( msg[3], mth, 'getv', self.m, matrix(2) )
  assertErrorMsgContains( msg[4], mth, 'getv', self.m, 1  , 1..2 )
end
function TestMatrixGet:testGetv() end

function TestMatrixErr:testSetv()
  local msg = {
    "invalid argument #2 (iterable expected)"          ,
    "invalid argument #3 (scalar or iterable expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'setv', self.m, nil , 0    )
  assertErrorMsgContains( msg[1], mth, 'setv', self.m, ''  , 0    )
  assertErrorMsgContains( msg[1], mth, 'setv', self.m, NaN , 0    )
  assertErrorMsgContains( msg[1], mth, 'setv', self.m, \x x, 0    )
  assertErrorMsgContains( msg[2], mth, 'setv', self.m, 1   , ''   )
  assertErrorMsgContains( msg[2], mth, 'setv', self.m, 1   , nil  )
  assertErrorMsgContains( msg[2], mth, 'setv', self.m, 1   , NaN  )
  assertErrorMsgContains( msg[2], mth, 'setv', self.m, 1   , \x x )
end
function TestMatrixSet:testSetv() end

function TestMatrixErr:testGetdiag()
  local msg = {
    "invalid argument #2 (iterable expected)",
    "invalid range member '1'"               ,
  }
  assertErrorMsgContains( msg[1], mth, 'getdiag', self.m, ''   )
  assertErrorMsgContains( msg[1], mth, 'getdiag', self.m, \x x )
  assertErrorMsgContains( msg[1], mth, 'getdiag', self.m, 1    )
  assertErrorMsgContains( msg[2], mth, 'getdiag', self.m, 1..2 )
end
function TestMatrixGet:testGetdiag() end

function TestMatrixErr:testSetdiag()
  local msg = {
    "invalid argument #2 (scalar or iterable expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'setdiag', self.m, nil  )
  assertErrorMsgContains( msg[1], mth, 'setdiag', self.m, ''   )
  assertErrorMsgContains( msg[1], mth, 'setdiag', self.m, \x x )
end
function TestMatrixSet:testSetdiag()end

function TestMatrixErr:testGetrow()
  local msg = {
    "invalid argument #2 (iterable expected)",
    "invalid argument #3 (iterable expected)",
    "cannot convert 'nil' to 'double'"       ,
    "invalid range member '1'"               ,
    "1-index out of bounds"                  ,
    }
  assertErrorMsgContains( msg[1], mth, 'getrow', self.m, ''         )
  assertErrorMsgContains( msg[1], mth, 'getrow', self.m, nil        )
  assertErrorMsgContains( msg[1], mth, 'getrow', self.m, NaN        )
  assertErrorMsgContains( msg[1], mth, 'getrow', self.m, \x x       )
  assertErrorMsgContains( msg[2], mth, 'getrow', self.m, 1   , ''   )
  assertErrorMsgContains( msg[2], mth, 'getrow', self.m, 1   , 1    )
  assertErrorMsgContains( msg[3], mth, 'getrow', self.m, 0          )
  assertErrorMsgContains( msg[3], mth, 'getrow', self.m, 5          )
  assertErrorMsgContains( msg[4], mth, 'getrow', self.m, 1   , 1..2 )
  assertErrorMsgContains( msg[5], mth, 'getrow', self.m, 1   , vector(1) )
end
function TestMatrixGet:testGetrow()end

function TestMatrixErr:testSetrow()
  local msg = {
    "invalid argument #2 (iterable expected)"          ,
    "invalid argument #3 (scalar or iterable expected)",
    "1-index out of bounds"                            ,
    "cannot convert 'nil' to 'double'"                 ,
  }
  assertErrorMsgContains( msg[1], mth, 'setrow', self.m, ''        )
  assertErrorMsgContains( msg[1], mth, 'setrow', self.m, nil       )
  assertErrorMsgContains( msg[1], mth, 'setrow', self.m, NaN       )
  assertErrorMsgContains( msg[1], mth, 'setrow', self.m, \x x      )
  assertErrorMsgContains( msg[2], mth, 'setrow', self.m, 1   , nil )
  assertErrorMsgContains( msg[2], mth, 'setrow', self.m, 1   , ''  )
  assertErrorMsgContains( msg[3], mth, 'setrow', self.m, 0   , 1   )
  assertErrorMsgContains( msg[3], mth, 'setrow', self.m, 3   , 1   )
  assertErrorMsgContains( msg[4], mth, 'setrow', self.m, 1   , matrix(1) )
  assertErrorMsgContains( msg[4], mth, 'setrow', matrix(3), 1 ,1..2  )   --CHECK FOR BETTER SOLUTION
  assertErrorMsgContains( msg[4], mth, 'setrow', matrix(3), 1 ,{1,2} )   --CHECK
end
function TestMatrixSet:testSetrow()end

function TestMatrixErr:testGetcol()
  local msg = {
    "invalid argument #2 (iterable expected)",
    "invalid argument #3 (iterable expected)",
    "cannot convert 'nil' to 'double'"       ,
    "invalid range member '1'"               ,
    "1-index out of bounds"                  ,
  }
  assertErrorMsgContains( msg[1], mth, 'getcol', self.m, ''   )
  assertErrorMsgContains( msg[1], mth, 'getcol', self.m, nil  )
  assertErrorMsgContains( msg[1], mth, 'getcol', self.m, NaN  )
  assertErrorMsgContains( msg[1], mth, 'getcol', self.m, \x x )
  assertErrorMsgContains( msg[2], mth, 'getcol', self.m, 1   , ''   )
  assertErrorMsgContains( msg[2], mth, 'getcol', self.m, 1   , 1    )
  assertErrorMsgContains( msg[3], mth, 'getcol', self.m, 0          )
  assertErrorMsgContains( msg[3], mth, 'getcol', self.m, 3          )
  assertErrorMsgContains( msg[4], mth, 'getcol', self.m, 1   , 1..2 )
  assertErrorMsgContains( msg[5], mth, 'getcol', self.m, 1   , vector(1) )
end
function TestMatrixGet:testGetcol()end

function TestMatrixErr:testSetcol()
  local msg = {
    "invalid argument #2 (iterable expected)"          ,
    "invalid argument #3 (scalar or iterable expected)",
    "1-index out of bounds"                            ,
    "cannot convert 'nil' to 'double'"                 ,
  }
  assertErrorMsgContains( msg[1], mth, 'setcol', self.m, ''         )
  assertErrorMsgContains( msg[1], mth, 'setcol', self.m, nil        )
  assertErrorMsgContains( msg[1], mth, 'setcol', self.m, NaN        )
  assertErrorMsgContains( msg[1], mth, 'setcol', self.m, \x x       )
  assertErrorMsgContains( msg[2], mth, 'setcol', self.m, 1   ,  ''  )
  assertErrorMsgContains( msg[2], mth, 'setcol', self.m, 1   ,  nil )
  assertErrorMsgContains( msg[3], mth, 'setcol', self.m, 0   ,  1   )
  assertErrorMsgContains( msg[3], mth, 'setcol', self.m, 3   ,  1   )
  assertErrorMsgContains( msg[4], mth, 'setcol', self.m, 1   ,  matrix(1) )
  assertErrorMsgContains( msg[4], mth, 'setcol', matrix(3), 1,  1..2  ) --CHECK
  assertErrorMsgContains( msg[4], mth, 'setcol', matrix(3), 1,  {1,2} ) --CHECK
end
function TestMatrixSet:testSetcol()end

-- size, same -----------------------------------------------------------------o

function TestMatrix:testNrow()
  for i,m in ipairs(s.mat) do
    assertEquals( m:nrow(), s.size[i][1] )
  end
end

function TestMatrix:testNcol()
  for i,m in ipairs(s.mat) do
    assertEquals( m:ncol(), s.size[i][2] )
  end
end

function TestMatrix:testSize()
  for i,m in ipairs(s.mat) do
    assertEquals( m:size(), s.size[i][1]*s.size[i][2] )
  end
end

function TestMatrix:testSizes()
  for i,m in ipairs(s.mat) do
    assertEquals( {m:sizes()}, s.size[i] )
  end
end

function TestMatrix:testTsizes()
  for i,m in ipairs(s.mat) do
    assertEquals( {m:tsizes()}, {s.size[i][2], s.size[i][1]} )
  end
end

function TestMatrixInPlace:setUp()
  self.mat   = {}
  for nr=1,5 do
    for nc=1,5 do
      self.mat  [(nr-1)*5+nc] = matrix(nr,nc):fill(1..nr*nc)
    end
  end
end

function TestMatrixErr:testRandom()
  local msg, s = {
    "invalid argument #1 or #2 (nrow[,ncol] >=1 or table [of tables] expected)",
    "invalid argument #1 (non-empty table expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'same', self.m, 1, ''   )
  assertErrorMsgContains( msg[1], mth, 'same', self.m, 1, 1..2 )
  assertErrorMsgContains( msg[1], mth, 'same', self.m, 1, nan  )
  assertErrorMsgContains( msg[2], mth, 'same', self.m, 1, {}   )
end
function TestMatrixInPlace:testRandom() end

function TestMatrixErr:testFill()
  local msg = {
    "invalid argument #2 (scalar, callable or indexable expected)",
    "incompatible container size"                                 ,
    "invalid container (iterable expected)"                       ,
    }
  assertErrorMsgContains( msg[1], mth,'fill', self.m, nil  )
  assertErrorMsgContains( msg[1], mth,'fill', self.m, true )
  assertErrorMsgContains( msg[2], mth,'fill', self.m, {}   )
end
function TestMatrixInPlace:testFill() end

function TestMatrixErr:testCopy()
  local msg = {
    "invalid argument #1 (matrix expected",
  }
  assertErrorMsgContains( msg[1], mth,'copy', self.m,  1         )
end
function TestMatrix:testCopy() end --think about puting in one of test-suits

function TestMatrixInPlace:testZeros()
  local m1
  for _,m in ipairs(self.mat) do
    m1 = m:zeros()
    for i=1,m:size() do assertEquals( m1:geti(i), 0 ) end
  end
end

function TestMatrixInPlace:testOnes()
  for _,m in ipairs(self.mat) do
    m:ones()
    for i=1,m:size() do assertEquals( m:geti(i), 1 ) end
  end
end

function TestMatrixInPlace:testEye()
  for i,m in ipairs(self.mat) do
    m:eye()
    for i=1,m.nr do
    for j=1,m.nc do
      if i==j then assertEquals( m:get(i,j), 1 )
      else         assertEquals( m:get(i,j), 0 ) end
    end end
  end
end

function TestMatrixErr:testSymp()
  local msg = {
    "invalid argument #1 (2n matrix expected)",
  }
  assertErrorMsgContains( msg[1], mth,'symp',  matrix(3)   ) --CHECK
  assertErrorMsgContains( msg[1], mth,'symp',  vector(2)   ) --CHECK
  assertErrorMsgContains( msg[1], mth,'symp',  matrix(4,3) ) --CHECK
end
function TestMatrix:testSymp() end

function TestMatrixErr:testCirc()
  local msg = {
    "invalid argument #2 (iterable expected)",
  }
  assertErrorMsgContains( msg[1], mth,'circ', self.m, nil  )
  assertErrorMsgContains( msg[1], mth,'circ', self.m, 1    )
  assertErrorMsgContains( msg[1], mth,'circ', self.m, \x x )
end
function TestMatrix:testCirc() end

function TestMatrixErr:testReshape()
  local msg, m, s = {
    "invalid matrix new sizes",
    }
  assertErrorMsgContains( msg[1], mth,'reshape', self.m, 3, 3  )
  assertErrorMsgContains( msg[1], mth,'reshape', self.m, 1, 5  )
  assertErrorMsgContains( msg[1], mth,'reshape', self.m, 0, 2  )
  assertErrorMsgContains( msg[1], mth,'reshape', self.m, 1, 0  )
end
function TestMatrixInPlace:testReshape() end

-- foreach, filter, map, fold, scan -------------------------------------------o

function TestMatrixErr:testForeach()
  local msg = {
    "invalid argument #2 (callable expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'foreach', self.m, nil       )
  assertErrorMsgContains( msg[1], mth, 'foreach', self.m, ''        )
  assertErrorMsgContains( msg[1], mth, 'foreach', self.m, 1         )
  assertErrorMsgContains( msg[1], mth, 'foreach', self.m, 1..2      )
  assertErrorMsgContains( msg[1], mth, 'foreach', self.m, matrix(1) )
  assertErrorMsgContains( msg[1], mth, 'foreach', self.m, { }       )
end
function TestMatrixFun:testForeach() end

function TestMatrixErr:testMap()
  local msg = {
    "invalid argument #2 (callable expected)"                 ,
    "invalid argument #3 (iterable expected)"                 ,
    "invalid range member '1'"                                ,
    "attempt to perform arithmetic on local 'x' (a nil value)",
  }
  assertErrorMsgContains( msg[1], mth, 'map', self.m, ''           )
  assertErrorMsgContains( msg[1], mth, 'map', self.m, 1..2         )
  assertErrorMsgContains( msg[1], mth, 'map', self.m, 1            )
  assertErrorMsgContains( msg[1], mth, 'map', self.m, matrix(1)    )
  assertErrorMsgContains( msg[1], mth, 'map', self.m, { }          )
  assertErrorMsgContains( msg[2], mth, 'map', self.m, \x x+1, ''   )
  assertErrorMsgContains( msg[2], mth, 'map', self.m, \x x+1, 1    )
  assertErrorMsgContains( msg[3], mth, 'map', self.m, \x x+1, 1..2 )
end
function TestMatrixFun:testMap() end

function TestMatrixErr:testMap2()
  local msg = {
    "invalid argument #2 (scalar or iterable expected)"       ,
    "invalid argument #3 (callable expected)"                 ,
    "invalid argument #4 (iterable expected)"                 ,
    "invalid range member '1'"                                ,
    "attempt to perform arithmetic on local 'y' (a nil value)",
  }
  assertErrorMsgContains( msg[1], mth, 'map2', self.m, nil  )
  assertErrorMsgContains( msg[1], mth, 'map2', self.m, ''   )
  assertErrorMsgContains( msg[1], mth, 'map2', self.m, NaN  )
  assertErrorMsgContains( msg[1], mth, 'map2', self.m, \x x )
  assertErrorMsgContains( msg[2], mth, 'map2', self.m, matrix(1), nil  )
  assertErrorMsgContains( msg[2], mth, 'map2', self.m, matrix(1), 1..2 )
  assertErrorMsgContains( msg[2], mth, 'map2', self.m, matrix(1), 1    )
  assertErrorMsgContains( msg[3], mth, 'map2', self.m, matrix(1), \x x, 1    )
  assertErrorMsgContains( msg[4], mth, 'map2', self.m, matrix(1), \x x, 1..2 )
  assertErrorMsgContains( msg[5], mth, 'map2', self.m, matrix(1), \x,y  x+y  )
end
function TestMatrixFun:testMap2() end

function TestMatrixErr:testMap3()
  local m = self.m
  local msg = {
    "invalid argument #2 (scalar or iterable expected)"       ,
    "invalid argument #3 (scalar or iterable expected)"       ,
    "invalid argument #4 (callable expected)"                 ,
    "invalid argument #5 (iterable expected)"                 ,
    "invalid range member '1'"                                ,
    "attempt to perform arithmetic on local 'y' (a nil value)",
    "attempt to perform arithmetic on local 'z' (a nil value)",
  }
  assertErrorMsgContains( msg[1], mth, 'map3', m, ''   )
  assertErrorMsgContains( msg[1], mth, 'map3', m, NaN  )
  assertErrorMsgContains( msg[1], mth, 'map3', m, \x x )
  assertErrorMsgContains( msg[2], mth, 'map3', m, m    , ''   )
  assertErrorMsgContains( msg[2], mth, 'map3', m, m    , NaN  )
  assertErrorMsgContains( msg[2], mth, 'map3', m, m    , \x x )
  assertErrorMsgContains( msg[3], mth, 'map3', m, m    , m    , nil  )
  assertErrorMsgContains( msg[3], mth, 'map3', m, m    , m    , 1..2 )
  assertErrorMsgContains( msg[3], mth, 'map3', m, m    , m    , 1    )
  assertErrorMsgContains( msg[4], mth, 'map3', m, m    , m    , \x x, 1    )
  assertErrorMsgContains( msg[5], mth, 'map3', m, m    , m    , \x x, 1..2 )
  assertErrorMsgContains( msg[6], mth, 'map3', m, matrix(1), m        , \x,y,z x+y+z )
  assertErrorMsgContains( msg[6], mth, 'map3', m, matrix(1), matrix(1), \x,y,z x+y+z )
  assertErrorMsgContains( msg[7], mth, 'map3', m, m        , matrix(1), \x,y,z x+y+z )
end
function TestMatrixFun:testMap3() end

function TestMatrixErr:testMapij()
  local msg = {
    "invalid argument #2 (callable expected)",
    "invalid argument #3 (iterable expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'mapij', self.m, nil       )
  assertErrorMsgContains( msg[1], mth, 'mapij', self.m, ''        )
  assertErrorMsgContains( msg[1], mth, 'mapij', self.m, 1..2      )
  assertErrorMsgContains( msg[1], mth, 'mapij', self.m, 1         )
  assertErrorMsgContains( msg[1], mth, 'mapij', self.m, matrix(1) )
  assertErrorMsgContains( msg[1], mth, 'mapij', self.m, { }       )
  assertErrorMsgContains( msg[2], mth, 'mapij', self.m, \x x+1  , ''   )
  assertErrorMsgContains( msg[2], mth, 'mapij', self.m, \x x+1  , \x x )
end
function TestMatrixFun:testMapij() end

function TestMatrixErr:testMapat()
  local msg = {
    "invalid argument #2 (callable expected)",
    "invalid argument #3 (iterable expected)",
    "invalid argument #4 (iterable expected)",
    "invalid range member '1'"               ,
    "attempt to perform arithmetic on local 'x' (a nil value)",
  }
  assertErrorMsgContains( msg[1], mth, 'mapat', self.m, nil       )
  assertErrorMsgContains( msg[1], mth, 'mapat', self.m, ''        )
  assertErrorMsgContains( msg[1], mth, 'mapat', self.m, 1..2      )
  assertErrorMsgContains( msg[1], mth, 'mapat', self.m, 1         )
  assertErrorMsgContains( msg[1], mth, 'mapat', self.m, matrix(1) )
  assertErrorMsgContains( msg[1], mth, 'mapat', self.m, { }       )
  assertErrorMsgContains( msg[2], mth, 'mapat', self.m, \x x+1  , ''   )
  assertErrorMsgContains( msg[2], mth, 'mapat', self.m, \x x+1  , nil  )
  assertErrorMsgContains( msg[2], mth, 'mapat', self.m, \x x+1  , NaN  )
  assertErrorMsgContains( msg[2], mth, 'mapat', self.m, \x x+1  , \x x )
  assertErrorMsgContains( msg[3], mth, 'mapat', self.m, \x x+1  , 1    , ''   )
  assertErrorMsgContains( msg[3], mth, 'mapat', self.m, \x x+1  , 1    , \x x )
  assertErrorMsgContains( msg[4], mth, 'mapat', self.m, \x x+1  , 1    , 1..2 )
  assertErrorMsgContains( msg[5], mth, 'mapat', self.m, \x x+1  , 0    )
  assertErrorMsgContains( msg[5], mth, 'mapat', self.m, \x x+1  , 5    )
end
function TestMatrixFun:testMapat() end

function TestMatrixErr:testFoldl()
  local msg = {
    "invalid argument #2 (callable expected)"                    ,
    "invalid argument #5 (iterable expected)"                    ,
    "invalid argument #4 (string 'vec', 'row' or 'col' expected)",
    "invalid range member '1'"                                   ,
  }
  m, cm = matrix(2), cmatrix(2)
  assertErrorMsgContains( msg[1], mth, 'foldl', self.m, nil  )
  assertErrorMsgContains( msg[1], mth, 'foldl', self.m, NaN  )
  assertErrorMsgContains( msg[1], mth, 'foldl', self.m, ''   )
  assertErrorMsgContains( msg[1], mth, 'foldl', self.m, {}   )
  assertErrorMsgContains( msg[1], mth, 'foldl', self.m, 1    )
  assertErrorMsgContains( msg[1], mth, 'foldl', self.m, 1..2 )
  assertErrorMsgContains( msg[1], mth, 'foldl', self.m, m    )
  assertErrorMsgContains( msg[1], mth, 'foldl', self.m, cm   )
  assertErrorMsgContains( msg[3], mth, 'foldl', self.m, \x x, '')
  assertErrorMsgContains( msg[3], mth, 'foldl', self.m, \x x, 1 , {}   , {}   )
  assertErrorMsgContains( msg[3], mth, 'foldl', self.m, \x x, 1 , 1..2 , {}   )
  assertErrorMsgContains( msg[3], mth, 'foldl', self.m, \x x, 1 , m    , {}   )
  assertErrorMsgContains( msg[3], mth, 'foldl', self.m, \x x, 1 , cm   , {}   )
  assertErrorMsgContains( msg[3], mth, 'foldl', self.m, \x x, 1 , ''   , {}   )
  assertErrorMsgContains( msg[2], mth, 'foldl', self.m, \x x, 1 , "vec", ''   )
  assertErrorMsgContains( msg[2], mth, 'foldl', self.m, \x x, 1 , "vec", 1    )
  assertErrorMsgContains( msg[2], mth, 'foldl', self.m, \x x, 1 , "vec", \x x )
end
function TestMatrixFun:testFoldl() end

function TestMatrixErr:testFoldr()
  local msg = {
    "invalid argument #2 (callable expected)"                    ,
    "invalid argument #5 (iterable expected)"                    ,
    "invalid argument #4 (string 'vec', 'row' or 'col' expected)",
    "invalid range member '1'"                                   ,
  }
  m, cm = matrix(2), cmatrix(2)
  assertErrorMsgContains( msg[1], mth, 'foldr', self.m, nil  )
  assertErrorMsgContains( msg[1], mth, 'foldr', self.m, NaN  )
  assertErrorMsgContains( msg[1], mth, 'foldr', self.m, ''   )
  assertErrorMsgContains( msg[1], mth, 'foldr', self.m, {}   )
  assertErrorMsgContains( msg[1], mth, 'foldr', self.m, 1    )
  assertErrorMsgContains( msg[1], mth, 'foldr', self.m, 1..2 )
  assertErrorMsgContains( msg[1], mth, 'foldr', self.m, m    )
  assertErrorMsgContains( msg[1], mth, 'foldr', self.m, cm   )
  assertErrorMsgContains( msg[3], mth, 'foldr', self.m, \x x, '')
  assertErrorMsgContains( msg[3], mth, 'foldr', self.m, \x x, 1 , {}   , {}   )
  assertErrorMsgContains( msg[3], mth, 'foldr', self.m, \x x, 1 , 1..2 , {}   )
  assertErrorMsgContains( msg[3], mth, 'foldr', self.m, \x x, 1 , m    , {}   )
  assertErrorMsgContains( msg[3], mth, 'foldr', self.m, \x x, 1 , cm   , {}   )
  assertErrorMsgContains( msg[3], mth, 'foldr', self.m, \x x, 1 , ''   , {}   )
  assertErrorMsgContains( msg[2], mth, 'foldr', self.m, \x x, 1 , "vec", ''   )
  assertErrorMsgContains( msg[2], mth, 'foldr', self.m, \x x, 1 , "vec", 1    )
  assertErrorMsgContains( msg[2], mth, 'foldr', self.m, \x x, 1 , "vec", \x x )
end
function TestMatrixFun:testFoldr() end


function TestMatrixErr:testScanl()
  local msg = {
    "invalid argument #2 (callable expected)"                    ,
    "invalid argument #5 (iterable expected)"                    ,
    "invalid argument #4 (string 'vec', 'row' or 'col' expected)",
    "invalid range member '1'"                                   ,
  }
  m, cm = matrix(2), cmatrix(2)
  assertErrorMsgContains( msg[1], mth, 'scanl', self.m, nil  )
  assertErrorMsgContains( msg[1], mth, 'scanl', self.m, NaN  )
  assertErrorMsgContains( msg[1], mth, 'scanl', self.m, ''   )
  assertErrorMsgContains( msg[1], mth, 'scanl', self.m, {}   )
  assertErrorMsgContains( msg[1], mth, 'scanl', self.m, 1    )
  assertErrorMsgContains( msg[1], mth, 'scanl', self.m, 1..2 )
  assertErrorMsgContains( msg[1], mth, 'scanl', self.m, m    )
  assertErrorMsgContains( msg[1], mth, 'scanl', self.m, cm   )
  assertErrorMsgContains( msg[3], mth, 'scanl', self.m, \x x, '')
  assertErrorMsgContains( msg[3], mth, 'scanl', self.m, \x x, 1 , {}   , {}   )
  assertErrorMsgContains( msg[3], mth, 'scanl', self.m, \x x, 1 , 1..2 , {}   )
  assertErrorMsgContains( msg[3], mth, 'scanl', self.m, \x x, 1 , m    , {}   )
  assertErrorMsgContains( msg[3], mth, 'scanl', self.m, \x x, 1 , cm   , {}   )
  assertErrorMsgContains( msg[3], mth, 'scanl', self.m, \x x, 1 , ''   , {}   )
  assertErrorMsgContains( msg[2], mth, 'scanl', self.m, \x x, 1 , "vec", ''   )
  assertErrorMsgContains( msg[2], mth, 'scanl', self.m, \x x, 1 , "vec", 1    )
  assertErrorMsgContains( msg[2], mth, 'scanl', self.m, \x x, 1 , "vec", \x x )
end
function TestMatrixFun:testScanl() end

function TestMatrixErr:testScanr()
  local msg = {
    "invalid argument #2 (callable expected)"                    ,
    "invalid argument #5 (iterable expected)"                    ,
    "invalid argument #4 (string 'vec', 'row' or 'col' expected)",
    "invalid range member '1'"                                   ,
  }
  m, cm = matrix(2), cmatrix(2)
  assertErrorMsgContains( msg[1], mth, 'scanr', self.m, nil  )
  assertErrorMsgContains( msg[1], mth, 'scanr', self.m, NaN  )
  assertErrorMsgContains( msg[1], mth, 'scanr', self.m, ''   )
  assertErrorMsgContains( msg[1], mth, 'scanr', self.m, {}   )
  assertErrorMsgContains( msg[1], mth, 'scanr', self.m, 1    )
  assertErrorMsgContains( msg[1], mth, 'scanr', self.m, 1..2 )
  assertErrorMsgContains( msg[1], mth, 'scanr', self.m, m    )
  assertErrorMsgContains( msg[1], mth, 'scanr', self.m, cm   )
  assertErrorMsgContains( msg[3], mth, 'scanr', self.m, \x x, '')
  assertErrorMsgContains( msg[3], mth, 'scanr', self.m, \x x, 1 , {}   , {}   )
  assertErrorMsgContains( msg[3], mth, 'scanr', self.m, \x x, 1 , 1..2 , {}   )
  assertErrorMsgContains( msg[3], mth, 'scanr', self.m, \x x, 1 , m    , {}   )
  assertErrorMsgContains( msg[3], mth, 'scanr', self.m, \x x, 1 , cm   , {}   )
  assertErrorMsgContains( msg[3], mth, 'scanr', self.m, \x x, 1 , ''   , {}   )
  assertErrorMsgContains( msg[2], mth, 'scanr', self.m, \x x, 1 , "vec", ''   )
  assertErrorMsgContains( msg[2], mth, 'scanr', self.m, \x x, 1 , "vec", 1    )
  assertErrorMsgContains( msg[2], mth, 'scanr', self.m, \x x, 1 , "vec", \x x )
end
function TestMatrixFun:testScanr() end

function TestMatrixErr:testFilter()
  local msg = {
    "invalid argument #2 (callable expected)",
    "invalid argument #3 (iterable expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'filter', self.m, nil       )
  assertErrorMsgContains( msg[1], mth, 'filter', self.m, ''        )
  assertErrorMsgContains( msg[1], mth, 'filter', self.m, 1..2      )
  assertErrorMsgContains( msg[1], mth, 'filter', self.m, 1         )
  assertErrorMsgContains( msg[1], mth, 'filter', self.m, matrix(1) )
  assertErrorMsgContains( msg[1], mth, 'filter', self.m, { }       )
  assertErrorMsgContains( msg[2], mth, 'filter', self.m, \x x     , ''   )
  assertErrorMsgContains( msg[2], mth, 'filter', self.m, \x x     , 1    )
  assertErrorMsgContains( msg[2], mth, 'filter', self.m, \x x     , \x x )
end
function TestMatrixFun:testFilter() end

function TestMatrixErr:testFilter_out()
  local msg = {
    "invalid argument #2 (callable expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'filter_out', self.m, nil       )
  assertErrorMsgContains( msg[1], mth, 'filter_out', self.m, ''        )
  assertErrorMsgContains( msg[1], mth, 'filter_out', self.m, 1..2      )
  assertErrorMsgContains( msg[1], mth, 'filter_out', self.m, 1         )
  assertErrorMsgContains( msg[1], mth, 'filter_out', self.m, matrix(1) )
  assertErrorMsgContains( msg[1], mth, 'filter_out', self.m, { }       )
end
function TestMatrixErr:testFilter_out() end

-- special maps ---------------------------------------------------------------o

function TestMatrixSMaps:testCeil () end
function TestMatrixSMaps:testFloor() end
function TestMatrixSMaps:testFrac () end
function TestMatrixSMaps:testTrunc() end
function TestMatrixSMaps:testRound() end
function TestMatrixSMaps:testAbs  () end
function TestMatrixSMaps:testSqrt () end
function TestMatrixSMaps:testExp  () end
function TestMatrixSMaps:testLog  () end
function TestMatrixSMaps:testLog10() end
function TestMatrixSMaps:testSin () end
function TestMatrixSMaps:testCos () end
function TestMatrixSMaps:testTan () end
function TestMatrixSMaps:testSinh() end
function TestMatrixSMaps:testCosh() end
function TestMatrixSMaps:testTanh() end
function TestMatrixSMaps:testAsin () end
function TestMatrixSMaps:testAcos () end
function TestMatrixSMaps:testAtan () end
function TestMatrixSMaps:testAsinh() end
function TestMatrixSMaps:testAcosh() end
function TestMatrixSMaps:testAtanh() end
function TestMatrixSMaps:testErf   () end
function TestMatrixSMaps:testTgamma() end
function TestMatrixSMaps:testLgamma() end
function TestMatrixSMaps:testCarg () end
function TestMatrixSMaps:testReal () end
function TestMatrixSMaps:testImag () end
function TestMatrixSMaps:testConj () end
function TestMatrixSMaps:testProj () end
function TestMatrixSMaps:testRect () end
function TestMatrixSMaps:testPolar() end

-- special scans --------------------------------------------------------------o

function TestMatrixSScans:testAccmin    () end
function TestMatrixSScans:testAccmax    () end
function TestMatrixSScans:testAccsum    () end
function TestMatrixSScans:testAccsumabs () end
function TestMatrixSScans:testAccsumsqr () end
function TestMatrixSScans:testAccprod   () end
function TestMatrixSScans:testAccsum    () end
function TestMatrixSScans:testRaccmin   () end
function TestMatrixSScans:testRaccmax   () end
function TestMatrixSScans:testRaccsum   () end
function TestMatrixSScans:testRaccsumabs() end
function TestMatrixSScans:testRaccsumsqr() end
function TestMatrixSScans:testRaccprod  () end

-- special folds --------------------------------------------------------------o

function TestMatrixSFolds:testMin() end
function TestMatrixSFolds:testMax() end
function TestMatrixSFolds:testSum() end
function TestMatrixSFolds:testSumabs() end
function TestMatrixSFolds:testSumsqr() end
function TestMatrixSFolds:testProduct() end
function TestMatrixSFolds:testAll() end
function TestMatrixSFolds:testAny() end

function TestMatrixErr:testAll()
  local msg = {
    "invalid argument #2 (callable expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'all', self.m, nil    )
  assertErrorMsgContains( msg[1], mth, 'all', self.m, ''     )
  assertErrorMsgContains( msg[1], mth, 'all', self.m, 1..2   )
  assertErrorMsgContains( msg[1], mth, 'all', self.m, 1      )
  assertErrorMsgContains( msg[1], mth, 'all', self.m, self.m )
  assertErrorMsgContains( msg[1], mth, 'all', self.m, { }    )
end

function TestMatrixErr:testAny()
    local msg = {
    "invalid argument #2 (callable expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'any', self.m, nil    )
  assertErrorMsgContains( msg[1], mth, 'any', self.m, ''     )
  assertErrorMsgContains( msg[1], mth, 'any', self.m, 1..2   )
  assertErrorMsgContains( msg[1], mth, 'any', self.m, 1      )
  assertErrorMsgContains( msg[1], mth, 'any', self.m, self.m )
  assertErrorMsgContains( msg[1], mth, 'any', self.m, { }    )
end

-- symplectic matrix ----------------------------------------------------------o

function TestMatrixSympl:testSympinv() end
function TestMatrixSympl:testSymperr() end

-- conjugate, transpose -------------------------------------------------------o

function TestMatrixLinAlg:testTranspose() end
function TestMatrixLinAlg:testTrace() end

-- inner, cross, mixed, outer -------------------------------------------------o

function TestMatrixLinAlg:testInner() end
function TestMatrixLinAlg:testCross() end
function TestMatrixLinAlg:testMixed() end
function TestMatrixLinAlg:testOuter() end

function TestMatrixErr:testInner()
  local msg = {
    "invalid argument #2 (matrix expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'inner', self.m, nil  )
  assertErrorMsgContains( msg[1], mth, 'inner', self.m, ''   )
  assertErrorMsgContains( msg[1], mth, 'inner', self.m, 1    )
  assertErrorMsgContains( msg[1], mth, 'inner', self.m, 1..2 )
  assertErrorMsgContains( msg[1], mth, 'inner', self.m, {}   )
end

function TestMatrixErr:testCross() --TODO: check input(expected size!)
    local msg = {
    "invalid argument #2 (matrix expected)",
    "invalid matrix sizes"                 ,
  }
  assertErrorMsgContains( msg[1], mth, 'cross', matrix(3), nil  )
  assertErrorMsgContains( msg[1], mth, 'cross', matrix(3), ''   )
  assertErrorMsgContains( msg[1], mth, 'cross', matrix(3), 1    )
  assertErrorMsgContains( msg[1], mth, 'cross', matrix(3), 1..2 )
  assertErrorMsgContains( msg[1], mth, 'cross', matrix(3), {}   )
  assertErrorMsgContains( msg[2], mth, 'cross', matrix(2), matrix(3) )
end

function TestMatrixErr:testMixed() --TODO: check input(expected size!)
  local msg, m1 = {
    "invalid argument #2 (matrix expected)",
    "invalid argument #3 (matrix expected)",
    "invalid matrix sizes"                 ,
    "incompatible matrix sizes"            ,
  }
  m1 = matrix(3,1)
  assertErrorMsgContains( msg[1], mth, 'mixed', m1, nil  )
  assertErrorMsgContains( msg[1], mth, 'mixed', m1, ''   )
  assertErrorMsgContains( msg[1], mth, 'mixed', m1, 1    )
  assertErrorMsgContains( msg[1], mth, 'mixed', m1, 1..2 )
  assertErrorMsgContains( msg[1], mth, 'mixed', m1, {}   )
  assertErrorMsgContains( msg[2], mth, 'mixed', m1, m1  , nil  )
  assertErrorMsgContains( msg[2], mth, 'mixed', m1, m1  , ''   )
  assertErrorMsgContains( msg[2], mth, 'mixed', m1, m1  , 1    )
  assertErrorMsgContains( msg[2], mth, 'mixed', m1, m1  , 1..2 )
  assertErrorMsgContains( msg[2], mth, 'mixed', m1, m1  , {}   )
  assertErrorMsgContains( msg[3], mth, 'mixed', matrix(2,1), m1, m1 )
  assertErrorMsgContains( msg[4], mth, 'mixed', matrix(3,2), m1, m1 )
  assertErrorMsgContains( msg[4], mth, 'mixed', m1, matrix(2,1), m1 )
  assertErrorMsgContains( msg[4], mth, 'mixed', m1, matrix(3,2), m1 )
  assertErrorMsgContains( msg[4], mth, 'mixed', m1, m1 ,matrix(2,1) )
  assertErrorMsgContains( msg[4], mth, 'mixed', m1, m1 ,matrix(3,2) )
end

function TestMatrixErr:testOuter() --TODO: check input(expected size!)
  local msg = {
    "invalid argument #2 (matrix expected)",
    "incompatible matrix sizes",
  }
  assertErrorMsgContains( msg[1], mth, 'outer', matrix(2,1), nil  )
  assertErrorMsgContains( msg[1], mth, 'outer', matrix(2,1), ''   )
  assertErrorMsgContains( msg[1], mth, 'outer', matrix(2,1), {}   )
  assertErrorMsgContains( msg[1], mth, 'outer', matrix(2,1), 1    )
  assertErrorMsgContains( msg[1], mth, 'outer', matrix(2,1), 1..2 )
  assertErrorMsgContains( msg[2], mth, 'outer', matrix(1,2), matrix(2,2) )
  assertErrorMsgContains( msg[2], mth, 'outer', matrix(2,2), matrix(1,2) )
end

-- norm, unit, center, angle (in place) ---------------------------------------o

function TestMatrixLinAlg:testNorm() end
function TestMatrixLinAlg:testDistance() end
function TestMatrixLinAlg:testUnit() end
function TestMatrixLinAlg:testCenter() end
function TestMatrixLinAlg:testAngle() end

function TestMatrixErr:testDistance()
  local msg = {
    "invalid argument #2 (matrix expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'distance', self.m, nil  )
  assertErrorMsgContains( msg[1], mth, 'distance', self.m, 1..2 )
  assertErrorMsgContains( msg[1], mth, 'distance', self.m, ''   )
  assertErrorMsgContains( msg[1], mth, 'distance', self.m, {}   )
  assertErrorMsgContains( msg[1], mth, 'distance', self.m, cmatrix(1) )
end

function TestMatrixErr:testUnit()
  local msg = {
    "null matrix norm",
  }
end

function TestMatrixErr:testAngle()
  local msg = {
    "null vector norm",
  }
end

-- operators ------------------------------------------------------------------o

function TestMatrixOp:testEq() end

function TestMatrixOp:testAddCPx() end

function TestMatrixErr:testAdd()
  local msg = {
    "invalid arguments (unsupported matrix operation)",
  }
end
function TestMatrixOp:testAdd() end

function TestMatrixOp:testSubCPx() end

function TestMatrixErr:testSub()
  local msg = {
    "invalid arguments (unsupported matrix operation)",
  }
end
function TestMatrixOp:testSub() end

function TestMatrixOp:testMulCPx() end

function TestMatrixErr:testMul()
  local msg = {
    "invalid arguments (unsupported matrix operation)",
  }
end
function TestMatrixOp:testMul() end

function TestMatrixErr:testTmul()
  local msg = {
    "invalid arguments (unsupported matrix operation)",
  }
end
function TestMatrixOp:testTmul() end

function TestMatrixOp:testDivCPx() end

function TestMatrixErr:testDiv()
  local msg = {
    "invalid arguments (unsupported matrix operation)",
  }
end
function TestMatrixOp:testDiv() end

function TestMatrixErr:testEmul()
  local msg = {
    "invalid argument #2 (matrix expected)",
  }
end
function TestMatrixOp:testEmul() end

function TestMatrixErr:testEdiv()
  local msg = {
    "invalid argument #2 (matrix expected)",
  }
end
function TestMatrixOp:tetEdiv() end

-- linear algebra -------------------------------------------------------------o

function TestMatrixLapack:testSolve() end
function TestMatrixLapack:testSvd() end

function TestMatrixLapack:testEigen() end
function TestMatrixErr:testEigen()
  local msg = {
    "matrix must be square",
  }
end

-- FFT, convolution, correlation, covrariance ---------------------------------o

function TestMatrixFFT:testFft() end
function TestMatrixFFT:testIfft() end

function TestMatrixErr:testRfft()
  local msg = {
    "incompatible matrix sizes",
  }
end
function TestMatrixFFT:testRfft() end

function TestMatrixErr:testIrfft()
  local msg = {
    "result matrix must be real",
    "incompatible matrix sizes" ,
  }
end
function TestMatrixFFT:testIrfft() end

 -- convolution theorem
function TestMatrixFFT:testConv() end

 -- correlation theorem
function TestMatrixFFT:testCorr() end
function TestMatrixFFT:testCovar() end

-- concatenation --------------------------------------------------------------o

function TestMatrixErr:testConcat()
  local msg = {
    "invalid argument #1 (matrix expected)"               ,
    "invalid argument #2 (matrix expected)"               ,
    "incompatible matrix sizes"                           ,
    "invalid argument #3 (string 'row' or 'col' expected)",
  }
end
function TestMatrix:testConcat() end

-- end ------------------------------------------------------------------------o
