--[=[
 o-----------------------------------------------------------------------------o
 |
 | Matrix module regression tests
 |
 | Methodical Accelerator Design - Copyright CERN 2015+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: A.Z. Teska, aleksandra.teska at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide regression test suites for the matrix module.

 o-----------------------------------------------------------------------------o
]=]

local assertEquals, assertAlmostEquals, assertTrue, assertFalse,
      assertErrorMsgContains, assertNil, assertNaN, assertIsString, assertInf
      in require 'luaunit'

local vector, cvector, matrix, cmatrix, is_vector, is_matrix, is_cvector,
      is_cmatrix, isa_vector, isa_matrix, linspace, logspace in MAD

local complex, infi, tiny, eps, huge, inf, nan, pi, Pi,
      randomseed, log,
      is_complex in MAD

-- regression test suite ------------------------------------------------------o

TestMatrix  = {}
TestCMatrix = {}

local  m,  v = {}, {}
local cm, cv = {}, {}
for j=1,10 do m[j]  = matrix(j,j) :random(randomseed(j)) end
for j=1,10 do v[j]  = vector(j)   :random(randomseed(j)) end
for j=1,10 do cm[j] = cmatrix(j,j):random(randomseed(j)) end

local values = {
  num = { tiny, 2^-64, 2^-63, 2^-53, eps, 2^-52, 2*eps, 2^-32, 2^-31, 1e-9,
          0.1-eps, 0.1, 0.1+eps, 0.5, 0.7-eps, 0.7, 0.7+eps, 1-eps, 1, 1+eps,
          1.1, 1.7, 2, 10, 1e2, 1e3, 1e6, 1e9, 2^31, 2^32, 2^52, 2^53,
          2^63, 2^64, huge },
}

function TestMatrix:testCtorMatrix()
  -- creation of matrices with different seeds
  local msg = {
  "invalid argument #1 or #2 (nrow[,ncol] or table [of tables] expected)",
  "bad argument #1 to 'mad_malloc' (cannot convert 'nil' to 'uint64_t')" ,
  }
  assertErrorMsgContains( msg[1], matrix, ''   )
  assertErrorMsgContains( msg[1], matrix, nil  )
  assertErrorMsgContains( msg[1], matrix, 0    )
  assertErrorMsgContains( msg[1], matrix,-1    )
  assertErrorMsgContains( msg[1], matrix, 1..2 )
  assertErrorMsgContains( msg[1], matrix, infi )
  assertErrorMsgContains( msg[1], matrix, nan  )
  assertErrorMsgContains( msg[2], matrix, inf  )

  for _,v in ipairs(v) do
    assertTrue( is_matrix(v) )
    assertTrue( is_vector(v) )
  end
  for i,m in ipairs(m) do
    assertTrue ( is_matrix(m) )
    if i == 1 then assertTrue ( is_vector(m) )
              else assertFalse( is_vector(m) ) end
  end
end

function TestMatrix:testCtorCMatrix()
  local msg = {
  "invalid argument #1 or #2 (nrow[,ncol] or table [of tables] expected)",
  "bad argument #1 to 'mad_malloc' (cannot convert 'nil' to 'uint64_t')" ,
  }
  assertErrorMsgContains( msg[1], cmatrix, ''   )
  assertErrorMsgContains( msg[1], cmatrix, nil  )
  assertErrorMsgContains( msg[1], cmatrix, 0    )
  assertErrorMsgContains( msg[1], cmatrix,-1    )
  assertErrorMsgContains( msg[1], cmatrix, 1..2 )
  assertErrorMsgContains( msg[1], cmatrix, infi )
  assertErrorMsgContains( msg[1], cmatrix, nan  )
  assertErrorMsgContains( msg[2], cmatrix, inf  )

  for i,cm in ipairs(cm) do
    assertTrue( is_cmatrix(cm) )
    --print(cm)
    for i=1,#cm do
      is_complex( cm[i] )
    end
  end
end

function TestMatrix:testIs_matrix()
  assertTrue ( is_matrix( matrix(2,2)) )
  assertFalse( is_matrix(cmatrix(2,2)) )
  assertTrue ( is_matrix( vector(1)  ) )
  assertFalse( is_matrix(cvector(1)  ) )
end

function TestMatrix:testIs_cmatrix()
  assertFalse( is_cmatrix( matrix(2,2)) )
  assertTrue ( is_cmatrix(cmatrix(2,2)) )
  assertFalse( is_cmatrix( vector(1)  ) )
  assertTrue ( is_cmatrix(cvector(1)  ) )
end

function TestMatrix:testIs_vector()
  assertFalse( is_vector( matrix(2,2)) )
  assertFalse( is_vector(cmatrix(2,2)) )
  assertTrue ( is_vector( vector(1)  ) )
  assertFalse( is_vector(cvector(1)  ) )
end

function TestMatrix:testIs_cvector()
  assertFalse( is_cvector( matrix(2,2)) )
  assertFalse( is_cvector(cmatrix(2,2)) )
  assertFalse( is_cvector( vector(1)  ) )
  assertTrue ( is_cvector(cvector(1)  ) )
end

function TestMatrix:testIsa_vector()
  assertFalse( isa_vector( matrix(2,2)) )
  assertFalse( isa_vector(cmatrix(2,2)) )
  assertTrue ( isa_vector( vector(1)  ) )
  assertTrue ( isa_vector(cvector(1)  ) )
end

function TestMatrix:testIsa_matrix()
  assertTrue ( isa_matrix( matrix(2,2)) )
  assertTrue ( isa_matrix(cmatrix(2,2)) )
  assertTrue ( isa_matrix( vector(1)  ) )
  assertTrue ( isa_matrix(cvector(1)  ) )
end

-- get, set -------------------------------------------------------------------o

local t =
  {
  { 0.9286338430918031, 0.7981905327208816, 0.2918908989053144, 1 },
  {-0.3540043171200369, 0.8020336034136235, 0.2751589695263197, 1 },
  { 0.4426082303008909, 0.6793722299415492,-0.4718603395451262, 1 },
  { 0.9370700019205285,-0.657495562826343 , 0.9678081932273772, 1 },
  { 0.6563040282125301, 0.7689912808655879, 0.1214582415972276, 1 },
  }
local m1 = matrix(t)

function TestMatrix:testGeti0()
  local msg = {
  "attempt to call a nil value",
  }
  assertErrorMsgContains( msg[1], geti0, m, nil   )

  assertEquals( m[10]:geti0( tiny), m[10]:geti0( 0) )
  assertEquals( m[10]:geti0( 0.1 ), m[10]:geti0( 0) )
  assertEquals( m[10]:geti0( eps ), m[10]:geti0( 0) )

  assertNil( m[10]:geti0( huge) )
  assertNil( m[10]:geti0( nan ) )
  assertNil( m[10]:geti0( inf ) )
  assertNil( m[10]:geti0(-1   ) )
  assertNil( m[10]:geti0( 100 ) )

  local m2  = matrix(5,5)
  for i = 1,5 do  for j = 1,5 do  assertEquals( m2:geti0(i+j-1), 0 ) end end

  for j = 1,4 do for i = 1,4 do
    assertEquals( t[j][i], m1:geti0( ((j-1)*4 )+i-1 ) )
  end end
end

function TestMatrix:testGeti()
  --assertNil( m[10]:geti(  ) )
  assertNil( m[10]:geti( huge) )
  assertNil( m[10]:geti( nan ) )
  assertNil( m[10]:geti( inf ) )
  assertNil( m[10]:geti(-1   ) )
  assertNil( m[10]:geti( 0   ) )
  assertNil( m[10]:geti( eps ) )
  assertNil( m[10]:geti( 101 ) )
  assertEquals( m[10]:geti( 1.1 ), m[10]:geti( 1) )

  local m2  = matrix(5,5)
  for i = 1,5 do  for j = 1,5 do  assertEquals( m2:geti(i+j), 0 ) end end

  for j = 1,4 do for i = 1,4 do
    assertEquals( t[j][i], m1:geti( ((j-1)*4 )+i ) )
  end end
end

function TestMatrix:testGet0()
  local msg = {
    "attempt to call a nil value",
    }
  assertErrorMsgContains( msg[1], get0, m[1], 0  , nil )
  assertErrorMsgContains( msg[1], get0, m[1], nil, 0   )

  assertNil( m[1]:get0( huge, 0   ) )
  assertNil( m[1]:get0( nan , 0   ) )
  assertNil( m[1]:get0( inf , 0   ) )
  assertNil( m[1]:get0(-1   , 0   ) )
  assertNil( m[1]:get0( 0   , huge) )
  assertNil( m[1]:get0( 0   , nan ) )
  assertNil( m[1]:get0( 0   , inf ) )
  assertNil( m[1]:get0( 0   ,-1   ) )

  local m2  = matrix(5,5)
  for i = 1,5 do  for j = 1,5 do  assertEquals( m2:get0(i-1,j-1), 0 ) end end

  for j = 1,4 do for i = 1,4 do
    assertEquals( t[j][i], m1:get0(j-1,i-1) )
  end end
end

function TestMatrix:testGet()
  local msg = {
    "attempt to call a nil value",
    }
  assertErrorMsgContains( msg[1], get0, m[1], 1  , nil )
  assertErrorMsgContains( msg[1], get0, m[1], nil, 1   )

  assertNil( m[1]:get( huge, 1   ) )
  assertNil( m[1]:get( nan , 1   ) )
  assertNil( m[1]:get( inf , 1   ) )
  assertNil( m[1]:get(-1   , 1   ) )
  assertNil( m[1]:get( 0   , 1   ) )
  assertNil( m[1]:get( 1   , huge) )
  assertNil( m[1]:get( 1   , nan ) )
  assertNil( m[1]:get( 1   , inf ) )
  assertNil( m[1]:get( 1   ,-1   ) )
  assertNil( m[1]:get( 1   , 0   ) )

  local m2  = matrix(5,5)
  for i = 1,5 do  for j = 1,5 do  assertEquals( m2:get(i,j), 0 ) end end

  for j = 1,4 do for i = 1,4 do
    assertEquals( t[j][i], m1:get(j,i) )
  end end
end


-- sets have to use get in testing(get dependand)
-- set the: special values, values from another table/matrix and compare
-- set in: made up matrices( m from the top values from t/m1), into empty matrices , non-existring matrices

function TestMatrix:testSeti0()
  local msg, m2 = {
    "0-index out of bounds",
    "attempt to call a nil value",
    }
  --assertErrorMsgContains( msg[1], seti0, m1,-1   , 1 )
  --assertErrorMsgContains( msg[1], seti0, m1, huge, 1 )
  --assertErrorMsgContains( msg[1], seti0, m1, inf , 1 )
  assertErrorMsgContains( msg[2], seti0, m1, nil , 1 )

  m2 = matrix(5,5)
  for i = 1,5 do
  for j = 1,5 do
    m2:seti0( i+j-1, 1 )
    assertEquals( m2:geti0(i+j-1), 1 )
  end end

  m2 = m1
  for j = 1,4 do for i = 1,4 do
    m2:seti0( ((j-1)*4 )+i-1, 0       )
    assertEquals( m2:geti0( ((j-1)*4 )+i-1 ), 0       )

    m2:seti0( ((j-1)*4 )+i-1, t[j][i] )
    assertEquals( m1:geti0( ((j-1)*4 )+i-1 ), t[j][i] )
  end end
end

function TestMatrix:testSeti()
  local msg, m2 = {
    "1-index out of bounds",
    "attempt to call a nil value",
    }
  --assertErrorMsgContains( msg[1], seti, m1, 0   , 1 )
  --assertErrorMsgContains( msg[1], seti, m1, 0.1 , 1 )
  --assertErrorMsgContains( msg[1], seti, m1,-1   , 1 )
  --assertErrorMsgContains( msg[1], seti, m1, huge, 1 )
  --assertErrorMsgContains( msg[1], seti, m1, inf , 1 )
  assertErrorMsgContains( msg[2], seti, m1, nil , 1 )

  m2  = matrix(5,5)
  for i = 1,5 do  for j = 1,5 do
    m2:seti0( i+j, 1 )
    assertEquals( m2:geti0(i+j), 1 )
    end end

  m2 = m1
  for j = 1,4 do for i = 1,4 do
    m2:seti( ((j-1)*4 )+i, 0       )
    assertEquals( m2:geti( ((j-1)*4 )+i ), 0       )
    m2:seti( ((j-1)*4 )+i, t[j][i] )
    assertEquals( m2:geti( ((j-1)*4 )+i ), t[j][i] )
  end end
end

function TestMatrix:testSet0()
  local msg, m2 = {
    "0-index out of bounds",
    "attempt to call a nil value",
    }
  --assertErrorMsgContains( msg[1], set0, m1,-1   , 1, 1 )
  --assertErrorMsgContains( msg[1], set0, m1, huge, 1, 1 )
  --assertErrorMsgContains( msg[1], set0, m1, inf , 1, 1 )
  assertErrorMsgContains( msg[2], set0, m1, nil , 1, 1 )
  m2  = matrix(5,5)
  for i = 1,5 do  for j = 1,5 do
    m2:set0( i-1, j-1, 1 )
    assertEquals( m2:get0(i-1,j-1), 1 )
  end end

  m2 = m1
  for j = 1,4 do for i = 1,4 do
    m2:set0( i-1, j-1, 0       )
    assertEquals( m2:get0(i-1,j-1), 0       )
    m2:set0( i-1, j-1, t[j][i] )
    assertEquals( m2:get0(i-1,j-1), t[j][i] )
  end end
end

function TestMatrix:testSet()
  local msg, m2 = {
    "1-index out of bounds",
    "attempt to call a nil value",
    }
  --assertErrorMsgContains( msg[1], set, m1, 0   , 1, 1 )
  --assertErrorMsgContains( msg[1], set, m1, 0.1 , 1, 1 )
  --assertErrorMsgContains( msg[1], set, m1,-1   , 1, 1 )
  --assertErrorMsgContains( msg[1], set, m1, huge, 1, 1 )
  --assertErrorMsgContains( msg[1], set, m1, inf , 1, 1 )
  assertErrorMsgContains( msg[2], set, m1, nil , 1, 1 )

  m2  = matrix(5,5)
  for i = 1,5 do  for j = 1,5 do
    m2:set( i, j, 1 )
    assertEquals( m2:get(i,j), 1 )
  end end

  m2 = m1
  for j = 1,4 do for i = 1,4 do
    m2:set( i, j, 0       )
    assertEquals( m2:get(i,j), 0       )
    m2:set( i, j, t[j][i] )
    assertEquals( m2:get(i,j), t[j][i] )
  end end
end

-- should go after seti0
function TestMatrix:testLinspace()
  -- mess with step messeges, to be looked up
  local msg, l = {
  "attempt to perform arithmetic on local 'start'",
  "attempt to perform arithmetic on local 'stop' ",

  "invalid argument #1 or #2 (nrow[,ncol] or table [of tables] expected)",
  "bad argument #1 to 'mad_malloc' (cannot convert 'nil' to 'uint64_t'",
  "attempt to compare number with string",
  --"invalid argument #3 (size expected)"  ,
  }
  assertErrorMsgContains( msg[1], linspace, nil, 1   )
  assertErrorMsgContains( msg[1], linspace, '' , 1   )
  assertErrorMsgContains( msg[2], linspace, 1  , nil )
  assertErrorMsgContains( msg[2], linspace, 1  , ''  )

  assertErrorMsgContains( msg[3], linspace, 2  , 2  , 0   )
  assertErrorMsgContains( msg[3], linspace, 2  , 2  ,-1   )
  assertErrorMsgContains( msg[3], linspace, 2  , 2  , nan )
  assertErrorMsgContains( msg[3], linspace, 2  , 2  ,-nan )
  assertErrorMsgContains( msg[3], linspace, 2  , 2  ,-inf )
  assertErrorMsgContains( msg[4], linspace, 2  , 2  , inf )
  assertErrorMsgContains( msg[5], linspace, 2  , 2  , ''  )

  assertEquals( #linspace( 2  , 2  , nil)     , 100 )
  assertEquals(  linspace( 2  , 2  , nil)[1]  , 2   )
  assertEquals(  linspace( 2  , 2  , nil)[100], 2   )

  l = linspace( 2  ,-inf)  for i = 2, #l do assertInf( l[i] ) end assertNaN( l[1] )
  l = linspace( 2  , inf)  for i = 2, #l do assertInf( l[i] ) end assertNaN( l[1] )
  l = linspace( inf, 2  )  for i = 1, #l do assertNaN( l[i] ) end
  l = linspace(-inf, 2  )  for i = 1, #l do assertNaN( l[i] ) end
  l = linspace( 2  , nan)  for i = 1, #l do assertNaN( l[i] ) end
  l = linspace( nan, 2  )  for i = 1, #l do assertNaN( l[i] ) end
end

function TestMatrix:testLogspace()
-- investigate the values inside the logspace
--
  local msg, l = {
  "attempt to index local 'x' "  ,
  "attempt to call method 'log' ",
  "invalid argument #1 or #2 (nrow[,ncol] or table [of tables] expected)",
  "bad argument #1 to 'mad_malloc' (cannot convert 'nil' to 'uint64_t'",
  }
  assertErrorMsgContains( msg[1], logspace, nil, 1   )
  assertErrorMsgContains( msg[2], logspace, '' , 1   )  --attempt to call method 'log' ?
  assertErrorMsgContains( msg[1], logspace, 1  , nil )
  assertErrorMsgContains( msg[2], logspace, 1  , ''  )  --attempt to call method 'log' ?
  assertErrorMsgContains( msg[3], logspace, 2  ,2   ,-1  )
  assertErrorMsgContains( msg[3], logspace, 2  ,2   , 0  )
  assertErrorMsgContains( msg[3], logspace, 2  ,2   , nan)
  assertErrorMsgContains( msg[3], logspace, 2  ,2   ,-nan)
  assertErrorMsgContains( msg[3], logspace, 2  ,2   ,-inf)
  assertErrorMsgContains( msg[4], logspace, 2  ,2   , inf)

  assertEquals( #logspace( 2  , 2  , nil)     , 100 )
  assertEquals(  logspace( 2  , 2  , nil)[1]  , 2   ) -- shouldn't it be log(2) ?
  assertEquals(  logspace( 2  , 2  , nil)[100], 2   )

  l = logspace( 2  ,-inf)  for i = 1, #l do assertNaN( l[i] ) end
  l = logspace( 2  , inf)  for i = 2, #l do assertInf( l[i] ) end assertNaN( l[1] )
  l = logspace( inf, 2  )  for i = 1, #l do assertNaN( l[i] ) end
  l = logspace(-inf, 2  )  for i = 1, #l do assertNaN( l[i] ) end
  l = logspace( 2  , nan)  for i = 1, #l do assertNaN( l[i] ) end
  l = logspace( nan, 2  )  for i = 1, #l do assertNaN( l[i] ) end

end

--   valid invocation: x:same(), x:same(e), x:same(nr, nc), x:same(e, nr, nc)
-- invalid invocation: x:same(e, nr), will be interpreted as x:same(nr, nc)
function TestMatrix:testSame() -- to be tested further, different way of testing
  local m1, m2 = matrix(2,2):random()
  m1:same( )
  m2 = m1
  for j = 1,4 do for i = 1,4 do
    assertEquals( m2:get(j,i), m1:get(j,i) )
  end end

  m1:same( nil)
  m2 = m1
  for j = 1,4 do for i = 1,4 do
    assertEquals( m2:get(j,i), m1:get(j,i) )
  end end
  m1:same( complex(2,1) )
  --print(is_cmatrix(m1))
  m2 = m1
  for j = 1,4 do for i = 1,4 do
    assertEquals( m2:get(j,i), m1:get(j,i) )
  end end

end


function TestMatrix:testGetsub()   -- to be done here, needed for further tests --uses: get, same
  local msg = {
    "invalid argument #2 (iterable expected)", --is_iterable(ir)
    "invalid argument #3 (iterable expected)", --is_iterable(jc)
    "invalid argument #4 (iterable expected)", --is_iterable(r )
    }

  --assertErrorMsgContains( msg[1], getsub, m, 0,0   )

end

function TestMatrix:testRandom()
  --for i=1,1000 do
  --  assertTrue( random()        >=  0   )
  --  assertTrue( random()        <   1   )
  --  assertTrue( random(100)     >=  1   )
  --  assertTrue( random(100)     <= 100  )
  --  assertTrue( random(-1,1)    >= -1   )
  --  assertTrue( random(-1,1)    <=  1   )
  --  assertTrue( random(-1,2^52) >= -1   )
  --  assertTrue( random(-1,2^52) <= 2^52 )
  --end
  --assertNaN( random(nan,  0 ) )
  --assertNaN( random( 0 , nan) )
  --assertNaN( random(nan, nan) )
  --local val  = {}
  --local oldVal = {}
  --for j=1,10 do
  --  randomseed( j )
  --  for i=1,500 do
  --    val[i] = random(0,2^52)
  --    assertTrue ( val[i] >= 0    )
  --    assertTrue ( val[i] <= 2^52 )
  --    assertFalse( val[i] == oldVal[i] )
  --    oldVal[i] = val[i]
  --  end
  --end
end
-- size, same -----------------------------------------------------------------o

-- add complex matrices, non-squere matrices, special cases (empty, nan)-- all reached with subsets
function TestMatrix:testNrow()
  for i,m in ipairs(m) do
    assertEquals( m:nrow(), i )
  end
  for i,v in ipairs(v) do
    assertEquals( v:nrow(), i )
  end
end

function TestMatrix:testNcol()
  for i,m in ipairs(m) do
    assertEquals( m:ncol(), i )
  end
  for i,v in ipairs(v) do
    assertEquals( v:ncol(), 1 )
  end
end

function TestMatrix:testSize()
  for i,m in ipairs(m) do
    assertEquals( m:size(), i*i )
  end
  for i,v in ipairs(v) do
    assertEquals( v:size(), i*1 )
  end
end

function TestMatrix:testSizes()
  for i,m in ipairs(m) do
    assertEquals( { m:sizes() }, {i,i} )
  end
  for i,v in ipairs(v) do
    assertEquals( { v:sizes() }, {i,1} )
  end
end

function TestMatrix:testTsizes() -- non squre!!
  for i,m in ipairs(m) do
    assertEquals( { m:tsizes() }, {i,i} )
  end
  for i,v in ipairs(v) do
    assertEquals( { v:tsizes() }, {1,i} )
  end
end

--function TestMatrix:testFill() end   -- to be done here, needed for further tests --uses: sizes, set, get

--[[

function TestMatrix:testSame() end

function TestMatrix:testCopy() end
function TestCMatrix:testCopy() end

function TestMatrix:testZeros() end
function TestCMatrix:testZeros() end

function TestMatrix:testOnes() end
function TestMatrix:testEye() end
function TestMatrix:testRandom() end

function TestMatrix:testSymp() end
function TestMatrix:testCirc() end
function TestMatrix:testFill() end

function TestMatrix:testVshape() end
function TestMatrix:testReshape() end

-- getx, setx -----------------------------------------------------------------o

function TestMatrix:testGetv() end
function TestMatrix:testSetv() end
function TestMatrix:testGetdiag() end
function TestMatrix:testSetdiag() end

function TestMatrix:testGetrow() end
function TestMatrix:testSetrow() end

function TestMatrix:testGetcol() end
function TestMatrix:testSetcol() end

function TestMatrix:testGetsub() end
function TestMatrix:testSetsub() end

-- foreach, filter, map, fold, scan -------------------------------------------o

function TestMatrix:testForeach() end
function TestMatrix:testFilter() end
function TestMatrix:testMapat() end
function TestMatrix:testMap() end
function TestMatrix:testMap2() end
function TestMatrix:testMap3() end

function TestMatrix:testFoldl() end
function TestMatrix:testFoldr() end

function TestMatrix:testScanl() end
function TestMatrix:testScanr() end

-- special maps ---------------------------------------------------------------o

function TestMatrix:testCeil () end
function TestMatrix:testFloor() end
function TestMatrix:testFrac () end
function TestMatrix:testTrunc() end
function TestMatrix:testRound() end

function TestMatrix:testAbs  () end
function TestMatrix:testSqrt () end
function TestMatrix:testExp  () end
function TestMatrix:testLog  () end
function TestMatrix:testLog10() end

function TestMatrix:testSin () end
function TestMatrix:testCos () end
function TestMatrix:testTan () end
function TestMatrix:testSinh() end
function TestMatrix:testCosh() end
function TestMatrix:testTanh() end

function TestMatrix:testAsin () end
function TestMatrix:testAcos () end
function TestMatrix:testAtan () end
function TestMatrix:testAsinh() end
function TestMatrix:testAcosh() end
function TestMatrix:testAtanh() end

function TestMatrix:testErf   () end
function TestMatrix:testTgamma() end
function TestMatrix:testLgamma() end

function TestMatrix:testCarg () end
function TestMatrix:testReal () end
function TestMatrix:testImag () end
function TestMatrix:testConj () end
function TestMatrix:testProj () end
function TestMatrix:testRect () end
function TestMatrix:testPolar() end

-- special folds --------------------------------------------------------------o

function TestMatrix:testMin() end
function TestMatrix:testMax() end
function TestMatrix:testSum() end
function TestMatrix:testSumabs() end
function TestMatrix:testSumsqr() end
function TestMatrix:testProduct() end
function TestMatrix:testAll() end
function TestMatrix:testAny() end

-- conjugate, transpose -------------------------------------------------------o

function TestMatrix:testTranspose() end
function TestCMatrix:testTranspose() end

function TestMatrix:testTrace() end

-- symplectic matrix ----------------------------------------------------------o

function TestMatrix:testSympinv() end
function TestCMatrix:testSympinv() end

function TestMatrix:testSymperr() end
function TestCMatrix:testSymperr() end

-- inner, cross, mixed, outer -------------------------------------------------o

function TestMatrix:testInner() end
function TestCMatrix:testInner() end

function TestMatrix:testCross() end
function TestMatrix:testMixed() end
function TestMatrix:testOuter() end

-- norm, unit, center, angle (in place) ---------------------------------------o

function TestMatrix:testNorm() end
function TestCMatrix:testNorm() end

function TestMatrix:testDistance() end
function TestCMatrix:testDistance() end

function TestMatrix:testUnit() end
function TestCMatrix:testUnit() end

function TestMatrix:testCenter() end
function TestCMatrix:testCenter() end

function TestMatrix:testAngle() end

-- operators ------------------------------------------------------------------o

function TestMatrix:testEq() end

function TestMatrix:testAddCPx() end
function TestMatrix:testAdd() end
function TestCMatrix:testAddCPx() end
function TestCMatrix:testAdd() end

function TestMatrix:testSubCPx() end
function TestMatrix:testSub() end
function TestCMatrix:testSubCPx() end
function TestCMatrix:testSub() end

function TestMatrix:testMulCPx() end
function TestMatrix:testMul() end
function TestCMatrix:testMulCPx() end
function TestCMatrix:testMul() end

function TestMatrix:testTmul() end
function TestCMatrix:testTmul() end

function TestMatrix:testDivCPx() end
function TestMatrix:testDiv() end
function TestCMatrix:testDivCPx() end
function TestCMatrix:testDiv() end

function TestMatrix:testEmul() end
function TestCMatrix:testEmul() end
function TestMatrix:testEdiv() end
function TestCMatrix:testEdiv() end

-- linear algebra -------------------------------------------------------------o

function TestMatrix:testSolve() end
function TestMatrix:testSvd() end
function TestCMatrix:testSvd() end

function TestMatrix:testEigen() end
function TestCMatrix:testEigen() end

-- FFT, convolution, correlation, covrariance ---------------------------------o

function TestMatrix:testFft() end
function TestMatrix:testIfft() end
function TestMatrix:testRfft() end
function TestMatrix:testIrfft() end

 -- convolution theorem
function TestMatrix:testConv() end
function TestCMatrix:testConv() end

 -- correlation theorem
function TestMatrix:testCorr() end
function TestCMatrix:testCorr() end
function TestMatrix:testCovar() end
]]

-- end ------------------------------------------------------------------------o
