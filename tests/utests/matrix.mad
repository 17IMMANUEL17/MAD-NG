--[=[
 o-----------------------------------------------------------------------------o
 |
 | Matrix module regression tests
 |
 | Methodical Accelerator Design - Copyright CERN 2015+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: A.Z. Teska, aleksandra.teska at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide regression test suites for the matrix module.

 o-----------------------------------------------------------------------------o
]=]

local assertEquals, assertAlmostEquals, assertTrue, assertFalse,
      assertErrorMsgContains, assertNil, assertNaN, assertIsString, assertInf
      in require 'luaunit'

local vector, cvector, matrix, cmatrix, is_vector, is_matrix, is_cvector,
      is_cmatrix, isa_vector, isa_matrix, linspace, logspace in MAD

local complex, infi, tiny, eps, huge, inf, nan, pi, Pi, randomseed, log,
      is_complex, range, nrange, is_cdata in MAD

-- regression test suite ------------------------------------------------------o

TestMatrix  = {}
TestCMatrix = {}

local values = {
  num = { tiny, 2^-64, 2^-63, 2^-53, eps, 2^-52, 2*eps, 2^-32, 2^-31, 1e-9,
          0.1-eps, 0.1, 0.1+eps, 0.5, 0.7-eps, 0.7, 0.7+eps, 1-eps, 1, 1+eps,
          1.1, 1.7, 2, 10, 1e2, 1e3, 1e6, 1e9, 2^31, 2^32, 2^52, 2^53,
          2^63, 2^64, huge },
}

local mth = \f,s,... s[f](s,...)

function TestMatrix:testCtorMatrix()
  local mat, vec = {}, {}
  local msg = {
  "invalid argument #1 or #2 (nrow[,ncol] >=1 or table [of tables] expected)",
  "bad argument #1 to 'malloc' (cannot convert 'nil' to 'uint64_t')" ,
  }
  assertErrorMsgContains( msg[1], matrix, ''   )
  assertErrorMsgContains( msg[1], matrix, nil  )
  assertErrorMsgContains( msg[1], matrix, 0    )
  assertErrorMsgContains( msg[1], matrix, tiny )
  assertErrorMsgContains( msg[1], matrix, eps  )
  assertErrorMsgContains( msg[1], matrix, 1..2 )
  assertErrorMsgContains( msg[1], matrix, infi )
  assertErrorMsgContains( msg[1], matrix, nan  )
  assertErrorMsgContains( msg[1], matrix,-1    )
  assertErrorMsgContains( msg[1], matrix,-eps  )
  assertErrorMsgContains( msg[2], matrix, inf  )
  assertErrorMsgContains( msg[2], matrix, huge )

  for i=1,3 do mat [i] = matrix(  i,  i)
               vec [i] = vector(  i,  i) end

  for i,v in ipairs(vec) do
    assertTrue  ( is_matrix(v) )
    assertTrue  ( is_vector(v) )
    assertEquals( v.nr, i )
    assertEquals( v.nc, 1 )
  end

  for i,m in ipairs(mat) do
    assertTrue  ( is_matrix(m) )
    assertEquals( m.nr, i )
    assertEquals( m.nc, i )
  end
end

function TestMatrix:testCtorCMatrix()
  local cmat, cvec = {}, {}
  local msg = {
  "invalid argument #1 or #2 (nrow[,ncol] >=1 or table [of tables] expected)",
  "bad argument #1 to 'malloc' (cannot convert 'nil' to 'uint64_t')" ,
  }
  assertErrorMsgContains( msg[1], cmatrix, ''   )
  assertErrorMsgContains( msg[1], cmatrix, nil  )
  assertErrorMsgContains( msg[1], cmatrix, 0    )
  assertErrorMsgContains( msg[1], cmatrix, tiny )
  assertErrorMsgContains( msg[1], cmatrix, eps  )
  assertErrorMsgContains( msg[1], cmatrix,-1    )
  assertErrorMsgContains( msg[1], cmatrix,-tiny )
  assertErrorMsgContains( msg[1], cmatrix, 1..2 )
  assertErrorMsgContains( msg[1], cmatrix, infi )
  assertErrorMsgContains( msg[1], cmatrix,-infi )
  assertErrorMsgContains( msg[1], cmatrix, nan  )
  assertErrorMsgContains( msg[1], cmatrix,-inf  )
  assertErrorMsgContains( msg[2], cmatrix, inf  )
  for i=1,3 do cmat [i] = cmatrix( i, i)
               cvec [i] = cvector( i, i) end

  for i,cv in ipairs(cvec) do
    assertTrue  ( is_cmatrix(cv) )
    assertTrue  ( is_cvector(cv) )
    assertEquals( cv.nr, i )
    assertEquals( cv.nc, 1 )
  end

  for i,cm in ipairs(cmat) do
    assertTrue  ( is_cmatrix(cm) )
    assertEquals( cm.nr, i )
    assertEquals( cm.nc, i )
  end
end

function TestMatrix:testCtorFromtable() --TODO
  local msg = {
  "invalid argument #1 (non-empty table expected)",
  "cannot convert 'string' to 'double'"           ,
  }
  assertErrorMsgContains( msg[1], matrix, {}   )
  assertErrorMsgContains( msg[2], matrix, {''} )

  assertTrue  ( is_matrix(matrix({ inf})) )
  assertTrue  ( is_matrix(matrix({-inf})) )
  assertTrue  ( is_matrix(matrix({ nan})) )
  assertEquals( matrix( { complex(0,1)}), matrix( 1)  ) -- complex matrix?
  assertEquals( matrix( { 1..2}        ), matrix({1}) )
  assertEquals( matrix( { matrix(2)}   ), matrix( 1)  )
end

function TestMatrix:testAlloc() --TODO after alloc fun changes
  local m, cm, v
  --m  =  matrix (16,16)
  --cm = cmatrix (12,12)
  --v = vector(2^32)
  --v = vector(2^27)
  --v = vector(2^26)
  --print(v:size())

  -- m =  matrix(20,20):random()-- *** Error in `./mad': free(): corrupted unsorted chunks: 0x000000000104ae70 ***
  --cm = cmatrix(10,10):random()
end

function TestMatrix:testCdataType()
  assertTrue ( is_matrix( matrix(2,2)) )
  assertFalse( is_matrix(cmatrix(2,2)) )
  assertTrue ( is_matrix( vector(1)  ) )
  assertFalse( is_matrix(cvector(1)  ) )

  assertFalse( is_cmatrix( matrix(2,2)) )
  assertTrue ( is_cmatrix(cmatrix(2,2)) )
  assertFalse( is_cmatrix( vector(1)  ) )
  assertTrue ( is_cmatrix(cvector(1)  ) )

  assertFalse( is_vector( matrix(2,2)) )
  assertFalse( is_vector(cmatrix(2,2)) )
  assertTrue ( is_vector( vector(1)  ) )
  assertFalse( is_vector(cvector(1)  ) )

  assertFalse( is_cvector( matrix(2,2)) )
  assertFalse( is_cvector(cmatrix(2,2)) )
  assertFalse( is_cvector( vector(1)  ) )
  assertTrue ( is_cvector(cvector(1)  ) )

  assertFalse( isa_vector( matrix(2,2)) )
  assertFalse( isa_vector(cmatrix(2,2)) )
  assertTrue ( isa_vector( vector(1)  ) )
  assertTrue ( isa_vector(cvector(1)  ) )

  assertTrue ( isa_matrix( matrix(2,2)) )
  assertTrue ( isa_matrix(cmatrix(2,2)) )
  assertTrue ( isa_matrix( vector(1)  ) )
  assertTrue ( isa_matrix(cvector(1)  ) )
end

--function TestMatrix:testIs_matrix()  end
--function TestMatrix:testIs_cmatrix() end
--function TestMatrix:testIs_vector()  end
--function TestMatrix:testIs_cvector() end
--function TestMatrix:testIsa_vector() end
--function TestMatrix:testIsa_matrix() end

-- get, set -------------------------------------------------------------------o

function TestMatrix:testGeti0()
  local msg = {
    "attempt to compare nil with number",
    }
  assertErrorMsgContains( msg[1], mth, 'geti0', matrix(2,2), nil )
  assertNil   (  matrix(2,2):geti0( nan  )    )
  assertNil   (  matrix(2,2):geti0(-1    )    )
  assertEquals(  matrix(2,2):geti0( 0    ), 0 )
  assertNil   (  matrix(2,2):geti0( 0-eps)    )
  assertEquals(  matrix(2,2):geti0( 3    ), 0 )
  assertEquals(  matrix(2,2):geti0( 3+eps), 0 )
  assertNil   (  matrix(2,2):geti0( 4    )    )
  assertNil   (  matrix(2,2):geti0( 4-eps)    )
  assertNil   ( cmatrix(2,2):geti0( nan  )    )
  assertNil   ( cmatrix(2,2):geti0(-1    )    )
  assertNil   ( cmatrix(2,2):geti0( 4    )    )
  assertEquals( matrix({1,2}):geti0(0.1  ), matrix({1,2}):geti0( 0) )
  assertEquals( matrix({1,2}):geti0(1-eps), matrix({1,2}):geti0( 0) )

  for nr=1,5 do
  for nc=1,5 do
    local m = matrix(nr,nc):fill(1..(nr*nc))
    for i=1,nr*nc do assertEquals( m:geti0(i-1), i ) end
  end end

  for nr=1,5 do
  for nc=1,5 do
    local cm = cmatrix(nr,nc):fill(1..(nr*nc)):fill(\x x+x*1i)
    for i=1,nr*nc do assertEquals( cm:geti0(i-1), complex(i,i) ) end
  end end
end

function TestMatrix:testGeti()
local msg = {
    "attempt to compare nil with number",
    }
  assertErrorMsgContains( msg[1], mth, 'geti', matrix(2,2), nil )
  assertNil   (  matrix(2,2):geti( nan  )    )
  assertNil   (  matrix(2,2):geti( 0    )    )
  assertEquals(  matrix(2,2):geti( 1    ), 0 )
  assertNil   (  matrix(2,2):geti( 1-eps)    )
  assertEquals(  matrix(2,2):geti( 4    ), 0 )
  assertEquals(  matrix(2,2):geti( 4+eps), 0 )
  assertNil   (  matrix(2,2):geti( 5    )    )
  assertNil   (  matrix(2,2):geti( 5-eps)    )
  assertNil   ( cmatrix(2,2):geti( nan  )    )
  assertNil   ( cmatrix(2,2):geti( 0    )    )
  assertNil   ( cmatrix(2,2):geti( 5    )    )
  assertEquals( matrix({1,2}):geti( 1.1 ), matrix({1,2}):geti( 1) )

  for nr=1,5 do
  for nc=1,5 do
    local m = matrix(nr,nc):fill(1..(nr*nc))
    for i=1,nr*nc do assertEquals( m:geti(i), i ) end
  end end

  for nr=1,5 do
  for nc=1,5 do
    local cm = cmatrix(nr,nc):fill(1..(nr*nc)):fill(\x x+x*1i)
    for i=1,nr*nc do assertEquals( cm:geti(i), complex(i,i) ) end
  end end
end

function TestMatrix:testGet0()
  local msg = {
    "attempt to compare nil with number",
    }
  assertErrorMsgContains( msg[1], mth, 'get0', matrix(2,2), 0  , nil )
  assertErrorMsgContains( msg[1], mth, 'get0', matrix(2,2), nil, 0   )
  assertNil   (  matrix(2,2):get0( nan  , 0)    )
  assertNil   (  matrix(2,2):get0(-1    , 0)    )
  assertEquals(  matrix(2,2):get0( 0    , 0), 0 )
  assertNil   (  matrix(2,2):get0( 0-eps, 0)    )
  assertEquals(  matrix(2,2):get0( 1    , 1), 0 )
  assertEquals(  matrix(2,2):get0( 1+eps, 1), 0 )
  assertNil   (  matrix(2,2):get0( 2    , 2)    )
  assertNil   (  matrix(2,2):get0( 2-eps, 2)    )
  assertNil   ( cmatrix(2,2):get0( nan  , 0)    )
  assertNil   ( cmatrix(2,2):get0(-1    , 0)    )
  assertNil   ( cmatrix(2,2):get0( 2    , 0)    )

  for nr=1,5 do
  for nc=1,5 do
    local m = matrix(nr,nc):fill(1..(nr*nc))
    for i=1,nr do for j=1,nc do  assertEquals( m:get0(i-1,j-1), (i-1)*nc+j )  end end
  end end

  for nr=1,5 do
  for nc=1,5 do
    local cm = cmatrix(nr,nc):fill(1..(nr*nc)):fill(\x x+x*1i)
    for i=1,nr do for j=1,nc do
      assertEquals( cm:get0(i-1,j-1), complex((i-1)*nc+j,(i-1)*nc+j) )
      end end
  end end
end

function TestMatrix:testGet()
  local msg = {
    "attempt to compare nil with number",
    }
  assertErrorMsgContains( msg[1], mth, 'get0', matrix(2,2), 1  , nil )
  assertErrorMsgContains( msg[1], mth, 'get0', matrix(2,2), nil, 1   )
  assertNil   (  matrix(2,2):get( nan  , 1)    )
  assertNil   (  matrix(2,2):get(-1    , 0)    )
  assertEquals(  matrix(2,2):get( 1    , 1), 0 )
  assertNil   (  matrix(2,2):get( 1-eps, 1)    )
  assertEquals(  matrix(2,2):get( 2    , 2), 0 )
  assertEquals(  matrix(2,2):get( 2+eps, 2), 0 )
  assertNil   (  matrix(2,2):get( 3    , 3)    )
  assertNil   (  matrix(2,2):get( 3-eps, 3)    )
  assertNil   ( cmatrix(2,2):get( nan  , 1)    )
  assertNil   ( cmatrix(2,2):get( 0    , 0)    )
  assertNil   ( cmatrix(2,2):get( 3    , 0)    )

  for nr=1,5 do
  for nc=1,5 do
    local m = matrix(nr,nc):fill(1..(nr*nc))
    for i=1,nr do for j=1,nc do
      assertEquals( m:get(i,j), (i-1)*nc + j )
    end end
  end end

  for nr=1,5 do
  for nc=1,5 do
    local cm = cmatrix(nr,nc):fill(1..(nr*nc)):fill(\x x+x*1i)
    for i=1,nr do for j=1,nc do
      assertEquals( cm:get(i,j), complex((i-1)*nc+j,(i-1)*nc+j) )
      end end
  end end
end

function TestMatrix:testSeti0() --extra test, used in fill()
  local msg = {
    "0-index out of bounds",
    "attempt to compare nil with number",
    }
  assertErrorMsgContains( msg[1], mth, 'seti0', matrix(2,2), nan  , 1 )
  assertErrorMsgContains( msg[2], mth, 'seti0', matrix(2,2), nil  , 1 )
  assertErrorMsgContains( msg[1], mth, 'seti0', matrix(2,2),-1    , 1 )
  assertErrorMsgContains( msg[1], mth, 'seti0', matrix(2,2),-eps  , 1 )
  assertErrorMsgContains( msg[1], mth, 'seti0', matrix(2,2), 5    , 1 )
  assertErrorMsgContains( msg[1], mth, 'seti0', matrix(2,2), 5-eps, 1 )

  for nr=1,5 do
  for nc=1,5 do
    local m = matrix(nr,nc)
    for i=1,nr*nc do
      m:seti0((i-1), i)
      assertEquals( m:geti0(i-1), i ) end
  end end

  for nr=1,5 do
  for nc=1,5 do
    local cm = cmatrix(nr,nc)
    for i=1,nr*nc do
      cm:seti0((i-1), complex(i,i))
      assertEquals( cm:geti0(i-1), complex(i,i) ) end
  end end
end

function TestMatrix:testSeti()
  local msg = {
    "1-index out of bounds",
    "attempt to compare nil with number",
    }
  assertErrorMsgContains( msg[1], mth, 'seti', matrix(2,2), 0   , 1 )
  assertErrorMsgContains( msg[1], mth, 'seti', matrix(2,2), 0.1 , 1 )
  assertErrorMsgContains( msg[1], mth, 'seti', matrix(2,2),-1   , 1 )
  assertErrorMsgContains( msg[1], mth, 'seti', matrix(2,2), inf , 1 )
  assertErrorMsgContains( msg[1], mth, 'seti', matrix(2,2), nan , 1 )
  assertErrorMsgContains( msg[2], mth, 'seti', matrix(2,2), nil , 1 )

  for nr=1,5 do
  for nc=1,5 do
    local m = matrix(nr,nc)
    for i=1,nr*nc do
      m:seti((i), i)
      assertEquals( m:geti0(i-1), i ) end
  end end

  for nr=1,5 do
  for nc=1,5 do
    local cm = cmatrix(nr,nc)
    for i=1,nr*nc do
      cm:seti((i), complex(i,i))
      assertEquals( cm:geti0(i-1), complex(i,i) ) end
  end end
end

function TestMatrix:testSet0()
  local msg = {
    "0-index out of bounds",
    "attempt to compare nil with number",
    }
  assertErrorMsgContains( msg[1], mth, 'set0', matrix(2,2), nan , 1, 1 )
  assertErrorMsgContains( msg[2], mth, 'set0', matrix(2,2), nil , 1, 1 )
  assertErrorMsgContains( msg[1], mth, 'set0', matrix(2,2),-1   , 1, 1 )
  assertErrorMsgContains( msg[1], mth, 'set0', matrix(2,2), 3   , 1, 1 )

  for nr=1,5 do
  for nc=1,5 do
    local m = matrix(nr,nc)
    local mRef = matrix(nr,nc):fill(1..(nr*nc))
    for i=1,nr do for j=1,nc do
      m:set0(i-1,j-1, (i-1)*nc+j )
      assertEquals( m:get0(i-1,j-1), mRef:get0(i-1,j-1) )
    end end
  end end

  for nr=1,5 do
  for nc=1,5 do
    local cm = cmatrix(nr,nc)
    local cmRef = cmatrix(nr,nc):fill(1..(nr*nc)):fill(\x x+x*1i)
    for i=1,nr do for j=1,nc do
      cm:set0(i-1,j-1, complex((i-1)*nc+j,(i-1)*nc+j))
      assertEquals( cm:get0(i-1,j-1), cmRef:get0(i-1,j-1) )
      end end
  end end
end

function TestMatrix:testSet()
  local msg = {
    "1-index out of bounds",
    "attempt to compare nil with number",
    }
  assertErrorMsgContains( msg[1], mth, 'set', matrix(2,2), 0   , 1, 1 )
  assertErrorMsgContains( msg[1], mth, 'set', matrix(2,2), 0.1 , 1, 1 )
  assertErrorMsgContains( msg[1], mth, 'set', matrix(2,2),-1   , 1, 1 )
  assertErrorMsgContains( msg[1], mth, 'set', matrix(2,2), inf , 1, 1 )
  assertErrorMsgContains( msg[1], mth, 'set', matrix(2,2), nan , 1, 1 )
  assertErrorMsgContains( msg[2], mth, 'set', matrix(2,2), nil , 1, 1 )

  for nr=1,5 do
  for nc=1,5 do
    local m = matrix(nr,nc)
    local mRef = matrix(nr,nc):fill(1..(nr*nc))
    for i=1,nr do for j=1,nc do
      m:set(i,j, (i-1)*nc+j )
      assertEquals( m:get0(i-1,j-1), mRef:get0(i-1,j-1) )
    end end
  end end

  for nr=1,5 do
  for nc=1,5 do
    local cm = cmatrix(nr,nc)
    local cmRef = cmatrix(nr,nc):fill(1..(nr*nc)):fill(\x x+x*1i)
    for i=1,nr do for j=1,nc do
      cm:set(i,j, complex((i-1)*nc+j,(i-1)*nc+j))
      assertEquals( cm:get0(i-1,j-1), cmRef:get0(i-1,j-1) )
      end end
  end end
end

-- both linspance and logspace special cases issing
function TestMatrix:testLinspace() --TODO after changes
  local nrng = {
          { 1 , 10, 100}, { 1, 10, 100}   , { 10, 1 , 10}, { 1,-10, 10},
          { 10,-1 , 100}, {-1, 10, 100}   , {-10, 1 , 10}, {-1,-10, 10},
          {-10,-1 , 100}, -- { 1, 2  , 2^64-2 },-- { 0.5, 1 , 2^64-1 },
          }  --uint64 biggest 2^64-1 (biggest posible for malloc)
  local msg, l, r = {
    "attempt to perform arithmetic on local 'start'",
    "attempt to perform arithmetic on local 'stop' ",
    "invalid argument #3 (size expected)"           ,
    "bad argument #1 to 'malloc' (cannot convert 'nil' to 'uint64_t')",
  }
  assertErrorMsgContains( msg[1], linspace, nil, 1   )
  assertErrorMsgContains( msg[1], linspace, '' , 1   )
  assertErrorMsgContains( msg[2], linspace, 1  , nil )
  assertErrorMsgContains( msg[2], linspace, 1  , ''  )
  assertErrorMsgContains( msg[3], linspace, 2  , 2  , 0   )
  assertErrorMsgContains( msg[3], linspace, 2  , 2  ,-1   )
  assertErrorMsgContains( msg[3], linspace, 2  , 2  , nan )
  assertErrorMsgContains( msg[3], linspace, 2  , 2  ,-inf )
  assertErrorMsgContains( msg[3], linspace, 2  , 2  , ''  )
  assertErrorMsgContains( msg[4], linspace, 2  , 2  , inf )

  assertTrue  (  is_cdata (linspace(1,1)) )
  assertTrue  (  is_vector(linspace(1,1)) )
  assertEquals( #linspace( 2, 2, nil)     , 100 )
  assertEquals(  linspace( 2, 2, nil)[1]  , 2   )
  assertEquals(  linspace( 2, 2, nil)[100], 2   )

  l = linspace( 2  ,-inf)  for i = 2, #l do assertInf( l[i] ) end assertNaN( l[1] )
  l = linspace( 2  , inf)  for i = 2, #l do assertInf( l[i] ) end assertNaN( l[1] )
  l = linspace( inf, 2  )  for i = 1, #l do assertNaN( l[i] ) end
  l = linspace(-inf, 2  )  for i = 1, #l do assertNaN( l[i] ) end
  l = linspace( 2  , nan)  for i = 1, #l do assertNaN( l[i] ) end
  l = linspace( nan, 2  )  for i = 1, #l do assertNaN( l[i] ) end

  for _,v in ipairs(nrng) do
    nr = nrange  ( v[1], v[2], v[3] )
    l  = linspace( v[1], v[2], v[3] )
    for i=1,#nr do
      assertEquals( l[i] - nr[i], 0 )
    end
  end

  for _,v in ipairs(values.num) do
    if v >= 1 and v < 10^4 then
      nr = nrange  ( 1, 10, v)
      l  = linspace( 1, 10, v)
      --print( v, nr:size(), #l )
      for i=1,#nr do
        --assertEquals( l[i] - nr[i], 0 )
      end
    end
  end
end

function TestMatrix:testLogspace()
  local msg, l = {
    "attempt to index local 'x' "        ,
    "attempt to call method 'log' "      ,
    "invalid argument #3 (size expected)",
    "invalid argument #1 or #2 (nrow[,ncol] >=1 or table [of tables] expected)",
    "bad argument #1 to 'malloc' (cannot convert 'nil' to 'uint64_t')"         ,
    }
  assertErrorMsgContains( msg[1], logspace, nil, 1   )
  assertErrorMsgContains( msg[2], logspace, '' , 1   )
  assertErrorMsgContains( msg[1], logspace, 1  , nil )
  assertErrorMsgContains( msg[2], logspace, 1  , ''  )

  assertErrorMsgContains( msg[4], logspace, 2  ,2   , eps)
  assertErrorMsgContains( msg[3], logspace, 2  ,2   ,-1  )
  assertErrorMsgContains( msg[3], logspace, 2  ,2   , 0  )
  assertErrorMsgContains( msg[3], logspace, 2  ,2   , nan)
  assertErrorMsgContains( msg[3], logspace, 2  ,2   ,-inf)
  assertErrorMsgContains( msg[5], logspace, 2  ,2   , inf)

  assertEquals( #logspace( 2, 2, nil)     , 100 )
  assertEquals(  logspace( 2, 2, nil)[1]  , 2   )
  assertEquals(  logspace( 2, 2, nil)[100], 2   )

  l = logspace( 2  ,-inf)  for i = 1, #l do assertNaN( l[i] ) end
  l = logspace( 2  , inf)  for i = 2, #l do assertInf( l[i] ) end assertNaN( l[1] )
  l = logspace( inf, 2  )  for i = 1, #l do assertNaN( l[i] ) end
  l = logspace(-inf, 2  )  for i = 1, #l do assertNaN( l[i] ) end
  l = logspace( 2  , nan)  for i = 1, #l do assertNaN( l[i] ) end
  l = logspace( nan, 2  )  for i = 1, #l do assertNaN( l[i] ) end
end

function TestMatrix:testSame()
  local m, cm =  matrix(3,3):random(), cmatrix(3,3):random()
  local msg, s = {
    "invalid argument #2 (scalar expected)",
    "invalid argument #1 or #2 (nrow[,ncol] >=1 or table [of tables] expected)",
    }
  assertErrorMsgContains( msg[1], mth, 'same', matrix(2,2), ''      )
  assertErrorMsgContains( msg[1], mth, 'same', matrix(2,2), {}      )
  assertErrorMsgContains( msg[1], mth, 'same', matrix(2,2), 1..2    )
  assertErrorMsgContains( msg[2], mth, 'same', matrix(2,2), 1, ''   )
  assertErrorMsgContains( msg[2], mth, 'same', matrix(2,2), 1, {}   )
  assertErrorMsgContains( msg[2], mth, 'same', matrix(2,2), 1, 1..2 )
  assertErrorMsgContains( msg[2], mth, 'same', matrix(2,2), 1, nan  )
  s = m:same( nan)  assertEquals( s:get(1,1), 0 )
  s = m:same( inf)  assertEquals( s:get(1,1), 0 )
  s = m:same( 0  )  assertEquals( s:get(1,1), 0 )

  -- no input
  for i = 1,3 do for j = 1,3 do  assertEquals( s:get(i,j), 0 ) end end
  s = cm:same( ) assertFalse( is_matrix(s) ) assertTrue ( is_cmatrix(s) ) assertEquals( {s.nr,s.nc}, {m.nr, m.nc} )
  s =  m:same( ) assertTrue ( is_matrix(s) ) assertFalse( is_cmatrix(s) ) assertEquals( {s.nr,s.nc}, {m.nr, m.nc} )

  -- one arg: e_
  s =  m:same(complex(1,1))
  assertFalse( is_matrix(s) ) assertTrue ( is_cmatrix(s) ) assertEquals( {s.nr,s.nc}, {m.nr,m.nc} )
  s = cm:same(1)
  assertTrue ( is_matrix(s) ) assertFalse( is_cmatrix(s) ) assertEquals( {s.nr,s.nc}, {m.nr,m.nc} )
  for i = 1,3 do for j = 1,3 do  assertEquals( s:get(i,j), 0 ) end end

  -- two arg: nr, nc
  s = cm:same(2,2) assertFalse( is_matrix(s) ) assertTrue ( is_cmatrix(s) ) assertEquals( {s.nr,s.nc}, {2,2} )
  s = cm:same(4,4) assertFalse( is_matrix(s) ) assertTrue ( is_cmatrix(s) ) assertEquals( {s.nr,s.nc}, {4,4} )
  s =  m:same(2,2) assertTrue ( is_matrix(s) ) assertFalse( is_cmatrix(s) ) assertEquals( {s.nr,s.nc}, {2,2} )
  s =  m:same(4,4) assertTrue ( is_matrix(s) ) assertFalse( is_cmatrix(s) ) assertEquals( {s.nr,s.nc}, {4,4} )
  for i = 1,4 do for j = 1,4 do  assertEquals( s:get(i,j), 0 ) end end

  -- three arg: e_, nr, nc
  s = m:same(complex(1,1), 2, 2)
  assertFalse( is_matrix(s) ) assertTrue ( is_cmatrix(s) ) assertEquals( {s.nr,s.nc}, {2,2} )
  s = m:same(complex(1,1), 5, 5)
  assertFalse( is_matrix(s) ) assertTrue ( is_cmatrix(s) ) assertEquals( {s.nr,s.nc}, {5,5} )
  s = cm:same(1, 2, 2)
  assertTrue ( is_matrix(s) ) assertFalse( is_cmatrix(s) ) assertEquals( {s.nr,s.nc}, {2,2} )
  s = cm:same(1, 5, 5)
  assertTrue ( is_matrix(s) ) assertFalse( is_cmatrix(s) ) assertEquals( {s.nr,s.nc}, {5,5} )
  for i = 1,5 do for j = 1,5 do  assertEquals( s:get(i,j), 0 ) end end
end

-- size, same -----------------------------------------------------------------o

local subM, subCM = {}, {}
for j=1,10 do subM [j] =  matrix(10,10):getsub(1..10, 1..j)
              subCM[j] = cmatrix(10,10):getsub(1..10, 1..j)
end

local  mat,  vec = {}, {}
for j=1,10 do mat[j] = matrix(j,j) end
for j=1,10 do vec[j] = vector(j)   end


function TestMatrix:testNrow()
  local m, cm , v, cv
  for nr=1,10 do
     v =  vector(nr)       assertEquals(  v:nrow(), nr )
    cv = cvector(nr)       assertEquals( cv:nrow(), nr )
    for nc=1,10 do
       m =  matrix(nr,nc)  assertEquals(  m:nrow(), nr )
      cm = cmatrix(nr,nc)  assertEquals( cm:nrow(), nr )
    end
  end
end

function TestMatrix:testNcol()
local m, cm , v, cv
  for nr=1,10 do
     v =  vector(nr)       assertEquals(  v:ncol(), 1  )
    cv = cvector(nr)       assertEquals( cv:ncol(), 1  )
    for nc=1,10 do
       m =  matrix(nr,nc)  assertEquals(  m:ncol(), nc )
      cm = cmatrix(nr,nc)  assertEquals( cm:ncol(), nc )
    end
  end
end

function TestMatrix:testSize()
  local m, cm , v, cv
  for nr=1,10 do
     v =  vector(nr)       assertEquals(  v:size(), nr*1  )
    cv = cvector(nr)       assertEquals( cv:size(), nr*1  )
    for nc=1,10 do
       m =  matrix(nr,nc)  assertEquals(  m:size(), nr*nc )
      cm = cmatrix(nr,nc)  assertEquals( cm:size(), nr*nc )
    end
  end
end

function TestMatrix:testSizes()
  local m, cm , v, cv
  for nr=1,10 do
     v =  vector(nr)       assertEquals( { v:sizes()}, {nr,1 } )
    cv = cvector(nr)       assertEquals( {cv:sizes()}, {nr,1 } )
    for nc=1,10 do
       m =  matrix(nr,nc)  assertEquals( { m:sizes()}, {nr,nc} )
      cm = cmatrix(nr,nc)  assertEquals( {cm:sizes()}, {nr,nc} )
    end
  end
end

function TestMatrix:testTsizes()
  local m, cm , v, cv
  for nr=1,10 do
     v =  vector(nr)       assertEquals( { v:tsizes()}, {1 ,nr} )
    cv = cvector(nr)       assertEquals( {cv:tsizes()}, {1 ,nr} )
    for nc=1,10 do
       m =  matrix(nr,nc)  assertEquals( { m:tsizes()}, {nc,nr} )
      cm = cmatrix(nr,nc)  assertEquals( {cm:tsizes()}, {nc,nr} )
    end
  end
end

function TestMatrix:testRandom() -- uses seti0, size
  local m1, m2 = matrix(2,2)
  local msg = {
    "invalid argument #2 (callable expected)",
    }
  assertErrorMsgContains( msg[1], mth,'random', m1, nan )
  assertErrorMsgContains( msg[1], mth,'random', m1, 1   )

  randomseed(2^52)  --randomseed(os.clock()*2^52)
  local oldVal, val = {},{}
  for i=1,2 do
    m1 = matrix(2,2):random()
    for i = 1,m1:size() do
      val[i] = m1:geti(i)
      assertTrue ( val[i] <  1    )
      assertTrue ( val[i] >= 0    )
      assertTrue ( val[i] <= 2^52 )
      assertFalse( val[i] == oldVal[i] )
      oldVal[i] = val[i]
    end
  end
end

function TestMatrix:testFill()
  local msg, m, cm = {
    "invalid argument #2 (scalar, callable or indexable expected)",
    }
  m  =  matrix(3,3)
  cm = cmatrix(3,3)
  assertErrorMsgContains( msg[1], mth,'fill', matrix(2,2), true )
  assertErrorMsgContains( msg[1], mth,'fill', matrix(2,2), nil  )

  --scalar
  m :fill(nan)          for i=1,m :size() do assertNaN   ( m :geti(i)    ) end
  m :fill(inf)          for i=1,m :size() do assertInf   ( m :geti(i)    ) end
  m :fill(1  )          for i=1,m :size() do assertEquals( m :geti(i), 1 ) end
  m :fill(complex(1,1)) for i=1,m :size() do assertEquals( m :geti(i), 1 ) end
  cm:fill(complex(1,1)) for i=1,cm:size() do assertEquals( cm:geti(i), complex(1,1) ) end

   --generator

  --cmatrix(nr,nc):fill(1..(nr*nc)):fill(\x x+x*1i)

   --2D container (2d tables, matrices, )
  m :fill(1..#m)        for i=1,m :size() do assertEquals( m :geti(i), i  ) end
  cm:fill(1..#m)        for i=1,m :size() do assertEquals( cm:geti(i), complex(i) ) end

   --1D container( 1d vectors, )
end

function TestMatrix:testGetsub()
  local msg = {
    "invalid argument #2 (iterable expected)", --is_iterable(ir) --has iparis or number
    "invalid argument #3 (iterable expected)", --is_iterable(jc) --has iparis or number
    "invalid argument #4 (iterable expected)", --is_iterable(r ) --has iparis
    "invalid range member '1'"        ,
    "cannot convert 'nil' to 'double'",
    }
  assertErrorMsgContains( msg[1], mth, 'getsub', matrix(2,2), ''  , 0   , 1    )
  assertErrorMsgContains( msg[2], mth, 'getsub', matrix(2,2), 2                )
  assertErrorMsgContains( msg[2], mth, 'getsub', matrix(2,2), 2..1             )
  assertErrorMsgContains( msg[3], mth, 'getsub', matrix(2,2), 0   , 0   , 1    )
  assertErrorMsgContains( msg[3], mth, 'getsub', matrix(2,2), 1..2, 1..2, \x x )
  assertErrorMsgContains( msg[4], mth, 'getsub', matrix(2,2), 1..2, 1..2, 1..4 )

  assertErrorMsgContains( msg[5], mth, 'getsub', matrix(2,2), 0, 0             )
  assertErrorMsgContains( msg[5], mth, 'getsub', matrix(2,2), 3, 1             )
  assertErrorMsgContains( msg[5], mth, 'getsub', matrix(2,2), 0, 1, matrix(1)  )
  assertErrorMsgContains( msg[5], mth, 'getsub', matrix(2,2), 3, 1, matrix(1)  )

  local M = matrix(3,3):fill(1..(3*3))

  assertEquals( M:getsub(4 , 1, {}), {} )
  assertEquals( M:getsub(0 , 1, {}), {} )
  assertEquals( M:getsub( 1,1)        , matrix( {1}          ) )
  assertEquals( M:getsub( 1,1)        , matrix( {1}          ) )
  assertEquals( M:getsub( 2,2)        , matrix( {5}          ) )
  assertEquals( M:getsub({1,2}, 2    ), matrix( {2,5}        ) )
  assertEquals( M:getsub({1,2},{2,3} ), matrix({{2,3},{5,6}} ) )
  assertEquals( M:getsub( 1..2, 1..2 ), matrix({{1,2},{4,5}} ) )
  assertEquals( M:getsub( 1, 1..2 )   , matrix({{1,2}}       ) )
  assertEquals( M:getsub( 1..3, 3 )   , matrix( {3,6,9}      ) )

  assertEquals( M:getsub( 1   , 1   , {}       ),  {1}         )
  assertEquals( M:getsub({1,2}, 2   , {}       ),  {2,5}       )
  assertEquals( M:getsub( 1..2, 1..2, {}       ),  {1,2,4,5}   )
  assertEquals( M:getsub( 1   , 2   , vector(1)),  vector({2}) )
  assertEquals( M:getsub( 2   , 1   , vector(1)),  matrix({4}) )
  assertEquals( M:getsub( 2   , 1   , matrix(1)),  matrix({4}) )
  assertEquals( M:getsub( 2   , 1   ,cmatrix(1)), cmatrix({4}) )
  assertEquals( M:getsub( 2   , 1   ,cmatrix(1)), cmatrix({4}) )
  assertEquals( M:getsub( 2   , 1   , matrix(2)),  matrix({{4,0},{0,0}}) )

  assertEquals( M:getsub(linspace(1,3,3), 3)             , matrix( {3,6,9}) )
  assertEquals( M:getsub(linspace(1,2,2),linspace(1,2,2)), matrix({{1,2},{4,5}}) )
  assertEquals( M:getsub(logspace(1,2,2),linspace(1,2,2)), matrix({{1,2},{4,5}}) )
end

--[[
function TestMatrix:testCopy()
  local msg, m = {
    "invalid argument #1 (matrix with compatible size expected"),}

end

function TestCMatrix:testCopy()
  local msg = {
    "invalid argument #1 (matrix with compatible size expected"),}
end

function TestMatrix:testZeros() end
function TestCMatrix:testZeros() end

function TestMatrix:testOnes() end
function TestMatrix:testEye() end

function TestMatrix:testSymp()
  local msg = {
    "invalid argument #1 (2n matrix expected)",}
end
function TestMatrix:testCirc()
  local msg = {
    "invalid argument #2 (iterable expected)",}
end

function TestMatrix:testVshape() end
function TestMatrix:testReshape()
  local msg = {
    "invalid matrix new sizes",
    }
end
-- conversion -----------------------------------------------------------------o

function TestMatrix:testTosting() end
function TestMatrix:testTotable() end

-- getx, setx -----------------------------------------------------------------o

function TestMatrix:testGetv() end
function TestMatrix:testSetv() end
function TestMatrix:testGetdiag() end
function TestMatrix:testSetdiag() end

function TestMatrix:testGetrow() end
function TestMatrix:testSetrow() end

function TestMatrix:testGetcol() end
function TestMatrix:testSetcol() end

function TestMatrix:testGetsub() end
function TestMatrix:testSetsub() end

-- foreach, filter, map, fold, scan -------------------------------------------o

function TestMatrix:testForeach() end
function TestMatrix:testFilter() end
function TestMatrix:testMapat() end
function TestMatrix:testMap() end
function TestMatrix:testMap2() end
function TestMatrix:testMap3() end

function TestMatrix:testFoldl() end
function TestMatrix:testFoldr() end

function TestMatrix:testScanl() end
function TestMatrix:testScanr() end

-- special maps ---------------------------------------------------------------o

function TestMatrix:testCeil () end
function TestMatrix:testFloor() end
function TestMatrix:testFrac () end
function TestMatrix:testTrunc() end
function TestMatrix:testRound() end

function TestMatrix:testAbs  () end
function TestMatrix:testSqrt () end
function TestMatrix:testExp  () end
function TestMatrix:testLog  () end
function TestMatrix:testLog10() end

function TestMatrix:testSin () end
function TestMatrix:testCos () end
function TestMatrix:testTan () end
function TestMatrix:testSinh() end
function TestMatrix:testCosh() end
function TestMatrix:testTanh() end

function TestMatrix:testAsin () end
function TestMatrix:testAcos () end
function TestMatrix:testAtan () end
function TestMatrix:testAsinh() end
function TestMatrix:testAcosh() end
function TestMatrix:testAtanh() end

function TestMatrix:testErf   () end
function TestMatrix:testTgamma() end
function TestMatrix:testLgamma() end

function TestMatrix:testCarg () end
function TestMatrix:testReal () end
function TestMatrix:testImag () end
function TestMatrix:testConj () end
function TestMatrix:testProj () end
function TestMatrix:testRect () end
function TestMatrix:testPolar() end

-- special folds --------------------------------------------------------------o

function TestMatrix:testMin() end
function TestMatrix:testMax() end
function TestMatrix:testSum() end
function TestMatrix:testSumabs() end
function TestMatrix:testSumsqr() end
function TestMatrix:testProduct() end
function TestMatrix:testAll() end
function TestMatrix:testAny() end

-- conjugate, transpose -------------------------------------------------------o

function TestMatrix:testTranspose() end
function TestCMatrix:testTranspose() end

function TestMatrix:testTrace() end

-- symplectic matrix ----------------------------------------------------------o

function TestMatrix:testSympinv() end
function TestCMatrix:testSympinv() end

function TestMatrix:testSymperr() end
function TestCMatrix:testSymperr() end

-- inner, cross, mixed, outer -------------------------------------------------o

function TestMatrix:testInner() end
function TestCMatrix:testInner() end

function TestMatrix:testCross() end
function TestMatrix:testMixed() end
function TestMatrix:testOuter() end

-- norm, unit, center, angle (in place) ---------------------------------------o

function TestMatrix:testNorm() end
function TestCMatrix:testNorm() end

function TestMatrix:testDistance() end
function TestCMatrix:testDistance() end

function TestMatrix:testUnit() end
function TestCMatrix:testUnit() end

function TestMatrix:testCenter() end
function TestCMatrix:testCenter() end

function TestMatrix:testAngle() end

-- operators ------------------------------------------------------------------o

function TestMatrix:testEq() end

function TestMatrix:testAddCPx() end
function TestMatrix:testAdd() end
function TestCMatrix:testAddCPx() end
function TestCMatrix:testAdd() end

function TestMatrix:testSubCPx() end
function TestMatrix:testSub() end
function TestCMatrix:testSubCPx() end
function TestCMatrix:testSub() end

function TestMatrix:testMulCPx() end
function TestMatrix:testMul() end
function TestCMatrix:testMulCPx() end
function TestCMatrix:testMul() end

function TestMatrix:testTmul() end
function TestCMatrix:testTmul() end

function TestMatrix:testDivCPx() end
function TestMatrix:testDiv() end
function TestCMatrix:testDivCPx() end
function TestCMatrix:testDiv() end

function TestMatrix:testEmul() end
function TestCMatrix:testEmul() end
function TestMatrix:testEdiv() end
function TestCMatrix:testEdiv() end

-- linear algebra -------------------------------------------------------------o

function TestMatrix:testSolve() end
function TestMatrix:testSvd() end
function TestCMatrix:testSvd() end

function TestMatrix:testEigen() end
function TestCMatrix:testEigen() end

-- FFT, convolution, correlation, covrariance ---------------------------------o

function TestMatrix:testFft() end
function TestMatrix:testIfft() end
function TestMatrix:testRfft() end
function TestMatrix:testIrfft() end

 -- convolution theorem
function TestMatrix:testConv() end
function TestCMatrix:testConv() end

 -- correlation theorem
function TestMatrix:testCorr() end
function TestCMatrix:testCorr() end
function TestMatrix:testCovar() end

-- concatenation --------------------------------------------------------------o

function TestMatrix:testConcat() end
]]

-- end ------------------------------------------------------------------------o
