--[=[
 o-----------------------------------------------------------------------------o
 |
 | Matrix module regression tests
 |
 | Methodical Accelerator Design - Copyright CERN 2015+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: A.Z. Teska, aleksandra.teska at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide regression test suites for the matrix module.

 o-----------------------------------------------------------------------------o
]=]

local assertEquals, assertAlmostEquals, assertTrue, assertFalse,
      assertErrorMsgContains, assertNil, assertNaN, assertIsString, assertInf
      in require 'luaunit'

local vector, cvector, matrix, cmatrix, is_vector, is_matrix, is_cvector,
      is_cmatrix, isa_vector, isa_matrix, linspace, logspace in MAD

local complex, range, nrange, nlogrange,infi, tiny, eps, huge, inf, nan, pi, Pi,
      randomseed, abs, log, min, totable, is_complex, is_cdata, is_table,
      is_nil, is_string in MAD

-- regression test suite ------------------------------------------------------o

TestMatrix  = {}
TestCMatrix = {}

local values = {
  num = { tiny, 2^-64, 2^-63, 2^-53, eps, 2^-52, 2*eps, 2^-32, 2^-31, 1e-9,
          0.1-eps, 0.1, 0.1+eps, 0.5, 0.7-eps, 0.7, 0.7+eps, 1-eps, 1, 1+eps,
          1.1, 1.7, 2, 10, 1e2, 1e3, 1e6, 1e9, 2^31, 2^32, 2^52, 2^53,
          2^63, 2^64, huge },
}

local mth = \f,s,... s[f](s,...)

function TestMatrix:testCtorMatrix()
  local m, v
  local msg = {
  "invalid argument #1 or #2 (nrow[,ncol] >=1 or table [of tables] expected)",
   "matrix too large",
  }
  assertErrorMsgContains( msg[1], matrix, ''     )
  assertErrorMsgContains( msg[1], matrix, nil    )
  assertErrorMsgContains( msg[1], matrix, 0      )
  assertErrorMsgContains( msg[1], matrix, tiny   )
  assertErrorMsgContains( msg[1], matrix, eps    )
  assertErrorMsgContains( msg[1], matrix, 1..2   )
  assertErrorMsgContains( msg[1], matrix, infi   )
  assertErrorMsgContains( msg[1], matrix, nan    )
  assertErrorMsgContains( msg[1], matrix,-1      )
  assertErrorMsgContains( msg[1], matrix,-eps    )
  assertErrorMsgContains( msg[2], matrix, inf    )
  assertErrorMsgContains( msg[2], matrix, huge   )
  assertErrorMsgContains( msg[2], matrix, 2^15+1 )
  assertErrorMsgContains( msg[2], vector, 2^30+1 )

  --assertTrue( is_matrix( vector(2^30)) )
  --assertTrue( is_matrix( matrix(2^15)) )
  for nr=1,5 do
    v = vector(nr)
    assertTrue  ( is_vector(v) )
    assertEquals( v.nr, nr )
    assertEquals( v.nc, 1  )
    for nc=1,5 do
      m = matrix(nr,nc)
      assertTrue  ( is_matrix(v) )
      assertTrue  ( is_matrix(m) )
      assertEquals( m.nr, nr )
      assertEquals( m.nc, nc )
    end end
end


function TestMatrix:testCtorCMatrix()
  local cm, cv
  local msg = {
  "invalid argument #1 or #2 (nrow[,ncol] >=1 or table [of tables] expected)",
  "matrix too large",
  }
  assertErrorMsgContains( msg[1], cmatrix, ''     )
  assertErrorMsgContains( msg[1], cmatrix, nil    )
  assertErrorMsgContains( msg[1], cmatrix, 0      )
  assertErrorMsgContains( msg[1], cmatrix, tiny   )
  assertErrorMsgContains( msg[1], cmatrix, eps    )
  assertErrorMsgContains( msg[1], cmatrix,-1      )
  assertErrorMsgContains( msg[1], cmatrix,-tiny   )
  assertErrorMsgContains( msg[1], cmatrix, 1..2   )
  assertErrorMsgContains( msg[1], cmatrix, infi   )
  assertErrorMsgContains( msg[1], cmatrix,-infi   )
  assertErrorMsgContains( msg[1], cmatrix, nan    )
  assertErrorMsgContains( msg[1], cmatrix,-inf    )
  assertErrorMsgContains( msg[2], cmatrix, inf    )
  assertErrorMsgContains( msg[2], cmatrix, 2^15   )
  assertErrorMsgContains( msg[2], cvector, 2^29+1 )

  --assertTrue( is_cmatrix( cvector(2^29)) )
  for nr=1,5 do
    cv = cvector(nr)
    assertTrue  ( is_cvector(cv) )
    assertEquals( cv.nr, nr )
    assertEquals( cv.nc, 1  )
    for nc=1,5 do
      cm = cmatrix(nr,nc)
      assertTrue  ( is_cmatrix(cv) )
      assertTrue  ( is_cmatrix(cm) )
      assertEquals( cm.nr, nr )
      assertEquals( cm.nc, nc )
    end end
end

function TestMatrix:testCtorFromtable() --TODO
  local msg = {
  "invalid argument #1 (non-empty table expected)",
  "cannot convert 'string' to 'double'"           ,
  "cannot convert 'string' to 'complex'"          ,
  }
  assertErrorMsgContains( msg[1],  matrix, {nil} )
  assertErrorMsgContains( msg[1], cmatrix, {}    )
  assertErrorMsgContains( msg[2],  matrix, {''}  )
  assertErrorMsgContains( msg[3], cmatrix, {''}  )

  assertTrue  ( is_matrix(matrix{ inf}) )
  assertTrue  ( is_matrix(matrix{-inf}) )
  assertTrue  ( is_matrix(matrix{ nan}) )
  assertEquals(  matrix{complex(0,1)} ,  matrix( 1)  ) -- complex/real matrix
  assertEquals(  matrix{matrix(2)}    ,  matrix( 1)  )
  assertEquals(  matrix{1..2}         ,  matrix({1}) )
  assertEquals( cmatrix{complex(0,1)} , cmatrix{complex(0,1)}  )
  assertEquals( cmatrix{1}.data[0]    , complex(1,0) ) -- data[0] used, needs change
  assertTrue  ( is_matrix ( matrix{2}      ) )
  assertTrue  ( is_vector ( matrix{2}      ) )
  assertTrue  ( is_cmatrix(cmatrix{2}      ) )
  assertTrue  ( is_cvector(cmatrix{2}      ) )
  assertTrue  ( is_vector ( matrix{{2,2,2}}) )
end

function TestMatrix:testCdataType()
  assertTrue ( is_matrix( matrix(2,2)) )
  assertFalse( is_matrix(cmatrix(2,2)) )
  assertTrue ( is_matrix( vector(1)  ) )
  assertFalse( is_matrix(cvector(1)  ) )

  assertFalse( is_cmatrix( matrix(2,2)) )
  assertTrue ( is_cmatrix(cmatrix(2,2)) )
  assertFalse( is_cmatrix( vector(1)  ) )
  assertTrue ( is_cmatrix(cvector(1)  ) )

  assertFalse( is_vector( matrix(2,2)) )
  assertFalse( is_vector(cmatrix(2,2)) )
  assertTrue ( is_vector( vector(1)  ) )
  assertFalse( is_vector(cvector(1)  ) )

  assertFalse( is_cvector( matrix(2,2)) )
  assertFalse( is_cvector(cmatrix(2,2)) )
  assertFalse( is_cvector( vector(1)  ) )
  assertTrue ( is_cvector(cvector(1)  ) )

  assertFalse( isa_vector( matrix(2,2)) )
  assertFalse( isa_vector(cmatrix(2,2)) )
  assertTrue ( isa_vector( vector(1)  ) )
  assertTrue ( isa_vector(cvector(1)  ) )

  assertTrue ( isa_matrix( matrix(2,2)) )
  assertTrue ( isa_matrix(cmatrix(2,2)) )
  assertTrue ( isa_matrix( vector(1)  ) )
  assertTrue ( isa_matrix(cvector(1)  ) )
end

--function TestMatrix:testIs_matrix()  end
--function TestMatrix:testIs_cmatrix() end
--function TestMatrix:testIs_vector()  end
--function TestMatrix:testIs_cvector() end
--function TestMatrix:testIsa_vector() end
--function TestMatrix:testIsa_matrix() end

-- get, set -------------------------------------------------------------------o

function TestMatrix:testGeti0()
  local msg, m, cm = {
    "attempt to compare nil with number",
    }
  assertErrorMsgContains( msg[1], mth, 'geti0', matrix(2), nil )
  assertNil   (  matrix(2):geti0( nan  )    )
  assertNil   (  matrix(2):geti0(-1    )    )
  assertEquals(  matrix(2):geti0( 0    ), 0 )
  assertNil   (  matrix(2):geti0( 0-eps)    )
  assertEquals(  matrix(2):geti0( 3    ), 0 )
  assertEquals(  matrix(2):geti0( 3+eps), 0 )
  assertNil   (  matrix(2):geti0( 4    )    )
  assertNil   (  matrix(2):geti0( 4-eps)    )
  assertNil   ( cmatrix(2):geti0( nan  )    )
  assertNil   ( cmatrix(2):geti0(-1    )    )
  assertNil   ( cmatrix(2):geti0( 4    )    )
  assertEquals( matrix({1,2}):geti0(0.1  ), matrix({1,2}):geti0( 0) )
  assertEquals( matrix({1,2}):geti0(1-eps), matrix({1,2}):geti0( 0) ) -- 4th interation err

  for nr=1,5 do
  for nc=1,5 do
    m  =  matrix(nr,nc):fill(1..nr*nc)
    cm = cmatrix(nr,nc):fill(1..nr*nc):fill(\x x+x*1i)
    for i=1,nr*nc do assertEquals( m :geti0(i-1), i            ) end
    for i=1,nr*nc do assertEquals( cm:geti0(i-1), complex(i,i) ) end
  end end
end

function TestMatrix:testGeti()
local msg, m, cm = {
    "attempt to compare nil with number",
    }
  assertErrorMsgContains( msg[1], mth, 'geti', matrix(2), nil )
  assertNil   (  matrix(2):geti( nan  )    )
  assertNil   (  matrix(2):geti( 0    )    )
  assertEquals(  matrix(2):geti( 1    ), 0 )
  assertNil   (  matrix(2):geti( 1-eps)    )
  assertEquals(  matrix(2):geti( 4    ), 0 )
  assertEquals(  matrix(2):geti( 4+eps), 0 )
  assertNil   (  matrix(2):geti( 5    )    )
  assertNil   (  matrix(2):geti( 5-eps)    )
  assertNil   ( cmatrix(2):geti( nan  )    )
  assertNil   ( cmatrix(2):geti( 0    )    )
  assertNil   ( cmatrix(2):geti( 5    )    )
  assertEquals( matrix({1,2}):geti( 1.1 ), matrix({1,2}):geti( 1) )

  for nr=1,5 do
  for nc=1,5 do
    m  =  matrix(nr,nc):fill(1..nr*nc)
    cm = cmatrix(nr,nc):fill(1..nr*nc):fill(\x x+x*1i)
    for i=1,nr*nc do assertEquals( m :geti(i), i            ) end
    for i=1,nr*nc do assertEquals( cm:geti(i), complex(i,i) ) end
  end end
end

function TestMatrix:testGet0()
  local msg, m, cm = {
    "attempt to compare nil with number",
    }
  assertErrorMsgContains( msg[1], mth, 'get0', matrix(2), 0  , nil )
  assertErrorMsgContains( msg[1], mth, 'get0', matrix(2), nil, 0   )
  assertNil   (  matrix(2):get0( nan  , 0)    )
  assertNil   (  matrix(2):get0(-1    , 0)    )
  assertEquals(  matrix(2):get0( 0    , 0), 0 )
  assertNil   (  matrix(2):get0( 0-eps, 0)    )
  assertEquals(  matrix(2):get0( 1    , 1), 0 )
  assertEquals(  matrix(2):get0( 1+eps, 1), 0 )
  assertNil   (  matrix(2):get0( 2    , 2)    )
  assertNil   (  matrix(2):get0( 2-eps, 2)    )
  assertNil   ( cmatrix(2):get0( nan  , 0)    )
  assertNil   ( cmatrix(2):get0(-1    , 0)    )
  assertNil   ( cmatrix(2):get0( 2    , 0)    )

  for nr=1,5 do
  for nc=1,5 do
    m  =  matrix(nr,nc):fill(1..nr*nc)
    cm = cmatrix(nr,nc):fill(1..nr*nc):fill(\x x+x*1i)
    for i=1,nr do for j=1,nc do
      assertEquals( m :get0(i-1,j-1), (i-1)*nc+j )
      assertEquals( cm:get0(i-1,j-1), complex((i-1)*nc+j,(i-1)*nc+j) )
    end end
  end end
end

function TestMatrix:testGet()
  local msg, m, cm = {
    "attempt to compare nil with number",
    }
  assertErrorMsgContains( msg[1], mth, 'get0', matrix(2), 1  , nil )
  assertErrorMsgContains( msg[1], mth, 'get0', matrix(2), nil, 1   )
  assertNil   (  matrix(2):get( nan  , 1)    )
  assertNil   (  matrix(2):get(-1    , 0)    )
  assertEquals(  matrix(2):get( 1    , 1), 0 )
  assertNil   (  matrix(2):get( 1-eps, 1)    )
  assertEquals(  matrix(2):get( 2    , 2), 0 )
  assertEquals(  matrix(2):get( 2+eps, 2), 0 )
  assertNil   (  matrix(2):get( 3    , 3)    )
  assertNil   (  matrix(2):get( 3-eps, 3)    )
  assertNil   ( cmatrix(2):get( nan  , 1)    )
  assertNil   ( cmatrix(2):get( 0    , 0)    )
  assertNil   ( cmatrix(2):get( 3    , 0)    )

  for nr=1,5 do
  for nc=1,5 do
    m  =  matrix(nr,nc):fill(1..nr*nc)
    cm = cmatrix(nr,nc):fill(1..nr*nc):fill(\x x+x*1i)
    for i=1,nr do for j=1,nc do
      assertEquals( m :get(i,j), (i-1)*nc + j )
      assertEquals( cm:get(i,j), complex((i-1)*nc+j,(i-1)*nc+j) )
    end end
  end end
end

function TestMatrix:testSeti0() -- add extra test, used in fill()
  local msg, m, cm = {
    "0-index out of bounds"             ,
    "attempt to compare nil with number",
    }
  assertErrorMsgContains( msg[1], mth, 'seti0', matrix(2), nan  , 1 )
  assertErrorMsgContains( msg[1], mth, 'seti0', matrix(2),-1    , 1 )
  assertErrorMsgContains( msg[1], mth, 'seti0', matrix(2),-eps  , 1 )
  assertErrorMsgContains( msg[1], mth, 'seti0', matrix(2), 4    , 1 )
  assertErrorMsgContains( msg[2], mth, 'seti0', matrix(2), nil  , 1 )

  for nr=1,5 do
  for nc=1,5 do
    m  =  matrix(nr,nc)
    cm = cmatrix(nr,nc)
    for i=1,nr*nc do
      m :seti0((i-1), i)
      cm:seti0((i-1), complex(i,i))
      assertEquals( m :geti0(i-1), i            )
      assertEquals( cm:geti0(i-1), complex(i,i) )
    end
  end end
end

function TestMatrix:testSeti()
  local msg, m, cm = {
    "1-index out of bounds"             ,
    "attempt to compare nil with number",
    }
  assertErrorMsgContains( msg[1], mth, 'seti', matrix(2), nan  , 1 )
  assertErrorMsgContains( msg[1], mth, 'seti', matrix(2), 0    , 1 )
  assertErrorMsgContains( msg[1], mth, 'seti', matrix(2), 1-eps, 1 )
  assertErrorMsgContains( msg[1], mth, 'seti', matrix(2), 5    , 1 )
  assertErrorMsgContains( msg[2], mth, 'seti', matrix(2), nil  , 1 )

  for nr=1,5 do
  for nc=1,5 do
    m  =  matrix(nr,nc)
    cm = cmatrix(nr,nc)
    for i=1,nr*nc do
      m :seti((i), i)
      cm:seti((i), complex(i,i))
      assertEquals( m :geti0(i-1), i            )
      assertEquals( cm:geti0(i-1), complex(i,i) )
    end
  end end
end

function TestMatrix:testSet0()
  local msg, m, cm, mRef, cmRef = {
    "0-index out of bounds"             ,
    "attempt to compare nil with number",
    }
  assertErrorMsgContains( msg[1], mth, 'set0', matrix(2), nan  , 1    , 1 )
  assertErrorMsgContains( msg[1], mth, 'set0', matrix(2),-1    , 0    , 1 )
  assertErrorMsgContains( msg[1], mth, 'set0', matrix(2),-1+eps, 0    , 1 )
  assertErrorMsgContains( msg[1], mth, 'set0', matrix(2), 0    ,-1+eps, 1 )
  assertErrorMsgContains( msg[1], mth, 'set0', matrix(2), 2    , 1    , 1 )
  assertErrorMsgContains( msg[1], mth, 'set0', matrix(2), 1    , 2    , 1 )
  assertErrorMsgContains( msg[2], mth, 'set0', matrix(2), nil  , 1    , 1 )
  assertErrorMsgContains( msg[2], mth, 'set0', matrix(2), 1    , nil  , 1 )

  for nr=1,5 do
  for nc=1,5 do
    m  =  matrix(nr,nc)
    cm = cmatrix(nr,nc)
    mRef  =  matrix(nr,nc):fill(1..nr*nc)
    cmRef = cmatrix(nr,nc):fill(1..nr*nc):fill(\x x+x*1i)
    for i=1,nr do for j=1,nc do
      m :set0(i-1,j-1, (i-1)*nc+j )
      cm:set0(i-1,j-1, complex((i-1)*nc+j,(i-1)*nc+j))
      assertEquals( m :get0(i-1,j-1), mRef :get0(i-1,j-1) )
      assertEquals( cm:get0(i-1,j-1), cmRef:get0(i-1,j-1) )
    end end
  end end
end

function TestMatrix:testSet()
  local msg, m, cm, mRef, cmRef = {
    "1-index out of bounds"             ,
    "attempt to compare nil with number",
    }
  assertErrorMsgContains( msg[1], mth, 'set', matrix(2), nan  , 1    , 1 )
  assertErrorMsgContains( msg[1], mth, 'set', matrix(2), 0    , 1    , 1 )
  assertErrorMsgContains( msg[1], mth, 'set', matrix(2), 1    , 0    , 1 )
  assertErrorMsgContains( msg[1], mth, 'set', matrix(2), 1-eps, 1    , 1 )
  assertErrorMsgContains( msg[1], mth, 'set', matrix(2), 1    , 1-eps, 1 )
  assertErrorMsgContains( msg[2], mth, 'set', matrix(2), nil  , 1    , 1 )

  for nr=1,5 do
  for nc=1,5 do
    m     =  matrix(nr,nc)
    cm    = cmatrix(nr,nc)
    mRef  =  matrix(nr,nc):fill(1..nr*nc)
    cmRef = cmatrix(nr,nc):fill(1..nr*nc):fill(\x x+x*1i)
    for i=1,nr do for j=1,nc do
      m :set(i, j, (i-1)*nc+j)
      cm:set(i, j, complex((i-1)*nc+j,(i-1)*nc+j))
      assertEquals( m :get0(i-1,j-1), mRef :get0(i-1,j-1) )
      assertEquals( cm:get0(i-1,j-1), cmRef:get0(i-1,j-1) )
    end end
  end end
end

function TestMatrix:testLinspace() --TODO
  local nrng = {
          { 1 , 10, 100}, { 1, 10, 100}   , { 10, 1 , 10}, { 1,-10, 10},
          { 10,-1 , 100}, {-1, 10, 100}   , {-10, 1 , 10}, {-1,-10, 10},
          {-10,-1 , 100},
          }
  local msg, l, nr = {
    "invalid argument #1 (finite scalar expected)"  ,
    "invalid argument #2 (finite scalar expected)"  ,
    "invalid argument #3 (positive number expected)",
    "bad argument #1 to 'ceil'"                     ,
    "matrix too large"                              ,
  }
  assertErrorMsgContains( msg[1], linspace, nil       )
  assertErrorMsgContains( msg[1], linspace, nil, 2    )
  assertErrorMsgContains( msg[1], linspace, '' , 2    )
  assertErrorMsgContains( msg[1], linspace, nan, 2    )
  assertErrorMsgContains( msg[1], linspace, inf, 2    )
  assertErrorMsgContains( msg[1], linspace,-inf, 2    )
  assertErrorMsgContains( msg[2], linspace, 2  , ''   )
  assertErrorMsgContains( msg[2], linspace, 2  , 1..2 )
  assertErrorMsgContains( msg[2], linspace, 2  , nan  )
  assertErrorMsgContains( msg[2], linspace, 2  , inf  )
  assertErrorMsgContains( msg[2], linspace, 2  ,-inf  )
  assertErrorMsgContains( msg[2], linspace, 2  , 1..2 )
  assertErrorMsgContains( msg[3], linspace, 2  , 2  , 0    )
  assertErrorMsgContains( msg[3], linspace, 2  , 2  ,-1    )
  assertErrorMsgContains( msg[3], linspace, 2  , 2  , nan  )
  assertErrorMsgContains( msg[5], linspace, 2  , 2  , inf  )
  assertErrorMsgContains( msg[3], linspace, 2  , 2  ,-inf  )
  assertErrorMsgContains( msg[4], linspace, 2  , 2  , ''   )
  assertErrorMsgContains( msg[4], linspace, 2  , 2  , 1..2 )

  assertTrue  (  is_vector (linspace(1,1))          )
  assertTrue  (  is_cvector(linspace(complex(1,1))) )
  assertEquals(  linspace( 1 )           [1]  , 0   )
  assertEquals(  linspace( 1 )           [100], 1   )
  assertEquals(  linspace( 0 )           [100], 0   )
  assertEquals(  linspace( 0.1 )         [100], 0.1 )
  assertEquals(  linspace( 2, 2, nil)    [1]  , 2   )
  assertEquals(  linspace( 2, 2, nil)    [100], 2   )
  assertEquals( #linspace( 2, 2, nil)         , 100 )
  assertEquals(  linspace( complex(1,1) )[100], complex(1,1) )
  assertEquals(  linspace( complex(1,1) )[1]  , complex(0,0) )

  nr = nrange  ( 0.5, 1 , 1000 )
  l  = linspace( 0.5, 1 , 1000 )
  assertEquals ( l[1]   , nr[1]    )
  assertEquals ( l[1000], nr[1000] )

  for _,v in ipairs(nrng) do
    nr = nrange  ( v[1], v[2], v[3] )
    l  = linspace( v[1], v[2], v[3] )
    for i=1,#nr do
      assertEquals( l[i] - nr[i], 0 )
    end
    nr = nrange  ( v[1], v[2], v[3] )
    l  = linspace( complex(v[1],v[1]), complex(v[2],v[2]), v[3] )
    for i=1,#nr do
      assertAlmostEquals( l[i].re - complex(nr[i],nr[i]).re , 0, eps )
      assertAlmostEquals( l[i].im - complex(nr[i],nr[i]).im , 0, eps )
    end
  end
  for _,v in ipairs(values.num) do
    if v >= 1  and v < 10^8 then
      nr = nrange  ( 1, 10, v)
      l  = linspace( 1, 10, v)
      for i=1,#nr do
        assertEquals( l[i] - nr[i], 0 )
      end
    end
  end
end

function TestMatrix:testLogspace()
  local nlrng =  { { 10^5, 1, 100 }, { 1, 10^5, 100 }, { 1, 10^-5, 100 }, }
  local msg, l, nr = {
    "invalid argument #1 (positive finite number expected)",
    "invalid argument #2 (positive finite number expected)",
    "invalid argument #3 (positive number expected)"       ,
    "bad argument #1 to 'ceil'"                            ,
    }
  assertErrorMsgContains( msg[1], logspace, 0          )
  assertErrorMsgContains( msg[1], logspace, nil        )
  assertErrorMsgContains( msg[1], logspace, nil , 1    )
  assertErrorMsgContains( msg[1], logspace, ''  , 1    )
  assertErrorMsgContains( msg[1], logspace, 1..2, 2    )
  assertErrorMsgContains( msg[1], logspace, nan , 2    )
  assertErrorMsgContains( msg[1], logspace, inf , 2    )
  assertErrorMsgContains( msg[1], logspace,-inf , 2    )
  assertErrorMsgContains( msg[2], logspace, 1   , ''   )
  assertErrorMsgContains( msg[2], logspace, 2   , 1..2 )
  assertErrorMsgContains( msg[2], logspace, 2   , nan  )
  assertErrorMsgContains( msg[2], logspace, 2   , inf  )
  assertErrorMsgContains( msg[2], logspace, 2   ,-inf  )
  assertErrorMsgContains( msg[3], logspace, 2   , 2  ,-1    )
  assertErrorMsgContains( msg[3], logspace, 2   , 2  , 0    )
  assertErrorMsgContains( msg[3], logspace, 2   , 2  , nan  )
  assertErrorMsgContains( msg[3], logspace, 2   , 2  ,-inf  )
  assertErrorMsgContains( msg[4], logspace, 2   , 2  , ''   )
  assertErrorMsgContains( msg[4], logspace, 2   , 2  , 1..2 )

  assertTrue  (  is_vector (logspace(1,1))          )
  assertTrue  (  is_cvector(logspace(complex(1,1))) )
  assertEquals(  logspace( 1 )           [1]  , 1   )
  assertEquals(  logspace( 1 )           [100], 1   )
  assertEquals(  logspace( 2, 2, nil)    [1]  , 2   )
  assertEquals(  logspace( 2, 2, nil)    [100], 2   )
  assertEquals( #logspace( 2, 2, nil)         , 100 )
  assertAlmostEquals(  logspace( 0.1 )         [100] - 0.1, 0, eps )
  assertAlmostEquals(  logspace( complex(1,1) )[100].re - complex(1,1).re, 0, eps )
  assertAlmostEquals(  logspace( complex(1,1) )[100].im - complex(1,1).im, 0, eps )

  for _,v in ipairs(nlrng) do
    nr = nlogrange  ( v[1], v[2], v[3] )
    l  = logspace( v[1], v[2], v[3] )
    for i=1,#nr do
      assertEquals( l[i] - nr[i], 0 )
    end
  end
  for _,v in ipairs(values.num) do
    if v >= 1  and v < 10^8 then
      nr = nlogrange  ( 1, 10, v)
      l  = logspace( 1, 10, v)
      for i=1,#nr do
        assertEquals( l[i] - nr[i], 0 )
      end
    end
  end
end

function TestMatrix:testSame()
  local m, cm =  matrix(3,3):random(), cmatrix(3,3):random()
  local msg, s = {
    "invalid argument #1 or #2 (nrow[,ncol] >=1 or table [of tables] expected)",
    "invalid argument #1 (non-empty table expected",
    }
  assertErrorMsgContains( msg[1], mth, 'same', matrix(2), 1   , ''   )
  assertErrorMsgContains( msg[1], mth, 'same', matrix(2), 1   , 1..2 )
  assertErrorMsgContains( msg[1], mth, 'same', matrix(2), 1   , nan  )
  assertErrorMsgContains( msg[2], mth, 'same', matrix(2), 1   , {}   )
  s = m:same( nan)  assertEquals( s:get(1,1), 0 )
  s = m:same( inf)  assertEquals( s:get(1,1), 0 )
  s = m:same( 0  )  assertEquals( s:get(1,1), 0 )

  for nr=1,5 do
  for nc=1,5 do
    m  =  matrix(nr,nc)
    -- no input
    s =  m:same( ) assertTrue ( is_matrix(s) ) assertFalse( is_cmatrix(s) ) assertEquals( {s.nr,s.nc}, {m.nr, m.nc} )
    for i = 1,nr do for j = 1,nc do  assertEquals( s:get(i,j), 0 ) end end
    -- one arg: e_
    s =  m:same(complex(1,1))
    assertFalse( is_matrix(s) ) assertTrue ( is_cmatrix(s) ) assertEquals( {s.nr,s.nc}, {m.nr,m.nc} )

    -- two arg: nr, nc
    s =  m:same(2,2) assertTrue ( is_matrix(s) ) assertFalse( is_cmatrix(s) ) assertEquals( {s.nr,s.nc}, {2,2} )
    s =  m:same(4,4) assertTrue ( is_matrix(s) ) assertFalse( is_cmatrix(s) ) assertEquals( {s.nr,s.nc}, {4,4} )
    for i = 1,4 do for j = 1,4 do  assertEquals( s:get(i,j), 0 ) end end

    -- three arg: e_, nr, nc
    s = m:same(complex(1,1), 2, 2)
    assertFalse( is_matrix(s) ) assertTrue ( is_cmatrix(s) ) assertEquals( {s.nr,s.nc}, {2,2} )
    s = m:same(complex(1,1), 5, 5)
    assertFalse( is_matrix(s) ) assertTrue ( is_cmatrix(s) ) assertEquals( {s.nr,s.nc}, {5,5} )
  end end
end
--[[
function TestCMatrix:testSame()
    cm = cmatrix(nr,nc)
    s = cm:same( ) assertFalse( is_matrix(s) ) assertTrue ( is_cmatrix(s) ) assertEquals( {s.nr,s.nc}, {m.nr, m.nc} )
    s = cm:same(1)
    assertTrue ( is_matrix(s) ) assertFalse( is_cmatrix(s) ) assertEquals( {s.nr,s.nc}, {m.nr,m.nc} )
    for i = 1,nr do for j = 1,nc do  assertEquals( s:get(i,j), 0 ) end end

    s = cm:same(2,2) assertFalse( is_matrix(s) ) assertTrue ( is_cmatrix(s) ) assertEquals( {s.nr,s.nc}, {2,2} )
    s = cm:same(4,4) assertFalse( is_matrix(s) ) assertTrue ( is_cmatrix(s) ) assertEquals( {s.nr,s.nc}, {4,4} )

    s = cm:same(1, 2, 2)
    assertTrue ( is_matrix(s) ) assertFalse( is_cmatrix(s) ) assertEquals( {s.nr,s.nc}, {2,2} )
    s = cm:same(1, 5, 5)
    assertTrue ( is_matrix(s) ) assertFalse( is_cmatrix(s) ) assertEquals( {s.nr,s.nc}, {5,5} )
  for i = 1,5 do for j = 1,5 do  assertEquals( s:get(i,j), 0 ) end end
end
]]

-- size, same -----------------------------------------------------------------o

function TestMatrix:testNrow()
  local m, cm , v, cv
  for nr=1,10 do
    v  =  vector(nr)       assertEquals(  v:nrow(), nr )
    cv = cvector(nr)       assertEquals( cv:nrow(), nr )
    for nc=1,10 do
      m  =  matrix(nr,nc)  assertEquals(  m:nrow(), nr )
      cm = cmatrix(nr,nc)  assertEquals( cm:nrow(), nr )
    end
  end
end

function TestMatrix:testNcol()
local m, cm , v, cv
  for nr=1,10 do
    v  =  vector(nr)       assertEquals(  v:ncol(), 1  )
    cv = cvector(nr)       assertEquals( cv:ncol(), 1  )
    for nc=1,10 do
      m  =  matrix(nr,nc)  assertEquals(  m:ncol(), nc )
      cm = cmatrix(nr,nc)  assertEquals( cm:ncol(), nc )
    end
  end
end

function TestMatrix:testSize()
  local m, cm , v, cv
  for nr=1,10 do
    v  =  vector(nr)       assertEquals(  v:size(), nr*1  )
    cv = cvector(nr)       assertEquals( cv:size(), nr*1  )
    for nc=1,10 do
      m  =  matrix(nr,nc)  assertEquals(  m:size(), nr*nc )
      cm = cmatrix(nr,nc)  assertEquals( cm:size(), nr*nc )
    end
  end
end

function TestMatrix:testSizes()
  local m, cm , v, cv
  for nr=1,10 do
    v  =  vector(nr)       assertEquals( { v:sizes()}, {nr,1 } )
    cv = cvector(nr)       assertEquals( {cv:sizes()}, {nr,1 } )
    for nc=1,10 do
      m  =  matrix(nr,nc)  assertEquals( { m:sizes()}, {nr,nc} )
      cm = cmatrix(nr,nc)  assertEquals( {cm:sizes()}, {nr,nc} )
    end
  end
end

function TestMatrix:testTsizes()
  local m, cm , v, cv
  for nr=1,10 do
    v  =  vector(nr)       assertEquals( { v:tsizes()}, {1 ,nr} )
    cv = cvector(nr)       assertEquals( {cv:tsizes()}, {1 ,nr} )
    for nc=1,10 do
      m  =  matrix(nr,nc)  assertEquals( { m:tsizes()}, {nc,nr} )
      cm = cmatrix(nr,nc)  assertEquals( {cm:tsizes()}, {nc,nr} )
    end
  end
end

function TestMatrix:testRandom()
  local m, cm = matrix(2,2)
  local msg = {
    "invalid argument #2 (callable expected)",
    }
  assertErrorMsgContains( msg[1], mth,'random', m, 1            )
  assertErrorMsgContains( msg[1], mth,'random', m, complex(1,1) )
  assertErrorMsgContains( msg[1], mth,'random', m, 1..2         )
  assertErrorMsgContains( msg[1], mth,'random', m, {}           )

  randomseed(2^52)  --randomseed(os.clock()*2^52)
  local oldVal , val = {},{}
  for nr=1,5 do
  for nc=1,5 do
    m  =  matrix(nr,nc):random()
    for i = 1,m:size() do
      val[i] = m:geti(i)
      assertTrue ( val[i] <  1    )
      assertTrue ( val[i] >= 0    )
      assertFalse( val[i] == oldVal[i] )
      oldVal[i] =  val[i]
    end
    cm = cmatrix(nr,nc):random()

    for i = 1,cm:size() do
      val[i] = cm:geti(i)
      assertTrue ( val[i].re <  1 )
      assertTrue ( val[i].re >= 0 )
      assertTrue ( val[i].im <  1 )
      assertTrue ( val[i].im >= 0 )
    end
  end end
end

function TestMatrix:testFill()
  local t, m, cm = {}
  local msg = {
    "invalid argument #2 (scalar, callable or indexable expected)",
    "container of insufficient size"                              ,
    }
  assertErrorMsgContains( msg[1], mth,'fill', matrix(2), nil  )
  assertErrorMsgContains( msg[1], mth,'fill', matrix(2), true )
  assertErrorMsgContains( msg[2], mth,'fill', matrix(2), {}   )
  for nr=1,5 do
  for nc=1,5 do
    m  =  matrix(nr,nc)
    cm = cmatrix(nr,nc)
    --scalar
    m:fill(nan)             for i=1,m :size() do assertNaN   ( m :geti(i)      ) end
    m:fill(inf)             for i=1,m :size() do assertInf   ( m :geti(i)      ) end
    m:fill(1  )             for i=1,m :size() do assertEquals( m :geti(i), 1   ) end
    m:fill(complex(1,1))    for i=1,m :size() do assertEquals( m :geti(i), 1   ) end
    --generator
    m :fill(1..#m)          for i=1,m :size() do assertEquals( m :geti(i), i   ) end
    m :fill(\x x^2)         for i=1,m :size() do assertEquals( m :geti(i), i^2 ) end
    --2D container
    m :fill( matrix(nr,nc)) for i=1,m :size() do assertEquals( m :geti(i), 0   ) end
    m :fill(cmatrix(nr,nc)) for i=1,m :size() do assertEquals( m :geti(i), 0   ) end
    --1D container
    for i=1,nr*nc do t[i]=i end
    m :fill(t)              for i=1,m :size() do assertEquals( m :geti(i), i   ) end
    m :fill(vector(nr*nc))  for i=1,m :size() do assertEquals( m :geti(i), 0   ) end
    --cmatrix: scalar
    cm:fill(1)              for i=1,cm:size() do assertEquals( cm:geti(i), complex(1,0) ) end
    cm:fill(complex(1,1))   for i=1,cm:size() do assertEquals( cm:geti(i), complex(1,1) ) end
    --generator
    cm:fill(1..nr*nc)       for i=1,cm:size() do assertEquals( cm:geti(i), complex(i)   ) end
    cm:fill(\x x+x*1i)      for i=1,cm:size() do assertEquals( cm:geti(i), complex(i,i) ) end
    cm:fill(\x x^2)         for i=1,cm:size() do assertEquals( cm:geti(i), (i+i*1i)^2   ) end
    --2D container
    cm:fill( matrix(nr,nc)) for i=1,cm:size() do assertEquals( cm:geti(i), complex(0,0) ) end
    cm:fill(cmatrix(nr,nc)) for i=1,cm:size() do assertEquals( cm:geti(i), complex(0,0) ) end
    --1D container
    for i=1,nr*nc do t[i]=i end
    cm:fill(t)              for i=1,cm:size() do assertEquals( cm:geti(i), complex(i,0) ) end
    cm:fill(t)              for i=1,cm:size() do assertEquals( cm:geti(i), complex(i,0) ) end
    cm:fill(vector(nr*nc))  for i=1,cm:size() do assertEquals( cm:geti(i), complex(0,0) ) end
  end end
--check of types change
  assertTrue( is_cmatrix(cmatrix(5,5):fill(matrix(5,5)) ) )
  assertTrue( is_matrix ( matrix(5,5):fill(complex(1,1))) )
  m , t =  matrix(5), {}
  for i=1,5 do t[i] = {} for j=1,5 do t[i][j]=(i-1)*5+j end end
  m :fill(t)             for i=1,m :size() do assertEquals( m :geti(i), i      ) end
  cm, t = cmatrix(5), {}
  for i=1,5 do t[i] = {} for j=1,5 do t[i][j]=(i-1)*5+j+((i-1)*5+j)*1i end end
  cm :fill(t)            for i=1,cm:size() do assertEquals( cm:geti(i), i+i*1i ) end
end

function TestMatrix:testCopy()
  local msg, m, mcopy = {
    "invalid argument #1 (matrix with compatible type and size expected",
  }
  assertErrorMsgContains( msg[1], mth,'copy', matrix(2),  1         )
  assertErrorMsgContains( msg[1], mth,'copy', matrix(2),  matrix(1) )
  assertErrorMsgContains( msg[1], mth,'copy', matrix(2), cmatrix(2) )

  for nr=1,5 do
  for nc=1,5 do
    m     = matrix(nr,nc):fill(1..nr*nc)
    mcopy = matrix(nr,nc)
    mcopy:copy(m)
    for i=1,m :size() do assertEquals( m:geti(i), mcopy:geti(i) ) end
  end end
  m     = matrix(5):fill(1..25)
  mcopy = matrix(4)
  mcopy:copy(m)
  for i=1,mcopy:size() do assertEquals( m:geti(i), mcopy:geti(i) ) end
  m:fill(1)
  assertEquals( mcopy, matrix(4):fill(1..16) )
  assertEquals( m    , matrix(5):fill(1)     )
end

function TestCMatrix:testCopy()
  local msg, cm, cmcopy = {
    "invalid argument #1 (matrix with compatible type and size expected",
  }
  assertErrorMsgContains( msg[1], mth,'copy', cmatrix(2),  1         )
  assertErrorMsgContains( msg[1], mth,'copy', cmatrix(2), cmatrix(1) )
  assertErrorMsgContains( msg[1], mth,'copy', cmatrix(2),  matrix(2) )

  for nr=1,5 do
  for nc=1,5 do
    cm     = cmatrix(nr,nc):fill(1..nr*nc):fill(\x x+x*1i)
    cmcopy = cmatrix(nr,nc)
    cmcopy:copy(cm)
    for i=1,cm :size() do assertEquals( cm:geti(i), cmcopy:geti(i) ) end
  end end
  cm     = cmatrix(5):fill(1..25)
  cmcopy = cmatrix(4)
  cmcopy:copy(cm)
  for i=1,cmcopy:size() do assertEquals( cm:geti(i), cmcopy:geti(i) ) end
end

function TestMatrix:testZeros()
  local m
  for nr=1,5 do
  for nc=1,5 do
    m = matrix(nr,nc):fill(1..nr*nc)
    m:zeros()
    for i=1,m :size() do assertEquals( m:geti(i), 0 ) end
  end end
end

function TestCMatrix:testZeros()
  local cm
  for nr=1,5 do
  for nc=1,5 do
    cm = cmatrix(nr,nc):fill(1..nr*nc):fill(\x x+x*1i)
    cm:zeros()
    for i=1,cm :size() do assertEquals( cm:geti(i), complex(0,0) ) end
  end end
end

function TestMatrix:testOnes()
  local m, cm
  for nr=1,5 do
  for nc=1,5 do
    m  =  matrix(nr,nc):fill(1..nr*nc)
    cm = cmatrix(nr,nc):fill(1..nr*nc):fill(\x x+x*1i)
    m :ones()
    cm:ones()
    for i=1,m :size() do assertEquals( m :geti(i), 1 ) end
    for i=1,cm:size() do assertEquals( cm:geti(i), complex(1,0) ) end
  end end
end

function TestMatrix:testEye()
  local m, cm
  for nr=1,5 do
  for nc=1,5 do
    m  =  matrix(nr,nc):fill(1..nr*nc)
    cm = cmatrix(nr,nc):fill(1..nr*nc):fill(\x x+x*1i)
    m :eye()
    cm:eye()
    s = { m:sizes() }
    for i=1,s[1] do
    for j=1,s[2] do
      if i==j then assertEquals( m :get(i,j), 1 )
      else         assertEquals( m :get(i,j), 0 ) end
    end end

    s = { cm:sizes() }
    for i=1,s[1] do
    for j=1,s[2] do
      if i==j then assertEquals( cm:get(i,j), complex(1,0) )
      else         assertEquals( cm:get(i,j), complex(0,0) ) end
    end end
  end end
end

function TestMatrix:testSymp() --TODO
  local msg = {
    "invalid argument #1 (2n matrix expected)",
  }
  assertErrorMsgContains( msg[1], mth,'symp',  vector(2)   )
  assertErrorMsgContains( msg[1], mth,'symp',  matrix(3)   )
  assertErrorMsgContains( msg[1], mth,'symp', cmatrix(3)   )
  assertErrorMsgContains( msg[1], mth,'symp',  matrix(4,3) )
  assertErrorMsgContains( msg[1], mth,'symp', cmatrix(4,3) )

  --print("\n", matrix(8):symp())
end

function TestMatrix:testCirc() --TODO
  local v
  local msg = {
    "invalid argument #2 (iterable expected)",
  }
  assertErrorMsgContains( msg[1], mth,'circ', matrix(2), nil  )
  assertErrorMsgContains( msg[1], mth,'circ', matrix(2), 1    )
  assertErrorMsgContains( msg[1], mth,'circ', matrix(2), \x x )

  local v = vector(2):fill(1)
  --print( matrix(4):circ( v ) )
end

function TestMatrix:testReshape()
  local msg, m, cm, s = {
    "invalid matrix new sizes",
    }
  assertErrorMsgContains( msg[1], mth,'reshape', matrix(2), 3, 3  )
  assertErrorMsgContains( msg[1], mth,'reshape', matrix(2), 1, 5  )
  assertErrorMsgContains( msg[1], mth,'reshape', matrix(2), 0, 2  )

  for nr=1,5  do
  for nc=1,5  do
  for i =1,nr do
  for j =1,nc do
    m  =  matrix(nr,nc):fill(1..nr*nc)
    cm = cmatrix(nr,nc):fill(1..nr*nc):fill(\x x+x*1i)
    cm:reshape(i,j)
    m :reshape(i,j)

    assertEquals( {m :sizes()}, {i,j} )
    assertEquals( {cm:sizes()}, {i,j} )
  end end
  end end
end

-- getx, setx -----------------------------------------------------------------o

function TestMatrix:testGetsub() --TODO: cleanup
  local mRes, mRef, r, ir, jc, x, m
  local msg = {
    "invalid argument #2 (iterable expected)"   ,
    "invalid argument #3 (iterable expected)"   ,
    "invalid argument #4 (iterable expected)"   ,
    "invalid range member '1'"                  ,
    "cannot convert 'nil' to 'double'"          ,
    }
  assertErrorMsgContains( msg[1], mth, 'getsub', matrix(2), nil          )
  assertErrorMsgContains( msg[1], mth, 'getsub', matrix(2), ''           )
  assertErrorMsgContains( msg[1], mth, 'getsub', matrix(2), \x x         )
  assertErrorMsgContains( msg[1], mth, 'getsub', matrix(2), complex(1,1) )
  assertErrorMsgContains( msg[2], mth, 'getsub', matrix(2), 1   , nil    )
  assertErrorMsgContains( msg[2], mth, 'getsub', matrix(2), 1   , ''     )
  assertErrorMsgContains( msg[2], mth, 'getsub', matrix(2), 1   , \x x   )
  assertErrorMsgContains( msg[5], mth, 'getsub', matrix(2), 0   , 0      )
  assertErrorMsgContains( msg[5], mth, 'getsub', matrix(2), 3   , 1      )
  assertErrorMsgContains( msg[5], mth, 'getsub', matrix(2), 1   , 3      )
  assertErrorMsgContains( msg[5], mth, 'getsub', matrix(2), 0   , 1      )
  assertErrorMsgContains( msg[5], mth, 'getsub', matrix(2), 1   , 0      )
  assertErrorMsgContains( msg[3], mth, 'getsub', matrix(2), 0   , 0   , 1    )
  assertErrorMsgContains( msg[3], mth, 'getsub', matrix(2), 1   , 1   , \x x )
  assertErrorMsgContains( msg[4], mth, 'getsub', matrix(2), 1   , 1   , 1..4 )

  m = matrix(5,5):fill(1..(5*5))
  assertTrue( is_table (m:getsub(1, 1, {} )) )
  assertTrue( is_vector(m:getsub(1, 1, nil)) )

  local newt = \x        => if is_table(x)   then return {}           else return x end end
  local cpx  = \m,x      => if is_cmatrix(m) then return complex(x,x) else return x end end
  local mat  = \m,x      => if is_matrix(m)  then return matrix(x)    else return cmatrix(x) end end
  local ref  = \m,i,j,nc => return cpx(m, (i-1)*nc+j) end

  local tab  = \x,m,...  =>
    local arg = {...}
    if     is_table(x) then return arg
    elseif #arg <= 2   then return mat(m,arg)
    else                    return mat(m,{{arg[1], arg[2]}, {arg[3], arg[4]}})
    end
  end

  r = { nil, {} }
  for ri =1,#r do
  for nr=1,5  do
  for nc=1,5  do
    x  = {  matrix(nr,nc):fill(1..nr*nc),
           cmatrix(nr,nc):fill(1..nr*nc):fill(\x x+x*1i)}
    for xi =1,#x do
      for i = 1,nr do
      for j = 1,nc do
        assertEquals( x[xi]:getsub( i, j):size(), 1 )
        assertEquals( x[xi]:getsub( i, j, newt(r[ri])), tab(r[ri], x[xi], ref(x[xi],i,j,nc)) )

        ir = {{1,i}, vector({1,i})}
        jc = {{1,j}, vector({1,j})}
        for d=1,#ir do
          mRef = tab(r[ri], x[xi], ref(x[xi],1,1,nc), ref(x[xi],1,j,nc), ref(x[xi],i,1,nc), ref(x[xi],i,j,nc))
          assertEquals( x[xi]:getsub(ir[d], jc[d], r[ri]), mRef )
        end

        for a = 1,i do
        for b = 1,j do
          m = x[xi]:getsub( a..i, b..j)
          assertEquals( m:size(), (i-a+1)*(j-b+1) )
          if (i-a)+1 > 1 and (j-b)+1 > 1 then
            mRes = tab( r[ri], x[xi], m:get(1,1)       , m:get(1,2)         , m:get(2,1)         , m:get(2,2)            )
            mRef = tab( r[ri], x[xi], ref(x[xi],a,b,nc), ref(x[xi],a,b+1,nc), ref(x[xi],a+1,b,nc), ref(x[xi],a+1,b+1,nc) )
            assertEquals( mRes, mRef )
            mRes = tab( r[ri], x[xi], m:get( i-a, j-b)     , m:get( i-a, j-b+1) , m:get( i-a+1, j-b) , m:get( i-a+1,j-b+1) )
            mRef = tab( r[ri], x[xi], ref(x[xi],i-1,j-1,nc), ref(x[xi],i-1,j,nc), ref(x[xi],i,j-1,nc), ref(x[xi],i,j,nc)   )
            assertEquals( mRes, mRef )
          elseif (i-a)+1 >  1 and (j-b)+1 == 1 then -- vectors
            mRes = tab( r[ri], x[xi], m:get(1,1)       , m:get(2,1)          )
            mRef = tab( r[ri], x[xi], ref(x[xi],a,b,nc), ref(x[xi],a+1,b,nc) )
            assertEquals( mRes, mRef )
            mRes = tab( r[ri], x[xi], m:get( i-a  ,j-b+1), m:get( i-a+1,j-b+1) )
            mRef = tab( r[ri], x[xi], ref(x[xi],i-1,j,nc), ref(x[xi],i,j,nc)   )
            assertEquals( mRes, mRef )
          elseif (i-a)+1 == 1 and (j-b)+1 >  1 then -- rows
            mRes = tab( r[ri], x[xi], m:get(1,1)       , m:get(1,2)          )
            mRef = tab( r[ri], x[xi], ref(x[xi],a,b,nc), ref(x[xi],a,b+1,nc) )
            assertEquals( mRes, mRef )
            mRes = tab( r[ri], x[xi], m:get( i-a+1, j-b) , m:get( i-a+1,j-b+1) )
            mRef = tab( r[ri], x[xi], ref(x[xi],i,j-1,nc), ref(x[xi],i,j,nc)   )
            assertEquals( mRes, mRef )
          end
        end end
      end end
    end
  end end end
  m  =  matrix(5,5):fill(1..(5*5))
  cm = cmatrix(5,5):fill(1..(5*5))
  assertTrue ( is_matrix (m :setsub(1,2, cmatrix(1) )))
  assertFalse( is_cmatrix(m :setsub(1,2, cmatrix(1) )))
  assertFalse( is_matrix (cm:setsub(1,2,  matrix(1) )))
  assertTrue ( is_cmatrix(cm:setsub(1,2,  matrix(1) )))
end

function TestMatrix:testSetsub() --TODO after getsub cleanup
  local msg, m, cm = {
    "invalid argument #2 (iterable expected)"          ,
    "invalid argument #3 (iterable expected)"          ,
    "invalid argument #4 (scalar or iterable expected)",
    "1-index out of bounds"                            ,
  }
  assertErrorMsgContains( msg[1], mth, 'setsub', matrix(2), nil , 1  , 1  )
  assertErrorMsgContains( msg[1], mth, 'setsub', matrix(2), ''  , 1  , 1  )
  assertErrorMsgContains( msg[1], mth, 'setsub', matrix(2), NaN , 1  , 1  )
  assertErrorMsgContains( msg[1], mth, 'setsub', matrix(2), \x x, 1  , 1  )
  assertErrorMsgContains( msg[2], mth, 'setsub', matrix(2), 1             )
  assertErrorMsgContains( msg[2], mth, 'setsub', matrix(2), 1   , nil, 1  )
  assertErrorMsgContains( msg[2], mth, 'setsub', matrix(2), 1   , '' , 1  )
  assertErrorMsgContains( msg[2], mth, 'setsub', matrix(2), 1   , NaN, 1  )
  assertErrorMsgContains( msg[3], mth, 'setsub', matrix(2), 1   , 1 , nil )
  assertErrorMsgContains( msg[3], mth, 'setsub', matrix(2), 1   , 1 , ''  )
  assertErrorMsgContains( msg[3], mth, 'setsub', matrix(2), 1   , 1 , NaN )
  assertErrorMsgContains( msg[4], mth, 'setsub', matrix(2), 0   , 1 , 1   )
  assertErrorMsgContains( msg[4], mth, 'setsub', matrix(2), 1   , 0 , 1   )
  assertErrorMsgContains( msg[1], mth, 'setsub', matrix(2), complex(1,1), 1 , 1 )
  assertErrorMsgContains( msg[2], mth, 'setsub', matrix(2), 1 , complex(1,1), 1 )

  --accordingly to the fixed version of getsub + possible inputs
  for nr=1,5  do
  for nc=1,5  do
    cm = cmatrix(nr,nc):fill(1..nr*nc):fill(\x x+x*1i)
    m  =  matrix(nr,nc):fill(1..nr*nc)
    for i = 1,nr do
    for j = 1,nc do
      --print( m:setsub())

    end end
  end end
end

function TestMatrix:testGetv()
  local t, m, cm = {}
  local msg = {
    "invalid argument #2 (iterable expected)"   ,
    "invalid argument #3 (iterable expected)"   ,
    "cannot convert 'nil' to 'double"           ,
    "invalid range member '1'"                  ,
  }
  assertErrorMsgContains( msg[1], mth, 'getv', matrix(2), nil )
  assertErrorMsgContains( msg[1], mth, 'getv', matrix(2), ''  )
  assertErrorMsgContains( msg[1], mth, 'getv', matrix(2), NaN )
  assertErrorMsgContains( msg[2], mth, 'getv', matrix(2), 1  , ''   )
  assertErrorMsgContains( msg[2], mth, 'getv', matrix(2), 1  , 1    )
  assertErrorMsgContains( msg[2], mth, 'getv', matrix(2), 1  , \x x )
  assertErrorMsgContains( msg[3], mth, 'getv', matrix(2), 0         )
  assertErrorMsgContains( msg[3], mth, 'getv', matrix(2), matrix(2) )
  assertErrorMsgContains( msg[4], mth, 'getv', matrix(2), 1  , 1..2 )
  assertEquals( matrix(2):fill(1..4):getv(1,NaN), matrix({1}) )

  for nr=1,5  do
  for nc=1,5  do
    m  =  matrix(nr,nc):fill(1..nr*nc)
    cm = cmatrix(nr,nc):fill(1..nr*nc)
    for i = 1,nr*nc do
      assertEquals( m :getv( i   )            ,  vector({i})           )
      assertEquals( m :getv( 1..i)            ,  vector(i):fill(1..i)  )
      assertEquals( m :getv({1,i})            ,  vector({1,i})         )
      assertEquals( cm:getv( i   )            ,  cvector({i})          )
      assertEquals( cm:getv( 1..i)            ,  cvector(i):fill(1..i) )
      assertEquals( cm:getv({1,i})            ,  cvector({1,i})        )
      assertEquals( m :getv( i    ,{})        ,  {i}                   )
      assertEquals( m :getv({1,i} ,{})        ,  {1,i}                 )
      assertEquals( m :getv( 1..i ,{})        ,  totable(1..i)         )
      assertEquals( cm:getv( i   , {})        ,  {complex(i,0)}        )
      assertEquals( cm:getv({1,i}, {})        ,  {complex(1,0),complex(i,0)} )
      assertEquals( m :getv( i   ,  matrix(2)),  matrix{{i,0},{0,0}} )
      assertEquals( m :getv({1,i},  matrix(2)),  matrix{{1,i},{0,0}} )
      assertEquals( cm:getv( i   , cmatrix(2)), cmatrix{{i,0},{0,0}} )        --can be also matrix in assertEq, check further
      assertEquals( cm:getv({1,i}, cmatrix(2)), cmatrix{{1,i},{0,0}} )
      t={} for j=1,i do t[j] = complex(j,0) end
      assertEquals( cm:getv( 1..i, {}), t )
      end
  end end
  assertTrue( is_cmatrix(m :getv( 5   , cmatrix(1))) )
  assertTrue( is_cmatrix(m :getv( 5   , cmatrix(1))) )
  assertTrue( is_cmatrix(m :getv({1,5}, cmatrix(2))) )
  assertTrue( is_matrix (cm:getv( 5   ,  matrix(2))) )
  assertTrue( is_matrix (cm:getv({1,5},  matrix(2))) )

  m = matrix(4):fill(1..16)
  m:getv(1..5,'in')
  assertEquals( m, matrix(4):fill(1..16) ) -- same output, info in documentation
end

function TestMatrix:testSetv()
  local t, m, cm = {}
  local msg = {
    "invalid argument #2 (iterable expected)"          ,
    "invalid argument #3 (scalar or iterable expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'setv', matrix(2), nil , 0    )
  assertErrorMsgContains( msg[1], mth, 'setv', matrix(2), ''  , 0    )
  assertErrorMsgContains( msg[1], mth, 'setv', matrix(2), NaN , 0    )
  assertErrorMsgContains( msg[1], mth, 'setv', matrix(2), \x x, 0    )
  assertErrorMsgContains( msg[2], mth, 'setv', matrix(2), 1   , ''   )
  assertErrorMsgContains( msg[2], mth, 'setv', matrix(2), 1   , nil  )
  assertErrorMsgContains( msg[2], mth, 'setv', matrix(2), 1   , NaN  )
  assertErrorMsgContains( msg[2], mth, 'setv', matrix(2), 1   , \x x )

  for nr=1,5 do
  for nc=1,5 do
    for i = 1,nr*nc do
      for d=1,i do t[d]=d end
      m = matrix(nr,nc):setv( i   , i    ) assertEquals( m :getv( i   ),  vector({i})          )
      m = matrix(nr,nc):setv( 1..i, i    ) assertEquals( m :getv( 1..i),  vector(i):fill(i)    )
      m = matrix(nr,nc):setv({1,i}, i    ) assertEquals( m :getv({1,i}),  vector({i,i})        )
      m = matrix(nr,nc):setv( 1..i, 1..i ) assertEquals( m :getv( 1..i),  vector(i):fill(1..i) )
      m = matrix(nr,nc):setv( i   , {i}  ) assertEquals( m :getv( i   ),  vector({i})          )
      m = matrix(nr,nc):setv({1,i}, {1,i}) assertEquals( m :getv({1,i}),  vector({1,i})        )
      m = matrix(nr,nc):setv( 1..i, t    ) assertEquals( m :getv( 1..i),  vector(i):fill(1..i) )
      cm=cmatrix(nr,nc):setv( i   , i    ) assertEquals( cm:getv( i   ), cvector({i})          )
      cm=cmatrix(nr,nc):setv( 1..i, i    ) assertEquals( cm:getv( 1..i), cvector(i):fill(i)    )
      cm=cmatrix(nr,nc):setv({1,i}, i    ) assertEquals( cm:getv({1,i}), cvector({i,i})        )
      cm=cmatrix(nr,nc):setv( 1..i, 1..i ) assertEquals( cm:getv( 1..i), cvector(i):fill(1..i) )
      cm=cmatrix(nr,nc):setv( i   , {i}  ) assertEquals( cm:getv( i   ), cvector({i})          )
      cm=cmatrix(nr,nc):setv({1,i}, {1,i}) assertEquals( cm:getv({1,i}), cvector({1,i})        )
      cm=cmatrix(nr,nc):setv( 1..i, t    ) assertEquals( cm:getv( 1..i), cvector(i):fill(1..i) )
    end
  end end
  m = matrix(5,5):setv({1,3}, 1..2              ) assertEquals( m :getv({1,3}),  vector({1,2}) )
  m = matrix(5,5):setv({1,3}, vector(3):fill(1) ) assertEquals( m :getv({1,3}),  vector({1,1}) )
  m = matrix(5,5):setv( 1   , complex(1,1)      ) assertEquals( m :getv( 1   ),  vector({1}  ) )
  cm=cmatrix(5,5):setv({1,3}, 1..2              ) assertEquals( cm:getv({1,3}), cvector({1,2}) )
  cm=cmatrix(5,5):setv({1,3}, cvector(3):fill(1)) assertEquals( cm:getv({1,3}), cvector({1,1}) )
  cm=cmatrix(5,5):setv( 1   , complex(1,1)      ) assertEquals( cm:getv( 1   ), cvector({complex(1,1)}) )
end

function TestMatrix:testGetdiag()
  local msg, m, cm, diag, cdiag, n = {
    "invalid argument #2 (iterable expected)",
    "invalid range member '1'"               ,
  }
  assertErrorMsgContains( msg[1], mth, 'getdiag', matrix(2), ''   )
  assertErrorMsgContains( msg[1], mth, 'getdiag', matrix(2), \x x )
  assertErrorMsgContains( msg[1], mth, 'getdiag', matrix(2), 1    )
  assertErrorMsgContains( msg[2], mth, 'getdiag', matrix(2), 1..2 )
  assertTrue( is_cmatrix( matrix(2):getdiag(cmatrix(2))) )
  assertTrue( is_matrix (cmatrix(2):getdiag( matrix(2))) )
  assertEquals( matrix(2):fill(1..4):getdiag(NaN), matrix(2):fill(1..4):getdiag() )

  for nr=1,5  do
  for nc=1,5  do
    m  =  matrix(nr,nc):fill(1..nr*nc)
    cm = cmatrix(nr,nc):fill(1..nr*nc):fill(\x x+x*1i)
    n  = min(nr,nc)
    diag, cdiag = {}, {}
    for i = 1,n do  diag[i] = (1+(i-1)*nc+i-1) end
    for i = 1,n do cdiag[i] = complex(1+(i-1)*nc+i-1, 1+(i-1)*nc+i-1) end

    assertEquals( m :getdiag()            ,  vector( diag) )
    assertEquals( m :getdiag({})          ,  diag          )
    assertEquals( m :getdiag(cmatrix(n,1)), cvector( diag) )
    assertEquals( cm:getdiag()            , cvector(cdiag) )
    assertEquals( cm:getdiag({})          ,  cdiag         )
    assertEquals( cm:getdiag(matrix(n,1)) ,  vector(cdiag) )
  end end
end

function TestMatrix:testSetdiag()
  local diag, cdiag, ref, cref, m, cm
  local msg = {
    "invalid argument #2 (scalar or iterable expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'setdiag', matrix(2), nil  )
  assertErrorMsgContains( msg[1], mth, 'setdiag', matrix(2), ''   )
  assertErrorMsgContains( msg[1], mth, 'setdiag', matrix(2), \x x )
  assertTrue ( is_cmatrix(cmatrix(2,2):setdiag( matrix(2)  )) )
  assertTrue ( is_matrix ( matrix(2,2):setdiag(cmatrix(2)  )) )
  assertFalse( is_cmatrix( matrix(2,2):setdiag(complex(1,1))) )
  m = matrix(2):setdiag(matrix(1):fill(1))
  assertEquals( m :getdiag(), vector({1,0}))

  for nr=1,5  do
  for nc=1,5  do
    m  =  matrix(nr,nc):fill(1..nr*nc)
    cm = cmatrix(nr,nc):fill(1..nr*nc):fill(\x x+x*1i)
    n  = min(nr,nc)
    diag, cdiag, ref, cref = {}, {}, {}, {}
    for i = 1,n do  diag[i] = (1+(i-1)*nc+i-1) end
    for i = 1,n do cdiag[i] = complex(1+(i-1)*nc+i-1, 1+(i-1)*nc+i-1) end
    for i = 1,n do if i<=3 then ref[i]  = i
                   else         ref[i]  = diag[i]  end end
    for i = 1,n do if i<=3 then cref[i] = i
                   else         cref[i] = cdiag[i] end end
    m :setdiag(1)            assertEquals( m :getdiag(), vector(n):fill(1)     )
    m :setdiag(1..n)         assertEquals( m :getdiag(), vector(n):fill(1..n)  )
    m :setdiag(diag)         assertEquals( m :getdiag(), vector(diag)          )
    m :setdiag({1,2,3})      assertEquals( m :getdiag(), vector(ref)           )
    m :setdiag(complex(0,1)) assertEquals( m :getdiag(), vector(n)             )
    cm:setdiag(1)            assertEquals( cm:getdiag(), cvector(n):fill(1)    )
    cm:setdiag(1..n)         assertEquals( cm:getdiag(), cvector(n):fill(1..n) )
    cm:setdiag(cdiag)        assertEquals( cm:getdiag(), cvector(cdiag)        )
    cm:setdiag({1,2,3})      assertEquals( cm:getdiag(), cvector(cref)         )
    cm:setdiag(complex(1,1)) assertEquals( cm:getdiag(), cvector(n):fill(1):fill(\x x+x*1i) )
  end end
end

function TestMatrix:testGetrow()
  local msg, m, r = {
    "invalid argument #2 (iterable expected)",
    "invalid argument #3 (iterable expected)",
    "cannot convert 'nil' to 'double'"       ,
    "invalid range member '1'"               ,
    "1-index out of bounds"                  ,
    }
  assertErrorMsgContains( msg[1], mth, 'getrow', matrix(2), ''         )
  assertErrorMsgContains( msg[1], mth, 'getrow', matrix(2), nil        )
  assertErrorMsgContains( msg[1], mth, 'getrow', matrix(2), NaN        )
  assertErrorMsgContains( msg[1], mth, 'getrow', matrix(2), \x x       )
  assertErrorMsgContains( msg[2], mth, 'getrow', matrix(2), 1   , ''   )
  assertErrorMsgContains( msg[2], mth, 'getrow', matrix(2), 1   , 1    )
  assertErrorMsgContains( msg[3], mth, 'getrow', matrix(2), 0          )
  assertErrorMsgContains( msg[3], mth, 'getrow', matrix(2), 5          )
  assertErrorMsgContains( msg[4], mth, 'getrow', matrix(2), 1   , 1..2 )
  assertErrorMsgContains( msg[5], mth, 'getrow', matrix(2), 1   , vector(1) )

  assertTrue  ( is_matrix (cmatrix(2):getrow(1, matrix(2))) )
  assertTrue  ( is_cmatrix( matrix(2):getrow(1,cmatrix(2))) )
  assertEquals( matrix(2,2):getrow(1, NaN      ), cmatrix(1,2) )
  assertEquals( matrix(2,2):fill(1..4):getrow(1, vector(2)), vector{1,2}   )
  assertEquals( matrix(2,2):fill(1..4):getrow(1, vector(3)), vector{1,2,0} )
  r = { nil, {} }
  for nr=1,5 do
  for nc=1,5 do
    for ri=1,#r do
    m = { matrix(nr,nc):fill(1..nr*nc),
         cmatrix(nr,nc):fill(1..nr*nc):fill(\x x+x*1i) }
      for mi=1,#m do
      for i =1,nr do
          ir = { i, {1,i}, 1..i }
          for j=1,#ir do
            assertEquals( m[mi]:getrow(ir[j],r[ri]), m[mi]:getsub(ir[j],1..nc,r[ri]) )
          end
      end end
    end
  end end
end

function TestMatrix:testSetrow()
  local m, cm, m1, cm1
  local msg = {
    "invalid argument #2 (iterable expected)"          ,
    "invalid argument #3 (scalar or iterable expected)",
    "1-index out of bounds"                            ,
    "cannot convert 'nil' to 'double'"                 ,
  }
  assertErrorMsgContains( msg[1], mth, 'setrow', matrix(2), ''        )
  assertErrorMsgContains( msg[1], mth, 'setrow', matrix(2), nil       )
  assertErrorMsgContains( msg[1], mth, 'setrow', matrix(2), NaN       )
  assertErrorMsgContains( msg[1], mth, 'setrow', matrix(2), \x x      )
  assertErrorMsgContains( msg[2], mth, 'setrow', matrix(2), 1   , nil )
  assertErrorMsgContains( msg[2], mth, 'setrow', matrix(2), 1   , ''  )
  assertErrorMsgContains( msg[3], mth, 'setrow', matrix(2), 0   , 1   )
  assertErrorMsgContains( msg[3], mth, 'setrow', matrix(2), 3   , 1   )
  assertErrorMsgContains( msg[4], mth, 'setrow', matrix(2), 1   , matrix(1) )
  assertErrorMsgContains( msg[4], mth, 'setrow', matrix(3), 1   , 1..2      )
  assertErrorMsgContains( msg[4], mth, 'setrow', matrix(3), 1   , {1,2}     )
  for nr=1,5 do
  for nc=1,5 do
    m   =  matrix(nr,nc):fill(1..nr*nc)
    cm  = cmatrix(nr,nc):fill(1..nr*nc):fill(\x x+x*1i)
    m1  =  matrix(nr,nc)  m1 :copy( m)
    cm1 = cmatrix(nr,nc)  cm1:copy(cm)
    for i=1,nr do
      m :setrow(i    , 1           )  m1 :setsub(i    ,1..nc, 1           ) assertEquals( m , m1  )
      m :setrow(i    , complex(1,1))  m1 :setsub(i    ,1..nc, complex(1,1)) assertEquals( m , m1  )
      m :setrow(1..i , 1           )  m1 :setsub(1..i ,1..nc, 1           ) assertEquals( m , m1  )
      m :setrow({1,i}, 1           )  m1 :setsub({1,i},1..nc, 1           ) assertEquals( m , m1  )
      m :setrow(i    , 1..5        )  m1 :setsub(i    ,1..nc, 1..5        ) assertEquals( m , m1  )
      m :setrow(1..i , 1..m:size() )  m1 :setsub(1..i ,1..nc, 1..m:size() ) assertEquals( m , m1  )
      m :setrow({1,i}, 1..10       )  m1 :setsub({1,i},1..nc, 1..10       ) assertEquals( m , m1  )
      m :setrow(i    , {1,2,3,4,5} )  m1 :setsub(i    ,1..nc, {1,2,3,4,5} ) assertEquals( m , m1  )

      cm:setrow(i    , 1           )  cm1:setsub(i    ,1..nc, 1           ) assertEquals( cm, cm1 )
      cm:setrow(1..i , 1           )  cm1:setsub(1..i ,1..nc, 1           ) assertEquals( cm, cm1 )
      cm:setrow({1,i}, 1           )  cm1:setsub({1,i},1..nc, 1           ) assertEquals( cm, cm1 )
      cm:setrow(i    , 1..5        )  cm1:setsub(i    ,1..nc, 1..5        ) assertEquals( cm, cm1 )
      cm:setrow(1..i , 1..m:size() )  cm1:setsub(1..i ,1..nc, 1..m:size() ) assertEquals( cm, cm1 )
      cm:setrow({1,i}, 1..10       )  cm1:setsub({1,i},1..nc, 1..10       ) assertEquals( cm, cm1 )
      cm:setrow(i    , {1,2,3,4,5} )  cm1:setsub(i    ,1..nc, {1,2,3,4,5} ) assertEquals( cm, cm1 )
    end
  end end
  assertFalse( is_cmatrix( matrix(5,5) :setrow(1, complex(1,1))) )
  assertFalse( is_matrix ( cmatrix(5,5):setrow(1, 1 )          ) )

  m  =  matrix(5,5):fill(1..25)
  m1 =  matrix(5,5) m1 :copy( m)
  m :setrow({1,5}      , {1,2,3,4,5,1,2,3,4,5} )
  m1:setsub({1,5}, 1..5, {1,2,3,4,5,1,2,3,4,5} )
  assertEquals( m, m1 )
  m :setrow(1..2       , {1,2,3,4,5,1,2,3,4,5} )
  m1:setsub(1..2 , 1..5, {1,2,3,4,5,1,2,3,4,5} )
  assertEquals( m, m1 )
end

function TestMatrix:testGetcol()
  local m, r
  local msg = {
    "invalid argument #2 (iterable expected)",
    "invalid argument #3 (iterable expected)",
    "cannot convert 'nil' to 'double'"       ,
    "invalid range member '1'"               ,
    "1-index out of bounds"                  ,
  }
  assertErrorMsgContains( msg[1], mth, 'getcol', matrix(2), ''   )
  assertErrorMsgContains( msg[1], mth, 'getcol', matrix(2), nil  )
  assertErrorMsgContains( msg[1], mth, 'getcol', matrix(2), NaN  )
  assertErrorMsgContains( msg[1], mth, 'getcol', matrix(2), \x x )
  assertErrorMsgContains( msg[2], mth, 'getcol', matrix(2), 1   , ''   )
  assertErrorMsgContains( msg[2], mth, 'getcol', matrix(2), 1   , 1    )
  assertErrorMsgContains( msg[3], mth, 'getcol', matrix(2), 0          )
  assertErrorMsgContains( msg[3], mth, 'getcol', matrix(2), 3          )
  assertErrorMsgContains( msg[4], mth, 'getcol', matrix(2), 1   , 1..2 )
  assertErrorMsgContains( msg[5], mth, 'getcol', matrix(2), 1   , vector(1) )
  r = { nil, {} }
  for nr=1,5 do
  for nc=1,5 do
    for ri=1,#r do
    m = { matrix(nr,nc):fill(1..nr*nc),
         cmatrix(nr,nc):fill(1..nr*nc):fill(\x x+x*1i) }
      for mi=1,#m do
      for i =1,nc do
          ir = { i, {1,i}, 1..i }
          for j=1,#ir do
            assertEquals( m[mi]:getcol(ir[j],r[ri]) , m[mi]:getsub(1..nr,ir[j],r[ri]) )
          end
      end end
    end
  end end
end

function TestMatrix:testSetcol()
  local m, cm, m1, cm1
  local msg = {
    "invalid argument #2 (iterable expected)"          ,
    "invalid argument #3 (scalar or iterable expected)",
    "1-index out of bounds"                            ,
    "cannot convert 'nil' to 'double'"                 ,
  }
  assertErrorMsgContains( msg[1], mth, 'setcol', matrix(2), ''         )
  assertErrorMsgContains( msg[1], mth, 'setcol', matrix(2), nil        )
  assertErrorMsgContains( msg[1], mth, 'setcol', matrix(2), NaN        )
  assertErrorMsgContains( msg[1], mth, 'setcol', matrix(2), \x x       )
  assertErrorMsgContains( msg[2], mth, 'setcol', matrix(2), 1   ,  ''  )
  assertErrorMsgContains( msg[2], mth, 'setcol', matrix(2), 1   ,  nil )
  assertErrorMsgContains( msg[3], mth, 'setcol', matrix(2), 0   ,  1   )
  assertErrorMsgContains( msg[3], mth, 'setcol', matrix(2), 3   ,  1   )
  assertErrorMsgContains( msg[4], mth, 'setcol', matrix(2), 1   ,  matrix(1) )
  assertErrorMsgContains( msg[4], mth, 'setcol', matrix(3), 1   ,  1..2      )
  assertErrorMsgContains( msg[4], mth, 'setcol', matrix(3), 1   ,  {1,2}     )

  for nr=1,5 do
  for nc=1,5 do
    m   =  matrix(nr,nc):fill(1..nr*nc)
    cm  = cmatrix(nr,nc):fill(1..nr*nc):fill(\x x+x*1i)
    m1  =  matrix(nr,nc)
    cm1 = cmatrix(nr,nc)
    for i=1,nc do
      m1 :copy( m)
      cm1:copy(cm)
      m :setcol(i    , 1           )   m1 :setsub(1..nr,i    , 1           ) assertEquals( m , m1  )
      m :setcol(i    , complex(1,1))   m1 :setsub(1..nr,i    , complex(1,1)) assertEquals( m , m1  )
      m :setcol(1..i , 1           )   m1 :setsub(1..nr,1..i , 1           ) assertEquals( m , m1  )
      m :setcol({1,i}, 1           )   m1 :setsub(1..nr,{1,i}, 1           ) assertEquals( m , m1  )
      m :setcol(i    , 1..5        )   m1 :setsub(1..nr,i    , 1..5        ) assertEquals( m , m1  )
      cm:setcol(i    , 1           )   cm1:setsub(1..nr,i    , 1           ) assertEquals( cm, cm1 )
      cm:setcol(1..i , 1           )   cm1:setsub(1..nr,1..i , 1           ) assertEquals( cm, cm1 )
      cm:setcol({1,i}, 1           )   cm1:setsub(1..nr,{1,i}, 1           ) assertEquals( cm, cm1 )
      cm:setcol(i    , 1..5        )   cm1:setsub(1..nr,i    , 1..5        ) assertEquals( cm, cm1 )

      m1:copy( m)   for k=1,i  do for j=1,nr do m1:seti(k+(j-1)*nc,(k-1)*nr+j) end end
      m :setcol(1..i , 1..m:size() )   assertEquals( m , m1  )
      m1:copy( m)   for j=1,nr do m1:seti(i+(j-1)*nc, j) end
      m :setcol(i    , {1,2,3,4,5} )   assertEquals( m , m1  )

      cm1:copy( cm) for k=1,i  do for j=1,nr do cm1:seti(k+(j-1)*nc,(k-1)*nr+j+0*1i) end end
      cm:setcol(1..i , 1..m:size() )   assertEquals( cm, cm1 )

      cm1:copy( cm) for j=1,nr do cm1:seti(i+(j-1)*nc, j) end
      cm:setcol(i    , {1,2,3,4,5} )   assertEquals( cm, cm1 )

      m = matrix(nr,nc):fill(1..nr*nc) m1:copy( m)
      for it,k in ipairs({1,i}) do for j=1,nr do m1:seti(k+(j-1)*nc, (it-1)*nr+j) end end
      m :setcol({1,i}, 1..10       )   assertEquals( m , m1  )

      cm  = cmatrix(nr,nc):fill(1..nr*nc):fill(\x x+x*1i)
      cm1:copy( cm)
      for it,k in ipairs({1,i}) do for j=1,nr do cm1:seti(k+(j-1)*nc, (it-1)*nr+j) end end
      cm:setcol({1,i}, 1..10       )   assertEquals( cm, cm1 )
    end
  end end
end

-- foreach, filter, map, fold, scan -------------------------------------------o
--[[
function TestMatrix:testForeach()
  local m, cm, m1, cm1, f, t
  local msg = {
    "invalid argument #2 (callable expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'foreach', matrix(2), nil       )
  assertErrorMsgContains( msg[1], mth, 'foreach', matrix(2), ''        )
  assertErrorMsgContains( msg[1], mth, 'foreach', matrix(2), 1         )
  assertErrorMsgContains( msg[1], mth, 'foreach', matrix(2), 1..2      )
  assertErrorMsgContains( msg[1], mth, 'foreach', matrix(2), matrix(1) )
  assertErrorMsgContains( msg[1], mth, 'foreach', matrix(2), { }       )

  f = \x,i,j => t[i][j]=x  end
  for nr=1,5 do
  for nc=1,5 do
    m  =  matrix(nr,nc):fill(1..nr*nc)
    cm = cmatrix(nr,nc):fill(1..nr*nc):fill(\x x+x*1i)
    t  = table.new(nr,nc)
    for i=0,nr-1 do local c = t[i+1] or table.new(nc,0) t[i+1] = c end
    m  :foreach(f)
    for i=1,#t   do for j=1,#t[i] do assertEquals( t[i][j], (i-1)*nc+j ) end end
    cm:foreach(f)
    for i=1,#t   do for j=1,#t[i] do assertEquals( t[i][j], (i-1)*nc+j+((i-1)*nc+j)*1i ) end end
   end end
end
]]

function TestMatrix:testMapat()
  local tref, m, cm, mref, cmref
  local msg = {
    "invalid argument #2 (callable expected)",
    "invalid argument #3 (iterable expected)",
    "invalid argument #4 (iterable expected)",
    "invalid range member '1'"               ,
    "attempt to perform arithmetic on local 'x' (a nil value)",
  }
  assertErrorMsgContains( msg[1], mth, 'mapat', matrix(2), nil       )
  assertErrorMsgContains( msg[1], mth, 'mapat', matrix(2), ''        )
  assertErrorMsgContains( msg[1], mth, 'mapat', matrix(2), 1..2      )
  assertErrorMsgContains( msg[1], mth, 'mapat', matrix(2), 1         )
  assertErrorMsgContains( msg[1], mth, 'mapat', matrix(2), matrix(1) )
  assertErrorMsgContains( msg[1], mth, 'mapat', matrix(2), { }       )
  assertErrorMsgContains( msg[2], mth, 'mapat', matrix(2), \x x+1  , ''   )
  assertErrorMsgContains( msg[2], mth, 'mapat', matrix(2), \x x+1  , nil  )
  assertErrorMsgContains( msg[2], mth, 'mapat', matrix(2), \x x+1  , NaN  )
  assertErrorMsgContains( msg[2], mth, 'mapat', matrix(2), \x x+1  , \x x )
  assertErrorMsgContains( msg[3], mth, 'mapat', matrix(2), \x x+1  , 1    , ''   )
  assertErrorMsgContains( msg[3], mth, 'mapat', matrix(2), \x x+1  , 1    , \x x )
  assertErrorMsgContains( msg[4], mth, 'mapat', matrix(2), \x x+1  , 1    , 1..2 )
  assertErrorMsgContains( msg[5], mth, 'mapat', matrix(2), \x x+1  , 0    )
  assertErrorMsgContains( msg[5], mth, 'mapat', matrix(2), \x x+1  , 5    )

  for nr=1,5 do
  for nc=1,5 do
    m    = matrix(nr,nc):fill(1..nr*nc)
    assertEquals( m:mapat(\x x, 1       , matrix{1,2}), matrix{1,2} )
    assertEquals( m:mapat(\x x, 1       , matrix{4,5}), matrix{1,5} )
    assertEquals( m:mapat(\x x+1, 1     , {2}), {2} )
    tref = {} for i=1,#m do tref[i]=i+1 end
    assertEquals( m:mapat(\x x+1, 1..#m , {}), tref )
    if nr*nc>1 then
    assertEquals( m:mapat(\x x+1, {1, 2}, {}), {2,3} )
    end
    mref = matrix(nr,nc) mref:seti(1,2)
    assertEquals( m:mapat(\x x+1, 1         ), mref )
    mref = matrix(nr,nc):fill(2..nr*nc+1)
    assertEquals( m:mapat(\x x+1, 1..#m     ), mref )
    mref = matrix(nr,nc) mref:seti(1,2)  mref:seti(#m,#m+1)
    assertEquals( m:mapat(\x x+1, {1, nr*nc}), mref )

    mref = matrix(nr,nc):fill(1..nr*nc)  mref:seti(1,2) mref:seti(#m,#m+1)
    m    = matrix(nr,nc):fill(1..nr*nc)  m:mapat(\x x+1, {1, #m}, 'in' )
    if #m>1 then assertEquals( m, mref ) end
    mref = matrix(nr,nc):fill(1..nr*nc)  mref:seti(1,2)
    m    = matrix(nr,nc):fill(1..nr*nc)  m:mapat(\x x+1,  1     , 'in' )
    assertEquals( m, mref )
    mref = matrix(nr,nc):fill(2..nr*nc+1)
    m    = matrix(nr,nc):fill(1..nr*nc)  m:mapat(\x x+1,  1..#m , 'in' )
    assertEquals( m , mref )
  end end
end

function TestMatrix:testMap()
  local m, cm, mref, cmref, tref, ctref
  local msg = {
    "invalid argument #2 (callable expected)"                 ,
    "invalid argument #3 (iterable expected)"                 ,
    "invalid range member '1'"                                ,
    "attempt to perform arithmetic on local 'x' (a nil value)",
  }
  assertErrorMsgContains( msg[1], mth, 'map', matrix(2), ''           )
  assertErrorMsgContains( msg[1], mth, 'map', matrix(2), 1..2         )
  assertErrorMsgContains( msg[1], mth, 'map', matrix(2), 1            )
  assertErrorMsgContains( msg[1], mth, 'map', matrix(2), matrix(1)    )
  assertErrorMsgContains( msg[1], mth, 'map', matrix(2), { }          )
  assertErrorMsgContains( msg[2], mth, 'map', matrix(2), \x x+1, ''   )
  assertErrorMsgContains( msg[2], mth, 'map', matrix(2), \x x+1, 1    )
  assertErrorMsgContains( msg[3], mth, 'map', matrix(2), \x x+1, 1..2 )
  assertEquals( matrix(2):map(\x x+1, matrix(2)), matrix(2):fill(1) )
  assertEquals( matrix(2):map(\x x+1, NaN      ), matrix(2):fill(1) )

  for nr=1,5 do
  for nc=1,5 do
    m    = matrix(nr,nc):fill(1..nr*nc)
    mref = matrix(nr,nc):fill(2..nr*nc+1)
    tref = {} for i=1,#m do tref[i]=i+1 end

    m1   = m:map( \x x+1 )
    assertEquals( m1, mref )
    assertEquals( m , matrix(nr,nc):fill(1..nr*nc) )
    m1   = m:map( \x x+1, {} )
    assertEquals( m1, tref )
    assertEquals( m , matrix(nr,nc):fill(1..nr*nc) )
    m1   = m:map( \x x+1, "in" )
    assertEquals( m1, mref )
    assertEquals( m , mref )

    cm    = cmatrix(nr,nc):fill(1..nr*nc)  :fill(\x x+x*1i)
    cmref = cmatrix(nr,nc):fill(2..nr*nc+1):fill(\x x+x*1i)
    ctref = {} for i=1,#cm do ctref[i]=complex(i+1,i+1) end
    cm1   = cm:map( \x x+1+1i )
    assertEquals( cm1, cmref )
    assertEquals( cm , cmatrix(nr,nc):fill(1..nr*nc):fill(\x x+x*1i) )
    cm1   = cm:map( \x x+1+1i, {} )
    assertEquals( cm1, ctref )
    assertEquals( cm , cmatrix(nr,nc):fill(1..nr*nc):fill(\x x+x*1i) )
    cm1   = cm:map( \x x+1+1i, "in" )
    assertEquals( cm1, cmref )
    assertEquals( cm , cmref )
  end end
  m = matrix(5,5):fill(1..25)
  m:map( \x x+1+1i, "in" )
  assertFalse( is_cmatrix(m) )
end

function TestMatrix:testMap2()
  local m1, m2, m, tref, cm1, cm2, cm, ctref
  local msg = {
    "invalid argument #2 (scalar or iterable expected)"       ,
    "invalid argument #3 (callable expected)"                 ,
    "invalid argument #4 (iterable expected)"                 ,
    "invalid range member '1'"                                ,
    "attempt to perform arithmetic on local 'y' (a nil value)",
  }
  assertErrorMsgContains( msg[1], mth, 'map2', matrix(2), nil  )
  assertErrorMsgContains( msg[1], mth, 'map2', matrix(2), ''   )
  assertErrorMsgContains( msg[1], mth, 'map2', matrix(2), NaN  )
  assertErrorMsgContains( msg[1], mth, 'map2', matrix(2), \x x )
  assertErrorMsgContains( msg[2], mth, 'map2', matrix(2), matrix(1), nil  )
  assertErrorMsgContains( msg[2], mth, 'map2', matrix(2), matrix(1), 1..2 )
  assertErrorMsgContains( msg[2], mth, 'map2', matrix(2), matrix(1), 1    )
  assertErrorMsgContains( msg[3], mth, 'map2', matrix(2), matrix(1), \x x, 1    )
  assertErrorMsgContains( msg[4], mth, 'map2', matrix(2), matrix(1), \x x, 1..2 )
  assertErrorMsgContains( msg[5], mth, 'map2', matrix(2), matrix(1), \x,y x+y )

  for nr=1,5 do
  for nc=1,5 do
    m1 = matrix(nr,nc):fill(1..nr*nc)
    m2 = matrix(nr,nc):fill(1..nr*nc)
    tref = {} for i=1,#m1 do tref[i] = 0 end

    assertEquals( m1:map2( m2, \x,y x-y ), m2:map2( m1, \x,y x-y ) )
    m = m1:map2 ( m2, \x,y x-y )
    assertEquals( m, matrix(nr,nc) )
    m = m1:map2 ( m2, \x,y x-y, {} )
    assertEquals( m, tref )
    m = m1:map2 ( m2, \x,y x-y, "in" )
    assertEquals( m1, matrix(nr,nc) )
    assertEquals( m , m1 )

    cm1 = cmatrix(nr,nc):fill(1..nr*nc):fill(\x x+x*1i)
    cm2 = cmatrix(nr,nc):fill(1..nr*nc):fill(\x x+x*1i)
    ctref = {} for i=1,#cm1 do ctref[i] = complex(0,0) end

    assertEquals ( cm1:map2( cm2, \x,y x-y ), cm2:map2( cm1, \x,y x-y ) )
    cm = cm1:map2( cm2, \x,y x-y )
    assertEquals ( cm, matrix(nr,nc) )
    cm = cm1:map2( cm2, \x,y x-y, {} )
    assertEquals ( cm, ctref )
    cm = cm1:map2( cm2, \x,y x-y, "in" )
    assertEquals ( cm1, matrix(nr,nc) )
    assertEquals ( cm , cm1 )
  end end
  m   =  matrix(5):fill(1..25)
  cm  = cmatrix(5):fill(1..25)
  cm1 = cm:map2( m, \x,y x-y )
  assertTrue  ( is_cmatrix(cm1) )
  assertEquals( cm1, cmatrix(5) )
  cm1 = m:map2( cm, \x,y x-y )
  assertEquals( cm1, cmatrix(5) )
  assertTrue  ( is_cmatrix(cm1) )

  m1 =  matrix(5):fill(1..25)
  m2 =  matrix(4):fill(1..20)
  assertEquals( m2:map2( m1, \x,y x-y ), matrix(4) )
end

function TestMatrix:testMap3()
  local m, cm, m1, m2, m3, cm1, cm2, cm3, tref, ctref = matrix(2)
  local msg = {
    "invalid argument #2 (scalar or iterable expected)"       ,
    "invalid argument #3 (scalar or iterable expected)"       ,
    "invalid argument #4 (callable expected)"                 ,
    "invalid argument #5 (iterable expected)"                 ,
    "invalid range member '1'"                                ,
    "attempt to perform arithmetic on local 'y' (a nil value)",
    "attempt to perform arithmetic on local 'z' (a nil value)",
  }
  assertErrorMsgContains( msg[1], mth, 'map3', m, ''   )
  assertErrorMsgContains( msg[1], mth, 'map3', m, NaN  )
  assertErrorMsgContains( msg[1], mth, 'map3', m, \x x )
  assertErrorMsgContains( msg[2], mth, 'map3', m, m    , ''   )
  assertErrorMsgContains( msg[2], mth, 'map3', m, m    , NaN  )
  assertErrorMsgContains( msg[2], mth, 'map3', m, m    , \x x )
  assertErrorMsgContains( msg[3], mth, 'map3', m, m    , m    , nil  )
  assertErrorMsgContains( msg[3], mth, 'map3', m, m    , m    , 1..2 )
  assertErrorMsgContains( msg[3], mth, 'map3', m, m    , m    , 1    )
  assertErrorMsgContains( msg[4], mth, 'map3', m, m    , m    , \x x, 1    )
  assertErrorMsgContains( msg[5], mth, 'map3', m, m    , m    , \x x, 1..2 )
  assertErrorMsgContains( msg[6], mth, 'map3', m, matrix(1), m        , \x,y,z x+y+z )
  assertErrorMsgContains( msg[6], mth, 'map3', m, matrix(1), matrix(1), \x,y,z x+y+z )
  assertErrorMsgContains( msg[7], mth, 'map3', m, m        , matrix(1), \x,y,z x+y+z )

  for nr=1,5 do
  for nc=1,5 do
    m1 = matrix(nr,nc):fill(2..2*nr*nc..2)
    m2 = matrix(nr,nc):fill(1..nr*nc)
    m3 = matrix(nr,nc):fill(1..nr*nc)
    tref = {} for i=1,#m1 do tref[i] = 0 end

    m = m1:map3 ( m2, m3, \x,y,z  x-y-z )
    assertEquals( m, matrix(nr,nc) )
    m = m2:map3 ( m1, m3, \x,y,z -x+y-z )
    assertEquals( m, matrix(nr,nc) )
    m = m1:map3 ( m2, m3, \x,y,z  x-y-z, {} )
    assertEquals( m, tref )
    m = m1:map3 ( m2, m3, \x,y,z  x-y-z, 'in' )
    assertEquals( m, matrix(nr,nc) )
    assertEquals( m, m1 )

    cm1 = cmatrix(nr,nc):fill(2..2*nr*nc..2)
    cm2 = cmatrix(nr,nc):fill(1..nr*nc)
    cm3 = cmatrix(nr,nc):fill(1..nr*nc)
    ctref = {} for i=1,#cm1 do ctref[i] = complex(0,0) end

    cm = cm1:map3 ( cm2, cm3, \x,y,z  x-y-z )
    assertEquals( cm, cmatrix(nr,nc) )
    cm = cm2:map3 ( cm1, cm3, \x,y,z -x+y-z )
    assertEquals( cm, cmatrix(nr,nc) )
    cm = cm1:map3 ( cm2, cm3, \x,y,z  x-y-z, {} )
    assertEquals( cm, ctref )
    cm = cm1:map3 ( cm2, cm3, \x,y,z  x-y-z, 'in' )
    assertEquals( cm, cmatrix(nr,nc) )
    assertEquals( cm, cm1 )
  end end
  m1  =  matrix(5):fill(2..50..2)
  m2  =  matrix(5):fill(1..25)
  cm1 = cmatrix(5):fill(1..25)
  cm  = cm1:map3( m1, m2, \x,y,z -x+y-z )
  assertTrue  ( is_cmatrix(cm) )
  assertEquals( cm, cmatrix(5) )

  m1 =  matrix(5):fill(2..50..2)
  m2 =  matrix(5):fill(1..25)
  m3 =  matrix(4):fill(1..20)
  assertEquals( m3:map3( m1, m2, \x,y,z -x+y-z ), matrix(4) )
end

-- TODO: check the err , change concept(?)
function TestMatrix:testFoldl()
  local m, mref, treg, cm, cmref, ctref
  local msg = {
    "invalid argument #2 (callable expected)"                    ,
    "invalid argument #5 (iterable expected)"                    ,
    "invalid argument #4 (string 'vec', 'row' or 'col' expected)",
    "invalid range member '1'"                                   ,
  }
  m, cm = matrix(2), cmatrix(2)
  assertErrorMsgContains( msg[1], mth, 'foldl', matrix(2), nil  )
  assertErrorMsgContains( msg[1], mth, 'foldl', matrix(2), NaN  )
  assertErrorMsgContains( msg[1], mth, 'foldl', matrix(2), ''   )
  assertErrorMsgContains( msg[1], mth, 'foldl', matrix(2), {}   )
  assertErrorMsgContains( msg[1], mth, 'foldl', matrix(2), 1    )
  assertErrorMsgContains( msg[1], mth, 'foldl', matrix(2), 1..2 )
  assertErrorMsgContains( msg[1], mth, 'foldl', matrix(2), m    )
  assertErrorMsgContains( msg[1], mth, 'foldl', matrix(2), cm   )
  assertErrorMsgContains( msg[3], mth, 'foldl', matrix(2), \x x, '')
  assertErrorMsgContains( msg[3], mth, 'foldl', matrix(2), \x x, 1 , {}   , {}   )
  assertErrorMsgContains( msg[3], mth, 'foldl', matrix(2), \x x, 1 , 1..2 , {}   )
  assertErrorMsgContains( msg[3], mth, 'foldl', matrix(2), \x x, 1 , m    , {}   )
  assertErrorMsgContains( msg[3], mth, 'foldl', matrix(2), \x x, 1 , cm   , {}   )
  assertErrorMsgContains( msg[3], mth, 'foldl', matrix(2), \x x, 1 , ''   , {}   )
  assertErrorMsgContains( msg[2], mth, 'foldl', matrix(2), \x x, 1 , "vec", ''   )
  assertErrorMsgContains( msg[2], mth, 'foldl', matrix(2), \x x, 1 , "vec", 1    )
  assertErrorMsgContains( msg[2], mth, 'foldl', matrix(2), \x x, 1 , "vec", \x x )

--[[
parameters:
  f: callable, x0: initial value, d: ['vec', 'row', 'col'], r: iterable
  r:{}, cmatrix(2), matrix(2), 1..2

default:
  x0 = x[ 1] or x[., 1] or x[ 1,.] for foldl
       x[#x] or x[.,nc] or x[nr,.] for foldr
   d = 'vec'  (r_ is discarded if any)
   r = scalar ['vec'] or x:same(nr,1) ['row'] or x:same(1,nc) ['col']
]]
--new version:

  for nr=1,5 do
  for nc=1,5 do
    m = matrix(nr,nc):fill(1..nr*nc)
    --1)  fold x, f
    assertEquals( m:foldl(\x x  )       , 1                        )
    assertEquals( m:foldl(\x x+1)       , m:geti(#m)               )
    -- 2') fold x, f, d
    assertEquals( m:foldl(\x x+1, "vec"), m:foldl(\x x+1)          )
    assertEquals( m:foldl(\x x  , "col"), matrix(1,nc):fill(1..nc) )
    mref = vector(nr)  for i=1,nr do      mref:seti( i, m:geti((i-1)*nc+1)) end
    assertEquals( m:foldl(\x x  , "row"), mref        )
    -- 3') fold x, f, r
    --print( m:foldl(\x x  , 1   ))

    -- 4') fold x, f, d, r
    --m:foldl(\x x  , "col", {}  )

    -- 5)  fold x, f,  x0
    --m:foldl(\x x  , 1  )

    -- 6)  fold x, f,  x0,   d
    --m:foldl(\x x  , 1, "col"  )

    -- 7') fold x, f, x0, r
    --m:foldl(\x x  , "col", {}  )

    -- 8)  fold x, f,  x0,   d, r
    --m:foldl(\x x  , 1, "col", {}  )

  end end
--[[
  for nr=1,5 do
  for nc=1,5 do
    tref = {}          for i=1,nr do      tref[i] = (i-1)*nc+1 end
    --assertEquals( m:foldl(\x x  , {}   ), tref        )
    tref = {}          for i=1,nc do      tref[i] = i end
    --assertEquals( m:foldl(\x x  , {}   , "col"), tref )

    cm = cmatrix(nr,nc):fill(1..nr*nc)
    assertEquals( cm:foldl(\x x  )       , complex(1,0)              )
    assertEquals( cm:foldl(\x x+1)       , cm:geti(#m)               )
    assertEquals( cm:foldl(\x x+1, "vec"), cm:geti(#m)               )
    assertEquals( cm:foldl(\x x  , "col"), cmatrix(1,nc):fill(1..nc) )
    cmref = cvector(nr)  for i=1,nr do     cmref:seti( i, complex(m:geti((i-1)*nc+1)),0) end
    assertEquals( cm:foldl(\x x  , "row"), cmref         )
    ctref = {}           for i=1,nr do     ctref[i] = complex((i-1)*nc+1, 0) end
    --assertEquals( cm:foldl(\x x  , {}   ), ctref         )
    ctref = {}           for i=1,nc do     ctref[i] = complex(i,0) end
    --assertEquals( cm:foldl(\x x  , {}    , "col"), ctref )

    if nc> 1 then
      cmref = cvector(nr)  for i=1,#cmref do cmref:seti( i, complex((i-1)*nc+1, (i-1)*nc+1) ) end
      --assertEquals( m:foldl(\x complex(x,x), cmatrix(nr,1)), cmref )
    else
       -- if it's just vector function is not being done on it
      cmref = cvector(nr)  for i=1,#cmref do cmref:seti( i, complex((i-1)*nc+1, 0) ) end
      --assertEquals( m:foldl(\x complex(x,x), cmatrix(nr,1)), cmref )
    end

    assertTrue  ( is_cmatrix(m :foldl(\x x, cmatrix(nr,1)))  )
    assertTrue  ( is_matrix (cm:foldl(\x x,  matrix(nr,1)))  )
    assertEquals( {m:foldl(\x x, matrix(5)):sizes()} , {5,5} )
  end end
]]
end

function TestMatrix:testFoldr()
  local m, mref, tref
  local msg = {
    "invalid argument #2 (callable expected)"                    ,
    "invalid argument #5 (iterable expected)"                    ,
    "invalid argument #4 (string 'vec', 'row' or 'col' expected)",
    "invalid range member '1'"                                   ,
  }
  m, cm = matrix(2), cmatrix(2)
  assertErrorMsgContains( msg[1], mth, 'foldr', matrix(2), nil  )
  assertErrorMsgContains( msg[1], mth, 'foldr', matrix(2), NaN  )
  assertErrorMsgContains( msg[1], mth, 'foldr', matrix(2), ''   )
  assertErrorMsgContains( msg[1], mth, 'foldr', matrix(2), {}   )
  assertErrorMsgContains( msg[1], mth, 'foldr', matrix(2), 1    )
  assertErrorMsgContains( msg[1], mth, 'foldr', matrix(2), 1..2 )
  assertErrorMsgContains( msg[1], mth, 'foldr', matrix(2), m    )
  assertErrorMsgContains( msg[1], mth, 'foldr', matrix(2), cm   )
  assertErrorMsgContains( msg[3], mth, 'foldr', matrix(2), \x x, '')
  assertErrorMsgContains( msg[3], mth, 'foldr', matrix(2), \x x, 1 , {}   , {}   )
  assertErrorMsgContains( msg[3], mth, 'foldr', matrix(2), \x x, 1 , 1..2 , {}   )
  assertErrorMsgContains( msg[3], mth, 'foldr', matrix(2), \x x, 1 , m    , {}   )
  assertErrorMsgContains( msg[3], mth, 'foldr', matrix(2), \x x, 1 , cm   , {}   )
  assertErrorMsgContains( msg[3], mth, 'foldr', matrix(2), \x x, 1 , ''   , {}   )
  assertErrorMsgContains( msg[2], mth, 'foldr', matrix(2), \x x, 1 , "vec", ''   )
  assertErrorMsgContains( msg[2], mth, 'foldr', matrix(2), \x x, 1 , "vec", 1    )
  assertErrorMsgContains( msg[2], mth, 'foldr', matrix(2), \x x, 1 , "vec", \x x )

--[[
  for nr=1,5 do
  for nc=1,5 do
    m = matrix(nr,nc):fill(1..nr*nc)
    assertEquals( m:foldr(\x x)           , 1 )
    assertEquals( m:foldr(\x x, "vec"    ), 1 )
    assertEquals( m:foldr(\x x, "col"    ), matrix(1,nc):fill(1..nc) )
    mref = vector(nr)  for i=1,nr do        mref:seti( i, m:geti((i-1)*nc+1)) end
    assertEquals( m:foldr(\x x, "row"    ), mref )
    tref = {}          for i=1,nr do        tref[i] = (i-1)*nc+1 end
    assertEquals( m:foldr(\x x, {}       ), tref )
    tref = {}          for i=1,nc do        tref[i] = i end
    assertEquals( m:foldr(\x x, {}, "col"), tref )

    cm = cmatrix(nr,nc):fill(1..nr*nc)
    assertEquals( cm:foldr(\x x)           , complex(1,0) )
    assertEquals( cm:foldr(\x x, "vec"    ), complex(1,0) )
    assertEquals( cm:foldr(\x x, "col"    ), cmatrix(1,nc):fill(1..nc) )
    cmref = vector(nr)  for i=1,nr do        cmref:seti( i, complex(cm:geti((i-1)*nc+1,0))) end
    assertEquals( cm:foldr(\x x, "row"    ), cmref )
    ctref = {}          for i=1,nr do        ctref[i] = complex((i-1)*nc+1,0) end
    assertEquals( cm:foldr(\x x, {}       ), ctref )
    ctref = {}          for i=1,nc do        ctref[i] = complex(i,0) end
    assertEquals( cm:foldr(\x x, {}, "col"), ctref )

    assertTrue  ( is_cmatrix(m :foldr(\x x, cmatrix(nr,1)))  )
    assertTrue  ( is_matrix (cm:foldr(\x x,  matrix(nr,1)))  )
    assertEquals( {m:foldr(\x x, matrix(5)):sizes()} , {5,5} )
    assertEquals( m:foldr(\x x), m:foldl(\x x) )
  end end
  ]]
end

--TODO: adapt smarter way of testing, same as fold
function TestMatrix:testScanl()
  local m, cm, mref, cmref
  local msg = {
    "invalid argument #2 (callable expected)"                    ,
    "invalid argument #5 (iterable expected)"                    ,
    "invalid argument #4 (string 'vec', 'row' or 'col' expected)",
    "invalid range member '1'"                                   ,
  }
  m, cm = matrix(2), cmatrix(2)
  assertErrorMsgContains( msg[1], mth, 'scanl', matrix(2), nil  )
  assertErrorMsgContains( msg[1], mth, 'scanl', matrix(2), NaN  )
  assertErrorMsgContains( msg[1], mth, 'scanl', matrix(2), ''   )
  assertErrorMsgContains( msg[1], mth, 'scanl', matrix(2), {}   )
  assertErrorMsgContains( msg[1], mth, 'scanl', matrix(2), 1    )
  assertErrorMsgContains( msg[1], mth, 'scanl', matrix(2), 1..2 )
  assertErrorMsgContains( msg[1], mth, 'scanl', matrix(2), m    )
  assertErrorMsgContains( msg[1], mth, 'scanl', matrix(2), cm   )
  assertErrorMsgContains( msg[3], mth, 'scanl', matrix(2), \x x, '')
  assertErrorMsgContains( msg[3], mth, 'scanl', matrix(2), \x x, 1 , {}   , {}   )
  assertErrorMsgContains( msg[3], mth, 'scanl', matrix(2), \x x, 1 , 1..2 , {}   )
  assertErrorMsgContains( msg[3], mth, 'scanl', matrix(2), \x x, 1 , m    , {}   )
  assertErrorMsgContains( msg[3], mth, 'scanl', matrix(2), \x x, 1 , cm   , {}   )
  assertErrorMsgContains( msg[3], mth, 'scanl', matrix(2), \x x, 1 , ''   , {}   )
  assertErrorMsgContains( msg[2], mth, 'scanl', matrix(2), \x x, 1 , "vec", ''   )
  assertErrorMsgContains( msg[2], mth, 'scanl', matrix(2), \x x, 1 , "vec", 1    )
  assertErrorMsgContains( msg[2], mth, 'scanl', matrix(2), \x x, 1 , "vec", \x x )

--[[

  for nr=1,5 do
  for nc=1,5 do
    m  =  matrix(nr,nc):fill(1..nr*nc)
    assertEquals( {m:scanl(\x x , "vec"):sizes()}, {nc*nr,1 } )
    assertEquals( {m:scanl(\x x , "row"):sizes()}, {nr   ,nc} )
    assertEquals( {m:scanl(\x x , "col"):sizes()}, {nr   ,nc} )
    assertEquals(  m:scanl(\x x), vector(nr*nc):fill(1) )
    assertEquals(  m:scanl(\x x), m:scanl(\x x, "vec" ) )
    mref = vector(nr)  for i=1,nr do mref:seti( i, m:geti((i-1)*nc+1)) end
    for i=1,nc do assertEquals( m:scanl(\x x, "row"):getcol(i), mref ) end
    mref = matrix(1,nc):fill(1..nc)
    for i=1,nr do assertEquals( m:scanl(\x x, "col"):getrow(i), mref ) end
    tref = {} for i=1,nr do for j=1,nc do  tref[(i-1)*nc+j] = (i-1)*nc+1 end end
    assertEquals( m:scanl(\x x, {}) , tref )

    cm = cmatrix(nr,nc):fill(1..nr*nc)
    assertEquals( {cm:scanl(\x x , "vec"):sizes()}, {nc*nr,1 } )
    assertEquals( {cm:scanl(\x x , "row"):sizes()}, {nr   ,nc} )
    assertEquals( {cm:scanl(\x x , "col"):sizes()}, {nr   ,nc} )
    assertEquals(  cm:scanl(\x x), cvector(nr*nc):fill(1) )
    assertEquals(  cm:scanl(\x x), cm:scanl(\x x, "vec" ) )
    cmref = cvector(nr) for i=1,nr do cmref:seti( i, cm:geti((i-1)*nc+1)) end
    for i=1,nc do assertEquals( cm:scanl(\x x, "row"):getcol(i), cmref )  end
    cmref = cmatrix(1,nc):fill(1..nc)
    for i=1,nr do assertEquals( cm:scanl(\x x, "col"):getrow(i), cmref )  end
    ctref = {} for i=1,nr do for j=1,nc do  ctref[(i-1)*nc+j] = complex((i-1)*nc+1,0) end end
    assertEquals( cm:scanl(\x x, {}) , ctref )

    assertTrue( is_cmatrix(m :scanl(\x x, cmatrix(5))) )
    assertTrue( is_matrix (cm:scanl(\x x,  matrix(5))) )
  end end
  ]]
end

function TestMatrix:testScanr()
  local msg = {
    "invalid argument #2 (callable expected)"                    ,
    "invalid argument #5 (iterable expected)"                    ,
    "invalid argument #4 (string 'vec', 'row' or 'col' expected)",
    "invalid range member '1'"                                   ,
  }
  m, cm = matrix(2), cmatrix(2)
  assertErrorMsgContains( msg[1], mth, 'scanr', matrix(2), nil  )
  assertErrorMsgContains( msg[1], mth, 'scanr', matrix(2), NaN  )
  assertErrorMsgContains( msg[1], mth, 'scanr', matrix(2), ''   )
  assertErrorMsgContains( msg[1], mth, 'scanr', matrix(2), {}   )
  assertErrorMsgContains( msg[1], mth, 'scanr', matrix(2), 1    )
  assertErrorMsgContains( msg[1], mth, 'scanr', matrix(2), 1..2 )
  assertErrorMsgContains( msg[1], mth, 'scanr', matrix(2), m    )
  assertErrorMsgContains( msg[1], mth, 'scanr', matrix(2), cm   )
  assertErrorMsgContains( msg[3], mth, 'scanr', matrix(2), \x x, '')
  assertErrorMsgContains( msg[3], mth, 'scanr', matrix(2), \x x, 1 , {}   , {}   )
  assertErrorMsgContains( msg[3], mth, 'scanr', matrix(2), \x x, 1 , 1..2 , {}   )
  assertErrorMsgContains( msg[3], mth, 'scanr', matrix(2), \x x, 1 , m    , {}   )
  assertErrorMsgContains( msg[3], mth, 'scanr', matrix(2), \x x, 1 , cm   , {}   )
  assertErrorMsgContains( msg[3], mth, 'scanr', matrix(2), \x x, 1 , ''   , {}   )
  assertErrorMsgContains( msg[2], mth, 'scanr', matrix(2), \x x, 1 , "vec", ''   )
  assertErrorMsgContains( msg[2], mth, 'scanr', matrix(2), \x x, 1 , "vec", 1    )
  assertErrorMsgContains( msg[2], mth, 'scanr', matrix(2), \x x, 1 , "vec", \x x )
--[[
  for nr=1,5 do
  for nc=1,5 do
    m  =  matrix(nr,nc):fill(1..nr*nc)
    cm = cmatrix(nr,nc):fill(1..nr*nc)
    assertEquals( {m:scanr(\x x , "vec"):sizes()}, {nc*nr,1 }  )
    assertEquals( {m:scanr(\x x , "row"):sizes()}, {nr   ,nc}  )
    assertEquals( {m:scanr(\x x , "col"):sizes()}, {nr   ,nc}  )
    assertEquals(  m:scanr(\x x), vector(nr*nc):fill(1..nr*nc) )
    assertEquals(  m:scanr(\x x), m:scanr(\x x, "vec" ) )
    assertEquals(  m:scanr(\x x), m:scanl(\x x+1)       )

    assertEquals(  m:scanr(\x x , "row"), m ) -- no change -- check
    assertEquals(  m:scanr(\x x , "col"), m ) -- no change -- check

    assertTrue( is_cmatrix(m :scanr(\x x, cmatrix(5))) )
    assertTrue( is_matrix (cm:scanr(\x x,  matrix(5))) )
  end end
  ]]
end

function TestMatrix:testFilter() --TODO: undertested for now
  local f, m, cm, mref
  local msg = {
    "invalid argument #2 (callable expected)",
    "invalid argument #3 (iterable expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'filter', matrix(2), nil       )
  assertErrorMsgContains( msg[1], mth, 'filter', matrix(2), ''        )
  assertErrorMsgContains( msg[1], mth, 'filter', matrix(2), 1..2      )
  assertErrorMsgContains( msg[1], mth, 'filter', matrix(2), 1         )
  assertErrorMsgContains( msg[1], mth, 'filter', matrix(2), matrix(1) )
  assertErrorMsgContains( msg[1], mth, 'filter', matrix(2), { }       )
  assertErrorMsgContains( msg[2], mth, 'filter', matrix(2), \x x     , ''   )
  assertErrorMsgContains( msg[2], mth, 'filter', matrix(2), \x x     , 1    )
  assertErrorMsgContains( msg[2], mth, 'filter', matrix(2), \x x     , \x x )

  for nr=1,5 do
  for nc=1,5 do
    m  =  matrix(nr,nc):fill(1..nr*nc)
    cm = cmatrix(nr,nc):fill(1..nr*nc):fill(\x x+x*1i)

    f=\x x==1
    assertEquals( m:filter(f    ), vector{1} )
    assertEquals( m:filter(f, {}), {1}       )
    mref = vector(1) mref:seti(1,1)
    assertEquals( m:filter(f, vector(25)), mref )

    f=\x x==1+1i
    assertEquals( cm:filter(f,{}), {1+1i} )
    cmref = cvector(1) cmref:seti(1,1+1i)
    assertEquals( cm:filter(f   )          , cmref )
    assertEquals( cm:filter(f, cvector(25)), cmref )

    f=\x x>1
    --mref = vector(nr*nc-1):fill(2..nr*nc)
    --for i=1,#m-1 do mref:seti(i, m:geti(i+1)) end
    --print( m:filter(f) )
    --print( mref )

    mref = {}            for i=1,#m-1 do mref[i] = m:geti(i+1) end
    assertEquals( m:filter(f, {}), mref )
    mref = vector(25) for i=1,25 do if i<=#m-1 then mref:seti(i, m:geti(i+1)) else mref:seti(i,0) end end
    --assertEquals( m:filter(f, vector(25)), mref )
  end end
end

--function TestMatrix:testFilter_out() end

-- conversion -----------------------------------------------------------------o

function TestMatrix:testTosting()
  local tostring in MAD
  local m, cm, c, r
  for nr=1,5 do
  for nc=1,5 do
    m  =  matrix(nr,nc):fill(1..nr*nc)
    cm = cmatrix(nr,nc):fill(1..nr*nc)
    assertTrue( is_string(tostring(m       )) )
    assertTrue( is_string(tostring(m , ''  )) )
    assertTrue( is_string(tostring(m , "\n")) )
    assertTrue( is_string(tostring(cm      )) )
    assertTrue( is_string(tostring(cm, ''  )) )
    assertTrue( is_string(tostring(cm, "\n")) )

    c, r = {}, {}
    for i=1,nr do for j=1,nc do c[j]=tostring((i-1)*nc+j) end r[i]=table.concat(c,' ')   end
    assertEquals( tostring(m       ), table.concat(r, '\n') )
    assertEquals( tostring(cm      ), table.concat(r, '\n') )
    for i=1,nr do for j=1,nc do c[j]=tostring((i-1)*nc+j) end r[i]=table.concat(c)       end
    assertEquals( tostring(m , ''  ), table.concat(r, '\n') )
    assertEquals( tostring(cm, ''  ), table.concat(r, '\n') )
    for i=1,nr do for j=1,nc do c[j]=tostring((i-1)*nc+j) end r[i]=table.concat(c, "\n") end
    assertEquals( tostring(m , '\n'), table.concat(r, '\n') )
    assertEquals( tostring(cm, '\n'), table.concat(r, '\n') )
  end end
end

function TestMatrix:testTotable()
  local m, cm, tref, ctref
  local msg = {
    "invalid argument #2 (table expected)"          ,
    "invalid argument #2 (table of tables expected)", -- triggering second err?
  }
  assertErrorMsgContains( msg[1], totable, matrix(2), ''        )
  assertErrorMsgContains( msg[1], totable, matrix(2), 1         )
  assertErrorMsgContains( msg[1], totable, matrix(2), true      )
  assertErrorMsgContains( msg[1], totable, matrix(2), 1..2      )
  assertErrorMsgContains( msg[1], totable, matrix(2), matrix(2) )

  for nr=1,5 do
  for nc=2,5 do
    m  =  matrix(nr,nc):fill(1..nr*nc)
    cm = cmatrix(nr,nc):fill(1..nr*nc)
    tref, ctref = {}, {}
    for i = 1,nr do  tref[i]={} for j=1,nc do  tref[i][j]=(i-1)*nc+j end end
    for i = 1,nr do ctref[i]={} for j=1,nc do ctref[i][j]=complex((i-1)*nc+j,0) end end
    assertEquals( totable(m )   ,  tref )
    assertEquals( totable(cm)   , ctref )
    assertEquals( matrix( tref) ,  m    )
    assertEquals( cmatrix(ctref), cm    )
    assertTrue  ( is_table  (totable( m)   ) )
    assertTrue  ( is_table  (totable(cm)   ) )
    assertTrue  ( is_matrix ( matrix( tref)) )
    assertTrue  ( is_cmatrix(cmatrix(ctref)) )
  end end
end

-- special maps ---------------------------------------------------------------o

local v   = {
  num = { 1, 2 },
}

local ceil, floor, frac, trunc, round in MAD

function TestMatrix:testCeil ()
  local m, v, nc, m1
  v = {{0.1, 0.3, 0.4, 0.5, 0.6}}
  m = matrix(v)

  nc = {m:sizes()}
  nc = nc[2]
  m1 = m:ceil()

  local mth  = \f,... f(...)
  local mth2 = \f,s,... s[f](s,...)

 -- for i=1,#v do for j=1,#v[i] do assertEquals( m1:geti((i-1)*nc+j), mth('ceil',v[i][j]) ) end end

end

--[[
function TestMatrix:testFloor() end
function TestMatrix:testFrac () end
function TestMatrix:testTrunc() end
function TestMatrix:testRound() end

function TestMatrix:testAbs  () end
function TestMatrix:testSqrt () end
function TestMatrix:testExp  () end
function TestMatrix:testLog  () end
function TestMatrix:testLog10() end

function TestMatrix:testSin () end
function TestMatrix:testCos () end
function TestMatrix:testTan () end
function TestMatrix:testSinh() end
function TestMatrix:testCosh() end
function TestMatrix:testTanh() end

function TestMatrix:testAsin () end
function TestMatrix:testAcos () end
function TestMatrix:testAtan () end
function TestMatrix:testAsinh() end
function TestMatrix:testAcosh() end
function TestMatrix:testAtanh() end

function TestMatrix:testErf   () end
function TestMatrix:testTgamma() end
function TestMatrix:testLgamma() end

function TestMatrix:testCarg () end
function TestMatrix:testReal () end
function TestMatrix:testImag () end
function TestMatrix:testConj () end
function TestMatrix:testProj () end
function TestMatrix:testRect () end
function TestMatrix:testPolar() end
]]

-- special folds --------------------------------------------------------------o

function TestMatrix:testMin()
  local m, mref, tref
  --[[
  for nr=1,5 do
  for nc=1,5 do
    m  =  matrix(nr,nc):fill(1..nr*nc)
    assertEquals( m:min()     , 1 )
    assertEquals( m:min("col"), matrix(1,nc):fill(1..nc) )

    mref = vector(nr) for i=1,nr do mref:seti( i, m:geti((i-1)*nc+1)) end
    assertEquals( m:min("row"    ), mref )
    tref = {}         for i=1,nr do tref[i] = (i-1)*nc+1 end
    assertEquals( m:min({}       ), tref )
  end end
  ]]
end


function TestMatrix:testMax()
  local m, mref, tref
  --[[
  for nr=1,5 do
  for nc=1,5 do
    m  =  matrix(nr,nc):fill(1..nr*nc )
    assertEquals( m:max()     , nr*nc )
    assertEquals( m:max("col"), matrix(1,nc):fill((nr-1)*nc+1..nr*nc) )
    mref = vector(nr) for i=1,nr do mref:seti( i, m:geti(i*nc) ) end
    assertEquals( m:max("row"    ), mref )
    tref = {}         for i=1,nr do tref[i] = i*nc end
    assertEquals( m:max({}       ), tref )
  end end
  ]]
end

function TestMatrix:testSum()
  local m, mref, tref, x, cm, cmref, ctref
  for nr=1,5 do
  for nc=1,5 do
    m    = matrix(nr,nc):fill(1..nr*nc )
    mref = 0 for i=1,nr*nc do mref=i+mref end
    assertEquals( m:sum()     , mref )
    mref = vector(nr)   for i=1,nr do x=0 for j=1,nc do x=(i-1)*nc+j + x end mref:seti(i, x) end
    assertEquals( m:sum("row"), mref )
    mref = matrix(1,nc) for i=1,nc do x=0 for j=1,nr do x=(j-1)*nc+i + x end mref:seti(i, x) end
    assertEquals( m:sum("col"), mref )
    tref = {}           for i=1,nr do x=0 for j=1,nc do x=(i-1)*nc+j + x end tref[i] = x     end
  --  assertEquals( m:sum({}   ),  tref )

    cm   = cmatrix(nr,nc):fill(1..nr*nc):fill(\x x+x*1i)
    cmref = 0 for i=1,nr*nc do cmref = complex(i,i)+cmref end
    assertEquals( cm:sum()     , cmref )
    cmref = cvector(nr)   for i=1,nr do x=0 for j=1,nc do x=complex((i-1)*nc+j,(i-1)*nc+j)+x end cmref:seti(i, x) end
    assertEquals( cm:sum("row"), cmref )
    cmref = cmatrix(1,nc) for i=1,nc do x=0 for j=1,nr do x=complex((j-1)*nc+i,(j-1)*nc+i)+x end cmref:seti(i, x) end
    assertEquals( cm:sum("col"), cmref )
    ctref = {}            for i=1,nr do x=0 for j=1,nc do x=complex((i-1)*nc+j,(i-1)*nc+j)+x end ctref[i] = x     end
 --   assertEquals( cm:sum({}   ),  ctref )
  end end
end

function TestMatrix:testSumabs() --TODO: finish after foldl --err: foldl does not work matrix(1)
  local m, mref, x, cm, cmref
  for nr=1,5 do
  for nc=1,5 do
    m    = matrix(nr,nc):fill(-1..-nr*nc..-1 )
    mref = 0 for i=1,nr*nc do mref=i+mref end
    --if nr*nc>1 then assertEquals( m:sumabs(), mref ) end
    if nr*nc>1 then
      --print( m , "\n")
      --print( m:sumabs(), mref , "\n")
    end

    cm   = cmatrix(nr,nc):fill(1..nr*nc):fill(\x x+x*1i)
    cmref = 0 for i=1,nr*nc do cmref = abs(complex(i,i))+cmref end
    --if nr*nc>1 then assertEquals( cm:sumabs(), cmref ) end
  end end
end

function TestMatrix:testSumsqr()
  local m, mref, x, cm, cmref
  for nr=1,5 do
  for nc=1,5 do
    mref = 0 for i=1,nr*nc do mref=i*i+mref end
    m    = matrix(nr,nc):fill(1..nr*nc )
    assertEquals( m:sumsqr(), mref )
    m    = matrix(nr,nc):fill(-1..-nr*nc..-1 )
    if nr*nc>1 then
    --  print( m:sumsqr(), mref )
    end

    cm   = cmatrix(nr,nc):fill(1..nr*nc):fill(\x x+x*1i)
    cmref = 0 for i=1,nr*nc do cmref = complex(i,i)*complex(i,i)+cmref end
    if nr*nc>1 then
      --print( cm:sumsqr(), cmref )
    end
  end end
end

function TestMatrix:testProduct()
  local m, mref, x, cm, cmref
  for nr=1,5 do
  for nc=1,5 do
    m    = matrix(nr,nc):fill(1..nr*nc )
    mref = 1 for i=1,nr*nc do mref=i*mref end
    assertEquals( m:product(), mref )
    m    = matrix(nr,nc):fill(nr*nc..1..-1 )
    --print(m:product(), m:product() - mref )

    cm    = cmatrix(nr,nc):fill(1..nr*nc):fill(\x x+x*1i)
    cmref = 1 for i=1,nr*nc do cmref = complex(i,i)*cmref end
    assertEquals( cm:product(), cmref )
  end end
end

function TestMatrix:testAll() --TODO: extend
  local msg = {
    "reentrant use of all (not expected)"    ,
    "invalid argument #2 (callable expected)",
  }
  assertErrorMsgContains( msg[2], mth, 'all', matrix(2), nil )
  assertFalse( matrix(2)           :all(\x x>2) )
  assertTrue ( matrix(2):fill(3)   :all(\x x>2) )
  assertFalse( matrix(3):fill(1..9):all(\x x>2) )
end

function TestMatrix:testAny() --TODO: extend
  local msg = {
    "reentrant use of all (not expected)"    ,
    "invalid argument #2 (callable expected)",
  }
  assertErrorMsgContains( msg[2], mth, 'any', matrix(2), nil )
  assertFalse( matrix(2)           :any(\x x>2) )
  assertTrue ( matrix(2):fill(3)   :any(\x x>2) )
  assertTrue ( matrix(3):fill(1..9):any(\x x>2) )
end

-- special scans --------------------------------------------------------------o
--[[
function TestMatrix:testAccmin   () end
function TestMatrix:testAccmax   () end
function TestMatrix:testAccsum   () end
function TestMatrix:testAccsumabs() end
function TestMatrix:testAccsumsqr() end
function TestMatrix:testAccprod  () end

function TestMatrix:testAccsum() end

function TestMatrix:testRaccmin   () end
function TestMatrix:testRaccmax   () end
function TestMatrix:testRaccsum   () end
function TestMatrix:testRaccsumabs() end
function TestMatrix:testRaccsumsqr() end
function TestMatrix:testRaccprod  () end
]]

-- conjugate, transpose -------------------------------------------------------o

function TestMatrix:testConjugate() -- TODO: revise, cm?
local m, cm
  for nr=1,5 do
  for nc=1,5 do
    m  =  matrix(nr,nc):fill(1..nr*nc )
    assertEquals( m :conj() , m  )
    cm = cmatrix(nr,nc):fill(1..nr*nc):fill(\x x+x*1i)
    assertEquals( cm:conj(), cmatrix(nr,nc):fill(1..nr*nc):fill(\x  x-x*1i) )
    cm = cmatrix(nr,nc):fill(-1..-nr*nc..-1):fill(\x x+x*1i)
    assertEquals( cm:conj(), cmatrix(nr,nc):fill(1..nr*nc):fill(\x -x+x*1i) )
  end end
end

function TestMatrix:testTranspose() -- TODO:expand the test
  local m1, m2
  for nr=1,5 do
  for nc=1,5 do
    m1 = matrix(nr,nc):fill(1..nr*nc )
    m2 = matrix(nr,nc):fill(1..nr*nc )
    assertEquals( {m1:t():sizes()}, {nc,nr}       )
    assertEquals(  m1:t():t()     , m1            )
    assertEquals( (m1+m2):t()     , m1:t()+m2:t() )
    assertEquals( (2*m2) :t()     , 2*m2:t()      )

    if nr == nc then
      assertEquals( (m1*m2):t(), m1:t()*m2:t() )
      m1:t('in')                                        -- only if nr==nc (size)
      assertEquals( m1, m2:t() )
      for i=1,nr do for j=1,nc do                       -- symmetric matrix test
        if i>j then m1:set(i,j, m1:get(j,i)) end
      end end
    end
  end end
end

function TestCMatrix:testTranspose()
  local cm1, cm2
  for nr=1,5 do
  for nc=1,5 do
    cm1 = cmatrix(nr,nc):fill(1..nr*nc ):fill(\x x+x*1i)
    cm2 = cmatrix(nr,nc):fill(1..nr*nc )
    assertEquals( {cm1:t():sizes()}     , {nc,nr}         )
    assertEquals(  cm1:t() :t()         , cm1             )
    assertEquals( (cm1+cm2):t()         , cm1:t()+cm2:t() )
    assertEquals( (2*cm2)  :t()         , 2*cm2:t()       )
    assertEquals(  cm1:t(false):t(false), cm1                       )
    assertEquals( (cm1+cm2):t(false)    , cm1:t(false)+cm2:t(false) )
    assertEquals( (2*cm2)  :t(false)    , 2*cm2:t(false)            )

    if nr == nc then
      assertEquals( (cm1*cm2):t(), cm1:t()*cm2:t() )
      cm1:t('in')                                       -- only if nr==nc (size)
      assertEquals( cm1, cmatrix(nr,nc):fill(1..nr*nc ):fill(\x x+x*1i):t() )
      cm1:t('in', false)
      assertEquals( cm1, cmatrix(nr,nc):fill(1..nr*nc ):fill(\x x-x*1i)     )
      for i=1,nr do for j=1,nc do                      -- symmetric matrix test
        if i>j then cm1:set(i,j, cm1:get(j,i)) end
      end end
      assertEquals(  cm1:t():conj(), cm1 )
    end
  end end
end

function TestMatrix:testTrace()
  local m, cm, x, cx
  for nr=1,5 do
  for nc=1,5 do
    m  =  matrix(nr,nc):fill(1..nr*nc )
    cm = cmatrix(nr,nc):fill(1..nr*nc ):fill(\x x+x*1i)
    x, cx = 0, 0
    if nr==nc then
      for i=1,nr do for j=1,nc do
        if i==j then x  =  m:get(i,j) + x  end
        if i==j then cx = cm:get(i,j) + cx end
      end end
      assertEquals( m :tr(), x  )
      assertEquals( cm:tr(), cx )
    end
  end end
end

-- symplectic matrix ----------------------------------------------------------o

--[[
--need to create a symplectic matrix set and then work on it thorugh below test

function TestMatrix:testSympinv()
  local msg = {
   "invalid argument #1 (2n matrix expected)",
  }
end

function TestCMatrix:testSympinv()
  local msg = {
   "invalid argument #1 (2n matrix expected)",
  }
end

function TestMatrix:testSymperr()
  local msg = {
    "invalid argument #1 (2n matrix expected)",
    "invalid argument #2 (different matrix expected)",
  }
end

function TestCMatrix:testSymperr()
  local msg = {
    "invalid argument #1 (2n matrix expected)",
    "invalid argument #2 (different matrix expected)",
  }
end
]]

-- inner, cross, mixed, outer -------------------------------------------------o

function TestMatrix:testInner()
  -- inner prod:  u'.v = |u|.|v| cos(u^v)
  local m1, m2, cm
  local msg = {
    "invalid argument #2 (matrix expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'inner', matrix(2), nil  )
  assertErrorMsgContains( msg[1], mth, 'inner', matrix(2), ''   )
  assertErrorMsgContains( msg[1], mth, 'inner', matrix(2), 1    )
  assertErrorMsgContains( msg[1], mth, 'inner', matrix(2), 1..2 )
  assertErrorMsgContains( msg[1], mth, 'inner', matrix(2), {}   )

  for nr=1,5 do
  for nc=1,5 do
    m1 =  matrix(nr,nc):fill(1..nr*nc)
    m2 =  matrix(nr,nc):fill(1..nr*nc)
    cm = cmatrix(nr,nc):fill(1..nr*nc)
    assertEquals( m1:inner(m2), (m1:t()*m2):tr() )
    assertEquals( m1:inner(cm), (m1:t()*cm):tr() )
  end end
end

function TestCMatrix:testInner()
  local cm1, cm2, m
  local msg = {
    "invalid argument #2 (matrix expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'inner', cmatrix(2), nil  )
  assertErrorMsgContains( msg[1], mth, 'inner', cmatrix(2), ''   )
  assertErrorMsgContains( msg[1], mth, 'inner', cmatrix(2), 1    )
  assertErrorMsgContains( msg[1], mth, 'inner', cmatrix(2), 1..2 )
  assertErrorMsgContains( msg[1], mth, 'inner', cmatrix(2), {}   )

  for nr=1,5 do
  for nc=1,5 do
    cm1 = cmatrix(nr,nc):fill(1..nr*nc)
    cm2 = cmatrix(nr,nc):fill(1..nr*nc)
    m   =  matrix(nr,nc):fill(1..nr*nc)
    assertEquals( cm1:inner(cm2), (cm1:t()*cm2):tr() )
    assertEquals( cm1:inner(m)  , (cm1:t()*m  ):tr() )
  end end
end

function TestMatrix:testCross() --TODO: different size of second matrix tests
 --cross prod:  uxv = |u|.|v| sin(u^v) \vec{n}
  local m1, m2, m3, cm1, cm2, cm3
  local msg = {
    "invalid argument #2 (matrix expected)",
    "invalid matrix sizes"                 ,
  }
  assertErrorMsgContains( msg[1], mth, 'cross', matrix(3), nil  )
  assertErrorMsgContains( msg[1], mth, 'cross', matrix(3), ''   )
  assertErrorMsgContains( msg[1], mth, 'cross', matrix(3), 1    )
  assertErrorMsgContains( msg[1], mth, 'cross', matrix(3), 1..2 )
  assertErrorMsgContains( msg[1], mth, 'cross', matrix(3), {}   )
  assertErrorMsgContains( msg[2], mth, 'cross', matrix(2), matrix(3) )
  -- generalize
  m1 = vector({1,2,3})
  m2 = vector({3,2,1})
  m3 = matrix(3) -- skew-symmetric matrix
  m3:seti( 4, m1:geti(3)) m3:seti( 2,-m1:geti(3))
  m3:seti( 3, m1:geti(2)) m3:seti( 7,-m1:geti(2))
  m3:seti( 8, m1:geti(1)) m3:seti( 6,-m1:geti(1))
  assertEquals( m1:cross(m2), m3*m2 )
  m1:cross(m2, 'in')
  assertEquals( m1, m3*m2 )

  m1 = matrix(3,2):fill(1..3*2)
  m1:cross( matrix(3,2):fill(1), 'in')
  assertEquals( m1, matrix(3,2):fill(1..3*2):cross( matrix(3,2):fill(1)) )

  --print(matrix(3):fill(1..9):cross(matrix(2,1)))

  for nc=1,5 do
    assertEquals(  matrix(3,nc):fill(1..3*nc):cross( matrix(3,nc):fill(1..3*nc)), matrix(3,nc) )
    assertEquals(  matrix(3,nc):fill(1..3*nc):cross(cmatrix(3,nc):fill(1..3*nc)), matrix(3,nc) )
    assertEquals( cmatrix(3,nc):fill(1..3*nc):cross( matrix(3,nc):fill(1..3*nc)), matrix(3,nc) )
    assertEquals( cmatrix(3,nc):fill(1..3*nc):cross(cmatrix(3,nc):fill(1..3*nc)), matrix(3,nc) )
    assertEquals(  matrix(3,nc)              :cross( matrix(3,nc):fill(1..3*nc)), matrix(3,nc) )
    assertEquals(  matrix(3,nc)              :cross( matrix(3,nc))              , matrix(3,nc) )
    assertEquals(  matrix(3,nc)              :cross(cmatrix(3,nc):fill(1..3*nc)), matrix(3,nc) )

    m1  =  matrix(3,nc):fill(1..3*nc)
    m2  =  matrix(3,nc):fill(3*nc..1..-1)
    m3  =  matrix(3,nc):fill(3*nc..1..-1)
    cm1 = cmatrix(3,nc):fill(1..3*nc)
    cm2 = cmatrix(3,nc):fill(3*nc..1..-1)
    cm3 = cmatrix(3,nc):fill(3*nc..1..-1)
    assertEquals( m1 :cross( m2)  ,-m2  :cross( m1)              )
    assertEquals( cm1:cross( m2)  ,-m2  :cross(cm1)              )
    assertEquals( cm1:cross(cm2)  ,-cm2 :cross(cm1)              )
    assertEquals( m1 :cross(m2+m3), m1  :cross( m2)+m1:cross(m3) )
    assertEquals( (2*m1):cross(m2), m1  :cross( m2*2)            )
    assertEquals( (2*m1):cross(m2), 2*m1:cross( m2)              )
    assertEquals( (2*m1):cross(m2), 2*m1:cross( m2)              )
    --assertEquals( m1:cross(m2:cross(m3)) , m2*(m1*m3)-m3*(m1*m2)  ) -- fin after multiplication tests
  end
end

function TestMatrix:testMixed() --TODO: 'in', r_ + r_ err
  -- mixed prod:  (uxv)'.w = u'.(vxw) = det(u,v,w)
  local m1, m2, m3
  local msg = {
    "invalid argument #2 (matrix expected)",
    "invalid argument #3 (matrix expected)",
    "invalid matrix sizes"                 ,
    "incompatible matrix sizes"            ,
  }
  m1 = matrix(3,1)
  assertErrorMsgContains( msg[1], mth, 'mixed', m1, nil  )
  assertErrorMsgContains( msg[1], mth, 'mixed', m1, ''   )
  assertErrorMsgContains( msg[1], mth, 'mixed', m1, 1    )
  assertErrorMsgContains( msg[1], mth, 'mixed', m1, 1..2 )
  assertErrorMsgContains( msg[1], mth, 'mixed', m1, {}   )
  assertErrorMsgContains( msg[2], mth, 'mixed', m1, m1  , nil  )
  assertErrorMsgContains( msg[2], mth, 'mixed', m1, m1  , ''   )
  assertErrorMsgContains( msg[2], mth, 'mixed', m1, m1  , 1    )
  assertErrorMsgContains( msg[2], mth, 'mixed', m1, m1  , 1..2 )
  assertErrorMsgContains( msg[2], mth, 'mixed', m1, m1  , {}   )
  assertErrorMsgContains( msg[3], mth, 'mixed', matrix(2,1), m1, m1 )
  assertErrorMsgContains( msg[4], mth, 'mixed', matrix(3,2), m1, m1 )
  assertErrorMsgContains( msg[4], mth, 'mixed', m1, matrix(2,1), m1 )
  assertErrorMsgContains( msg[4], mth, 'mixed', m1, matrix(3,2), m1 )
  assertErrorMsgContains( msg[4], mth, 'mixed', m1, m1 ,matrix(2,1) )
  assertErrorMsgContains( msg[4], mth, 'mixed', m1, m1 ,matrix(3,2) )
-- x.nr==3, y.nr==x.nr, z.nr==x.nr, y.nc==x.nc, z.nc==x.nc

  for nc=1,5 do
    m1 = matrix(3,nc):fill(1..nc*6..2)
    m2 = matrix(3,nc):fill(3*nc..1..-1)
    m3 = matrix(3,nc):fill(1..3*nc)
    -- vector vs number after inner
    --print( m1:mixed( m2, m3)     , "\n" )
    --print( m1:cross(m2):inner(m3), "\n" )
    --assertEquals( m1:mixed( m2, m3), m1:cross(m2):inner(m3) )
  end
end

function TestMatrix:testOuter()
  -- x * y:t() without temporary --  outer prod:  u.v' = matrix
  local m1, m2, cm1, cm2
  local msg = {
    "invalid argument #2 (matrix expected)",
    "incompatible matrix sizes",
  }
  assertErrorMsgContains( msg[1], mth, 'outer', matrix(2,1), nil  )
  assertErrorMsgContains( msg[1], mth, 'outer', matrix(2,1), ''   )
  assertErrorMsgContains( msg[1], mth, 'outer', matrix(2,1), {}   )
  assertErrorMsgContains( msg[1], mth, 'outer', matrix(2,1), 1    )
  assertErrorMsgContains( msg[1], mth, 'outer', matrix(2,1), 1..2 )
  assertErrorMsgContains( msg[2], mth, 'outer', matrix(1,2), matrix(2,2) )
  assertErrorMsgContains( msg[2], mth, 'outer', matrix(2,2), matrix(1,2) )

  for nr=1,5 do
    m1  =  matrix(nr,1):fill(1..2*nr..2)
    m2  =  matrix(nr,1):fill(1..nr)
    cm1 = cmatrix(nr,1):fill(1..2*nr..2):fill(\x x+x*1i)
    cm2 = cmatrix(nr,1):fill(1..nr):fill(\x x+x*1i)
    assertEquals(  m1:outer( m2),  m1* m2:t() )
    assertEquals( cm1:outer(cm2), cm1*cm2:t() )
    assertEquals( cm1:outer( m2), cm1* m2:t() )
    assertEquals(  m1:outer(cm2),  m1*cm2:t() )

    if nr==1 then            -- size issue, can not be used with anything bigger
      m1 :outer(m2 , 'in')
      cm1:outer(cm2, 'in')
      assertEquals( m1 , m1*m2:t() )
      assertEquals( cm1, cmatrix(nr,1):fill(1..2*nr..2):fill(\x x+x*1i)*cm2:t() )
    end
  end
end

-- norm, unit, center, angle (in place) ---------------------------------------o

function TestMatrix:testNorm()
--|u| = sqrt(u'.u)
  local m
  for nr=1,5 do
  for nc=1,5 do
    m = matrix(nr,nc):fill(1..nr*nc)
    --print( m:norm()         , "\n")
    --print( (m*m:t()):sqrt() , "\n")
    if nr == 1 then
      assertEquals( m:norm(), (m*m:t()):sqrt():geti(1) )
    end
  end end
end

function TestCMatrix:testNorm()
  local cm
  for nr=1,5 do
  for nc=1,5 do
    cm = cmatrix(nr,nc):fill(1..nr*nc)
    if nr == 1 then
      assertEquals( complex(cm:norm(),0), (cm*cm:t()):sqrt():geti(1) )
    end
  end end
end

function TestMatrix:testDistance()
  local msg, m1, m2 = {
    "invalid argument #2 (matrix expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'distance', matrix(2), nil  )
  assertErrorMsgContains( msg[1], mth, 'distance', matrix(2), 1..2 )
  assertErrorMsgContains( msg[1], mth, 'distance', matrix(2), ''   )
  assertErrorMsgContains( msg[1], mth, 'distance', matrix(2), {}   )
  assertErrorMsgContains( msg[1], mth, 'distance', matrix(2), cmatrix(1) )

  for nr=1,5 do
  for nc=1,5 do
    m1 = matrix(nr,nc):fill(1..nr*nc)
    m2 = matrix(nr,nc):fill(nr*nc..1..-1)
    --print( m1             , "\n")
    --print( m1:distance(m2), "\n")
    x=0
    --for i=1, nr*nc do  x=m1:geti(i) + m2:geti(i) + x   end
  end end
end

function TestCMatrix:testDistance()
  local msg, cm = {
    "invalid argument #2 (cmatrix expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'distance', cmatrix(2), nil  )
  assertErrorMsgContains( msg[1], mth, 'distance', cmatrix(2), 1..2 )
  assertErrorMsgContains( msg[1], mth, 'distance', cmatrix(2), ''   )
  assertErrorMsgContains( msg[1], mth, 'distance', cmatrix(2), {}   )
  assertErrorMsgContains( msg[1], mth, 'distance', cmatrix(2), matrix(1) )

  for nr=1,5 do
  for nc=1,5 do
    cm = cmatrix(nr,nc):fill(1..nr*nc)
  end end
end

--[[
function TestMatrix:testUnit()
  local msg = {
    "null matrix norm",
  }
end

function TestCMatrix:testUnit()
  local msg = {
    "null matrix norm",
  }
end

function TestMatrix:testCenter() end
function TestCMatrix:testCenter() end

function TestMatrix:testAngle()
  local msg = {
    "null vector norm",
  }
end

-- operators ------------------------------------------------------------------o

function TestMatrix:testEq() end

function TestMatrix:testAddCPx() end
function TestMatrix:testAdd()
  local msg = {
    "invalid arguments (unsupported matrix operation)",
  }
end
function TestCMatrix:testAddCPx() end
function TestCMatrix:testAdd()
  local msg = {
    "invalid arguments (unsupported matrix operation)",
  }
end

function TestMatrix:testSubCPx() end
function TestMatrix:testSub()
  local msg = {
    "invalid arguments (unsupported matrix operation)",
  }
end

function TestCMatrix:testSubCPx() end

function TestCMatrix:testSub()
  local msg = {
    "invalid arguments (unsupported matrix operation)",
  }
end

function TestMatrix:testMulCPx() end
function TestMatrix:testMul()
  local msg = {
    "invalid arguments (unsupported matrix operation)",
  }
end

function TestCMatrix:testMulCPx() end
function TestCMatrix:testMul()
  local msg = {
    "invalid arguments (unsupported matrix operation)",
  }
end

function TestMatrix:testTmul()
  local msg = {
    "invalid arguments (unsupported matrix operation)",
  }
end
function TestCMatrix:testTmul()
  local msg = {
    "invalid arguments (unsupported matrix operation)",
  }
end

function TestMatrix:testDivCPx() end

function TestMatrix:testDiv()
  local msg = {
    "invalid arguments (unsupported matrix operation)",
  }
end

function TestCMatrix:testDivCPx() end
function TestCMatrix:testDiv()
  local msg = {
    "invalid arguments (unsupported matrix operation)",
  }
end

function TestMatrix:testEmul()
  local msg = {
    "invalid argument #2 (matrix expected)",
  }
end

function TestCMatrix:testEmul()
  local msg = {
    "invalid argument #2 (matrix expected)",
  }
end

function TestMatrix:testEdiv()
  local msg = {
    "invalid argument #2 (matrix expected)",
  }
end

function TestCMatrix:testEdiv()
  local msg = {
    "invalid argument #2 (matrix expected)",
  }
end


-- linear algebra -------------------------------------------------------------o

function TestMatrix:testSolve() end
function TestMatrix:testSvd() end
function TestCMatrix:testSvd() end

function TestMatrix:testEigen()
  local msg = {
    "matrix must be square",
  }
end

function TestCMatrix:testEigen()
  local msg = {
    "matrix must be square",
  }
end


-- FFT, convolution, correlation, covrariance ---------------------------------o

function TestMatrix:testFft() end
function TestMatrix:testIfft() end

function TestMatrix:testRfft()
  local msg = {
    "incompatible matrix sizes",
  }
end

function TestMatrix:testIrfft()
  local msg = {
    "result matrix must be real",
    "incompatible matrix sizes" ,
  }
end

 -- convolution theorem
function TestMatrix:testConv() end
function TestCMatrix:testConv() end

 -- correlation theorem
function TestMatrix:testCorr() end
function TestCMatrix:testCorr() end
function TestMatrix:testCovar() end

-- concatenation --------------------------------------------------------------o

function TestMatrix:testConcat()
  local msg = {
    "invalid argument #1 (matrix expected)"               ,
    "invalid argument #2 (matrix expected)"               ,
    "incompatible matrix sizes"                           ,
    "invalid argument #3 (string 'row' or 'col' expected)",
  }
end
]]
-- end ------------------------------------------------------------------------o
