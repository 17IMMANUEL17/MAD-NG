--[=[
 o-----------------------------------------------------------------------------o
 |
 | Matrix module regression tests
 |
 | Methodical Accelerator Design - Copyright CERN 2015+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: A.Z. Teska, aleksandra.teska at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide regression test suites for the matrix module.

 o-----------------------------------------------------------------------------o
]=]

local assertEquals, assertAlmostEquals, assertTrue, assertFalse,
      assertErrorMsgContains, assertNil, assertNaN, assertIsString, assertInf
      in require 'luaunit'

local vector, cvector, matrix, cmatrix, is_vector, is_matrix, is_cvector,
      is_cmatrix, isa_vector, isa_matrix, linspace, logspace in MAD

local complex, infi, tiny, eps, huge, inf, nan, pi, Pi, randomseed, log,
      is_complex, range, nrange, nlogrange, is_cdata in MAD

-- regression test suite ------------------------------------------------------o

TestMatrix  = {}
TestCMatrix = {}

local values = {
  num = { tiny, 2^-64, 2^-63, 2^-53, eps, 2^-52, 2*eps, 2^-32, 2^-31, 1e-9,
          0.1-eps, 0.1, 0.1+eps, 0.5, 0.7-eps, 0.7, 0.7+eps, 1-eps, 1, 1+eps,
          1.1, 1.7, 2, 10, 1e2, 1e3, 1e6, 1e9, 2^31, 2^32, 2^52, 2^53,
          2^63, 2^64, huge },
}

local mth = \f,s,... s[f](s,...)

function TestMatrix:testCtorMatrix()
  local m, v
  local msg = {
  "invalid argument #1 or #2 (nrow[,ncol] >=1 or table [of tables] expected)",
   "matrix too large",
  }
  assertErrorMsgContains( msg[1], matrix, ''     )
  assertErrorMsgContains( msg[1], matrix, nil    )
  assertErrorMsgContains( msg[1], matrix, 0      )
  assertErrorMsgContains( msg[1], matrix, tiny   )
  assertErrorMsgContains( msg[1], matrix, eps    )
  assertErrorMsgContains( msg[1], matrix, 1..2   )
  assertErrorMsgContains( msg[1], matrix, infi   )
  assertErrorMsgContains( msg[1], matrix, nan    )
  assertErrorMsgContains( msg[1], matrix,-1      )
  assertErrorMsgContains( msg[1], matrix,-eps    )
  assertErrorMsgContains( msg[2], matrix, inf    )
  assertErrorMsgContains( msg[2], matrix, huge   )
  assertErrorMsgContains( msg[2], matrix, 2^15+1 )
  assertErrorMsgContains( msg[2], vector, 2^30+1 )

  assertTrue( is_matrix( vector(2^30)) )
  assertTrue( is_matrix( matrix(2^15)) )
  for nr=1,5 do
    v = vector(nr)
    assertTrue  ( is_vector(v) )
    assertEquals( v.nr, nr )
    assertEquals( v.nc, 1  )
    for nc=1,5 do
      m = matrix(nr,nc)
      assertTrue  ( is_matrix(v) )
      assertTrue  ( is_matrix(m) )
      assertEquals( m.nr, nr )
      assertEquals( m.nc, nc )
    end end
end

function TestMatrix:testCtorCMatrix()
  local cm, cv
  local msg = {
  "invalid argument #1 or #2 (nrow[,ncol] >=1 or table [of tables] expected)",
  "matrix too large",
  }
  assertErrorMsgContains( msg[1], cmatrix, ''     )
  assertErrorMsgContains( msg[1], cmatrix, nil    )
  assertErrorMsgContains( msg[1], cmatrix, 0      )
  assertErrorMsgContains( msg[1], cmatrix, tiny   )
  assertErrorMsgContains( msg[1], cmatrix, eps    )
  assertErrorMsgContains( msg[1], cmatrix,-1      )
  assertErrorMsgContains( msg[1], cmatrix,-tiny   )
  assertErrorMsgContains( msg[1], cmatrix, 1..2   )
  assertErrorMsgContains( msg[1], cmatrix, infi   )
  assertErrorMsgContains( msg[1], cmatrix,-infi   )
  assertErrorMsgContains( msg[1], cmatrix, nan    )
  assertErrorMsgContains( msg[1], cmatrix,-inf    )
  assertErrorMsgContains( msg[2], cmatrix, inf    )
  assertErrorMsgContains( msg[2], cmatrix, 2^15   )
  assertErrorMsgContains( msg[2], cvector, 2^29+1 )

  assertTrue( is_cmatrix( cvector(2^29)) )
  for nr=1,5 do
    cv = cvector(nr)
    assertTrue  ( is_cvector(cv) )
    assertEquals( cv.nr, nr )
    assertEquals( cv.nc, 1  )
    for nc=1,5 do
      cm = cmatrix(nr,nc)
      assertTrue  ( is_cmatrix(cv) )
      assertTrue  ( is_cmatrix(cm) )
      assertEquals( cm.nr, nr )
      assertEquals( cm.nc, nc )
    end end
end

function TestMatrix:testCtorFromtable() --TODO
  local msg = {
  "invalid argument #1 (non-empty table expected)",
  "cannot convert 'string' to 'double'"           ,
  "cannot convert 'string' to 'complex'"          ,
  }
  assertErrorMsgContains( msg[1],  matrix, {nil} )
  assertErrorMsgContains( msg[1], cmatrix, {}    )
  assertErrorMsgContains( msg[2],  matrix, {''}  )
  assertErrorMsgContains( msg[3], cmatrix, {''}  )

  assertTrue  ( is_matrix(matrix({ inf})) )
  assertTrue  ( is_matrix(matrix({-inf})) )
  assertTrue  ( is_matrix(matrix({ nan})) )
  assertEquals(  matrix( {complex(0,1)} ),  matrix( 1)  ) -- complex/real matrix
  assertEquals(  matrix( {matrix(2)}    ),  matrix( 1)  )
  assertEquals(  matrix( {1..2}         ),  matrix({1}) )
  assertEquals( cmatrix( {complex(0,1)} ), cmatrix({complex(0,1)})  )
  assertEquals( cmatrix( {1}).data[0]    , complex(1,0) ) -- data[0] used, needs change
end

function TestMatrix:testCdataType()
  assertTrue ( is_matrix( matrix(2,2)) )
  assertFalse( is_matrix(cmatrix(2,2)) )
  assertTrue ( is_matrix( vector(1)  ) )
  assertFalse( is_matrix(cvector(1)  ) )

  assertFalse( is_cmatrix( matrix(2,2)) )
  assertTrue ( is_cmatrix(cmatrix(2,2)) )
  assertFalse( is_cmatrix( vector(1)  ) )
  assertTrue ( is_cmatrix(cvector(1)  ) )

  assertFalse( is_vector( matrix(2,2)) )
  assertFalse( is_vector(cmatrix(2,2)) )
  assertTrue ( is_vector( vector(1)  ) )
  assertFalse( is_vector(cvector(1)  ) )

  assertFalse( is_cvector( matrix(2,2)) )
  assertFalse( is_cvector(cmatrix(2,2)) )
  assertFalse( is_cvector( vector(1)  ) )
  assertTrue ( is_cvector(cvector(1)  ) )

  assertFalse( isa_vector( matrix(2,2)) )
  assertFalse( isa_vector(cmatrix(2,2)) )
  assertTrue ( isa_vector( vector(1)  ) )
  assertTrue ( isa_vector(cvector(1)  ) )

  assertTrue ( isa_matrix( matrix(2,2)) )
  assertTrue ( isa_matrix(cmatrix(2,2)) )
  assertTrue ( isa_matrix( vector(1)  ) )
  assertTrue ( isa_matrix(cvector(1)  ) )
end

--function TestMatrix:testIs_matrix()  end
--function TestMatrix:testIs_cmatrix() end
--function TestMatrix:testIs_vector()  end
--function TestMatrix:testIs_cvector() end
--function TestMatrix:testIsa_vector() end
--function TestMatrix:testIsa_matrix() end

-- get, set -------------------------------------------------------------------o

function TestMatrix:testGeti0()
  local msg, m, cm = {
    "attempt to compare nil with number",
    }
  assertErrorMsgContains( msg[1], mth, 'geti0', matrix(2,2), nil )
  assertNil   (  matrix(2,2):geti0( nan  )    )
  assertNil   (  matrix(2,2):geti0(-1    )    )
  assertEquals(  matrix(2,2):geti0( 0    ), 0 )
  assertNil   (  matrix(2,2):geti0( 0-eps)    )
  assertEquals(  matrix(2,2):geti0( 3    ), 0 )
  assertEquals(  matrix(2,2):geti0( 3+eps), 0 )
  assertNil   (  matrix(2,2):geti0( 4    )    )
  assertNil   (  matrix(2,2):geti0( 4-eps)    )
  assertNil   ( cmatrix(2,2):geti0( nan  )    )
  assertNil   ( cmatrix(2,2):geti0(-1    )    )
  assertNil   ( cmatrix(2,2):geti0( 4    )    )
  assertEquals( matrix({1,2}):geti0(0.1  ), matrix({1,2}):geti0( 0) )
  assertEquals( matrix({1,2}):geti0(1-eps), matrix({1,2}):geti0( 0) ) -- 4th interation err

  for nr=1,5 do
  for nc=1,5 do
    m  =  matrix(nr,nc):fill(1..(nr*nc))
    cm = cmatrix(nr,nc):fill(1..(nr*nc)):fill(\x x+x*1i)
    for i=1,nr*nc do assertEquals( m :geti0(i-1), i            ) end
    for i=1,nr*nc do assertEquals( cm:geti0(i-1), complex(i,i) ) end
  end end
end

function TestMatrix:testGeti()
local msg, m, cm = {
    "attempt to compare nil with number",
    }
  assertErrorMsgContains( msg[1], mth, 'geti', matrix(2,2), nil )
  assertNil   (  matrix(2,2):geti( nan  )    )
  assertNil   (  matrix(2,2):geti( 0    )    )
  assertEquals(  matrix(2,2):geti( 1    ), 0 )
  assertNil   (  matrix(2,2):geti( 1-eps)    )
  assertEquals(  matrix(2,2):geti( 4    ), 0 )
  assertEquals(  matrix(2,2):geti( 4+eps), 0 )
  assertNil   (  matrix(2,2):geti( 5    )    )
  assertNil   (  matrix(2,2):geti( 5-eps)    )
  assertNil   ( cmatrix(2,2):geti( nan  )    )
  assertNil   ( cmatrix(2,2):geti( 0    )    )
  assertNil   ( cmatrix(2,2):geti( 5    )    )
  assertEquals( matrix({1,2}):geti( 1.1 ), matrix({1,2}):geti( 1) )

  for nr=1,5 do
  for nc=1,5 do
    m  =  matrix(nr,nc):fill(1..(nr*nc))
    cm = cmatrix(nr,nc):fill(1..(nr*nc)):fill(\x x+x*1i)
    for i=1,nr*nc do assertEquals( m :geti(i), i            ) end
    for i=1,nr*nc do assertEquals( cm:geti(i), complex(i,i) ) end
  end end
end

function TestMatrix:testGet0()
  local msg, m, cm = {
    "attempt to compare nil with number",
    }
  assertErrorMsgContains( msg[1], mth, 'get0', matrix(2,2), 0  , nil )
  assertErrorMsgContains( msg[1], mth, 'get0', matrix(2,2), nil, 0   )
  assertNil   (  matrix(2,2):get0( nan  , 0)    )
  assertNil   (  matrix(2,2):get0(-1    , 0)    )
  assertEquals(  matrix(2,2):get0( 0    , 0), 0 )
  assertNil   (  matrix(2,2):get0( 0-eps, 0)    )
  assertEquals(  matrix(2,2):get0( 1    , 1), 0 )
  assertEquals(  matrix(2,2):get0( 1+eps, 1), 0 )
  assertNil   (  matrix(2,2):get0( 2    , 2)    )
  assertNil   (  matrix(2,2):get0( 2-eps, 2)    )
  assertNil   ( cmatrix(2,2):get0( nan  , 0)    )
  assertNil   ( cmatrix(2,2):get0(-1    , 0)    )
  assertNil   ( cmatrix(2,2):get0( 2    , 0)    )

  for nr=1,5 do
  for nc=1,5 do
    m  =  matrix(nr,nc):fill(1..(nr*nc))
    cm = cmatrix(nr,nc):fill(1..(nr*nc)):fill(\x x+x*1i)
    for i=1,nr do for j=1,nc do
      assertEquals( m :get0(i-1,j-1), (i-1)*nc+j )
      assertEquals( cm:get0(i-1,j-1), complex((i-1)*nc+j,(i-1)*nc+j) )
    end end
  end end
end

function TestMatrix:testGet()
  local msg, m, cm = {
    "attempt to compare nil with number",
    }
  assertErrorMsgContains( msg[1], mth, 'get0', matrix(2,2), 1  , nil )
  assertErrorMsgContains( msg[1], mth, 'get0', matrix(2,2), nil, 1   )
  assertNil   (  matrix(2,2):get( nan  , 1)    )
  assertNil   (  matrix(2,2):get(-1    , 0)    )
  assertEquals(  matrix(2,2):get( 1    , 1), 0 )
  assertNil   (  matrix(2,2):get( 1-eps, 1)    )
  assertEquals(  matrix(2,2):get( 2    , 2), 0 )
  assertEquals(  matrix(2,2):get( 2+eps, 2), 0 )
  assertNil   (  matrix(2,2):get( 3    , 3)    )
  assertNil   (  matrix(2,2):get( 3-eps, 3)    )
  assertNil   ( cmatrix(2,2):get( nan  , 1)    )
  assertNil   ( cmatrix(2,2):get( 0    , 0)    )
  assertNil   ( cmatrix(2,2):get( 3    , 0)    )

  for nr=1,5 do
  for nc=1,5 do
    m  =  matrix(nr,nc):fill(1..(nr*nc))
    cm = cmatrix(nr,nc):fill(1..(nr*nc)):fill(\x x+x*1i)
    for i=1,nr do for j=1,nc do
      assertEquals( m :get(i,j), (i-1)*nc + j )
      assertEquals( cm:get(i,j), complex((i-1)*nc+j,(i-1)*nc+j) )
    end end
  end end
end

function TestMatrix:testSeti0() -- add extra test, used in fill()
  local msg, m, cm = {
    "0-index out of bounds",
    "attempt to compare nil with number",
    }
  assertErrorMsgContains( msg[1], mth, 'seti0', matrix(2,2), nan  , 1 )
  assertErrorMsgContains( msg[2], mth, 'seti0', matrix(2,2), nil  , 1 )
  assertErrorMsgContains( msg[1], mth, 'seti0', matrix(2,2),-1    , 1 )
  assertErrorMsgContains( msg[1], mth, 'seti0', matrix(2,2),-eps  , 1 )
  assertErrorMsgContains( msg[1], mth, 'seti0', matrix(2,2), 5    , 1 )
  assertErrorMsgContains( msg[1], mth, 'seti0', matrix(2,2), 5-eps, 1 )

  for nr=1,5 do
  for nc=1,5 do
    m  =  matrix(nr,nc)
    cm = cmatrix(nr,nc)
    for i=1,nr*nc do
      m:seti0((i-1), i)
      assertEquals( m:geti0(i-1), i )
      cm:seti0((i-1), complex(i,i))
      assertEquals( cm:geti0(i-1), complex(i,i) )
    end
  end end
end

function TestMatrix:testSeti()
  local msg, m, cm = {
    "1-index out of bounds",
    "attempt to compare nil with number",
    }
  assertErrorMsgContains( msg[1], mth, 'seti', matrix(2,2), 0   , 1 )
  assertErrorMsgContains( msg[1], mth, 'seti', matrix(2,2), 0.1 , 1 )
  assertErrorMsgContains( msg[1], mth, 'seti', matrix(2,2),-1   , 1 )
  assertErrorMsgContains( msg[1], mth, 'seti', matrix(2,2), inf , 1 )
  assertErrorMsgContains( msg[1], mth, 'seti', matrix(2,2), nan , 1 )
  assertErrorMsgContains( msg[2], mth, 'seti', matrix(2,2), nil , 1 )

  for nr=1,5 do
  for nc=1,5 do
    m  =  matrix(nr,nc)
    cm = cmatrix(nr,nc)
    for i=1,nr*nc do
      m :seti((i), i)
      cm:seti((i), complex(i,i))
      assertEquals( m :geti0(i-1), i            )
      assertEquals( cm:geti0(i-1), complex(i,i) )
    end
  end end
end

function TestMatrix:testSet0()
  local msg, m, cm, mRef, cmRef = {
    "0-index out of bounds",
    "attempt to compare nil with number",
    }
  assertErrorMsgContains( msg[1], mth, 'set0', matrix(2,2), nan , 1, 1 )
  assertErrorMsgContains( msg[2], mth, 'set0', matrix(2,2), nil , 1, 1 )
  assertErrorMsgContains( msg[1], mth, 'set0', matrix(2,2),-1   , 1, 1 )
  assertErrorMsgContains( msg[1], mth, 'set0', matrix(2,2), 3   , 1, 1 )

  for nr=1,5 do
  for nc=1,5 do
    m  =  matrix(nr,nc)
    cm = cmatrix(nr,nc)
    mRef  =  matrix(nr,nc):fill(1..(nr*nc))
    cmRef = cmatrix(nr,nc):fill(1..(nr*nc)):fill(\x x+x*1i)
    for i=1,nr do for j=1,nc do
      m :set0(i-1,j-1, (i-1)*nc+j )
      cm:set0(i-1,j-1, complex((i-1)*nc+j,(i-1)*nc+j))
      assertEquals( m :get0(i-1,j-1), mRef :get0(i-1,j-1) )
      assertEquals( cm:get0(i-1,j-1), cmRef:get0(i-1,j-1) )
    end end
  end end
end

function TestMatrix:testSet()
  local msg, m, cm, mRef, cmRef = {
    "1-index out of bounds",
    "attempt to compare nil with number",
    }
  assertErrorMsgContains( msg[1], mth, 'set', matrix(2,2), 0   , 1, 1 )
  assertErrorMsgContains( msg[1], mth, 'set', matrix(2,2), 0.1 , 1, 1 )
  assertErrorMsgContains( msg[1], mth, 'set', matrix(2,2),-1   , 1, 1 )
  assertErrorMsgContains( msg[1], mth, 'set', matrix(2,2), inf , 1, 1 )
  assertErrorMsgContains( msg[1], mth, 'set', matrix(2,2), nan , 1, 1 )
  assertErrorMsgContains( msg[2], mth, 'set', matrix(2,2), nil , 1, 1 )

  for nr=1,5 do
  for nc=1,5 do
    m     =  matrix(nr,nc)
    cm    = cmatrix(nr,nc)
    mRef  =  matrix(nr,nc):fill(1..(nr*nc))
    cmRef = cmatrix(nr,nc):fill(1..(nr*nc)):fill(\x x+x*1i)
    for i=1,nr do for j=1,nc do
      m :set(i, j, (i-1)*nc+j)
      cm:set(i, j, complex((i-1)*nc+j,(i-1)*nc+j))
      assertEquals( m :get0(i-1,j-1), mRef :get0(i-1,j-1) )
      assertEquals( cm:get0(i-1,j-1), cmRef:get0(i-1,j-1) )
    end end
  end end
end

function TestMatrix:testLinspace() --TODO
  local nrng = {
          { 1 , 10, 100}, { 1, 10, 100}   , { 10, 1 , 10}, { 1,-10, 10},
          { 10,-1 , 100}, {-1, 10, 100}   , {-10, 1 , 10}, {-1,-10, 10},
          {-10,-1 , 100},
          }
  local msg, l, nr = {
    "invalid argument #1 (finite scalar expected)"  ,
    "invalid argument #2 (finite scalar expected)"  ,
    "invalid argument #3 (positive number expected)",
    "bad argument #1 to 'ceil' (number expected, got string)",
    "matrix too large",
  }
  assertErrorMsgContains( msg[1], linspace, nil      )
  assertErrorMsgContains( msg[1], linspace, nil, 2   )
  assertErrorMsgContains( msg[1], linspace, '' , 2   )
  assertErrorMsgContains( msg[1], linspace, nan, 2   )
  assertErrorMsgContains( msg[1], linspace, inf, 2   )
  assertErrorMsgContains( msg[1], linspace,-inf, 2   )
  assertErrorMsgContains( msg[2], linspace, 2  , ''  )
  assertErrorMsgContains( msg[2], linspace, 2  , nan )
  assertErrorMsgContains( msg[2], linspace, 2  , inf )
  assertErrorMsgContains( msg[2], linspace, 2  ,-inf )
  assertErrorMsgContains( msg[3], linspace, 2  , 2  , 0   )
  assertErrorMsgContains( msg[3], linspace, 2  , 2  ,-1   )
  assertErrorMsgContains( msg[4], linspace, 2  , 2  , ''  )
  assertErrorMsgContains( msg[3], linspace, 2  , 2  , nan )
  assertErrorMsgContains( msg[5], linspace, 2  , 2  , inf )
  assertErrorMsgContains( msg[3], linspace, 2  , 2  ,-inf )

  assertTrue  (  is_vector (linspace(1,1))          )
  assertTrue  (  is_cvector(linspace(complex(1,1))) )
  assertEquals(  linspace( 1 )           [1]  , 0   )
  assertEquals(  linspace( 1 )           [100], 1   )
  assertEquals(  linspace( 0 )           [100], 0   )
  assertEquals(  linspace( 0.1 )         [100], 0.1 )
  assertEquals(  linspace( 2, 2, nil)    [1]  , 2   )
  assertEquals(  linspace( 2, 2, nil)    [100], 2   )
  assertEquals( #linspace( 2, 2, nil)         , 100 )
  assertEquals(  linspace( complex(1,1) )[100], complex(1,1) )
  assertEquals(  linspace( complex(1,1) )[1]  , complex(0,0) )

  nr = nrange  ( 0.5, 1 , 1000 )
  l  = linspace( 0.5, 1 , 1000 )
  assertEquals ( l[1]   , nr[1]    )
  assertEquals ( l[1000], nr[1000] )

  for _,v in ipairs(nrng) do
    nr = nrange  ( v[1], v[2], v[3] )
    l  = linspace( v[1], v[2], v[3] )
    for i=1,#nr do
      assertEquals( l[i] - nr[i], 0 )
    end
    nr = nrange  ( v[1], v[2], v[3] )
    l  = linspace( complex(v[1],v[1]), complex(v[2],v[2]), v[3] )
    for i=1,#nr do
      assertAlmostEquals( l[i].re - complex(nr[i],nr[i]).re , 0, eps )
      assertAlmostEquals( l[i].im - complex(nr[i],nr[i]).im , 0, eps )
    end
  end
  for _,v in ipairs(values.num) do
    if v >= 1  and v < 10^8 then
      nr = nrange  ( 1, 10, v)
      l  = linspace( 1, 10, v)
      for i=1,#nr do
        assertEquals( l[i] - nr[i], 0 )
      end
    end
  end
end

function TestMatrix:testLogspace()
  local nlrng =  { { 10^5, 1, 100 }, { 1, 10^5, 100 }, { 1, 10^-5, 100 }, }
  local msg, l, nr = {
    "invalid argument #1 (positive finite number expected)",
    "invalid argument #2 (positive finite number expected)",
    "invalid argument #3 (positive number expected)"       ,
    "bad argument #1 to 'ceil' (number expected, got string)",
    "matrix too large",
    }
  assertErrorMsgContains( msg[1], logspace, 0        )
  assertErrorMsgContains( msg[1], logspace, nil      )
  assertErrorMsgContains( msg[1], logspace, nil, 1   )
  assertErrorMsgContains( msg[1], logspace, '' , 1   )
  assertErrorMsgContains( msg[1], logspace, nan, 2   )
  assertErrorMsgContains( msg[1], logspace, inf, 2   )
  assertErrorMsgContains( msg[1], logspace,-inf, 2   )
  assertErrorMsgContains( msg[2], logspace, 1  , ''  )
  assertErrorMsgContains( msg[2], logspace, 2  , nan )
  assertErrorMsgContains( msg[2], logspace, 2  , inf )
  assertErrorMsgContains( msg[2], logspace, 2  ,-inf )
  assertErrorMsgContains( msg[3], logspace, 2  , 2  ,-1   )
  assertErrorMsgContains( msg[3], logspace, 2  , 2  , 0   )
  assertErrorMsgContains( msg[4], logspace, 2  , 2  , ''  )
  assertErrorMsgContains( msg[3], logspace, 2  , 2  , nan )
  assertErrorMsgContains( msg[5], logspace, 2  , 2  , inf )
  assertErrorMsgContains( msg[3], logspace, 2  , 2  ,-inf )

  assertTrue  (  is_vector (logspace(1,1))          )
  assertTrue  (  is_cvector(logspace(complex(1,1))) )
  assertEquals(  logspace( 1 )           [1]  , 1   )
  assertEquals(  logspace( 1 )           [100], 1   )
  assertEquals(  logspace( 2, 2, nil)    [1]  , 2   )
  assertEquals(  logspace( 2, 2, nil)    [100], 2   )
  assertEquals( #logspace( 2, 2, nil)         , 100 )
  assertAlmostEquals(  logspace( 0.1 )         [100] - 0.1, 0, eps )
  assertAlmostEquals(  logspace( complex(1,1) )[100].re - complex(1,1).re, 0, eps )
  assertAlmostEquals(  logspace( complex(1,1) )[100].im - complex(1,1).im, 0, eps )

  for _,v in ipairs(nlrng) do
    nr = nlogrange  ( v[1], v[2], v[3] )
    l  = logspace( v[1], v[2], v[3] )
    for i=1,#nr do
      assertEquals( l[i] - nr[i], 0 )
    end
  end
  for _,v in ipairs(values.num) do
    if v >= 1  and v < 10^8 then
      nr = nlogrange  ( 1, 10, v)
      l  = logspace( 1, 10, v)
      for i=1,#nr do
        assertEquals( l[i] - nr[i], 0 )
      end
    end
  end
end

function TestMatrix:testSame()
  local m, cm =  matrix(3,3):random(), cmatrix(3,3):random()
  local msg, s = {
    "invalid argument #2 (scalar expected)",
    "invalid argument #1 or #2 (nrow[,ncol] >=1 or table [of tables] expected)",
    }
  assertErrorMsgContains( msg[1], mth, 'same', matrix(2,2), ''      )
  assertErrorMsgContains( msg[1], mth, 'same', matrix(2,2), {}      )
  assertErrorMsgContains( msg[1], mth, 'same', matrix(2,2), 1..2    )
  assertErrorMsgContains( msg[2], mth, 'same', matrix(2,2), 1, ''   )
  assertErrorMsgContains( msg[2], mth, 'same', matrix(2,2), 1, {}   )
  assertErrorMsgContains( msg[2], mth, 'same', matrix(2,2), 1, 1..2 )
  assertErrorMsgContains( msg[2], mth, 'same', matrix(2,2), 1, nan  )
  s = m:same( nan)  assertEquals( s:get(1,1), 0 )
  s = m:same( inf)  assertEquals( s:get(1,1), 0 )
  s = m:same( 0  )  assertEquals( s:get(1,1), 0 )

  for nr=1,5 do
  for nc=1,5 do
    m  =  matrix(nr,nc)
    cm = cmatrix(nr,nc)
    -- no input
    s = cm:same( ) assertFalse( is_matrix(s) ) assertTrue ( is_cmatrix(s) ) assertEquals( {s.nr,s.nc}, {m.nr, m.nc} )
    s =  m:same( ) assertTrue ( is_matrix(s) ) assertFalse( is_cmatrix(s) ) assertEquals( {s.nr,s.nc}, {m.nr, m.nc} )
    for i = 1,nr do for j = 1,nc do  assertEquals( s:get(i,j), 0 ) end end
    -- one arg: e_
    s =  m:same(complex(1,1))
    assertFalse( is_matrix(s) ) assertTrue ( is_cmatrix(s) ) assertEquals( {s.nr,s.nc}, {m.nr,m.nc} )
    s = cm:same(1)
    assertTrue ( is_matrix(s) ) assertFalse( is_cmatrix(s) ) assertEquals( {s.nr,s.nc}, {m.nr,m.nc} )
    for i = 1,nr do for j = 1,nc do  assertEquals( s:get(i,j), 0 ) end end

    -- two arg: nr, nc
    s = cm:same(2,2) assertFalse( is_matrix(s) ) assertTrue ( is_cmatrix(s) ) assertEquals( {s.nr,s.nc}, {2,2} )
    s = cm:same(4,4) assertFalse( is_matrix(s) ) assertTrue ( is_cmatrix(s) ) assertEquals( {s.nr,s.nc}, {4,4} )
    s =  m:same(2,2) assertTrue ( is_matrix(s) ) assertFalse( is_cmatrix(s) ) assertEquals( {s.nr,s.nc}, {2,2} )
    s =  m:same(4,4) assertTrue ( is_matrix(s) ) assertFalse( is_cmatrix(s) ) assertEquals( {s.nr,s.nc}, {4,4} )
    for i = 1,4 do for j = 1,4 do  assertEquals( s:get(i,j), 0 ) end end

    -- three arg: e_, nr, nc
    s = m:same(complex(1,1), 2, 2)
    assertFalse( is_matrix(s) ) assertTrue ( is_cmatrix(s) ) assertEquals( {s.nr,s.nc}, {2,2} )
    s = m:same(complex(1,1), 5, 5)
    assertFalse( is_matrix(s) ) assertTrue ( is_cmatrix(s) ) assertEquals( {s.nr,s.nc}, {5,5} )
    s = cm:same(1, 2, 2)
    assertTrue ( is_matrix(s) ) assertFalse( is_cmatrix(s) ) assertEquals( {s.nr,s.nc}, {2,2} )
    s = cm:same(1, 5, 5)
    assertTrue ( is_matrix(s) ) assertFalse( is_cmatrix(s) ) assertEquals( {s.nr,s.nc}, {5,5} )
  for i = 1,5 do for j = 1,5 do  assertEquals( s:get(i,j), 0 ) end end
  end end
end

-- size, same -----------------------------------------------------------------o

function TestMatrix:testNrow()
  local m, cm , v, cv
  for nr=1,10 do
    v  =  vector(nr)       assertEquals(  v:nrow(), nr )
    cv = cvector(nr)       assertEquals( cv:nrow(), nr )
    for nc=1,10 do
      m  =  matrix(nr,nc)  assertEquals(  m:nrow(), nr )
      cm = cmatrix(nr,nc)  assertEquals( cm:nrow(), nr )
    end
  end
end

function TestMatrix:testNcol()
local m, cm , v, cv
  for nr=1,10 do
    v  =  vector(nr)       assertEquals(  v:ncol(), 1  )
    cv = cvector(nr)       assertEquals( cv:ncol(), 1  )
    for nc=1,10 do
      m  =  matrix(nr,nc)  assertEquals(  m:ncol(), nc )
      cm = cmatrix(nr,nc)  assertEquals( cm:ncol(), nc )
    end
  end
end

function TestMatrix:testSize()
  local m, cm , v, cv
  for nr=1,10 do
    v  =  vector(nr)       assertEquals(  v:size(), nr*1  )
    cv = cvector(nr)       assertEquals( cv:size(), nr*1  )
    for nc=1,10 do
      m  =  matrix(nr,nc)  assertEquals(  m:size(), nr*nc )
      cm = cmatrix(nr,nc)  assertEquals( cm:size(), nr*nc )
    end
  end
end

function TestMatrix:testSizes()
  local m, cm , v, cv
  for nr=1,10 do
    v  =  vector(nr)       assertEquals( { v:sizes()}, {nr,1 } )
    cv = cvector(nr)       assertEquals( {cv:sizes()}, {nr,1 } )
    for nc=1,10 do
      m  =  matrix(nr,nc)  assertEquals( { m:sizes()}, {nr,nc} )
      cm = cmatrix(nr,nc)  assertEquals( {cm:sizes()}, {nr,nc} )
    end
  end
end

function TestMatrix:testTsizes()
  local m, cm , v, cv
  for nr=1,10 do
    v  =  vector(nr)       assertEquals( { v:tsizes()}, {1 ,nr} )
    cv = cvector(nr)       assertEquals( {cv:tsizes()}, {1 ,nr} )
    for nc=1,10 do
      m  =  matrix(nr,nc)  assertEquals( { m:tsizes()}, {nc,nr} )
      cm = cmatrix(nr,nc)  assertEquals( {cm:tsizes()}, {nc,nr} )
    end
  end
end

function TestMatrix:testRandom() --TODO: more tests needed
  local m, cm = matrix(2,2)
  local msg = {
    "invalid argument #2 (callable expected)",
    }
  assertErrorMsgContains( msg[1], mth,'random', m, nan )
  assertErrorMsgContains( msg[1], mth,'random', m, 1   )

  randomseed(2^52)  --randomseed(os.clock()*2^52)
  local oldVal , val = {},{}
  for nr=1,5 do
  for nc=1,5 do
    m  =  matrix(nr,nc):random()
    for i = 1,m:size() do
      val[i] = m:geti(i)
      assertTrue ( val[i] <  1    )
      assertTrue ( val[i] >= 0    )
      assertFalse( val[i] == oldVal[i] )
      oldVal[i] =  val[i]
    end
    cm = cmatrix(nr,nc):random()

    for i = 1,cm:size() do
      val[i] = cm:geti(i)
      assertTrue ( val[i].re <  1 )
      assertTrue ( val[i].re >= 0 )
      assertTrue ( val[i].im <  1 )
      assertTrue ( val[i].im >= 0 )
    end
  end end
end

function TestMatrix:testFill() --add all options
  local msg, m, cm = {
    "invalid argument #2 (scalar, callable or indexable expected)",
    }
  m  =  matrix(3,3)
  cm = cmatrix(3,3)
  assertErrorMsgContains( msg[1], mth,'fill', matrix(2,2), true )
  assertErrorMsgContains( msg[1], mth,'fill', matrix(2,2), nil  )
  for nr=1,5 do
  for nc=1,5 do
    m  =  matrix(nr,nc)
    cm = cmatrix(nr,nc)

    --scalar
    m :fill(nan)          for i=1,m :size() do assertNaN   ( m :geti(i)    ) end
    m :fill(inf)          for i=1,m :size() do assertInf   ( m :geti(i)    ) end
    m :fill(1  )          for i=1,m :size() do assertEquals( m :geti(i), 1 ) end
    m :fill(complex(1,1)) for i=1,m :size() do assertEquals( m :geti(i), 1 ) end
    cm:fill(complex(1,1)) for i=1,cm:size() do assertEquals( cm:geti(i), complex(1,1) ) end

    --generator
    --cmatrix(nr,nc):fill(1..(nr*nc)):fill(\x x+x*1i)

     --2D container (2d tables, matrices, )
    m :fill(1..#m)        for i=1,m :size() do assertEquals( m :geti(i), i  ) end
    cm:fill(1..#m)        for i=1,m :size() do assertEquals( cm:geti(i), complex(i) ) end
    --1D container( 1d vectors, )

   end end
end

function TestMatrix:testCopy()
  local msg, m, mcopy = {
    "invalid argument #1 (matrix with compatible size expected",
  }
  assertErrorMsgContains( msg[1], mth,'copy', matrix(2,2), 1            )
  assertErrorMsgContains( msg[1], mth,'copy', matrix(2,2),  matrix(1,1) )
  assertErrorMsgContains( msg[1], mth,'copy', matrix(2,2), cmatrix(2,2) )

  for nr=1,5 do
  for nc=1,5 do
    m     = matrix(nr,nc):fill(1..(nr*nc))
    mcopy = matrix(nr,nc)
    m:copy(mcopy)
    for i=1,m :size() do assertEquals( m:geti(i), mcopy:geti(i) ) end
  end end
end

function TestCMatrix:testCopy()
  local msg, cm, cmcopy = {
    "invalid argument #1 (matrix with compatible size expected",
  }
  assertErrorMsgContains( msg[1], mth,'copy', cmatrix(2,2), 1            )
  assertErrorMsgContains( msg[1], mth,'copy', cmatrix(2,2), cmatrix(1,1) )
  assertErrorMsgContains( msg[1], mth,'copy', cmatrix(2,2),  matrix(2,2) )

  for nr=1,5 do
  for nc=1,5 do
    cm     = cmatrix(nr,nc):fill(1..(nr*nc)):fill(\x x+x*1i)
    cmcopy = cmatrix(nr,nc)
    cm:copy(cmcopy)
    for i=1,cm :size() do assertEquals( cm:geti(i), cmcopy:geti(i) ) end
  end end
end

function TestMatrix:testZeros()
  local m
  for nr=1,5 do
  for nc=1,5 do
    m = matrix(nr,nc):fill(1..(nr*nc))
    m:zeros()
    for i=1,m :size() do assertEquals( m:geti(i), 0 ) end
  end end
end

function TestCMatrix:testZeros()
  local cm
  for nr=1,5 do
  for nc=1,5 do
    cm = cmatrix(nr,nc):fill(1..(nr*nc)):fill(\x x+x*1i)
    cm:zeros()
    for i=1,cm :size() do assertEquals( cm:geti(i), complex(0,0) ) end
  end end
end

function TestMatrix:testOnes()
  local m, cm
  for nr=1,5 do
  for nc=1,5 do
    m  =  matrix(nr,nc):fill(1..(nr*nc))
    cm = cmatrix(nr,nc):fill(1..(nr*nc)):fill(\x x+x*1i)
    m :ones()
    cm:ones()
    for i=1,m :size() do assertEquals( m :geti(i), 1 ) end
    for i=1,cm:size() do assertEquals( cm:geti(i), complex(1,0) ) end
  end end
end

function TestMatrix:testEye()
  local m, cm
  for nr=1,5 do
  for nc=1,5 do
    m  =  matrix(nr,nc):fill(1..(nr*nc))
    cm = cmatrix(nr,nc):fill(1..(nr*nc)):fill(\x x+x*1i)
    m :eye()
    cm:eye()
    s = { m:sizes() }
    for i=1,s[1] do
    for j=1,s[2] do
      if i==j then assertEquals( m :get(i,j), 1 )
      else         assertEquals( m :get(i,j), 0 ) end
    end end

    s = { cm:sizes() }
    for i=1,s[1] do
    for j=1,s[2] do
      if i==j then assertEquals( cm:get(i,j), complex(1,0) )
      else         assertEquals( cm:get(i,j), complex(0,0) ) end
    end end
  end end
end

function TestMatrix:testSymp() --TODO
  local msg = {
    "invalid argument #1 (2n matrix expected)",}
  assertErrorMsgContains( msg[1], mth,'symp',  vector(2)   )
  assertErrorMsgContains( msg[1], mth,'symp',  matrix(3)   )
  assertErrorMsgContains( msg[1], mth,'symp', cmatrix(3)   )
  assertErrorMsgContains( msg[1], mth,'symp',  matrix(4,3) )
  assertErrorMsgContains( msg[1], mth,'symp', cmatrix(4,3) )

  --print("\n", matrix(8):symp())
end

function TestMatrix:testCirc() --TODO
  local msg = {
    "invalid argument #2 (iterable expected)",}
  assertErrorMsgContains( msg[1], mth,'circ', matrix(2), nil  )
  assertErrorMsgContains( msg[1], mth,'circ', matrix(2), \x x )
  assertErrorMsgContains( msg[1], mth,'circ', matrix(2), 1    )

  local v = vector(2):fill(1)
  --print( matrix(4):circ( v ) )

end

function TestMatrix:testVshape()
  local m, cm, s, cs
  for nr=1,5 do
  for nc=1,5 do
    m  =  matrix(nr,nc):fill(1..(nr*nc))
    cm = cmatrix(nr,nc):fill(1..(nr*nc)):fill(\x x+x*1i)
    s  = m :size()
    cs = cm:size()
    m :vshape()
    cm:vshape()

    assertTrue  ( is_vector (m ) )
    assertTrue  ( is_cvector(cm) )
    assertEquals( {m :sizes()}, {s ,1} )
    assertEquals( {cm:sizes()}, {cs,1} )
    for i=1,s  do assertEquals( m :geti(i), i      ) end
    for i=1,cs do assertEquals( cm:geti(i), i+i*1i ) end
  end end
end

function TestMatrix:testReshape()
  local msg, m, cm, s = {
    "invalid matrix new sizes",
    }
  assertErrorMsgContains( msg[1], mth,'reshape', matrix(2), 3, 3  )

  for nr=1,5  do
  for nc=1,5  do
  for i =1,nr do
  for j =1,nc do
    m  =  matrix(nr,nc):fill(1..(nr*nc))
    cm = cmatrix(nr,nc):fill(1..(nr*nc)):fill(\x x+x*1i)
    cm:reshape(i,j)
    m :reshape(i,j)

    assertEquals( {m :sizes()}, {i,j} )
    assertEquals( {cm:sizes()}, {i,j} )
  end end
  end end
end

function TestMatrix:testGetsub()
  local msg = {
    "invalid argument #2 (iterable expected)", --is_iterable(ir) --has iparis or number
    "invalid argument #3 (iterable expected)", --is_iterable(jc) --has iparis or number
    "invalid argument #4 (iterable expected)", --is_iterable(r ) --has iparis
    "invalid range member '1'"        ,
    "cannot convert 'nil' to 'double'",
    }
  assertErrorMsgContains( msg[1], mth, 'getsub', matrix(2,2), ''  , 0   , 1    )
  assertErrorMsgContains( msg[2], mth, 'getsub', matrix(2,2), 2                )
  assertErrorMsgContains( msg[2], mth, 'getsub', matrix(2,2), 2..1             )
  assertErrorMsgContains( msg[3], mth, 'getsub', matrix(2,2), 0   , 0   , 1    )
  assertErrorMsgContains( msg[3], mth, 'getsub', matrix(2,2), 1..2, 1..2, \x x )
  assertErrorMsgContains( msg[4], mth, 'getsub', matrix(2,2), 1..2, 1..2, 1..4 )

  assertErrorMsgContains( msg[5], mth, 'getsub', matrix(2,2), 0, 0             )
  assertErrorMsgContains( msg[5], mth, 'getsub', matrix(2,2), 3, 1             )
  assertErrorMsgContains( msg[5], mth, 'getsub', matrix(2,2), 0, 1, matrix(1)  )
  assertErrorMsgContains( msg[5], mth, 'getsub', matrix(2,2), 3, 1, matrix(1)  )

-- full on test with every possible option, then use this to test othe get

  -- ir,jc: number, range, table, matrix
  -- ir,jc/y: number/scalar, range, table, matrix
  -- x      in { matrix, cmatrix }
  -- ir, jc in { n, a..b, {}, vector }
  -- rr     in { {}, vector }
  local mth2 = \f,s,... s[f](s,...)

  local x  = { matrix, cmatrix }
  local ir = { n, 1..2, {}, vector }
  local rr = { {}, vector }

  for nr=1,5 do
  for nc=1,5 do
    local m = matrix(nr,nc):fill(1..(nr*nc))

  end end

  local M = matrix(3,3):fill(1..(3*3))
  assertEquals( M:getsub(4 , 1, {}), {} )
  assertEquals( M:getsub(0 , 1, {}), {} )
  assertEquals( M:getsub( 1,1)        , matrix( {1}          ) )
  assertEquals( M:getsub( 1,1)        , matrix( {1}          ) )
  assertEquals( M:getsub( 2,2)        , matrix( {5}          ) )
  assertEquals( M:getsub({1,2}, 2    ), matrix( {2,5}        ) )
  assertEquals( M:getsub({1,2},{2,3} ), matrix({{2,3},{5,6}} ) )
  assertEquals( M:getsub( 1..2, 1..2 ), matrix({{1,2},{4,5}} ) )
  assertEquals( M:getsub( 1, 1..2 )   , matrix({{1,2}}       ) )
  assertEquals( M:getsub( 1..3, 3 )   , matrix( {3,6,9}      ) )

  assertEquals( M:getsub( 1   , 1   , {}       ),  {1}         )
  assertEquals( M:getsub({1,2}, 2   , {}       ),  {2,5}       )
  assertEquals( M:getsub( 1..2, 1..2, {}       ),  {1,2,4,5}   )
  assertEquals( M:getsub( 1   , 2   , vector(1)),  vector({2}) )
  assertEquals( M:getsub( 2   , 1   , vector(1)),  matrix({4}) )
  assertEquals( M:getsub( 2   , 1   , matrix(1)),  matrix({4}) )
  assertEquals( M:getsub( 2   , 1   ,cmatrix(1)), cmatrix({4}) )
  assertEquals( M:getsub( 2   , 1   ,cmatrix(1)), cmatrix({4}) )
  assertEquals( M:getsub( 2   , 1   , matrix(2)),  matrix({{4,0},{0,0}}) )

  assertEquals( M:getsub(linspace(1,3,3), 3)             , matrix( {3,6,9}) )
  assertEquals( M:getsub(linspace(1,2,2),linspace(1,2,2)), matrix({{1,2},{4,5}}) )
  assertEquals( M:getsub(logspace(1,2,2),linspace(1,2,2)), matrix({{1,2},{4,5}}) )
end

--[[
-- conversion -----------------------------------------------------------------o

function TestMatrix:testTosting()
end

function TestMatrix:testTotable()
end

-- getx, setx -----------------------------------------------------------------o

function TestMatrix:testGetv() end
function TestMatrix:testSetv() end
function TestMatrix:testGetdiag() end
function TestMatrix:testSetdiag() end

function TestMatrix:testGetrow() end
function TestMatrix:testSetrow() end

function TestMatrix:testGetcol() end
function TestMatrix:testSetcol() end

function TestMatrix:testGetsub() end
function TestMatrix:testSetsub() end

-- foreach, filter, map, fold, scan -------------------------------------------o

function TestMatrix:testForeach() en
function TestMatrix:testFilter() end
function TestMatrix:testMapat() end
function TestMatrix:testMap() end
function TestMatrix:testMap2() end
function TestMatrix:testMap3() end

function TestMatrix:testFoldl() end
function TestMatrix:testFoldr() end

function TestMatrix:testScanl() end
function TestMatrix:testScanr() end

-- special maps ---------------------------------------------------------------o

function TestMatrix:testCeil () end
function TestMatrix:testFloor() end
function TestMatrix:testFrac () end
function TestMatrix:testTrunc() end
function TestMatrix:testRound() end

function TestMatrix:testAbs  () end
function TestMatrix:testSqrt () end
function TestMatrix:testExp  () end
function TestMatrix:testLog  () end
function TestMatrix:testLog10() end

function TestMatrix:testSin () end
function TestMatrix:testCos () end
function TestMatrix:testTan () end
function TestMatrix:testSinh() end
function TestMatrix:testCosh() end
function TestMatrix:testTanh() end

function TestMatrix:testAsin () end
function TestMatrix:testAcos () end
function TestMatrix:testAtan () end
function TestMatrix:testAsinh() end
function TestMatrix:testAcosh() end
function TestMatrix:testAtanh() end

function TestMatrix:testErf   () end
function TestMatrix:testTgamma() end
function TestMatrix:testLgamma() end

function TestMatrix:testCarg () end
function TestMatrix:testReal () end
function TestMatrix:testImag () end
function TestMatrix:testConj () end
function TestMatrix:testProj () end
function TestMatrix:testRect () end
function TestMatrix:testPolar() end

-- special folds --------------------------------------------------------------o

function TestMatrix:testMin() end
function TestMatrix:testMax() end
function TestMatrix:testSum() end
function TestMatrix:testSumabs() end
function TestMatrix:testSumsqr() end
function TestMatrix:testProduct() end
function TestMatrix:testAll() end
function TestMatrix:testAny() end

-- conjugate, transpose -------------------------------------------------------o

function TestMatrix:testTranspose() end
function TestCMatrix:testTranspose() end

function TestMatrix:testTrace() end

-- symplectic matrix ----------------------------------------------------------o

function TestMatrix:testSympinv() end
function TestCMatrix:testSympinv() end

function TestMatrix:testSymperr() end
function TestCMatrix:testSymperr() end

-- inner, cross, mixed, outer -------------------------------------------------o

function TestMatrix:testInner() end
function TestCMatrix:testInner() end

function TestMatrix:testCross() end
function TestMatrix:testMixed() end
function TestMatrix:testOuter() end

-- norm, unit, center, angle (in place) ---------------------------------------o

function TestMatrix:testNorm() end
function TestCMatrix:testNorm() end

function TestMatrix:testDistance() end
function TestCMatrix:testDistance() end

function TestMatrix:testUnit() end
function TestCMatrix:testUnit() end

function TestMatrix:testCenter() end
function TestCMatrix:testCenter() end

function TestMatrix:testAngle() end

-- operators ------------------------------------------------------------------o

function TestMatrix:testEq() end

function TestMatrix:testAddCPx() end
function TestMatrix:testAdd() end
function TestCMatrix:testAddCPx() end
function TestCMatrix:testAdd() end

function TestMatrix:testSubCPx() end
function TestMatrix:testSub() end
function TestCMatrix:testSubCPx() end
function TestCMatrix:testSub() end

function TestMatrix:testMulCPx() end
function TestMatrix:testMul() end
function TestCMatrix:testMulCPx() end
function TestCMatrix:testMul() end

function TestMatrix:testTmul() end
function TestCMatrix:testTmul() end

function TestMatrix:testDivCPx() end
function TestMatrix:testDiv() end
function TestCMatrix:testDivCPx() end
function TestCMatrix:testDiv() end

function TestMatrix:testEmul() end
function TestCMatrix:testEmul() end
function TestMatrix:testEdiv() end
function TestCMatrix:testEdiv() end

-- linear algebra -------------------------------------------------------------o

function TestMatrix:testSolve() end
function TestMatrix:testSvd() end
function TestCMatrix:testSvd() end

function TestMatrix:testEigen() end
function TestCMatrix:testEigen() end

-- FFT, convolution, correlation, covrariance ---------------------------------o

function TestMatrix:testFft() end
function TestMatrix:testIfft() end
function TestMatrix:testRfft() end
function TestMatrix:testIrfft() end

 -- convolution theorem
function TestMatrix:testConv() end
function TestCMatrix:testConv() end

 -- correlation theorem
function TestMatrix:testCorr() end
function TestCMatrix:testCorr() end
function TestMatrix:testCovar() end

-- concatenation --------------------------------------------------------------o

function TestMatrix:testConcat() end
]]

-- end ------------------------------------------------------------------------o
