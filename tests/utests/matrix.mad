--[=[
 o-----------------------------------------------------------------------------o
 |
 | Matrix module regression tests - real matrices
 |
 | Methodical Accelerator Design - Copyright CERN 2015+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: A.Z. Teska, aleksandra.teska at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide regression test suites for the matrix module.

 o-----------------------------------------------------------------------------o
]=]

local assertEquals, assertAlmostEquals, assertInf, assertFalse, assertNotEquals,
      assertErrorMsgContains, assertNil, assertNaN, assertIsString, assertTrue
      in require 'luaunit'

local vector, cvector, matrix, cmatrix, is_vector, is_matrix, is_cvector,
      is_cmatrix, isa_vector, isa_matrix, linspace, logspace in MAD

local complex, range, nrange, nlogrange,infi, tiny, eps, huge, inf, nan, pi, Pi,
      sqrt, abs, log, exp, min, randomseed, floor, round,
      sin, cos, tan, sinh, cosh, tanh, asin, acos, atan, asinh, acosh, atanh,
      totable, is_complex, is_cdata, is_table, is_nil, is_string in MAD

-- locals ---------------------------------------------------------------------o

local dat    = require 'matrix_rotdat'
local fftdat = require 'matrix_fftdat'
local lindat = require 'matrix_lindat'

local mth = \f,s,... s[f](s,...)
local ref = \i,j,nc ( (i-1)*nc+j )

local values = {
  num = { tiny, 2^-64, 2^-63, 2^-53, eps, 2^-52, 2*eps, 2^-32, 2^-31, 1e-9,
          0.1-eps, 0.1, 0.1+eps, 0.5, 0.7-eps, 0.7, 0.7+eps, 1-eps, 1, 1+eps,
          1.1, 1.7, 2, 10, 1e2, 1e3, 1e6, 1e9, 2^31, 2^32, 2^52, 2^53,
          2^63, 2^64, huge },
}

local errMat = matrix(2)

local G = {}
G.mat   = {}
G.size  = {}
G.res   = {}
G.vi    = {}
G.vj    = {}

for nr=1,5 do
  G.vi[nr] = vector(nr):fill(1..nr)
  G.vj[nr] = vector(nr):fill(1..nr)
  for nc=1,5 do
    G.mat  [ref(nr,nc,5)] = matrix(nr,nc):fill(1..nr*nc)
    G.res  [ref(nr,nc,5)] = matrix(nr,nc)
    G.size [ref(nr,nc,5)] = {nr,nc}
  end
end

randomseed( os.clock() )

-- regression test suites -----------------------------------------------------o

TestMatrix    = {}
TestMatrixErr = {}

TestMatrixGet = {}
TestMatrixSet = {}

TestMatrixInPlace   = {}
TestMatrixInPlaceII = {}
TestMatrixFun       = {}

TestMatrixSMapsI  = {}
TestMatrixSMapsII = {}
TestMatrixSFolds  = {}
TestMatrixSScans  = {}

TestMatrixSympl  = {}
TestMatrixLinAlg = {}
TestMatrixOps    = {}
TestMatrixLapack = {}
TestMatrixFFT    = {}
TestMatrixRot    = {}
TestMatrixConv   = {}

function TestMatrixErr:testCtor()
  local msg = {
  "invalid argument #1 or #2 (nrow[,ncol] >=1 or table [of tables] expected)",
   "matrix too large",
  }
  assertErrorMsgContains( msg[1], matrix, ''     )
  assertErrorMsgContains( msg[1], matrix, nil    )
  assertErrorMsgContains( msg[1], matrix, 0      )
  assertErrorMsgContains( msg[1], matrix, tiny   )
  assertErrorMsgContains( msg[1], matrix, eps    )
  assertErrorMsgContains( msg[1], matrix, 1..2   )
  assertErrorMsgContains( msg[1], matrix, infi   )
  assertErrorMsgContains( msg[1], matrix, nan    )
  assertErrorMsgContains( msg[1], matrix,-1      )
  assertErrorMsgContains( msg[1], matrix,-eps    )
  assertErrorMsgContains( msg[2], matrix, inf    )
  assertErrorMsgContains( msg[2], matrix, huge   )
  assertErrorMsgContains( msg[2], matrix, 2^15+1 )
  assertErrorMsgContains( msg[2], vector, 2^30+1 )
end

function TestMatrix:testCtor()
  local nr, nc
  --assertTrue( is_matrix( vector(2^30)) )
  --assertTrue( is_matrix( matrix(2^15)) )
  for i,m in ipairs(G.mat) do
    nr, nc = m:sizes()
    assertTrue  ( is_matrix(m) )
    if nc==1 then
      assertTrue  ( is_vector(m) )
      assertEquals( nc, 1 )
    else
    assertEquals( nr, G.size[i][1] )
    assertEquals( nc, G.size[i][2] )
    end
  end
end

function TestMatrixErr:testCtorFromtable()
  local msg = {
  "invalid argument #1 (non-empty table expected)",
  "cannot convert 'string' to 'double'"           ,
  "cannot convert 'string' to 'complex'"          ,
  }
  assertErrorMsgContains( msg[1],  matrix, {nil} )
  assertErrorMsgContains( msg[2],  matrix, {''}  )
end

function TestMatrix:testCtorFromtable() --TODO
  assertTrue  ( is_matrix( matrix{2} ) )
  assertTrue  ( is_vector( matrix{2} ) )
  assertTrue  ( is_matrix ( matrix{complex(0,0)} ) )
  assertEquals( matrix{complex(0,0)},  matrix(1) ) -- complex/real matrix
  assertEquals( matrix{complex(0,0)}, cmatrix(1) )
end

function TestMatrix:testCdataType()
  local m, v = matrix(2), vector(2)
  assertTrue ( is_matrix ( m ) )
  assertTrue ( is_matrix ( v ) )
  assertFalse( is_vector ( m ) )
  assertTrue ( is_vector ( v ) )
  assertFalse( is_cmatrix( m ) )
  assertFalse( is_cmatrix( v ) )
  assertFalse( is_cvector( m ) )
  assertFalse( is_cvector( v ) )
  assertFalse( isa_vector( m ) )
  assertTrue ( isa_vector( v ) )
  assertTrue ( isa_matrix( m ) )
  assertTrue ( isa_matrix( v ) )
end

function TestMatrixErr:testLinspace()
  local msg = {
    "invalid argument #1 (finite scalar expected)"  ,
    "invalid argument #2 (finite scalar expected)"  ,
    "invalid argument #3 (positive number expected)",
    "bad argument #1 to 'ceil'"                     ,
    "matrix too large"                              ,
  }
  assertErrorMsgContains( msg[1], linspace, nil       )
  assertErrorMsgContains( msg[1], linspace, nil, 2    )
  assertErrorMsgContains( msg[1], linspace, '' , 2    )
  assertErrorMsgContains( msg[1], linspace, nan, 2    )
  assertErrorMsgContains( msg[1], linspace, inf, 2    )
  assertErrorMsgContains( msg[1], linspace,-inf, 2    )
  assertErrorMsgContains( msg[2], linspace, 2  , ''   )
  assertErrorMsgContains( msg[2], linspace, 2  , 1..2 )
  assertErrorMsgContains( msg[2], linspace, 2  , nan  )
  assertErrorMsgContains( msg[2], linspace, 2  , inf  )
  assertErrorMsgContains( msg[2], linspace, 2  ,-inf  )
  assertErrorMsgContains( msg[2], linspace, 2  , 1..2 )
  assertErrorMsgContains( msg[3], linspace, 2  , 2  , 0    )
  assertErrorMsgContains( msg[3], linspace, 2  , 2  ,-1    )
  assertErrorMsgContains( msg[3], linspace, 2  , 2  , nan  )
  assertErrorMsgContains( msg[5], linspace, 2  , 2  , inf  )
  assertErrorMsgContains( msg[3], linspace, 2  , 2  ,-inf  )
  assertErrorMsgContains( msg[4], linspace, 2  , 2  , ''   )
  assertErrorMsgContains( msg[4], linspace, 2  , 2  , 1..2 )
end

function TestMatrix:testLinspace()
  local nrng, l, nr = {
        { 1 , 10, 100}, { 1, 10, 100}, { 10, 1 , 10}, { 1,-10, 10},
        { 10,-1 , 100}, {-1, 10, 100}, {-10, 1 , 10}, {-1,-10, 10},
        {-10,-1 , 100},
        }
  assertTrue  (  is_vector (linspace(1,1))          )
  assertTrue  (  is_cvector(linspace(complex(1,1))) )
  assertEquals(  linspace( 1 )           [1]  , 0   )
  assertEquals(  linspace( 1 )           [100], 1   )
  assertEquals(  linspace( 2, 2, nil)    [1]  , 2   )
  assertEquals(  linspace( 2, 2, nil)    [100], 2   )
  assertEquals( #linspace( 2, 2, nil)         , 100 )
  assertEquals(  linspace( complex(1,1) )[100], complex(1,1) )
  assertEquals(  linspace( complex(1,1) )[1]  , complex(0,0) )
  nr = nrange  ( 0.5, 1 , 1000 )
  l  = linspace( 0.5, 1 , 1000 )
  assertEquals ( l[1]   , nr[1]    )
  assertEquals ( l[1000], nr[1000] )

  for _,v in ipairs(nrng) do
    nr = nrange  ( v[1], v[2], v[3] )
    l  = linspace( v[1], v[2], v[3] )
    for i=1,#nr do
      assertEquals( l[i] - nr[i], 0 )
    end
    nr = nrange  ( v[1], v[2], v[3] )
    l  = linspace( complex(v[1],v[1]), complex(v[2],v[2]), v[3] )
    for i=1,#nr do
      assertAlmostEquals( l[i].re - complex(nr[i],nr[i]).re , 0, eps )
      assertAlmostEquals( l[i].im - complex(nr[i],nr[i]).im , 0, eps )
    end
  end
end

function TestMatrixErr:testLogspace()
  local msg = {
    "invalid argument #1 (positive finite number expected)",
    "invalid argument #2 (positive finite number expected)",
    "invalid argument #3 (positive number expected)"       ,
    "bad argument #1 to 'ceil'"                            ,
  }
  assertErrorMsgContains( msg[1], logspace, 0          )
  assertErrorMsgContains( msg[1], logspace, nil        )
  assertErrorMsgContains( msg[1], logspace, nil , 1    )
  assertErrorMsgContains( msg[1], logspace, ''  , 1    )
  assertErrorMsgContains( msg[1], logspace, 1..2, 2    )
  assertErrorMsgContains( msg[1], logspace, nan , 2    )
  assertErrorMsgContains( msg[1], logspace, inf , 2    )
  assertErrorMsgContains( msg[1], logspace,-inf , 2    )
  assertErrorMsgContains( msg[2], logspace, 1   , ''   )
  assertErrorMsgContains( msg[2], logspace, 2   , 1..2 )
  assertErrorMsgContains( msg[2], logspace, 2   , nan  )
  assertErrorMsgContains( msg[2], logspace, 2   , inf  )
  assertErrorMsgContains( msg[2], logspace, 2   ,-inf  )
  assertErrorMsgContains( msg[3], logspace, 2   , 2  ,-1    )
  assertErrorMsgContains( msg[3], logspace, 2   , 2  , 0    )
  assertErrorMsgContains( msg[3], logspace, 2   , 2  , nan  )
  assertErrorMsgContains( msg[3], logspace, 2   , 2  ,-inf  )
  assertErrorMsgContains( msg[4], logspace, 2   , 2  , ''   )
  assertErrorMsgContains( msg[4], logspace, 2   , 2  , 1..2 )
end

function TestMatrix:testLogspace()
  local nlrng, nr, l =  { { 10^5, 1, 100 }, { 1, 10^5, 100 }, { 1, 10^-5, 100 }, }
  assertTrue  ( is_vector (logspace(1,1))          )
  assertTrue  ( is_cvector(logspace(complex(1,1))) )
  assertEquals( logspace( 1 )           [1]  , 1   )
  assertEquals( logspace( 1 )           [100], 1   )
  assertEquals( logspace( 2, 2, nil)    [1]  , 2   )
  assertEquals( logspace( 2, 2, nil)    [100], 2   )
  assertEquals(#logspace( 2, 2, nil)         , 100 )
  assertAlmostEquals( logspace( 0.1 )         [100] - 0.1, 0, eps )
  assertAlmostEquals( logspace( complex(1,1) )[100].re - complex(1,1).re, 0, eps )
  assertAlmostEquals( logspace( complex(1,1) )[100].im - complex(1,1).im, 0, eps )

  for _,v in ipairs(nlrng) do
    nr = nlogrange  ( v[1], v[2], v[3] )
    l  = logspace( v[1], v[2], v[3] )
    for i=1,#nr do
      assertEquals( l[i] - nr[i], 0 )
    end
    nr = nrange  ( v[1], v[2], v[3] )
    l  = linspace( complex(v[1],v[1]), complex(v[2],v[2]), v[3] )
    for i=1,#nr do
      assertAlmostEquals( l[i].re - complex(nr[i],nr[i]).re , 0, eps )
      assertAlmostEquals( l[i].im - complex(nr[i],nr[i]).im , 0, eps )
    end
  end
end

-- get, set -------------------------------------------------------------------o

function TestMatrixSet:setUp()
  self.mat   = {}
  self.empty = {}
  for nr=1,5 do
  for nc=1,5 do
    self.mat  [ref(nr,nc,5)] = matrix(nr,nc):fill(1..nr*nc)
    self.empty[ref(nr,nc,5)] = matrix(nr,nc)
  end end
end

function TestMatrixErr:testGeti0()
    local msg = {
    "attempt to compare nil with number",
    }
  assertErrorMsgContains( msg[1], mth, 'geti0', errMat, nil )
end

function TestMatrixGet:testGeti0()
  for _,m in ipairs(G.mat) do
    for i=1,m:size() do assertEquals( m:geti0(i-1), i ) end
  end
end

function TestMatrixErr:testGeti()
  local msg = {
    "attempt to compare nil with number",
  }
  assertErrorMsgContains( msg[1], mth, 'geti', errMat, nil )
end

function TestMatrixGet:testGeti()
  for _,m in ipairs(G.mat) do
    for i=1,m:size() do assertEquals( m:geti(i), i ) end
  end
end

function TestMatrixErr:testGet0()
  local msg = {
    "attempt to compare nil with number",
  }
  assertErrorMsgContains( msg[1], mth, 'get0', errMat, 0  , nil )
  assertErrorMsgContains( msg[1], mth, 'get0', errMat, nil, 0   )
end

function TestMatrixGet:testGet0()
  local nr, nc
  for _,m in ipairs(G.mat) do
    nr, nc = m:sizes()
    for i=1,nr do
    for j=1,nc do
      assertEquals( m:get0(i-1,j-1), ref(i,j,nc) )
    end end
  end
end

function TestMatrixErr:testGet()
  local msg = {
    "attempt to compare nil with number",
  }
  assertErrorMsgContains( msg[1], mth, 'get0', errMat, 1  , nil )
  assertErrorMsgContains( msg[1], mth, 'get0', errMat, nil, 1   )
end

function TestMatrixGet:testGet()
  local nr, nc
  for _,m in ipairs(G.mat) do
    nr, nc = m:sizes()
    for i=1,nr do
    for j=1,nc do
      assertEquals( m:get(i,j), ref(i,j,nc) )
    end end
  end
end

function TestMatrixErr:testSeti0()
  local msg = {
    "0-index out of bounds"             ,
    "attempt to compare nil with number",
  }
  assertErrorMsgContains( msg[1], mth, 'seti0', errMat, nan  , 1 )
  assertErrorMsgContains( msg[1], mth, 'seti0', errMat,-1    , 1 )
  assertErrorMsgContains( msg[1], mth, 'seti0', errMat,-eps  , 1 )
  assertErrorMsgContains( msg[1], mth, 'seti0', errMat, 4    , 1 )
  assertErrorMsgContains( msg[2], mth, 'seti0', errMat, nil  , 1 )
end

function TestMatrixSet:testSeti0()
  for _,m in ipairs(self.empty) do
    for i=1,m:size() do
      m:seti0((i-1), i)
      assertEquals( m:geti0(i-1), i )
    end
  end
end

function TestMatrixErr:testSeti()
  local msg = {
    "1-index out of bounds"             ,
    "attempt to compare nil with number",
  }
  assertErrorMsgContains( msg[1], mth, 'seti', errMat, nan  , 1 )
  assertErrorMsgContains( msg[1], mth, 'seti', errMat, 0    , 1 )
  assertErrorMsgContains( msg[1], mth, 'seti', errMat, 1-eps, 1 )
  assertErrorMsgContains( msg[1], mth, 'seti', errMat, 5    , 1 )
  assertErrorMsgContains( msg[2], mth, 'seti', errMat, nil  , 1 )
end

function TestMatrixSet:testSeti()
  for _,m in ipairs(self.empty) do
    for i=1,m:size() do
      m:seti((i), i)
      assertEquals( m:geti(i), i )
    end
  end
end

function TestMatrixErr:testSet0()
  local msg = {
    "0-index out of bounds"             ,
    "attempt to compare nil with number",
  }
  assertErrorMsgContains( msg[1], mth, 'set0', errMat, nan  , 1    , 1 )
  assertErrorMsgContains( msg[1], mth, 'set0', errMat,-1    , 0    , 1 )
  assertErrorMsgContains( msg[1], mth, 'set0', errMat,-1+eps, 0    , 1 )
  assertErrorMsgContains( msg[1], mth, 'set0', errMat, 0    ,-1+eps, 1 )
  assertErrorMsgContains( msg[1], mth, 'set0', errMat, 2    , 1    , 1 )
  assertErrorMsgContains( msg[1], mth, 'set0', errMat, 1    , 2    , 1 )
  assertErrorMsgContains( msg[2], mth, 'set0', errMat, nil  , 1    , 1 )
  assertErrorMsgContains( msg[2], mth, 'set0', errMat, 1    , nil  , 1 )
end

function TestMatrixSet:testSet0()
  local nr, nc
  for _,m in ipairs(self.empty) do
    nr, nc = m:sizes()
    for i=1,nr do
    for j=1,nc do
      m:set0(i-1,j-1, ref(i,j,nc) )
      assertEquals( m:get0(i-1,j-1), ref(i,j,nc) )
    end end
  end
end

function TestMatrixErr:testSet()
  local msg = {
    "1-index out of bounds"             ,
    "attempt to compare nil with number",
  }
  assertErrorMsgContains( msg[1], mth, 'set', errMat, nan  , 1    , 1 )
  assertErrorMsgContains( msg[1], mth, 'set', errMat, 0    , 1    , 1 )
  assertErrorMsgContains( msg[1], mth, 'set', errMat, 1    , 0    , 1 )
  assertErrorMsgContains( msg[1], mth, 'set', errMat, 1-eps, 1    , 1 )
  assertErrorMsgContains( msg[1], mth, 'set', errMat, 1    , 1-eps, 1 )
  assertErrorMsgContains( msg[2], mth, 'set', errMat, nil  , 1    , 1 )
end

function TestMatrixSet:testSet()
  local nr, nc
  for _,m in ipairs(self.empty) do
    nr, nc = m:sizes()
    for i=1,nr do
    for j=1,nc do
      m:set(i, j, ref(i,j,nc) )
      assertEquals( m:get(i,j), ref(i,j,nc) )
    end end
  end
end

function TestMatrixErr:testSame()
  local msg, s = {
    "invalid argument #1 or #2 (nrow[,ncol] >=1 or table [of tables] expected)",
    "invalid argument #1 (non-empty table expected)"                           ,
    "invalid argument #2 (nil or scalar expected)"                             ,
  }
  assertErrorMsgContains( msg[1], mth, 'same', errMat, 1   , ''   )
  assertErrorMsgContains( msg[1], mth, 'same', errMat, 1   , 1..2 )
  assertErrorMsgContains( msg[1], mth, 'same', errMat, 1   , nan  )
  assertErrorMsgContains( msg[2], mth, 'same', errMat, 1   , {}   )
  assertErrorMsgContains( msg[3], mth, 'same', errMat, ''  , 2, 2 )
  assertErrorMsgContains( msg[3], mth, 'same', errMat, 1..2, 2, 2 )
end

function TestMatrixSet:testSame()
  local s
  s = errMat:same( nan)          assertEquals( s:get(1,1), 0 )
  s = errMat:same( inf)          assertEquals( s:get(1,1), 0 )
  s = errMat:same( 0  )          assertEquals( s:get(1,1), 0 )

  for _,m in ipairs(G.mat) do
    -- no input
    s = m:same()    assertEquals( s, matrix(m:sizes()) )
    -- two arg: nr, nc
    s = m:same(2  ,2  ) assertEquals( s, matrix(2) )
    s = m:same(6  ,6  ) assertEquals( s, matrix(6) )
    s = m:same(nil,2,2) assertEquals( s, matrix(2) )
    -- three arg: e_, nr, nc
    s = m:same(complex(1,1), 2, 2) assertEquals( {s:sizes()}, {2,2} ) assertFalse( is_matrix(s) )
    s = m:same(1, 2, 2)            assertEquals( {s:sizes()}, {2,2} ) assertTrue ( is_matrix(s) )
  end
end

-- getx, setx -----------------------------------------------------------------o

function TestMatrixErr:testGetsub()
  local msg = {
    "invalid argument #2 (iterable expected)"                                  ,
    "invalid argument #3 (iterable expected)"                                  ,
    "invalid argument #4 (iterable expected)"                                  ,
    "invalid range member '1'"                                                 ,
    "cannot convert 'nil' to 'double'"                                         ,
    "invalid argument #1 or #2 (nrow[,ncol] >=1 or table [of tables] expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'getsub', errMat, nil          )
  assertErrorMsgContains( msg[1], mth, 'getsub', errMat, ''           )
  assertErrorMsgContains( msg[1], mth, 'getsub', errMat, \x x         )
  assertErrorMsgContains( msg[1], mth, 'getsub', errMat, complex(1,1) )
  assertErrorMsgContains( msg[2], mth, 'getsub', errMat, 1   , nil    )
  assertErrorMsgContains( msg[2], mth, 'getsub', errMat, 1   , ''     )
  assertErrorMsgContains( msg[2], mth, 'getsub', errMat, 1   , \x x   )
  assertErrorMsgContains( msg[3], mth, 'getsub', errMat, 0   , 0   , 1    )
  assertErrorMsgContains( msg[3], mth, 'getsub', errMat, 1   , 1   , \x x )
  assertErrorMsgContains( msg[4], mth, 'getsub', errMat, 1   , 1   , 1..4 )
  assertErrorMsgContains( msg[5], mth, 'getsub', errMat, 0   , 0      )
  assertErrorMsgContains( msg[5], mth, 'getsub', errMat, 0   , 1      )
  assertErrorMsgContains( msg[5], mth, 'getsub', errMat, 1   , 0      )
  assertErrorMsgContains( msg[5], mth, 'getsub', errMat, 3   , 1      )
  assertErrorMsgContains( msg[5], mth, 'getsub', errMat, 1   , 3      )
  assertErrorMsgContains( msg[5], mth, 'getsub', errMat, {0}      , 1 )
  assertErrorMsgContains( msg[5], mth, 'getsub', errMat, vector(1), 1 )
  assertErrorMsgContains( msg[6], mth, 'getsub', errMat, 2..1     , 1 )
end

function TestMatrixGet:testGetsub()
  local nr, nc, r
  local m = G.mat[25]
  r = m:getsub( 2   , 2    )  assertEquals( r:get(1,1), m:get(2,2))
  r = m:getsub( 2   , 2, {})  assertEquals( r[1], m:get(2,2))
  r = m:getsub( 2   , 2, vector(2) )
  assertEquals( r:get(1,1), m:get(2,2) )
  assertEquals( r:get(2,1), 0          )

  r = m:getsub( 1..2, 1..3)   nr, nc = r:sizes()
  for i=1,nr do for j=1,nc do assertEquals(r:get(i,j), m:get(i, j)) end end
  r = m:getsub({1}  ,{1,2})   nr, nc = r:sizes()
  for i=1,nr do for j=1,nc do assertEquals(r:get(i,j), ref(i,j,nc)) end end

  for _,m in ipairs(G.mat) do    -- 25 (all shapes over 5x5)
    local nr, nc = m:sizes()
    for li=1,nr do               -- 625 (all sub-shapes over 5x5)
    for lj=1,nc do
      local vi, vj = G.vi[li], G.vj[lj]
      vi:perm(); vj:perm()
      local r = m:getsub(vi, vj)
      for i=1,li do
      for j=1,lj do
        assertEquals(r:get(i,j), m:get(vi[i], vj[j]))
      end end
    end end
  end
end

function TestMatrixErr:testSetsub()
  local msg = {
    "invalid argument #2 (iterable expected)"          ,
    "invalid argument #3 (iterable expected)"          ,
    "invalid argument #4 (scalar or iterable expected)",
    "1-index out of bounds"                            ,
    "cannot convert 'nil' to 'double'"                 ,
  }
  assertErrorMsgContains( msg[1], mth, 'setsub', errMat, nil , 1  , 1  )
  assertErrorMsgContains( msg[1], mth, 'setsub', errMat, ''  , 1  , 1  )
  assertErrorMsgContains( msg[1], mth, 'setsub', errMat, NaN , 1  , 1  )
  assertErrorMsgContains( msg[1], mth, 'setsub', errMat, \x x, 1  , 1  )
  assertErrorMsgContains( msg[2], mth, 'setsub', errMat, 1             )
  assertErrorMsgContains( msg[2], mth, 'setsub', errMat, 1   , nil, 1  )
  assertErrorMsgContains( msg[2], mth, 'setsub', errMat, 1   , '' , 1  )
  assertErrorMsgContains( msg[2], mth, 'setsub', errMat, 1   , NaN, 1  )
  assertErrorMsgContains( msg[3], mth, 'setsub', errMat, 1   , 1 , nil )
  assertErrorMsgContains( msg[3], mth, 'setsub', errMat, 1   , 1 , ''  )
  assertErrorMsgContains( msg[3], mth, 'setsub', errMat, 1   , 1 , NaN )
  assertErrorMsgContains( msg[4], mth, 'setsub', errMat, 0   , 1 , 1   )
  assertErrorMsgContains( msg[4], mth, 'setsub', errMat, 1   , 0 , 1   )
  assertErrorMsgContains( msg[5], mth, 'setsub', errMat, 1..2, 1..2, 1..3 )
  assertErrorMsgContains( msg[5], mth, 'setsub', errMat, 1..2, 1..2, {1}  )
  assertErrorMsgContains( msg[1], mth, 'setsub', errMat, complex(1,1), 1 , 1 )
  assertErrorMsgContains( msg[2], mth, 'setsub', errMat, 1 , complex(1,1), 1 )
end

function TestMatrixSet:testSetsub()
  local mt = matrix(5)
  mt:setsub( 1..5, 1, {1,1,1,1,1})
  for i=1,5 do
  for j=1,5 do
    if j==1 then assertEquals( mt:get(i,j), 1 )
            else assertEquals( mt:get(i,j), 0 ) end
  end end
  mt:setsub( 1..5, 1, 1..5)
  for i=1,5 do
  for j=1,5 do
    if j==1 then assertEquals( mt:get(i,j), i )
            else assertEquals( mt:get(i,j), 0 ) end
  end end
  mt:setsub( 1..5, 1..5, 1)
  for i=1,25 do assertEquals( mt:geti(i), 1 ) end

  for i,m in ipairs(self.mat) do
    local nr, nc = m:sizes()
    for li=1,nr do
    for lj=1,nc do
      local vi, vj = G.vi[li], G.vj[lj]
      vi:perm(); vj:perm()
      mt = m:getsub(vi, vj)
      m:setsub(vi,vj,1..#vi*#vj)
      local r = m:getsub(vi, vj)
      for i=1,li do
      for j=1,lj do
        assertEquals(r:get(i,j), ref(i,j,lj))
      end end
      m:setsub(vi,vj,mt)
    end end
  end
end

function TestMatrixErr:testGetv()
  local msg = {
    "invalid argument #2 (iterable expected)",
    "invalid argument #3 (iterable expected)",
    "cannot convert 'nil' to 'double"        ,
    "invalid range member '1'"               ,
  }
  assertErrorMsgContains( msg[1], mth, 'getv', errMat, nil )
  assertErrorMsgContains( msg[1], mth, 'getv', errMat, ''  )
  assertErrorMsgContains( msg[1], mth, 'getv', errMat, NaN )
  assertErrorMsgContains( msg[2], mth, 'getv', errMat, 1  , ''   )
  assertErrorMsgContains( msg[2], mth, 'getv', errMat, 1  , 1    )
  assertErrorMsgContains( msg[2], mth, 'getv', errMat, 1  , \x x )
  assertErrorMsgContains( msg[3], mth, 'getv', errMat, 0         )
  assertErrorMsgContains( msg[3], mth, 'getv', errMat, matrix(2) )
  assertErrorMsgContains( msg[4], mth, 'getv', errMat, 1  , 1..2 )
end

function TestMatrixGet:testGetv()
  local m1 = matrix(4):fill(1..16)
  assertEquals( m1:getv(1   , {} )      , {1}                  )
  assertEquals( m1:getv(1   , vector(2)), vector{1,0}          )
  assertEquals( m1:getv(1..2)           , vector(2):fill(1..2) )
  assertEquals( m1:getv{1,2}            , vector(2):fill(1..2) )

  for _,m in ipairs(G.mat) do
    local nr, nc = m:sizes()
    for j=1,m:size() do
      assertEquals( m:getv(j), vector{j} )
    end
    for li=1,nr do
      local vi = G.vi[li]:copy()
      for j=1,li do vi[j] = math.random(1,nc*nr) end
      vi:perm()
      assertEquals( m:getv(vi), vector(#vi):fill(vi) )
    end
  end
  m1:getv(1..5,'in') assertEquals( m1, matrix(4):fill(1..16) ) -- same output - to documentation
end

function TestMatrixErr:testSetv()
  local msg = {
    "invalid argument #2 (iterable expected)"          ,
    "invalid argument #3 (scalar or iterable expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'setv', errMat, nil , 0    )
  assertErrorMsgContains( msg[1], mth, 'setv', errMat, ''  , 0    )
  assertErrorMsgContains( msg[1], mth, 'setv', errMat, NaN , 0    )
  assertErrorMsgContains( msg[1], mth, 'setv', errMat, \x x, 0    )
  assertErrorMsgContains( msg[2], mth, 'setv', errMat, 1   , ''   )
  assertErrorMsgContains( msg[2], mth, 'setv', errMat, 1   , nil  )
  assertErrorMsgContains( msg[2], mth, 'setv', errMat, 1   , NaN  )
  assertErrorMsgContains( msg[2], mth, 'setv', errMat, 1   , \x x )
end

function TestMatrixSet:testSetv()
  local mt = self.empty[25]
  mt:setv(1..5, 1)           for i=1,5 do assertEquals( mt:getv(1..5):geti(i), 1 ) end
  mt:setv(1..5, 1..5)        for i=1,5 do assertEquals( mt:getv(1..5):geti(i), i ) end
  mt:setv(1..5, {0,0,0,0,0}) for i=1,5 do assertEquals( mt:getv(1..5):geti(i), 0 ) end

  for _,m in ipairs(self.empty) do
    local nr, nc = m:sizes()
    for j=1,m:size() do
      m:setv(j,j)
      assertEquals( m:getv(j), vector{j} )
    end
    for li=1,nr do
      local vi = G.vi[li]
      vi:perm()
      local mt = m:getv(vi)
      m:setv(vi,1..li)
      assertEquals( m:getv(vi), vector(li):fill(1..li) )
      m:setv(vi,mt)
    end
  end
end

function TestMatrixErr:testGetdiag()
  local msg = {
    "invalid argument #2 (iterable expected)",
    "invalid range member '1'"               ,
  }
  assertErrorMsgContains( msg[1], mth, 'getdiag', errMat, ''   )
  assertErrorMsgContains( msg[1], mth, 'getdiag', errMat, \x x )
  assertErrorMsgContains( msg[1], mth, 'getdiag', errMat, 1    )
  assertErrorMsgContains( msg[2], mth, 'getdiag', errMat, 1..2 )
end

function TestMatrixGet:testGetdiag()
  for _,m in ipairs(G.mat) do
    local nr, nc = m:sizes()
    local n , d  = min(nr,nc), m:getdiag()
    assertEquals( {d:sizes()}, {n,1} )
    for i=1,n do assertEquals( d[i], m:get(i,i) ) end
    assertEquals( m:getdiag({}), totable(d) )
  end
end

function TestMatrixErr:testSetdiag()
  local msg = {
    "invalid argument #2 (scalar or iterable expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'setdiag', errMat, nil  )
  assertErrorMsgContains( msg[1], mth, 'setdiag', errMat, ''   )
  assertErrorMsgContains( msg[1], mth, 'setdiag', errMat, \x x )
end

function TestMatrixSet:testSetdiag()
  for _,m in ipairs(self.empty) do
    local nr, nc = m:sizes()
    local n = min(nr,nc)
    for i=1,n do
      local ra = 1..i
      m:setdiag(ra)
      local d = m:getdiag()
      assertEquals( {m:getdiag():sizes()}, {n,1} )
      for i=1,n do assertEquals( m:getdiag()[i], m:get(i,i) ) end
    end
  end
end

function TestMatrixErr:testGetrow()
  local msg = {
    "invalid argument #2 (iterable expected)",
    "invalid argument #3 (iterable expected)",
    "cannot convert 'nil' to 'double'"       ,
    "invalid range member '1'"               ,
    "1-index out of bounds"                  ,
  }
  assertErrorMsgContains( msg[1], mth, 'getrow', errMat, ''         )
  assertErrorMsgContains( msg[1], mth, 'getrow', errMat, nil        )
  assertErrorMsgContains( msg[1], mth, 'getrow', errMat, NaN        )
  assertErrorMsgContains( msg[1], mth, 'getrow', errMat, \x x       )
  assertErrorMsgContains( msg[2], mth, 'getrow', errMat, 1   , ''   )
  assertErrorMsgContains( msg[2], mth, 'getrow', errMat, 1   , 1    )
  assertErrorMsgContains( msg[3], mth, 'getrow', errMat, 0          )
  assertErrorMsgContains( msg[3], mth, 'getrow', errMat, 5          )
  assertErrorMsgContains( msg[4], mth, 'getrow', errMat, 1   , 1..2 )
  assertErrorMsgContains( msg[5], mth, 'getrow', errMat, 1   , vector(1) )
end

function TestMatrixGet:testGetrow()
  local m = G.mat[25]
  assertEquals( m:getrow{1,2}            , m:getsub({1,2},1..5   ) )
  assertEquals( m:getrow(vector{1,2})    , m:getsub({1,2},1..5   ) )
  assertEquals( m:getrow(vector{1,2}, {}), m:getsub({1,2},1..5,{}) )

  for _,m in ipairs(G.mat) do
    local nr, nc = m:sizes()
    for i=1,nr do
    for a=1,i  do
      for li=1,i-a+1 do
        local ra = a..i..li
        assertEquals( m:getrow(ra), m:getsub(ra,1..nc) )
      end
    end end
  end
end

function TestMatrixErr:testSetrow()
  local m = matrix(3)
  local msg = {
    "invalid argument #2 (iterable expected)"          ,
    "invalid argument #3 (scalar or iterable expected)",
    "1-index out of bounds"                            ,
    "cannot convert 'nil' to 'double'"                 ,
  }
  assertErrorMsgContains( msg[1], mth, 'setrow', errMat, ''         )
  assertErrorMsgContains( msg[1], mth, 'setrow', errMat, nil        )
  assertErrorMsgContains( msg[1], mth, 'setrow', errMat, NaN        )
  assertErrorMsgContains( msg[1], mth, 'setrow', errMat, \x x       )
  assertErrorMsgContains( msg[2], mth, 'setrow', errMat, 1   , nil  )
  assertErrorMsgContains( msg[2], mth, 'setrow', errMat, 1   , ''   )
  assertErrorMsgContains( msg[3], mth, 'setrow', errMat, 0   , 1    )
  assertErrorMsgContains( msg[3], mth, 'setrow', errMat, 3   , 1    )
  assertErrorMsgContains( msg[4], mth, 'setrow', m     , 1   ,1..2  )
  assertErrorMsgContains( msg[4], mth, 'setrow', m     , 1   ,{1,2} )
  assertErrorMsgContains( msg[4], mth, 'setrow', errMat, 1   , matrix(1) )
end

function TestMatrixSet:testSetrow()
  local mt = self.empty[25]
  mt:setrow(1, 1)           for i=1,5 do assertEquals( mt:getrow(1):geti(i), 1 ) end
  mt:setrow(1, 1..5)        for i=1,5 do assertEquals( mt:getrow(1):geti(i), i ) end
  mt:setrow(1, {0,0,0,0,0}) for i=1,5 do assertEquals( mt:getrow(1):geti(i), 0 ) end

  for _,m in ipairs(self.empty) do
    local nr, nc = m:sizes()
    for i=1,nr do
    for a=1,i  do
      for li=1,i-a+1 do
        local ra = a..i..li
        local r = 1..nc*#ra
        m:setrow(ra,r)
        for ii=1,#ra do
        for jj=1,nc  do
          assertEquals( m:getrow(ra):get(ii,jj), ref(ii,jj,nc) )
        end end
        m:setrow(ra,0)
      end
    end end
  end
end

function TestMatrixErr:testGetcol()
  local msg = {
    "invalid argument #2 (iterable expected)",
    "invalid argument #3 (iterable expected)",
    "cannot convert 'nil' to 'double'"       ,
    "invalid range member '1'"               ,
    "1-index out of bounds"                  ,
  }
  assertErrorMsgContains( msg[1], mth, 'getcol', errMat, ''   )
  assertErrorMsgContains( msg[1], mth, 'getcol', errMat, nil  )
  assertErrorMsgContains( msg[1], mth, 'getcol', errMat, NaN  )
  assertErrorMsgContains( msg[1], mth, 'getcol', errMat, \x x )
  assertErrorMsgContains( msg[2], mth, 'getcol', errMat, 1   , ''   )
  assertErrorMsgContains( msg[2], mth, 'getcol', errMat, 1   , 1    )
  assertErrorMsgContains( msg[3], mth, 'getcol', errMat, 0          )
  assertErrorMsgContains( msg[3], mth, 'getcol', errMat, 3          )
  assertErrorMsgContains( msg[4], mth, 'getcol', errMat, 1   , 1..2 )
  assertErrorMsgContains( msg[5], mth, 'getcol', errMat, 1   , vector(1) )
end

function TestMatrixGet:testGetcol()
  local m = G.mat[25]
  assertEquals( m:getcol{1,2}            , m:getsub(1..5,{1,2}   ) )
  assertEquals( m:getcol(vector{1,2})    , m:getsub(1..5,{1,2}   ) )
  --print( m:getcol(vector{1,2}, {}), m:getsub(1..5,{1,2},{}) ) -- not the same output, check

  for _,m in ipairs(G.mat) do
    local nr, nc = m:sizes()
    for j=1,nc do
    for b=1,j  do
      for lj = 1,j-b+1 do
        local rb = b..j..lj
        assertEquals( m:getcol(rb) , m:getsub(1..nr,rb) )
      end
    end end
  end
end

function TestMatrixErr:testSetcol()
  local m = matrix(3)
  local msg = {
    "invalid argument #2 (iterable expected)"          ,
    "invalid argument #3 (scalar or iterable expected)",
    "1-index out of bounds"                            ,
    "cannot convert 'nil' to 'double'"                 ,
  }
  assertErrorMsgContains( msg[1], mth, 'setcol', errMat, ''         )
  assertErrorMsgContains( msg[1], mth, 'setcol', errMat, nil        )
  assertErrorMsgContains( msg[1], mth, 'setcol', errMat, NaN        )
  assertErrorMsgContains( msg[1], mth, 'setcol', errMat, \x x       )
  assertErrorMsgContains( msg[2], mth, 'setcol', errMat, 1   ,  ''  )
  assertErrorMsgContains( msg[2], mth, 'setcol', errMat, 1   ,  nil )
  assertErrorMsgContains( msg[3], mth, 'setcol', errMat, 0   ,  1   )
  assertErrorMsgContains( msg[3], mth, 'setcol', errMat, 3   ,  1   )
  assertErrorMsgContains( msg[4], mth, 'setcol', errMat, 1   ,  matrix(1) )
  assertErrorMsgContains( msg[4], mth, 'setcol', m     , 1,  1..2  )
  assertErrorMsgContains( msg[4], mth, 'setcol', m     , 1,  {1,2} )
end

function TestMatrixSet:testSetcol()
  local mt = self.empty[25]
  mt:setcol(1, 1)           for i=1,5 do assertEquals( mt:getcol(1):geti(i), 1 ) end
  mt:setcol(1, 1..5)        for i=1,5 do assertEquals( mt:getcol(1):geti(i), i ) end
  mt:setcol(1, {0,0,0,0,0}) for i=1,5 do assertEquals( mt:getcol(1):geti(i), 0 ) end

  for _,m in ipairs(self.empty) do
    local nr, nc = m:sizes()
    for j=1,nc do
    for b=1,j  do
      for lj = 1,j-b+1 do
        local rb = b..j..lj
        local r = 1..nr*#rb
        m:setcol(rb,r)
        for ii=1,nr  do
        for jj=1,#rb do
          assertEquals( m:getcol(rb):get(ii,jj), ref(jj,ii,nr) )
        end end
        m:setcol(rb,0)
      end
    end end
  end
end

-- size, same -----------------------------------------------------------------o

function TestMatrix:testNrow()
  for i,m in ipairs(G.mat) do
    assertEquals( m:nrow(), G.size[i][1] )
  end
end

function TestMatrix:testNcol()
  for i,m in ipairs(G.mat) do
    assertEquals( m:ncol(), G.size[i][2] )
  end
end

function TestMatrix:testSize()
  for i,m in ipairs(G.mat) do
    assertEquals( m:size(), G.size[i][1]*G.size[i][2] )
  end
end

function TestMatrix:testSizes()
  for i,m in ipairs(G.mat) do
    assertEquals( {m:sizes()}, G.size[i] )
  end
end

function TestMatrix:testTsizes()
  for i,m in ipairs(G.mat) do
    assertEquals( {m:tsizes()}, {G.size[i][2], G.size[i][1]} )
  end
end

-- in place -------------------------------------------------------------------o

function TestMatrixInPlace:setUp()
  self.mat   = {}
  for nr=1,5 do
  for nc=1,5 do
    self.mat[ref(nr,nc,5)] = matrix(nr,nc):fill(1..nr*nc)
  end end
end

function TestMatrixErr:testRandom()
  local msg, s = {
    "invalid argument #1 or #2 (nrow[,ncol] >=1 or table [of tables] expected)",
    "invalid argument #1 (non-empty table expected)"                           ,
  }
  assertErrorMsgContains( msg[1], mth, 'same', errMat, 1, ''   )
  assertErrorMsgContains( msg[1], mth, 'same', errMat, 1, 1..2 )
  assertErrorMsgContains( msg[1], mth, 'same', errMat, 1, nan  )
  assertErrorMsgContains( msg[2], mth, 'same', errMat, 1, {}   )
end

function TestMatrixInPlace:testRandom()
  local oldVal, val = {}, {}
  for _,m in ipairs(self.mat) do
    m:random()
    for i = 1,m:size() do
      val[i] = m:geti(i)
      assertTrue ( val[i] <  1    )
      assertTrue ( val[i] >= 0    )
      assertFalse( val[i] == oldVal[i] )
      oldVal[i] =  val[i]
    end
  end
end

function TestMatrixInPlaceII:testPerm()
  local oldV = {}
  local fact = \n => for i=1,n-1 do n=n*i end return n end
  for j=1,5 do
    local v = vector(j):fill(1..j)
    for i=1,fact(j) do
      v = v:perm()
      assertFalse( v == oldV[i] )
      for is=1,v:size() do
        assertTrue( v:geti(is) <= j )
        assertTrue( v:geti(is) >= 1 )
      end
      oldV[i] = v
    end
  end
end

function TestMatrixErr:testFill()
  local msg = {
    "invalid argument #2 (scalar, callable or indexable expected)",
    "incompatible container size"                                 ,
    "invalid container (iterable expected)"                       ,
  }
  assertErrorMsgContains( msg[1], mth,'fill', errMat, nil  )
  assertErrorMsgContains( msg[1], mth,'fill', errMat, true )
  assertErrorMsgContains( msg[2], mth,'fill', errMat, {}   )
end
function TestMatrixInPlace:testFill()
  for _,m in ipairs(self.mat) do
    --scalar
    m:fill(nan)               for i=1,m:size() do assertNaN   ( m:geti(i)      ) end
    m:fill(inf)               for i=1,m:size() do assertInf   ( m:geti(i)      ) end
    m:fill(1  )               for i=1,m:size() do assertEquals( m:geti(i), 1   ) end
    m:fill(complex(1,1))      for i=1,m:size() do assertEquals( m:geti(i), 1   ) end
    --generator
    m:fill(1..#m)             for i=1,m:size() do assertEquals( m:geti(i), i   ) end
    m:fill\x x^2              for i=1,m:size() do assertEquals( m:geti(i), i^2 ) end
    --2D container
    m:fill( m:same() )        for i=1,m:size() do assertEquals( m:geti(i), 0   ) end
    --1D container
    t={} for i=1,m :size() do t[i]=i end
    m:fill(t)                 for i=1,m:size() do assertEquals( m:geti(i), i   ) end
    m:fill(vector(m :size())) for i=1,m:size() do assertEquals( m:geti(i), 0   ) end
  end
  local m, t = matrix(5), {}
  for i=1,5 do t[i] = {}      for j=1,5 do t[i][j]=(i-1)*5+j end end
  m :fill(t)                  for i=1,m :size() do assertEquals( m :geti(i), i ) end
  assertTrue( is_matrix ( matrix(5,5):fill(complex(1,1))) )  --matrix types change
end

function TestMatrixErr:testCopy()
  local msg = {
    "invalid argument #1 (matrix expected)",
  }
  assertErrorMsgContains( msg[1], mth,'copy', errMat,  1 )
end

function TestMatrixInPlaceII:testCopy()
  for i,m in ipairs(G.mat) do
    local mcopy = matrix(m :sizes() )
    mcopy:copy(m)
    for i=1,m:size() do assertEquals( m:geti(i), mcopy:geti(i) ) end
  end
end

function TestMatrixInPlaceII:testResize()
  for i,m in ipairs(G.mat) do
    local nr,nc = m:sizes()
    for ir=1,5 do
    for ic=1,5 do
      local mres = m:resize( ir,ic )
      local minr, minc = min(nr,ir), min(nc,ic)
      assertEquals( {mres:sizes()}, {ir, ic} )
      for jr=1     ,minr do for jc=1     ,minc do assertEquals( mres:get(jr,jc), m:get(jr,jc) ) end end
      for jr=minr+1,ir   do for jc=minc+1,ic   do assertEquals( mres:get(jr,jc), 0            ) end end

      mres = m:resize( matrix(ir,ic) )
      minr, minc = min(nr,ir), min(nc,ic)
      for jr=1     ,minr do for jc=1     ,minc do assertEquals( mres:get(jr,jc), m:get(jr,jc) ) end end
      for jr=minr+1,ir   do for jc=minc+1,ic   do assertEquals( mres:get(jr,jc), 0            ) end end
    end
    end
  end
end

function TestMatrixInPlace:testZeros()
  for _,m in ipairs(self.mat) do
    local  m1 = m:zeros()
    for i=1,m:size() do assertEquals( m1:geti(i), 0 ) end
  end
end

function TestMatrixInPlace:testOnes()
  for _,m in ipairs(self.mat) do
    m:ones()
    for i=1,m:size() do assertEquals( m:geti(i), 1 ) end
  end
end

function TestMatrixInPlace:testEye()
  for i,m in ipairs(self.mat) do
    local nr, nc = m:sizes()
    m:eye()
    for i=1,nr do
    for j=1,nc do
      if i==j then assertEquals( m:get(i,j), 1 )
      else         assertEquals( m:get(i,j), 0 ) end
    end end
  end
end

function TestMatrixErr:testSymp()
  local msg = {
    "invalid argument #1 (2n matrix expected)",
  }
  assertErrorMsgContains( msg[1], mth,'symp',  matrix(3)   )
  assertErrorMsgContains( msg[1], mth,'symp',  vector(2)   )
  assertErrorMsgContains( msg[1], mth,'symp',  matrix(4,3) )
end

function TestMatrixInPlaceII:testSymp()
  for i=2,6,2 do
    local m = matrix(i):symp()
    assertTrue( m:t() == -m )
    for ii=1,i do
    for jj=1,i do
      if     ii==2 and jj==1 then assertEquals( m:get(ii,jj),-1 )
      elseif ii==4 and jj==3 then assertEquals( m:get(ii,jj),-1 )
      elseif ii==6 and jj==5 then assertEquals( m:get(ii,jj),-1 )
      elseif ii==1 and jj==2 then assertEquals( m:get(ii,jj), 1 )
      elseif ii==3 and jj==4 then assertEquals( m:get(ii,jj), 1 )
      elseif ii==5 and jj==6 then assertEquals( m:get(ii,jj), 1 )
      else                        assertEquals( m:get(ii,jj), 0 ) end
    end end
  end
end

function TestMatrixErr:testCirc()
  local msg = {
    "invalid argument #2 (iterable expected)",
  }
  assertErrorMsgContains( msg[1], mth,'circ', errMat, nil  )
  assertErrorMsgContains( msg[1], mth,'circ', errMat, 1    )
  assertErrorMsgContains( msg[1], mth,'circ', errMat, \x x )
end

function TestMatrixInPlaceII:testCirc()
  for i=1,5 do
    local m = matrix(i)
    local t = {} for j=1,i do t[j]=j end
    --'row'
    m:circ(t)
    for j=1,i   do assertEquals( m:get(j  ,j  ), 1   ) end
    for j=1,i-1 do assertEquals( m:get(j+1,j  ), 2   )
                   assertEquals( m:get(j  ,j+1), i   ) end
    for j=1,i-2 do assertEquals( m:get(j+2,j  ), 3   )
                   assertEquals( m:get(j  ,j+2), i-1 ) end
    for j=1,i-3 do assertEquals( m:get(j+3,j  ), 4   )
                   assertEquals( m:get(j  ,j+3), i-2 ) end
    m:fill(0):circ(vector(i):fill(1..i))
    for j=1,i   do assertEquals( m:get(j  ,j  ), 1   ) end
    for j=1,i-1 do assertEquals( m:get(j+1,j  ), 2   )
                   assertEquals( m:get(j  ,j+1), i   ) end
    for j=1,i-2 do assertEquals( m:get(j+2,j  ), 3   )
                   assertEquals( m:get(j  ,j+2), i-1 ) end
    for j=1,i-3 do assertEquals( m:get(j+3,j  ), 4   )
                   assertEquals( m:get(j  ,j+3), i-2 ) end
    --'col'
    m:fill(0):circ(matrix(1,i):fill(1..i))
    for j=1,i   do assertEquals( m:get(j  ,j  ), 1   ) end
    for j=1,i-1 do assertEquals( m:get(j+1,j  ), i   )
                   assertEquals( m:get(j  ,j+1), 2   ) end
    for j=1,i-2 do assertEquals( m:get(j+2,j  ), i-1 )
                   assertEquals( m:get(j  ,j+2), 3   ) end
    for j=1,i-3 do assertEquals( m:get(j+3,j  ), i-2 )
                   assertEquals( m:get(j  ,j+3), 4   ) end
  end
end

function TestMatrixErr:testReshape()
  local msg = {
    "invalid matrix new sizes",
  }
  assertErrorMsgContains( msg[1], mth,'reshape', errMat, nil, 2 )
  assertErrorMsgContains( msg[1], mth,'reshape', errMat, 0  , 1 )
  assertErrorMsgContains( msg[1], mth,'reshape', errMat, 1  , 0 )
  assertErrorMsgContains( msg[1], mth,'reshape', errMat, 3  , 2 )
  assertErrorMsgContains( msg[1], mth,'reshape', errMat, 1  , 5 )
end

function TestMatrixInPlaceII:testReshape()
  local m
  m = matrix(2,2) assertEquals( {m:reshape() :sizes()}, {4,1} )
  m = matrix(2,2) assertEquals( {m:reshape(1):sizes()}, {1,1} )
  for nr=1,5 do
  for nc=1,5 do
    for i=1,nr do
    for j=1,nc do
      m = matrix(nr,nc):fill(1..nr*nc)
      m:reshape(i,j)
      assertEquals( {m:sizes()}, {i,j} )
      for i=1,m:size() do assertEquals( m:geti(i), i) end
    end end
  end end
end

-- foreach, filter, map, fold, scan -------------------------------------------o

function TestMatrixFun:setUp()
  self.mat = {}
  for nr=1,5 do
  for nc=1,5 do
    self.mat[ref(nr,nc,5)] = matrix(nr,nc):fill(1..nr*nc)
  end end
end

function TestMatrixErr:testForeach()
  local msg = {
    "invalid argument #2 (callable expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'foreach', errMat, nil       )
  assertErrorMsgContains( msg[1], mth, 'foreach', errMat, ''        )
  assertErrorMsgContains( msg[1], mth, 'foreach', errMat, 1         )
  assertErrorMsgContains( msg[1], mth, 'foreach', errMat, 1..2      )
  assertErrorMsgContains( msg[1], mth, 'foreach', errMat, matrix(1) )
  assertErrorMsgContains( msg[1], mth, 'foreach', errMat, { }       )
end

function TestMatrixFun:testForeach()
  local t, nr, nc
  local f = \x,i,j => t[i][j] = x  end
  for _,m in ipairs(self.mat) do
    nr, nc = m:sizes()
    t = table.new(nr, nc)
    for i=0,nr-1 do local c = t[i+1] or table.new(nc,0); t[i+1] = c end
    m:foreach(f)
    for i=1,nr do for j=1,nc do assertEquals( t[i][j], ref(i,j,nc) ) end end
  end
end

function TestMatrixErr:testMap()
  local msg = {
    "invalid argument #2 (callable expected)"                 ,
    "invalid argument #2 (scalar function expected)"          ,
    "invalid argument #3 (iterable expected)"                 ,
    "attempt to perform arithmetic on local 'y' (a nil value)",
    "invalid range member '1'"                                ,
  }
  assertErrorMsgContains( msg[1], mth, 'map', errMat, ''        )
  assertErrorMsgContains( msg[1], mth, 'map', errMat, 1..2      )
  assertErrorMsgContains( msg[1], mth, 'map', errMat, 1         )
  assertErrorMsgContains( msg[1], mth, 'map', errMat, matrix(1) )
  assertErrorMsgContains( msg[1], mth, 'map', errMat, {}        )
  assertErrorMsgContains( msg[2], mth, 'map', errMat, '!'       )
  assertErrorMsgContains( msg[4], mth, 'map', errMat, '+'       )
  assertErrorMsgContains( msg[3], mth, 'map', errMat, \x x+1, ''   )
  assertErrorMsgContains( msg[3], mth, 'map', errMat, \x x+1, 1    )
  assertErrorMsgContains( msg[5], mth, 'map', errMat, \x x+1, 1..2 )
end

function TestMatrixFun:testMap()
  local m1
  for i,m in ipairs(self.mat) do
    m1 = m:map '~'        for i=1,#m1 do assertEquals( m1:geti(i),-i ) end
    m1 = m:map \x x-x     for i=1,#m1 do assertEquals( m1:geti(i), 0 ) end
    --totable test
    m1 = m:map('!'   ,{}) for i=1,#m1 do assertFalse ( m1[i] )    end
    m1 = m:map(\x x-x,{}) for i=1,#m1 do assertEquals( m1[i], 0 ) end
    --'in' place test
    m:map('~'   , 'in')   for i=1,#m  do assertEquals( m :geti(i),-i ) end
    m:map(\x x-x, 'in')   for i=1,#m  do assertEquals( m :geti(i), 0 ) end
  end
end

function TestMatrixErr:testMap2()
  local m = matrix(1)
  local msg = {
    "invalid argument #2 (scalar or iterable expected)"       ,
    "invalid argument #3 (callable expected)"                 ,
    "invalid argument #3 (scalar function expected)"          ,
    "invalid argument #4 (iterable expected)"                 ,
    "invalid range member '1'"                                ,
    "attempt to perform arithmetic on local 'y' (a nil value)",
  }
  assertErrorMsgContains( msg[1], mth, 'map2', errMat, nil  )
  assertErrorMsgContains( msg[1], mth, 'map2', errMat, ''   )
  assertErrorMsgContains( msg[1], mth, 'map2', errMat, NaN  )
  assertErrorMsgContains( msg[1], mth, 'map2', errMat, \x x )
  assertErrorMsgContains( msg[2], mth, 'map2', errMat, m    , nil  )
  assertErrorMsgContains( msg[2], mth, 'map2', errMat, m    , ''   )
  assertErrorMsgContains( msg[2], mth, 'map2', errMat, m    , 1..2 )
  assertErrorMsgContains( msg[2], mth, 'map2', errMat, m    , 1    )
  assertErrorMsgContains( msg[3], mth, 'map2', errMat, m    , '!'  )
  assertErrorMsgContains( msg[4], mth, 'map2', errMat, m    , \x x, 1    )
  assertErrorMsgContains( msg[5], mth, 'map2', errMat, m    , \x x, 1..2 )
  assertErrorMsgContains( msg[6], mth, 'map2', errMat, m    , \x,y  x+y  )
end

function TestMatrixFun:testMap2()
  local mt
  for _,m1 in ipairs(self.mat) do
    mt = m1:same()
    mt = m1:map2(1 , '+'      )     for i=1,#mt do assertEquals( mt:geti(i), i+1 ) end
    mt = m1:map2(1 , \x,y x-y )     for i=1,#mt do assertEquals( mt:geti(i), i-1 ) end
    mt = m1:map2(m1, '~'      )     for i=1,#mt do assertEquals( mt:geti(i),-i   ) end
    mt = m1:map2(m1, '!'     , {})  for i=1,#mt do assertFalse ( mt[i] )      end

    ir = { m1, 1..#m1, totable(1..#m1) }
    for d=1,#ir do
    mt = m1:map2(ir[d], '+'     )   for i=1,#mt do assertEquals( mt:geti(i), i*2 ) end
    mt = m1:map2(ir[d], \x,y x-y)   for i=1,#mt do assertEquals( mt:geti(i), 0   ) end
    --totable test
    mt = m1:map2(ir[d], '<'   , {}) for i=1,#mt do assertFalse ( mt[i] )      end
    mt = m1:map2(ir[d], '-'   , {}) for i=1,#mt do assertEquals( mt[i], 0   ) end
    mt = m1:map2(ir[d], \x x+x, {}) for i=1,#mt do assertEquals( mt[i], i*2 ) end
    end
    --'in' place test
    for d=1,#ir do
      m1:map2(ir[d], '~'  , 'in')   for i=1,#m1 do assertEquals( m1:geti(i), i*(-1)^d ) end
    end
      m1:map2(m1, \x,y x-y, 'in')   for i=1,#m1 do assertEquals( m1:geti(i), 0 )        end
  end
end

function TestMatrixErr:testMap3()
  local m = matrix(1)
  local msg = {
    "invalid argument #2 (scalar or iterable expected)"       ,
    "invalid argument #3 (scalar or iterable expected)"       ,
    "invalid argument #4 (callable expected)"                 ,
    "invalid argument #4 (scalar function expected)"          ,
    "invalid argument #5 (iterable expected)"                 ,
    "invalid range member '1'"                                ,
    "attempt to perform arithmetic on local 'y' (a nil value)",
    "attempt to perform arithmetic on local 'z' (a nil value)",
  }
  assertErrorMsgContains( msg[1], mth, 'map3', errMat, nil  )
  assertErrorMsgContains( msg[1], mth, 'map3', errMat, ''   )
  assertErrorMsgContains( msg[1], mth, 'map3', errMat, NaN  )
  assertErrorMsgContains( msg[1], mth, 'map3', errMat, \x x )
  assertErrorMsgContains( msg[2], mth, 'map3', errMat, errMat, nil  )
  assertErrorMsgContains( msg[2], mth, 'map3', errMat, errMat, ''   )
  assertErrorMsgContains( msg[2], mth, 'map3', errMat, errMat, NaN  )
  assertErrorMsgContains( msg[2], mth, 'map3', errMat, errMat, \x x )
  assertErrorMsgContains( msg[3], mth, 'map3', errMat, errMat, errMat, nil  )
  assertErrorMsgContains( msg[3], mth, 'map3', errMat, errMat, errMat, 1..2 )
  assertErrorMsgContains( msg[3], mth, 'map3', errMat, errMat, errMat, 1    )
  assertErrorMsgContains( msg[4], mth, 'map3', errMat, m     , m     , '!'  )
  assertErrorMsgContains( msg[5], mth, 'map3', errMat, errMat, errMat, \x x, 1    )
  assertErrorMsgContains( msg[6], mth, 'map3', errMat, errMat, errMat, \x x, 1..2 )
  assertErrorMsgContains( msg[7], mth, 'map3', errMat, m     , errMat, \x,y,z x+y+z )
  assertErrorMsgContains( msg[7], mth, 'map3', errMat, m     , m     , \x,y,z x+y+z )
  assertErrorMsgContains( msg[8], mth, 'map3', errMat, errMat, m     , \x,y,z x+y+z )
end

function TestMatrixFun:testMap3()
  local mt
  for _,m1 in ipairs(self.mat) do
    local nr, nc = m1:sizes()
    mt = m1:same()
    mt = m1:map3(m1, m1, '~'          ) for i=1,#mt do assertEquals( mt:geti(i),-i   ) end
    mt = m1:map3(m1, m1, '+'          ) for i=1,#mt do assertEquals( mt:geti(i), i*2 ) end
    mt = m1:map3(m1, m1, \x,y,z x+y+z ) for i=1,#mt do assertEquals( mt:geti(i), i*3 ) end
    mt = m1:map3(m1, m1, '<'      , {}) for i=1,#mt do assertFalse ( mt[i] )      end

    m2 = { m1, 1..#m1, totable(1..#m1) }
    m3 = { m1, 1..#m1, totable(1..#m1) }
    for i=1,#m2 do
    for j=1,#m3 do
      mt = m1:map3(m2[i],m3[j], \x,y,z x+y+z)     for i=1,#mt do assertEquals( mt:geti(i), i*3 ) end
      mt = m1:map3(m2[i],m3[j], \x,y,z x+y+z, {}) for i=1,#mt do assertEquals( mt[i]     , i*3 ) end      --totable test
    end end
    --'in' place test
    m1:map3(m1, m1, '~'         , 'in') for i=1,#m1 do assertEquals( m1:geti(i), -i   ) end
    m1:map3(m1, m1, \x,y,z x+y+z, 'in') for i=1,#m1 do assertEquals( m1:geti(i), -i*3 ) end
  end
end

function TestMatrixErr:testMapij()
  local msg = {
    "invalid argument #2 (callable expected)",
    "invalid argument #3 (iterable expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'mapij', errMat, nil       )
  assertErrorMsgContains( msg[1], mth, 'mapij', errMat, ''        )
  assertErrorMsgContains( msg[1], mth, 'mapij', errMat, 1..2      )
  assertErrorMsgContains( msg[1], mth, 'mapij', errMat, 1         )
  assertErrorMsgContains( msg[1], mth, 'mapij', errMat, matrix(1) )
  assertErrorMsgContains( msg[1], mth, 'mapij', errMat, { }       )
  assertErrorMsgContains( msg[2], mth, 'mapij', errMat, \x x+1  , ''   )
  assertErrorMsgContains( msg[2], mth, 'mapij', errMat, \x x+1  , \x x )
end

function TestMatrixFun:testMapij() --recheck
  local m1
  for i,m in ipairs(self.mat) do
    local nr, nc = m:sizes()
    m1 = m:mapij '~'        for i=1,#m1 do assertEquals( m1:geti(i),-i ) end
    m1 = m:mapij \x x-x     for i=1,#m1 do assertEquals( m1:geti(i), 0 ) end
    m1 = m:mapij \x,i,j i+j
    for i=1,nr do
    for j=1,nc do
      assertEquals( m1:get(i,j), i+j )
    end end
    m1 = m:mapij \x,i,j x+i+j
    for i=1,nr do
    for j=1,nc do
      assertEquals( m1:get(i,j), ref(i,j,nc)+i+j )
    end end
    --totable test
    m1 = m:mapij('!'   ,{}) for i=1,#m1 do assertFalse ( m1[i] )    end
    m1 = m:mapij(\x x-x,{}) for i=1,#m1 do assertEquals( m1[i], 0 ) end
    m1 = m:mapij( \x,i,j => if j>3 then x=3 end return x end, {} )
    for i=1,nr do
    for j=1,nc do
      if j > 3 then assertEquals( m1[ref(i,j,nc)], 3           )
               else assertEquals( m1[ref(i,j,nc)], ref(i,j,nc) ) end
    end end
    --'in' place test
    m:mapij('~'   , 'in')   for i=1,#m  do assertEquals( m :geti(i),-i ) end
    m:mapij(\x x-x, 'in')   for i=1,#m  do assertEquals( m :geti(i), 0 ) end
  end
end

function TestMatrixErr:testMapat()
  local msg = {
    "invalid argument #2 (callable expected)"                 ,
    "invalid argument #3 (iterable expected)"                 ,
    "invalid argument #4 (iterable expected)"                 ,
    "invalid range member '1'"                                ,
    "attempt to perform arithmetic on local 'x' (a nil value)",
    "attempt to perform arithmetic on local 'y' (a nil value)",
  }
  assertErrorMsgContains( msg[1], mth, 'mapat', errMat, nil       )
  assertErrorMsgContains( msg[1], mth, 'mapat', errMat, ''        )
  assertErrorMsgContains( msg[1], mth, 'mapat', errMat, 1..2      )
  assertErrorMsgContains( msg[1], mth, 'mapat', errMat, 1         )
  assertErrorMsgContains( msg[1], mth, 'mapat', errMat, matrix(1) )
  assertErrorMsgContains( msg[1], mth, 'mapat', errMat, { }       )
  assertErrorMsgContains( msg[2], mth, 'mapat', errMat, \x x+1 , ''   )
  assertErrorMsgContains( msg[2], mth, 'mapat', errMat, \x x+1 , nil  )
  assertErrorMsgContains( msg[2], mth, 'mapat', errMat, \x x+1 , NaN  )
  assertErrorMsgContains( msg[2], mth, 'mapat', errMat, \x x+1 , \x x )
  assertErrorMsgContains( msg[3], mth, 'mapat', errMat, \x x+1 , 1    , ''   )
  assertErrorMsgContains( msg[3], mth, 'mapat', errMat, \x x+1 , 1    , \x x )
  assertErrorMsgContains( msg[4], mth, 'mapat', errMat, \x x+1 , 1    , 1..2 )
  assertErrorMsgContains( msg[5], mth, 'mapat', errMat, \x x+1 , 0    )
  assertErrorMsgContains( msg[5], mth, 'mapat', errMat, \x x+1 , 5    )
  assertErrorMsgContains( msg[6], mth, 'mapat', errMat, '+'    , 1    )
end

function TestMatrixFun:testMapat()
  local mt, m
  for _,m in ipairs(self.mat) do
    local nr, nc = m:sizes()
    for j=1,m:size() do
      assertEquals( m:getv(j), vector{j} )
    end
    for li=1,nr do
      local vi = G.vi[li]:copy()
      for j=1,li do vi[j] = math.random(1,nc*nr) end
      vi:perm()
      mt = m:mapat('~',vi)
      assertEquals( mt:getv(vi), vector(#vi):fill(-vi) )
      mt = m:mapat('!',vi)
      assertEquals( mt:getv(vi), vector(#vi):fill(0)   )
    end
  end
  m  = self.mat[5]
  mt = m:mapat('~',vector{1,2,3})
  for i=1,#mt do
    if i<=3 then assertEquals(mt:geti(i),-i )
            else assertEquals(mt:geti(i), i ) end
  end
  mt = m:mapat('~',vector{1,2,3}, {})
  for i=1,#mt do
    if i<=3 then assertEquals(mt[i],-i )
            else assertEquals(mt[i], i ) end
  end
  m:mapat(\x x+1,vector{1,2,3}, 'in')
  for i=1,#m do
    if i<=3 then assertEquals(m:geti(i), i+1 )
            else assertEquals(m:geti(i), i   ) end
  end
end

function TestMatrixErr:testFoldl()
  local msg = {
    "invalid argument #2 (callable expected)"                    ,
    "invalid argument #5 (iterable expected)"                    ,
    "invalid argument #4 (string 'vec', 'row' or 'col' expected)",
    "invalid range member '1'"                                   ,
    "attempt to perform arithmetic on local 'x' (a table value)" ,
  }
  m, cm = matrix(2), cmatrix(2)
  assertErrorMsgContains( msg[1], mth, 'foldl', errMat, nil  )
  assertErrorMsgContains( msg[1], mth, 'foldl', errMat, NaN  )
  assertErrorMsgContains( msg[1], mth, 'foldl', errMat, ''   )
  assertErrorMsgContains( msg[1], mth, 'foldl', errMat, {}   )
  assertErrorMsgContains( msg[1], mth, 'foldl', errMat, 1    )
  assertErrorMsgContains( msg[1], mth, 'foldl', errMat, 1..2 )
  assertErrorMsgContains( msg[1], mth, 'foldl', errMat, m    )
  assertErrorMsgContains( msg[1], mth, 'foldl', errMat, cm   )
  assertErrorMsgContains( msg[3], mth, 'foldl', errMat, \x x, '')
  assertErrorMsgContains( msg[3], mth, 'foldl', errMat, \x x, 1 , {}   , {}   )
  assertErrorMsgContains( msg[3], mth, 'foldl', errMat, \x x, 1 , 1..2 , {}   )
  assertErrorMsgContains( msg[3], mth, 'foldl', errMat, \x x, 1 , m    , {}   )
  assertErrorMsgContains( msg[3], mth, 'foldl', errMat, \x x, 1 , cm   , {}   )
  assertErrorMsgContains( msg[3], mth, 'foldl', errMat, \x x, 1 , ''   , {}   )
  assertErrorMsgContains( msg[2], mth, 'foldl', errMat, \x x, 1 , "vec", ''   )
  assertErrorMsgContains( msg[2], mth, 'foldl', errMat, \x x, 1 , "vec", 1    )
  assertErrorMsgContains( msg[2], mth, 'foldl', errMat, \x x, 1 , "vec", \x x )
  assertErrorMsgContains( msg[5], mth, 'foldl', errMat, '+' , {} )
end
--[[
parameters:
  f: callable, x0: initial value, d: ['vec', 'row', 'col'], r: iterable
  r:{}, cmatrix(2), matrix(2), 1..2

fold cases:
  1) x:fold( f )
  2) x:fold( f, nil, d )      and 2') x:fold( f, d )
  3) x:fold( f, nil, nil, r ) and 3') x:fold( f, r ) and  3") x:fold( f, nil, r)
  4) x:fold( f, nil, d, r )   and 4') x:fold( f, d, r) and  4") x:fold( f, d, nil, r )
  5) x:fold( f, x0 )
  6) x:fold( f, x0 , d )
  7) x:fold( f, x0, nil, r ) and 7') x:fold( f, x0, r )
  8) x:fold( f, x0 , d, r )
]]

local sum = \r =>local x = 0    for i=1,r:size() do x = x + r[i] end return x end
local sub = \r =>local x = r[1] for i=2,r:size() do x = x - r[i] end return x end

function TestMatrixFun:testFoldl()
  local m1, mt
  for _,m in ipairs(self.mat) do
    local nr, nc = m:sizes()
    assertEquals( m:foldl \x x, 1 )                                 -- 1)
    assertEquals( m:foldl('+' , 2  , nil, {}), sum(1..m:size())+2 ) -- 7)
    local mRes = {
      m:foldl '+'                 , -- 1)
      m:foldl('+'     , 'vec')    , -- 2)
      m:foldl('+', nil, 'vec')    , -- 2)
      m:foldl('+'     , 'vec', {}), -- 4)
      m:foldl('+' , 0)            , -- 5)
      m:foldl('+' , 0,  'vec')    , -- 6)
      m:foldl('+' , nil      , {}), -- 3)
      m:foldl('+' , nil, nil , {}), -- 3)
    }
    for j=1,#mRes do assertEquals( mRes[j], sum(1..m:size()) ) end

    local t ={}  for i=1,nc do t [i]=sum(ref(1,i,nc)..ref(nr,i,nc)..nc) end
    local tr={}  for i=1,nr do tr[i]=sum(ref(i,1,nc)..ref(i,nc,nc)..1 ) end
    m1 = m:foldl('+'   , 'col')    for i=1,nc do assertEquals( m1:geti(i), t [i] ) end -- 2)
    m1 = m:foldl('+'   , 'row')    for i=1,nr do assertEquals( m1:geti(i), tr[i] ) end -- 2)
    m1 = m:foldl('+', 0, 'col')    for i=1,nc do assertEquals( m1:geti(i), t [i] ) end -- 6)
    m1 = m:foldl('+', 0, 'row')    for i=1,nr do assertEquals( m1:geti(i), tr[i] ) end -- 6)
    m1 = m:foldl('+', 0, 'col',{}) for i=1,nc do assertEquals( m1[i]     , t [i] ) end -- 8)
    m1 = m:foldl('+', 0, 'row',{}) for i=1,nr do assertEquals( m1[i]     , tr[i] ) end -- 8)

  -- non-commutative operations
    if nr*nc%2 == 0 then assertEquals( m:foldl '~',-1 )
                    else assertEquals( m:foldl '~', 1 ) end
    assertEquals( m:foldl '-', sub(1..m:size()) )
    m1 = m:foldl('-', 'col') for i=1,nc do assertEquals( m1:geti(i), sub(ref(1,i,nc)..ref(nr,i,nc)..nc) ) end
    m1 = m:foldl('-', 'row') for j=1,nr do assertEquals( m1:geti(j), sub(ref(j,1,nc)..ref(j,nc,nc)..1 ) ) end
  end
  assertEquals( vector(4):fill(4..1..-1):foldl '^' , (4^3)^2 )
end

function TestMatrixErr:testFoldr()
  local msg = {
    "invalid argument #2 (callable expected)"                    ,
    "invalid argument #5 (iterable expected)"                    ,
    "invalid argument #4 (string 'vec', 'row' or 'col' expected)",
    "invalid range member '1'"                                   ,
  }
  m, cm = matrix(2), cmatrix(2)
  assertErrorMsgContains( msg[1], mth, 'foldr', errMat, nil  )
  assertErrorMsgContains( msg[1], mth, 'foldr', errMat, NaN  )
  assertErrorMsgContains( msg[1], mth, 'foldr', errMat, ''   )
  assertErrorMsgContains( msg[1], mth, 'foldr', errMat, {}   )
  assertErrorMsgContains( msg[1], mth, 'foldr', errMat, 1    )
  assertErrorMsgContains( msg[1], mth, 'foldr', errMat, 1..2 )
  assertErrorMsgContains( msg[1], mth, 'foldr', errMat, m    )
  assertErrorMsgContains( msg[1], mth, 'foldr', errMat, cm   )
  assertErrorMsgContains( msg[3], mth, 'foldr', errMat, \x x, '')
  assertErrorMsgContains( msg[3], mth, 'foldr', errMat, \x x, 1 , {}   , {}   )
  assertErrorMsgContains( msg[3], mth, 'foldr', errMat, \x x, 1 , 1..2 , {}   )
  assertErrorMsgContains( msg[3], mth, 'foldr', errMat, \x x, 1 , m    , {}   )
  assertErrorMsgContains( msg[3], mth, 'foldr', errMat, \x x, 1 , cm   , {}   )
  assertErrorMsgContains( msg[3], mth, 'foldr', errMat, \x x, 1 , ''   , {}   )
  assertErrorMsgContains( msg[2], mth, 'foldr', errMat, \x x, 1 , "vec", ''   )
  assertErrorMsgContains( msg[2], mth, 'foldr', errMat, \x x, 1 , "vec", 1    )
  assertErrorMsgContains( msg[2], mth, 'foldr', errMat, \x x, 1 , "vec", \x x )
end

function TestMatrixFun:testFoldr()
  local m1, v
  for _,m in ipairs(self.mat) do
    local nr, nc = m:sizes()
    assertEquals( m:foldr \x x, 1 )                                 -- 1)
    assertEquals( m:foldr('+' , 2  , nil, {}), sum(1..m:size())+2 ) -- 7)
    local mRes = {
      m:foldr '+'                 , -- 1)
      m:foldr('+'     , 'vec')    , -- 2)
      m:foldr('+', nil, 'vec')    , -- 2)
      m:foldr('+'     , 'vec', {}), -- 4)
      m:foldr('+' , 0 )           , -- 5)
      m:foldr('+' , 0 , 'vec')    , -- 6)
      m:foldr('+' , nil      , {}), -- 3)
      m:foldr('+' , nil, nil , {}), -- 3)
    }
    for j=1,#mRes do assertEquals( mRes[j], sum(1..m:size()) ) end

    local t ={} for i=1,nc do t [i]=sum(ref(1,i,nc)..ref(nr,i,nc)..nc) end
    local tr={} for i=1,nr do tr[i]=sum(ref(i,1,nc)..ref(i,nc,nc)..1 ) end

    m1 = m:foldr('+'   , 'col')    for i=1,nc do assertEquals( m1:geti(i), t [i] ) end -- 2)
    m1 = m:foldr('+'   , 'row')    for i=1,nr do assertEquals( m1:geti(i), tr[i] ) end -- 2)
    m1 = m:foldr('+', 0, 'col')    for i=1,nc do assertEquals( m1:geti(i), t [i] ) end -- 6)
    m1 = m:foldr('+', 0, 'row')    for i=1,nr do assertEquals( m1:geti(i), tr[i] ) end -- 6)
    m1 = m:foldr('+', 0, 'col',{}) for i=1,nc do assertEquals( m1[i]     , t [i] ) end -- 8)
    m1 = m:foldr('+', 0, 'row',{}) for i=1,nr do assertEquals( m1[i]     , tr[i] ) end -- 8)

  -- non-commutative operations
    if nr*nc == 1 then assertEquals( m:foldr '~', 1 )
                  else assertEquals( m:foldr '~',-1 ) end

    v =  vector( m:size() ):fill(1..m:size()):map(\x => if x%2==0 then x=-x end return x end)
    assertEquals( m:foldr '-', v:foldr('+') )
    m1 = m:foldr('-', 'col')
    for i=1,nc do
      assertEquals( m1:geti(i), sum(ref(1,i,nc)..ref(nr,i,nc)..2*nc) - sum(ref(2,i,nc)..ref(nr,i,nc)..2*nc) )
    end
    m1 = m:foldr('-', 'row')
    for j=1,nr do
      assertEquals( m1:geti(j), sum(ref(j,1,nc)..ref(j,nc,nc)..2 ) - sum(ref(j,2,nc)..ref(j,nc,nc)..2 ) )
    end
  end
  assertEquals( vector(4):fill(4..1..-1):foldr '^', 4^(3^2) )
end

--[[ scan cases:
1) x:scan( f )
2) x:scan( f, nil, d )      and 2') x:scan( f, d )
3) x:scan( f, nil, nil, r ) and 3') x:scan( f, r ) and  3") x:scan( f, nil, r)
4) x:scan( f, nil, d, r )   and 4') x:scan( f, d, r) and  4")x:scan( f, d, nil, r )
5) x:scan( f, x0 )
6) x:scan( f, x0 , d )
7) x:scan( f, x0 , nil, r ) and 7') x:scan( f, x0, r )
8) x:scan( f, x0 , d, r )              ]]

function TestMatrixErr:testScanl()
  local msg = {
    "invalid argument #2 (callable expected)"                    ,
    "invalid argument #5 (iterable expected)"                    ,
    "invalid argument #4 (string 'vec', 'row' or 'col' expected)",
    "invalid range member '1'"                                   ,
  }
  m, cm = matrix(2), cmatrix(2)
  assertErrorMsgContains( msg[1], mth, 'scanl', errMat, nil  )
  assertErrorMsgContains( msg[1], mth, 'scanl', errMat, NaN  )
  assertErrorMsgContains( msg[1], mth, 'scanl', errMat, ''   )
  assertErrorMsgContains( msg[1], mth, 'scanl', errMat, {}   )
  assertErrorMsgContains( msg[1], mth, 'scanl', errMat, 1    )
  assertErrorMsgContains( msg[1], mth, 'scanl', errMat, 1..2 )
  assertErrorMsgContains( msg[1], mth, 'scanl', errMat, m    )
  assertErrorMsgContains( msg[1], mth, 'scanl', errMat, cm   )
  assertErrorMsgContains( msg[3], mth, 'scanl', errMat, \x x, '')
  assertErrorMsgContains( msg[3], mth, 'scanl', errMat, \x x, 1 , {}   , {}   )
  assertErrorMsgContains( msg[3], mth, 'scanl', errMat, \x x, 1 , 1..2 , {}   )
  assertErrorMsgContains( msg[3], mth, 'scanl', errMat, \x x, 1 , m    , {}   )
  assertErrorMsgContains( msg[3], mth, 'scanl', errMat, \x x, 1 , cm   , {}   )
  assertErrorMsgContains( msg[3], mth, 'scanl', errMat, \x x, 1 , ''   , {}   )
  assertErrorMsgContains( msg[2], mth, 'scanl', errMat, \x x, 1 , "vec", ''   )
  assertErrorMsgContains( msg[2], mth, 'scanl', errMat, \x x, 1 , "vec", 1    )
  assertErrorMsgContains( msg[2], mth, 'scanl', errMat, \x x, 1 , "vec", \x x )
end

function TestMatrixFun:testScanl()
  local m1
  for _,m in ipairs(self.mat) do
    local nr, nc = m:sizes()
    m1 = m:scanl \x x                 for i=1,#m1 do assertEquals( m1:geti(i), 1           ) end -- 1)
    m1 = m:scanl '+'                  for i=1,#m1 do assertEquals( m1:geti(i), sum(1..i)   ) end -- 1)
    m1 = m:scanl('+','vec')           for i=1,#m1 do assertEquals( m1:geti(i), sum(1..i)   ) end -- 2)
    m1 = m:scanl('+', 0   )           for i=1,#m1 do assertEquals( m1:geti(i), sum(1..i)   ) end -- 5)
    m1 = m:scanl('+', 0   ,'vec')     for i=1,#m1 do assertEquals( m1:geti(i), sum(1..i)   ) end -- 6)
    m1 = m:scanl('+','vec', {}  )     for i=1,#m1 do assertEquals( m1[i]     , sum(1..i)   ) end -- 4)
    m1 = m:scanl('+', 0   ,'vec', {}) for i=1,#m1 do assertEquals( m1[i]     , sum(1..i)   ) end -- 8)
    m1 = m:scanl('+', nil       , {}) for i=1,#m1 do assertEquals( m1[i]     , sum(1..i)   ) end -- 3)
    m1 = m:scanl('+', nil , nil , {}) for i=1,#m1 do assertEquals( m1[i]     , sum(1..i)   ) end -- 3)
    m1 = m:scanl('+',  2  , nil , {}) for i=1,#m1 do assertEquals( m1[i]     , sum(1..i)+2 ) end -- 7)
    m1 = m:scanl('+', 'col') -- 2)
    for i=1,nr do for j=1,nc do assertEquals( m1:get(i,j), sum(ref(1,j,nc)..ref(i,j,nc)..nc) ) end end
    m1 = m:scanl('+', 'row') -- 2)
    for i=1,nr do for j=1,nc do assertEquals( m1:get(i,j), sum(ref(i,1,nc)..ref(i,j,nc)..1 ) ) end end

  -- non-commutative operations
    m1 = m:scanl '-'             for i=1,#m1 do assertEquals( m1:geti(i), sub(1..i) ) end
    m1 = m:scanl('-', nil  , {}) for i=1,#m1 do assertEquals( m1[i]     , sub(1..i) ) end
    m1 = m:scanl('-', 'row')
    for i=1,nr do for j=1,nc do
      assertEquals( m1:get(i,j), sub(ref(i,1,nc)..ref(i,j,nc)..1 ) )
    end end
  end
  assertEquals( vector(4):fill(4..1..-1):scanl '^', vector{4, 4^3, (4^3)^2, ((4^3)^2)^1} )
end

function TestMatrixErr:testScanr()
  local msg = {
    "invalid argument #2 (callable expected)"                    ,
    "invalid argument #5 (iterable expected)"                    ,
    "invalid argument #4 (string 'vec', 'row' or 'col' expected)",
    "invalid range member '1'"                                   ,
  }
  m, cm = matrix(2), cmatrix(2)
  assertErrorMsgContains( msg[1], mth, 'scanr', errMat, nil  )
  assertErrorMsgContains( msg[1], mth, 'scanr', errMat, NaN  )
  assertErrorMsgContains( msg[1], mth, 'scanr', errMat, ''   )
  assertErrorMsgContains( msg[1], mth, 'scanr', errMat, {}   )
  assertErrorMsgContains( msg[1], mth, 'scanr', errMat, 1    )
  assertErrorMsgContains( msg[1], mth, 'scanr', errMat, 1..2 )
  assertErrorMsgContains( msg[1], mth, 'scanr', errMat, m    )
  assertErrorMsgContains( msg[1], mth, 'scanr', errMat, cm   )
  assertErrorMsgContains( msg[3], mth, 'scanr', errMat, \x x, '')
  assertErrorMsgContains( msg[3], mth, 'scanr', errMat, \x x, 1 , {}   , {}   )
  assertErrorMsgContains( msg[3], mth, 'scanr', errMat, \x x, 1 , 1..2 , {}   )
  assertErrorMsgContains( msg[3], mth, 'scanr', errMat, \x x, 1 , m    , {}   )
  assertErrorMsgContains( msg[3], mth, 'scanr', errMat, \x x, 1 , cm   , {}   )
  assertErrorMsgContains( msg[3], mth, 'scanr', errMat, \x x, 1 , ''   , {}   )
  assertErrorMsgContains( msg[2], mth, 'scanr', errMat, \x x, 1 , "vec", ''   )
  assertErrorMsgContains( msg[2], mth, 'scanr', errMat, \x x, 1 , "vec", 1    )
  assertErrorMsgContains( msg[2], mth, 'scanr', errMat, \x x, 1 , "vec", \x x )
end

function TestMatrixFun:testScanr()
  local function subR(r)
    local x = table.new(r:size(),1)
    x[r:size()] = r[r:size()]
    for i=r:size()-1,1,-1 do
      if i%2 == 0 then x[i]= -(x[i+1] - r[i])
                  else x[i]= - x[i+1] + r[i]  end
    end
    return x
  end

  local m1
  for _,m in ipairs(self.mat) do
    local nr, nc = m:sizes()
    m1 = m:scanr \x x                 for i=1  ,#m1  do assertEquals( m1:geti(i), i               ) end -- 1)
    m1 = m:scanr '+'                  for i=#m1,1,-1 do assertEquals( m1:geti(i), sum(i..nr*nc)   ) end -- 1)
    m1 = m:scanr('+','vec')           for i=#m1,1,-1 do assertEquals( m1:geti(i), sum(i..nr*nc)   ) end -- 2)
    m1 = m:scanr('+', 0   )           for i=#m1,1,-1 do assertEquals( m1:geti(i), sum(i..nr*nc)   ) end -- 5)
    m1 = m:scanr('+', 0   ,'vec')     for i=#m1,1,-1 do assertEquals( m1:geti(i), sum(i..nr*nc)   ) end -- 6)
    m1 = m:scanr('+','vec', {})       for i=#m1,1,-1 do assertEquals( m1[i]     , sum(i..nr*nc)   ) end -- 4)
    m1 = m:scanr('+', 0   ,'vec', {}) for i=#m1,1,-1 do assertEquals( m1[i]     , sum(i..nr*nc)   ) end -- 8)
    m1 = m:scanr('+', nil       , {}) for i=#m1,1,-1 do assertEquals( m1[i]     , sum(i..nr*nc)   ) end -- 3)
    m1 = m:scanr('+', nil , nil , {}) for i=#m1,1,-1 do assertEquals( m1[i]     , sum(i..nr*nc)   ) end -- 3)
    m1 = m:scanr('+',  2  , nil , {}) for i=#m1,1,-1 do assertEquals( m1[i]     , sum(i..nr*nc)+2 ) end -- 7)
    m1 = m:scanr('+', 'col')
    for i=nr,1,-1 do for j=1,nc do assertEquals( m1:get(i,j), sum(ref(nr,j,nc)..ref(i,j,nc)..-nc) ) end end
    m1 = m:scanr('+', 'row')
    for j=nc,1,-1 do for i=1,nr do assertEquals( m1:get(i,j), sum(ref(i,nc,nc)..ref(i,j,nc)..-1 ) ) end end

    -- non-commutative operations
    local refT = subR(1..nr*nc)
    m1 = m:scanr '-'           for i=#m1,1,-1 do assertEquals( m1:geti(i), refT[i] ) end
    m1 = m:scanr('-', nil, {}) for i=#m1,1,-1 do assertEquals( m1[i]     , refT[i] ) end

    m1 = m:scanr('-', 'col')
    for i=nr,1,-1 do
    for j=1 ,nc   do
      assertEquals( m1:get(i,j),  sum(ref(i,j,nc)..ref(nr,j,nc)..2*nc ) - sum(ref(i+1,j,nc)..ref(nr,j,nc)..2*nc) )
    end end

    m1 = m:scanr('-', 'row')
    for i=1 ,nr   do
    for j=nc,1,-1 do
      assertEquals( m1:get(i,j), sum(ref(i,j,nc)..ref(i,nc,nc)..2) - sum(ref(i,j+1,nc)..ref(i,nc,nc)..2 ) )
    end end
  end
  assertEquals( vector(4):fill(4..1..-1):scanr '^', vector{ 4^3^2^1, 3^2^1, 2^1, 1 } )
end

function TestMatrixErr:testFilter()
  local msg = {
    "invalid argument #2 (callable expected)",
    "invalid argument #3 (iterable expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'filter', errMat, nil       )
  assertErrorMsgContains( msg[1], mth, 'filter', errMat, ''        )
  assertErrorMsgContains( msg[1], mth, 'filter', errMat, 1..2      )
  assertErrorMsgContains( msg[1], mth, 'filter', errMat, 1         )
  assertErrorMsgContains( msg[1], mth, 'filter', errMat, matrix(1) )
  assertErrorMsgContains( msg[1], mth, 'filter', errMat, { }       )
  assertErrorMsgContains( msg[2], mth, 'filter', errMat, \x x     , ''   )
  assertErrorMsgContains( msg[2], mth, 'filter', errMat, \x x     , 1    )
  assertErrorMsgContains( msg[2], mth, 'filter', errMat, \x x     , \x x )
end

function TestMatrixFun:testFilter()
 for _,m in ipairs(self.mat) do
    local m1
    assertEquals( m:filter(\x x==1, vector(25)), vector(1):seti(1,1) )
    m1 = m:filter(\x x==1    ) for i=1,#m1   do assertEquals( m1:geti(i), 1   ) end
    m1 = m:filter(\x x==1, {}) for i=1,#m1   do assertEquals( m1[i]     , 1   ) end
    m1 = m:filter(\x x>1 , {}) for i=1,#m1-1 do assertEquals( m1[i]     , i+1 ) end
    m1 = m:filter(\x x<5)
    local nr, nc = m1:sizes()
    assertEquals( {m1:sizes()}, {ref(nr,nc,nc),1} )
    for i=1,ref(nr,nc,nc) do assertEquals( m1:geti(i), i ) end
  end
end

function TestMatrixErr:testFilter_out()
  local msg = {
    "invalid argument #2 (callable expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'filter_out', errMat, nil       )
  assertErrorMsgContains( msg[1], mth, 'filter_out', errMat, ''        )
  assertErrorMsgContains( msg[1], mth, 'filter_out', errMat, 1..2      )
  assertErrorMsgContains( msg[1], mth, 'filter_out', errMat, 1         )
  assertErrorMsgContains( msg[1], mth, 'filter_out', errMat, matrix(1) )
  assertErrorMsgContains( msg[1], mth, 'filter_out', errMat, {}        )
end

function TestMatrixFun:testFilter_out()
 for _,m in ipairs(self.mat) do
  local m1
    assertEquals( m:filter(\x x==1, vector(25)), vector(1):seti(1,1) )
    m1 = m:filter_out(\x x~=1    ) for i=1,#m1   do assertEquals( m1:geti(i), 1   ) end
    m1 = m:filter_out(\x x~=1, {}) for i=1,#m1   do assertEquals( m1[i]     , 1   ) end
    m1 = m:filter_out(\x x<=1, {}) for i=1,#m1-1 do assertEquals( m1[i]     , i+1 ) end
    m1 = m:filter_out(\x x>=5)
    local nr, nc = m1:sizes()
    assertEquals( {m1:sizes()}, {ref(nr,nc,nc),1} )
    for i=1,ref(nr,nc,nc) do assertEquals( m1:geti(i), i ) end
  end
end

-- special maps ---------------------------------------------------------------o

function TestMatrixSMapsI:SetUp ()
  self.empty = {}
  for nr=1,3 do
  for nc=1,3 do
    self.empty[ref(nr,nc,3)] = matrix(nr,nc)
  end end
end

function TestMatrixSMapsII:SetUp ()
  self.mat = {}
  for nr=1,3 do
  for nc=1,3 do
    local r = 1..nr*nc
    self.mat[ref(nr,nc,3)] = matrix(nr,nc):fill(r)
  end end
end

function TestMatrixSMapsI:testCeil ()
  for _,m in ipairs(self.empty) do
    local r  = nrange(0.01, 1, m:size())
    m = m:fill(r):ceil()
    for i=1,#m do assertEquals( m:geti(i), 1 ) end
  end
end

function TestMatrixSMapsI:testFloor()
  for _,m in ipairs(self.empty) do
    local r  = nrange(0, 1-0.01, m:size())
    m = m:fill(r):floor()
    for i=1,#m do assertEquals( m:geti(i), 0 ) end
  end
end

function TestMatrixSMapsI:testFrac ()
  for _,m in ipairs(self.empty) do
    local r  = range(0.1,(m:size())/10,0.1)
    m = m:fill(r):frac()
    for i=1,#m do
      if     r[i] < 1 then assertAlmostEquals( m:geti(i) -i/10  , 0, eps )
      elseif r[i] < 2 then assertEquals      ( m:geti(i), i/10-1 )
                      else assertEquals      ( m:geti(i), i/10-2 )         end
    end
  end
end

function TestMatrixSMapsI:testTrunc()
  for _,m in ipairs(self.empty) do
    local r  = nrange(0, 3-0.01, m:size())
    m = m:fill(r):trunc()
    for i=1,#m do
      if     r[i] < 1 then assertEquals( m:geti(i), 0 )
      elseif r[i] < 2 then assertEquals( m:geti(i), 1 )
                      else assertEquals( m:geti(i), 2 ) end
    end
  end
end

function TestMatrixSMapsI:testRound()
  for _,m in ipairs(self.empty) do
    local r = nrange(0, 1, m:size())
    m = m:fill(r):round()
    for i=1,#m do
    if r[i] < 0.5 then assertEquals( m:geti(i), 0 )
                  else assertEquals( m:geti(i), 1 ) end
    end
  end
end

function TestMatrixSMapsI:testAbs()
  for _,m in ipairs(self.empty) do
    local r  = nrange(-3,3, m:size())
    m = m:fill(r):abs()
    for i=1,#m do
      assertTrue( m:geti(i) >= 0 )
    end
  end
end

function TestMatrixSMapsII:testSqrt()
  for _,m in ipairs(self.mat) do
    m:sqrt('in')
    for i=1,#m do assertAlmostEquals( m:geti(i)*m:geti(i) - i, 0, 16*eps ) end
  end
end

function TestMatrixSMapsII:testExp()
  for _,m in ipairs(self.mat) do
    m:exp('in')
    for i=1,#m do assertEquals( log(m:geti(i)), i )  end
  end
end

function TestMatrixSMapsII:testLog()
  for _,m in ipairs(self.mat) do
    local r = 1..m:size()
    m:log('in')
    for i=1,#m do assertAlmostEquals( exp(m:geti(i)) / i, 1, eps ) end
  end
end

function TestMatrixSMapsII:testLog10()
  for _,m in ipairs(self.mat) do
    m:log10('in')
    for i=1,#m do assertAlmostEquals( m:geti(i) - log(i)/log(10), 0, eps ) end
  end
end

function TestMatrixSMapsI:testSin()
  for _,m in ipairs(self.empty) do
    local r = nrange(1,pi/2,m:size())
    m = m:fill(r):sin()
    for i=1,#m do assertEquals( m:geti(i), -sin(-r[i]) ) end
  end
end

function TestMatrixSMapsI:testCos()
  for _,m in ipairs(self.empty) do
    local r = nrange(1,pi/2,m:size())
    m = m:fill(r):cos()
    for i=1,#m do assertEquals      ( m:geti(i),  cos(-r[i])  )
                  assertAlmostEquals( m:geti(i) - sin(pi/2-r[i]), 0, eps ) end
  end
end

function TestMatrixSMapsI:testTan()
  for _,m in ipairs(self.empty) do
    local r = nrange(1,pi/2,m:size())
    m = m:fill(r):tan()
    for i=1,#m do
      assertAlmostEquals( m:geti(i) - sin(r[i])/cos(r[i]), 0, 32*eps )
    end
  end
end

function TestMatrixSMapsI:testSinh()
  for _,m in ipairs(self.empty) do
    local r = nrange(1,pi/2,m:size())
    m = m:fill(r):sinh()
    for i=1,#m do
     assertAlmostEquals( m:geti(i) / (2*sinh(r[i]/2)*cosh(r[i]/2)), 1, eps )
    end
  end
end

function TestMatrixSMapsI:testCosh()
  for _,m in ipairs(self.empty) do
    local r = nrange(1,pi/2,m:size())
    m = m:fill(r):cosh()
    for i=1,#m do
      assertAlmostEquals( m:geti(i) / (1 + 2*sinh(r[i]/2)^2) - 1, 0, 2*eps )
    end
  end
end

function TestMatrixSMapsI:testTanh()
  for _,m in ipairs(self.empty) do
    local r = nrange(1,pi/2,m:size())
    m = m:fill(r):tanh()
    for i=1,#m do assertAlmostEquals( m:geti(i) - sinh(r[i])/cosh(r[i]), 0, eps ) end
  end
end

function TestMatrixSMapsI:testAsin()
  for _,m in ipairs(self.empty) do
    local r = nrange(1,pi/2,m:size())
    m = m:fill(r):sin():asin()
    for i=1,#m do assertAlmostEquals( m:geti(i) - r[i], 0, 16*eps ) end
  end
end

function TestMatrixSMapsI:testAcos()
  for _,m in ipairs(self.empty) do
    local r = nrange(1,pi/2,m:size())
    m = m:fill(r):cos():acos()
    for i=1,#m do assertAlmostEquals( m:geti(i) / r[i] - 1, 0, eps ) end
  end
end

function TestMatrixSMapsI:testAtan()
  for _,m in ipairs(self.empty) do
    local r = nrange(1,pi/2,m:size())
    m = m:fill(r):tan():atan()
    for i=1,#m do assertEquals( m:geti(i), r[i] ) end
  end
end

function TestMatrixSMapsI:testAsinh()
  for _,m in ipairs(self.empty) do
    local r = nrange(1,pi/2,m:size())
    m = m:fill(r):asinh():sinh()
    for i=1,#m do assertAlmostEquals( m:geti(i) / r[i] - 1, 0, eps ) end
  end
end

function TestMatrixSMapsI:testAcosh()
  for _,m in ipairs(self.empty) do
    local r = nrange(1,pi/2,m:size())
    m = m:fill(r):acosh():cosh()
    for i=1,#m do assertAlmostEquals( m:geti(i) / r[i] - 1, 0, eps ) end
  end
end

function TestMatrixSMapsI:testAtanh()
  for _,m in ipairs(self.empty) do
    local r = nrange(1,pi/2,m:size())
    m = m:fill(r):tanh():atanh()
    for i=1,#m do assertAlmostEquals( m:geti(i) / r[i] - 1, 0, eps ) end
  end
end

--function TestMatrixSMaps:testErf()    end
--function TestMatrixSMaps:testTgamma() end
--function TestMatrixSMaps:testLgamma() end

function TestMatrixSMapsII:testCarg()
  for i,m in ipairs(self.mat) do
    m:carg('in')
    for i=1,#m do assertEquals( m:geti(i), 0 ) end
  end
end

function TestMatrixSMapsII:testReal()
  for _,m in ipairs(self.mat) do
    m:real('in')
    for i=1,#m do assertEquals( m:geti(i), i ) end
  end
end

function TestMatrixSMapsII:testImag()
  for i,m in ipairs(self.mat) do
    m:imag('in')
    for i=1,#m do assertEquals( m:geti(i), 0 ) end
end
end

function TestMatrixSMapsII:testConj()
  for _,m in ipairs(self.mat) do
    m:conj('in')
    for i=1,#m do assertEquals( m:geti(i), i ) end
  end
end

function TestMatrixSMapsII:testProj() -- complex values, cmatrix
  for _,m in ipairs(self.mat) do
    m = m:proj()
    assertFalse( is_matrix(m) )
    for i=1,#m do assertEquals( m:geti(i), i+0i ) end
  end
  for _,m in ipairs(self.mat) do
    m:proj('in')
    assertTrue( is_matrix(m) )
    for i=1,#m do assertEquals( m:geti(i), i ) end
  end
end

function TestMatrixSMapsII:testRect()
  for _,m in ipairs(self.mat) do
    m:rect('in')
    for i=1,#m do assertEquals( m:geti(i), i ) end
  end
end

function TestMatrixSMapsII:testPolar() -- complex values, cmatrix
  for _,m in ipairs(self.mat) do
    m = m:polar()
    assertFalse( is_matrix(m) )
    for i=1,#m do assertEquals( m:geti(i), i+0i ) end
  end
  for _,m in ipairs(self.mat) do
    m:polar('in')
    assertTrue( is_matrix(m) )
    for i=1,#m do assertEquals( m:geti(i), i ) end
  end
end

-- special folds --------------------------------------------------------------o

function TestMatrixSFolds:testMin()
  local m1
  for _,m in ipairs(G.mat) do
    local nr, nc = m:sizes()
    assertEquals( m:min(), 1 )
    m1 = m:min("col") for i=1,nc do assertEquals( m1:geti(i), i           ) end
    m1 = m:min("row") for i=1,nr do assertEquals( m1:geti(i), ref(i,1,nc) ) end
  end
end

function TestMatrixSFolds:testMax()
  local m1
  for _,m in ipairs(G.mat) do
    local  nr, nc = m:sizes()
    assertEquals( m:max(), m:size() )
    m1 = m:max("col") for i=1,nc do assertEquals( m1:geti(i), ref(nr,i,nc) ) end
    m1 = m:max("row") for i=1,nr do assertEquals( m1:geti(i), ref(i,nc,nc) ) end
  end
end

function TestMatrixSFolds:testSum()
  local m1
  for _,m in ipairs(G.mat) do
    local nr, nc = m:sizes()
    assertEquals( m:sum(), sum(1..m:size()) )
    m1 = m:sum('col') for i=1,nc do assertEquals( m1:geti(i), sum(ref(1,i,nc)..ref(nr,i,nc)..nc) ) end
    m1 = m:sum('row') for i=1,nr do assertEquals( m1:geti(i), sum(ref(i,1,nc)..ref(i,nc,nc)..1 ) ) end
  end
end

function TestMatrixSFolds:testSumabs()
  local m1, mres
  for _,m in ipairs(G.mat) do
    local nr, nc = m:sizes()
    m1 = m:copy():map(\x -x)
    assertEquals( m1:sumabs(), sum(1..m:size()) )
    mres = m:sumabs('col') for i=1,nc do assertEquals( mres:geti(i), sum(ref(1,i,nc)..ref(nr,i,nc)..nc) ) end
    mres = m:sumabs('row') for i=1,nr do assertEquals( mres:geti(i), sum(ref(i,1,nc)..ref(i,nc,nc)..1 ) ) end
  end
end

function TestMatrixSFolds:testSumsqr()
  local sumsqr = \r =>local x = 0 for i=1,r:size() do x = x + r[i]^2 end return x end
  local m1
  for _,m in ipairs(G.mat) do
    local nr, nc = m:sizes()
    assertEquals( m:sumsqr(), sumsqr(1..m:size()) )
    m1 = m:sumsqr('col') for i=1,nc do assertEquals( m1:geti(i), sumsqr(ref(1,i,nc)..ref(nr,i,nc)..nc) ) end
    m1 = m:sumsqr('row') for i=1,nr do assertEquals( m1:geti(i), sumsqr(ref(i,1,nc)..ref(i,nc,nc)..1 ) ) end
  end
end

function TestMatrixSFolds:testProduct()
  local prod = \r =>local x = 1 for i=1,r:size() do x = x * r[i] end return x end
  local m1
  for _,m in ipairs(G.mat) do
    local nr, nc = m:sizes()
    assertEquals( m:product(), prod(1..m:size()) )
    m1 = m:product('col') for i=1,nc do assertEquals( m1:geti(i), prod(ref(1,i,nc)..ref(nr,i,nc)..nc) ) end
    m1 = m:product('row') for i=1,nr do assertEquals( m1:geti(i), prod(ref(i,1,nc)..ref(i,nc,nc)..1 ) ) end
  end
end

function TestMatrixErr:testAll()
  local msg = {
    "invalid argument #2 (callable expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'all', errMat, nil    )
  assertErrorMsgContains( msg[1], mth, 'all', errMat, ''     )
  assertErrorMsgContains( msg[1], mth, 'all', errMat, 1..2   )
  assertErrorMsgContains( msg[1], mth, 'all', errMat, 1      )
  assertErrorMsgContains( msg[1], mth, 'all', errMat, errMat )
  assertErrorMsgContains( msg[1], mth, 'all', errMat, { }    )
end

function TestMatrixSFolds:testAll()
  local m1
  for _,m in ipairs(G.mat) do
    local nr, nc = m:sizes()
    assertFalse ( m:all \x x> m:size()   )
    assertTrue  ( m:all \x x< m:size()+1 )
    m1 = m:all( \x x<16, 'col')
    if m:size() < 16 then
      for i=1,m1:size()   do assertEquals( m1:geti(i) , 1 ) end
    elseif m:size() == 16 then
      for i=1,m1:size()-1 do assertEquals( m1:geti(i) , 1 ) end
                             assertEquals( m1:geti(nc), 0 )
    else
      for i=1,m1:size()   do assertEquals( m1:geti(i) , 0 ) end
    end

    m1 = m:all( \x x<16, 'row')
    if m:size() < 16 then
      for i=1,m1:size()   do assertEquals( m1:geti(i) , 1 ) end
    else
      for i=1,3           do assertEquals( m1:geti(i) , 1 ) end
      for i=4,nr          do assertEquals( m1:geti(i) , 0 ) end
    end
  end
end

function TestMatrixErr:testAny()
  local msg = {
    "invalid argument #2 (callable expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'any', errMat, nil    )
  assertErrorMsgContains( msg[1], mth, 'any', errMat, ''     )
  assertErrorMsgContains( msg[1], mth, 'any', errMat, 1..2   )
  assertErrorMsgContains( msg[1], mth, 'any', errMat, 1      )
  assertErrorMsgContains( msg[1], mth, 'any', errMat, errMat )
  assertErrorMsgContains( msg[1], mth, 'any', errMat, { }    )
end

function TestMatrixSFolds:testAny()
  local m1
  for _,m in ipairs(G.mat) do
    local nr, nc = m:sizes()
    assertFalse ( m:any \x x> m:size()   )
    assertTrue  ( m:any \x x< m:size()+1 )

    m1 = m:any( \x x>16, 'col')
    if m:size() <= 16 then
      for i=1,m1:size()   do assertEquals( m1:geti(i) , 0 ) end
    elseif nr == 4 and nc == 5 then
      for i=2,m1:size()   do assertEquals( m1:geti(i) , 1 ) end
                             assertEquals( m1:geti(1) , 0 )
    else
      for i=1,m1:size()   do assertEquals( m1:geti(i) , 1 ) end
    end

    m1 = m:any( \x x>16, 'row')
    if m:size() <= 16 then
      for i=1,m1:size()   do assertEquals( m1:geti(i) , 0 ) end
    elseif m:size() == 20 then
      for i=1,m1:size()-1 do assertEquals( m1:geti(i) , 0 ) end
                             assertEquals( m1:geti(nr), 1 )
    else
      for i=1,3           do assertEquals( m1:geti(i) , 0 ) end
      for i=4,nr          do assertEquals( m1:geti(i) , 1 ) end
    end
  end
end

-- special scans --------------------------------------------------------------o

-- left accumulation
function TestMatrixSScans:testAccmin()
  local m1
  for _,m in ipairs(G.mat) do
    local nr, nc = m:sizes()
    m1 = m:accmin()      for i=1,m:size()         do assertEquals( m1:geti(i) , 1 ) end
    m1 = m:accmin("col") for i=1,nr do for j=1,nc do assertEquals( m1:get(i,j), j ) end end
    m1 = m:accmin("row") for i=1,nr do for j=1,nc do assertEquals( m1:get(i,j), ref(i,1,nc) ) end end
  end
end

function TestMatrixSScans:testAccmax()
  local m1
  for _,m in ipairs(G.mat) do
    local nr, nc = m:sizes()
    m1 = m:accmax()      for i=1,m:size()         do assertEquals( m1:geti(i) , i ) end
    m1 = m:accmax("col") for i=1,nr do for j=1,nc do assertEquals( m1:get(i,j), ref(i,j,nc) ) end end
    m1 = m:accmax("row") for i=1,nr do for j=1,nc do assertEquals( m1:get(i,j), ref(i,j,nc) ) end end
  end
end

function TestMatrixSScans:testAccsum() --double testing, need change
  for _,m in ipairs(G.mat) do
    local nr, nc = m:sizes()
    m1 = m:accsum() for i=1,m:size() do assertEquals( m1:geti(i), sum(1..i) ) end
    m1 = m:accsum("col")
    for i=1,nr do for j=1,nc do assertEquals( m1:get(i,j), sum(ref(1,j,nc)..ref(i,j,nc)..nc) ) end end
    m1 = m:accsum("row")
    for i=1,nr do for j=1,nc do assertEquals( m1:get(i,j), sum(ref(i,1,nc)..ref(i,j,nc)..1 ) ) end end
  end
end

function TestMatrixSScans:testAccsumabs()
for _,mg in ipairs(G.mat) do
    local nr, nc = mg:sizes()
    m = matrix(nr,nc)
    m = mg:copy():map(\x -x)
    m1 = m:accsumabs() for i=1,m:size() do assertEquals( m1:geti(i), sum(1..i) ) end
    m1 = m:accsumabs("col")
    for i=1,nr do for j=1,nc do assertEquals( m1:get(i,j), sum(ref(1,j,nc)..ref(i,j,nc)..nc) ) end end
    m1 = m:accsumabs("row")
    for i=1,nr do for j=1,nc do assertEquals( m1:get(i,j), sum(ref(i,1,nc)..ref(i,j,nc)..1 ) ) end end
  end
end

function TestMatrixSScans:testAccsumsqr()
  local sumsqr = \r =>local x = 0 for i=1,r:size() do x = x + r[i]^2 end return x end
  for _,m in ipairs(G.mat) do
    local nr, nc = m:sizes()
    m1 = m:accsumsqr() for i=1,m:size() do assertEquals( m1:geti(i), sumsqr(1..i) ) end
    m1 = m:accsumsqr("col")
    for i=1,nr do for j=1,nc do assertEquals( m1:get(i,j), sumsqr(ref(1,j,nc)..ref(i,j,nc)..nc) ) end end
    m1 = m:accsumsqr("row")
    for i=1,nr do for j=1,nc do assertEquals( m1:get(i,j), sumsqr(ref(i,1,nc)..ref(i,j,nc)..1 ) ) end end
  end
end

function TestMatrixSScans:testAccprod()
  local prod = \r =>local x = 1 for i=1,r:size() do x = x * r[i] end return x end
  for _,m in ipairs(G.mat) do
    local nr, nc = m:sizes()
    m1 = m:accprod() for i=1,m:size() do assertEquals( m1:geti(i), prod(1..i) ) end
    m1 = m:accprod("col")
    for i=1,nr do for j=1,nc do assertEquals( m1:get(i,j), prod(ref(1,j,nc)..ref(i,j,nc)..nc) )  end end
    m1 = m:accprod("row")
    for i=1,nr do for j=1,nc do assertEquals( m1:get(i,j), prod(ref(i,1,nc)..ref(i,j,nc)..1 ) )  end end
  end
end

-- right accumulation
function TestMatrixSScans:testRaccmin()
  local m1
  for _,m in ipairs(G.mat) do
    local nr, nc = m:sizes()
    m1 = m:raccmin()      for i=1,m:size()         do assertEquals( m1:geti(i) , i ) end
    m1 = m:raccmin("col") for i=1,nr do for j=1,nc do assertEquals( m1:get(i,j), ref(i,j,nc) ) end end
    m1 = m:raccmin("row") for i=1,nr do for j=1,nc do assertEquals( m1:get(i,j), ref(i,j,nc) ) end end
  end
end

function TestMatrixSScans:testRaccmax()
  local m1
  for _,m in ipairs(G.mat) do
    local nr, nc = m:sizes()
    m1 = m:raccmax()      for i=1,m:size()         do assertEquals( m1:geti(i) , m1:geti(m:size()) ) end
    m1 = m:raccmax("col") for i=1,nr do for j=1,nc do assertEquals( m1:get(i,j), ref(nr,j,nc) ) end end
    m1 = m:raccmax("row") for i=1,nr do for j=1,nc do assertEquals( m1:get(i,j), ref(i,nc,nc) ) end end
  end
end

function TestMatrixSScans:testRaccsum()
  local m1
  for _,m in ipairs(G.mat) do
    local nr, nc = m:sizes()
    m1 = m:raccsum()
    for i=1,m:size()            do assertEquals( m1:geti(i) , sum(i..nr*nc)   ) end
    m1 = m:raccsum("col")
    for i=nr,1,-1 do for j=1,nc do assertEquals( m1:get(i,j), sum(ref(nr,j,nc)..ref(i,j,nc)..-nc) ) end end
    m1 = m:raccsum("row")
    for i=1,nr do for j=nc,1,-1 do assertEquals( m1:get(i,j), sum(ref(i,j,nc)..ref(i,nc,nc))      ) end end
  end
end

function TestMatrixSScans:testRaccsumabs()
  local m1
  for _,mg in ipairs(G.mat) do
    local nr, nc = mg:sizes()
    m = matrix(nr,nc)
    m = mg:copy():map(\x -x)
    m1 = m:raccsumabs()
    for i=1,m:size()            do assertEquals( m1:geti(i) , sum(i..nr*nc)   ) end
    m1 = m:raccsumabs("col")
    for i=nr,1,-1 do for j=1,nc do assertEquals( m1:get(i,j), sum(ref(nr,j,nc)..ref(i,j,nc)..-nc) ) end end
    m1 = m:raccsumabs("row")
    for i=1,nr do for j=nc,1,-1 do assertEquals( m1:get(i,j), sum(ref(i,j,nc)..ref(i,nc,nc))      ) end end
  end
end

function TestMatrixSScans:testRaccsumsqr()
  local sumsqr = \r =>local x = 0 for i=1,r:size() do x = x + r[i]^2 end return x end
  local m1
  for _,m in ipairs(G.mat) do
    local nr, nc = m:sizes()
    m1 = m:raccsumsqr()
    for i=1,m:size()            do assertEquals( m1:geti(i) , sumsqr(i..nr*nc)   ) end
    m1 = m:raccsumsqr("col")
    for i=nr,1,-1 do for j=1,nc do assertEquals( m1:get(i,j), sumsqr(ref(nr,j,nc)..ref(i,j,nc)..-nc) ) end end
    m1 = m:raccsumsqr("row")
    for i=1,nr do for j=nc,1,-1 do assertEquals( m1:get(i,j), sumsqr(ref(i,j,nc)..ref(i,nc,nc))      ) end end
  end
end

function TestMatrixSScans:testRaccprod()
  local prod = \r =>local x = 1 for i=1,r:size() do x = x * r[i] end return x end
  local m1
  for _,m in ipairs(G.mat) do
    local nr, nc = m:sizes()
    m1 = m:raccprod()
    if nr*nc < 25 then
      for i=1,m:size() do assertEquals( m1:geti(i) - prod(i..nr*nc), 0 ) end
    end
    m1 = m:raccprod("col")
    for i=nr,1,-1 do for j=1,nc do assertAlmostEquals( m1:get(i,j) - prod(ref(nr,j,nc)..ref(i,j,nc)..-nc), 0, eps ) end end
    m1 = m:raccprod("row")
    for i=1,nr do for j=nc,1,-1 do assertAlmostEquals( m1:get(i,j) - prod(ref(i,j,nc)..ref(i,nc,nc)), 0, eps ) end end
  end
end

-- symplectic matrix ----------------------------------------------------------o

function TestMatrixErr:testSympinv()
  local msg = {
   "invalid argument #1 (2n matrix expected)",
  }
  assertErrorMsgContains( msg[1], mth,'sympinv',  matrix(3)   )
  assertErrorMsgContains( msg[1], mth,'sympinv',  matrix(4,3) )
end

function TestMatrixSympl:testSympinv()
-- -J M' J
--[[ M' J M = J => M^-1 = J^-1 M'      det(M)  = ±1 (i.e. Sp(n))
     symp M = {{A,B},{C,D}} <=> A'D - C'B = 1, A'C = C'A, B'D = D'B ]]
  local mat = matrix(2)
  local j  = matrix(2):symp()
  local m1 = { matrix{{1,0},{0,1}},
               matrix{{1,0},{1,1}},
               matrix{{1,1},{0,1}}, }
  for _,m in ipairs(m1) do
    assertEquals( m:t()*j*m      , j )
    assertEquals( m:sympinv()   , -j*m:t()*j )
    assertEquals( m:sympinv(mat), -j*m:t()*j )
  end
end

function TestMatrixErr:testSymperr()
  local msg = {
    "invalid argument #1 (2n matrix expected)"       ,
    "invalid argument #2 (different matrix expected)",
  }
  assertErrorMsgContains( msg[1], mth,'symperr',  matrix(3)   )
  assertErrorMsgContains( msg[1], mth,'symperr',  matrix(4,3) )
end

function TestMatrixSympl:testSymperr()
  -- M' J M - J
  --assertEquals( m:symperr(), m:t()*j*m-j )
  local j  = matrix(2):symp()
  local m1 = { matrix{{1,0},{0,1}},
               matrix{{1,0},{1,1}},
               matrix{{1,1},{0,1}}, }
  for _,m in ipairs(m1) do
    assertEquals( m:symperr(), 0 )
  end
  local m1 = { matrix{{0,0},{0,1}},
               matrix{{0,1},{0,1}}, }
  for _,m in ipairs(m1) do
    assertTrue( m:symperr() ~= 0 )
  end
end

-- conjugate, transpose -------------------------------------------------------o

function TestMatrixLinAlg:testConjugate()
  for _,m in ipairs(G.mat) do assertEquals( m:conj(), m )  end
end

function TestMatrixLinAlg:testTranspose()
  local m1
  for _,m in ipairs(G.mat) do
    local nr, nc = m:sizes()
    m1 = m:copy()
    assertEquals( {m:t():sizes()}, {nc,nr}        )
    assertEquals(  m:t()  :t()   , m              )
    assertEquals( (m + m1):t()   , m:t() + m1:t() )
    assertEquals( (2 * m) :t()   , 2 * m:t()      )
    if nr == nc then assertEquals( (m*m1):t(), m:t()*m1:t() ) end
    m1 = m:t()
    for i=1,nr do for j=1,nc do
      assertEquals( m1:get(i,j), m:get(j,i) )
    end end
  end
end

function TestMatrixLinAlg:testTrace()
  for _,m in ipairs(G.mat) do
    local nr, nc = m:sizes()
    assertEquals( m:tr(), m:getdiag():sum() )
  end
end

-- inner, cross, mixed, outer -------------------------------------------------o

function TestMatrixErr:testInner()
  local msg = {
    "invalid argument #2 (matrix expected)",
    "incompatible matrix sizes"            ,
  }
  assertErrorMsgContains( msg[1], mth, 'inner', errMat, nil  )
  assertErrorMsgContains( msg[1], mth, 'inner', errMat, ''   )
  assertErrorMsgContains( msg[1], mth, 'inner', errMat, 1    )
  assertErrorMsgContains( msg[1], mth, 'inner', errMat, 1..2 )
  assertErrorMsgContains( msg[1], mth, 'inner', errMat, {}   )
  assertErrorMsgContains( msg[2], mth, 'inner', errMat, errMat, errMat )
end

function TestMatrixLinAlg:testInner()
  -- inner prod:  u'.v = |u|.|v| cos(u^v)
  for _,m1 in ipairs(G.mat) do
    local m2   = m1:copy()
    local mres = m1:inner(m2)
    local mref = (m1:t()*m2):getdiag()
    local s = mref:size()
    if s == 1 then    assertEquals( mres        , mref:geti(1) )
    else for i=1,s do assertEquals( mres:geti(i), mref:geti(i) ) end
    end

    assertEquals( m1:inner(m2, 'tr'), (m1:t()*m2):tr() )
  end
end

function TestMatrixErr:testOuter()
  local m = matrix(2,1)
  local msg = {
    "invalid argument #2 (matrix expected)",
    "incompatible matrix sizes",
  }
  assertErrorMsgContains( msg[1], mth, 'outer', m          , nil  )
  assertErrorMsgContains( msg[1], mth, 'outer', m          , ''   )
  assertErrorMsgContains( msg[1], mth, 'outer', m          , {}   )
  assertErrorMsgContains( msg[1], mth, 'outer', m          , 1    )
  assertErrorMsgContains( msg[1], mth, 'outer', m          , 1..2 )
  assertErrorMsgContains( msg[2], mth, 'outer', matrix(1,2), matrix(2,2) )
end

function TestMatrixLinAlg:testOuter()
  -- x * y:t() without temporary
  for nr=1,5 do
    local m1 = vector(nr):fill(1..2*nr..2)
    local m2 = vector(nr):fill(1..nr)
    assertEquals( m1:outer(m2), m1*m2:t() )
  end
end

function TestMatrixErr:testCross()
  local m = matrix(3)
  local msg = {
    "invalid argument #2 (matrix expected)",
    "invalid matrix sizes"                 ,
  }
  assertErrorMsgContains( msg[1], mth, 'cross', m     , nil  )
  assertErrorMsgContains( msg[1], mth, 'cross', m     , ''   )
  assertErrorMsgContains( msg[1], mth, 'cross', m     , 1    )
  assertErrorMsgContains( msg[1], mth, 'cross', m     , 1..2 )
  assertErrorMsgContains( msg[1], mth, 'cross', m     , {}   )
  assertErrorMsgContains( msg[2], mth, 'cross', errMat, m    )
end

function TestMatrixLinAlg:testCross() --TODO: check
  -- cross prod:  uxv = |u|.|v| sin(u^v) \vec{n}
  local m1  = matrix(3):fill(0..8)   -- skew-symmetric matrix
  local m2 = vector {2,-4,2}
  local m3 = vector {2,-4,2}
  assertEquals( m2:cross(m3), m1*m3 )

  for nc=1,5 do
    m1 = matrix(3,nc):fill(1..3*nc)
    m2 = matrix(3,nc):fill(3*nc..1..-1)
    m3 = m2:copy()
    assertEquals(    m1 :cross(m2)   ,-m2  :cross( m1)              )
    assertEquals(    m1 :cross(m2+m3), m1  :cross( m2)+m1:cross(m3) )
    assertEquals( (2*m1):cross(m2)   , m1  :cross( m2*2)            )
    assertEquals( (2*m1):cross(m2)   , 2*m1:cross( m2)              )
    assertEquals( (2*m1):cross(m2)   , 2*m1:cross( m2)              )
    --assertEquals( m1:cross( m2:cross(m3) ) , m2*(m1*m3)-m3*(m1*m2)  ) -- after multiplication tests
  end
end

function TestMatrixErr:testMixed()
  local msg = {
    "invalid argument #2 (matrix expected)",
    "invalid argument #3 (matrix expected)",
    "invalid matrix sizes"                 ,
    "incompatible matrix sizes"            ,
  }
  local m1 = matrix(3,1)
  assertErrorMsgContains( msg[1], mth, 'mixed', m1, nil  )
  assertErrorMsgContains( msg[1], mth, 'mixed', m1, ''   )
  assertErrorMsgContains( msg[1], mth, 'mixed', m1, 1    )
  assertErrorMsgContains( msg[1], mth, 'mixed', m1, 1..2 )
  assertErrorMsgContains( msg[1], mth, 'mixed', m1, {}   )
  assertErrorMsgContains( msg[2], mth, 'mixed', m1, m1  , nil  )
  assertErrorMsgContains( msg[2], mth, 'mixed', m1, m1  , ''   )
  assertErrorMsgContains( msg[2], mth, 'mixed', m1, m1  , 1    )
  assertErrorMsgContains( msg[2], mth, 'mixed', m1, m1  , 1..2 )
  assertErrorMsgContains( msg[2], mth, 'mixed', m1, m1  , {}   )
  assertErrorMsgContains( msg[3], mth, 'mixed', matrix(2,1), m1, m1 )
  assertErrorMsgContains( msg[4], mth, 'mixed', matrix(3,2), m1, m1 )
  assertErrorMsgContains( msg[4], mth, 'mixed', m1, matrix(2,1), m1 )
  assertErrorMsgContains( msg[4], mth, 'mixed', m1, matrix(3,2), m1 )
  assertErrorMsgContains( msg[4], mth, 'mixed', m1, m1 ,matrix(2,1) )
  assertErrorMsgContains( msg[4], mth, 'mixed', m1, m1 ,matrix(3,2) )
end

function TestMatrixLinAlg:testMixed()
  -- x:cross(y):inner(z) without temporary
  for nc=1,5 do
    m1 = matrix(3,nc):fill(1..3*nc)
    m2 = matrix(3,nc):fill(3*nc..1..-1)
    m3 = matrix(3,nc):fill(1)
    assertEquals( m1:mixed(m2,m3), m1:cross(m2):inner(m3) )
  end
end

-- norm, unit, center, angle (in place) ---------------------------------------o

function TestMatrixLinAlg:testNorm() --|u| = sqrt(u'.u), forbidius norm
  for _,m in ipairs(G.mat) do
    assertEquals( m:norm(), sqrt(m:map(\x x^2):foldl('+')) )
  end
end

function TestMatrixErr:testDistance()
  local msg = {
    "invalid argument #2 (matrix expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'distance', errMat, nil  )
  assertErrorMsgContains( msg[1], mth, 'distance', errMat, 1..2 )
  assertErrorMsgContains( msg[1], mth, 'distance', errMat, ''   )
  assertErrorMsgContains( msg[1], mth, 'distance', errMat, {}   )
end

function TestMatrixLinAlg:testDistance()
  for _,m1 in ipairs(G.mat) do
    local m2 = m1:copy()
    assertEquals( m1:distance(m2), sqrt( ( ( m1:map2(m2,'-'))*(m1:map2(m2,'-') ):t() ):tr() ) )
  end
end

function TestMatrixErr:testUnit()
  local msg = {
    "null matrix norm",
  }
  assertErrorMsgContains( msg[1], mth, 'unit', matrix(2) )
end

function TestMatrixLinAlg:testUnit()  --  unit :  u / |u|
  for _,m in ipairs(G.mat) do
    assertEquals( m:unit(), m/m:norm() )
  end
end

function TestMatrixLinAlg:testCenter()
  for _,m in ipairs(G.mat) do
    local mid = m:sum()/m:size()
    assertEquals( m:center(),  m:map(\x x-mid) )
  end
end

function TestMatrixErr:testAngle()
  local msg = {
    "null vector norm",
  }
  assertErrorMsgContains( msg[1], mth, 'angle', vector{1,1,1}, vector{0,0,0} )
  assertErrorMsgContains( msg[1], mth, 'angle', vector{0,0,0}, vector{1,1,1} )
end

function TestMatrixLinAlg:testAngle()
  -- angle:  u^v = acos(u'.v / |u|.|v|)  in [0,pi] (or [-pi,pi] if n)
  local function unitVectors(n1, n2, r)
    local v = {}
    if is_nil(r) then r=1 end
    for i = 1, n1 do
      local a = pi*(i-1)/n1
      v[i]={}
      for j = 1, n2 do
        local b = pi*(j-1)/n2
        local x = r * cos(a) * sin(b)
        local y = r * sin(a) * sin(b)
        local z = r * cos(b)
        v[i][j] = vector{x,y,z}
      end
    end
    return v
  end

  local n, m = 16, 16
  for i,t in ipairs( unitVectors( m, n ) ) do
  for j,v in ipairs( t ) do
    assertAlmostEquals( vector{0,0,1}:angle( v ) - pi*(j-1)/n, 0,2* eps )
  end
  end
  assertEquals      ( vector{1,0,0}:angle(vector{ 1, 0, 0}), 0    )
  assertAlmostEquals( vector{1,0,0}:angle(vector{ 1, 1, 0}), pi/4, eps )
  assertAlmostEquals( vector{1,0,1}:angle(vector{ 1, 1, 0}), pi/3, eps )
  assertEquals      ( vector{1,0,0}:angle(vector{ 0, 1, 0}), pi/2 )
  assertEquals      ( vector{1,0,0}:angle(vector{-1,-1, 0}), 3*pi/4 )
  assertEquals      ( vector{1,0,0}:angle(vector{-1, 0, 0}), pi   )
  assertEquals      ( vector{0,0,1}:angle(vector{ 0, 0, 1}), 0    )
  assertEquals      ( vector{0,0,1}:angle(vector{ 0, 0,-1}), pi   )
end

-- operators ------------------------------------------------------------------o

function TestMatrixOps:testUnm()
  for _,m1 in ipairs(G.mat) do
    local m = -m1     for i=1,#m do assertEquals( m:geti(i),-i ) end
    local m = m1:unm()for i=1,#m do assertEquals( m:geti(i),-i ) end
  end
end

function TestMatrixOps:testMod()
  for _,m1 in ipairs(G.mat) do
    local m = m1:copy()
    local mres = m%m1 for i=1,#m do assertEquals( mres:geti(i), 0 ) end
  end
end

function TestMatrixOps:testPow()
  for _,m1 in ipairs(G.mat) do
    local m = m1:copy()
    local mres = m^m1 for i=1,#m do assertEquals( mres:geti(i), i^i ) end
  end
end

function TestMatrixOps:testEq() --TODO
  for _,m1 in ipairs(G.mat) do
    local m2 = m1:copy()
    local m3 = m1:same()
    assertTrue ( m1 == m2 )
    assertFalse( m1 == m3 )
  end
end

function TestMatrixErr:testAdd()
  local msg = {
    "invalid arguments (unsupported matrix operation)",
    "incompatible matrix sizes"                       ,
  }
  assertErrorMsgContains( msg[1], mth, 'add', errMat, ''   )
  assertErrorMsgContains( msg[1], mth, 'add', errMat, nil  )
  assertErrorMsgContains( msg[1], mth, 'add', errMat, 1..4 )
  assertErrorMsgContains( msg[2], mth, 'add', errMat, matrix(1) )
  assertErrorMsgContains( msg[2], mth, 'add', errMat, matrix(3) )
  --assertErrorMsgContains( msg[2], mth, 'add', errMat, matrix(2), {} )
  --assertErrorMsgContains( msg[1], mth, 'add', errMat, matrix(2), 1..4 ) --assertion fail, core dump
end

function TestMatrixOps:testAdd()
  local mres, m2, cm1
  for _,m1 in ipairs(G.mat) do
    local m2  = m1:copy()
    local cm1 = cmatrix(m1:sizes()):fill(1..m1:size()):map(\x x+x*1i)
    mres = 2  + m1  for i=1,m1:size() do assertEquals( mres:geti(i), i+2      ) end -- num + mat  => num + vec
    mres = m1 + 2   for i=1,m1:size() do assertEquals( mres:geti(i), i+2      ) end -- mat + num  => vec + num
    mres = m1 + m2  for i=1,m1:size() do assertEquals( mres:geti(i), i+i      ) end -- mat + mat  => vec + vec
    mres = m1 + 2i  for j=1,m1:size() do assertEquals( mres:geti(j), j+2i     ) end -- mat + cpx  => vec + cpx
    assertTrue( is_cmatrix(mres) )
    mres = m1 + cm1 for j=1,m1:size() do assertEquals( mres:geti(j), 2*j+j*1i ) end -- mat + cmat => vec + cvec
    assertTrue( is_cmatrix(mres) )
  end
end

function TestMatrixOps:testAddCPx()
  for _,m1 in ipairs(G.mat) do
    local mres = 2i + m1  -- cpx + mat => cpx + vec
    assertTrue( is_cmatrix(mres) )
    for i=1,m1:size() do assertEquals( mres:geti(i), i+2i ) end
  end
end

function TestMatrixErr:testSub()
  local msg = {
    "invalid arguments (unsupported matrix operation)",
    "incompatible matrix sizes"                       ,
  }
  assertErrorMsgContains( msg[1], mth, 'sub', errMat, ''   )
  assertErrorMsgContains( msg[1], mth, 'sub', errMat, nil  )
  assertErrorMsgContains( msg[1], mth, 'sub', errMat, 1..4 )
  assertErrorMsgContains( msg[2], mth, 'sub', errMat, matrix(1) )
  assertErrorMsgContains( msg[2], mth, 'sub', errMat, matrix(3) )
end

function TestMatrixOps:testSub()
  local mres, m2, cm1
  for _,m1 in ipairs(G.mat) do
    local m2  = m1:copy()
    local cm1 = cmatrix(m1:sizes()):fill(1..m1:size()):map(\x x+x*1i)
    mres = 2  - m1  for i=1,m1:size() do assertEquals( mres:geti(i), 2-i  ) end -- num - mat  => num - vec
    mres = m1 - 2   for i=1,m1:size() do assertEquals( mres:geti(i), i-2  ) end -- mat - num  => vec + -num
    mres = m1 - m2  for i=1,m1:size() do assertEquals( mres:geti(i), 0    ) end -- mat - mat  => vec - vec
    mres = m1 - 2i  for i=1,m1:size() do assertEquals( mres:geti(i), i-2i ) end -- mat - cpx  => vec + -cpx
    assertTrue( is_cmatrix(mres) )
    mres = m1 - cm1 for i=1,m1:size() do assertEquals( mres:geti(i), i*1i ) end -- mat - cmat => vec - cvec
    assertTrue( is_cmatrix(mres) )
  end
end

function TestMatrixOps:testSubCPx()
  for _,m1 in ipairs(G.mat) do
    local mres = 2i + m1     -- cpx - mat => cpx - vec
    assertTrue( is_cmatrix(mres) )
    for i=1,m1:size() do assertEquals( mres:geti(i), i+2i ) end
  end
end

function TestMatrixErr:testMul()
  local msg = {
    "invalid arguments (unsupported matrix operation)",
    "incompatible matrix sizes"                       ,
  }
  assertErrorMsgContains( msg[1], mth, 'mul', errMat, ''     )
  assertErrorMsgContains( msg[1], mth, 'mul', errMat, nil    )
  assertErrorMsgContains( msg[1], mth, 'mul', errMat, 1..4   )
  assertErrorMsgContains( msg[2], mth, 'mul', matrix(2,1), matrix(2,1) )
  assertErrorMsgContains( msg[2], mth, 'mul', matrix(1,2), matrix(1,1) )
  assertErrorMsgContains( msg[2], mth, 'mul', matrix(1,2), matrix(3,1) )
end

function TestMatrixOps:testMul()
  local ref = \m1, m2 ,i ,j => local x = 0 for ii=1,m1:ncol() do   x = x + m1:get(i,ii) * m2:get(ii,j) end return x end

  local mres, m2, cm2
  for _,m1 in ipairs(G.mat) do
    local m2  = m1:copy()
    mres = 2  * m1  for i=1,m1:size() do assertEquals( mres:geti(i), 2*i  ) end -- num * mat => num * vec
    mres = m1 * 2   for i=1,m1:size() do assertEquals( mres:geti(i), 2*i  ) end -- mat * num => vec * num
    mres = m1 * 2i  for j=1,m1:size() do assertEquals( mres:geti(j), j*2i ) end -- mat * cpx => vec * cp
    assertTrue( is_cmatrix(mres) )
  end
  for _,m1 in ipairs(G.mat) do
    local nc1 = m1:ncol()
    for i=1,5 do
      m2   = matrix(nc1,i):fill(1..nc1*i)
      mres = m1 * m2  -- mat * mat
      assertEquals( {mres:sizes()}, {m1:nrow(), m2:ncol()} )
      for i=1,m1:nrow() do
      for j=1,m2:ncol() do
        assertEquals( mres:get(i,j), ref(m1,m2,i,j) )
      end end

      cm2  = cmatrix(nc1,i):fill(1..nc1*i)
      mres = m1 * cm2 -- mat * cmat
      assertEquals( {mres:sizes()}, {m1:nrow(), cm2:ncol()} )
      assertTrue  ( is_cmatrix(mres) )
      for i=1,m1 :nrow() do
      for j=1,cm2:ncol() do
        assertEquals( mres:get(i,j), ref(m1,cm2,i,j) )
      end end
    end
  end
end

function TestMatrixOps:testMulCPx()
  for _,m1 in ipairs(G.mat) do
    local mres = 2i * m1  -- cpx * mat => cpx * vec
    for j=1,m1:size() do assertEquals( mres:geti(j), j*2i ) end
    assertTrue( is_cmatrix(mres) )
  end
end

function TestMatrixErr:testTmul()
  local msg = {
    "invalid arguments (unsupported matrix operation)",
    "incompatible matrix sizes"                       ,
  }
  assertErrorMsgContains( msg[1], mth, 'tmul', errMat, ''   )
  assertErrorMsgContains( msg[1], mth, 'tmul', errMat, nil  )
  assertErrorMsgContains( msg[1], mth, 'tmul', errMat, 1..4 )
  assertErrorMsgContains( msg[2], mth, 'tmul', matrix(2,1), matrix(1,2) )
  assertErrorMsgContains( msg[2], mth, 'tmul', matrix(1,2), matrix(3,1) )
end

function TestMatrixOps:testTmul()
  local ref = \m1, m2 ,i ,j => local x = 0 for ii=1,m1:ncol() do   x = x + m1:get(i,ii) * m2:get(ii,j) end return x end
  local mres, m2, cm1

  for _,m1 in ipairs(G.mat) do
    local nr1 = m1:nrow()
    for i=1,5 do
      m2   = matrix(nr1,i):fill(1..nr1*i)
      mres = m1:tmul(m2) -- mat' * mat
      assertEquals( {mres:sizes()}, {m1:ncol(), m2:ncol()} )
      for i=1,mres:nrow() do
      for j=1,mres:ncol() do
        assertEquals( mres:get(i,j), ref(m1:t(), m2, i, j) )
      end end

      cm2  = cmatrix(nr1,i):fill(1..nr1*i)
      mres = m1:tmul(cm2) -- mat' * cmat
      assertEquals( {mres:sizes()}, {m1:ncol(), cm2:ncol()} )
      assertTrue  ( is_cmatrix(mres) )
      for i=1,mres:nrow() do
      for j=1,mres:ncol() do
        assertEquals( mres:get(i,j), ref(m1:t(), cm2, i, j) )
      end end
    end
  end
end

function TestMatrixErr:testMult()
  local msg = {
    "invalid arguments (unsupported matrix operation)",
    "incompatible matrix sizes"                       ,
  }
  assertErrorMsgContains( msg[1], mth, 'mult', errMat, ''   )
  assertErrorMsgContains( msg[1], mth, 'mult', errMat, nil  )
  assertErrorMsgContains( msg[1], mth, 'mult', errMat, 1..4 )
  assertErrorMsgContains( msg[2], mth, 'mult', matrix(2,1), matrix(1,2) )
  assertErrorMsgContains( msg[2], mth, 'mult', matrix(1,2), matrix(3,1) )
end

function TestMatrixOps:testMult()
  local mres, m2, cm1
  local ref = \m1, m2 ,i ,j => local x = 0 for ii=1,m1:ncol() do  x = x + m1:get(i,ii) * m2:get(ii,j)end return x end

  for _,m1 in ipairs(G.mat) do
    local nr1 = m1:ncol()
    for i=1,5 do
      m2   = matrix(i,nr1):fill(1..nr1*i)
      mres = m1:mult(m2) -- mat * mat'
      assertEquals( {mres:sizes()}, {m1:nrow(), m2:nrow()} )
      for i=1,mres:nrow() do
      for j=1,mres:ncol() do
        assertEquals( mres:get(i,j), ref(m1, m2:t(), i, j) )
      end end

      cm2  = cmatrix(i,nr1):fill(1..nr1*i)
      mres = m1:mult(cm2) -- mat * cmat'
      assertEquals( {mres:sizes()}, {m1:nrow(), cm2:nrow()} )
      assertTrue  ( is_cmatrix(mres) )
      for i=1,mres:nrow() do
      for j=1,mres:ncol() do
        assertEquals( mres:get(i,j), ref(m1, cm2:t(), i, j) )
      end end
    end
  end
end

function TestMatrixErr:testDiv()
  local msg = {
    "invalid arguments (unsupported matrix operation)",
    "incompatible matrix sizes"                       ,
  }
  assertErrorMsgContains( msg[1], mth, 'div', errMat, ''   )
  assertErrorMsgContains( msg[1], mth, 'div', errMat, nil  )
  assertErrorMsgContains( msg[1], mth, 'div', errMat, 1..4 )
  assertErrorMsgContains( msg[2], mth, 'div', matrix(2,1), matrix(1,2) )
  assertErrorMsgContains( msg[2], mth, 'div', matrix(1,2), matrix(3,1) )
end

function TestMatrixOps:testDiv() -- TODO nonsquare
  local mres, mref, m1, cm1
  for _,m in ipairs(G.mat) do
    local nr, nc = m:sizes()
    --mat / num
    mres = m:div(2)
    for i=1,mres:size() do
      assertEquals( mres:geti(i), i/2 )
    end
    m1 = m:copy():random(randomseed(2))
    if nr == nc then
      mres = m1 * (1/m1)
      mref = m1:copy():eye()
      for i=1,mres:size() do assertAlmostEquals( mres:geti(i) - mref:geti(i), 0, 8*eps ) end

      local m2 = m:copy()
      mres = 1/m1 * m1 * m2
      for i=1,mres:size() do assertAlmostEquals( mres:geti(i) - m2:geti(i), 0, 128*eps ) end
    end
  end
end

function TestMatrixOps:testDivCPx() -- TODO
  for _,m1 in ipairs(G.mat) do
    local mres = 2i / m1  -- cpx / mat
    --print( mres, "\n" )
    --for j=1,m1:size() do print( mres:geti(j), j*2i ) end
    assertTrue( is_cmatrix(mres) )
  end
end

function TestMatrixErr:testEmul()
  local msg = {
    "invalid argument #2 (matrix expected)",
    "incompatible matrix sizes"            ,
  }
  assertErrorMsgContains( msg[1], mth, 'emul', errMat, ''   )
  assertErrorMsgContains( msg[1], mth, 'emul', errMat, nil  )
  assertErrorMsgContains( msg[1], mth, 'emul', errMat, 1..4 )
  assertErrorMsgContains( msg[2], mth, 'emul', errMat, matrix(1) )
  assertErrorMsgContains( msg[2], mth, 'emul', errMat, matrix(3) )
end

function TestMatrixOps:testEmul()
  for _,m1 in ipairs(G.mat) do
    local m2  = m1:copy()
    local cm1 = cmatrix(m1:sizes()):fill(1..m1:size()):map(\x x+x*1i)
    assertEquals( m1:emul(m2) , m1:map2(m2 , '*') )
    assertEquals( m1:emul(cm1), m1:map2(cm1, '*') )
    assertTrue( is_cmatrix(m1:emul(cm1)) )
  end
end

function TestMatrixErr:testEdiv()
  local msg = {
    "invalid argument #2 (matrix expected)",
    "incompatible matrix sizes"            ,
  }
  assertErrorMsgContains( msg[1], mth, 'ediv', errMat, ''   )
  assertErrorMsgContains( msg[1], mth, 'ediv', errMat, nil  )
  assertErrorMsgContains( msg[1], mth, 'ediv', errMat, 1..4 )
  assertErrorMsgContains( msg[2], mth, 'ediv', errMat, matrix(1) )
  assertErrorMsgContains( msg[2], mth, 'ediv', errMat, matrix(3) )
end

function TestMatrixOps:tetEdiv()
  for _,m1 in ipairs(G.mat) do
    local m2  = m1:copy()
    local cm1 = cmatrix(m1:sizes()):fill(1..m1:size()):map(\x x+x*1i)
    assertEquals( m1:ediv(m2) , m1:map2(m2 , '/') )
    assertEquals( m1:ediv(cm1), m1:map2(cm1, '/') )
    assertTrue( is_cmatrix(m1:ediv(cm1)) )
   end
end

-- linear algebra -------------------------------------------------------------o

function TestMatrixLapack:testSolve()
  for i,m1 in ipairs(lindat.solveIn1) do
    local m2 = lindat.solveIn2[i]
    local m3 = lindat.solveOut[i]
    for i=1,m2:size() do assertAlmostEquals( m1:solve(m2):geti(i) - m3:geti(i), 0, 2*eps ) end
  end
end

function TestMatrixErr:testSvd()
  local msg = {
    "invalid input argument" ,
    "SVD failed to converged",
  }
end

function TestMatrixLapack:testSvd()
  local ru, rs, rv, info
  for i,m in ipairs(lindat.svdIn) do
    local refU = lindat.svdU[i]
    local refS = lindat.svdS[i]:getdiag()
    local refV = lindat.svdV[i]
    ru, rs, rv, info = m:svd()
    for j=1,ru:size() do assertAlmostEquals( ru:geti(j) - refU:geti(j), 0,  3*eps ) end
    for j=1,rs:size() do assertAlmostEquals( rs:geti(j) - refS:geti(j), 0, 64*eps ) end
    for j=1,rv:size() do assertAlmostEquals( rv:geti(j) - refV:geti(j), 0,  3*eps ) end

    -- M = U*S*V'
    local m1 = ru * matrix(m:sizes()):setdiag(rs) * rv:t()
    for j=1,m1:size() do assertAlmostEquals( m1:geti(j) - m:geti(j)   , 0, 32*eps ) end
  end
end

function TestMatrixErr:testDet()
  local msg = {
    "matrix must be square",
  }
  assertErrorMsgContains( msg[1], mth, 'det', matrix(2,1) )
end

function TestMatrixLapack:testDet()
  assertEquals( matrix(2):symp():det(), 1 )
  assertEquals( matrix(2):eye() :det(), 1 )

  local M = {}
  for i=1,5 do M[i] = matrix(i):random() end
  for i,m in ipairs(M) do
    local m1 = matrix(i):random()
    assertAlmostEquals( (m*m1):det() - m:det()*m1:det(), 0,3*eps )
    assertAlmostEquals(  m:t():det() - m:det()         , 0,2*eps )
    assertAlmostEquals( (2*m) :det() - m:det()*(2^i)   , 0,  eps )
    --assertAlmostEquals( (1/m) :det() - 1/(m:det())     , 0, 1e6*eps ) --big eps check
  end
end

function TestMatrixErr:testEigen()
  local msg = {
    "matrix must be square"                  ,
    "invalid input argument"                 ,
    "eigen failed to compute all eigenvalues",
  }
  assertErrorMsgContains( msg[1], mth, 'eigen', matrix(2,1) )
  assertErrorMsgContains( msg[1], mth, 'eigen', matrix(1,3) )
end

function TestMatrixLapack:testEigen()
-- sum of eigen values and the trace should be the same (sum of diag should be
-- euqal to the sum of eigen, sum of the product should be euqal to det )

-- A*V = V*D
  local w, vl, vr, info, m
  for i=1,5,1 do
    m = matrix(i)
    w, vl, vr, info = m:eigen()
    assertEquals( w   , cvector(i)      )
    assertEquals( vl  , matrix(i):eye() )
    assertEquals( vr  , matrix(i):eye() )
    assertEquals( info, 0 )
  end
  -- upper triangle
  m = matrix{{2,1},{1,2}}
  m = matrix{{1,1,1,1},{0,2,2,2},{0,0,3,3},{0,0,0,4}}
  w, vl, vr, info = m:eigen()
  --print( m  , "\n" )
  --print( w  , "\n" )
  --print( vl , "\n" )
  --print( vr , "\n" )

  for i,m in ipairs(lindat.eigenIn) do
    w, vl, vr, info = m:eigen()
    local refD = lindat.eigenD[i]:getdiag()
    local refW = lindat.eigenW[i]
    local refV = lindat.eigenV[i]
    --assertEquals( w   :sum(), m:tr() )
    --assertEquals( refD:sum(), m:tr() )
    for j=1,w :size() do assertAlmostEquals( w :geti(j).im - refD:geti(j), 0, 32*eps ) end -- im of res, re of ref
    for j=1,vl:size() do assertAlmostEquals( vl:geti(j)    - refW:geti(j), 0,  2*eps ) end
    for j=1,vr:size() do
      --print( vr:geti(j), refV:geti(j), vr:geti(j) - refV:geti(j) )
      --print( vr:geti(j) - refV:geti(j) )
    end

  end
end

-- FFT, convolution, correlation, covrariance ---------------------------------o
  --vector sizes: 1,2,3,4,5,7,11,13,17,19,25
  --matrix sizes: (of 2,5,7 combinations)

function TestMatrixFFT:testFFT()
  for i,s in ipairs(fftdat.sv) do
    local ref = fftdat.fftVOut[i]
    local res = fftdat.fftVIn:getsub(1..s, 1):fft()
    for j=1,res:size() do
      assertAlmostEquals( res:geti(j).re - ref:geti(j).re, 0, 16*eps )
      assertAlmostEquals( res:geti(j).im - ref:geti(j).im, 0, 12*eps )
    end
  end

  for i ,s1 in ipairs(fftdat.sm) do
  for ii,s2 in ipairs(fftdat.sm) do
    local refMat = fftdat.fftMOut[ref(i,ii,3)]
    local res = fftdat.fftMIn:getsub(1..s1, 1..s2):fft()
    for j=1,res:size() do
      assertAlmostEquals( res:geti(j).re - refMat:geti(j).re, 0, 16*eps )
      assertAlmostEquals( res:geti(j).im - refMat:geti(j).im, 0, 16*eps )
    end
  end end
end

function TestMatrixFFT:testIFFT()
  for i,s in ipairs(fftdat.sv) do
    local ref = fftdat.fftVIn:getsub(1..s, 1)
    local res = ref:fft():ifft()
    for j=1,res:size() do
      assertAlmostEquals( res:geti(j).re - ref:geti(j), 0, 4*eps )
      assertAlmostEquals( res:geti(j).im              , 0,   eps )
    end
  end

  for i ,s1 in ipairs(fftdat.sm) do
  for ii,s2 in ipairs(fftdat.sm) do
    local ref = fftdat.fftMIn:getsub(1..s1, 1..s2)
    local res = ref:fft():ifft()
    for j=1,res:size() do
      assertAlmostEquals( res:geti(j).re - ref:geti(j), 0, 2*eps )
      assertAlmostEquals( res:geti(j).im,               0,   eps )
    end
  end end
end

function TestMatrixErr:testRFFT()
  local msg = {
    "incompatible matrix sizes",
  }
  assertErrorMsgContains( msg[1], mth, 'rfft', vector(1), matrix(2) )
  assertErrorMsgContains( msg[1], mth, 'rfft', matrix(3), vector(2) )
end

function TestMatrixFFT:testRFFT()
  for i,s in ipairs(fftdat.sv) do
    local ref = fftdat.fftVOut[i]
    local res = fftdat.fftVIn:getsub(1..s, 1):rfft()
    for j=1,res:size() do
      assertAlmostEquals( res:geti(j).im - ref:geti(j).im, 0, 12*eps )
    end
  end
  for i ,s1 in ipairs(fftdat.sm) do
  for ii,s2 in ipairs(fftdat.sm) do
    local refMat = fftdat.fftMOut[ref(i,ii,3)]
    local res    = fftdat.fftMIn:getsub(1..s1, 1..s2):rfft()
    local nc, nr = res:sizes()
    for ic=1,nc do
    for ir=1,nr do
      assertAlmostEquals( res:get(ic,ir).re - refMat:get(ic,ir).re, 0, 16*eps )
      assertAlmostEquals( res:get(ic,ir).im - refMat:get(ic,ir).im, 0, 16*eps )
    end end
  end end
end

function TestMatrixErr:testIRFFT()
  local msg = {
    "N.A."                     ,
    "incompatible matrix sizes",
  }
  assertErrorMsgContains( msg[1], mth, 'irfft',  vector(1), cmatrix(2) )
  assertErrorMsgContains( msg[2], mth, 'irfft', cvector(3),  matrix(1) )
end

function TestMatrixFFT:testIRFFT()
  for i,s in ipairs(fftdat.sv) do
    local ref = fftdat.fftVIn:getsub(1..s, 1)
    local res = ref:rfft():irfft()
    for j=1,res:size() do
      assertAlmostEquals( res:geti(j) - ref:geti(j), 0, 2*eps )
    end
  end

  -- 2D
  for i ,s1 in ipairs(fftdat.sm) do
  for ii,s2 in ipairs(fftdat.sm) do
    local ref = fftdat.fftMIn:getsub(1..s1, 1..s2)
    local res = ref:rfft():irfft()
    for j=1,res:size() do
      assertAlmostEquals( res:geti(j) - ref:geti(j), 0, 2*eps )
    end
  end end

  local m,res
  m   = matrix{{1,1,0},{1,1,0},{1,1,0}}
  res = m:rfft():irfft()
  for j=1,res:size() do assertAlmostEquals( res:geti(j) - m:geti(j), 0, 2*eps ) end

  --output: 3x2 matrix, to be used after changes
  --[[
  m   = matrix{{1,1,1},{1,1,1},{0,0,0}}
  res = m:rfft():irfft()
  for j=1,res:size() do assertAlmostEquals( res:geti(j) - m:geti(j), 0, 2*eps ) end

  m   = matrix{{1,1,1},{0,0,0},{1,1,1}}
  res = m:rfft():irfft()
  for j=1,res:size() do assertAlmostEquals( res:geti(j) - m:geti(j), 0, 2*eps ) end

  m   = matrix(3):eye()
  res = m:rfft():irfft()
  for j=1,res:size() do assertAlmostEquals( res:geti(j) - m:geti(j), 0, 2*eps ) end
  ]]
end

function TestMatrixErr:testConv()
  local msg = {
    "incompatible matrix sizes",
  }
  assertErrorMsgContains( msg[1], mth, 'conv',  vector(1), vector(2) )
  assertErrorMsgContains( msg[1], mth, 'conv',  matrix(1), matrix(2) )
end

-- pascal triangle helpers
local pasVal = \x   => local y = 1 for i=1,x do y = y * i end return y end
local function pasVec(x, s)
  local v = vector(x)
  for z=1,x do v:seti(z, pasVal(x-1) / (pasVal(z-1) * pasVal(x-z))) end
  return v
end

 -- convolution theorem
function TestMatrixFFT:testConv()
  -- HELP - to get full conv: nr, nc = xr+yr-1, xc+yc-1
  for i=3,8 do
    local s = (i-1)+(i-2) - 1
    local v1 = pasVec(i-1):resize(s,1)
    local v2 = pasVec(i-2):resize(s,1)
    local ref = pasVec(s)
    local res = v1:conv(v2)
    assertEquals( res, v2:conv(v1) )
    for j=1,s do
      assertAlmostEquals( res:geti(j)-ref:geti(j), 0, 51*eps )
    end
  end
end

 -- correlation theorem
function TestMatrixFFT:testCorr() -- shift needed
  for i=3,5 do
    local s = (i-1)+(i-2) - 1
    local v1 = pasVec(i-1):resize(s,1)
    local v2 = pasVec(i-2):resize(s,1)
    local res = v1:corr(v2)
    local ref = pasVec(s)

    local n = s/2+1
    for j=1  ,n do assertAlmostEquals( res:geti(j) - ref:geti(j + n-2), 0, 4*eps ) end
    for j=n+1,s do assertAlmostEquals( res:geti(j) - ref:geti(j - n  ), 0,   eps ) end
    --assertEquals( v1:corr(v2), v2:corr(v1) )
  end
  local v1 = vector{0,0,1,0,0,0}
  local v2 = vector{0,0,0,0,1,0}
  --print( v2:corr(v1) )

  local v1 = vector{1,2,3,4,5}
  --print( v1, "\n" )
  for i=1,4 do
    --print( v1:shift(i,0), "\n" )
  end

  local m1 = matrix{{1,2},{3,4}}
  --print( m1           , "\n" )
  --print( m1:shift(1,0), "\n" )
  --print( m1:shift(0,1), "\n" )
end

function TestMatrixFFT:testCovar()
  for i,s in ipairs(fftdat.sv) do
    local v1 = fftdat.fftVIn:getsub(1..s, 1):fft()
    local v2 = fftdat.fftVIn:getsub(1..s, 1):fft()
    --assertEquals( v1:covar(v2), v2:covar(v1) )
    --local res = v1:covar(v2)
  end
end

-- rotations ------------------------------------------------------------------o

function TestMatrixErr:testRot()
  local msg = {
    "invalid argument #1 (2D squared matrix expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'rot', matrix(2,1), pi )
  assertErrorMsgContains( msg[1], mth, 'rot', matrix(2,3), pi )
end

function TestMatrixErr:testRotxyz()
  local msg = {
    "invalid argument #1 (3D squared matrix expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'rotx', matrix(3,2), pi )
  assertErrorMsgContains( msg[1], mth, 'roty', matrix(3,2), pi )
  assertErrorMsgContains( msg[1], mth, 'rotz', matrix(3,2), pi )
end

function TestMatrixRot:testRot()
  local m = matrix(2)
  for i,a in ipairs(dat.rad) do
    local res = m:rot(a)
    local ref = dat.rot[i]
    for j=1,res:size() do
      assertAlmostEquals( res:geti(j) - ref:geti(j), 0, eps )
    end
  end
end

function TestMatrixRot:testRotx()
  local m = matrix(3)
  for i,ax in ipairs(dat.rad) do
    local res = m:rotx(ax)
    local ref = dat.rotx[i]
    assertEquals( res:t()*res, matrix(3):eye() )
    for j=1,res:size() do
      assertAlmostEquals( res:geti(j) - ref:geti(j), 0, eps )
    end
  end
end

function TestMatrixRot:testRoty()
  local m = matrix(3)
  for i,ay in ipairs(dat.rad) do
    local res = m:roty(ay)
    local ref = dat.roty[i]
    assertEquals( res:t()*res, matrix(3):eye() )
    for j=1,res:size() do
      assertAlmostEquals( res:geti(j) - ref:geti(j), 0, eps )
    end
  end
end

function TestMatrixRot:testRotz()
  local m = matrix(3)
  for i,az in ipairs(dat.rad) do
    local res = m:rotz(az)
    local ref = dat.rotz[i]
    assertEquals( res:t()*res, matrix(3):eye() )
    for j=1,res:size() do
      assertAlmostEquals( res:geti(j) - ref:geti(j), 0, eps )
    end
  end
end

function TestMatrixRot:testRotxy()
  for i,ax in ipairs(dat.rad) do
    for ii,ay in ipairs(dat.rad) do
      local res = matrix(3):rotxy(ax,ay)
      local ref = matrix(3):roty(ay)*matrix(3):rotx(ax)
      for j=1,res:size() do
        assertEquals( res:geti(j), ref:geti(j) )
      end
    end
  end
end

function TestMatrixRot:testRotxz()
  for i,ax in ipairs(dat.rad) do
    for ii,az in ipairs(dat.rad) do
      local res = matrix(3):rotxz(ax,az)
      local ref = matrix(3):rotz(az)*matrix(3):rotx(ax)
      for j=1,res:size() do
        assertEquals( res:geti(j), ref:geti(j) )
      end
    end
  end
end

function TestMatrixRot:testRotyz()
  for i,ay in ipairs(dat.rad) do
    for ii,az in ipairs(dat.rad) do
      local res = matrix(3):rotyz(ay,az)
      local ref = matrix(3):rotz(az)*matrix(3):roty(ay)
      for j=1,res:size() do
        assertEquals( res:geti(j), ref:geti(j) )
      end
    end
  end
end

function TestMatrixRot:testRotyx()
  for i,ay in ipairs(dat.rad) do
    for ii,ax in ipairs(dat.rad) do
      local res = matrix(3):rotyx(ay,ax)
      local ref = matrix(3):rotx(ax)*matrix(3):roty(ay)
      for j=1,res:size() do
        assertEquals( res:geti(j), ref:geti(j) )
      end
    end
  end
end

function TestMatrixRot:testRotzx()
  for i,az in ipairs(dat.rad) do
    for ii,ax in ipairs(dat.rad) do
      local res = matrix(3):rotzx(az,ax)
      local ref = matrix(3):rotx(ax)*matrix(3):rotz(az)
      for j=1,res:size() do
        assertEquals( res:geti(j), ref:geti(j) )
      end
    end
  end
end

function TestMatrixRot:testRotzy()
  for i,az in ipairs(dat.rad) do
    for ii,ay in ipairs(dat.rad) do
      local res = matrix(3):rotzy(az,ay)
      local ref = matrix(3):roty(ay)*matrix(3):rotz(az)
      for j=1,res:size() do
        assertEquals( res:geti(j), ref:geti(j) )
      end
    end
  end
end

function TestMatrixRot:testRotxyz()
  for i,ax in ipairs(dat.rad) do
    for ii,ay in ipairs(dat.rad) do
      for iii,az in ipairs(dat.rad) do
        local res = matrix(3):rotxyz(ax,ay,az)
        local ref = matrix(3):rotz(az)*matrix(3):roty(ay)*matrix(3):rotx(ax)
        for j=1,res:size() do
          assertAlmostEquals( res:geti(j) - ref:geti(j), 0, eps )
        end
      end
    end
  end
end

function TestMatrixRot:testRotzyx()
  for i,ax in ipairs(dat.rad) do
    for ii,ay in ipairs(dat.rad) do
      for iii,az in ipairs(dat.rad) do
        local res = matrix(3):rotzyx(ax,ay,az)
        local ref = matrix(3):rotx(ax)*matrix(3):roty(ay)*matrix(3):rotz(az)
        for j=1,res:size() do
          assertAlmostEquals( res:geti(j) - ref:geti(j), 0, eps )
        end
      end
    end
  end
end

function TestMatrixRot:testRotmad()
  for i,th in ipairs(dat.rad) do
    for ii,phi in ipairs(dat.rad) do
      for iii,psi in ipairs(dat.rad) do
        local res = matrix(3):rotmad(th,phi,psi)
        local ref = matrix(3):roty(th)*matrix(3):rotx(-phi)*matrix(3):rotz(psi)
        for j=1,res:size() do
          assertAlmostEquals( res:geti(j) - ref:geti(j), 0, 2*eps )
        end
      end
    end
  end
end

function TestMatrixRot:testTorotmad()
  for i,th in ipairs(dat.rad) do
    for ii,phi in ipairs(dat.rad) do
      for iii,psi in ipairs(dat.rad) do
        local a1, a2, a3 = matrix(3):rotmad(th,phi,psi):torotmad(th/2,phi/2,psi/2)
        if phi == pi then
          assertAlmostEquals( a1 - th ,-pi, eps )
          assertAlmostEquals( a2 - phi,-pi, eps )
          assertAlmostEquals( a3 - psi,-pi, eps )
        else
          assertAlmostEquals( a1 - th , 0 , eps )
          assertAlmostEquals( a2 - phi, 0 , eps )
          assertAlmostEquals( a3 - psi, 0 , eps )
        end
      end
    end
  end
end

function TestMatrixErr:testRotv()
  local msg = {
    "invalid argument #2 (iterable expected)"         ,
    "invalid argument #1 (3D squared matrix expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'rotv', matrix(3)  , pi  )
  assertErrorMsgContains( msg[2], mth, 'rotv', matrix(2,3), {1,0,0}, pi )
end

function TestMatrixRot:testRotv()
  local v = vector{0,0,1}:unit()
  for _,a in ipairs(dat.rad) do
    for _,a1 in ipairs(dat.rad) do
      for _,a2 in ipairs(dat.rad) do
        local m1  = matrix(3):rotz( a1 )
        local m2  = matrix(3):roty( a2 )
        local m3  = matrix(3):rotz( a  )
        local v1  = m1 * m2 * v

        local res = matrix(3):rotv(v1,a)
        local ref = m1 * m2 * m3 * ( m1 * m2 ):t()
        for j=1,res:size() do
          assertAlmostEquals( res:geti(j) - ref:geti(j), 0, eps )
        end
      end
    end
  end
end

function TestMatrixErr:testTorotv()
  local msg = {
    "invalid argument #2 (iterable expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'torotv', matrix(3), 1  )
end

function TestMatrixRot:testTorotv()
  local fmt = MAD.option.format
  MAD.option.format = "%.5e"
  MAD.export('tostring', true)
  print()
  print('a/pi', '', 'a1/pi', '', 'a2/pi', '', '|res|', '', '|v1|', '', 'res-v1')
  local v = vector{0,0,1}:unit()
  for _,a in ipairs(dat.rad) do
    for _,a1 in ipairs(dat.rad) do
      for _,a2 in ipairs(dat.rad) do
        local m1  = matrix(3):rotz( a1 )
        local m2  = matrix(3):roty( a2 )
        local v1  = m1 * m2 * v
        local res, ares = matrix(3):rotv(v1,a):torotv()
        assertAlmostEquals( ares - a, 0, eps )
        print( a/pi, a1/pi, a2/pi,
               res[1]-v1:geti(1), res[2]-v1:geti(2), res[3]-v1:geti(3))
          --assertAlmostEquals( res[j] - v1:geti(j), 0, eps )
      end
    end
  end
  MAD.option.format = fmt
end

function TestMatrixErr:testRotq()
local msg = {
    "invalid argument #2 (iterable expected)"         ,
    "invalid argument #1 (3D squared matrix expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'rotq', matrix(3)  , pi  )
  assertErrorMsgContains( msg[2], mth, 'rotq', matrix(2,3), {1,0,0,0} )
end

function TestMatrixRot:testRotq(
  )
  local v = vector{0,0,1}:unit()
  for _,a in ipairs(dat.rad) do
    for _,a1 in ipairs(dat.rad) do
      for _,a2 in ipairs(dat.rad) do
        local m1  = matrix(3):rotz( a1 )
        local m2  = matrix(3):roty( a2 )
        local m3  = matrix(3):rotz( a  )
        local v1  = m1 * m2 * v
        local ref = matrix(3):rotv(v1,a)

        local q   = {cos(a/2), v1[1]*sin(a/2), v1[2]*sin(a/2), v1[3]*sin(a/2) }
        local res = matrix(3):rotq(q)
        for j=1,res:size() do
          assertAlmostEquals( res:geti(j) - ref:geti(j), 0,2* eps )
        end
      end
    end
  end
end

function TestMatrixRot:testTorotq() -- TODO
  local v = vector{0,0,1}:unit()
  for _,a in ipairs(dat.rad) do
    for _,a1 in ipairs(dat.rad) do
      for _,a2 in ipairs(dat.rad) do
        local m1  = matrix(3):rotz( a1 )
        local m2  = matrix(3):roty( a2 )
        local v1  = m1 * m2 * v

        local q   = {cos(a/2), v1[1]*sin(a/2), v1[2]*sin(a/2), v1[3]*sin(a/2) }
        local res = (matrix(3):rotq(q)):torotq()
        --print(q  )
        --print(res,"\n --")
        assertAlmostEquals( res[1] - q[1], 0, eps)
      end
    end
  end
end

-- concatenation, conversion --------------------------------------------------o

function TestMatrixErr:testConcat()
  local msg = {
    "invalid argument #1 (matrix expected)"                     ,
    "invalid argument #2 (matrix expected)"                     ,
    "incompatible matrix sizes"                                 ,
    "invalid argument #3 (string 'vec', row' or 'col' expected)",
    "incompatible matrix sizes"                                 ,
  }
  assertErrorMsgContains( msg[2], mth, 'concat', errMat     , ''        )
  assertErrorMsgContains( msg[2], mth, 'concat', errMat     , nil       )
  assertErrorMsgContains( msg[2], mth, 'concat', errMat     , 1..4      )
  assertErrorMsgContains( msg[3], mth, 'concat', errMat     , matrix(1) )
  assertErrorMsgContains( msg[3], mth, 'concat', matrix(3)  , errMat    )
  assertErrorMsgContains( msg[4], mth, 'concat', errMat     , errMat     , ''    )
  assertErrorMsgContains( msg[4], mth, 'concat', errMat     , errMat     , 1     )
  assertErrorMsgContains( msg[5], mth, 'concat', matrix(1,2), matrix(3,2), 'row' )
  assertErrorMsgContains( msg[5], mth, 'concat', matrix(2,3), matrix(2,2), 'col' )
  assertErrorMsgContains( msg[5], mth, 'concat', errMat     , errMat     , 'col', matrix(3) )
end

function TestMatrix:testConcat()
  local mres
  for _,m in ipairs(G.mat) do
    local nr, nc = m:sizes()
    mres = m:concat( m )
    for i=1,#m do assertEquals( mres:geti(i)   , i )
                  assertEquals( mres:geti(i+#m), i ) end
    mres = m:concat( m, 'col', matrix(nr*2, nc) )
    for i=1,#m do assertEquals( mres:geti(i)   , i )
                  assertEquals( mres:geti(i+#m), i ) end
    mres = m:concat( m, 'vec')
    for i=1,#m do assertEquals( mres:geti(i)   , i )
                  assertEquals( mres:geti(i+#m), i ) end
    mres = m:concat( m, 'row')
    for i=1,nr do
      for j=1,nc do assertEquals( mres:get(i,j), ref(i,j,nc) ) end
      for j=1,nc do assertEquals( mres:get(i,j), ref(i,j,nc) ) end
    end
  end
end

function TestMatrixConv:testTosting()
  local tostring in MAD
  local m, c, r, nr, nc = matrix(2)
  assertTrue( is_string(tostring(m      )) )
  assertTrue( is_string(tostring(m, ''  )) )
  assertTrue( is_string(tostring(m, "\n")) )

  for i,m in ipairs(G.mat) do
    nr, nc = m:sizes()
    c, r = {}, {}
    for i=1,nr do for j=1,nc do c[j]=tostring(ref(i,j,nc)) end r[i]=table.concat(c, ' ')  end
    assertEquals( tostring(m      ), table.concat(r, '\n') )
    for i=1,nr do for j=1,nc do c[j]=tostring(ref(i,j,nc)) end r[i]=table.concat(c)       end
    assertEquals( tostring(m, ''  ), table.concat(r, '\n') )
    for i=1,nr do for j=1,nc do c[j]=tostring(ref(i,j,nc)) end r[i]=table.concat(c, "\n") end
    assertEquals( tostring(m, '\n'), table.concat(r, '\n') )
  end
end

function TestMatrixErr:testTotable()
  local msg = {
    "invalid argument #2 (table expected)"          ,
    "invalid argument #2 (table of tables expected)",
  }
  assertErrorMsgContains( msg[1], totable, errMat, ''     )
  assertErrorMsgContains( msg[1], totable, errMat, 1      )
  assertErrorMsgContains( msg[1], totable, errMat, true   )
  assertErrorMsgContains( msg[1], totable, errMat, 1..2   )
  assertErrorMsgContains( msg[1], totable, errMat, errMat )
  assertErrorMsgContains( msg[2], totable, errMat, {{},5} )
end

function TestMatrixConv:testTotable()
  assertTrue( is_table(totable( matrix(2))) )
  for i,m in ipairs(G.mat) do
    local nr, nc = m:sizes()
    local tref   = totable(m)
    if nc ~=1 then
      for i=1,nr do for j=1,nc do assertEquals( tref[i][j], ref(i,j,nc) ) end end
    else
      for i=1,nr do               assertEquals( tref[i]   , ref(i,1,nc) ) end
    end
    assertTrue  ( is_table(totable( m))  )
    assertEquals( matrix(totable(m )), m )
  end
end

-- performance test suite -----------------------------------------------------o

Test_Matrix = {}

--fill benchmark
function Test_Matrix:testFillGen2()
  local m = matrix(2)
  local r = 1..4
  local t0 = os.clock()
  for i=1,1e7 do
    m:fill(r)
  end
  local dt = os.clock() - t0
  assertAlmostEquals( dt, 0.5, 1 )
end

function Test_Matrix:testFillScal2()
  local m = matrix(2)
  local t0 = os.clock()
  for i=1,1e7 do
    m:fill(1)
  end
  local dt = os.clock() - t0
  assertAlmostEquals( dt, 0.5, 1 )
end

function Test_Matrix:testFillTab2()
  local m = matrix(2)
  local t = {1,2,3,4}
  local t0 = os.clock()
  for i=1,1e7 do
    m:fill(t)
  end
  local dt = os.clock() - t0
  assertAlmostEquals( dt, 0.5, 1 )
end

function Test_Matrix:testFillGen3()
  local m = matrix(3)
  local r = 1..9
  local t0 = os.clock()
  for i=1,1e7 do
    m:fill(r)
  end
  local dt = os.clock() - t0
  assertAlmostEquals( dt, 0.5, 1 )
end

function Test_Matrix:testFillScal3()
  local m = matrix(3)
  local t0 = os.clock()
  for i=1,1e7 do
    m:fill(1)
  end
  local dt = os.clock() - t0
  assertAlmostEquals( dt, 0.5, 1 )
end

function Test_Matrix:testFillTab3()
  local m = matrix(3)
  local t = {1,2,3,4,5,6,7,8,9}
  local t0 = os.clock()
  for i=1,1e7 do
    m:fill(t)
  end
  local dt = os.clock() - t0
  assertAlmostEquals( dt, 0.5, 1 )
end

-- end ------------------------------------------------------------------------o

