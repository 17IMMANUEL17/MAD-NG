--[=[
 o-----------------------------------------------------------------------------o
 |
 | MTable tests
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 |          A. Bloch,  aurelien.bloch at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide regression test suites for the mtable module.

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local assertFalse, assertTrue, assertNil, assertNotNil, assertEquals,
  assertStrContains, assertErrorMsgContains                      in MAD.utest
local mtable, filesys                                            in MAD
local is_table, is_vector, is_mtable, is_number                  in MAD.typeid
local abs, eps, pi, random                                       in MAD.gmath

local generate = false
local refdir   = \s -> "mtable_ref/"..s
local rundir   = \s -> "mtable_run/"..s
local _msg     = {
  "invalid write access to readonly mtable",
  "nil reference value",
  "invalid write access to readonly mtable",
}
-- helpers --------------------------------------------------------------------o

local function getEmptyTables()
  local tbl1  = mtable "tbl1" { "x", "y", "z" }
  local tbl2  = mtable "tbl2" { {"dict"}, "x", "y", "z" }
  local tbl3  = mtable "tbl3" { "x", "y", "z", {"dict"} }
  return tbl1, tbl2, tbl3
end

local function getRows(i)
  i = i or 1
  local row1 = { i        , -i, pi*i            }
  local row2 = { 'name'..i, -i, pi*i, i         }
  local row3 = { i        , -i, pi*i, 'name'..i }
  return row1, row2, row3
end

local function getCols(n)
  n = n or 4
  local coli, col2, col3, coldict = {}, {}, {}, {}
  for i=1,n do
    coli[i]    =  i
    col2[i]    = -i
    col3[i]    =  i*pi
    coldict[i] = (i == 2) and "name2" or "name1"
  end
  return coli, col2, col3, coldict
end

local function getIdxTbl()
  local tbl1, tbl2,  tbl3   = getEmptyTables()
  local row11, row21, row31 = getRows(1)
  local row12, row22, row32 = getRows(2)
  local row13, row23, row33 = getRows(3)
  local row14, row24, row34 = getRows(4)
  row21[1] = "name1"; row31[4] = "name1"
  row22[1] = "name2"; row32[4] = "name2"
  row23[1] = "name1"; row33[4] = "name1"
  row24[1] = "name1"; row34[4] = "name1"
  tbl1:addrow(row11); tbl2:addrow(row21); tbl3:addrow(row31)
  tbl1:addrow(row12); tbl2:addrow(row22); tbl3:addrow(row32)
  tbl1:addrow(row13); tbl2:addrow(row23); tbl3:addrow(row33)
  tbl1:addrow(row14); tbl2:addrow(row24); tbl3:addrow(row34)
  return tbl1, tbl2, tbl3
end

local function assertVecEquals (actual, expected)
  for i=1,#expected do
    assertEquals(actual[i], expected[i])
  end
end

local function assertFiles (name)
  if generate then return end
  local ref  = assert(io.open(refdir(name), "r"))
  local run  = assert(io.open(rundir(name), "r"))
  local reftbl, sref = string.splitall(ref:read("*all"), " \n,:;[]")
  local runtbl, srun = string.splitall(run:read("*all"), " \n,:;[]")
  assertEquals(sref, srun)
  for i=1,sref do
    reftbl[i] = tonumber(reftbl[i]) or reftbl[i]
    runtbl[i] = tonumber(runtbl[i]) or runtbl[i]
    if is_number(reftbl[i]) then
      local approx = abs(runtbl[i]-reftbl[i])
      if 14*eps < approx then
        local div = min(runtbl[i], reftbl[i])
        if div == 0 then
          assertAlmostEquals(approx, 0, 1.1e-5)
        else
          assertAlmostEquals((runtbl[i]-reftbl[i])/div, 0, 1.1e-6)
        end
      end
    else
      assertEquals(runtbl[i], reftbl[i])
    end
  end
  if not generate then os.remove(rundir(name)) end
end

local function testWrite(tbl, filnam_, colnam_, hdrnam_)
  tbl:write(rundir(filnam_), colnam_, hdrnam_)
  if string.sub(filnam_,-4) ~= '.tfs' then filnam_ = filnam_ .. '.tfs' end
  assertFiles(filnam_)
end

local function newrow(i)
  return { 'name'..i, i, -i, pi*i }
end

local function newtbl(n)
  local t = mtable { {'name'}, 'x', 'y', 'z' }
  for i=1,n do t = t+newrow(i) end
  return t
end

local function chkrow(tbl, i)
    local x = tbl.x[i]
    assertEquals(tbl.x[i],    x)
    assertEquals(tbl.y[i],   -x)
    assertEquals(tbl.z[i], pi*x)
    assertEquals(tbl[i].name, 'name'..x)
end

local function checktbl(tbl, n)
  assertEquals(#tbl, n)
  for i=1,n do chkrow(tbl, i) end
  tbl:check_index()
end

-- regression test suite ------------------------------------------------------o

TestMTable = {}

function TestMTable:testCtor0()
  local t = newtbl(0)
  -- print() t:write()
  checktbl(t, 0)
end

function TestMTable:testCtor1()
  local t = newtbl(1)
  -- print() t:write()
  checktbl(t, 1)
end

function TestMTable:testCtorN()
  local t = newtbl(10)
  -- print() t:write()
  checktbl(t, 10)
end

function TestMTable:testAddRow0()
  local t = newtbl(0)
  t:addrow(newrow(0))
  -- print() t:write()
  checktbl(t, 1)
end

function TestMTable:testAddRow1()
  local t = newtbl(1)
  t:addrow(newrow(1))
  -- print() t:write()
  checktbl(t, 2)
end

function TestMTable:testAddRowN()
  local t = newtbl(10)
  t:addrow(newrow(11))
  -- print() t:write()
  checktbl(t, 11)
end

function TestMTable:testInsRow1()
  local t = newtbl(1)
  t:insrow('name1', newrow(0))
  -- print() t:write()
  checktbl(t, 2)
end

function TestMTable:testInsRowN()
  local t = newtbl(10)
  t:insrow('name1' , newrow(0))
  t:insrow('name3' , newrow(2.5))
  t:insrow('name10', newrow(9.5))
  -- print() t:write()
  checktbl(t, 13)
end

function TestMTable:testRemRow1()
  local t = newtbl(1)
  t:remrow'name1'
  -- print() t:write()
  checktbl(t, 0)
end

function TestMTable:testRemRowN()
  local t = newtbl(10)
  t:remrow'name1'
  t:remrow'name5'
  t:remrow'name10'
  -- print() t:write()
  checktbl(t, 7)
end

function TestMTable:testRemoveRow0()
  local t = newtbl(0)
  local sel = {name1=1}
  t:remove { select=\r -> sel[r.name] }
  -- print() t:write()
  checktbl(t, 0)
end

function TestMTable:testRemoveRow1()
  local t = newtbl(1)
  local sel = {name1=1}
  t:remove { select=\r -> sel[r.name] }
  -- print() t:write()
  checktbl(t, 0)
end

function TestMTable:testRemoveRowN()
  local t = newtbl(10)
  local sel = {name1=1, name2=1, name5=1, name6=1, name7=1, name9=1,name10=1}
  t:remove { select=\r -> sel[r.name] }
  -- print() t:write()
  checktbl(t, 3)
end

function TestMTable:testRemoveRow1st()
  local t = newtbl(10)
  local sel = {name1=1}
  t:remove { select=\r -> sel[r.name] }
  -- print() t:write()
  checktbl(t, 9)
end

function TestMTable:testRemoveRowNth()
  local t = newtbl(10)
  local sel = {name10=1}
  t:remove { select=\r -> sel[r.name] }
  -- print() t:write()
  checktbl(t, 9)
end

function TestMTable:testNameOf()
  local t = newtbl(10)
  for i=1,5 do t:insrow(5, newrow(5)) end
  -- print() t:write()
  checktbl(t, 15)
  for i=1,2 do assertEquals(t:name_of(4+i, 7), 'name5{'..(i-3)..'}') end
  for i=3,5 do assertEquals(t:name_of(4+i, 7), 'name5{'..(i-2)..'}') end
end

-------------------------------------------------------------------------------o

function TestMTable:testConstructor()
  local tbl1  = mtable "tbl1"  { }
  local tbl2  = mtable "tbl2"  { "x", "y", "z" }
  local tbl3  = mtable "tbl3"  { {"dict"}, "x", "y", "z" }
  local tbl4  = mtable "tbl4"  { "x", "y", "z", {"dict"} }
  local tbl42 = tbl4   "tbl42" { }

  assertEquals(#tbl1,  0)
  assertEquals(#tbl2,  0)
  assertEquals(#tbl3,  0)
  assertEquals(#tbl4,  0)
  assertEquals(#tbl42, 0)

  assertEquals(tbl1.name, "tbl1")
  assertEquals(tbl2.name, "tbl2")
  assertEquals(tbl3.name, "tbl3")
  assertEquals(tbl4.name, "tbl4")
  assertEquals(tbl42.name, "tbl42")

  for _,col in ipairs{"x", "y", "z"} do
    assertNil(tbl1[col])
    assertNotNil(tbl2[col])
    assertNotNil(tbl3[col])
    assertNotNil(tbl4[col])
    assertNotNil(tbl42[col])
  end

  assertNotNil(tbl3.dict)
  assertNotNil(tbl4.dict)
  assertNotNil(tbl42.dict)
end

function TestMTable:testIsMtable()
  local tbl1  = mtable "tbl1"  { }
  local tbl2  = mtable "tbl2"  { "x", "y", "z" }
  local tbl3  = mtable "tbl3"  { {"dict"}, "x", "y", "z" }
  local tbl32 = tbl3   "tbl32" { }
  assertTrue(is_mtable(mtable))
  assertTrue(is_mtable(tbl1))
  assertTrue(is_mtable(tbl2))
  assertTrue(is_mtable(tbl3))
  assertTrue(is_mtable(tbl32))
end

function TestMTable:testIsOwner()
  local tbl1  = mtable "tbl1"  { }
  local tbl2  = mtable "tbl2"  { "x", "y", "z" }
  local tbl3  = mtable "tbl3"  { {"dict"}, "x", "y", "z" }
  local tbl32 = tbl3   "tbl32" { }
  assertTrue(mtable:is_owner())
  assertFalse(tbl1:is_owner())
  assertTrue(tbl2:is_owner())
  assertTrue(tbl3:is_owner())
  assertFalse(tbl32:is_owner())
end

function TestMTable:testIsView()
  local tbl1  = mtable "tbl1"  { }
  local tbl2  = mtable "tbl2"  { "x", "y", "z" }
  local tbl3  = mtable "tbl3"  { {"dict"}, "x", "y", "z" }
  local tbl32 = tbl3   "tbl32" { }
  assertFalse(mtable:is_view())
  assertTrue(tbl1:is_view())
  assertFalse(tbl2:is_view())
  assertFalse(tbl3:is_view())
  assertTrue(tbl32:is_view())
end

function TestMTable:testAddOperator()
  local tbl1, tbl2, tbl3 = getEmptyTables()
  local row1, row2, row3 = getRows()
  local tbl22 = tbl2   "tbl22" { }
  local tbl4  = mtable "tbl4"  { }
  local add = \a,b -> a + b

  tbl1  = tbl1  + row1
  tbl2  = tbl2  + row2
  tbl22 = tbl22 + row2
  tbl3  = tbl3  + row3
  assertErrorMsgContains(_msg[1], add, mtable, row2)
  assertErrorMsgContains(_msg[1], add, tbl4  , row2)

  assertEquals(#tbl1  , 1)
  assertEquals(#tbl2  , 2)
  assertEquals(#tbl3  , 1)
  assertEquals(#tbl4  , 0)
  assertEquals(#tbl22 , 2)
  assertEquals(#mtable, 0)
end

function TestMTable:testAddRow1st()
  local tbl1, tbl2, tbl3 = getEmptyTables()
  local row1, row2, row3 = getRows()
  local tbl22 = tbl2   "tbl22" { }
  local tbl4  = mtable "tbl4"  { }

  tbl1 :addrow(row1)
  tbl2 :addrow(row2)
  tbl22:addrow(row2)
  tbl3 :addrow(row3)
  assertErrorMsgContains(_msg[1], mtable.addrow, mtable, row2)
  assertErrorMsgContains(_msg[1], mtable.addrow, tbl4  , row2)

  assertEquals(#tbl1  , 1)
  assertEquals(#tbl2  , 2)
  assertEquals(#tbl3  , 1)
  assertEquals(#tbl4  , 0)
  assertEquals(#tbl22 , 2)
  assertEquals(#mtable, 0)
end

function TestMTable:testGetSimple()
  local tbl1, tbl2, tbl3 = getEmptyTables()
  local row1, row2, row3 = getRows()
  tbl1:addrow(row1); tbl2:addrow(row2); tbl3:addrow(row3)
  for i,v in ipairs(row1) do assertEquals(tbl1:get(1, i), row1[i]) end
  for i,v in ipairs(row2) do assertEquals(tbl2:get(1, i), row2[i]) end
  for i,v in ipairs(row3) do assertEquals(tbl3:get(1, i), row3[i]) end
end

function TestMTable:testAddRows()
  local tbl1, tbl2, tbl3 = getEmptyTables()
  local tbl22 = tbl2   "tbl22" { }
  for i=1,10 do
    local row1, row2, row3 = getRows(i)
    tbl1:addrow(row1) ; tbl2:addrow(row2) ; tbl3:addrow(row3)
    tbl1:check_index(); tbl2:check_index(); tbl3:check_index()
    tbl22:check_index()
  end
  for i=1,10 do
    local row1, row2, row3 = getRows(i)
    for j=1,3 do assertEquals(tbl1:get(i, j), row1[j]) end
    for j=1,4 do
      assertEquals(tbl2 :get(i, j), row2[j])
      assertEquals(tbl22:get(i, j), row2[j])
      assertEquals(tbl3 :get(i, j), row3[j])
    end
  end
end

function TestMTable:testAddRowIni()
  local tbl1, tbl2, tbl3 = getEmptyTables()
  local tbl22 = tbl2   "tbl22" { }
  tbl1:addrow({ 5, 5, 5, 5, 1      , 2, 3         }, 5)
  tbl2:addrow({ 5, 5, 5, 5, "name1", 1, 2, 3      }, 5)
  tbl3:addrow({ 5, 5, 5, 5, 1      , 2, 3, "name1"}, 5)
  for i,v in ipairs{1      ,2,3  } do assertEquals(tbl1:get(1,i), v) end
  for i,v in ipairs{"name1",1,2,3} do
    assertEquals(tbl2 :get(1,i), v)
    assertEquals(tbl22:get(1,i), v)
  end
  for i,v in ipairs{1,2,3,"name1"} do assertEquals(tbl3:get(1,i), v) end
end

function TestMTable:testAddRowNil()
  local tbl1, tbl2, tbl3 = getEmptyTables()

  tbl1:addrow{ }
  assertErrorMsgContains(_msg[2], mtable.addrow, tbl2, { })
  assertErrorMsgContains(_msg[2], mtable.addrow, tbl3, { })

  assertEquals(#tbl1, 1)
  assertEquals(#tbl2, 0)
  assertEquals(#tbl3, 0)
  for j=1,3 do assertEquals(tbl1:get(1,j), nil) end

  assertErrorMsgContains(_msg[2], mtable.addrow, tbl2, {  })
  assertErrorMsgContains(_msg[2], mtable.addrow, tbl3, {  })
  tbl2:addrow { "name1", nil, nil, nil     }
  tbl3:addrow {     nil, nil, nil, "name1" }
  assertEquals(#tbl2, 1)
  assertEquals(#tbl3, 1)
  for j=1,3 do
    assertEquals(tbl2:get(1,j+1), nil)
    assertEquals(tbl3:get(1,j  ), nil)
  end
end

function TestMTable:testIndexOfInt()
  local tbl1, tbl2, tbl3  = getEmptyTables()
  local msg = {
    "invalid argument #2 (integer or string expected)",
  }
  for i=1,4 do
    local row1, row2, row3 = getRows(i)
    tbl1:addrow(row1);
    tbl2:addrow(row2);
    tbl3:addrow(row3);
  end
  for i, tbl in ipairs{tbl1, tbl2, tbl3} do
    assertNil(tbl:index_of(0   ))
    assertNil(tbl:index_of(5   ))
    assertNil(tbl:index_of(100 ))
    assertNil(tbl:index_of(-100))
    assertEquals(tbl:index_of(1) , 1)
    assertEquals(tbl:index_of(4) , 4)
    assertEquals(tbl:index_of(-1), 4)
    assertEquals(tbl:index_of(-3), 2)
    assertErrorMsgContains(msg[1], mtable.index_of, tbl, 1.5)
  end
end

function TestMTable:testIndexOfString()
  local _, tbl2, tbl3 = getIdxTbl()

  for i,tbl in ipairs{tbl2, tbl3} do
    assertNil   (tbl:index_of("name100  "   )   )
    assertNil   (tbl:index_of("name1[4] "   )   )
    assertNil   (tbl:index_of("name2[2] "   )   )
    assertNil   (tbl:index_of("name1[-4]"   )   )
    assertNil   (tbl:index_of("name2[-2]"   )   )
    assertNil   (tbl:index_of("name1{3} ", 2)   )
    assertNil   (tbl:index_of("name1{3} ",-3)   )
    assertNil   (tbl:index_of("name1{-2}", 1)   )
    assertNil   (tbl:index_of("name1{-2}",-4)   )
    assertNil   (tbl:index_of("name1{-3}", 3)   )
    assertNil   (tbl:index_of("name1{-3}",-2)   )
    assertEquals(tbl:index_of("name1"       ), 1)
    assertEquals(tbl:index_of("name2"       ), 2)
    assertEquals(tbl:index_of("name1[1]"    ), 1)
    assertEquals(tbl:index_of("name2[1]"    ), 2)
    assertEquals(tbl:index_of("name1[2]"    ), 3)
    assertEquals(tbl:index_of("name1[3]"    ), 4)
    assertEquals(tbl:index_of("name1[-1]"   ), 4)
    assertEquals(tbl:index_of("name2[-1]"   ), 2)
    assertEquals(tbl:index_of("name1[-3]"   ), 1)
    assertEquals(tbl:index_of("name1{1}" , 1), 1)
    assertEquals(tbl:index_of("name1{1}" ,-4), 1)
    assertEquals(tbl:index_of("name1{1}" , 2), 3)
    assertEquals(tbl:index_of("name1{1}" ,-3), 3)
    assertEquals(tbl:index_of("name1{2}" , 2), 4)
    assertEquals(tbl:index_of("name1{2}" ,-3), 4)
    assertEquals(tbl:index_of("name1{-1}", 2), 1)
    assertEquals(tbl:index_of("name1{-1}",-3), 1)
    assertEquals(tbl:index_of("name1{-1}", 1), 1)
    assertEquals(tbl:index_of("name1{-1}",-4), 1)
    assertEquals(tbl:index_of("name1{-2}", 3), 1)
    assertEquals(tbl:index_of("name1{-2}",-2), 1)
    assertEquals(tbl:index_of("name1{-1}", 3), 3)
    assertEquals(tbl:index_of("name1{-1}",-2), 3)
    assertEquals(tbl:index_of("name1{-2}", 4), 3)
    assertEquals(tbl:index_of("name1{-2}",-1), 3)
    assertEquals(tbl:index_of("name1{-3}", 4), 1)
    assertEquals(tbl:index_of("name1{-3}",-1), 1)
    assertEquals(tbl:index_of("name2{-1}", 3), 2)
    assertEquals(tbl:index_of("name2{-1}",-2), 2)
  end
end

function TestMTable:testIndexOfStringNoDict()
  local tbl1 = getIdxTbl()
  local msg  = {
    "no reference column found",
  }
  assertErrorMsgContains(msg[1], mtable.index_of, tbl1, "name1"      )
  assertErrorMsgContains(msg[1], mtable.index_of, tbl1, "name1[1]"   )
  assertErrorMsgContains(msg[1], mtable.index_of, tbl1, "name1{1}", 1)
end

function TestMTable:testNameOfDirect()
  local _, tbl2, tbl3  = getEmptyTables()
  local msg = {
    "invalid argument #2 (integer expected)",
  }
  for i=1,4 do
    local _, row2, row3 = getRows(i)
    tbl2:addrow(row2);
    tbl3:addrow(row3);
  end
  for i, tbl in ipairs{tbl2, tbl3} do
    assertNil(tbl:name_of(0   ))
    assertNil(tbl:name_of(5   ))
    assertNil(tbl:name_of(100 ))
    assertNil(tbl:name_of(-100))
    assertEquals(tbl:name_of(1) , "name1")
    assertEquals(tbl:name_of(4) , "name4")
    assertEquals(tbl:name_of(-1), "name4")
    assertEquals(tbl:name_of(-3), "name2")
    assertErrorMsgContains(msg[1], mtable.name_of, tbl, 1.5)
  end
end

function TestMTable:testNameOfCnt()
  local _, tbl2, tbl3 = getIdxTbl()
  for i,tbl in ipairs{tbl2, tbl3} do
    assertEquals(tbl:name_of(2   ), "name2"    )
    assertEquals(tbl:name_of(1   ), "name1[1]" )
    assertEquals(tbl:name_of(3   ), "name1[2]" )
    assertEquals(tbl:name_of(4   ), "name1[3]" )
    assertEquals(tbl:name_of(1, 1), "name1{1}" )
    assertEquals(tbl:name_of(1,-4), "name1{1}" )
    assertEquals(tbl:name_of(3, 2), "name1{1}" )
    assertEquals(tbl:name_of(3,-3), "name1{1}" )
    assertEquals(tbl:name_of(4, 2), "name1{2}" )
    assertEquals(tbl:name_of(4,-3), "name1{2}" )
    assertEquals(tbl:name_of(1, 2), "name1{-1}")
    assertEquals(tbl:name_of(1,-3), "name1{-1}")
    assertEquals(tbl:name_of(1, 3), "name1{-1}")
    assertEquals(tbl:name_of(1,-2), "name1{-1}")
    assertEquals(tbl:name_of(1, 4), "name1{-2}")
    assertEquals(tbl:name_of(1,-1), "name1{-2}")
  end
end

function TestMTable:testNameOfCntNoDict()
  local tbl1  = getIdxTbl()
  local msg   = {
    "no reference column found",
  }
  assertErrorMsgContains(msg[1], mtable.name_of, tbl1, 2   )
  assertErrorMsgContains(msg[1], mtable.name_of, tbl1, 1   )
  assertErrorMsgContains(msg[1], mtable.name_of, tbl1, 1, 1)
end

function TestMTable:testRangeOfInt()
  local tbl1, tbl2, tbl3  = getEmptyTables()
  local msg = {
    "invalid range start",
    "invalid argument #2 (integer, string, table or range expected)",
  }
  for i=1,4 do
    local row1, row2, row3 = getRows(i)
    tbl1:addrow(row1);
    tbl2:addrow(row2);
    tbl3:addrow(row3);
  end
  for i, tbl in ipairs{tbl1, tbl2, tbl3} do
    assertEquals(table.pack(tbl:range_of(1 )), {1,1, n=2})
    assertEquals(table.pack(tbl:range_of(4 )), {4,4, n=2})
    assertEquals(table.pack(tbl:range_of(-1)), {4,4, n=2})
    assertEquals(table.pack(tbl:range_of(-3)), {2,2, n=2})
    assertErrorMsgContains(msg[1], mtable.range_of, tbl, 0  )
    assertErrorMsgContains(msg[1], mtable.range_of, tbl, 5  )
    assertErrorMsgContains(msg[1], mtable.range_of, tbl, 100)
    assertErrorMsgContains(msg[1], mtable.range_of, tbl,-100)
    assertErrorMsgContains(msg[2], mtable.range_of, tbl, 1.5)
  end
end

function TestMTable:testRangeOfStringInt()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local tpack         = table.pack
  for i,tbl in ipairs{tbl1, tbl2, tbl3} do
    assertEquals(tpack(tbl:range_of(" 1/ 1")), {1,1, n=2})
    assertEquals(tpack(tbl:range_of(" 1/-1")), {1,4, n=2})
    assertEquals(tpack(tbl:range_of(" 2/ 2")), {2,2, n=2})
    assertEquals(tpack(tbl:range_of("-1/ 1")), {4,1, n=2})
    assertEquals(tpack(tbl:range_of("-1/ 4")), {4,4, n=2})
    assertEquals(tpack(tbl:range_of(" 4/-1")), {4,4, n=2})
    assertEquals(tpack(tbl:range_of(" 1/ 1")), {1,1, n=2})
    assertEquals(tpack(tbl:range_of("-1/ 1")), {4,1, n=2})
    assertEquals(tpack(tbl:range_of(" 2/ 2")), {2,2, n=2})
    assertEquals(tpack(tbl:range_of(" 1/-1")), {1,4, n=2})
    assertEquals(tpack(tbl:range_of(" 4/-1")), {4,4, n=2})
    assertEquals(tpack(tbl:range_of("-1/ 4")), {4,4, n=2})
  end
end

function TestMTable:testRangeOfStringPositive()
  local _, tbl2, tbl3 = getIdxTbl()
  for i,tbl in ipairs{tbl2, tbl3} do
    assertEquals(table.pack(tbl:range_of("name1    /name1    "   )), {1,1, n=2})
    assertEquals(table.pack(tbl:range_of("name1    /name2    "   )), {1,2, n=2})
    assertEquals(table.pack(tbl:range_of("name1[2] /name1[2] "   )), {3,3, n=2})
    assertEquals(table.pack(tbl:range_of("name1[-2]/name1[-2]"   )), {3,3, n=2})
    assertEquals(table.pack(tbl:range_of("name1[1] /name1[3] "   )), {1,4, n=2})
    assertEquals(table.pack(tbl:range_of("name1[-3]/name1[-1]"   )), {1,4, n=2})
    assertEquals(table.pack(tbl:range_of("name1[2] /name1[3] "   )), {3,4, n=2})
    assertEquals(table.pack(tbl:range_of("name1[-2]/name1[-1]"   )), {3,4, n=2})
    assertEquals(table.pack(tbl:range_of("name1[1] /name1[-1]"   )), {1,4, n=2})
    assertEquals(table.pack(tbl:range_of("name1{1} /name1{2} ", 2)), {3,4, n=2})
    assertEquals(table.pack(tbl:range_of("name1{1} /name1{2} ",-3)), {3,4, n=2})
    assertEquals(table.pack(tbl:range_of("name1{1} /name1{2} ", 3)), {3,4, n=2})
    assertEquals(table.pack(tbl:range_of("name1{1} /name1{2} ",-2)), {3,4, n=2})
    assertEquals(table.pack(tbl:range_of("name1{-1}/name1{1} ", 3)), {3,3, n=2})
    assertEquals(table.pack(tbl:range_of("name1{-1}/name1{1} ",-2)), {3,3, n=2})
    assertEquals(table.pack(tbl:range_of("name1{-2}/name1{-1}", 4)), {3,4, n=2})
    assertEquals(table.pack(tbl:range_of("name1{-2}/name1{-1}",-1)), {3,4, n=2})
    assertEquals(table.pack(tbl:range_of("name1{-1}/name1{1} ", 2)), {1,3, n=2})
    assertEquals(table.pack(tbl:range_of("name1{-1}/name1{1} ",-3)), {1,3, n=2})
    assertEquals(table.pack(tbl:range_of("name1{-1}/name1{2} ", 2)), {1,4, n=2})
    assertEquals(table.pack(tbl:range_of("name1{-1}/name1{2} ",-3)), {1,4, n=2})
    assertEquals(table.pack(tbl:range_of("name1[2] /name1{2} ", 2)), {3,4, n=2})
    assertEquals(table.pack(tbl:range_of("name1[2] /name1{2} ",-3)), {3,4, n=2})
    assertEquals(table.pack(tbl:range_of("name1[-2]/name1{2} ", 2)), {3,4, n=2})
    assertEquals(table.pack(tbl:range_of("name1[-2]/name1{2} ",-3)), {3,4, n=2})
    assertEquals(table.pack(tbl:range_of("name1{-1}/name1[3] ", 2)), {1,4, n=2})
    assertEquals(table.pack(tbl:range_of("name1{-1}/name1[3] ",-3)), {1,4, n=2})
    assertEquals(table.pack(tbl:range_of("name1{1} /name1[3] ", 2)), {3,4, n=2})
    assertEquals(table.pack(tbl:range_of("name1{1} /name1[3] ",-3)), {3,4, n=2})
  end
end

function TestMTable:testRangeOfStringNegative()
  local _, tbl2, tbl3 = getIdxTbl()
  for i,tbl in ipairs{tbl2, tbl3} do
    assertEquals(table.pack(tbl:range_of("name2    /name1    "   )), {2,1, n=2})
    assertEquals(table.pack(tbl:range_of("name1[3] /name1[1] "   )), {4,1, n=2})
    assertEquals(table.pack(tbl:range_of("name1[-1]/name1[-3]"   )), {4,1, n=2})
    assertEquals(table.pack(tbl:range_of("name1[3] /name1[2] "   )), {4,3, n=2})
    assertEquals(table.pack(tbl:range_of("name1[-1]/name1[-2]"   )), {4,3, n=2})
    assertEquals(table.pack(tbl:range_of("name1[-1]/name1[1] "   )), {4,1, n=2})
    assertEquals(table.pack(tbl:range_of("name1{2} /name1{1} ", 2)), {4,3, n=2})
    assertEquals(table.pack(tbl:range_of("name1{2} /name1{1} ",-3)), {4,3, n=2})
    assertEquals(table.pack(tbl:range_of("name1{2} /name1{1} ", 3)), {4,3, n=2})
    assertEquals(table.pack(tbl:range_of("name1{2} /name1{1} ",-2)), {4,3, n=2})
    assertEquals(table.pack(tbl:range_of("name1{-1}/name1{-2}", 4)), {4,3, n=2})
    assertEquals(table.pack(tbl:range_of("name1{-1}/name1{-2}",-1)), {4,3, n=2})
    assertEquals(table.pack(tbl:range_of("name1{1}/name1{-1} ", 2)), {3,1, n=2})
    assertEquals(table.pack(tbl:range_of("name1{1}/name1{-1} ",-3)), {3,1, n=2})
    assertEquals(table.pack(tbl:range_of("name1{2}/name1{-1} ", 2)), {4,1, n=2})
    assertEquals(table.pack(tbl:range_of("name1{2}/name1{-1} ",-3)), {4,1, n=2})
    assertEquals(table.pack(tbl:range_of("name1{2}/name1[2]  ", 2)), {4,3, n=2})
    assertEquals(table.pack(tbl:range_of("name1{2}/name1[2]  ",-3)), {4,3, n=2})
    assertEquals(table.pack(tbl:range_of("name1{2}/name1[-2] ", 2)), {4,3, n=2})
    assertEquals(table.pack(tbl:range_of("name1{2}/name1[-2] ",-3)), {4,3, n=2})
    assertEquals(table.pack(tbl:range_of("name1[3]/name1{-1} ", 2)), {4,1, n=2})
    assertEquals(table.pack(tbl:range_of("name1[3]/name1{-1} ",-3)), {4,1, n=2})
    assertEquals(table.pack(tbl:range_of("name1[3]/name1{1}  ", 2)), {4,3, n=2})
    assertEquals(table.pack(tbl:range_of("name1[3]/name1{1}  ",-3)), {4,3, n=2})
  end
end

function TestMTable:testRangeOfStringInvalid()
  local _, tbl2, tbl3 = getIdxTbl()
  local range_of      = mtable.range_of
  local msg = {
    "invalid range start",
    "invalid range stop",
    "invalid argument #2 (integer or string expected)",
  }
  for i,tbl in ipairs{tbl2, tbl3} do
    assertErrorMsgContains(msg[3], range_of, tbl, "                   "   )
    assertErrorMsgContains(msg[1], range_of, tbl, "         /         "   )
    assertErrorMsgContains(msg[2], range_of, tbl, "name1    /         "   )
    assertErrorMsgContains(msg[1], range_of, tbl, "name100  /name1    "   )
    assertErrorMsgContains(msg[2], range_of, tbl, "name1    /name200  "   )
    assertErrorMsgContains(msg[1], range_of, tbl, "name100  /name200  "   )
    assertErrorMsgContains(msg[1], range_of, tbl, "name1[-4]/name1[3] "   )
    assertErrorMsgContains(msg[2], range_of, tbl, "name1[1] /name1[4] "   )
    assertErrorMsgContains(msg[1], range_of, tbl, "name1[4] /name1[3] "   )
    assertErrorMsgContains(msg[2], range_of, tbl, "name1[1] /name1[-4]"   )
    assertErrorMsgContains(msg[1], range_of, tbl, "name1{-2}/name1{1} ", 2)
    assertErrorMsgContains(msg[2], range_of, tbl, "name1{-1}/name1{3} ", 2)
    assertErrorMsgContains(msg[1], range_of, tbl, "name1{3} /name1{1} ", 2)
    assertErrorMsgContains(msg[2], range_of, tbl, "name1{-1}/name1{-3}", 2)
  end
end

function TestMTable:testRangeOfTableInt()
  local tbl1, tbl2, tbl3  = getEmptyTables()
  for i=1,4 do
    local row1, row2, row3 = getRows(i)
    tbl1:addrow(row1);
    tbl2:addrow(row2);
    tbl3:addrow(row3);
  end
  for i, tbl in ipairs{tbl1, tbl2, tbl3} do
    assertEquals(table.pack(tbl:range_of({1 , 1})), {1,1, n=2})
    assertEquals(table.pack(tbl:range_of({1 ,-1})), {1,4, n=2})
    assertEquals(table.pack(tbl:range_of({2 , 2})), {2,2, n=2})
    assertEquals(table.pack(tbl:range_of({-1, 1})), {4,1, n=2})
    assertEquals(table.pack(tbl:range_of({-1, 4})), {4,4, n=2})
    assertEquals(table.pack(tbl:range_of({4 ,-1})), {4,4, n=2})
  end
end

function TestMTable:testRangeOfTableStringInt()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local tpack         = table.pack
  for i,tbl in ipairs{tbl1, tbl2, tbl3} do
    assertEquals(tpack(tbl:range_of({" 1", " 1"})), {1,1, n=2})
    assertEquals(tpack(tbl:range_of({" 1", "-1"})), {1,4, n=2})
    assertEquals(tpack(tbl:range_of({" 2", " 2"})), {2,2, n=2})
    assertEquals(tpack(tbl:range_of({"-1", " 1"})), {4,1, n=2})
    assertEquals(tpack(tbl:range_of({"-1", " 4"})), {4,4, n=2})
    assertEquals(tpack(tbl:range_of({" 4", "-1"})), {4,4, n=2})
    assertEquals(tpack(tbl:range_of({" 1", " 1"})), {1,1, n=2})
    assertEquals(tpack(tbl:range_of({"-1", " 1"})), {4,1, n=2})
    assertEquals(tpack(tbl:range_of({" 2", " 2"})), {2,2, n=2})
    assertEquals(tpack(tbl:range_of({" 1", "-1"})), {1,4, n=2})
    assertEquals(tpack(tbl:range_of({" 4", "-1"})), {4,4, n=2})
    assertEquals(tpack(tbl:range_of({"-1", " 4"})), {4,4, n=2})
  end
end

function TestMTable:testRangeOfTableStringPositiveAbsolute()
  local _, tbl2, tbl3 = getIdxTbl()
  local tpack         = table.pack
  for i,tbl in ipairs{tbl2, tbl3} do
    assertEquals(tpack(tbl:range_of({"name1    ", "name1    "})), {1,1, n=2})
    assertEquals(tpack(tbl:range_of({"name1    ", "name2    "})), {1,2, n=2})
    assertEquals(tpack(tbl:range_of({"name1[2] ", "name1[2] "})), {3,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1[-2]", "name1[-2]"})), {3,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1[1] ", "name1[3] "})), {1,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1[-3]", "name1[-1]"})), {1,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1[2] ", "name1[3] "})), {3,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1[-2]", "name1[-1]"})), {3,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1[1] ", "name1[-1]"})), {1,4, n=2})
  end
end

function TestMTable:testRangeOfTableStringPositiveRelative()
  local _, tbl2, tbl3 = getIdxTbl()
  local tpack         = table.pack
  for i,tbl in ipairs{tbl2, tbl3} do
    assertEquals(tpack(tbl:range_of({"name1{1} ", "name1{2} "}, 2)), {3,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1{1} ", "name1{2} "},-3)), {3,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1{1} ", "name1{2} "}, 3)), {3,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1{1} ", "name1{2} "},-2)), {3,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1{-1}", "name1{1} "}, 3)), {3,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1{-1}", "name1{1} "},-2)), {3,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1{-2}", "name1{-1}"}, 4)), {3,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1{-2}", "name1{-1}"},-1)), {3,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1{-1}", "name1{1} "}, 2)), {1,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1{-1}", "name1{1} "},-3)), {1,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1{-1}", "name1{2} "}, 2)), {1,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1{-1}", "name1{2} "},-3)), {1,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1[2] ", "name1{2} "}, 2)), {3,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1[2] ", "name1{2} "},-3)), {3,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1[-2]", "name1{2} "}, 2)), {3,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1[-2]", "name1{2} "},-3)), {3,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1{-1}", "name1[3] "}, 2)), {1,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1{-1}", "name1[3] "},-3)), {1,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1{1} ", "name1[3] "}, 2)), {3,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1{1} ", "name1[3] "},-3)), {3,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1{1} ", "name1{2} ", 2})), {3,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1{1} ", "name1{2} ",-3})), {3,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1{1} ", "name1{2} ", 3})), {3,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1{1} ", "name1{2} ",-2})), {3,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1{-1}", "name1{1} ", 3})), {3,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1{-1}", "name1{1} ",-2})), {3,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1{-2}", "name1{-1}", 4})), {3,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1{-2}", "name1{-1}",-1})), {3,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1{-1}", "name1{1} ", 2})), {1,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1{-1}", "name1{1} ",-3})), {1,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1{-1}", "name1{2} ", 2})), {1,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1{-1}", "name1{2} ",-3})), {1,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1[2] ", "name1{2} ", 2})), {3,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1[2] ", "name1{2} ",-3})), {3,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1[-2]", "name1{2} ", 2})), {3,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1[-2]", "name1{2} ",-3})), {3,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1{-1}", "name1[3] ", 2})), {1,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1{-1}", "name1[3] ",-3})), {1,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1{1} ", "name1[3] ", 2})), {3,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1{1} ", "name1[3] ",-3})), {3,4, n=2})
  end
end

function TestMTable:testRangeOfTableStringNegativeAbsolute()
  local _, tbl2, tbl3 = getIdxTbl()
  local tpack         = table.pack
  for i,tbl in ipairs{tbl2, tbl3} do
    assertEquals(tpack(tbl:range_of({"name1    ", "name1    "})), {1,1, n=2})
    assertEquals(tpack(tbl:range_of({"name2    ", "name1    "})), {2,1, n=2})
    assertEquals(tpack(tbl:range_of({"name1[2] ", "name1[2] "})), {3,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1[-2]", "name1[-2]"})), {3,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1[3] ", "name1[1] "})), {4,1, n=2})
    assertEquals(tpack(tbl:range_of({"name1[-1]", "name1[-3]"})), {4,1, n=2})
    assertEquals(tpack(tbl:range_of({"name1[3] ", "name1[2] "})), {4,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1[-1]", "name1[-2]"})), {4,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1[-1]", "name1[1] "})), {4,1, n=2})
  end
end

function TestMTable:testRangeOfTableStringNegativeRelative()
  local _, tbl2, tbl3 = getIdxTbl()
  local tpack         = table.pack
  for i,tbl in ipairs{tbl2, tbl3} do
    assertEquals(tpack(tbl:range_of({"name1{2} ", "name1{1} "}, 2)), {4,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1{2} ", "name1{1} "},-3)), {4,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1{2} ", "name1{1} "}, 3)), {4,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1{2} ", "name1{1} "},-2)), {4,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1{-1}", "name1{-2}"}, 4)), {4,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1{-1}", "name1{-2}"},-1)), {4,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1{1} ", "name1{-1}"}, 2)), {3,1, n=2})
    assertEquals(tpack(tbl:range_of({"name1{1} ", "name1{-1}"},-3)), {3,1, n=2})
    assertEquals(tpack(tbl:range_of({"name1{2} ", "name1{-1}"}, 2)), {4,1, n=2})
    assertEquals(tpack(tbl:range_of({"name1{2} ", "name1{-1}"},-3)), {4,1, n=2})
    assertEquals(tpack(tbl:range_of({"name1{2} ", "name1[2] "}, 2)), {4,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1{2} ", "name1[2] "},-3)), {4,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1{2} ", "name1[-2]"}, 2)), {4,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1{2} ", "name1[-2]"},-3)), {4,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1[3] ", "name1{-1}"}, 2)), {4,1, n=2})
    assertEquals(tpack(tbl:range_of({"name1[3] ", "name1{-1}"},-3)), {4,1, n=2})
    assertEquals(tpack(tbl:range_of({"name1[3] ", "name1{1} "}, 2)), {4,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1[3] ", "name1{1} "},-3)), {4,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1{2} ", "name1{1} ", 2})), {4,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1{2} ", "name1{1} ",-3})), {4,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1{2} ", "name1{1} ", 3})), {4,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1{2} ", "name1{1} ",-2})), {4,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1{-1}", "name1{-2}", 4})), {4,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1{-1}", "name1{-2}",-1})), {4,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1{1} ", "name1{-1}", 2})), {3,1, n=2})
    assertEquals(tpack(tbl:range_of({"name1{1} ", "name1{-1}",-3})), {3,1, n=2})
    assertEquals(tpack(tbl:range_of({"name1{2} ", "name1{-1}", 2})), {4,1, n=2})
    assertEquals(tpack(tbl:range_of({"name1{2} ", "name1{-1}",-3})), {4,1, n=2})
    assertEquals(tpack(tbl:range_of({"name1{2} ", "name1[2] ", 2})), {4,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1{2} ", "name1[2] ",-3})), {4,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1{2} ", "name1[-2]", 2})), {4,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1{2} ", "name1[-2]",-3})), {4,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1[3] ", "name1{-1}", 2})), {4,1, n=2})
    assertEquals(tpack(tbl:range_of({"name1[3] ", "name1{-1}",-3})), {4,1, n=2})
    assertEquals(tpack(tbl:range_of({"name1[3] ", "name1{1} ", 2})), {4,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1[3] ", "name1{1} ",-3})), {4,3, n=2})
  end
end

function TestMTable:testRangeOfTableInvalid()
  local _, tbl2, tbl3 = getIdxTbl()
  local range_of      = mtable.range_of
  local msg = {
    "invalid range start",
    "invalid range stop",
    "invalid argument #2 (integer or string expected)",
  }
  for i,tbl in ipairs{tbl2, tbl3} do
    assertErrorMsgContains(msg[1], range_of, tbl, { 0         , 2          }   )
    assertErrorMsgContains(msg[2], range_of, tbl, { 1         , 5          }   )
    assertErrorMsgContains(msg[1], range_of, tbl, {-100       , 2          }   )
    assertErrorMsgContains(msg[2], range_of, tbl, { 1         , 100        }   )
    assertErrorMsgContains(msg[3], range_of, tbl, { 1.5       , 2          }   )
    assertErrorMsgContains(msg[3], range_of, tbl, { 1         , 2.5        }   )
    assertErrorMsgContains(msg[1], range_of, tbl, {"         ", "         "}   )
    assertErrorMsgContains(msg[1], range_of, tbl, {"         ", "         "}   )
    assertErrorMsgContains(msg[2], range_of, tbl, {"name1    ", "         "}   )
    assertErrorMsgContains(msg[1], range_of, tbl, {"name100  ", "name1    "}   )
    assertErrorMsgContains(msg[2], range_of, tbl, {"name1    ", "name200  "}   )
    assertErrorMsgContains(msg[1], range_of, tbl, {"name100  ", "name200  "}   )
    assertErrorMsgContains(msg[1], range_of, tbl, {"name1[-4]", "name1[3] "}   )
    assertErrorMsgContains(msg[2], range_of, tbl, {"name1[1] ", "name1[4] "}   )
    assertErrorMsgContains(msg[1], range_of, tbl, {"name1[4] ", "name1[3] "}   )
    assertErrorMsgContains(msg[2], range_of, tbl, {"name1[1] ", "name1[-4]"}   )
    assertErrorMsgContains(msg[1], range_of, tbl, {"name1{-2}", "name1{1} "}, 2)
    assertErrorMsgContains(msg[2], range_of, tbl, {"name1{-1}", "name1{3} "}, 2)
    assertErrorMsgContains(msg[1], range_of, tbl, {"name1{3} ", "name1{1} "}, 2)
    assertErrorMsgContains(msg[2], range_of, tbl, {"name1{-1}", "name1{-3}"}, 2)
    assertErrorMsgContains(msg[1], range_of, tbl, {"name1{-2}", "name1{1} ", 2})
    assertErrorMsgContains(msg[2], range_of, tbl, {"name1{-1}", "name1{3} ", 2})
    assertErrorMsgContains(msg[1], range_of, tbl, {"name1{3} ", "name1{1} ", 2})
    assertErrorMsgContains(msg[2], range_of, tbl, {"name1{-1}", "name1{-3}", 2})
  end
end

function TestMTable:testRangeOfRange()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  for i,tbl in ipairs{tbl1, tbl2, tbl3} do
    assertEquals(table.pack(tbl:range_of( 1 ..  4)), {1,4, n=2})
    assertEquals(table.pack(tbl:range_of(-4 .. -1)), {1,4, n=2})
    assertEquals(table.pack(tbl:range_of( 2 ..  3)), {2,3, n=2})
    assertEquals(table.pack(tbl:range_of( 4 ..  1)), {4,1, n=2})
    assertEquals(table.pack(tbl:range_of(-1 .. -4)), {4,1, n=2})
    assertEquals(table.pack(tbl:range_of( 3 ..  2)), {3,2, n=2})
  end
end

function TestMTable:testLengthOf0TrnPositive()
  local _, tbl2, tbl3 = getIdxTbl()
  local length_of     = mtable.length_of
  local msg = {
    "invalid range start",
    "invalid range stop",
  }
  for i,tbl in ipairs{tbl2, tbl3} do
    assertEquals(tbl:length_of(                               ), 4)
    assertEquals(tbl:length_of( "1         /  4       "       ), 4)
    assertEquals(tbl:length_of( "name1[1]  /  name1[3]"       ), 4)
    assertEquals(tbl:length_of({"name1[1] ", "name1[3]"   }   ), 4)
    assertEquals(tbl:length_of({"name1{-1}", "name1{2}", 2}   ), 4)
    assertEquals(tbl:length_of({2          , 3            }   ), 2)
    assertEquals(tbl:length_of( nil                        , 0), 4)
    assertEquals(tbl:length_of( "1         /  4       "    , 0), 4)
    assertEquals(tbl:length_of( "name1[1]  /  name1[3]"    , 0), 4)
    assertEquals(tbl:length_of({"name1[1] ", "name1[3]"   }, 0), 4)
    assertEquals(tbl:length_of({"name1{-1}", "name1{2}", 2}, 0), 4)
    assertEquals(tbl:length_of({2          , 3            }, 0), 2)
    assertErrorMsgContains(msg[1], length_of, tbl,  "name1[-4] / name1[3] "    )
    assertErrorMsgContains(msg[2], length_of, tbl, {"name1{-1}","name1{-3}", 2})
  end
end

function TestMTable:testLengthOf0TrnNegative()
  local _, tbl2, tbl3 = getIdxTbl()
  local length_of     = mtable.length_of
  local msg = {
    "invalid range start",
    "invalid range stop",
  }
  for i,tbl in ipairs{tbl2, tbl3} do
    assertEquals(tbl:length_of( "4        /  1       "        ), 2)
    assertEquals(tbl:length_of( "name1[3] /  name1[1]"        ), 2)
    assertEquals(tbl:length_of({3         , 2             }   ), 4)
    assertEquals(tbl:length_of({"name1[3]", "name1[1] "   }   ), 2)
    assertEquals(tbl:length_of({"name1{2}", "name1{-1}", 2}   ), 2)
    assertEquals(tbl:length_of( "4        /  1        "    , 0), 2)
    assertEquals(tbl:length_of( "name1[3] /  name1[1] "    , 0), 2)
    assertEquals(tbl:length_of({"name1[3]", "name1[1] "   }, 0), 2)
    assertEquals(tbl:length_of({"name1{2}", "name1{-1}", 2}, 0), 2)
    assertEquals(tbl:length_of({3          , 2            }, 0), 4)
    assertErrorMsgContains(msg[1], length_of, tbl, {"name1{-3}","name1{-1}", 2})
    assertErrorMsgContains(msg[2], length_of, tbl,  "name1[3] / name1[-4] "    )
  end
end

function TestMTable:testLengthOfNTrnPositive()
  local _, tbl2, tbl3 = getIdxTbl()
  local length_of     = mtable.length_of
  for i,tbl in ipairs{tbl2, tbl3} do
    assertEquals(tbl:length_of( nil                        , 5), 24)
    assertEquals(tbl:length_of( "1         /  4       "    , 5), 24)
    assertEquals(tbl:length_of( "name1[1]  /  name1[3]"    , 5), 24)
    assertEquals(tbl:length_of({"name1[1] ", "name1[3]"   }, 5), 24)
    assertEquals(tbl:length_of({"name1{-1}", "name1{2}", 2}, 5), 24)
    assertEquals(tbl:length_of({2          , 3            }, 5), 22)
  end
end

function TestMTable:testLengthOfNTrnNegative()
  local _, tbl2, tbl3 = getIdxTbl()
  local length_of     = mtable.length_of
  for i,tbl in ipairs{tbl2, tbl3} do
    assertEquals(tbl:length_of( "4        /  1        "    , 5), 22)
    assertEquals(tbl:length_of( "name1[3] /  name1[1] "    , 5), 22)
    assertEquals(tbl:length_of({"name1[3]", "name1[1] "   }, 5), 22)
    assertEquals(tbl:length_of({"name1{2}", "name1{-1}", 2}, 5), 22)
    assertEquals(tbl:length_of({3         , 2             }, 5), 24)
  end
end

function TestMTable:testGetRowIdx()
  local tbl1, tbl2, tbl3 = getEmptyTables()
  for i=1,4 do
    local row1, row2, row3 = getRows(i)
    tbl1:addrow(row1); tbl2:addrow(row2); tbl3:addrow(row3)
  end
  for i=1,4 do
    local row1, row2, row3 = getRows(i)
    assertVecEquals(tbl1:getrow(i), row1)
    assertVecEquals(tbl2:getrow(i), row2)
    assertVecEquals(tbl3:getrow(i), row3)
  end
end

function TestMTable:testGetRowName()
  local tbl1, tbl2, tbl3 = getEmptyTables()
  for i=1,4 do
    local row1, row2, row3 = getRows(i)
    tbl1:addrow(row1); tbl2:addrow(row2); tbl3:addrow(row3)
  end
  for i=1,4 do
    local row1, row2, row3 = getRows(i)
    assertVecEquals(tbl2:getrow(row2[1]), row2)
    assertVecEquals(tbl3:getrow(row3[4]), row3)
  end
end

function TestMTable:testGetRowNameRef()
  local _, tbl2, tbl3 = getIdxTbl()
  local _, row2, row3 = getRows(3)
  row2[1], row3[4] = "name1", "name1"
  assertVecEquals(tbl2:getrow("name1", 2), row2)
  assertVecEquals(tbl3:getrow("name1", 2), row3)
end

function TestMTable:testGetColIdx()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local coli    = { 1       ,  2     , 3      , 4       }
  local coldict = { "name1" , "name2", "name1", "name1" }
  local col2    = {-1       ,-2      ,-3      ,-4       }
  local col3    = { pi      , 2*pi   , 3*pi   , 4*pi    }
  for i,tbl in ipairs{tbl1, tbl2, tbl3} do
    assertVecEquals(tbl:getcol(2), col2)
    assertVecEquals(tbl:getcol(3), col3)
    local nc = (i == 1) and 3 or 4
    assertVecEquals(tbl:getcol(1-nc), col2)
    assertVecEquals(tbl:getcol(2-nc), col3)
  end
  assertVecEquals(tbl1:getcol( 1), coli   )
  assertVecEquals(tbl1:getcol(-3), coli   )
  assertVecEquals(tbl2:getcol( 4), coli   )
  assertVecEquals(tbl2:getcol(-1), coli   )
  assertVecEquals(tbl3:getcol( 1), coli   )
  assertVecEquals(tbl3:getcol(-4), coli   )
  assertVecEquals(tbl2:getcol( 1), coldict)
  assertVecEquals(tbl2:getcol(-4), coldict)
  assertVecEquals(tbl3:getcol( 4), coldict)
  assertVecEquals(tbl3:getcol(-1), coldict)
end

function TestMTable:testGetColInvalid()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  assertNil(tbl1:getcol( 4    ))
  assertNil(tbl2:getcol( 5    ))
  assertNil(tbl3:getcol( 5    ))
  assertNil(tbl1:getcol(-4    ))
  assertNil(tbl2:getcol(-5    ))
  assertNil(tbl3:getcol(-5    ))
  assertNil(tbl1:getcol("none"))
  assertNil(tbl2:getcol("none"))
end

function TestMTable:testGetColName()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local coli    = { 1       ,  2     , 3      , 4       }
  local coldict = { "name1" , "name2", "name1", "name1" }
  local col2    = {-1       ,-2      ,-3      ,-4       }
  local col3    = { pi      , 2*pi   , 3*pi   , 4*pi    }
  for i,tbl in ipairs{tbl1, tbl3} do
    assertVecEquals(tbl:getcol("x"), coli)
    assertVecEquals(tbl:getcol("y"), col2)
    assertVecEquals(tbl:getcol("z"), col3)
  end
  assertVecEquals(tbl2:getcol("x"   ), col2   )
  assertVecEquals(tbl2:getcol("y"   ), col3   )
  assertVecEquals(tbl2:getcol("z"   ), coli   )
  assertVecEquals(tbl2:getcol("dict"), coldict)
  assertVecEquals(tbl3:getcol("dict"), coldict)
end

function TestMTable:testGetIdx()
  local tbl1, tbl2, tbl3          = getIdxTbl()
  local coli, col2, col3, coldict = getCols()
  local val1    = { coli    , col2   , col3             }
  local val2    = { coldict , col2   , col3   , coli    }
  local val3    = { coli    , col2   , col3   , coldict }
  -- positive idx
  for i=1,4 do
    for j=1,3 do assertEquals(tbl1:get(i,j), val1[j][i]) end
    for j=1,4 do
      assertEquals(tbl2:get(i,j), val2[j][i])
      assertEquals(tbl3:get(i,j), val3[j][i])
    end
  end
  -- negative idx
  for i=-4,-1 do
    for j=-3,-1 do assertEquals(tbl1:get(i,j), val1[4+j][5+i]) end
    for j=-4,-1 do
      assertEquals(tbl2:get(i,j), val2[5+j][5+i])
      assertEquals(tbl3:get(i,j), val3[5+j][5+i])
    end
  end
end

function TestMTable:testGetNamedCol()
  local tbl1, tbl2, tbl3          = getIdxTbl()
  local coli, col2, col3, coldict = getCols()
  for i=1,4 do
    assertEquals(tbl1:get(i, "x"   ), coli[i]   )
    assertEquals(tbl1:get(i, "y"   ), col2[i]   )
    assertEquals(tbl1:get(i, "z"   ), col3[i]   )
    assertEquals(tbl2:get(i, "dict"), coldict[i])
    assertEquals(tbl2:get(i, "x"   ), col2[i]   )
    assertEquals(tbl2:get(i, "y"   ), col3[i]   )
    assertEquals(tbl2:get(i, "z"   ), coli[i]   )
    assertEquals(tbl3:get(i, "x"   ), coli[i]   )
    assertEquals(tbl3:get(i, "y"   ), col2[i]   )
    assertEquals(tbl3:get(i, "z"   ), col3[i]   )
    assertEquals(tbl3:get(i, "dict"), coldict[i])
  end
end

function TestMTable:testGetNamedRow()
  local _, tbl2, tbl3 = getIdxTbl()
  for i,tbl in ipairs{tbl2, tbl3} do
    assertEquals(tbl:get("name1",2), -1)
    assertEquals(tbl:get("name2",2), -2)
  end
end

function TestMTable:testGetNamedRowRef()
  local _, tbl2, tbl3 = getIdxTbl()
  for i,tbl in ipairs{tbl2, tbl3} do
    assertEquals(tbl:get("name1",2, 1), -1)
    assertEquals(tbl:get("name1",2,-3), -1)
    assertEquals(tbl:get("name1",2, 2), -3)
    assertEquals(tbl:get("name1",2,-2), -3)
    assertEquals(tbl:get("name1",2, 3), -4)
    assertEquals(tbl:get("name1",2,-1), -4)
  end
end

function TestMTable:testGetInvalid()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  for i,tbl in ipairs{tbl1, tbl2, tbl3} do
    assertNil(tbl:get( 6    , 1     ))
    assertNil(tbl:get(-6    , 1     ))
    assertNil(tbl:get( 1    , "none"))
    assertNil(tbl:get( 1    , 6     ))
    assertNil(tbl:get( 1    ,-6     ))
  end
  for i,tbl in ipairs{tbl2, tbl3} do
    assertNil(tbl:get("name1"   , 1, 4))
    assertNil(tbl:get("name1[2]", 1   ))
    assertNil(tbl:get("name1"   , 1,-4))
  end
end

function TestMTable:testSetIdx()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local last = 1
  local r = \ => last = random() return last end
  for i=1,4 do
    for j=1,3 do
      tbl1:set(i  , j  , r()); assertEquals(tbl1:get(i  , j  ), last)
      tbl1:set(i-5, j-4, r()); assertEquals(tbl1:get(i-5, j-4), last)
      tbl3:set(i  , j  , r()); assertEquals(tbl3:get(i  , j  ), last)
      tbl3:set(i-5, j-5, r()); assertEquals(tbl3:get(i-5, j-5), last)
    end
    for j=2,4 do
      tbl2:set(i  , j  , r()); assertEquals(tbl2:get(i  , j  ), last)
      tbl2:set(i-5, j-5, r()); assertEquals(tbl2:get(i-5, j-5), last)
    end
  end
end

function TestMTable:testSetNamedCol()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local last = 1
  local r    = \ => last = random() return last end
  for _,tbl in ipairs{tbl1, tbl2, tbl3} do
    for _,key in ipairs{"x", "y", "z"} do
      for i=1,4 do
        tbl:set(i, key, r()); assertEquals(tbl:get(i, key),last)
      end
    end
  end
end

function TestMTable:testSetNamedRow()
  local _, tbl2, tbl3 = getIdxTbl()
  local last = 1
  local r    = \ => last = random() return last end
  for i,tbl in ipairs{tbl2, tbl3} do
    tbl:set("name1", 2, r()); assertEquals(tbl:get("name1", 2), last)
    tbl:set("name2", 2, r()); assertEquals(tbl:get("name2", 2), last)
  end
end

function TestMTable:testGetNamedRowRef()
  local _, tbl2, tbl3 = getIdxTbl()
  local last = 1
  local r    = \ => last = random() return last end
  for i,tbl in ipairs{tbl2, tbl3} do
    tbl:set("name1", 2, r(), 1); assertEquals(tbl:get("name1", 2, 1), last)
    tbl:set("name1", 2, r(),-3); assertEquals(tbl:get("name1", 2,-3), last)
    tbl:set("name1", 2, r(), 2); assertEquals(tbl:get("name1", 2, 2), last)
    tbl:set("name1", 2, r(),-2); assertEquals(tbl:get("name1", 2,-2), last)
    tbl:set("name1", 2, r(), 3); assertEquals(tbl:get("name1", 2, 3), last)
    tbl:set("name1", 2, r(),-1); assertEquals(tbl:get("name1", 2,-1), last)
  end
end

function TestMTable:testSetInvalid()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local v   = 241
  local msg = {
    "row index out of bounds",
    "invalid argument #3 (valid column expected)",
    "invalid argument #2 (valid row[cnt] expected)",
    "invalid argument #2 (valid row expected)",
  }
  for i,tbl in ipairs{tbl1, tbl2, tbl3} do
    assertErrorMsgContains(msg[1], mtable.set, tbl,  6        , 1     , v)
    assertErrorMsgContains(msg[1], mtable.set, tbl, -6        , 1     , v)
    assertErrorMsgContains(msg[2], mtable.set, tbl,  1        , "none", v)
    assertErrorMsgContains(msg[2], mtable.set, tbl,  1        , 6     , v)
    assertErrorMsgContains(msg[2], mtable.set, tbl,  1        ,-6     , v)
  end
  for i,tbl in ipairs{tbl2, tbl3} do
    assertErrorMsgContains(msg[3], mtable.set, tbl, "name1"   , 1     , v, 4)
    assertErrorMsgContains(msg[3], mtable.set, tbl, "name1"   , 1     , v,-4)
    assertErrorMsgContains(msg[4], mtable.set, tbl, "name1[2]", 1     , v   )
  end
end

function TestMTable:testSetDict()
  local _, tbl2, tbl3 = getIdxTbl()
  for i,tbl in ipairs{tbl2, tbl3} do
    tbl:set("name1", "dict", "name5"   ); assertEquals(tbl:get("name5", 2),-1)
    tbl:set("name1", "dict", "name6", 2); assertEquals(tbl:get("name6", 2),-4)
    tbl:set("name1", "dict", "name7", 1); assertEquals(tbl:get("name7", 2),-3)
  end
end

function TestMTable:testAddCol()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local col1 = { "v1", "v2", "v3", "v4" }
  local col2 = \i -> i
  local col3 = { 10  , 20  , 30  , 40   }
  local col4 = \i -> i+1
  for i,tbl in ipairs{tbl1, tbl2, tbl3} do
    tbl:addcol("col2", col2)
    tbl:addcol("col1", col1)
    tbl:addcol("col4", col4)
    tbl:addcol("col3", col3)
    tbl:addcol("col5", {})
    -- test value
    for i=1,4 do
      assertEquals(tbl:getcol("col1")[i], col1[i])
      assertEquals(tbl:getcol("col2")[i], col2(i))
      assertEquals(tbl:getcol("col3")[i], col3[i])
      assertEquals(tbl:getcol("col4")[i], col4(i))
      assertEquals(tbl:getcol("col5")[i], nil    )
    end
    -- test order
    assertEquals(tbl:getcol("col1"), tbl:getcol(-5))
    assertEquals(tbl:getcol("col2"), tbl:getcol(-2))
    assertEquals(tbl:getcol("col3"), tbl:getcol(-4))
    assertEquals(tbl:getcol("col4"), tbl:getcol(-1))
    assertEquals(tbl:getcol("col5"), tbl:getcol(-3))
  end
end

function TestMTable:testAddColNvec()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local col1 = {10  , "v2", nil , true }
  local col2 = {10  , 20  , 30  , 40   }
  local col3 = { "v1", "v2", "v3", "v4" }
  for i,tbl in ipairs{tbl1, tbl2, tbl3} do
    tbl:addcol("col1", col1, true )
    tbl:addcol("col2", col2, true )
    tbl:addcol("col3", col3, false)
    tbl:addcol("col4", col2, false)
    for i=1,4 do
      assertEquals(tbl:getcol("col1")[i], col1[i])
      assertEquals(tbl:getcol("col2")[i], col2[i])
    end
    assertFalse(is_vector(tbl:getcol("col1")))
    assertFalse(is_vector(tbl:getcol("col2")))
    assertFalse(is_vector(tbl:getcol("col3")))
    assertTrue (is_vector(tbl:getcol("col4")))
  end
end

function TestMTable:testAddColInvalid()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local msg = {
    "invalid argument #2 (column name already in use)",
    "incompatible container size",
  }
  for i,tbl in ipairs{tbl1, tbl2, tbl3} do
    tbl:addcol("col1", {})
    tbl:addcol("col2", \ ())
    assertErrorMsgContains(msg[1], mtable.addcol, tbl, "col1", {   })
    assertErrorMsgContains(msg[1], mtable.addcol, tbl, "col2", \ () )
    assertErrorMsgContains(msg[2], mtable.addcol, tbl, "col3", { 1 })
  end
end

-------------------------------------------------------------------------------o

function TestMTable:testInsRow()
  local tbl1  = mtable "tbl1"  { }
  local tbl2  = mtable "tbl2"  { "x", "y", "z" }
  local tbl3  = mtable "tbl3"  { {"dict"}, "x", "y", "z" }
  local tbl4  = mtable "tbl4"  { "x", "y", "z", {"dict"} }
  local tbl32 = tbl3   "tbl32" { }
  local val1, val2  = { 1, 2, 3 }      , { "v2", 1, 2, 3 }
  local val3, val4  = { "v3", 3, 3, 3 }, { "v4", 4, 4, 4 }

  assertErrorMsgContains(_msg[1], mtable.insrow, mtable, 1, val1)
  tbl2:insrow(1, val1)
  tbl3:insrow(1, val2)

  -- ini
  tbl2:insrow(2,{ 5, 5, 5, 5, 1, 2, 3 }, 5)
  tbl3:insrow(2,{ 5, 5, 5, 5, "v2", 1, 2, 3 }, 5)

  assertEquals(#tbl2, 2)
  assertEquals(#tbl3, 2)

  for i=1,2 do
    for j=1,3 do assertEquals(tbl2[i][j], val1[j]) end
    for j=1,4 do assertEquals(tbl3[i][j], val2[j]) end
  end

  -- key by value
  tbl3:insrow(2, val3)
  tbl3:insrow("v3", val4)
  for i=1,4 do
    assertEquals(tbl3[2][i], val4[i])
    assertEquals(tbl3[3][i], val3[i])
  end

  -- ref
  tbl3:insrow("v2[2]", {"v5", 1, 2, 3})
  tbl3:insrow("v2{1}", {"v6", 1, 2, 3}, nil, 3)
  assertEquals(tbl3[4][1], "v5")
  assertEquals(tbl3[5][1], "v6")

  -- nil
  assertErrorMsgContains(_msg[2], tbl4.insrow, tbl4, 1, { })
  tbl4:insrow(1, { nil, nil, nil, "v1" })
  tbl4:insrow(2, { nil, nil, nil, "v2" })
  for i=1,2 do for j=1,3 do assertEquals(tbl4[i][j], nil) end end
  assertEquals(tbl4[1][4], "v1")
end

function TestMTable:testSetRow()
  local tbl1  = mtable "tbl1"  { }
  local tbl2  = mtable "tbl2"  { "x", "y", "z" }
  local tbl3  = mtable "tbl3"  { {"dict"}, "x", "y", "z" }
  local tbl4  = mtable "tbl4"  { "x", "y", "z", {"dict"} }
  local tbl32 = tbl3   "tbl32" { }
  local ini1, ini2  = { 0, 0, 0 }      , { "v0", 0, 0, 0 }
  local val1, val2  = { 1, 2, 3 }      , { "v2", 1, 2, 3 }
  local val3, val4  = { "v3", 3, 3, 3 }, { "v4", 4, 4, 4 }

  assertErrorMsgContains(_msg[3], mtable.setrow, mtable, 1, val1)
  assertErrorMsgContains(_msg[3], mtable.setrow, tbl1  , 1, val1)

  tbl2:addrow(ini1); tbl2:addrow(ini1)
  tbl3:addrow(ini2); tbl3:addrow(ini2)
  tbl2:setrow(1, val1)
  tbl3:setrow(1, val2)

  -- ini
  tbl2:setrow(2, { 5, 5, 5, 5, 1, 2, 3 }, 5)
  tbl3:setrow(2, { 5, 5, 5, 5, "v2", 1, 2, 3 }, 5)

  assertEquals(#tbl2, 2)
  assertEquals(#tbl3, 2)

  for i=1,2 do
    for j=1,3 do assertEquals(tbl2[i][j], val1[j]) end
    for j=1,4 do assertEquals(tbl3[i][j], val2[j]) end
  end

  -- key by value
  tbl3:setrow(1, {"v3", 3, 3, 3})
  tbl3:setrow("v2", {"v4", 4, 4, 4})
  for i=1,4 do
    assertEquals(tbl3[1][i], val3[i])
    assertEquals(tbl3[2][i], val4[i])
  end

  -- ref
  tbl3:insrow(1, ini2); tbl3:insrow(3, ini2); tbl3:addrow(ini2)
  tbl3:setrow("v0[3]", {"v5", 1, 2, 3})
  tbl3:setrow("v0{1}", {"v6", 1, 2, 3}, nil, 2)
  assertEquals(tbl3[5][1], "v5")
  assertEquals(tbl3[3][1], "v6")

  -- nil
  tbl4:addrow { 1, 2, 3, "v1" }
  -- assertErrorMsgContains(_msg[2], tbl4.setrow, tbl4, 1, { }, 1) -- TODO should not modify anything
  tbl4:setrow(1, { nil, nil, nil, "v2" }, 1)
  for j=1,3 do assertEquals(tbl4[1][j], nil) end
  assertEquals(tbl4[1][4], "v2")
end

function TestMTable:testRemRow()
  local tbl1  = mtable "tbl1"  { }
  local tbl2  = mtable "tbl2"  { "x", "y", "z" }
  local tbl3  = mtable "tbl3"  { {"dict"}, "x", "y", "z" }
  local tbl4  = mtable "tbl4"  { "x", "y", "z", {"dict"} }
  local tbl32 = tbl3   "tbl32" { }
  local ini1  = { 0, 0, 0 }
  local ini2  = { "v0", 0, 0, 0 }
  local val1  = { 1, 2, 3 }

  tbl2:addrow(ini1); tbl2:addrow(ini1); tbl2:addrow(ini1)
  tbl3:addrow(ini2); tbl3:addrow(ini2); tbl3:addrow(ini2)
  tbl2:remrow(2)   ; tbl2:remrow(2)   ; tbl2:remrow(1)
  tbl3:remrow(2)   ; tbl3:remrow(2)   ; tbl3:remrow(1)

  assertEquals(#tbl2, 0)
  assertEquals(#tbl3, 0)

  -- key by value
  tbl3:addrow(ini2)
  tbl3:remrow("v0")
  assertEquals(#tbl3, 0)

  -- ref
  tbl3:addrow{ "v0", 1, 0, 0 };
  tbl3:addrow{ "v0", 2, 0, 0 };
  tbl3:addrow{ "v0", 3, 0, 0 };
  tbl3:remrow("v0[3]")
  tbl3:remrow("v0{1}", 2)
  assertEquals(tbl3[1][1], "v0")
  assertEquals(tbl3[1][2], 1)
  assertEquals(#tbl3, 1)
end

function TestMTable:testSwpRow()
  local tbl1  = mtable "tbl1"  { "x", "y", "z" }
  local tbl2  = mtable "tbl2"  { {"dict"}, "x", "y", "z" }
  local tbl22 = tbl2   "tbl22" { }

  tbl1:addrow{ 1, 1, 1 }          ; tbl1:addrow{ 2, 2, 3 }
  tbl2:addrow{ "v1", 1, 1, 1 }    ; tbl2:addrow{ "v2", 2, 2, 2 }
  assertEquals(tbl1[1][1], 1)     ; assertEquals(tbl1[2][1], 2)
  assertEquals(tbl2[1][1], "v1")  ; assertEquals(tbl2[2][1], "v2")
  tbl1:swprow(1,2)
  tbl2:swprow(1,2)
  assertEquals(tbl1[1][1], 2)     ; assertEquals(tbl1[2][1], 1)
  assertEquals(tbl2[1][1],  "v2") ; assertEquals(tbl2[2][1],  "v1")
  assertEquals(tbl22[1][1], "v2") ; assertEquals(tbl22[2][1], "v1")

  -- key by value
  tbl2:swprow("v1","v2")
  assertEquals(tbl2[1][1],  "v1") ; assertEquals(tbl2[2][1],  "v2")
  assertEquals(tbl22[1][1], "v1") ; assertEquals(tbl22[2][1], "v2")

  -- ref
  tbl2:addrow{ "v0", 1, 0, 0 };
  tbl2:addrow{ "v0", 2, 0, 0 };
  tbl2:addrow{ "v0", 3, 0, 0 };
  tbl2:swprow("v0[2]", "v0{2}", 4)
  assertEquals(tbl2[4].x, 3)
  assertEquals(tbl2[5].x, 2)
end

function TestMTable:testClrRow()
  local tbl1  = mtable "tbl1"  { "x", "y", "z" }
  local tbl2  = mtable "tbl2"  { {"dict"}, "x", "y", "z", novector=true }
  local tbl3  = mtable "tbl2"  { {"dict"}, "x", "y", "z", novector={1,"y"} }
  local row1  = { 1, 2, 3 }
  local row2  = { "v0", 1, 2, 3 }

  for i=1,4 do tbl1:addrow(row1); tbl2:addrow(row2); tbl3:addrow(row2) end

  -- tbl1:clrrow(1)
  -- tbl1:clrrow(-1)
end

function TestMTable:testRemCol()
  local tbl1  = mtable "tbl1"  { "x", "y", "z" }
  local tbl2  = mtable "tbl2"  { {"dict"}, "x", "y", "z" }
  local tbl22 = tbl2   "tbl22" { }
  local row1  = {       1, 2, 3 }
  local row2  = { "v0", 1, 2, 3 }
  local col   = \i -> i
  local msg   = {
    "invalid argument #2 (generator column expected)",
    "invalid argument #2 (valid column expected)",
  }

  for i=1,3 do tbl1:addrow(row1); tbl2:addrow(row2) end
  tbl1:addcol("c1", col)  ; tbl1:addcol("c2", col) ; tbl1:addcol("c3", col)
  tbl2:addcol("c1", col)  ; tbl2:addcol("c2", col) ; tbl2:addcol("c3", col)

  -- tbl22:addcol("c4", col) ; tbl22:remcol("c4") -- TODO fix var_raw

  tbl1:remcol(5)          ; tbl1:remcol("c1")     -- ; tbl1:remcol(-1)    -- TODO change reflect argument
  tbl2:remcol(6)          ; tbl2:remcol("c1")     -- ; tbl2:remcol(-1)    -- TODO change reflect argument
  assertNil(tbl1.c1)      ; assertNil(tbl1.c2)    -- ; assertNil(tbl1.c3) -- TODO change reflect argument
  assertNil(tbl2.c1)      ; assertNil(tbl2.c2)    -- ; assertNil(tbl2.c3) -- TODO change reflect argument

  -- now allowed
--  for i=1,3 do assertErrorMsgContains(msg[1], mtable.remcol, tbl1, i) end
--  for i=1,4 do assertErrorMsgContains(msg[1], mtable.remcol, tbl2, i) end
--  assertErrorMsgContains(msg[1], mtable.remcol, tbl1, 100)
  assertErrorMsgContains(msg[2], mtable.remcol, tbl1, "none")
end

function TestMTable:testNoVector()
  local tbl11 = mtable "tbl11" { "x", "y", "z" }
  local tbl12 = mtable "tbl12" { "x", "y", "z", novector = true }
  local tbl13 = mtable "tbl13" { "x", "y", "z", novector = {1, "y"} }
  local tbl21 = mtable "tbl21" { {"dict"}, "x", "y", "z" }
  local tbl22 = mtable "tbl22" { {"dict"}, "x", "y", "z", novector = true }
  local tbl23 = mtable "tbl23" { {"dict"}, "x", "y", "z", novector = {2, "y"} }
  local row1, row2 = { 1, 2, 3 }, { "v0", 1, 2, 3}
  local col1, col2 = { 10, 10 } , { 15, 15 }

  tbl11:addrow(row1); tbl11:addrow(row1); tbl21:addrow(row2); tbl21:addrow(row2)
  tbl12:addrow(row1); tbl12:addrow(row1); tbl22:addrow(row2); tbl22:addrow(row2)
  tbl13:addrow(row1); tbl13:addrow(row1); tbl23:addrow(row2); tbl23:addrow(row2)

  for i=1,3 do
    assertTrue(is_vector(tbl11:getcol(i)))
    assertTrue(is_vector(tbl21:getcol(i+1)))

    assertTrue(is_table(tbl12:getcol(i)))
    assertTrue(is_table(tbl22:getcol(i+1)))
  end
  for i=1,2 do
    assertTrue(is_table(tbl13:getcol(i)))
    assertTrue(is_table(tbl23:getcol(i+1)))
  end
  assertTrue(is_vector(tbl13:getcol(3)))
  assertTrue(is_vector(tbl23:getcol(4)))
  assertTrue(is_table (tbl23:getcol(1)))

  -- maintenance after adding columns
  tbl11:addcol("c1", col1); tbl11:addcol("c2", col2, true)
  tbl12:addcol("c1", col1); tbl12:addcol("c2", col2, true)
  tbl13:addcol("c1", col1); tbl13:addcol("c2", col2, true)
  tbl21:addcol("c1", col1); tbl21:addcol("c2", col2, true)
  tbl22:addcol("c1", col1); tbl22:addcol("c2", col2, true)
  tbl23:addcol("c1", col1); tbl23:addcol("c2", col2, true)

  assertTrue(is_vector(tbl11:getcol("c1")))
  assertTrue(is_table (tbl12:getcol("c1")))
  assertTrue(is_vector(tbl13:getcol("c1")))
  assertTrue(is_vector(tbl21:getcol("c1")))
  assertTrue(is_table (tbl22:getcol("c1")))
  assertTrue(is_vector(tbl23:getcol("c1")))

  assertTrue(is_table(tbl11:getcol("c2")))
  assertTrue(is_table(tbl12:getcol("c2")))
  assertTrue(is_table(tbl13:getcol("c2")))
  assertTrue(is_table(tbl21:getcol("c2")))
  assertTrue(is_table(tbl22:getcol("c2")))
  assertTrue(is_table(tbl23:getcol("c2")))
end

function TestMTable:testWrite()
  filesys.mkdir(rundir(""))
  local tbl1 = mtable "tbl1" { "x", "y", "z" }
  local tbl2 = mtable "tbl2" { {"dict"}, "x", "y", "z" }
  local tbl3 = mtable "tbl3" { {"dict"}, "x", "y", "z", column = {"x", 3}}
  local tbl4 = mtable "tbl4" {
    {"dict"}, "x", "y", "z",
    header1 = "MyHeader1", header2 = 42,
    header  = {"header1", "header2"}
  }
  local tbl5 = mtable "tbl5" {
    "x", "y", "z",
    novector = true, header = {"novector"}
  }
  local tbl6 = mtable "tbl6" {
    "x", "y", "z",
    novector = {1, "y"}, header = {"novector"}
  }
  local tbl7 = mtable "tbl7" {
    {"name"}, "x", "y", "z",
    header1  = "header 'whith quote'", header2 = "header \"double quote\"",
    header3  = 42.5, header4 = true, header5 = { "val", 3 }, -- TODO add boolean
    novector = true, header = { "type", "header1", "header2", "header3",
    "header4", "header5", "novector" },
  }
  local row1, row2 = { 1, 2, 3 }, { "v0", 1, 2, 3}

  tbl1.time, tbl1.date, tbl1.origin = "", "", ""
  tbl2.time, tbl2.date, tbl2.origin = "", "", ""
  tbl3.time, tbl3.date, tbl3.origin = "", "", ""
  tbl4.time, tbl4.date, tbl4.origin = "", "", ""
  tbl5.time, tbl5.date, tbl5.origin = "", "", ""
  tbl6.time, tbl6.date, tbl6.origin = "", "", ""
  tbl7.time, tbl7.date, tbl7.origin = "", "", ""
  tbl1:addrow(row1); tbl1:addrow(row1)
  tbl2:addrow(row2); tbl2:addrow(row2)
  tbl3:addrow(row2); tbl3:addrow(row2)
  tbl4:addrow(row2); tbl4:addrow(row2)
  tbl5:addrow(row1); tbl5:addrow(row1)
  tbl6:addrow(row1); tbl6:addrow(row1)
  tbl7:addrow(row2); tbl7:addrow(row2)

  -- extensions
  testWrite(tbl1, "tbl-name1")
  testWrite(tbl1, "tbl-name2.tfs")

  -- with dictionary
  testWrite(tbl2, "tbl-dict")

  -- choose column
  testWrite(tbl2, "tbl-col1", {"x", 3})
  testWrite(tbl3, "tbl-col2")

  -- choose header
  testWrite(tbl4, "tbl-header1", nil, { "title", "header1" })
  testWrite(tbl4, "tbl-header2")

  -- novector
  testWrite(tbl5, "tbl-novector1")
  testWrite(tbl6, "tbl-novector2")

  -- tbl with quoted string
  tbl7:addrow{"name1", 1  , 2    , 3.15}
  tbl7:addrow{"name2", nil, nil  , true}
  tbl7:addrow{"name1", 1  , false, 3.15}
  tbl7:addcol("gen"  , \i->i)
  tbl7:addrow{"name1", "value 'whith quote'", "value \"double quote\"", 3}
  testWrite(tbl7, "tbl-write")

  if not generate then filesys.rmdir(rundir("")) end
end

function TestMTable:testRead()
  local parent = mtable "parent" { var = 42 }

  -- extensions
  -- local tbl1 = mtable:read(refdir("tbl-name1"))
  -- local tbl2 = mtable:read(refdir("tbl-name2.tfs"))
  -- for i=1,2 do
  --   for j=1,3 do
  --     assertEquals(tbl1[i][j], j)
  --     assertEquals(tbl2[i][j], j)
  --   end
  -- end

  -- inheritance
  -- local tbl3 = parent:read(refdir("tbl-name1"))
  -- assertFalse(parent:is_owner())
  -- assertTrue(tbl3:is_owner())
  -- assertEquals(tbl3.var, 42)
  -- assertEquals(tbl3.parent, parent)

  -- test values read
  -- local tbl4 = mtable:read(refdir("tbl-write")) -- TODO types not correct can not read back tbl-write

  -- TODO when read is fixed :  test if quote is handled properly
  -- TODO test read values
  -- test dictionary
end

function TestMTable:testBuildIndex()
  local tbl = mtable "tbl" { {"name1"}, "name2" , "id" }
  tbl:addrow{ "n1"   , "n2"   , 1}
  tbl:addrow{ "other", "other", 2}
  tbl:addrow{ "n1"   , "n2"   , 3}
  tbl:addrow{ "n1"   , "n2"   , 4}

  for col,v in pairs{name1="n1", name2="n2"} do
    tbl:build_index(col)
    assertEquals(tbl:getrow(v.."[1]"   ).id, 1)
    assertEquals(tbl:getrow(v.."[3]"   ).id, 4)
    assertEquals(tbl:getrow(v.."{2}", 2).id, 4)
  end

  for _,col in ipairs{1} do -- TODO add ,-2 when build index is fixed
    tbl:build_index(col)
    assertEquals(tbl:getrow("n1[1]"   ).id, 1)
    assertEquals(tbl:getrow("n1[3]"   ).id, 4)
    assertEquals(tbl:getrow("n1{2}", 2).id, 4)
  end

  tbl:build_index("none")
  -- local v = tbl:getrow("n1[1]"   ).id -- TODO not supposed to work
  -- TODO add test
end

function TestMTable:testSetReadOnly()
  local tbl1 = mtable "tbl1" { {"dict"}, "x", "y", "z"}
  local tbl2 = mtable "tbl2" { {"dict"}, "x", "y", "z"}
  local msg  = {
    "forbidden write access to 'tbl1' (readonly object or variable)",
    "invalid write access to readonly mtable",
  }

  tbl2:addrow{ "v1", 1, 1, 1 }

  tbl1:set_readonly()
  tbl2:set_readonly()

  assertErrorMsgContains(msg[1],\tbl,k,v   => tbl[k]    = v end, tbl1, "var", 42)
  assertErrorMsgContains(msg[2],\tbl,i,j,v => tbl[i][j] = v end, tbl2, 1, 2, 42)
  assertErrorMsgContains(msg[2], mtable.set, tbl2, 1, 2, 42)
  assertErrorMsgContains(_msg[1], mtable.addrow, tbl1,  { "v2", 2, 2, 2 })
  assertErrorMsgContains(_msg[1], mtable.addrow, tbl2, { "v2", 2, 2, 2 })
  assertErrorMsgContains(_msg[1], mtable.insrow, tbl2, 1, { "v2", 2, 2, 2 })
  assertErrorMsgContains(_msg[1], mtable.setrow, tbl2, 1, { "v2", 2, 2, 2 })  -- TODO doesn't let tbl2 in a valid state
  tbl2:set_readonly(false); tbl2:addrow{ "v2", 2, 2, 2 }; tbl2:set_readonly()
  assertErrorMsgContains(_msg[1], mtable.swprow, tbl2, 1, 2)                   -- TODO doesn't let tbl2 in a valid state
  assertErrorMsgContains(_msg[1], mtable.remrow, tbl2, 1)                      -- TODO doesn't let tbl2 in a valid state
  assertErrorMsgContains(_msg[1], mtable.addcol, tbl2, "c1", {5})
  tbl2:set_readonly(false); tbl2:addcol("gen",\i->i); tbl2:set_readonly()
  assertErrorMsgContains(msg[2], mtable.remcol, tbl2, "gen")

  -- tbl2:build_index(2) -- TODO should not work ? -> no

  -- TODO test for add sort, remove, insert, cycle,
  -- TODO select
end

function TestMTable:testIter()
  local tbl1 = mtable "tbl1" { {"dict"} }
  local tbl2 = mtable "tbl2" { {"dict"} }
  local val1 = { "v1", "v2", "v3", "v4" }
  local val2 = { "v0", "v1", "v0", "v0" }
  local i    = 1

  for _,v in ipairs(val1) do tbl1:addrow{v} end
  for _,v in ipairs(val2) do tbl2:addrow{v} end

  for _,row in tbl1:iter() do
    assertEquals(row[1], val1[i])
    i=i+1
  end

  -- range
  i = 2
  for _,row in tbl1:iter("v2/v3") do
    assertEquals(row[1], val1[(i-1) % 4 + 1])
    i = i + 1
  end
  assertEquals(i, 4)

  i = 1
  for _,row in tbl2:iter{"v0{-1}","v0[2]", 2} do
    assertEquals(row[1], val2[(i-1) % 4 + 1])
    i = i + 1
  end
  assertEquals(i, 4)

  -- nturn
  i = 1
  for _,row in tbl1:iter(nil, 1, 1) do
    assertEquals(row[1], val1[(i-1) % 4 + 1])
    i = i + 1
  end
  assertEquals(i, 9)

   -- dir
  i = 8
  for _,row in tbl1:iter(nil, 1, -1) do
    assertEquals(row[1], val1[(i-1) % 4 + 1])
    i = i - 1
  end
  assertEquals(i, 0)

end

function TestMTable:testCycle()
  local tbl    = mtable "tbl" { {"dict"} }
  local before = { "v1", "v2", "v3", "v4" }
  local after1 = { "v3", "v4", "v1", "v2" }
  local after2 = { "v4", "v1", "v2", "v3" }
  local i      = 1

  for _,v in ipairs(before) do tbl:addrow{v} end

  for _,row in tbl:iter() do
    assertEquals(row[1], before[i])
    i = i + 1
  end

  i = 1
  tbl:cycle(3)
  for _,row in tbl:iter() do
    assertEquals(row[1], after1[i])
    i = i + 1
  end

  i = 1
  tbl:cycle("v4")
  for _,row in tbl:iter() do
    assertEquals(row[1], after2[i])
    i = i + 1
  end

end

function TestMTable:testForeach()
  local tbl  = mtable "tbl" { {"dict"} }
  local tbl2 = mtable "tbl" { {"dict"}, "kind" }
  local val  = { "v1", "v2", "v3", "v4", "v0", "v1", "v0", "v0" }
  local val2 = { "kind1", "kind2" }
  local i    = 1
  local act1 = \row,_ => assertEquals(row[1], val[i]); i=i+1 end
  local act2 = \row,_ => assertEquals(row[1], val[i]); i=i+2 end
  local act3 = \row,_ => assertEquals(row[1], "v0")  ; i=i+1 end

  for i,v in ipairs(val) do
    tbl:addrow{v}
    tbl2:addrow{v, val2[i%2]}
  end

  i=1; tbl:foreach(act1)                                ; assertEquals(i, 9)
  i=1; tbl:foreach(act1, nil  , nil, true)              ; assertEquals(i, 1)
  i=2; tbl:foreach(act1, {2,6})                         ; assertEquals(i, 7)
  -- i=1; tbl:foreach(act1, {2,6}, nil, true)              ; assertEquals(i, 1) -- TODO change of behavior
  i=2; tbl:foreach(act1, nil,   \r,i -> 1 < i and i < 7); assertEquals(i, 7)
  i=3; tbl:foreach(act1, {3,5}, \r,i -> 1 < i and i < 7); assertEquals(i, 6)
  i=1; tbl:foreach(act2, nil,   \r,i -> i%2 == 1       ); assertEquals(i, 9)

  -- argument packed in a table (equivalent to test above)
  i=1; tbl:foreach{action=act1}                             ; assertEquals(i, 9)
  -- i=1; tbl:foreach{action=act1, default=true}               ; assertEquals(i, 1) -- TODO change of behavior
  -- i=1; tbl:foreach{action=act1, default="none"}             ; assertEquals(i, 1) -- TODO change of behavior
  i=2; tbl:foreach{action=act1, range={2,6}}                ; assertEquals(i, 7)
  -- i=1; tbl:foreach{action=act1, range={2,6}, default=true}  ; assertEquals(i, 1) -- TODO change of behavior
  -- i=1; tbl:foreach{action=act1, range={2,6}, default="none"}; assertEquals(i, 1) -- TODO change of behavior
  i=2; tbl:foreach{action=act1, select=\r,i -> 1<i and i<7} ; assertEquals(i, 7)
  i=3; tbl:foreach{action=act1, range={3,5}, select=\r,i -> 1<i and i<7}
  assertEquals(i, 6)
  i=1; tbl:foreach{action=act2, select=\r,i -> i%2 == 1}    ; assertEquals(i, 9)

  -- argument packed in a table (test new capabilities)
  tbl:deselect(); tbl:select(nil, \r,i -> i >=5)
  i=5; tbl:foreach  { action=act1, selected=true  }; assertEquals(i, 9)
  i=1; tbl:foreach  { action=act3, pattern="0"    }; assertEquals(i, 4)
  i=1; tbl2:foreach { action=act2, kind="kind1"   }; assertEquals(i, 9)
end

function TestMTable:testSelect()
  local tbl  = mtable "tbl" { {"dict"} }
  local tbl2 = mtable "tbl" { {"dict"}, "kind" }
  local val  = { "v1", "v2", "v3", "v4", "v0", "v1", "v0", "v0" }
  local val2 = { "kind1", "kind2" }
  local val3 = { [5]=true, [7]=true, [8]=true }
  local assertSelect = \tbl,min,max,step =>
    for i=1,8,step or 1 do
      if min <= i and i < max
      then assertTrue (tbl[i][0])
      else assertFalse(tbl[i][0])
      end
    end
    tbl:deselect()
  end
  local assertSelect2 = \tbl,key =>
    for i=1,8 do
      if key[i]
      then assertTrue (tbl[i][0])
      else assertFalse(tbl[i][0])
      end
    end
    tbl:deselect()
  end

  for i,v in ipairs(val) do tbl:addrow{v}; tbl2:addrow{v, val2[i%2]} end
  tbl:deselect(); tbl2:deselect();

  assertSelect(tbl:select()                              , 1, 9)
  assertSelect(tbl:select(nil  , nil, true)              , 1, 1)
  assertSelect(tbl:select({2,6})                         , 2, 7)
  -- assertSelect(tbl:select({2,6}, nil, true)              , 1, 1) -- TODO change of behavior
  assertSelect(tbl:select(nil,   \r,i -> 1 < i and i < 7), 2, 7)
  assertSelect(tbl:select({3,5}, \r,i -> 1 < i and i < 7), 3, 6)
  assertSelect(tbl:select(nil,   \r,i -> i%2 == 1       ), 1, 9, 2)

  -- argument packed in a table (equivalent to test above)
  assertSelect(tbl:select{ }                                        , 1, 9)
  -- assertSelect(tbl:select{ default=true }                           , 1, 1) -- TODO change of behavior
  -- assertSelect(tbl:select{ default="none" }                         , 1, 1) -- TODO change of behavior
  assertSelect(tbl:select{ range={2,6} }                            , 2, 7)
  -- assertSelect(tbl:select{ range={2,6}, default=true }              , 1, 1) -- TODO change of behavior
  -- assertSelect(tbl:select{ range={2,6}, default="none" }            , 1, 1) -- TODO change of behavior
  assertSelect(tbl:select{ select=\r,i -> 1 < i and i < 7 }         , 2, 7)
  assertSelect(tbl:select{ range={3,5}, select=\r,i -> 1<i and i<7 }, 3, 6)
  assertSelect(tbl:select{ select=\r,i -> i%2 == 1 }                , 1, 9, 2)

  -- argument packed in a table (test new capabilities)
  assertSelect2(tbl:select{ pattern="0"  }, val3)
  assertSelect(tbl2:select{ kind="kind1" }, 1, 9, 2)
end

function TestMTable:testDeselect()
  local tbl  = mtable "tbl" { {"dict"} }
  local tbl2 = mtable "tbl" { {"dict"}, "kind" }
  local val  = { "v1", "v2", "v3", "v4", "v0", "v1", "v0", "v0" }
  local val2 = { "kind1", "kind2" }
  local val3 = { [5]=true, [7]=true, [8]=true }
  local assertDeselect = \tbl,min,max,step =>
    for i=1,8,step or 1 do
      if min <= i and i < max
      then assertFalse(tbl[i][0])
      else assertTrue (tbl[i][0])
      end
    end
    tbl:select()
  end
  local assertDeselect2 = \tbl,key =>
    for i=1,8 do
      if key[i]
      then assertFalse(tbl[i][0])
      else assertTrue (tbl[i][0])
      end
    end
    tbl:select()
  end

  for i,v in ipairs(val) do tbl:addrow{v}; tbl2:addrow{v, val2[i%2]} end
  tbl:select(); tbl2:select()

  assertDeselect(tbl:deselect()                              , 1, 9)
  assertDeselect(tbl:deselect(nil  , nil, true)              , 1, 1)
  assertDeselect(tbl:deselect({2,6})                         , 2, 7)
  -- assertDeselect(tbl:deselect({2,6}, nil, true)              , 1, 1)  -- TODO change of behavior
  assertDeselect(tbl:deselect(nil,   \r,i -> 1 < i and i < 7), 2, 7)
  assertDeselect(tbl:deselect({3,5}, \r,i -> 1 < i and i < 7), 3, 6)
  assertDeselect(tbl:deselect(nil,   \r,i -> i%2 == 1       ), 1, 9, 2)

  -- argument packed in a table (equivalent to test above)
  assertDeselect(tbl:deselect{}                                       , 1, 9)
  assertDeselect(tbl:deselect{default=true }                          , 1, 1)
  assertDeselect(tbl:deselect{default="none" }                        , 1, 1)
  assertDeselect(tbl:deselect{range={2,6} }                           , 2, 7)
  -- assertDeselect(tbl:deselect{range={2,6}, default=true }             , 1, 1) -- TODO change of behavior
  -- assertDeselect(tbl:deselect{range={2,6}, default="none" }           , 1, 1) -- TODO change of behavior
  assertDeselect(tbl:deselect{select=\r,i -> 1 < i and i < 7 }        , 2, 7)
  assertDeselect(tbl:deselect{range={3,5}, select=\r,i ->1<i and i<7 }, 3, 6)
  assertDeselect(tbl:deselect{select=\r,i -> i%2 == 1 }               , 1, 9, 2)

  -- argument packed in a table (test new capabilities)
  assertDeselect2(tbl:deselect{ pattern="0"  }, val3)
  assertDeselect(tbl2:deselect{ kind="kind1" }, 1, 9, 2)
end

function TestMTable:testFilter()
  local tbl  = mtable "tbl" { {"dict"} }
  local tbl2 = mtable "tbl" { {"dict"}, "kind" }
  local val  = { "v1", "v2", "v3", "v4", "v0", "v1", "v0", "v0" }
  local val2 = { "kind1", "kind2" }
  local assertFilter = \idx,min,max,step_ =>
    local j, step = 1, step_ or 1
    for i=min,max,step do
      assertEquals(idx[j], i)
      j=j+1
    end
  end

  for i,v in ipairs(val) do tbl:addrow{v}; tbl2:addrow{v, val2[i%2]} end

  assertFilter(tbl:filter()                              ,  1, 8)
  assertEquals(tbl:filter(nil  , nil, true)              , {n=0})
  assertFilter(tbl:filter({2,6})                         ,  2, 6)
  -- assertEquals(tbl:filter({2,6}, nil, true)              , {n=0}) -- TODO change of behavior
  assertFilter(tbl:filter(nil,   \r,i -> 1 < i and i < 7),  2, 6)
  assertFilter(tbl:filter({3,5}, \r,i -> 1 < i and i < 7),  3, 5)
  assertFilter(tbl:filter(nil,   \r,i -> i%2 == 1       ),  1, 8, 2)

  -- argument packed in a table (equivalent to test above)
  assertFilter(tbl:filter { }, 1, 8)
  assertEquals(tbl:filter { default=true }, {n=0})
  assertEquals(tbl:filter { default="none" }, {n=0})
  assertFilter(tbl:filter { range={2,6} }, 2, 6)
  -- assertEquals(tbl:filter { range={2,6}, default=true }, {n=0})   -- TODO change of behavior
  -- assertEquals(tbl:filter { range={2,6}, default="none" }, {n=0}) -- TODO change of behavior
  assertFilter(tbl:filter { select=\r,i -> 1 < i and i < 7 }, 2, 6)
  assertFilter(tbl:filter { range={3,5}, select=\r,i -> 1 < i and i < 7 }, 3, 5)
  assertFilter(tbl:filter { select=\r,i -> i%2 == 1 }, 1, 8, 2)

  -- argument packed in a table (test new capabilities)
  assertEquals(tbl:filter  { pattern="0"  }, { 5, 7, 8, n=3})
  assertFilter(tbl2:filter { kind="kind1" }, 1, 8, 2)
end

function TestMTable:testSort()
  local nsort = { 9, 7, 4, 0, 1, 8, 4, 4 }

  local slt1  = { 0, 1, 4, 4, 4, 7, 8, 9 }
  local slt2  = { 9, 7, 0, 1, 4, 8, 4, 4 }
  local slt3  = { 1, 7, 4, 0, 4, 8, 9, 4 }
  local slt4  = { 9, 7, 1, 0, 4, 8, 4, 4 }

  local sgt1  = { 9, 8, 7, 4, 4, 4, 1, 0 }
  local sgt2  = { 9, 7, 8, 4, 1, 0, 4, 4 }
  local sgt3  = { 9, 7, 4, 0, 4, 8, 1, 4 }
  local sgt4  = { 9, 7, 4, 0, 1, 8, 4, 4 }

  local sel   = { [9]=true, [7]=true, [1]=true }
  local lt    = \r1,r2 -> r1[1] < r2[1]
  local gt    = \r1,r2 -> r1[1] > r2[1]
  local assertSort = \cmp,val,... =>
    local tbl = mtable "tbl" { "v1", "v2" }
    for i,v in ipairs(nsort) do tbl:addrow{v, v} end
    tbl:deselect(); tbl:select(nil, \r,i -> sel[r[1]])
    tbl:sort(cmp, ...)
    for i,row in tbl:iter() do
      assertEquals(row[1], val[i])
      assertEquals(row[2], val[i])
      -- test if column[0] is also sorted
      if sel[row[1]]
      then assertTrue (row[0])
      else assertFalse(row[0])
      end
    end
  end

  -- sort increasing
  assertSort(lt, slt1)
  assertSort(lt, slt2, {3,6})
  assertSort(lt, slt3, nil  , \r,i -> i%2 == 1)
  assertSort(lt, slt4, {3,6}, \r,i -> i%2 == 1)

  -- sort decreasing
  assertSort(gt, sgt1)
  assertSort(gt, sgt2, {3,6})
  assertSort(gt, sgt3, nil  , \r,i -> i%2 == 1)
  assertSort(gt, sgt4, {3,6}, \r,i -> i%2 == 1)
end

function TestMTable:testCopy()
  local tbl1 = mtable "tbl1" { "x", "y", "z" }
  local tbl2 = mtable "tbl2" { {"dict"}, "x", "y", "z",
    novector=true, header ={"var"}, var=42, columns={"dict", "x"}}
  local tbl3 = mtable "tbl3" { {"dict"}, "x", "y", "z", novector = {1, "y"}}
  local row1, row2 = { 1, 2, 3 }, { "v0", 1, 2, 3 }
  local col1, col2 = { 1, 2, 3 }, \i -> i

  for i=1,3 do tbl1:addrow(row1); tbl2:addrow(row2); tbl3:addrow(row2) end
  tbl1:addcol("c1", col1); tbl2:addcol("c1", col1); tbl3:addcol("c1", col1)
  tbl1:addcol("c2", col2); tbl2:addcol("c2", col2); tbl3:addcol("c2", col2)
  tbl1:deselect{2,3}   ; tbl2:deselect{2,3}     ; tbl3:deselect{2,3}

  -- local cpy1 = tbl1:copy("cpy1") -- TODO forward declarion of build_indx
  -- local cpy2 = tbl2:copy("cpy2")
  -- local cpy3 = tbl3:copy("cpy3")

  -- assertEquals(cpy1.name, "cpy1")
  -- assertEquals(cpy2.name, "cpy2")
  -- assertEquals(cpy3.name, "cpy3")

  -- assertEquals(#cpy1, #tbl1)
  -- assertEquals(#cpy2, #tbl2)
  -- assertEquals(#cpy3, #tbl3)

  -- assertEquals(cpy2.var, tbl2.var)

  -- for i=1,3 do
  --   for j=0,4 do assertEquals(cpy1[i][j], tbl1[i][j]) end
  --   for j=0,5 do
  --     assertEquals(cpy2[i][j], tbl2[i][j])
  --     assertEquals(cpy3[i][j], tbl3[i][j])
  --   end
  -- end

  -- test consistence a novector
  -- for i=1,4 do
  --   assertEquals(is_vector(cpy1:getcol(i)), is_vector(tbl1:getcol(i)))
  -- end
  -- for i=1,5 do
  --   assertEquals(is_vector(cpy2:getcol(i)), is_vector(tbl2:getcol(i)))
  --   assertEquals(is_vector(cpy3:getcol(i)), is_vector(tbl3:getcol(i)))
  -- end

  -- existing dictionary
  -- assertEquals(cpy2:getrow("v0[2]").c1, 2)
  -- assertEquals(cpy3:getrow("v0[2]").c1, 2)

  -- TODO test copy without name
end

function TestMTable:testRemove()
  local rem1  = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }
  local rem2  = { 1, 2, 7, 8, 9, 10 }
  local rem3  = { 2, 4, 6, 8, 10 }
  local rem4  = { 1, 2, 4, 6, 7, 8, 9, 10 }
  local assertRemove = \val,... =>
    local tbl = mtable "tbl" { "v1", "v2" }
    for i=1,10 do tbl:addrow{i, i} end
    tbl:deselect(); tbl:select{2,7}
    tbl:remove(...)
    for i,row in tbl:iter() do
      assertEquals(row[1], val[i])
      assertEquals(row[2], val[i])
      -- test if column[0] is removed properly
      if 2 <= row[1] and row[1] <= 7
      then assertTrue (row[0])
      else assertFalse(row[0])
      end
    end
  end

  assertRemove(rem1)
  -- assertRemove(rem2, {3,6})                 -- TODO doesn't remove anything
  assertRemove(rem3, nil  , \r,i -> i%2 == 1)
  assertRemove(rem4, {3,6}, \r,i -> i%2 == 1)

  assertRemove(rem1, { })
  -- assertRemove(rem2, { range={3,6} })        -- TODO doesn't remove anything
  assertRemove(rem3, { select=\r,i -> i%2 == 1 })
  assertRemove(rem4, { range={3,6}, select=\r,i -> i%2 == 1 })
end

function TestMTable:testRemove2()
  local val1  = { "v1", "v2", "v3", "v4", "v0", "v1", "v0", "v0" }
  local val2  = { "kind1", "kind2" }
  local rem1  = { 1, 2, 3, 4, 6 }
  local rem2  = { 2, 4, 6, 8, 10 }
  local assertRemove = \val,... =>
    local tbl = mtable "tbl" { {"dict"}, "kind", "i" }
    for i,v in ipairs(val1) do tbl:addrow{v, val2[i%2], i} end
    tbl:deselect(); tbl:select{2,7}
    tbl:remove(...)
    for i,row in tbl:iter() do
      assertEquals(row[3], val[i])
      -- test if column[0] is removed properly
      if 2 <= row[3] and row[3] <= 7
      then assertTrue (row[0])
      else assertFalse(row[0])
      end
    end
  end

  assertRemove(rem1, { pattern = "0"     })
  assertRemove(rem2, { kind    = "kind1" })
end

-- end ------------------------------------------------------------------------o
