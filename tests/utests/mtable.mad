--[=[
 o-----------------------------------------------------------------------------o
 |
 | MTable tests
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide regression test suites for the mtable module.

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local assertFalse, assertTrue, assertNil, assertNotNil, assertEquals,
  assertStrContains, assertErrorMsgContains                         in MAD.utest
local mtable                                                        in MAD
local is_mtable, is_original_mtable in MAD.typeid

-- regression test suite ------------------------------------------------------o

TestMTable = {}

function TestMTable:testConstructor()
  local tbl1  = mtable 'tbl1'  { }
  local tbl2  = mtable 'tbl2'  { 'x', 'y', 'z' }
  local tbl3  = mtable 'tbl3'  { {'dict'}, 'x', 'y', 'z' }
  local tbl4  = mtable 'tbl4'  { 'x', 'y', 'z', {'dict'} }
  local tbl42 = tbl4   'tbl42' { }

  assertEquals(#tbl1,  0)
  assertEquals(#tbl2,  0)
  assertEquals(#tbl3,  0)
  assertEquals(#tbl4,  0)
  assertEquals(#tbl42, 0)

  assertEquals(tbl1.name, 'tbl1')
  assertEquals(tbl2.name, 'tbl2')
  assertEquals(tbl3.name, 'tbl3')
  assertEquals(tbl4.name, 'tbl4')
  assertEquals(tbl42.name, 'tbl42')

  for _,col in ipairs({'x', 'y', 'z'}) do
    assertNil(tbl1[col])
    assertNotNil(tbl2[col])
    assertNotNil(tbl3[col])
    assertNotNil(tbl4[col])
    assertNotNil(tbl42[col])
  end

  assertNotNil(tbl3.dict)
  assertNotNil(tbl4.dict)
  assertNotNil(tbl42.dict)
end

function TestMTable:testIsMtable()
  local tbl1  = mtable 'tbl1'  { }
  local tbl2  = mtable 'tbl2'  { 'x', 'y', 'z' }
  local tbl3  = mtable 'tbl3'  { {'dict'}, 'x', 'y', 'z' }
  local tbl32 = tbl3   'tbl32' { }

  assertTrue(is_mtable(tbl1))
  assertTrue(is_mtable(tbl2))
  assertTrue(is_mtable(tbl3))
  assertTrue(is_mtable(tbl32))

  assertFalse(is_original_mtable(tbl1))
  assertTrue(is_original_mtable(tbl2))
  assertTrue(is_original_mtable(tbl3))
  assertFalse(is_original_mtable(tbl32))
end

function TestMTable:testAddRow()
  local tbl1  = mtable 'tbl1'  { }
  local tbl2  = mtable 'tbl2'  { 'x', 'y', 'z' }
  local tbl3  = mtable 'tbl3'  { {'dict'}, 'x', 'y', 'z' }
  local tbl4  = mtable 'tbl4'  { 'x', 'y', 'z', {'dict'} }
  local tbl32 = tbl3   'tbl32' { }
  local val1  = { 1, 2, 3 }
  local val2  = { "v2", 1, 2, 3 }
  -- using operator
  -- local test = mtable + val1          -- TODO mtable should be readonly
  -- tbl1  = tbl1 + val1                 -- TODO shlould not work (not original)
  tbl2 = tbl2 + val1
  tbl3 = tbl3 + val2
  -- tbl32 = tbl32 + val2                -- TODO shlould not work (not original)

  -- using addrow
  -- mtable:addrow(val1)                 -- TODO mtable should be readonly
  -- tbl1:addrow { 1, 2, 3 }             -- TODO shlould not work (not original)
  tbl2:addrow(val1)
  tbl3:addrow(val2)
  -- tbl32:addrow(val2)                  -- TODO shlould not work (not original)

  -- ini
  tbl2:addrow({ 5, 5, 5, 5, 1, 2, 3 }, 5)
  tbl3:addrow({ 5, 5, 5, 5, "v2", 1, 2, 3 }, 5)

  assertEquals(#tbl2, 3)
  assertEquals(#tbl3, 3)

  for i=1,3 do
    for j=1,3 do assertEquals(tbl2[i][j], val1[j]) end
    for j=1,4 do assertEquals(tbl3[i][j], val2[j]) end
  end

  -- nil
  assertErrorMsgContains("table index is nil", tbl4.addrow, tbl4, { })
  -- assertErrorMsgContains("table index is nil", tbl4.addrow, tbl4, { 1 }) -- TODO doesn't let tbl4 unmodified
  tbl4:addrow { nil, nil, nil, "v2" }
  for j=1,3 do assertEquals(tbl4[1][j], nil) end
  assertEquals(tbl4[1][4], "v2")
end

function TestMTable:testInsRow()
  local tbl1  = mtable 'tbl1'  { }
  local tbl2  = mtable 'tbl2'  { 'x', 'y', 'z' }
  local tbl3  = mtable 'tbl3'  { {'dict'}, 'x', 'y', 'z' }
  local tbl4  = mtable 'tbl4'  { 'x', 'y', 'z', {'dict'} }
  local tbl32 = tbl3   'tbl32' { }
  local val1  = { 1, 2, 3 }
  local val2  = { "v2", 1, 2, 3 }
  local val3  = { "v3", 3, 3, 3 }
  local val4  = { "v4", 4, 4, 4 }

  -- mtable:insrow(1,val1)               -- TODO mtable should be readonly + cannot on empty table
  tbl2:addrow(val1)                      -- TODO to be removed once insert empty table is fixed
  tbl3:addrow(val2)                      -- TODO to be removed once insert empty table is fixed
  tbl2:insrow(1, val1)
  tbl3:insrow(1, val2)

  -- ini
  tbl2:insrow(2,{ 5, 5, 5, 5, 1, 2, 3 }, 5)
  tbl3:insrow(2,{ 5, 5, 5, 5, "v2", 1, 2, 3 }, 5)

  assertEquals(#tbl2, 3) -- TODO 2 once modified
  assertEquals(#tbl3, 3) -- TODO 2 once modified

  for i=1,3 do -- TODO i=1,2 once modified
    for j=1,3 do assertEquals(tbl2[i][j], val1[j]) end
    for j=1,4 do assertEquals(tbl3[i][j], val2[j]) end
  end

  -- key by value
  tbl3:insrow(2, {"v3", 3, 3, 3})
  tbl3:insrow("v3", {"v4", 4, 4, 4})
  for i=1,4 do
    assertEquals(tbl3[2][i], val4[i])
    assertEquals(tbl3[3][i], val3[i])
  end

  -- ref
  tbl3:insrow("v2[3]", {"v5", 1, 2, 3})
  tbl3:insrow("v2{1}", {"v6", 1, 2, 3}, nil, 3)
  assertEquals(tbl3[6][1], "v5")
  assertEquals(tbl3[4][1], "v6")

  -- nil
  tbl4:addrow({ nil, nil, nil, "v2" })              -- TODO to be removed once insert empty table is fixed
  -- assertErrorMsgContains("table index is nil", tbl4.insrow, tbl4, 1, { }) -- TODO Doesn't copy nil so doesn't emmit an error
  tbl4:insrow(1, { nil, nil, nil, "v2" })
  -- tbl4:insrow(2, { nil, nil, nil, "v2" }) -- TODO should be able to add at the end
  for j=1,3 do assertEquals(tbl4[1][j], nil) end
  assertEquals(tbl4[1][4], "v2")
end

function TestMTable:testSetRow()
  local tbl1  = mtable 'tbl1'  { }
  local tbl2  = mtable 'tbl2'  { 'x', 'y', 'z' }
  local tbl3  = mtable 'tbl3'  { {'dict'}, 'x', 'y', 'z' }
  local tbl4  = mtable 'tbl4'  { 'x', 'y', 'z', {'dict'} }
  local tbl32 = tbl3   'tbl32' { }
  local ini1  = { 0, 0, 0 }
  local ini2  = { "v0", 0, 0, 0 }
  local val1  = { 1, 2, 3 }
  local val2  = { "v2", 1, 2, 3 }
  local val3  = { "v3", 3, 3, 3 }
  local val4  = { "v4", 4, 4, 4 }

  -- mtable:setrow(1,val1)               -- TODO mtable should be readonly + cannot on empty table
  tbl2:addrow(ini1); tbl2:addrow(ini1)
  tbl3:addrow(ini2); tbl3:addrow(ini2)
  tbl2:setrow(1, val1)
  tbl3:setrow(1, val2)

  -- ini
  tbl2:setrow(2, { 5, 5, 5, 5, 1, 2, 3 }, 5)
  tbl3:setrow(2, { 5, 5, 5, 5, "v2", 1, 2, 3 }, 5)

  assertEquals(#tbl2, 2)
  assertEquals(#tbl3, 2)

  for i=1,2 do
    for j=1,3 do assertEquals(tbl2[i][j], val1[j]) end
    for j=1,4 do assertEquals(tbl3[i][j], val2[j]) end
  end

  -- key by value
  tbl3:setrow(1, {"v3", 3, 3, 3})
  tbl3:setrow("v2", {"v4", 4, 4, 4})
  for i=1,4 do
    assertEquals(tbl3[1][i], val3[i])
    assertEquals(tbl3[2][i], val4[i])
  end

  -- ref
  tbl3:insrow(1, ini2); tbl3:insrow(3, ini2); tbl3:addrow(ini2)
  -- tbl3:setrow("v0[3]", {"v5", 1, 2, 3})      -- TODO corrupted dictionary due to rem_idx
  -- tbl3:setrow("v0{1}", {"v6", 1, 2, 3}, nil, 2)
  -- assertEquals(tbl3[5][1], "v5")
  -- assertEquals(tbl3[3][1], "v6")

  -- nil
  tbl4:addrow { 1, 2, 3, "v2" }
  -- assertErrorMsgContains("table index is nil", tbl4.setrow, tbl4, 1, { }) -- TODO Doesn't copy nil so doesn't emmit an error
  -- tbl4:setrow(1, { nil, nil, nil, "v3" }) -- TODO doen't set to nil
  -- for j=1,3 do assertEquals(tbl4[1][j], nil) end
  -- assertEquals(tbl4[1][4], "v3")
end

function TestMTable:testRemRow()
  local tbl1  = mtable 'tbl1'  { }
  local tbl2  = mtable 'tbl2'  { 'x', 'y', 'z' }
  local tbl3  = mtable 'tbl3'  { {'dict'}, 'x', 'y', 'z' }
  local tbl4  = mtable 'tbl4'  { 'x', 'y', 'z', {'dict'} }
  local tbl32 = tbl3   'tbl32' { }
  local ini1  = { 0, 0, 0 }
  local ini2  = { "v0", 0, 0, 0 }
  local val1  = { 1, 2, 3 }

  -- mtable:setrow(1,val1)               -- TODO mtable should be readonly + cannot on empty table
  tbl2:addrow(ini1); tbl2:addrow(ini1); tbl2:addrow(ini1)
  tbl3:addrow(ini2); tbl3:addrow(ini2); tbl3:addrow(ini2)
  -- tbl2:remrow(2); tbl2:remrow(2); tbl2:remrow(1) -- TODO corrupted dictionary due to rem_idx
  -- tbl3:remrow(2); tbl3:remrow(2); tbl3:remrow(1)

  -- assertEquals(#tbl2, 0)
  -- assertEquals(#tbl3, 0)

  -- key by value
  tbl3:addrow(ini2)
  -- tbl3:remrow("v0")           -- TODO corrupted dictionarry due to rem_idx
  -- assertEquals(#tbl3, 0)

  -- ref
  tbl3:addrow({ "v0", 1, 0, 0 });
  tbl3:addrow({ "v0", 2, 0, 0 });
  tbl3:addrow({ "v0", 3, 0, 0 });
  -- tbl3:remrow("v0[3]")      -- TODO corrupted dictionarry due to rem_idx
  -- tbl3:remrow("v0{1}", 2)
  -- assertEquals(tbl3[1][1], "v0")
  -- assertEquals(tbl3[1][2], 1)
  -- assertEquals(#tbl3, 1)
end

function TestMTable:testGetRow()
  local tbl1  = mtable 'tbl1'  { 'x', 'y', 'z' }
  local tbl2  = mtable 'tbl2'  { {'dict'}, 'x', 'y', 'z' }
  local tbl22 = tbl2   'tbl22' { }
  local val1  = { 1, 2, 3 }
  local val2  = { "v2", 4, 3, 2 }

  tbl1:addrow(val1);
  tbl2:addrow(val2);
  for k,v in pairs(tbl1:getrow(1))  do assertEquals(v, val1[k]) end
  for k,v in pairs(tbl2:getrow(1))  do assertEquals(v, val2[k]) end
  for k,v in pairs(tbl22:getrow(1)) do assertEquals(v, val2[k]) end

  -- key by value
  for k,v in pairs(tbl2:getrow("v2"))  do assertEquals(v, val2[k]) end
  for k,v in pairs(tbl22:getrow("v2")) do assertEquals(v, val2[k]) end

  -- ref
  tbl2:addrow({ "v0", 1, 0, 0 });
  tbl2:addrow({ "v0", 2, 0, 0 });
  tbl2:addrow({ "v0", 3, 0, 0 });
  assertEquals(tbl2:getrow("v0").x, 1)
  assertEquals(tbl2:getrow("v0[2]").x, 2)
  assertEquals(tbl2:getrow("v0{2}", 3).x, 3)
end

function TestMTable:testSwpRow()
  local tbl1  = mtable 'tbl1'  { 'x', 'y', 'z' }
  local tbl2  = mtable 'tbl2'  { {'dict'}, 'x', 'y', 'z' }
  local tbl22 = tbl2   'tbl22' { }

  tbl1:addrow{ 1, 1, 1 }          ; tbl1:addrow{ 2, 2, 3 }
  tbl2:addrow{ "v1", 1, 1, 1 }    ; tbl2:addrow{ "v2", 2, 2, 2 }
  assertEquals(tbl1[1][1], 1)     ; assertEquals(tbl1[2][1], 2)
  assertEquals(tbl2[1][1], "v1")  ; assertEquals(tbl2[2][1], "v2")
  tbl1:swprow(1,2)
  tbl2:swprow(1,2)
  assertEquals(tbl1[1][1], 2)     ; assertEquals(tbl1[2][1], 1)
  assertEquals(tbl2[1][1],  "v2") ; assertEquals(tbl2[2][1],  "v1")
  assertEquals(tbl22[1][1], "v2") ; assertEquals(tbl22[2][1], "v1")

  -- key by value
  tbl2:swprow("v1","v2")
  assertEquals(tbl2[1][1],  "v1") ; assertEquals(tbl2[2][1],  "v2")
  assertEquals(tbl22[1][1], "v1") ; assertEquals(tbl22[2][1], "v2")

  -- ref
  tbl2:addrow{ "v0", 1, 0, 0 };
  tbl2:addrow{ "v0", 2, 0, 0 };
  tbl2:addrow{ "v0", 3, 0, 0 };
  tbl2:swprow("v0[2]", "v0{2}", 4)
  assertEquals(tbl2[4].x, 3)
  assertEquals(tbl2[5].x, 2)
end

-- end ------------------------------------------------------------------------o