--[=[
 o-----------------------------------------------------------------------------o
 |
 | MTable tests
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide regression test suites for the mtable module.

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local assertFalse, assertTrue, assertNil, assertNotNil, assertEquals,
  assertStrContains, assertErrorMsgContains                        in MAD.utest
local mtable, filesys                                              in MAD
local is_table, is_vector, is_mtable, is_original_mtable           in MAD.typeid

local generate = true
local refdir   = \s -> "mtable_ref/"..s
local rundir   = \s -> "mtable_run/"..s

-- helpers --------------------------------------------------------------------o

local function assertFiles (name)
  if generate then return end
  local ref  = assert(io.open(refdir(name), "r"))
  local run  = assert(io.open(rundir(name), "r"))
  local reftbl, sref = string.splitall(ref:read("*all"), " \n,:;[]")
  local runtbl, srun = string.splitall(run:read("*all"), " \n,:;[]")
  assertEquals(sref, srun)
  for i=1,sref do
    reftbl[i] = tonumber(reftbl[i]) or reftbl[i]
    runtbl[i] = tonumber(runtbl[i]) or runtbl[i]
    if is_number(reftbl[i]) then
      local approx = abs(runtbl[i]-reftbl[i])
      if 14*eps < approx then
        local div = min(runtbl[i], reftbl[i])
        if div == 0 then
          assertAlmostEquals(approx, 0, 1.1e-5)
        else
          assertAlmostEquals((runtbl[i]-reftbl[i])/div, 0, 1.1e-6)
        end
      end
    else
      assertEquals(runtbl[i], reftbl[i])
    end
  end
  if not generate then os.remove(rundir(name)) end
end

local function testWrite(tbl, filnam_, colnam_, hdrnam_)
  tbl:write(rundir(filnam_), colnam_, hdrnam_)
  assertFiles(filnam_)
end

-- regression test suite ------------------------------------------------------o

TestMTable = {}

function TestMTable:testConstructor()
  local tbl1  = mtable 'tbl1'  { }
  local tbl2  = mtable 'tbl2'  { 'x', 'y', 'z' }
  local tbl3  = mtable 'tbl3'  { {'dict'}, 'x', 'y', 'z' }
  local tbl4  = mtable 'tbl4'  { 'x', 'y', 'z', {'dict'} }
  local tbl42 = tbl4   'tbl42' { }

  assertEquals(#tbl1,  0)
  assertEquals(#tbl2,  0)
  assertEquals(#tbl3,  0)
  assertEquals(#tbl4,  0)
  assertEquals(#tbl42, 0)

  assertEquals(tbl1.name, 'tbl1')
  assertEquals(tbl2.name, 'tbl2')
  assertEquals(tbl3.name, 'tbl3')
  assertEquals(tbl4.name, 'tbl4')
  assertEquals(tbl42.name, 'tbl42')

  for _,col in ipairs({'x', 'y', 'z'}) do
    assertNil(tbl1[col])
    assertNotNil(tbl2[col])
    assertNotNil(tbl3[col])
    assertNotNil(tbl4[col])
    assertNotNil(tbl42[col])
  end

  assertNotNil(tbl3.dict)
  assertNotNil(tbl4.dict)
  assertNotNil(tbl42.dict)
end

function TestMTable:testIsMtable()
  local tbl1  = mtable 'tbl1'  { }
  local tbl2  = mtable 'tbl2'  { 'x', 'y', 'z' }
  local tbl3  = mtable 'tbl3'  { {'dict'}, 'x', 'y', 'z' }
  local tbl32 = tbl3   'tbl32' { }

  assertTrue(is_mtable(tbl1))
  assertTrue(is_mtable(tbl2))
  assertTrue(is_mtable(tbl3))
  assertTrue(is_mtable(tbl32))

  assertFalse(is_original_mtable(tbl1))
  assertTrue(is_original_mtable(tbl2))
  assertTrue(is_original_mtable(tbl3))
  assertFalse(is_original_mtable(tbl32))
end

function TestMTable:testAddRow()
  local tbl1  = mtable 'tbl1'  { }
  local tbl2  = mtable 'tbl2'  { 'x', 'y', 'z' }
  local tbl3  = mtable 'tbl3'  { {'dict'}, 'x', 'y', 'z' }
  local tbl4  = mtable 'tbl4'  { 'x', 'y', 'z', {'dict'} }
  local tbl32 = tbl3   'tbl32' { }
  local val1  = { 1, 2, 3 }
  local val2  = { "v2", 1, 2, 3 }
  -- using operator
  -- local test = mtable + val1          -- TODO mtable should be readonly
  -- tbl1  = tbl1 + val1                 -- TODO shlould not work (not original)
  tbl2 = tbl2 + val1
  tbl3 = tbl3 + val2
  -- tbl32 = tbl32 + val2                -- TODO shlould not work (not original)

  -- using addrow
  -- mtable:addrow(val1)                 -- TODO mtable should be readonly
  -- tbl1:addrow { 1, 2, 3 }             -- TODO shlould not work (not original)
  tbl2:addrow(val1)
  tbl3:addrow(val2)
  -- tbl32:addrow(val2)                  -- TODO shlould not work (not original)

  -- ini
  tbl2:addrow({ 5, 5, 5, 5, 1, 2, 3 }, 5)
  tbl3:addrow({ 5, 5, 5, 5, "v2", 1, 2, 3 }, 5)

  assertEquals(#tbl2, 3)
  assertEquals(#tbl3, 3)

  for i=1,3 do
    for j=1,3 do assertEquals(tbl2[i][j], val1[j]) end
    for j=1,4 do assertEquals(tbl3[i][j], val2[j]) end
  end

  -- nil
  assertErrorMsgContains("table index is nil", tbl4.addrow, tbl4, { })
  -- assertErrorMsgContains("table index is nil", tbl4.addrow, tbl4, { 1 }) -- TODO doesn't let tbl4 unmodified
  tbl4:addrow { nil, nil, nil, "v2" }
  for j=1,3 do assertEquals(tbl4[1][j], nil) end
  assertEquals(tbl4[1][4], "v2")
end

function TestMTable:testInsRow()
  local tbl1  = mtable 'tbl1'  { }
  local tbl2  = mtable 'tbl2'  { 'x', 'y', 'z' }
  local tbl3  = mtable 'tbl3'  { {'dict'}, 'x', 'y', 'z' }
  local tbl4  = mtable 'tbl4'  { 'x', 'y', 'z', {'dict'} }
  local tbl32 = tbl3   'tbl32' { }
  local val1  = { 1, 2, 3 }
  local val2  = { "v2", 1, 2, 3 }
  local val3  = { "v3", 3, 3, 3 }
  local val4  = { "v4", 4, 4, 4 }

  -- mtable:insrow(1,val1)               -- TODO mtable should be readonly + cannot on empty table
  tbl2:addrow(val1)                      -- TODO to be removed once insert empty table is fixed
  tbl3:addrow(val2)                      -- TODO to be removed once insert empty table is fixed
  tbl2:insrow(1, val1)
  tbl3:insrow(1, val2)

  -- ini
  tbl2:insrow(2,{ 5, 5, 5, 5, 1, 2, 3 }, 5)
  tbl3:insrow(2,{ 5, 5, 5, 5, "v2", 1, 2, 3 }, 5)

  assertEquals(#tbl2, 3) -- TODO 2 once modified
  assertEquals(#tbl3, 3) -- TODO 2 once modified

  for i=1,3 do -- TODO i=1,2 once modified
    for j=1,3 do assertEquals(tbl2[i][j], val1[j]) end
    for j=1,4 do assertEquals(tbl3[i][j], val2[j]) end
  end

  -- key by value
  tbl3:insrow(2, {"v3", 3, 3, 3})
  tbl3:insrow("v3", {"v4", 4, 4, 4})
  for i=1,4 do
    assertEquals(tbl3[2][i], val4[i])
    assertEquals(tbl3[3][i], val3[i])
  end

  -- ref
  tbl3:insrow("v2[3]", {"v5", 1, 2, 3})
  tbl3:insrow("v2{1}", {"v6", 1, 2, 3}, nil, 3)
  assertEquals(tbl3[6][1], "v5")
  assertEquals(tbl3[4][1], "v6")

  -- nil
  tbl4:addrow({ nil, nil, nil, "v2" })              -- TODO to be removed once insert empty table is fixed
  -- assertErrorMsgContains("table index is nil", tbl4.insrow, tbl4, 1, { }) -- TODO Doesn't copy nil so doesn't emmit an error
  tbl4:insrow(1, { nil, nil, nil, "v2" })
  -- tbl4:insrow(2, { nil, nil, nil, "v2" }) -- TODO should be able to add at the end
  for j=1,3 do assertEquals(tbl4[1][j], nil) end
  assertEquals(tbl4[1][4], "v2")
end

function TestMTable:testSetRow()
  local tbl1  = mtable 'tbl1'  { }
  local tbl2  = mtable 'tbl2'  { 'x', 'y', 'z' }
  local tbl3  = mtable 'tbl3'  { {'dict'}, 'x', 'y', 'z' }
  local tbl4  = mtable 'tbl4'  { 'x', 'y', 'z', {'dict'} }
  local tbl32 = tbl3   'tbl32' { }
  local ini1  = { 0, 0, 0 }
  local ini2  = { "v0", 0, 0, 0 }
  local val1  = { 1, 2, 3 }
  local val2  = { "v2", 1, 2, 3 }
  local val3  = { "v3", 3, 3, 3 }
  local val4  = { "v4", 4, 4, 4 }

  -- mtable:setrow(1,val1)               -- TODO mtable should be readonly + cannot on empty table
  tbl2:addrow(ini1); tbl2:addrow(ini1)
  tbl3:addrow(ini2); tbl3:addrow(ini2)
  tbl2:setrow(1, val1)
  tbl3:setrow(1, val2)

  -- ini
  tbl2:setrow(2, { 5, 5, 5, 5, 1, 2, 3 }, 5)
  tbl3:setrow(2, { 5, 5, 5, 5, "v2", 1, 2, 3 }, 5)

  assertEquals(#tbl2, 2)
  assertEquals(#tbl3, 2)

  for i=1,2 do
    for j=1,3 do assertEquals(tbl2[i][j], val1[j]) end
    for j=1,4 do assertEquals(tbl3[i][j], val2[j]) end
  end

  -- key by value
  tbl3:setrow(1, {"v3", 3, 3, 3})
  tbl3:setrow("v2", {"v4", 4, 4, 4})
  for i=1,4 do
    assertEquals(tbl3[1][i], val3[i])
    assertEquals(tbl3[2][i], val4[i])
  end

  -- ref
  tbl3:insrow(1, ini2); tbl3:insrow(3, ini2); tbl3:addrow(ini2)
  -- tbl3:setrow("v0[3]", {"v5", 1, 2, 3})      -- TODO corrupted dictionary due to rem_idx
  -- tbl3:setrow("v0{1}", {"v6", 1, 2, 3}, nil, 2)
  -- assertEquals(tbl3[5][1], "v5")
  -- assertEquals(tbl3[3][1], "v6")

  -- nil
  tbl4:addrow { 1, 2, 3, "v2" }
  -- assertErrorMsgContains("table index is nil", tbl4.setrow, tbl4, 1, { }) -- TODO Doesn't copy nil so doesn't emmit an error
  -- tbl4:setrow(1, { nil, nil, nil, "v3" }) -- TODO doen't set to nil
  -- for j=1,3 do assertEquals(tbl4[1][j], nil) end
  -- assertEquals(tbl4[1][4], "v3")
end

function TestMTable:testRemRow()
  local tbl1  = mtable 'tbl1'  { }
  local tbl2  = mtable 'tbl2'  { 'x', 'y', 'z' }
  local tbl3  = mtable 'tbl3'  { {'dict'}, 'x', 'y', 'z' }
  local tbl4  = mtable 'tbl4'  { 'x', 'y', 'z', {'dict'} }
  local tbl32 = tbl3   'tbl32' { }
  local ini1  = { 0, 0, 0 }
  local ini2  = { "v0", 0, 0, 0 }
  local val1  = { 1, 2, 3 }

  -- mtable:setrow(1,val1)               -- TODO mtable should be readonly + cannot on empty table
  tbl2:addrow(ini1); tbl2:addrow(ini1); tbl2:addrow(ini1)
  tbl3:addrow(ini2); tbl3:addrow(ini2); tbl3:addrow(ini2)
  -- tbl2:remrow(2); tbl2:remrow(2); tbl2:remrow(1) -- TODO corrupted dictionary due to rem_idx
  -- tbl3:remrow(2); tbl3:remrow(2); tbl3:remrow(1)

  -- assertEquals(#tbl2, 0)
  -- assertEquals(#tbl3, 0)

  -- key by value
  tbl3:addrow(ini2)
  -- tbl3:remrow("v0")           -- TODO corrupted dictionarry due to rem_idx
  -- assertEquals(#tbl3, 0)

  -- ref
  tbl3:addrow({ "v0", 1, 0, 0 });
  tbl3:addrow({ "v0", 2, 0, 0 });
  tbl3:addrow({ "v0", 3, 0, 0 });
  -- tbl3:remrow("v0[3]")      -- TODO corrupted dictionarry due to rem_idx
  -- tbl3:remrow("v0{1}", 2)
  -- assertEquals(tbl3[1][1], "v0")
  -- assertEquals(tbl3[1][2], 1)
  -- assertEquals(#tbl3, 1)
end

function TestMTable:testGetRow()
  local tbl1  = mtable 'tbl1'  { 'x', 'y', 'z' }
  local tbl2  = mtable 'tbl2'  { {'dict'}, 'x', 'y', 'z' }
  local tbl22 = tbl2   'tbl22' { }
  local val1  = { 1, 2, 3 }
  local val2  = { "v2", 4, 3, 2 }

  tbl1:addrow(val1);
  tbl2:addrow(val2);
  for k,v in pairs(tbl1:getrow(1))  do assertEquals(v, val1[k]) end
  for k,v in pairs(tbl2:getrow(1))  do assertEquals(v, val2[k]) end
  for k,v in pairs(tbl22:getrow(1)) do assertEquals(v, val2[k]) end

  -- key by value
  for k,v in pairs(tbl2:getrow("v2"))  do assertEquals(v, val2[k]) end
  for k,v in pairs(tbl22:getrow("v2")) do assertEquals(v, val2[k]) end

  -- ref
  tbl2:addrow({ "v0", 1, 0, 0 });
  tbl2:addrow({ "v0", 2, 0, 0 });
  tbl2:addrow({ "v0", 3, 0, 0 });
  assertEquals(tbl2:getrow("v0").x, 1)
  assertEquals(tbl2:getrow("v0[2]").x, 2)
  assertEquals(tbl2:getrow("v0{2}", 3).x, 3)
end

function TestMTable:testSwpRow()
  local tbl1  = mtable 'tbl1'  { 'x', 'y', 'z' }
  local tbl2  = mtable 'tbl2'  { {'dict'}, 'x', 'y', 'z' }
  local tbl22 = tbl2   'tbl22' { }

  tbl1:addrow{ 1, 1, 1 }          ; tbl1:addrow{ 2, 2, 3 }
  tbl2:addrow{ "v1", 1, 1, 1 }    ; tbl2:addrow{ "v2", 2, 2, 2 }
  assertEquals(tbl1[1][1], 1)     ; assertEquals(tbl1[2][1], 2)
  assertEquals(tbl2[1][1], "v1")  ; assertEquals(tbl2[2][1], "v2")
  tbl1:swprow(1,2)
  tbl2:swprow(1,2)
  assertEquals(tbl1[1][1], 2)     ; assertEquals(tbl1[2][1], 1)
  assertEquals(tbl2[1][1],  "v2") ; assertEquals(tbl2[2][1],  "v1")
  assertEquals(tbl22[1][1], "v2") ; assertEquals(tbl22[2][1], "v1")

  -- key by value
  tbl2:swprow("v1","v2")
  assertEquals(tbl2[1][1],  "v1") ; assertEquals(tbl2[2][1],  "v2")
  assertEquals(tbl22[1][1], "v1") ; assertEquals(tbl22[2][1], "v2")

  -- ref
  tbl2:addrow{ "v0", 1, 0, 0 };
  tbl2:addrow{ "v0", 2, 0, 0 };
  tbl2:addrow{ "v0", 3, 0, 0 };
  -- tbl2:swprow("v0[2]", "v0{2}", 4) -- TODO corrupted dictionarry due to rem_idx
  -- assertEquals(tbl2[4].x, 3)
  -- assertEquals(tbl2[5].x, 2)
end

function TestMTable:testAddCol()
  local tbl1  = mtable 'tbl1'  { }
  local tbl2  = mtable 'tbl2'  { 'x', 'y', 'z' }
  local tbl3  = mtable 'tbl3'  { {'dict'}, 'x', 'y', 'z' }
  local tbl32 = tbl3   'tbl32' { }
  local col1  = { 1, 2, 3 }
  local row1  = { 1, 2, 3 }
  local row2  = { "v0", 1, 2, 3 }
  local msg   = {
    "invalid modification of readonly mtable",
    "invalid argument #1 (original mtable expected)",
    "incompatible container size",
  }

  assertErrorMsgContains(msg[3], mtable.addcol, tbl2, "val1", col1)
  assertErrorMsgContains(msg[3], mtable.addcol, tbl3, "val2", col1)

  for i=1,3 do tbl2:addrow(row1); tbl3:addrow(row2) end
  -- tbl2:addcol("col1", col1) -- TODO fix vector nr in add_col
  -- tbl3:addcol("col1", col1)

  -- generators
  tbl2:addcol("col1", \i -> i)
  tbl3:addcol("col1", \i -> i)
  for i=1,3 do
    assertEquals(tbl2[i][4], i)
    assertEquals(tbl3[i][5], i)
  end

  -- nil
  tbl2:addcol("col2", {}, true)
  tbl3:addcol("col2", {}, true)
  -- assertTrue(is_vector(tbl2.col1)) -- TODO fix vector nr in add_col
  assertFalse(is_vector(tbl2.col2))
  -- assertTrue(is_vector(tbl3.col1))
  assertFalse(is_vector(tbl3.col2))

  assertErrorMsgContains(msg[1], mtable.addcol, mtable, "colname", { })
  assertErrorMsgContains(msg[2], mtable.addcol, tbl1,   "colname", { })
  assertErrorMsgContains(msg[2], mtable.addcol, tbl32,  "colname", { })
end

function TestMTable:testGetCol()
  local tbl1  = mtable 'tbl1'  { 'x', 'y', 'z' }
  local tbl2  = mtable 'tbl2'  { {'dict'}, 'x', 'y', 'z' }
  local tbl22 = tbl2   'tbl22' { }
  local row1  = { 1, 2, 3 }
  local row2  = { "v0", 1, 2, 3 }
  local col   = { 1, 1, 1 }

  for i=1,3 do tbl1:addrow(row1); tbl2:addrow(row2) end
  for i,v in ipairs(tbl1:getcol("x"))  do assertEquals(v, 1) end
  for i,v in ipairs(tbl2:getcol("x"))  do assertEquals(v, 1) end
  for i,v in ipairs(tbl22:getcol("x")) do assertEquals(v, 1) end
  for i,v in ipairs(tbl1:getcol(2))    do assertEquals(v, 2) end
  for i,v in ipairs(tbl2:getcol(3))    do assertEquals(v, 2) end
  for i,v in ipairs(tbl22:getcol(3))   do assertEquals(v, 2) end
  for i,v in ipairs(tbl1:getcol(-1))   do assertEquals(v, 3) end
  -- for i,v in ipairs(tbl2:getcol(-1))  do assertEquals(v, 3) end -- TODO fix nr use to nc in get_col
  -- for i,v in ipairs(tbl22:getcol(-1))  do assertEquals(v, 3) end -- TODO fix nr use to nc in get_col

  assertNil(tbl1:getcol(4))
  assertNil(tbl2:getcol(5))
  assertNil(tbl22:getcol(5))
  assertNil(tbl1:getcol("none"))
  assertNil(tbl2:getcol("none"))
  assertNil(tbl22:getcol("none"))
end

function TestMTable:testRemCol()
  local tbl1  = mtable 'tbl1'  { 'x', 'y', 'z' }
  local tbl2  = mtable 'tbl2'  { {'dict'}, 'x', 'y', 'z' }
  local tbl22 = tbl2   'tbl22' { }
  local row1  = { 1, 2, 3 }
  local row2  = { "v0", 1, 2, 3 }
  local msg   = {
    "invalid argument #2 (generator column expected)",
    "invalid argument #2 (valid column expected",
    "invalid argument #1 (original mtable expected)",
  }

  for i=1,3 do tbl1:addrow(row1); tbl2:addrow(row2) end
  tbl1:addcol("c1", \i->i) ; tbl1:addcol("c2", \i->i) ; tbl1:addcol("c3", \i->i)
  tbl2:addcol("c1", \i->i) ; tbl2:addcol("c2", \i->i) ; tbl2:addcol("c3", \i->i)

  assertErrorMsgContains(msg[3], mtable.remcol, tbl22, "c2")

  tbl1:remcol(5)           ; tbl1:remcol("c1")       -- ; tbl1:remcol(-1)    -- TODO fix negative index is not superted
  tbl2:remcol(6)           ; tbl2:remcol("c1")       -- ; tbl2:remcol(-1)    -- TODO fix negative index is not superted
  assertNil(tbl1.c1)       ; assertNil(tbl1.c2)      -- ; assertNil(tbl1.c3) -- TODO fix negative index is not superted
  assertNil(tbl2.c1)       ; assertNil(tbl2.c2)      -- ; assertNil(tbl2.c3) -- TODO fix negative index is not superted

  for i=1,3 do assertErrorMsgContains(msg[1], mtable.remcol, tbl1, i) end
  for i=1,4 do assertErrorMsgContains(msg[1], mtable.remcol, tbl2, i) end
  assertErrorMsgContains(msg[1], mtable.remcol, tbl1, 100)
  assertErrorMsgContains(msg[2], mtable.remcol, tbl1, "none")
end

function TestMTable:testGetSet()
  local tbl1     = mtable 'tbl1'  { 'x', 'y', 'z' }
  local tbl2     = mtable 'tbl2'  { {'dict'}, 'x', 'y', 'z' }
  local tbl22    = tbl2   'tbl22' { }
  local v        = 271
  for i=1,3 do tbl1:addrow{1,2,3}; tbl2:addrow{"v0",1,2,3} end

  for i=1,3 do
    for j=1,3 do
      tbl1:set(i  , j  , j*v+i); assertEquals(tbl1:get(i  , j  ), j*v+i)
      tbl1:set(i  , j-4, j*v+i); assertEquals(tbl1:get(i  , j-4), j*v+i)
      tbl1:set(i-4, j  , j*v+i); assertEquals(tbl1:get(i-4, j  ), j*v+i)
      tbl1:set(i-4, j-4, j*v+i); assertEquals(tbl1:get(i-4, j-4), j*v+i)
    end
    for j=2,4 do
      tbl2:set(i  , j  , j*v+i); assertEquals(tbl2:get(i  , j  ), j*v+i)
      tbl2:set(i  , j-5, j*v+i); assertEquals(tbl2:get(i  , j-5), j*v+i)
      tbl2:set(i-4, j  , j*v+i); assertEquals(tbl2:get(i-4, j  ), j*v+i)
      tbl2:set(i-4, j-5, j*v+i); assertEquals(tbl2:get(i-4, j-5), j*v+i)

      assertEquals(tbl22:get(i  , j  ), j*v+i)
      assertEquals(tbl22:get(i  , j-5), j*v+i)
      assertEquals(tbl22:get(i-4, j  ), j*v+i)
      assertEquals(tbl22:get(i-4, j-5), j*v+i)
    end
    for j,v1 in ipairs{'x','y','z'} do
      tbl1:set(i , v1, j*v+i); assertEquals(tbl1:get(i , v1), j*v+i)
      tbl2:set(i , v1, j*v+i); assertEquals(tbl2:get(i , v1), j*v+i)
      tbl22:set(i, v1, j*v+i); assertEquals(tbl22:get(i, v1), j*v+i)
    end
    -- tbl2:set(i, 1     , "v1"); assertEquals(tbl2:get(i, 1     ), "v1") -- TODO update dictionarry not working
    -- tbl2:set(i, "dict", "v1"); assertEquals(tbl2:get(i, "dict"), "v1") -- TODO update dictionarry not working
    -- tbl2:set("v1", 2  , i, v+2*i); assertEquals(tbl2:get("v1", 2   , i  ), v+2*i) -- TODO update dictionarry not working
    -- tbl2:set("v1", "x", i, v+3*i); assertEquals(tbl2:get("v1", "x" , i  ), v+3*i) -- TODO update dictionarry not working
    -- tbl2:set("v1", 2   , i-4, v+4*i); assertEquals(tbl2:get("v1", 2   , i-4), v+4*i) -- TODO fix reflection on cn1 -- TODO update dictionarry not working
    -- tbl2:set("v1", "x" , i-4, v+5*i); assertEquals(tbl2:get("v1", "x" , i-4), v+5*i) -- TODO fix reflection on cn1 -- TODO update dictionarry not working

    -- assertEquals(tbl22:get(i, 1     ), "v1")    -- TODO update dictionarry not working
    -- assertEquals(tbl22:get(i, "dict"), "v1")    -- TODO update dictionarry not working
    -- assertEquals(tbl22:get("v1", 2   , i  ), 1) -- TODO update dictionarry not working
    -- assertEquals(tbl22:get("v1", "x" , i  ), 1) -- TODO update dictionarry not working
    -- assertEquals(tbl22:get("v1", 2   , i-4), 1) -- TODO fix reflection on cnt -- TODO update dictionarry not working
    -- assertEquals(tbl22:get("v1", "x" , i-4), 1) -- TODO fix reflection on cnt -- TODO update dictionarry not working
  end
end

function TestMTable:testNoVector()
  local tbl11 = mtable 'tbl11' { 'x', 'y', 'z' }
  local tbl12 = mtable 'tbl12' { 'x', 'y', 'z', novector = true }
  local tbl13 = mtable 'tbl13' { 'x', 'y', 'z', novector = {1, "y"} }
  local tbl21 = mtable 'tbl21' { {'dict'}, 'x', 'y', 'z' }
  local tbl22 = mtable 'tbl22' { {'dict'}, 'x', 'y', 'z', novector = true }
  local tbl23 = mtable 'tbl23' { {'dict'}, 'x', 'y', 'z', novector = {2, "y"} }
  local row1  = { 1, 2, 3 }
  local row2  = { "v0", 1, 2, 3}
  local col1   = { 10, 10 }
  local col2   = { 15, 15 }

  tbl11:addrow(row1); tbl11:addrow(row1); tbl21:addrow(row2); tbl21:addrow(row2)
  tbl12:addrow(row1); tbl12:addrow(row1); tbl22:addrow(row2); tbl22:addrow(row2)
  tbl13:addrow(row1); tbl13:addrow(row1); tbl23:addrow(row2); tbl23:addrow(row2)

  for i=1,3 do
    assertTrue(is_vector(tbl11:getcol(i)))
    assertTrue(is_vector(tbl21:getcol(i+1)))

    assertTrue(is_table(tbl12:getcol(i)))
    assertTrue(is_table(tbl22:getcol(i+1)))
  end

  for i=1,2 do
    assertTrue(is_table(tbl13:getcol(i)))
    assertTrue(is_table(tbl23:getcol(i+1)))
  end
  assertTrue(is_vector(tbl13:getcol(3)))
  assertTrue(is_vector(tbl23:getcol(4)))
  assertTrue(is_table (tbl23:getcol(1)))

  -- maintenance after adding columns
  -- tbl11:addcol("c1", col1); tbl11:addcol("c2", col2, true) -- TODO fix vector nr in add_col -- todo fix rmax in expand
  -- tbl12:addcol("c1", col1); tbl12:addcol("c2", col2, true) -- TODO fix vector nr in add_col -- todo fix rmax in expand
  -- tbl13:addcol("c1", col1); tbl13:addcol("c2", col2, true) -- TODO fix vector nr in add_col -- todo fix rmax in expand
  -- tbl21:addcol("c1", col1); tbl21:addcol("c2", col2, true) -- TODO fix vector nr in add_col -- todo fix rmax in expand
  -- tbl22:addcol("c1", col1); tbl22:addcol("c2", col2, true) -- TODO fix vector nr in add_col -- todo fix rmax in expand
  -- tbl23:addcol("c1", col1); tbl23:addcol("c2", col2, true) -- TODO fix vector nr in add_col -- todo fix rmax in expand

  -- assertTrue(is_vector(tbl11:getcol("c1"))) -- TODO fix addcol
  -- assertTrue(is_table (tbl12:getcol("c1"))) -- TODO fix addcol -- TODO fix nvec_ behavior
  -- assertTrue(is_vector(tbl13:getcol("c1"))) -- TODO fix addcol
  -- assertTrue(is_vector(tbl21:getcol("c1"))) -- TODO fix addcol
  -- assertTrue(is_table (tbl22:getcol("c1"))) -- TODO fix addcol -- TODO fix nvec_ behavior
  -- assertTrue(is_vector(tbl23:getcol("c1"))) -- TODO fix addcol

  -- assertTrue(is_table(tbl11:getcol("c2"))) -- TODO fix addcol
  -- assertTrue(is_table(tbl12:getcol("c2"))) -- TODO fix addcol
  -- assertTrue(is_table(tbl13:getcol("c2"))) -- TODO fix addcol
  -- assertTrue(is_table(tbl21:getcol("c2"))) -- TODO fix addcol
  -- assertTrue(is_table(tbl22:getcol("c2"))) -- TODO fix addcol
  -- assertTrue(is_table(tbl23:getcol("c2"))) -- TODO fix addcol
end

function TestMTable:testWrite()
  filesys.mkdir(rundir(""))
  local tbl1 = mtable 'tbl1' { 'x', 'y', 'z' }
  local tbl2 = mtable 'tbl2' { {'dict'}, 'x', 'y', 'z' }
  -- local tbl3 = mtable 'tbl3' { {'dict'}, 'x', 'y', 'z', column = {"x", 3}} -- TODO fix column name when integer argument -- TODO fix table_ini table.cat calls
  local tbl4 = mtable 'tbl4' {
    {'dict'}, 'x', 'y', 'z',
    header1 = "MyHeader1", header2 = 42,
    header  = {"header1", "header2"}
  }
  local tbl5 = mtable 'tbl5' {
    {'name'}, 'x', 'y', 'z',
    header1="header 'whith quote'",
    header2="header \"double quote\"",
    header3=42.5,
    novector=true
  }

  local row1 = { 1, 2, 3 }
  local row2 = { "v0", 1, 2, 3}

  tbl1.time, tbl1.date, tbl1.origin = "", "", ""
  tbl2.time, tbl2.date, tbl2.origin = "", "", ""
  -- tbl3.time, tbl3.date, tbl3.origin = "", "", ""  -- TODO fix table_ini table.cat calls
  tbl4.time, tbl4.date, tbl4.origin = "", "", ""
  tbl1:addrow(row1); tbl1:addrow(row1);
  tbl2:addrow(row2); tbl2:addrow(row2)
  -- tbl3:addrow(row2); tbl3:addrow(row2)            -- TODO fix table_ini table.cat calls
  tbl4:addrow(row2); tbl4:addrow(row2)

  -- extensions
  testWrite(tbl1, 'tbl-name1')
  testWrite(tbl1, 'tbl-name2.tfs')

  -- with dictionary
  testWrite(tbl2, 'tbl-dict') -- TODO should it be a special marker ?

  -- choose column
  testWrite(tbl2, 'tbl-col1', {'x', 3}) -- TODO fix column name when integer argument (see generated file)
  -- testWrite(tbl3, 'tbl-col2') -- TODO fix column name when integer argument (see generated file) -- TODO fix table_ini table.cat calls

  -- choose header
  testWrite(tbl4, 'tbl-header1', nil, { "title", "header1" })
  testWrite(tbl4, 'tbl-header2')

  -- tbl with quoted string
  tbl5:addrow{"name1", 1, 2, 3.15}
  tbl5:addrow{"name2", nil, nil, nil}
  tbl5:addrow{"name1", 1, 2, 3.15}
  tbl5:addcol("gen", \i->i)
  tbl5:addrow{"name1", "value 'whith quote'", "value \"double quote\"", 3}
  testWrite(tbl5, 'tbl-write', nil, {"type","header1", "header2", "header3"})

  if not generate then filesys.rmdir(rundir("")) end
end

function TestMTable:testRead()
  local parent = mtable 'parent' { var = 42 }

  -- extensions
  local tbl1 = mtable:read(refdir('tbl-name1'))
  local tbl2 = mtable:read(refdir('tbl-name2.tfs'))
  for i=1,2 do
    for j=1,3 do
      assertEquals(tbl1[i][j], j)
      assertEquals(tbl2[i][j], j)
    end
  end

  -- inheritance
  local tbl3 = parent:read(refdir('tbl-name1'))
  assertFalse(is_original_mtable(parent))
  assertTrue(is_original_mtable(tbl3))
  assertEquals(tbl3.var, 42)
  assertEquals(tbl3.parent, parent)

  -- test values read
  -- local tbl4 = mtable:read(refdir('tbl-write')) -- TODO types not correct can not read back tbl-write

  -- TODO when read is fixed :  test if quote is handled properly
  -- TODO test read values
  -- test dictionary
end

function TestMTable:testBuildIndex()
  local tbl = mtable 'tbl' { {'name1'}, 'name2' , 'id' }
  tbl:addrow{ "n1"   , "n2"   , 1}
  tbl:addrow{ "other", "other", 2}
  tbl:addrow{ "n1"   , "n2"   , 3}
  tbl:addrow{ "n1"   , "n2"   , 4}

  for col,v in pairs{name1="n1", name2="n2"} do
    tbl:build_index(col)
    assertEquals(tbl:getrow(v.."[1]"   ).id, 1)
    assertEquals(tbl:getrow(v.."[3]"   ).id, 4)
    assertEquals(tbl:getrow(v.."{2}", 2).id, 4)
  end

  for _,col in ipairs{1} do -- TODO add ,-2 when reflection is fixed
    tbl:build_index(col)
    assertEquals(tbl:getrow("n1[1]"   ).id, 1)
    assertEquals(tbl:getrow("n1[3]"   ).id, 4)
    assertEquals(tbl:getrow("n1{2}", 2).id, 4)
  end

  tbl:build_index('none')
  local v = tbl:getrow("n1[1]"   ).id -- TODO not supposed to work

end

function TestMTable:testSetReadOnly()
  local tbl1 = mtable 'tbl1' { {'dict'}, 'x', 'y', 'z'}
  local tbl2 = mtable 'tbl2' { {'dict'}, 'x', 'y', 'z'}
  local msg  = {
    "forbidden write access to 'tbl1' (readonly object or variable)",
    "invalid use of object <mtable readonly column:",
    "invalid modification of readonly mtable"
  }

  tbl2:addrow{ "v1", 1, 1, 1 }

  tbl1:set_readonly()
  tbl2:set_readonly()

  assertErrorMsgContains(msg[1],\tbl,k,v   => tbl[k]    = v end, tbl1, "var", 42)
  assertErrorMsgContains(msg[2],\tbl,i,j,v => tbl[i][j] = v end, tbl2, 1, 2, 42)
  assertErrorMsgContains(msg[2], mtable.set, tbl2, 1, 2, 42)
  assertErrorMsgContains(msg[2], mtable.addrow, tbl1,  { "v2", 2, 2, 2 })
  -- assertErrorMsgContains(msg[2], mtable.addrow, tbl2, { "v2", 2, 2, 2 }) -- TODO fix expand function
  -- assertErrorMsgContains(msg[2], mtable.insrow, tbl2, 1, { "v2", 2, 2, 2 }) -- TODO fix expand function -- error message is not readonly
  -- assertErrorMsgContains(msg[2], mtable.setrow, tbl2, 1, { "v2", 2, 2, 2 }) -- TODO doesn't let tbl2 in a valid state
  tbl2:set_readonly(false); tbl2:addrow{ "v2", 2, 2, 2 }; tbl2:set_readonly()
  assertErrorMsgContains(msg[2], mtable.swprow, tbl2, 1, 2) -- TODO doesn't let tbl2 in a valid state
  assertErrorMsgContains(msg[2], mtable.remrow, tbl2, 1) -- TODO doesn't let tbl2 in a valid state
  assertErrorMsgContains(msg[3], mtable.addcol, tbl2, "c1", {5})
  tbl2:set_readonly(false); tbl2:addcol("gen",\i->i); tbl2:set_readonly()
  assertErrorMsgContains(msg[3], mtable.remcol, tbl2, "gen")

  tbl2:build_index(2) -- TODO should not work ?

  -- TODO test for add sort, remove, insert, cycle, select
end

function TestMTable:testIndexOf()
  local tbl = mtable 'tbl' { {'dict'}, 'x', 'y', 'z', 's' }

  tbl:addrow{"v0",1,2,3,0}
  tbl:addrow{"v1",1,2,3,4}
  tbl:addrow{"v0",1,2,3,6}
  tbl:addrow{"v0",1,2,3,9}

  assertNil(tbl:index_of(100))
  assertNil(tbl:index_of(-100))
  assertEquals(tbl:index_of(4), 4)
  assertEquals(tbl:index_of(-3), 2)
  -- assertEquals(tbl:index_of(5,'spos'), 3) -- TODO add local bsearch
  -- assertEquals(tbl:index_of(5.5), 3)      -- TODO add local bsearch
  assertEquals(tbl:index_of("v0"       ), 1)
  assertEquals(tbl:index_of("v0[3]"    ), 4)
  assertEquals(tbl:index_of("v0[-1]"   ), 4)
  assertEquals(tbl:index_of("v0{2}" , 2), 4)
  assertEquals(tbl:index_of("v0{-1}", 2), 1)
end

function TestMTable:testNameOf()
  local tbl = mtable 'tbl' { {'dict'}, 'x', 'y', 'z' }

  tbl:addrow{"v0",1,2,3}
  tbl:addrow{"v1",1,2,3}
  tbl:addrow{"v0",1,2,3}
  tbl:addrow{"v0",1,2,3}

  assertNil(tbl:name_of(100))
  assertNil(tbl:name_of(-100))
  assertEquals(tbl:name_of(2)   , "v1"    )
  assertEquals(tbl:name_of(2)   , "v1"    )
  -- assertEquals(tbl:name_of(1)   , "v0[1]" ) -- TODO fix order argument of string format
  -- assertEquals(tbl:name_of(-1)  , "v0[3]" ) -- TODO fix order argument of string format
  -- assertEquals(tbl:name_of(1, 1), "v0{1}")  -- TODO fix order argument of string format
  -- assertEquals(tbl:name_of(4, 2), "v0{2}")  -- TODO fix order argument of string format
  -- assertEquals(tbl:name_of(1, 2), "v0{-1}") -- TODO fix negatif ref
  -- assertEquals(tbl:name_of(1, 4), "v0{-3}") -- TODO fix negatif ref
end

function TestMTable:testRangeOf()
  local tbl = mtable 'tbl' { {'dict'}, 'x', 'y', 'z', 's' }

  tbl:addrow{"v0",1,2,3,0}
  tbl:addrow{"v1",1,2,3,4}
  tbl:addrow{"v0",1,2,3,6}
  tbl:addrow{"v0",1,2,3,9}

  assertEquals(table.pack(tbl:range_of(100)), {n=2})
  assertEquals(table.pack(tbl:range_of(-100)), {n=2})
  assertEquals(table.pack(tbl:range_of(4 )), {4,4, n=2})
  assertEquals(table.pack(tbl:range_of(-3)), {2,2, n=2})
  -- assertEquals(table.pack(tbl:range_of(5,'spos')), {3, 3, n=2}) -- TODO add local bsearch
  -- assertEquals(table.pack(tbl:range_of(5.5     )), {3, 3, n=2}) -- TODO add local bsearch -- fix range_of is_integer

  assertEquals(table.pack(tbl:range_of("v0/v1")), {1,2, n=2})
  assertEquals(table.pack(tbl:range_of("v0[1]/v0[3]")), {1,4, n=2})
  assertEquals(table.pack(tbl:range_of("v0{-1}/v0{2}", 2)), {1,4, n=2})
  assertEquals(table.pack(tbl:range_of("v0{-1}/v0{2}", 2)), {1,4, n=2})
  assertEquals(table.pack(tbl:range_of("v0[2]/v0{2}", 2)), {3,4, n=2})
  assertEquals(table.pack(tbl:range_of("v0{1}/v0[3]", 2)), {3,4, n=2})

  assertEquals(table.pack(tbl:range_of({1       , 2      }   )), {1,2, n=2})
  -- assertEquals(table.pack(tbl:range_of({5       , 8 }, "spos")), {3,4, n=2}) -- TODO add local bsearch
  -- assertEquals(table.pack(tbl:range_of({5.5     , 7.5      } )), {3,4, n=2}) -- TODO add local bsearch
  assertEquals(table.pack(tbl:range_of({"v0"    , "v1"   }   )), {1,2, n=2})
  assertEquals(table.pack(tbl:range_of({"v0[1]" , "v0[3]"}   )), {1,4, n=2})
  assertEquals(table.pack(tbl:range_of({"v0{-1}", "v0{2}"}, 2)), {1,4, n=2})
  assertEquals(table.pack(tbl:range_of({"v0{-1}", "v0{2}"}, 2)), {1,4, n=2})
  assertEquals(table.pack(tbl:range_of({"v0[2]" , "v0{2}"}, 2)), {3,4, n=2})
  assertEquals(table.pack(tbl:range_of({"v0{1}" , "v0[3]"}, 2)), {3,4, n=2})

  assertEquals(table.pack(tbl:range_of({"v0{-1}", "v0{2}", 2})), {1,4, n=2})
  assertEquals(table.pack(tbl:range_of({"v0{-1}", "v0{2}", 2})), {1,4, n=2})
  assertEquals(table.pack(tbl:range_of({"v0[2]" , "v0{2}", 2})), {3,4, n=2})
  assertEquals(table.pack(tbl:range_of({"v0{1}" , "v0[3]", 2})), {3,4, n=2})
end

function TestMTable:testLengthOf()
  local tbl = mtable 'tbl' { {'dict'}, 'x', 'y', 'z', 's' }

  tbl:addrow{"v0",1,2,3,0}
  tbl:addrow{"v1",1,2,3,4}
  tbl:addrow{"v0",1,2,3,6}
  tbl:addrow{"v0",1,2,3,9}

  -- assertEquals(tbl:length_of(100), 1) -- TODO fix length_of for single number
  -- assertEquals(tbl:length_of(-100), 1) -- TODO fix length_of for single number
  -- assertEquals(tbl:length_of(4 ), 1) -- TODO fix length_of for single number
  -- assertEquals(tbl:length_of(-3), 1) -- TODO fix length_of for single number
  -- assertEquals(tbl:length_of(5,'spos'), 1) -- TODO add local bsearch -- TODO fix length_of for single number
  -- assertEquals(tbl:length_of(5.5     ), 1) -- TODO add local bsearch -- fix range_of is_integer -- TODO fix length_of for single number

  -- assertEquals(tbl:length_of("v0/v1"), 2)
  -- assertEquals(tbl:length_of("v0[1]/v0[3]"), 4)
  -- assertEquals(tbl:length_of("v0{-1}/v0{2}", 2), 4)
  -- assertEquals(tbl:length_of("v0{-1}/v0{2}", 2), 4)
  -- assertEquals(tbl:length_of("v0[2]/v0{2}", 2), 2)
  -- assertEquals(tbl:length_of("v0{1}/v0[3]", 2), 2)

  -- assertEquals(table.pack(tbl:range_of({1       , 2      }   )), {1,2, n=2})
  -- assertEquals(table.pack(tbl:range_of({5       , 8 }, "spos")), {3,4, n=2}) -- TODO add local bsearch
  -- assertEquals(table.pack(tbl:range_of({5.5     , 7.5      } )), {3,4, n=2}) -- TODO add local bsearch
  -- assertEquals(table.pack(tbl:range_of({"v0"    , "v1"   }   )), {1,2, n=2})
  -- assertEquals(table.pack(tbl:range_of({"v0[1]" , "v0[3]"}   )), {1,4, n=2})
  -- assertEquals(table.pack(tbl:range_of({"v0{-1}", "v0{2}"}, 2)), {1,4, n=2})
  -- assertEquals(table.pack(tbl:range_of({"v0{-1}", "v0{2}"}, 2)), {1,4, n=2})
  -- assertEquals(table.pack(tbl:range_of({"v0[2]" , "v0{2}"}, 2)), {3,4, n=2})
  -- assertEquals(table.pack(tbl:range_of({"v0{1}" , "v0[3]"}, 2)), {3,4, n=2})

  -- assertEquals(table.pack(tbl:range_of({"v0{-1}", "v0{2}", 2})), {1,4, n=2})
  -- assertEquals(table.pack(tbl:range_of({"v0{-1}", "v0{2}", 2})), {1,4, n=2})
  -- assertEquals(table.pack(tbl:range_of({"v0[2]" , "v0{2}", 2})), {3,4, n=2})
  -- assertEquals(table.pack(tbl:range_of({"v0{1}" , "v0[3]", 2})), {3,4, n=2})
end

function TestMTable:testIter()
  local tbl1 = mtable 'tbl1' { {'dict'} }
  local tbl2 = mtable 'tbl2' { {'dict'} }
  local val1 = { "v1", "v2", "v3", "v4" }
  local val2 = { "v0", "v1", "v0", "v0" }
  local i    = 1

  for _,v in ipairs(val1) do tbl1:addrow{v} end
  for _,v in ipairs(val2) do tbl2:addrow{v} end

  for _,row in tbl1:iter() do
    assertEquals(row[1], val1[i])
    i = i + 1
  end

  -- range
  i = 2
  for _,row in tbl1:iter("v2/v3") do
    assertEquals(row[1], val1[(i-1) % 4 + 1])
    i = i + 1
  end
  assertEquals(i, 4)

  i = 1
  for _,row in tbl2:iter{"v0{-1}","v0[2]", 2} do
    assertEquals(row[1], val2[(i-1) % 4 + 1])
    i = i + 1
  end
  assertEquals(i, 4)

  -- nturn
  i = 1
  for _,row in tbl1:iter(nil, 1, 1) do
    assertEquals(row[1], val1[(i-1) % 4 + 1])
    i = i + 1
  end
  assertEquals(i, 9)

   -- dir
  i = 8
  for _,row in tbl1:iter(nil, 1, -1) do
    assertEquals(row[1], val1[(i-1) % 4 + 1])
    i = i - 1
  end
  assertEquals(i, 0)

end

function TestMTable:testCycle()
  local tbl    = mtable 'tbl' { {'dict'} }
  local before = { "v1", "v2", "v3", "v4" }
  local after1 = { "v3", "v4", "v1", "v2" }
  local after2 = { "v4", "v1", "v2", "v3" }
  local i      = 1

  for _,v in ipairs(before) do tbl:addrow{v} end

  for _,row in tbl:iter() do
    assertEquals(row[1], before[i])
    i = i + 1
  end

  i = 1
  tbl:cycle(3)
  for _,row in tbl:iter() do
    assertEquals(row[1], after1[i])
    i = i + 1
  end

  i = 1
  tbl:cycle("v4")
  for _,row in tbl:iter() do
    assertEquals(row[1], after2[i])
    i = i + 1
  end

end

function TestMTable:testForeach()
  local tbl = mtable 'tbl' { {'dict'} }
  local val = { "v1", "v2", "v3", "v4", "v0", "v1", "v0", "v0" }
  local i   = 1
  local act = \row,_ => assertEquals(row[1], val[i]); i=i+1 end

  for _,v in ipairs(val) do tbl:addrow{v} end

  i=1; tbl:foreach(act)                                 ; assertEquals(i, 9)
  i=1; tbl:foreach(act, nil, nil, true)                 ; assertEquals(i, 1)
  i=2; tbl:foreach(act, {2,6})                          ; assertEquals(i, 7)
  i=1; tbl:foreach(act, {2,6}, nil, true)               ; assertEquals(i, 1)
  i=2; tbl:foreach(act, nil, \r,i -> 1 < i and i < 7)   ; assertEquals(i, 7)
  i=3; tbl:foreach(act, {3, 5}, \r,i -> 1 < i and i < 7); assertEquals(i, 6)
  i=3; tbl:foreach(act, {2, 6}, \r,i -> 2 < i and i < 6); assertEquals(i, 6)

end
-- end ------------------------------------------------------------------------o