--[=[
 o-----------------------------------------------------------------------------o
 |
 | Track vs PTC tests
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: I. Tecker, irina.tecker at cern.ch
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide regression test suites for the track module versus MADX-PTC results.

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local assertTrue, assertEquals, assertAllAlmostEquals            in MAD.utest


local beam, sequence, mtable, track, option, filesys             in MAD
local drift, hkicker, vkicker, kicker, solenoid, rfcavity,
      sbend, rbend, quadrupole, sextupole, octupole,
      decapole, dodecapole, multipole                            in MAD.element
local printf, assertf, tblicpy                                   in MAD.utility
local eps, pi                                                    in MAD.constant
local fnone, ftrue                                               in MAD.gfunc
local abs                                                        in math

local refdir = \s -> 'track_ref/'..(s or '')
local rundir = \s -> 'track_run/'..(s or '')

-- local ----------------------------------------------------------------------o

local models = {'DKD','TKT'}
local X0s    = {{x=0   , px=0    , y=0    , py=0   , t=0   , pt=0   }, -- zero
                {x=3e-3, px=-2e-4, y=-2e-3, py=3e-4, t=0   , pt=0   }, -- 4D
                {x=3e-3, px=-2e-4, y=-2e-3, py=3e-4, t=0   , pt=2e-5}, -- 5D
                {x=3e-3, px=-2e-4, y=-2e-3, py=3e-4, t=1e-5, pt=2e-5}} -- 6D

local colres = {'name','cfgid',
                'c10','c20','c30','c40','c50','c60',
                'c11','c12','c13','c14','c15','c16',
                'c21','c22','c23','c24','c25','c26',
                'c31','c32','c33','c34','c35','c36',
                'c41','c42','c43','c44','c45','c46',
                'c51','c52','c53','c54','c55','c56',
                'c61','c62','c63','c64','c65','c66'}

local colcfg = {        'model','energy','tilt','tpath','method','nslice','eon','x0i'}
local prtcfg = {'cfgid','model','energy','tilt','tpath','method','nslice','eon','x0i'}
local prthdr = {'name','type','title','origin','date','time'}

local cfgsav, ressav, difsav = true, true, true
local cfgtbl, restbl

-- setup ----------------------------------------------------------------------o

local function getres ()
  if restbl then return restbl:clear() end
  restbl = mtable 'Cmad_res' (tblicpy(colres)) -- colres becomes the object
  -- printf("#restbl=%d\n", #restbl)
  return restbl
end

local function getcfg ()
  if cfgtbl then return cfgtbl end

  cfgtbl = mtable 'Cmad_cfg' (tblicpy(colcfg)) -- colcfg becomes the object

  for model=1,#models do       -- hamiltonians
  for energy = 1,6500,6499 do  -- beam energy
  for tilt=0,2 do              -- multiple of pi/8
  for tpath=0,1 do             -- total path
  for method=2,6,2 do          -- integration order
  for nslice=1,3 do            -- number of slices
  for eon=0,1 do               -- element is on
  for x0i=1,#X0s do            -- initial coordinates
    cfgtbl = cfgtbl + {model, energy, tilt, tpath, method, nslice, eon, x0i}
  end end end end end end end end

  -- add config id = row index
  cfgtbl:addcol('cfgid', \i -> i)

  if cfgsav then
    local fmt = option.format
    option.format = "% -8.4g"
    cfgtbl.colwidth = 8
    cfgtbl:write(rundir("Cmad_cfg.txt"), prtcfg, prthdr)
    option.format = fmt
  end
  -- printf("#cfgtbl=%d\n", #cfgtbl)
  return cfgtbl
end

-- check results --------------------------------------------------------------o

local e_on  = 0
local e_tlt = 0

local function chkres (seq)
  local beam = beam {particle = 'proton'}
  local res  = getres()
  local cfg  = getcfg()
  local row  = {}
  local run  = 0

  for i=1,#cfg do
    -- global settings
    e_on  = cfg.eon[i]
    e_tlt = cfg.tilt[i]*pi/8

    -- skip invalid cases (madx compat)
    if not (e_on >= seq.nooff and e_tlt <= (1-seq.notilt)*pi) then
      goto skip
    end

    -- skip invalid cases (physics compat)
    assertf(#seq == 4, "invalid sequence '%s' size %d ~= 4", seq.name, #seq)
    -- curved element with not strength
    assertf(not (e_on  == 0 and seq[2].angle ~= 0 and seq[2].l ~= 0),
                       "invalid curved case %d '%s'", i, seq.name)
    -- drift, solenoid, rfcav
    assertf(not (e_tlt ~= 0 and seq[2].tilt  == 0),
                       "invalid tilted case %d '%s'", i, seq.name)

    -- run track for these settings
    beam.energy = cfg.energy[i]
    local tbl = track {
      beam      = beam,
      sequence  = seq,
      X0        = X0s   [cfg.x0i  [i]],
      model     = models[cfg.model[i]],
      method    = cfg.method[i],
      nslice    = cfg.nslice[i],
      totalpath = cfg.tpath [i]<1,
      mapdef    = true,
      save      = true,
      mapsave   = true,
      observe   = false,
    }

    -- extend mtable
    tbl:addcol('cfgid', \ -> cfg.cfgid[i])
    for i=1,6 do   -- order 0 (vector)
      tbl:addcol('c'..i..'0', \r -> tbl.M[r][i]:get(1))
      for j=1,6 do -- order 1 (matrix)
      tbl:addcol('c'..i.. j , \r -> tbl.M[r][i]:get(j+1))
    end end

    -- copy to results
    for i=1,#tbl do
      for j=1,#colres do row[j] = tbl:getcol(colres[j])[i] end
      res = res + row
    end
    run = run + 1
::skip::
  end

  -- read PTC ref, build diff (filename: seqxNAME.txt)
  local nam = string.lower(seq.name)
  local dif = mtable:read(refdir('seqx'..nam..'.txt'))
  assert(#dif == #res, "invalid PTC input (#rows differs)")
  for j=3,#colres do -- substract res in-place
    local rc, dc = res:getcol(j), dif:getcol(j) ; dc:sub(rc,dc)
  end

  -- save results and diff (filenames: seqNAME.txt, seqNAMEdif.txt)
  if ressav or difsav then
    local fmt, colw = option.format, option.colwidth
    option.format, option.colwidth = "% -.16e", 24
    if ressav then res:write(rundir('seq'..nam..   '.txt'), colres, prthdr) end
    if difsav then dif:write(rundir('seq'..nam..'dif.txt')                ) end
    option.format, option.colwidth = fmt, colw
  end

  return res, dif
end

-- Tests ----------------------------------------------------------------------o

TestTrackPTCda = {}

function TestTrackPTCda:setUp ()
  filesys.mkdir(rundir())
  self.optfmt = option.format
  option.format = "%-.10g"
end

function TestTrackPTCda:tearDown ()
  option.format = self.optfmt
end

-- Sequences ------------------------------------------------------------------o
-- TODO: trueRBEND, RFMULTIPOLE, CRABCAVITY, BEAMBEAM, ELSEPARATOR, WIGGLER, ...
-- TODO: all versions with knl, ksl...

function TestTrackPTCda:testDRIFT ()
  local seq = sequence 'DRIFT' { nooff=1, notilt=1,
    drift 'DRIFT1' {at=0.75, l=1.5, tilt:=e_tlt },
    drift 'DRIFT2' {at=3.25, l=1.5, tilt:=e_tlt },
  }
  chkres(seq)
  -- TODO: add assertions
end

function TestTrackPTCda:testSBEND ()
  local seq = sequence 'SBEND' { nooff=1, notilt=0,
    sbend 'SBEND1' {at=0.75, l=1.5, tilt:=e_tlt, k0:= 0.05*e_on, angle= 0.05*1.5, kill_ent_fringe=true, kill_exi_fringe=true},
    sbend 'SBEND2' {at=3.25, l=1.5, tilt:=e_tlt, k0:=-0.05*e_on, angle=-0.05*1.5, kill_ent_fringe=true, kill_exi_fringe=true},
  }
  chkres(seq)
  -- TODO: add assertions
end

function TestTrackPTCda:testSBENDfr ()
  local seq = sequence 'SBENDfr' { nooff=1, notilt=0,
    sbend 'SBENDfr1' {at=0.75, l=1.5, tilt:=e_tlt, k0:= 0.05*e_on, angle= 0.05*1.5},
    sbend 'SBENDfr2' {at=3.25, l=1.5, tilt:=e_tlt, k0:=-0.05*e_on, angle=-0.05*1.5},
  }
  chkres(seq)
  -- TODO: add assertions
end

function TestTrackPTCda:testSBENDfh ()
  local seq = sequence 'SBENDfh' { nooff=1, notilt=0,
    sbend 'SBENDfh1' {at=0.75, l=1.5, tilt:=e_tlt, k0:= 0.05*e_on, angle= 0.05*1.5, e1= 0.05*1.5/2, e2= 0.05*1.5/1.5, hgap=0.03, fint=0.5},
    sbend 'SBENDfh2' {at=3.25, l=1.5, tilt:=e_tlt, k0:=-0.05*e_on, angle=-0.05*1.5, e1=-0.05*1.5/2, e2=-0.05*1.5/1.5, hgap=0.03, fint=0.5},
  }
  chkres(seq)
  -- TODO: add assertions
end

function TestTrackPTCda:testRBEND ()
  local seq = sequence 'RBEND' { nooff=1, notilt=0,
    rbend 'RBEND1' {at=0.75, l=1.5, tilt:=e_tlt, k0:= 0.05*e_on, angle= 0.05*1.5, kill_ent_fringe=true, kill_exi_fringe=true},
    rbend 'RBEND2' {at=3.25, l=1.5, tilt:=e_tlt, k0:=-0.05*e_on, angle=-0.05*1.5, kill_ent_fringe=true, kill_exi_fringe=true},
  }
  chkres(seq)
  -- TODO: add assertions
end

function TestTrackPTCda:testRBENDfr ()
  local seq = sequence 'RBENDfr' { nooff=1, notilt=0,
    rbend 'RBENDfr1' {at=0.75, l=1.5, tilt:=e_tlt, k0:= 0.05*e_on, angle= 0.05*1.5},
    rbend 'RBENDfr2' {at=3.25, l=1.5, tilt:=e_tlt, k0:=-0.05*e_on, angle=-0.05*1.5},
  }
  chkres(seq)
  -- TODO: add assertions
end

function TestTrackPTCda:testQUAD ()
  local seq = sequence 'QUAD' { nooff=0, notilt=0,
    quadrupole 'QUAD1' {at=0.75, l=1.5, tilt:=e_tlt, k1:= 0.25*e_on},
    quadrupole 'QUAD2' {at=3.25, l=1.5, tilt:=e_tlt, k1:=-0.25*e_on},
  }
  chkres(seq)
  -- TODO: add assertions
end

function TestTrackPTCda:testSEXT ()
  local seq = sequence 'SEXT' { nooff=0, notilt=0,
    sextupole 'SEXT1' {at=0.75, l=1.5, tilt:=e_tlt, k2:= 0.25*e_on},
    sextupole 'SEXT2' {at=3.25, l=1.5, tilt:=e_tlt, k2:=-0.25*e_on},
  }
  chkres(seq)
  -- TODO: add assertions
end

function TestTrackPTCda:testOCTU ()
  local seq = sequence 'OCTU' { nooff=0, notilt=0,
    octupole 'OCTU1' {at=0.75, l=1.5, tilt:=e_tlt, k3:= 0.25*e_on},
    octupole 'OCTU2' {at=3.25, l=1.5, tilt:=e_tlt, k3:=-0.25*e_on},
  }
  chkres(seq)
  -- TODO: add assertions
end

function TestTrackPTCda:testDECA ()
  local seq = sequence 'DECA' {l=4, nooff=0, notilt=0,
    multipole 'DECA1' {at=0.75, lrad=1.5, tilt:=e_tlt, knl:={0,0,0,0, 0.25*e_on}},
    multipole 'DECA2' {at=3.25, lrad=1.5, tilt:=e_tlt, knl:={0,0,0,0,-0.25*e_on}},
  }
  chkres(seq)
  -- TODO: add assertions
end

function TestTrackPTCda:testDODECA ()
  local seq = sequence 'DODECA' {l=4, nooff=0, notilt=0,
    multipole 'DODECA1' {at=0.75, lrad=1.5, tilt:=e_tlt, knl:={0,0,0,0,0, 0.25*e_on}},
    multipole 'DODECA2' {at=3.25, lrad=1.5, tilt:=e_tlt, knl:={0,0,0,0,0,-0.25*e_on}},
  }
  chkres(seq)
  -- TODO: add assertions
end

function TestTrackPTCda:testMULT ()
  local seq = sequence 'MULT' {l=4, nooff=0, notilt=0,
    multipole 'MULT1' {at=0.75, lrad=1.5, tilt:=e_tlt, knl:={ 0.05*1.5*e_on, 0.25*1.5*e_on}, angle= 0.05*1.5},
    multipole 'MULT2' {at=3.25, lrad=1.5, tilt:=e_tlt, knl:={-0.05*1.5*e_on,-0.25*1.5*e_on}, angle=-0.05*1.5},
  }
  chkres(seq)
  -- TODO: add assertions
end

function TestTrackPTCda:testHKICK ()
  local seq = sequence 'HKICK' { nooff=0, notilt=0,
    hkicker 'HKICK1' {at=0.75, l=1.5, tilt:=e_tlt, kick:= 0.25e-3*e_on},
    hkicker 'HKICK2' {at=3.25, l=1.5, tilt:=e_tlt, kick:=-0.25e-3*e_on},
  }
  chkres(seq)
  -- TODO: add assertions
end

function TestTrackPTCda:testVKICK ()
  local seq = sequence 'VKICK' { nooff=0, notilt=0,
    vkicker 'VKICK1' {at=0.75, l=1.5, tilt:=e_tlt, kick:=-0.25e-3*e_on},
    vkicker 'VKICK2' {at=3.25, l=1.5, tilt:=e_tlt, kick:= 0.25e-3*e_on},
  }
  chkres(seq)
  -- TODO: add assertions
end

function TestTrackPTCda:testKICK ()
  local seq = sequence 'KICK' { nooff=0, notilt=0,
    kicker 'KICK1' {at=0.75, l=1.5, tilt:=e_tlt, hkick:= 0.25e-3*e_on, vkick:=-0.25e-3*e_on},
    kicker 'KICK2' {at=3.25, l=1.5, tilt:=e_tlt, hkick:=-0.25e-3*e_on, vkick:= 0.25e-3*e_on},
  }
  chkres(seq)
  -- TODO: add assertions
end

function TestTrackPTCda:testSOL ()
  local seq = sequence 'SOL' { nooff=0, notilt=1,
    solenoid 'SOL1' {at=0.75, l=1.5, tilt:=e_tlt, ks:= 0.25*e_on},
    solenoid 'SOL2' {at=3.25, l=1.5, tilt:=e_tlt, ks:=-0.25*e_on},
  }
  chkres(seq)
  -- TODO: add assertions
end

function TestTrackPTCda:testCAV0 ()
  local seq = sequence 'CAV0' {l=4, nooff=1, notilt=1,
    rfcavity 'CAV01' {at=0.75, l=0, tilt:=e_tlt, volt:=8*e_on, freq=400, lag=0.5, no_cavity_totalpath=true},
    rfcavity 'CAV02' {at=3.25, l=0, tilt:=e_tlt, volt:=8*e_on, freq=400, lag=0.5, no_cavity_totalpath=true},
  }
  chkres(seq)
  -- TODO: add assertions
end

function TestTrackPTCda:testCAV0t ()
  local seq = sequence 'CAV0t' {l=4, nooff=1, notilt=1,
    rfcavity 'CAV0t1' {at=0.75, l=0, tilt:=e_tlt, volt:=8*e_on, freq=400, lag=0.5},
    rfcavity 'CAV0t2' {at=3.25, l=0, tilt:=e_tlt, volt:=8*e_on, freq=400, lag=0.5},
  }
  chkres(seq)
  -- TODO: add assertions
end

function TestTrackPTCda:testCAV ()
  local seq = sequence 'CAV' { nooff=1, notilt=1,
    rfcavity 'CAV1' {at=0.75, l=1.5, tilt:=e_tlt, volt:=8*e_on, freq=400, lag=0.5, no_cavity_totalpath=true},
    rfcavity 'CAV2' {at=3.25, l=1.5, tilt:=e_tlt, volt:=8*e_on, freq=400, lag=0.5, no_cavity_totalpath=true},
  }
  chkres(seq)
  -- TODO: add assertions
end

function TestTrackPTCda:testCAVt ()
  local seq = sequence 'CAVt' { nooff=1, notilt=1,
    rfcavity 'CAVt1' {at=0.75, l=1.5, tilt:=e_tlt, volt:=8*e_on, freq=400, lag=0.5},
    rfcavity 'CAVt2' {at=3.25, l=1.5, tilt:=e_tlt, volt:=8*e_on, freq=400, lag=0.5},
  }
  chkres(seq)
  -- TODO: add assertions
end

function TestTrackPTCda:testCAVh ()
  local seq = sequence 'CAVh' { nooff=1, notilt=1,
   rfcavity 'CAVh1' {at=0.75, l=1.5, tilt:=e_tlt, volt:=8*e_on, harmon=2, lag=0.5},
   rfcavity 'CAVh2' {at=3.25, l=1.5, tilt:=e_tlt, volt:=8*e_on, harmon=2, lag=0.5},
 }
  chkres(seq)
  -- TODO: add assertions
end

function TestTrackPTCda:testCAVb ()
  local seq = sequence 'CAVb' { nooff=1, notilt=1,
    rfcavity 'CAVb1' {at=0.75, l=1.5, tilt:=e_tlt, volt:=8*e_on, freq=400, lag=0.5, n_bessel=3},
    rfcavity 'CAVb2' {at=3.25, l=1.5, tilt:=e_tlt, volt:=8*e_on, freq=400, lag=0.5, n_bessel=3},
  }
  chkres(seq)
  -- TODO: add assertions
end

-- end ------------------------------------------------------------------------o
