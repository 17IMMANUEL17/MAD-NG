local assert    in _G
local fun       in MAD
local layangle in MAD.element.flags

MADX:open_env()

-- share lhcb1 with lhcb2
lhcb1:share(lhcb2)

-- proper settings of sequence direction
lhcb2.direction = -1

-- change angle
if option.rbarc == true then
  local toarc = \e => if e.kind == 'rbend' then rbarc(e) end end

  lhcb1:foreach(toarc)
  lhcb2:foreach(toarc)
end

-- change RBEND to SBEND for MAD-X compatibility
local eface = \s -> s.angle/2

mbrb :set_parent(sbend) :set{ e1=eface, e2=eface }
mbrc :set_parent(sbend) :set{ e1=eface, e2=eface }
mbrs :set_parent(sbend) :set{ e1=eface, e2=eface }
mbw  :set_parent(sbend) :set{ e1=eface, e2=eface }
mbx  :set_parent(sbend) :set{ e1=eface, e2=eface }
mbxw :set_parent(sbend) :set{ e1=eface, e2=eface }

lhcb1:foreach \e -> assert(e.kind ~= 'rbend', "unexpected rbend")
lhcb2:foreach \e -> assert(e.kind ~= 'rbend', "unexpected rbend")

-- Mark Angle ------------------------------------------------------------------

local lhc_mark_angle = {
  -- IP1 --
  "MBXW.F4L1","MBXW.E4L1","MBXW.D4L1","MBXW.C4L1","MBXW.B4L1","MBXW.A4L1",
  "MBXW.F4R1","MBXW.E4R1","MBXW.D4R1","MBXW.C4R1","MBXW.B4R1","MBXW.A4R1",
  -- IP2 --
  "MBX.4L2","MBX.4R2",
  -- IP5 --
  "MBXW.F4L5","MBXW.E4L5","MBXW.D4L5","MBXW.C4L5","MBXW.B4L5","MBXW.A4L5",
  "MBXW.F4R5","MBXW.E4R5","MBXW.D4R5","MBXW.C4R5","MBXW.B4R5","MBXW.A4R5",
  -- IP8 --
  "MBX.4L8","MBX.4R8",
}

local lhcb1_mark_angle = {
  "MBRC.4L1.B1","MBRC.4R1.B1", -- IP1
  "MBRC.4L2.B1","MBRC.4R2.B1", -- IP2
  "MBRC.4L5.B1","MBRC.4R5.B1", -- IP5
  "MBRC.4L8.B1","MBRC.4R8.B1", -- IP8
}

local lhcb2_mark_angle = {
  "MBRC.4L1.B2","MBRC.4R1.B2", -- IP1
  "MBRC.4L2.B2","MBRC.4R2.B2", -- IP2
  "MBRC.4L5.B2","MBRC.4R5.B2", -- IP5
  "MBRC.4L8.B2","MBRC.4R8.B2", -- IP8
}

local function get_selangle(lhc, lhcb)
  return \seq, sel =>
    local func
    if sel == false then func = \name => seq[name]:deselect(layangle) end
    else                 func = \name => seq[name]:select(layangle) end
    end
    fun.foreach(func, lhc)
    fun.foreach(func, lhcb)
  end
end

lhcb1:set_readonly(false); lhcb2:set_readonly(false)
lhcb1:set_functions{ selangle = get_selangle(lhc_mark_angle, lhcb1_mark_angle) }
lhcb2:set_functions{ selangle = get_selangle(lhc_mark_angle, lhcb2_mark_angle) }
lhcb1:set_readonly(true); lhcb2:set_readonly(true)

-- mechanical separation -------------------------------------------------------
local function get_mech(seq)
  return \e, idx =>
    if e.kind == "marker" then
      e.mech_sep = (seq[idx+1] or seq[idx-1]).mech_sep
    end
  end
end

lhcb1:foreach(get_mech(lhcb1))
lhcb2:foreach(get_mech(lhcb2))

MADX:close_env()

-- kickers compatibilty (to be reviewed)
local E = MAD.element

E. kicker.knl = \s -> ( s.hkick and { -s.hkick } )
E. kicker.ksl = \s -> ( s.vkick and {  s.vkick } )
E.hkicker.knl = \s -> ((s.hkick or s.kick) and { -(s.hkick or s.kick) })
E.vkicker.ksl = \s -> ((s.vkick or s.kick) and {   s.vkick or s.kick  })
