--[=[
 o-----------------------------------------------------------------------------o
 |
 | Matrix module regression tests - complex matrices
 |
 | Methodical Accelerator Design - Copyright CERN 2015+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: A.Z. Teska, aleksandra.teska at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide regression test suites for the matrix module.

 o-----------------------------------------------------------------------------o
]=]

local assertEquals, assertAlmostEquals, assertTrue, assertFalse,
      assertErrorMsgContains, assertNil, assertNaN, assertIsString, assertInf
      in require 'luaunit'

local vector, cvector, matrix, cmatrix, is_vector, is_matrix, is_cvector,
      is_cmatrix, isa_vector, isa_matrix, linspace, logspace in MAD

local complex, range, nrange, nlogrange,infi, tiny, eps, huge, inf, nan, pi, Pi,
      randomseed, abs, log, min, totable, is_complex, is_cdata, is_table,
      is_nil, is_string in MAD

-- regression test suite ------------------------------------------------------o

TestCMatrix  = {}

local values = {
  num = { tiny, 2^-64, 2^-63, 2^-53, eps, 2^-52, 2*eps, 2^-32, 2^-31, 1e-9,
          0.1-eps, 0.1, 0.1+eps, 0.5, 0.7-eps, 0.7, 0.7+eps, 1-eps, 1, 1+eps,
          1.1, 1.7, 2, 10, 1e2, 1e3, 1e6, 1e9, 2^31, 2^32, 2^52, 2^53,
          2^63, 2^64, huge },
}

local mth = \f,s,... s[f](s,...)

function TestCMatrix:testCtor()
  local cm, cv
  local msg = {
  "invalid argument #1 or #2 (nrow[,ncol] >=1 or table [of tables] expected)",
  "matrix too large",
  }
  assertErrorMsgContains( msg[1], cmatrix, ''     )
  assertErrorMsgContains( msg[1], cmatrix, nil    )
  assertErrorMsgContains( msg[1], cmatrix, 0      )
  assertErrorMsgContains( msg[1], cmatrix, tiny   )
  assertErrorMsgContains( msg[1], cmatrix, eps    )
  assertErrorMsgContains( msg[1], cmatrix,-1      )
  assertErrorMsgContains( msg[1], cmatrix,-tiny   )
  assertErrorMsgContains( msg[1], cmatrix, 1..2   )
  assertErrorMsgContains( msg[1], cmatrix, infi   )
  assertErrorMsgContains( msg[1], cmatrix,-infi   )
  assertErrorMsgContains( msg[1], cmatrix, nan    )
  assertErrorMsgContains( msg[1], cmatrix,-inf    )
  assertErrorMsgContains( msg[2], cmatrix, inf    )
  assertErrorMsgContains( msg[2], cmatrix, 2^15   )
  assertErrorMsgContains( msg[2], cvector, 2^29+1 )

  --assertTrue( is_cmatrix( cvector(2^29)) )
  for nr=1,5 do
    cv = cvector(nr)
    assertTrue  ( is_cvector(cv) )
    assertEquals( cv.nr, nr )
    assertEquals( cv.nc, 1  )
    for nc=1,5 do
      cm = cmatrix(nr,nc)
      assertTrue  ( is_cmatrix(cv) )
      assertTrue  ( is_cmatrix(cm) )
      assertEquals( cm.nr, nr )
      assertEquals( cm.nc, nc )
    end end
end

function TestCMatrix:testCtorFromtable() --TODO
  local msg = {
    "invalid argument #1 (non-empty table expected)"                           ,
    "cannot convert 'string' to 'complex'"                                     ,
    "invalid argument #1 or #2 (nrow[,ncol] >=1 or table [of tables] expected)",
  }
  assertErrorMsgContains( msg[1], cmatrix, {}    )
  assertErrorMsgContains( msg[2], cmatrix, {''}  )
  assertErrorMsgContains( msg[3], cmatrix, nil   )
  assertEquals( cmatrix{complex(0,1)} , cmatrix{complex(0,1)}  )
  assertEquals( cmatrix{1}.data[0]    , complex(1,0) ) -- data[0] used, needs change
  assertTrue  ( is_cmatrix(cmatrix{2}      ) )
  assertTrue  ( is_cvector(cmatrix{2}      ) )
end

function TestCMatrix:testCdataType()
  local cm, cv = cmatrix(2), cvector(2)
  assertFalse( is_matrix ( cm ) )
  assertFalse( is_matrix ( cv ) )
  assertFalse( is_vector ( cm ) )
  assertFalse( is_vector ( cv ) )
  assertTrue ( is_cmatrix( cm ) )
  assertTrue ( is_cmatrix( cv ) )
  assertFalse( is_cvector( cm ) )
  assertTrue ( is_cvector( cv ) )
  assertFalse( isa_vector( cm ) )
  assertTrue ( isa_vector( cv ) )
  assertTrue ( isa_matrix( cm ) )
  assertTrue ( isa_matrix( cv ) )
end

-- get, set -------------------------------------------------------------------o

function TestCMatrix:testGeti0()
  local msg, cm = {
    "attempt to compare nil with number",
    }
  assertErrorMsgContains( msg[1], mth, 'geti0', cmatrix(2), nil )
  assertNil   ( cmatrix(2):geti0( nan  )    )
  assertNil   ( cmatrix(2):geti0(-1    )    )
  assertNil   ( cmatrix(2):geti0( 4    )    )
  assertEquals( cmatrix({1,2}):geti0(0.1  ), cmatrix({1,2}):geti0( 0) )
  assertEquals( cmatrix({1,2}):geti0(1-eps), cmatrix({1,2}):geti0( 0) ) -- 4th interation err

  for nr=1,5 do
  for nc=1,5 do
    cm = cmatrix(nr,nc):fill(1..nr*nc):fill \x x+x*1i
    for i=1,nr*nc do assertEquals( cm:geti0(i-1), complex(i,i) ) end
  end end
end

function TestCMatrix:testGeti()
local msg, cm = {
    "attempt to compare nil with number",
    }
  assertErrorMsgContains( msg[1], mth, 'geti', cmatrix(2), nil )
  assertNil   ( cmatrix(2):geti( nan  )               )
  assertNil   ( cmatrix(2):geti( 0    )               )
  assertEquals( cmatrix(2):geti( 1    ), complex(0,0) )
  assertNil   ( cmatrix(2):geti( 1-eps)               )
  assertEquals( cmatrix(2):geti( 4    ), complex(0,0) )
  assertEquals( cmatrix(2):geti( 4+eps), complex(0,0) )
  assertNil   ( cmatrix(2):geti( 5    )               )
  assertNil   ( cmatrix(2):geti( 5-eps)               )
  assertEquals( cmatrix({1,2}):geti( 1.1 ), cmatrix({1,2}):geti( 1) )

  for nr=1,5 do
  for nc=1,5 do
    cm = cmatrix(nr,nc):fill(1..nr*nc):fill \x x+x*1i
    for i=1,nr*nc do assertEquals( cm:geti(i), complex(i,i) ) end
  end end
end

function TestCMatrix:testGet0()
  local msg, cm = {
    "attempt to compare nil with number",
    }
  assertErrorMsgContains( msg[1], mth, 'get0', cmatrix(2), 0  , nil )
  assertErrorMsgContains( msg[1], mth, 'get0', cmatrix(2), nil, 0   )
  assertNil   ( cmatrix(2):get0( nan  , 0)               )
  assertNil   ( cmatrix(2):get0(-1    , 0)               )
  assertEquals( cmatrix(2):get0( 0    , 0), complex(0,0) )
  assertNil   ( cmatrix(2):get0( 0-eps, 0)               )
  assertEquals( cmatrix(2):get0( 1    , 1), complex(0,0) )
  assertEquals( cmatrix(2):get0( 1+eps, 1), complex(0,0) )
  assertNil   ( cmatrix(2):get0( 2    , 2)               )
  assertNil   ( cmatrix(2):get0( 2-eps, 2)               )

  for nr=1,5 do
  for nc=1,5 do
    cm = cmatrix(nr,nc):fill(1..nr*nc):fill \x x+x*1i
    for i=1,nr do for j=1,nc do
      assertEquals( cm:get0(i-1,j-1), complex((i-1)*nc+j,(i-1)*nc+j) )
    end end
  end end
end

function TestCMatrix:testGet()
  local msg, cm = {
    "attempt to compare nil with number",
    }
  assertErrorMsgContains( msg[1], mth, 'get0', cmatrix(2), 1  , nil )
  assertErrorMsgContains( msg[1], mth, 'get0', cmatrix(2), nil, 1   )
  assertNil   ( cmatrix(2):get( nan  , 1)               )
  assertNil   ( cmatrix(2):get(-1    , 0)               )
  assertEquals( cmatrix(2):get( 1    , 1), complex(0,0) )
  assertNil   ( cmatrix(2):get( 1-eps, 1)               )
  assertEquals( cmatrix(2):get( 2    , 2), complex(0,0) )
  assertEquals( cmatrix(2):get( 2+eps, 2), complex(0,0) )
  assertNil   ( cmatrix(2):get( 3    , 3)               )
  assertNil   ( cmatrix(2):get( 3-eps, 3)               )

  for nr=1,5 do
  for nc=1,5 do
    cm = cmatrix(nr,nc):fill(1..nr*nc):fill \x x+x*1i
    for i=1,nr do for j=1,nc do
      assertEquals( cm:get(i,j), complex((i-1)*nc+j,(i-1)*nc+j) )
    end end
  end end
end

function TestCMatrix:testSeti0() -- add extra test, used in fill()
  local msg, cm = {
    "0-index out of bounds"             ,
    "attempt to compare nil with number",
    }
  assertErrorMsgContains( msg[1], mth, 'seti0', cmatrix(2), nan  , 1 )
  assertErrorMsgContains( msg[1], mth, 'seti0', cmatrix(2),-1    , 1 )
  assertErrorMsgContains( msg[1], mth, 'seti0', cmatrix(2),-eps  , 1 )
  assertErrorMsgContains( msg[1], mth, 'seti0', cmatrix(2), 4    , 1 )
  assertErrorMsgContains( msg[2], mth, 'seti0', cmatrix(2), nil  , 1 )

  for nr=1,5 do
  for nc=1,5 do
    cm = cmatrix(nr,nc)
    for i=1,nr*nc do
      cm:seti0((i-1), complex(i,i))
      assertEquals( cm:geti0(i-1), complex(i,i) )
    end
  end end
end

function TestCMatrix:testSeti()
  local msg, cm = {
    "1-index out of bounds"             ,
    "attempt to compare nil with number",
    }
  assertErrorMsgContains( msg[1], mth, 'seti', cmatrix(2), nan  , 1 )
  assertErrorMsgContains( msg[1], mth, 'seti', cmatrix(2), 0    , 1 )
  assertErrorMsgContains( msg[1], mth, 'seti', cmatrix(2), 1-eps, 1 )
  assertErrorMsgContains( msg[1], mth, 'seti', cmatrix(2), 5    , 1 )
  assertErrorMsgContains( msg[2], mth, 'seti', cmatrix(2), nil  , 1 )

  for nr=1,5 do
  for nc=1,5 do
    cm = cmatrix(nr,nc)
    for i=1,nr*nc do
      cm:seti((i), complex(i,i))
      assertEquals( cm:geti0(i-1), complex(i,i) )
    end
  end end
end

function TestCMatrix:testSet0()
  local msg, cm, cmRef = {
    "0-index out of bounds"             ,
    "attempt to compare nil with number",
    }
  assertErrorMsgContains( msg[1], mth, 'set0', cmatrix(2), nan  , 1    , 1 )
  assertErrorMsgContains( msg[1], mth, 'set0', cmatrix(2),-1    , 0    , 1 )
  assertErrorMsgContains( msg[1], mth, 'set0', cmatrix(2),-1+eps, 0    , 1 )
  assertErrorMsgContains( msg[1], mth, 'set0', cmatrix(2), 0    ,-1+eps, 1 )
  assertErrorMsgContains( msg[1], mth, 'set0', cmatrix(2), 2    , 1    , 1 )
  assertErrorMsgContains( msg[1], mth, 'set0', cmatrix(2), 1    , 2    , 1 )
  assertErrorMsgContains( msg[2], mth, 'set0', cmatrix(2), nil  , 1    , 1 )
  assertErrorMsgContains( msg[2], mth, 'set0', cmatrix(2), 1    , nil  , 1 )

  for nr=1,5 do
  for nc=1,5 do
    cm    = cmatrix(nr,nc)
    cmRef = cmatrix(nr,nc):fill(1..nr*nc):fill \x x+x*1i
    for i=1,nr do for j=1,nc do
      cm:set0(i-1,j-1, complex((i-1)*nc+j,(i-1)*nc+j))
      assertEquals( cm:get0(i-1,j-1), cmRef:get0(i-1,j-1) )
    end end
  end end
end

function TestCMatrix:testSet()
  local msg, cm, cmRef = {
    "1-index out of bounds"             ,
    "attempt to compare nil with number",
    }
  assertErrorMsgContains( msg[1], mth, 'set', cmatrix(2), nan  , 1    , 1 )
  assertErrorMsgContains( msg[1], mth, 'set', cmatrix(2), 0    , 1    , 1 )
  assertErrorMsgContains( msg[1], mth, 'set', cmatrix(2), 1    , 0    , 1 )
  assertErrorMsgContains( msg[1], mth, 'set', cmatrix(2), 1-eps, 1    , 1 )
  assertErrorMsgContains( msg[1], mth, 'set', cmatrix(2), 1    , 1-eps, 1 )
  assertErrorMsgContains( msg[2], mth, 'set', cmatrix(2), nil  , 1    , 1 )

  for nr=1,5 do
  for nc=1,5 do
    cm    = cmatrix(nr,nc)
    cmRef = cmatrix(nr,nc):fill(1..nr*nc):fill \x x+x*1i
    for i=1,nr do for j=1,nc do
      cm:set(i, j, complex((i-1)*nc+j,(i-1)*nc+j))
      assertEquals( cm:get0(i-1,j-1), cmRef:get0(i-1,j-1) )
    end end
  end end
end

function TestCMatrix:testLinspace() --TODO
  local nrng = {
          { 1 , 10, 100}, { 1, 10, 100}   , { 10, 1 , 10}, { 1,-10, 10},
          { 10,-1 , 100}, {-1, 10, 100}   , {-10, 1 , 10}, {-1,-10, 10},
          {-10,-1 , 100},
          }
  local msg, l, nr = {
    "invalid argument #1 (finite scalar expected)"  ,
    "invalid argument #2 (finite scalar expected)"  ,
    "invalid argument #3 (positive number expected)",
    "bad argument #1 to 'ceil'"                     ,
    "matrix too large"                              ,
  }
  assertErrorMsgContains( msg[1], linspace, nil       )
  assertErrorMsgContains( msg[1], linspace, nil, 2    )
  assertErrorMsgContains( msg[1], linspace, '' , 2    )
  assertErrorMsgContains( msg[1], linspace, nan, 2    )
  assertErrorMsgContains( msg[1], linspace, inf, 2    )
  assertErrorMsgContains( msg[1], linspace,-inf, 2    )
  assertErrorMsgContains( msg[2], linspace, 2  , ''   )
  assertErrorMsgContains( msg[2], linspace, 2  , 1..2 )
  assertErrorMsgContains( msg[2], linspace, 2  , nan  )
  assertErrorMsgContains( msg[2], linspace, 2  , inf  )
  assertErrorMsgContains( msg[2], linspace, 2  ,-inf  )
  assertErrorMsgContains( msg[2], linspace, 2  , 1..2 )
  assertErrorMsgContains( msg[3], linspace, 2  , 2  , 0    )
  assertErrorMsgContains( msg[3], linspace, 2  , 2  ,-1    )
  assertErrorMsgContains( msg[3], linspace, 2  , 2  , nan  )
  assertErrorMsgContains( msg[5], linspace, 2  , 2  , inf  )
  assertErrorMsgContains( msg[3], linspace, 2  , 2  ,-inf  )
  assertErrorMsgContains( msg[4], linspace, 2  , 2  , ''   )
  assertErrorMsgContains( msg[4], linspace, 2  , 2  , 1..2 )

  assertTrue  (  is_vector (linspace(1,1))          )
  assertTrue  (  is_cvector(linspace(complex(1,1))) )
  assertEquals(  linspace( 1 )           [1]  , 0   )
  assertEquals(  linspace( 1 )           [100], 1   )
  assertEquals(  linspace( 0 )           [100], 0   )
  assertEquals(  linspace( 0.1 )         [100], 0.1 )
  assertEquals(  linspace( 2, 2, nil)    [1]  , 2   )
  assertEquals(  linspace( 2, 2, nil)    [100], 2   )
  assertEquals( #linspace( 2, 2, nil)         , 100 )
  assertEquals(  linspace( complex(1,1) )[100], complex(1,1) )
  assertEquals(  linspace( complex(1,1) )[1]  , complex(0,0) )

  nr = nrange  ( 0.5, 1 , 1000 )
  l  = linspace( 0.5, 1 , 1000 )
  assertEquals ( l[1]   , nr[1]    )
  assertEquals ( l[1000], nr[1000] )

  for _,v in ipairs(nrng) do
    nr = nrange  ( v[1], v[2], v[3] )
    l  = linspace( v[1], v[2], v[3] )
    for i=1,#nr do
      assertEquals( l[i] - nr[i], 0 )
    end
    nr = nrange  ( v[1], v[2], v[3] )
    l  = linspace( complex(v[1],v[1]), complex(v[2],v[2]), v[3] )
    for i=1,#nr do
      assertAlmostEquals( l[i].re - complex(nr[i],nr[i]).re , 0, eps )
      assertAlmostEquals( l[i].im - complex(nr[i],nr[i]).im , 0, eps )
    end
  end
  for _,v in ipairs(values.num) do
    if v >= 1  and v < 10^8 then
      nr = nrange  ( 1, 10, v)
      l  = linspace( 1, 10, v)
      for i=1,#nr do
        assertEquals( l[i] - nr[i], 0 )
      end
    end
  end
end

function TestCMatrix:testLogspace()
  local nlrng =  { { 10^5, 1, 100 }, { 1, 10^5, 100 }, { 1, 10^-5, 100 }, }
  local msg, l, nr = {
    "invalid argument #1 (positive finite number expected)",
    "invalid argument #2 (positive finite number expected)",
    "invalid argument #3 (positive number expected)"       ,
    "bad argument #1 to 'ceil'"                            ,
  }
  assertErrorMsgContains( msg[1], logspace, 0          )
  assertErrorMsgContains( msg[1], logspace, nil        )
  assertErrorMsgContains( msg[1], logspace, nil , 1    )
  assertErrorMsgContains( msg[1], logspace, ''  , 1    )
  assertErrorMsgContains( msg[1], logspace, 1..2, 2    )
  assertErrorMsgContains( msg[1], logspace, nan , 2    )
  assertErrorMsgContains( msg[1], logspace, inf , 2    )
  assertErrorMsgContains( msg[1], logspace,-inf , 2    )
  assertErrorMsgContains( msg[2], logspace, 1   , ''   )
  assertErrorMsgContains( msg[2], logspace, 2   , 1..2 )
  assertErrorMsgContains( msg[2], logspace, 2   , nan  )
  assertErrorMsgContains( msg[2], logspace, 2   , inf  )
  assertErrorMsgContains( msg[2], logspace, 2   ,-inf  )
  assertErrorMsgContains( msg[3], logspace, 2   , 2  ,-1    )
  assertErrorMsgContains( msg[3], logspace, 2   , 2  , 0    )
  assertErrorMsgContains( msg[3], logspace, 2   , 2  , nan  )
  assertErrorMsgContains( msg[3], logspace, 2   , 2  ,-inf  )
  assertErrorMsgContains( msg[4], logspace, 2   , 2  , ''   )
  assertErrorMsgContains( msg[4], logspace, 2   , 2  , 1..2 )

  assertTrue  (  is_vector (logspace(1,1))          )
  assertTrue  (  is_cvector(logspace(complex(1,1))) )
  assertEquals(  logspace( 1 )           [1]  , 1   )
  assertEquals(  logspace( 1 )           [100], 1   )
  assertEquals(  logspace( 2, 2, nil)    [1]  , 2   )
  assertEquals(  logspace( 2, 2, nil)    [100], 2   )
  assertEquals( #logspace( 2, 2, nil)         , 100 )
  assertAlmostEquals(  logspace( 0.1 )         [100] - 0.1, 0, eps )
  assertAlmostEquals(  logspace( complex(1,1) )[100].re - complex(1,1).re, 0, eps )
  assertAlmostEquals(  logspace( complex(1,1) )[100].im - complex(1,1).im, 0, eps )

  for _,v in ipairs(nlrng) do
    nr = nlogrange  ( v[1], v[2], v[3] )
    l  = logspace( v[1], v[2], v[3] )
    for i=1,#nr do
      assertEquals( l[i] - nr[i], 0 )
    end
  end
  for _,v in ipairs(values.num) do
    if v >= 1  and v < 10^8 then
      nr = nlogrange  ( 1, 10, v)
      l  = logspace( 1, 10, v)
      for i=1,#nr do
        assertEquals( l[i] - nr[i], 0 )
      end
    end
  end
end

function TestCMatrix:testSame() -- TODO: recheck both same tests
  local cm = cmatrix(3,3):random()
  local msg, s = {
    "invalid argument #1 or #2 (nrow[,ncol] >=1 or table [of tables] expected)",
    "invalid argument #1 (non-empty table expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'same', cmatrix(2), 1, ''   )
  assertErrorMsgContains( msg[1], mth, 'same', cmatrix(2), 1, 1..2 )
  assertErrorMsgContains( msg[1], mth, 'same', cmatrix(2), 1, nan  )
  assertErrorMsgContains( msg[2], mth, 'same', cmatrix(2), 1, {}   )
  s = cm:same( nan)  assertEquals( s:get(1,1), complex(0,0) )
  s = cm:same( inf)  assertEquals( s:get(1,1), complex(0,0) )
  s = cm:same( 0  )  assertEquals( s:get(1,1), complex(0,0) )

  for nr=1,5 do
  for nc=1,5 do
    cm  =  cmatrix(nr,nc)
    -- no input
    s = cm:same( ) assertFalse( is_matrix(s) )  assertEquals( {s.nr,s.nc}, {cm.nr, cm.nc} )
    for i = 1,nr do for j = 1,nc do  assertEquals( s:get(i,j), complex(0,0) ) end end
    -- one arg: e_
    s = cm:same(1)
    assertFalse( is_matrix(s) )  assertEquals( {s.nr,s.nc}, {cm.nr,cm.nc} )
    -- two arg: nr, nc
    s = cm:same(2,2) assertFalse( is_matrix(s) ) assertEquals( {s.nr,s.nc}, {2,2} )
    s = cm:same(4,4) assertFalse( is_matrix(s) ) assertEquals( {s.nr,s.nc}, {4,4} )
    for i = 1,4 do for j = 1,4 do  assertEquals( s:get(i,j), complex(0,0) ) end end
    -- three arg: e_, nr, nc
    s = cm:same(1, 2, 2)
    assertFalse( is_matrix(s) ) assertEquals( {s.nr,s.nc}, {2,2} )
    s = cm:same(1, 5, 5)
    assertFalse( is_matrix(s) ) assertEquals( {s.nr,s.nc}, {5,5} )
    for i = 1,5 do for j = 1,5 do  assertEquals( s:get(i,j), complex(0,0) ) end end
  end end
end

-- size, same -----------------------------------------------------------------o

function TestCMatrix:testNrow()
  local cm, cv
  for nr=1,10 do
    cv = cvector(nr)       assertEquals( cv:nrow(), nr )
    for nc=1,10 do
      cm = cmatrix(nr,nc)  assertEquals( cm:nrow(), nr )
    end
  end
end

function TestCMatrix:testNcol()
local cm, cv
  for nr=1,10 do
    cv = cvector(nr)       assertEquals( cv:ncol(), 1  )
    for nc=1,10 do
      cm = cmatrix(nr,nc)  assertEquals( cm:ncol(), nc )
    end
  end
end

function TestCMatrix:testSize()
  local cm, cv
  for nr=1,10 do
    cv = cvector(nr)       assertEquals( cv:size(), nr*1  )
    for nc=1,10 do
      cm = cmatrix(nr,nc)  assertEquals( cm:size(), nr*nc )
    end
  end
end

function TestCMatrix:testSizes()
  local cm, cv
  for nr=1,10 do
    cv = cvector(nr)       assertEquals( {cv:sizes()}, {nr,1 } )
    for nc=1,10 do
      cm = cmatrix(nr,nc)  assertEquals( {cm:sizes()}, {nr,nc} )
    end
  end
end

function TestCMatrix:testTsizes()
  local cm, cv
  for nr=1,10 do
    cv = cvector(nr)       assertEquals( {cv:tsizes()}, {1 ,nr} )
    for nc=1,10 do
      cm = cmatrix(nr,nc)  assertEquals( {cm:tsizes()}, {nc,nr} )
    end
  end
end

function TestCMatrix:testRandom()
  local oldVal, val, cm = {},{}
  local msg = {
    "invalid argument #2 (callable expected)",
    }
  assertErrorMsgContains( msg[1], mth,'random', cmatrix(2), 1            )
  assertErrorMsgContains( msg[1], mth,'random', cmatrix(2), complex(1,1) )
  assertErrorMsgContains( msg[1], mth,'random', cmatrix(2), 1..2         )
  assertErrorMsgContains( msg[1], mth,'random', cmatrix(2), {}           )

  randomseed(2^52)  --randomseed(os.clock()*2^52)
  for nr=1,5 do
  for nc=1,5 do
    cm = cmatrix(nr,nc):random()
    for i = 1,cm:size() do
      val[i] = cm:geti(i)
      assertTrue ( val[i].re <  1 )
      assertTrue ( val[i].re >= 0 )
      assertTrue ( val[i].im <  1 )
      assertTrue ( val[i].im >= 0 )
    end
  end end
end

function TestCMatrix:testFill()
  local t, cm = {}
  local msg = {
    "invalid argument #2 (scalar, callable or indexable expected)",
    "container of insufficient size"                              ,
    }
  assertErrorMsgContains( msg[1], mth,'fill', cmatrix(2), nil  )
  assertErrorMsgContains( msg[1], mth,'fill', cmatrix(2), true )
  assertErrorMsgContains( msg[2], mth,'fill', cmatrix(2), {}   )
  for nr=1,5 do
  for nc=1,5 do
    cm = cmatrix(nr,nc)
    --scalar
    cm:fill(1)              for i=1,cm:size() do assertEquals( cm:geti(i), complex(1,0) ) end
    cm:fill(complex(1,1))   for i=1,cm:size() do assertEquals( cm:geti(i), complex(1,1) ) end
    --generator
    cm:fill(1..nr*nc)       for i=1,cm:size() do assertEquals( cm:geti(i), complex(i)   ) end
    cm:fill\x x+x*1i        for i=1,cm:size() do assertEquals( cm:geti(i), complex(i,i) ) end
    --2D container
    cm:fill( matrix(nr,nc)) for i=1,cm:size() do assertEquals( cm:geti(i), complex(0,0) ) end
    cm:fill(cmatrix(nr,nc)) for i=1,cm:size() do assertEquals( cm:geti(i), complex(0,0) ) end
    --1D container
    for i=1,nr*nc do t[i]=i end
    cm:fill(t)              for i=1,cm:size() do assertEquals( cm:geti(i), complex(i,0) ) end
    cm:fill(vector(nr*nc))  for i=1,cm:size() do assertEquals( cm:geti(i), complex(0,0) ) end
  end end
--check of types change
  assertTrue( is_cmatrix(cmatrix(5,5):fill(matrix(5,5)) ) )
  cm, t = cmatrix(5), {}
  for i=1,5 do t[i] = {} for j=1,5 do t[i][j]=(i-1)*5+j+((i-1)*5+j)*1i end end
  cm :fill(t)            for i=1,cm:size() do assertEquals( cm:geti(i), i+i*1i ) end
end

function TestCMatrix:testCopy()
  local msg, cm, cmcopy = {
    "invalid argument #1 (matrix with compatible type and size expected",
  }
  assertErrorMsgContains( msg[1], mth,'copy', cmatrix(2),  1         )
  assertErrorMsgContains( msg[1], mth,'copy', cmatrix(2), cmatrix(1) )
  assertErrorMsgContains( msg[1], mth,'copy', cmatrix(2),  matrix(2) )

  for nr=1,5 do
  for nc=1,5 do
    cm     = cmatrix(nr,nc):fill(1..nr*nc):fill \x x+x*1i
    cmcopy = cmatrix(nr,nc)
    cmcopy:copy(cm)
    for i=1,cm :size() do assertEquals( cm:geti(i), cmcopy:geti(i) ) end
  end end
  cm     = cmatrix(5):fill(1..25)
  cmcopy = cmatrix(4)
  cmcopy:copy(cm)
  for i=1,cmcopy:size() do assertEquals( cm:geti(i), cmcopy:geti(i) ) end
end

function TestCMatrix:testZeros()
  local cm
  for nr=1,5 do
  for nc=1,5 do
    cm = cmatrix(nr,nc):fill(1..nr*nc):fill \x x+x*1i
    cm:zeros()
    for i=1,cm:size() do assertEquals( cm:geti(i), complex(0,0) ) end
  end end
end

function TestCMatrix:testOnes()
  local cm
  for nr=1,5 do
  for nc=1,5 do
    cm = cmatrix(nr,nc):fill(1..nr*nc):fill \x x+x*1i
    cm:ones()
    for i=1,cm:size() do assertEquals( cm:geti(i), complex(1,0) ) end
  end end
end

function TestCMatrix:testEye()
  local cm, s
  for nr=1,5 do
  for nc=1,5 do
    cm = cmatrix(nr,nc):fill(1..nr*nc):fill \x x+x*1i
    cm:eye()

    s = { cm:sizes() }
    for i=1,s[1] do
    for j=1,s[2] do
      if i==j then assertEquals( cm:get(i,j), complex(1,0) )
      else         assertEquals( cm:get(i,j), complex(0,0) ) end
    end end
  end end
end

function TestCMatrix:testSymp() --TODO
  local msg = {
    "invalid argument #1 (2n matrix expected)",
  }
  assertErrorMsgContains( msg[1], mth,'symp', cvector(2)   )
  assertErrorMsgContains( msg[1], mth,'symp', cmatrix(3)   )
  assertErrorMsgContains( msg[1], mth,'symp', cmatrix(4,3) )
end

function TestCMatrix:testCirc() --TODO
  local msg = {
    "invalid argument #2 (iterable expected)",
  }
  assertErrorMsgContains( msg[1], mth,'circ', cmatrix(2), nil  )
  assertErrorMsgContains( msg[1], mth,'circ', cmatrix(2), 1    )
  assertErrorMsgContains( msg[1], mth,'circ', cmatrix(2), \x x )
end

function TestCMatrix:testReshape()
  local msg, cm, s = {
    "invalid matrix new sizes",
    }
  assertErrorMsgContains( msg[1], mth,'reshape', cmatrix(2), 3, 3  )
  assertErrorMsgContains( msg[1], mth,'reshape', cmatrix(2), 1, 5  )
  assertErrorMsgContains( msg[1], mth,'reshape', cmatrix(2), 0, 2  )
  assertErrorMsgContains( msg[1], mth,'reshape', cmatrix(2), 1, 0  )

  for nr=1,5  do
  for nc=1,5  do
  for i =1,nr do
  for j =1,nc do
    cm = cmatrix(nr,nc):fill(1..nr*nc):fill \x x+x*1i
    cm:reshape(i,j)
    assertEquals( {cm:sizes()}, {i,j} )
  end end
  end end
end

-- getx, setx -----------------------------------------------------------------o

function TestCMatrix:testGetsub()
  local cm, cm1, cmRes, cmRef, r, ir, jc
  local msg = {
    "invalid argument #2 (iterable expected)",
    "invalid argument #3 (iterable expected)",
    "invalid argument #4 (iterable expected)",
    "invalid range member '1'"               ,
    "cannot convert 'nil' to 'complex'"      ,
    }
  assertErrorMsgContains( msg[1], mth, 'getsub', cmatrix(2), nil          )
  assertErrorMsgContains( msg[1], mth, 'getsub', cmatrix(2), ''           )
  assertErrorMsgContains( msg[1], mth, 'getsub', cmatrix(2), \x x         )
  assertErrorMsgContains( msg[1], mth, 'getsub', cmatrix(2), complex(1,1) )
  assertErrorMsgContains( msg[2], mth, 'getsub', cmatrix(2), 1   , nil    )
  assertErrorMsgContains( msg[2], mth, 'getsub', cmatrix(2), 1   , ''     )
  assertErrorMsgContains( msg[2], mth, 'getsub', cmatrix(2), 1   , \x x   )
  assertErrorMsgContains( msg[5], mth, 'getsub', cmatrix(2), 0   , 0      )
  assertErrorMsgContains( msg[5], mth, 'getsub', cmatrix(2), 3   , 1      )
  assertErrorMsgContains( msg[5], mth, 'getsub', cmatrix(2), 1   , 3      )
  assertErrorMsgContains( msg[5], mth, 'getsub', cmatrix(2), 0   , 1      )
  assertErrorMsgContains( msg[5], mth, 'getsub', cmatrix(2), 1   , 0      )
  assertErrorMsgContains( msg[3], mth, 'getsub', cmatrix(2), 0   , 0   , 1    )
  assertErrorMsgContains( msg[3], mth, 'getsub', cmatrix(2), 1   , 1   , \x x )
  assertErrorMsgContains( msg[4], mth, 'getsub', cmatrix(2), 1   , 1   , 1..4 )

  cm = cmatrix(5,5):fill(1..(5*5))
  assertTrue( is_table  (cm:getsub(1, 1, {} )) )
  assertTrue( is_cvector(cm:getsub(1, 1, nil)) )
  assertTrue( is_cmatrix(cm:setsub(1, 2, matrix(1) )))

  local newt = \x      => if is_table(x)   then return {} else return x end end
  local ref  = \i,j,nc => return complex((i-1)*nc+j,(i-1)*nc+j) end
  local tab  = \x,...  =>
    local arg = {...}
    if     is_table(x) then return arg
    elseif #arg <= 2   then return cmatrix(arg)
    else                    return cmatrix({{arg[1], arg[2]}, {arg[3], arg[4]}})
    end
  end

  r = { nil, {} }
  for ri=1,#r do
  for nr=1,5  do
  for nc=1,5  do
    cm = cmatrix(nr,nc):fill(1..nr*nc):fill \x x+x*1i
    for i = 1,nr do
    for j = 1,nc do
      assertEquals( cm:getsub( i, j):size(), 1 )
      assertEquals( cm:getsub( i, j, newt(r[ri])), tab(r[ri], ref(i,j,nc)) )
      ir = { {1,i}, vector({1,i}) }
      jc = { {1,j}, vector({1,j}) }
      for d=1,#ir do
        cmRef = tab(r[ri], ref(1,1,nc), ref(1,j,nc), ref(i,1,nc), ref(i,j,nc))
        assertEquals( cm:getsub(ir[d], jc[d], r[ri]), cmRef )
      end
      for a = 1,i do
      for b = 1,j do
        cm1 = cm:getsub( a..i, b..j)
        assertEquals( cm1:size(), (i-a+1)*(j-b+1) )
        if (i-a)+1 > 1 and (j-b)+1 > 1 then
          cmRes = tab( r[ri], cm1:get(1,1), cm1:get(1,2) , cm1:get(2,1) , cm1:get(2,2)    )
          cmRef = tab( r[ri], ref(a,b,nc) , ref(a,b+1,nc), ref(a+1,b,nc), ref(a+1,b+1,nc) )
          assertEquals( cmRes, cmRef )
          cmRes = tab( r[ri], cm1:get( i-a, j-b), cm1:get( i-a, j-b+1), cm1:get( i-a+1, j-b), cm1:get( i-a+1,j-b+1) )
          cmRef = tab( r[ri], ref(i-1,j-1,nc)   , ref(i-1,j,nc)       , ref(i,j-1,nc)       , ref(i,j,nc)           )
          assertEquals( cmRes, cmRef )
        elseif (i-a)+1 >  1 and (j-b)+1 == 1 then -- vectors
          cmRes = tab( r[ri], cm1:get(1,1), cm1:get(2,1)  )
          cmRef = tab( r[ri], ref(a,b,nc) , ref(a+1,b,nc) )
          assertEquals( cmRes, cmRef )
          cmRes = tab( r[ri], cm1:get( i-a,j-b+1), cm1:get( i-a+1,j-b+1) )
          cmRef = tab( r[ri], ref(i-1,j,nc)      , ref(i,j,nc)           )
          assertEquals( cmRes, cmRef )
        elseif (i-a)+1 == 1 and (j-b)+1 >  1 then -- rows
          cmRes = tab( r[ri], cm1:get(1,1), cm1:get(1,2)  )
          cmRef = tab( r[ri], ref(a,b,nc) , ref(a,b+1,nc) )
          assertEquals( cmRes, cmRef )
          cmRes = tab( r[ri], cm1:get( i-a+1, j-b), cm1:get( i-a+1,j-b+1) )
          cmRef = tab( r[ri], ref(i,j-1,nc)       , ref(i,j,nc)           )
          assertEquals( cmRes, cmRef )
        end
      end end
    end end
  end end end
end

function TestCMatrix:testSetsub() --TODO after getsub cleanup
  local msg, cm = {
    "invalid argument #2 (iterable expected)"          ,
    "invalid argument #3 (iterable expected)"          ,
    "invalid argument #4 (scalar or iterable expected)",
    "1-index out of bounds"                            ,
  }
  assertErrorMsgContains( msg[1], mth, 'setsub', cmatrix(2), nil , 1  , 1  )
  assertErrorMsgContains( msg[1], mth, 'setsub', cmatrix(2), ''  , 1  , 1  )
  assertErrorMsgContains( msg[1], mth, 'setsub', cmatrix(2), NaN , 1  , 1  )
  assertErrorMsgContains( msg[1], mth, 'setsub', cmatrix(2), \x x, 1  , 1  )
  assertErrorMsgContains( msg[2], mth, 'setsub', cmatrix(2), 1             )
  assertErrorMsgContains( msg[2], mth, 'setsub', cmatrix(2), 1   , nil, 1  )
  assertErrorMsgContains( msg[2], mth, 'setsub', cmatrix(2), 1   , '' , 1  )
  assertErrorMsgContains( msg[2], mth, 'setsub', cmatrix(2), 1   , NaN, 1  )
  assertErrorMsgContains( msg[3], mth, 'setsub', cmatrix(2), 1   , 1 , nil )
  assertErrorMsgContains( msg[3], mth, 'setsub', cmatrix(2), 1   , 1 , ''  )
  assertErrorMsgContains( msg[3], mth, 'setsub', cmatrix(2), 1   , 1 , NaN )
  assertErrorMsgContains( msg[4], mth, 'setsub', cmatrix(2), 0   , 1 , 1   )
  assertErrorMsgContains( msg[4], mth, 'setsub', cmatrix(2), 1   , 0 , 1   )
  assertErrorMsgContains( msg[1], mth, 'setsub', cmatrix(2), complex(1,1), 1 , 1 )
  assertErrorMsgContains( msg[2], mth, 'setsub', cmatrix(2), 1 , complex(1,1), 1 )

  --accordingly to the fixed version of getsub + possible inputs
  for nr=1,5  do
  for nc=1,5  do
    cm = cmatrix(nr,nc):fill(1..nr*nc):fill \x x+x*1i
    for i = 1,nr do
    for j = 1,nc do
      --print( m:setsub())

    end end
  end end
end

function TestCMatrix:testGetv()
  local t, m, cm = {}
  local msg = {
    "invalid argument #2 (iterable expected)",
    "invalid argument #3 (iterable expected)",
    "cannot convert 'nil' to 'complex"        ,
    "invalid range member '1'"               ,
  }
  assertErrorMsgContains( msg[1], mth, 'getv', cmatrix(2), nil )
  assertErrorMsgContains( msg[1], mth, 'getv', cmatrix(2), ''  )
  assertErrorMsgContains( msg[1], mth, 'getv', cmatrix(2), NaN )
  assertErrorMsgContains( msg[2], mth, 'getv', cmatrix(2), 1  , ''   )
  assertErrorMsgContains( msg[2], mth, 'getv', cmatrix(2), 1  , 1    )
  assertErrorMsgContains( msg[2], mth, 'getv', cmatrix(2), 1  , \x x )
  assertErrorMsgContains( msg[3], mth, 'getv', cmatrix(2), 0         )
  assertErrorMsgContains( msg[3], mth, 'getv', cmatrix(2), matrix(2) )
  assertErrorMsgContains( msg[4], mth, 'getv', cmatrix(2), 1  , 1..2 )
  assertEquals( cmatrix(2):fill(1..4):getv(1,NaN), cmatrix({1}) )

  for nr=1,5  do
  for nc=1,5  do
    cm = cmatrix(nr,nc):fill(1..nr*nc)
    for i = 1,nr*nc do
      assertEquals( cm:getv( i   )            , cvector({i})          )
      assertEquals( cm:getv( 1..i)            , cvector(i):fill(1..i) )
      assertEquals( cm:getv({1,i})            , cvector({1,i})        )
      assertEquals( cm:getv( i   , {})        , {complex(i,0)}        )
      assertEquals( cm:getv({1,i}, {})        , {complex(1,0),complex(i,0)} )
      assertEquals( cm:getv( i   , cmatrix(2)), cmatrix{{i,0},{0,0}} )        --can be also matrix in assertEq, check further
      assertEquals( cm:getv({1,i}, cmatrix(2)), cmatrix{{1,i},{0,0}} )
      t={} for j=1,i do t[j] = complex(j,0) end
      assertEquals( cm:getv( 1..i, {}), t )
      end
  end end
  assertTrue( is_matrix (cm:getv( 5   ,  matrix(2))) )
  assertTrue( is_matrix (cm:getv({1,5},  matrix(2))) )
end

function TestCMatrix:testSetv()
  local t, cm = {}
  local msg = {
    "invalid argument #2 (iterable expected)"          ,
    "invalid argument #3 (scalar or iterable expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'setv', cmatrix(2), nil , 0    )
  assertErrorMsgContains( msg[1], mth, 'setv', cmatrix(2), ''  , 0    )
  assertErrorMsgContains( msg[1], mth, 'setv', cmatrix(2), NaN , 0    )
  assertErrorMsgContains( msg[1], mth, 'setv', cmatrix(2), \x x, 0    )
  assertErrorMsgContains( msg[2], mth, 'setv', cmatrix(2), 1   , ''   )
  assertErrorMsgContains( msg[2], mth, 'setv', cmatrix(2), 1   , nil  )
  assertErrorMsgContains( msg[2], mth, 'setv', cmatrix(2), 1   , NaN  )
  assertErrorMsgContains( msg[2], mth, 'setv', cmatrix(2), 1   , \x x )

  for nr=1,5 do
  for nc=1,5 do
    for i = 1,nr*nc do
      for d=1,i do t[d]=d end
      cm = cmatrix(nr,nc):setv( i   , i    ) assertEquals( cm:getv( i   ), cvector({i})          )
      cm = cmatrix(nr,nc):setv( 1..i, i    ) assertEquals( cm:getv( 1..i), cvector(i):fill(i)    )
      cm = cmatrix(nr,nc):setv({1,i}, i    ) assertEquals( cm:getv({1,i}), cvector({i,i})        )
      cm = cmatrix(nr,nc):setv( 1..i, 1..i ) assertEquals( cm:getv( 1..i), cvector(i):fill(1..i) )
      cm = cmatrix(nr,nc):setv( i   , {i}  ) assertEquals( cm:getv( i   ), cvector({i})          )
      cm = cmatrix(nr,nc):setv({1,i}, {1,i}) assertEquals( cm:getv({1,i}), cvector({1,i})        )
      cm = cmatrix(nr,nc):setv( 1..i, t    ) assertEquals( cm:getv( 1..i), cvector(i):fill(1..i) )
    end
  end end
  cm = cmatrix(5,5):setv({1,3}, 1..2              ) assertEquals( cm:getv({1,3}), cvector({1,2}) )
  cm = cmatrix(5,5):setv({1,3}, cvector(3):fill(1)) assertEquals( cm:getv({1,3}), cvector({1,1}) )
  cm = cmatrix(5,5):setv( 1   , complex(1,1)      ) assertEquals( cm:getv( 1   ), cvector({complex(1,1)}) )
end

function TestCMatrix:testGetdiag()
  local msg, cm, cdiag, n = {
    "invalid argument #2 (iterable expected)",
    "invalid range member '1'"               ,
  }
  assertErrorMsgContains( msg[1], mth, 'getdiag', cmatrix(2), ''   )
  assertErrorMsgContains( msg[1], mth, 'getdiag', cmatrix(2), \x x )
  assertErrorMsgContains( msg[1], mth, 'getdiag', cmatrix(2), 1    )
  assertErrorMsgContains( msg[2], mth, 'getdiag', cmatrix(2), 1..2 )
  assertTrue( is_cmatrix( matrix(2):getdiag(cmatrix(2))) )
  assertTrue( is_matrix (cmatrix(2):getdiag( matrix(2))) )
  assertEquals( matrix(2):fill(1..4):getdiag(NaN), matrix(2):fill(1..4):getdiag() )

  for nr=1,5  do
  for nc=1,5  do
    cm = cmatrix(nr,nc):fill(1..nr*nc):fill \x x+x*1i
    n  = min(nr,nc)
    cdiag = {}
    for i = 1,n do cdiag[i] = complex(1+(i-1)*nc+i-1, 1+(i-1)*nc+i-1) end

    assertEquals( cm:getdiag()           , cvector(cdiag) )
    assertEquals( cm:getdiag({})         ,  cdiag         )
    assertEquals( cm:getdiag(matrix(n,1)),  vector(cdiag) )
  end end
end

function TestCMatrix:testSetdiag()
  local cdiag, cref, cm
  local msg = {
    "invalid argument #2 (scalar or iterable expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'setdiag', cmatrix(2), nil  )
  assertErrorMsgContains( msg[1], mth, 'setdiag', cmatrix(2), ''   )
  assertErrorMsgContains( msg[1], mth, 'setdiag', cmatrix(2), \x x )
  assertTrue ( is_cmatrix(cmatrix(2,2):setdiag( matrix(2)  )) )
  assertTrue ( is_matrix ( matrix(2,2):setdiag(cmatrix(2)  )) )
  assertFalse( is_cmatrix( matrix(2,2):setdiag(complex(1,1))) )
  cm = cmatrix(2):setdiag(cmatrix(1):fill(1))
  assertEquals( cm:getdiag(), cvector({1,0}))

  for nr=1,5  do
  for nc=1,5  do
    cm = cmatrix(nr,nc):fill(1..nr*nc):fill \x x+x*1i
    n  = min(nr,nc)
    diag, cdiag, ref, cref = {}, {}, {}, {}
    for i = 1,n do cdiag[i] = complex(1+(i-1)*nc+i-1, 1+(i-1)*nc+i-1) end
    for i = 1,n do if i<=3 then cref[i] = i
                   else         cref[i] = cdiag[i] end end
    cm:setdiag(1)            assertEquals( cm:getdiag(), cvector(n):fill(1)    )
    cm:setdiag(1..n)         assertEquals( cm:getdiag(), cvector(n):fill(1..n) )
    cm:setdiag(cdiag)        assertEquals( cm:getdiag(), cvector(cdiag)        )
    cm:setdiag({1,2,3})      assertEquals( cm:getdiag(), cvector(cref)         )
    cm:setdiag(complex(1,1)) assertEquals( cm:getdiag(), cvector(n):fill(1):fill \x x+x*1i  )
  end end
end

function TestCMatrix:testGetrow()
  local msg, cm, r = {
    "invalid argument #2 (iterable expected)",
    "invalid argument #3 (iterable expected)",
    "cannot convert 'nil' to 'complex'"      ,
    "invalid range member '1'"               ,
    "1-index out of bounds"                  ,
    }
  assertErrorMsgContains( msg[1], mth, 'getrow', cmatrix(2), ''         )
  assertErrorMsgContains( msg[1], mth, 'getrow', cmatrix(2), nil        )
  assertErrorMsgContains( msg[1], mth, 'getrow', cmatrix(2), NaN        )
  assertErrorMsgContains( msg[1], mth, 'getrow', cmatrix(2), \x x       )
  assertErrorMsgContains( msg[2], mth, 'getrow', cmatrix(2), 1   , ''   )
  assertErrorMsgContains( msg[2], mth, 'getrow', cmatrix(2), 1   , 1    )
  assertErrorMsgContains( msg[3], mth, 'getrow', cmatrix(2), 0          )
  assertErrorMsgContains( msg[3], mth, 'getrow', cmatrix(2), 5          )
  assertErrorMsgContains( msg[4], mth, 'getrow', cmatrix(2), 1   , 1..2 )
  assertErrorMsgContains( msg[5], mth, 'getrow', cmatrix(2), 1   , vector(1) )

  assertTrue  ( is_matrix (cmatrix(2):getrow(1, matrix(2))) )
  assertEquals( cmatrix(2,2):getrow(1, NaN      ), cmatrix(1,2) )
  assertEquals( cmatrix(2,2):fill(1..4):getrow(1, cvector(2)), cvector{1,2}   )
  assertEquals( cmatrix(2,2):fill(1..4):getrow(1, cvector(3)), cvector{1,2,0} )
  r = { nil, {} }
  for nr=1,5 do
  for nc=1,5 do
    for ri=1,#r do
      cm = cmatrix(nr,nc):fill(1..nr*nc):fill \x x+x*1i
      for i =1,nr do
        ir = { i, {1,i}, 1..i }
        for j=1,#ir do
          assertEquals( cm:getrow(ir[j],r[ri]), cm:getsub(ir[j],1..nc,r[ri]) )
        end
      end end
  end end
end

function TestCMatrix:testSetrow()
  local cm, cm1
  local msg = {
    "invalid argument #2 (iterable expected)"          ,
    "invalid argument #3 (scalar or iterable expected)",
    "1-index out of bounds"                            ,
    "cannot convert 'nil' to 'complex'"                 ,
  }
  assertErrorMsgContains( msg[1], mth, 'setrow', cmatrix(2), ''        )
  assertErrorMsgContains( msg[1], mth, 'setrow', cmatrix(2), nil       )
  assertErrorMsgContains( msg[1], mth, 'setrow', cmatrix(2), NaN       )
  assertErrorMsgContains( msg[1], mth, 'setrow', cmatrix(2), \x x      )
  assertErrorMsgContains( msg[2], mth, 'setrow', cmatrix(2), 1   , nil )
  assertErrorMsgContains( msg[2], mth, 'setrow', cmatrix(2), 1   , ''  )
  assertErrorMsgContains( msg[3], mth, 'setrow', cmatrix(2), 0   , 1   )
  assertErrorMsgContains( msg[3], mth, 'setrow', cmatrix(2), 3   , 1   )
  assertErrorMsgContains( msg[4], mth, 'setrow', cmatrix(2), 1   , matrix(1) )
  assertErrorMsgContains( msg[4], mth, 'setrow', cmatrix(3), 1   , 1..2      )
  assertErrorMsgContains( msg[4], mth, 'setrow', cmatrix(3), 1   , {1,2}     )
  for nr=1,5 do
  for nc=1,5 do
    m   =  matrix(nr,nc):fill(1..nr*nc)
    cm  = cmatrix(nr,nc):fill(1..nr*nc):fill \x x+x*1i
    cm1 = cmatrix(nr,nc)  cm1:copy(cm)
    for i=1,nr do
      cm:setrow(i    , 1           )  cm1:setsub(i    ,1..nc, 1           ) assertEquals( cm, cm1 )
      cm:setrow(1..i , 1           )  cm1:setsub(1..i ,1..nc, 1           ) assertEquals( cm, cm1 )
      cm:setrow({1,i}, 1           )  cm1:setsub({1,i},1..nc, 1           ) assertEquals( cm, cm1 )
      cm:setrow(i    , 1..5        )  cm1:setsub(i    ,1..nc, 1..5        ) assertEquals( cm, cm1 )
      cm:setrow(1..i , 1..m:size() )  cm1:setsub(1..i ,1..nc, 1..cm:size() ) assertEquals( cm, cm1 )
      cm:setrow({1,i}, 1..10       )  cm1:setsub({1,i},1..nc, 1..10       ) assertEquals( cm, cm1 )
      cm:setrow(i    , {1,2,3,4,5} )  cm1:setsub(i    ,1..nc, {1,2,3,4,5} ) assertEquals( cm, cm1 )
    end
  end end
  assertFalse( is_matrix ( cmatrix(5,5):setrow(1, 1 )) )

  cm  =  cmatrix(5,5):fill(1..25)
  cm1 =  cmatrix(5,5) cm1:copy(cm)
  cm :setrow({1,5}      , {1,2,3,4,5,1,2,3,4,5} )
  cm1:setsub({1,5}, 1..5, {1,2,3,4,5,1,2,3,4,5} )
  assertEquals( cm, cm1 )
  cm :setrow(1..2       , {1,2,3,4,5,1,2,3,4,5} )
  cm1:setsub(1..2 , 1..5, {1,2,3,4,5,1,2,3,4,5} )
  assertEquals( cm, cm1 )
end

function TestCMatrix:testGetcol()
  local cm, r
  local msg = {
    "invalid argument #2 (iterable expected)",
    "invalid argument #3 (iterable expected)",
    "cannot convert 'nil' to 'complex'"       ,
    "invalid range member '1'"               ,
    "1-index out of bounds"                  ,
  }
  assertErrorMsgContains( msg[1], mth, 'getcol', cmatrix(2), ''   )
  assertErrorMsgContains( msg[1], mth, 'getcol', cmatrix(2), nil  )
  assertErrorMsgContains( msg[1], mth, 'getcol', cmatrix(2), NaN  )
  assertErrorMsgContains( msg[1], mth, 'getcol', cmatrix(2), \x x )
  assertErrorMsgContains( msg[2], mth, 'getcol', cmatrix(2), 1   , ''   )
  assertErrorMsgContains( msg[2], mth, 'getcol', cmatrix(2), 1   , 1    )
  assertErrorMsgContains( msg[3], mth, 'getcol', cmatrix(2), 0          )
  assertErrorMsgContains( msg[3], mth, 'getcol', cmatrix(2), 3          )
  assertErrorMsgContains( msg[4], mth, 'getcol', cmatrix(2), 1   , 1..2 )
  assertErrorMsgContains( msg[5], mth, 'getcol', cmatrix(2), 1   , vector(1) )
  r = { nil, {} }
  for nr=1,5 do
  for nc=1,5 do
    for ri=1,#r do
    cm = cmatrix(nr,nc):fill(1..nr*nc):fill \x x+x*1i
      for i =1,nc do
        ir = { i, {1,i}, 1..i }
        for j=1,#ir do
          assertEquals( cm:getcol(ir[j],r[ri]), cm:getsub(1..nr,ir[j],r[ri]) )
        end
      end end
  end end
end

function TestCMatrix:testSetcol()
  local cm, cm1
  local msg = {
    "invalid argument #2 (iterable expected)"          ,
    "invalid argument #3 (scalar or iterable expected)",
    "1-index out of bounds"                            ,
    "cannot convert 'nil' to 'complex'"                 ,
  }
  assertErrorMsgContains( msg[1], mth, 'setcol', cmatrix(2), ''         )
  assertErrorMsgContains( msg[1], mth, 'setcol', cmatrix(2), nil        )
  assertErrorMsgContains( msg[1], mth, 'setcol', cmatrix(2), NaN        )
  assertErrorMsgContains( msg[1], mth, 'setcol', cmatrix(2), \x x       )
  assertErrorMsgContains( msg[2], mth, 'setcol', cmatrix(2), 1   ,  ''  )
  assertErrorMsgContains( msg[2], mth, 'setcol', cmatrix(2), 1   ,  nil )
  assertErrorMsgContains( msg[3], mth, 'setcol', cmatrix(2), 0   ,  1   )
  assertErrorMsgContains( msg[3], mth, 'setcol', cmatrix(2), 3   ,  1   )
  assertErrorMsgContains( msg[4], mth, 'setcol', cmatrix(2), 1   ,  cmatrix(1) )
  assertErrorMsgContains( msg[4], mth, 'setcol', cmatrix(3), 1   ,  1..2       )
  assertErrorMsgContains( msg[4], mth, 'setcol', cmatrix(3), 1   ,  {1,2}      )

  for nr=1,5 do
  for nc=1,5 do
    cm  = cmatrix(nr,nc):fill(1..nr*nc):fill \x x+x*1i
    cm1 = cmatrix(nr,nc)
    for i=1,nc do
      cm1:copy(cm)
      cm:setcol(i    , 1           )   cm1:setsub(1..nr,i    , 1           ) assertEquals( cm, cm1 )
      cm:setcol(1..i , 1           )   cm1:setsub(1..nr,1..i , 1           ) assertEquals( cm, cm1 )
      cm:setcol({1,i}, 1           )   cm1:setsub(1..nr,{1,i}, 1           ) assertEquals( cm, cm1 )
      cm:setcol(i    , 1..5        )   cm1:setsub(1..nr,i    , 1..5        ) assertEquals( cm, cm1 )

      cm1:copy( cm) for k=1,i  do for j=1,nr do cm1:seti(k+(j-1)*nc,(k-1)*nr+j+0*1i) end end
      cm:setcol(1..i , 1..cm:size() )   assertEquals( cm, cm1 )
      cm1:copy( cm) for j=1,nr do cm1:seti(i+(j-1)*nc, j) end
      cm:setcol(i    , {1,2,3,4,5} )   assertEquals( cm, cm1 )

      cm  = cmatrix(nr,nc):fill(1..nr*nc):fill \x x+x*1i
      cm1:copy( cm)
      for it,k in ipairs({1,i}) do for j=1,nr do cm1:seti(k+(j-1)*nc, (it-1)*nr+j) end end
      cm:setcol({1,i}, 1..10       )   assertEquals( cm, cm1 )
    end
  end end
end

-- foreach, filter, map, fold, scan -------------------------------------------o

function TestCMatrix:testForeach()
  local cm, cm1, f, t
  local msg = {
    "invalid argument #2 (callable expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'foreach', cmatrix(2), nil       )
  assertErrorMsgContains( msg[1], mth, 'foreach', cmatrix(2), ''        )
  assertErrorMsgContains( msg[1], mth, 'foreach', cmatrix(2), 1         )
  assertErrorMsgContains( msg[1], mth, 'foreach', cmatrix(2), 1..2      )
  assertErrorMsgContains( msg[1], mth, 'foreach', cmatrix(2), matrix(1) )
  assertErrorMsgContains( msg[1], mth, 'foreach', cmatrix(2), { }       )

  f = \x,i,j => t[i][j]=x  end
  for nr=1,5 do
  for nc=1,5 do
    cm = cmatrix(nr,nc):fill(1..nr*nc):fill \x x+x*1i
    t  = table.new(nr,nc)
    for i=0,nr-1 do local c = t[i+1] or table.new(nc,0) t[i+1] = c end
    cm:foreach(f)
    for i=1,#t   do for j=1,#t[i] do assertEquals( t[i][j], (i-1)*nc+j+((i-1)*nc+j)*1i ) end end
   end end
end

function TestCMatrix:testMap() --TODO: rethink adding different lambda f
  local cm, cmref, ctref
  local msg = {
    "invalid argument #2 (callable expected)"                 ,
    "invalid argument #3 (iterable expected)"                 ,
    "invalid range member '1'"                                ,
    "attempt to perform arithmetic on local 'x' (a nil value)",
  }
  assertErrorMsgContains( msg[1], mth, 'map', cmatrix(2), ''           )
  assertErrorMsgContains( msg[1], mth, 'map', cmatrix(2), 1..2         )
  assertErrorMsgContains( msg[1], mth, 'map', cmatrix(2), 1            )
  assertErrorMsgContains( msg[1], mth, 'map', cmatrix(2), matrix(1)    )
  assertErrorMsgContains( msg[1], mth, 'map', cmatrix(2), { }          )
  assertErrorMsgContains( msg[2], mth, 'map', cmatrix(2), \x x+1, ''   )
  assertErrorMsgContains( msg[2], mth, 'map', cmatrix(2), \x x+1, 1    )
  assertErrorMsgContains( msg[3], mth, 'map', cmatrix(2), \x x+1, 1..2 )
  assertEquals( cmatrix(2):map(\x x+1, matrix(2)), cmatrix(2):fill(1) )
  assertEquals( cmatrix(2):map(\x x+1, NaN      ), cmatrix(2):fill(1) )

  for nr=1,5 do
  for nc=1,5 do
    cm    = cmatrix(nr,nc):fill(1..nr*nc)  :fill \x x+x*1i
    cmref = cmatrix(nr,nc):fill(2..nr*nc+1):fill \x x+x*1i
    ctref = {} for i=1,#cm do ctref[i]=complex(i+1,i+1) end
    cm1   = cm:map  \x x+1+1i
    assertEquals( cm1, cmref )
    assertEquals( cm , cmatrix(nr,nc):fill(1..nr*nc):fill \x x+x*1i  )
    cm1   = cm:map( \x x+1+1i, {} )
    assertEquals( cm1, ctref )
    assertEquals( cm , cmatrix(nr,nc):fill(1..nr*nc):fill \x x+x*1i  )
    cm1   = cm:map( \x x+1+1i, 'in' )
    assertEquals( cm1, cmref )
    assertEquals( cm , cmref )
  end end
  cm = matrix(5,5):fill(1..25)
  cm:map( \x x+1+1i, 'in' )
  assertTrue ( is_matrix(cm) ) -- should it be?
end

function TestCMatrix:testMap2()
  local cm1, cm2, cm, ctref, m
  local msg = {
    "invalid argument #2 (scalar or iterable expected)",
    "invalid argument #3 (callable expected)"          ,
    "invalid argument #4 (iterable expected)"          ,
    "invalid range member '1'"                         ,
    "nvalid arguments (unsupported complex operation)" ,
  }
  assertErrorMsgContains( msg[1], mth, 'map2', cmatrix(2), nil  )
  assertErrorMsgContains( msg[1], mth, 'map2', cmatrix(2), ''   )
  assertErrorMsgContains( msg[1], mth, 'map2', cmatrix(2), NaN  )
  assertErrorMsgContains( msg[1], mth, 'map2', cmatrix(2), \x x )
  assertErrorMsgContains( msg[2], mth, 'map2', cmatrix(2), cmatrix(1), nil  )
  assertErrorMsgContains( msg[2], mth, 'map2', cmatrix(2), cmatrix(1), 1..2 )
  assertErrorMsgContains( msg[2], mth, 'map2', cmatrix(2), cmatrix(1), 1    )
  assertErrorMsgContains( msg[3], mth, 'map2', cmatrix(2), cmatrix(1), \x x, 1    )
  assertErrorMsgContains( msg[4], mth, 'map2', cmatrix(2), cmatrix(1), \x x, 1..2 )
  assertErrorMsgContains( msg[5], mth, 'map2', cmatrix(2), cmatrix(1), \x,y  x+y  )

  for nr=1,5 do
  for nc=1,5 do
    cm1 = cmatrix(nr,nc):fill(1..nr*nc):fill \x x+x*1i
    cm2 = cmatrix(nr,nc):fill(1..nr*nc):fill \x x+x*1i
    ctref = {} for i=1,#cm1 do ctref[i] = complex(0,0) end

    assertEquals ( cm1:map2( cm2, \x,y x-y ), cm2:map2( cm1, \x,y x-y ) )
    cm = cm1:map2( cm2, \x,y x-y )
    assertEquals ( cm, matrix(nr,nc) )
    cm = cm1:map2( cm2, \x,y x-y, {} )
    assertEquals ( cm, ctref )
    cm = cm1:map2( cm2, \x,y x-y, "in" )
    assertEquals ( cm1, matrix(nr,nc)  )
    assertEquals ( cm , cm1 )
  end end
  m   =  matrix(5):fill(1..25)
  cm  = cmatrix(5):fill(1..25)
  cm1 = cm:map2( m, \x,y x-y )
  assertTrue  ( is_cmatrix(cm1) )
  assertEquals( cm1, cmatrix(5) )
  cm1 = m:map2( cm, \x,y x-y )
  assertEquals( cm1, cmatrix(5) )
  assertTrue  ( is_cmatrix(cm1) )

  cm1 =  cmatrix(5):fill(1..25)
  cm2 =  cmatrix(4):fill(1..20)
  assertEquals( cm2:map2( cm1, \x,y x-y ), cmatrix(4) )
end

function TestCMatrix:testMap3()
  local cm, cm1, cm2, cm3, ctref = cmatrix(2)
  local msg = {
    "invalid argument #2 (scalar or iterable expected)",
    "invalid argument #3 (scalar or iterable expected)",
    "invalid argument #4 (callable expected)"          ,
    "invalid argument #5 (iterable expected)"          ,
    "invalid range member '1'"                         ,
    "invalid arguments (unsupported complex operation)",
  }
  assertErrorMsgContains( msg[1], mth, 'map3', cm, ''   )
  assertErrorMsgContains( msg[1], mth, 'map3', cm, NaN  )
  assertErrorMsgContains( msg[1], mth, 'map3', cm, \x x )
  assertErrorMsgContains( msg[2], mth, 'map3', cm, cm        , ''   )
  assertErrorMsgContains( msg[2], mth, 'map3', cm, cm        , NaN  )
  assertErrorMsgContains( msg[2], mth, 'map3', cm, cm        , \x x )
  assertErrorMsgContains( msg[3], mth, 'map3', cm, cm        , cm    , nil  )
  assertErrorMsgContains( msg[3], mth, 'map3', cm, cm        , cm    , 1..2 )
  assertErrorMsgContains( msg[3], mth, 'map3', cm, cm        , cm    , 1    )
  assertErrorMsgContains( msg[4], mth, 'map3', cm, cm        , cm    , \x x, 1    )
  assertErrorMsgContains( msg[5], mth, 'map3', cm, cm        , cm    , \x x, 1..2 )
  assertErrorMsgContains( msg[6], mth, 'map3', cm, cmatrix(1), cm        , \x,y,z x+y+z )
  assertErrorMsgContains( msg[6], mth, 'map3', cm, cmatrix(1), cmatrix(1), \x,y,z x+y+z )
  assertErrorMsgContains( msg[6], mth, 'map3', cm, cm        , cmatrix(1), \x,y,z x+y+z )

  for nr=1,5 do
  for nc=1,5 do
    cm1 = cmatrix(nr,nc):fill(2..2*nr*nc..2)
    cm2 = cmatrix(nr,nc):fill(1..nr*nc)
    cm3 = cmatrix(nr,nc):fill(1..nr*nc)
    ctref = {} for i=1,#cm1 do ctref[i] = complex(0,0) end

    cm = cm1:map3 ( cm2, cm3, \x,y,z  x-y-z )
    assertEquals( cm, cmatrix(nr,nc) )
    cm = cm2:map3 ( cm1, cm3, \x,y,z -x+y-z )
    assertEquals( cm, cmatrix(nr,nc) )
    cm = cm1:map3 ( cm2, cm3, \x,y,z  x-y-z, {} )
    assertEquals( cm, ctref )
    cm = cm1:map3 ( cm2, cm3, \x,y,z  x-y-z, 'in' )
    assertEquals( cm, cmatrix(nr,nc) )
    assertEquals( cm, cm1 )
  end end
  m1  =  matrix(5):fill(2..50..2)
  m2  =  matrix(5):fill(1..25)
  cm1 = cmatrix(5):fill(1..25)
  cm  = cm1:map3( m1, m2, \x,y,z -x+y-z )
  assertTrue  ( is_cmatrix(cm) )
  assertEquals( cm, cmatrix(5) )

  cm1 =  cmatrix(5):fill(2..50..2)
  cm2 =  cmatrix(5):fill(1..25)
  cm3 =  cmatrix(4):fill(1..20)
  assertEquals( cm3:map3( cm1, cm2, \x,y,z -x+y-z ), cmatrix(4) )
end

function TestCMatrix:testMapij()
  local cm, cmref, cm1, ctref
  local msg = {
    "invalid argument #2 (callable expected)",
    "invalid argument #3 (iterable expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'mapij', cmatrix(2), nil       )
  assertErrorMsgContains( msg[1], mth, 'mapij', cmatrix(2), ''        )
  assertErrorMsgContains( msg[1], mth, 'mapij', cmatrix(2), 1..2      )
  assertErrorMsgContains( msg[1], mth, 'mapij', cmatrix(2), 1         )
  assertErrorMsgContains( msg[1], mth, 'mapij', cmatrix(2), cmatrix(1) )
  assertErrorMsgContains( msg[1], mth, 'mapij', cmatrix(2), { }       )
  assertErrorMsgContains( msg[2], mth, 'mapij', cmatrix(2), \x x+1  , ''   )
  assertErrorMsgContains( msg[2], mth, 'mapij', cmatrix(2), \x x+1  , \x x )
  for nr=1,5 do
  for nc=1,5 do
    cm    = cmatrix(nr,nc):fill(1..nr*nc)  :fill \x x+x*1i
    cmref = cmatrix(nr,nc):fill(2..nr*nc+1):fill \x x+x*1i
    cmref = cm:map   \x x+1
    cm1   = cm:mapij \x x+1
    assertEquals( cm1, cmref )
    assertEquals( cm , cmatrix(nr,nc):fill(1..nr*nc):fill \x x+x*1i )
    ctref = {} for i=1,#cm do ctref[i]=complex(i+1,i) end
    cmref = cm:map  ( \x x+1, {} )
    cm1   = cm:mapij( \x x+1, {} )
    assertEquals( cm1, cmref )
    assertEquals( cm1, ctref )
    cm1   = cm:mapij( \x x+1, 'in' )
    assertEquals( cm , cmatrix(nr,nc):fill(2..nr*nc+1):fill \x x+(x-1)*1i )
    assertEquals( cm1, cm )
  end end
end

function TestCMatrix:testMapat() --TODO: check copy not same
  local  n, cm, cmref, ctref
  local msg = {
    "invalid argument #2 (callable expected)",
    "invalid argument #3 (iterable expected)",
    "invalid argument #4 (iterable expected)",
    "invalid range member '1'"               ,
    "attempt to perform arithmetic on local 'x' (a nil value)",
  }
  assertErrorMsgContains( msg[1], mth, 'mapat', cmatrix(2), nil       )
  assertErrorMsgContains( msg[1], mth, 'mapat', cmatrix(2), ''        )
  assertErrorMsgContains( msg[1], mth, 'mapat', cmatrix(2), 1..2      )
  assertErrorMsgContains( msg[1], mth, 'mapat', cmatrix(2), 1         )
  assertErrorMsgContains( msg[1], mth, 'mapat', cmatrix(2), cmatrix(1) )
  assertErrorMsgContains( msg[1], mth, 'mapat', cmatrix(2), { }       )
  assertErrorMsgContains( msg[2], mth, 'mapat', cmatrix(2), \x x+1  , ''   )
  assertErrorMsgContains( msg[2], mth, 'mapat', cmatrix(2), \x x+1  , nil  )
  assertErrorMsgContains( msg[2], mth, 'mapat', cmatrix(2), \x x+1  , NaN  )
  assertErrorMsgContains( msg[2], mth, 'mapat', cmatrix(2), \x x+1  , \x x )
  assertErrorMsgContains( msg[3], mth, 'mapat', cmatrix(2), \x x+1  , 1    , ''   )
  assertErrorMsgContains( msg[3], mth, 'mapat', cmatrix(2), \x x+1  , 1    , \x x )
  assertErrorMsgContains( msg[4], mth, 'mapat', cmatrix(2), \x x+1  , 1    , 1..2 )
  assertErrorMsgContains( msg[5], mth, 'mapat', cmatrix(2), \x x+1  , 0    )
  assertErrorMsgContains( msg[5], mth, 'mapat', cmatrix(2), \x x+1  , 5    )
  for nr=1,5 do
  for nc=1,5 do
    n = nr*nc
    cm = cmatrix(nr,nc):fill(1..n)
    assertEquals( cm:mapat(\x x  , 1 , cmatrix{1,2}), cmatrix{1,2} )
    assertEquals( cm:mapat(\x x  , 1 , cmatrix{4,5}), cmatrix{1,5} )
    assertEquals( cm:mapat(\x x+1, 1 , {2}), {complex(2,0)} )
    ctref = {} for i=1,n do ctref[i]=complex(i+1,0) end
    assertEquals( cm:mapat(\x x+1, 1..n , {}), ctref )
    if n>1 then
      assertEquals( cm:mapat(\x x+1, {1, 2}, {}), {complex(2,0),complex(3,0)} )
    end
    cmref = cmatrix(nr,nc):fill(1..n):seti(1,complex(2,0))
    assertEquals( cm:mapat(\x x+1, 1     ), cmref )
    cmref = cmatrix(nr,nc):fill(2..n+1)
    assertEquals( cm:mapat(\x x+1, 1..n  ), cmref )
    cmref = cmatrix(nr,nc):fill(1..n):seti(1,complex(2,0)):seti(n,complex(n+1,0))
    assertEquals( cm:mapat(\x x+1, {1, n}), cmref )

    cmref = cmatrix(nr,nc):fill(1..n):seti(1,complex(2,0)):seti(n,complex(n+1,0))
    cm    = cmatrix(nr,nc):fill(1..n):mapat(\x x+1, {1, n}, 'in')
    if n>1 then assertEquals( cm, cmref ) end
    cmref = cmatrix(nr,nc):fill(1..n):seti(1,complex(2,0))
    cm    = cmatrix(nr,nc):fill(1..n):mapat(\x x+1, 1     , 'in')
    assertEquals( cm, cmref )
    cmref = cmatrix(nr,nc):fill(2..n+1)
    cm    = cmatrix(nr,nc):fill(1..n):mapat(\x x+1, 1..n  , 'in')
    assertEquals( cm, cmref )
  end end
--[[
]]
end

-- TODO: check the err , change concept(?)
function TestCMatrix:testFoldl()
  local cm, cmref, ctref
  local msg = {
    "invalid argument #2 (callable expected)"                    ,
    "invalid argument #5 (iterable expected)"                    ,
    "invalid argument #4 (string 'vec', 'row' or 'col' expected)",
    "invalid range member '1'"                                   ,
  }
  cm = cmatrix(2)
  assertErrorMsgContains( msg[1], mth, 'foldl', cmatrix(2), nil  )
  assertErrorMsgContains( msg[1], mth, 'foldl', cmatrix(2), NaN  )
  assertErrorMsgContains( msg[1], mth, 'foldl', cmatrix(2), ''   )
  assertErrorMsgContains( msg[1], mth, 'foldl', cmatrix(2), {}   )
  assertErrorMsgContains( msg[1], mth, 'foldl', cmatrix(2), 1    )
  assertErrorMsgContains( msg[1], mth, 'foldl', cmatrix(2), 1..2 )
  assertErrorMsgContains( msg[1], mth, 'foldl', cmatrix(2), cm   )
  assertErrorMsgContains( msg[3], mth, 'foldl', cmatrix(2), \x x, '')
  assertErrorMsgContains( msg[3], mth, 'foldl', cmatrix(2), \x x, 1 , {}   , {}   )
  assertErrorMsgContains( msg[3], mth, 'foldl', cmatrix(2), \x x, 1 , 1..2 , {}   )
  assertErrorMsgContains( msg[3], mth, 'foldl', cmatrix(2), \x x, 1 , cm   , {}   )
  assertErrorMsgContains( msg[3], mth, 'foldl', cmatrix(2), \x x, 1 , ''   , {}   )
  assertErrorMsgContains( msg[2], mth, 'foldl', cmatrix(2), \x x, 1 , "vec", ''   )
  assertErrorMsgContains( msg[2], mth, 'foldl', cmatrix(2), \x x, 1 , "vec", 1    )
  assertErrorMsgContains( msg[2], mth, 'foldl', cmatrix(2), \x x, 1 , "vec", \x x )
--[[
parameters:
  f: callable, x0: initial value, d: ['vec', 'row', 'col'], r: iterable
  r:{}, cmatrix(2), matrix(2), 1..2

default:
  x0 = x[ 1] or x[., 1] or x[ 1,.] for foldl
       x[#x] or x[.,nc] or x[nr,.] for foldr
   d = 'vec'  (r_ is discarded if any)
   r = scalar ['vec'] or x:same(nr,1) ['row'] or x:same(1,nc) ['col']
]]
  for nr=1,5 do
  for nc=1,5 do
    m = matrix(nr,nc):fill(1..nr*nc)
    --1) x:fold( f )
    assertEquals( m:foldl \x x       , 1          )
    assertEquals( m:foldl \x x+1     , m:geti(#m) )

    --2) x:fold( f, nil, d ) and 2') x:fold( f, d )
    assertEquals( m:foldl(\x x+1     , 'vec'), m:foldl(\x x+1)          )
    assertEquals( m:foldl(\x x+1, nil, 'vec'), m:foldl(\x x+1)          )
    assertEquals( m:foldl(\x x       , 'col'), matrix(1,nc):fill(1..nc) )
    assertEquals( m:foldl(\x x  , nil, 'col'), matrix(1,nc):fill(1..nc) )
    mref = vector(nr)  for i=1,nr do mref:seti( i, m:geti((i-1)*nc+1)) end
    assertEquals( m:foldl(\x x       , 'row'), mref )
    assertEquals( m:foldl(\x x  , nil, 'row'), mref )

    --4) x:fold( f, nil, d, r ) and 4') x:fold( f, d, r) and  4")x:fold( f, d, nil, r )
    tref = {} for i=1,nr do tref[i] = (i-1)*nc+1 end
    assertEquals( m:foldl(\x x  , nil, "row", {}), tref )
    assertEquals( m:foldl(\x x        ,"row", {}), tref )
    assertEquals( m:foldl(\x x  ,"row", nil , {}), tref )
    tref = {} for i=1,nc do tref[i] = i end
    assertEquals( m:foldl(\x x  , nil, "col", {}), tref )
    assertEquals( m:foldl(\x x        ,"col", {}), tref )
    assertEquals( m:foldl(\x x  ,"col", nil , {}), tref )
    assertEquals( m:foldl(\x x+1      ,"vec", {}), nr*nc ) -- not a table -> vector
    assertEquals( m:foldl(\x x+1, nil, "vec", {}), nr*nc ) -- not a table -> vector
    assertEquals( m:foldl(\x x+1,"vec", nil , {}), nr*nc ) -- not a table -> vector

    --5)  x:fold( f, x0 )
    assertEquals( m:foldl(\x x-1  , 0)       ,-nr*nc )

    --6)  x:fold( f, x0 , d )
    assertEquals( m:foldl(\x x-1  , 0, "vec"),-nr*nc )
    mref = matrix(1,nc):fill(-nr)
    assertEquals( m:foldl(\x x-1  , 0, "col"), mref )
    mref = matrix(nr,1):fill(-nc)
    assertEquals( m:foldl(\x x-1  , 0, "row"), mref )

    --8)  x:fold( f, x0 , d, r )
    assertEquals( m:foldl(\x x-1  , 0, "vec", {}),-nr*nc )
    tref = {} for i=1,nc do tref[i] =-nr end
    assertEquals( m:foldl(\x x-1  , 0, "col", {}), tref )
    tref = {} for i=1,nr do tref[i] =-nc end
    assertEquals( m:foldl(\x x-1  , 0, "row", {}), tref )

    --3) x:fold( f, nil, nil, r ) and 3')x:fold( f, r ) and  3")x:fold( f, nil, r)
    --print( m:foldl(\x x-1           , {} ) )                         -- attemt to perform arithetics on table values
    assertEquals( m:foldl(\x x             , {})         , {} )        -- empty tables (x0?)
    assertEquals( m:foldl(\x x-1  ,nil     , {})         , -nr*nc+2 )  -- not a table
    assertEquals( m:foldl(\x x-1  ,nil, nil, {})         , -nr*nc+2 )  -- not a table
    assertEquals( m:foldl(\x x-1  ,nil, nil, matrix(2,2)), -nr*nc+2 )

    --7)  x:fold( f, x0 , nil, r ) and 7') x:fold( f, x0, r )
    assertEquals( m:foldl(\x x-1  , 2, nil, {}), -nr*nc+2 )
    assertEquals( m:foldl(\x x-1  , 2     , {}), -nr*nc+2 )
    assertEquals( m:foldl(\x x-1  , 0, nil, {}), -nr*nc   )
  end end
end

function TestCMatrix:testFoldr()
  local cm, cmref, ctref
  local msg = {
    "invalid argument #2 (callable expected)"                    ,
    "invalid argument #5 (iterable expected)"                    ,
    "invalid argument #4 (string 'vec', 'row' or 'col' expected)",
    "invalid range member '1'"                                   ,
  }
  cm = cmatrix(2)
  assertErrorMsgContains( msg[1], mth, 'foldr', cmatrix(2), nil  )
  assertErrorMsgContains( msg[1], mth, 'foldr', cmatrix(2), NaN  )
  assertErrorMsgContains( msg[1], mth, 'foldr', cmatrix(2), ''   )
  assertErrorMsgContains( msg[1], mth, 'foldr', cmatrix(2), {}   )
  assertErrorMsgContains( msg[1], mth, 'foldr', cmatrix(2), 1    )
  assertErrorMsgContains( msg[1], mth, 'foldr', cmatrix(2), 1..2 )
  assertErrorMsgContains( msg[1], mth, 'foldr', cmatrix(2), cm   )
  assertErrorMsgContains( msg[3], mth, 'foldr', cmatrix(2), \x x, '')
  assertErrorMsgContains( msg[3], mth, 'foldr', cmatrix(2), \x x, 1 , {}   , {}   )
  assertErrorMsgContains( msg[3], mth, 'foldr', cmatrix(2), \x x, 1 , 1..2 , {}   )
  assertErrorMsgContains( msg[3], mth, 'foldr', cmatrix(2), \x x, 1 , cm   , {}   )
  assertErrorMsgContains( msg[3], mth, 'foldr', cmatrix(2), \x x, 1 , ''   , {}   )
  assertErrorMsgContains( msg[2], mth, 'foldr', cmatrix(2), \x x, 1 , "vec", ''   )
  assertErrorMsgContains( msg[2], mth, 'foldr', cmatrix(2), \x x, 1 , "vec", 1    )
  assertErrorMsgContains( msg[2], mth, 'foldr', cmatrix(2), \x x, 1 , "vec", \x x )

--[[
  for nr=1,5 do
  for nc=1,5 do
    m = matrix(nr,nc):fill(1..nr*nc)
    assertEquals( m:foldr(\x x)           , 1 )
    assertEquals( m:foldr(\x x, "vec"    ), 1 )
    assertEquals( m:foldr(\x x, "col"    ), matrix(1,nc):fill(1..nc) )
    mref = vector(nr)  for i=1,nr do        mref:seti( i, m:geti((i-1)*nc+1)) end
    assertEquals( m:foldr(\x x, "row"    ), mref )
    tref = {}          for i=1,nr do        tref[i] = (i-1)*nc+1 end
    assertEquals( m:foldr(\x x, {}       ), tref )
    tref = {}          for i=1,nc do        tref[i] = i end
    assertEquals( m:foldr(\x x, {}, "col"), tref )

    cm = cmatrix(nr,nc):fill(1..nr*nc)
    assertEquals( cm:foldr(\x x)           , complex(1,0) )
    assertEquals( cm:foldr(\x x, "vec"    ), complex(1,0) )
    assertEquals( cm:foldr(\x x, "col"    ), cmatrix(1,nc):fill(1..nc) )
    cmref = vector(nr)  for i=1,nr do        cmref:seti( i, complex(cm:geti((i-1)*nc+1,0))) end
    assertEquals( cm:foldr(\x x, "row"    ), cmref )
    ctref = {}          for i=1,nr do        ctref[i] = complex((i-1)*nc+1,0) end
    assertEquals( cm:foldr(\x x, {}       ), ctref )
    ctref = {}          for i=1,nc do        ctref[i] = complex(i,0) end
    assertEquals( cm:foldr(\x x, {}, "col"), ctref )

    assertTrue  ( is_cmatrix(m :foldr(\x x, cmatrix(nr,1)))  )
    assertTrue  ( is_matrix (cm:foldr(\x x,  matrix(nr,1)))  )
    assertEquals( {m:foldr(\x x, matrix(5)):sizes()} , {5,5} )
    assertEquals( m:foldr(\x x), m:foldl(\x x) )
  end end
  ]]
end

--TODO: adapt smarter way of testing, same as fold
function TestCMatrix:testScanl()
  local cm, cmref
  local msg = {
    "invalid argument #2 (callable expected)"                    ,
    "invalid argument #5 (iterable expected)"                    ,
    "invalid argument #4 (string 'vec', 'row' or 'col' expected)",
    "invalid range member '1'"                                   ,
  }
  cm = cmatrix(2)
  assertErrorMsgContains( msg[1], mth, 'scanl', cmatrix(2), nil  )
  assertErrorMsgContains( msg[1], mth, 'scanl', cmatrix(2), NaN  )
  assertErrorMsgContains( msg[1], mth, 'scanl', cmatrix(2), ''   )
  assertErrorMsgContains( msg[1], mth, 'scanl', cmatrix(2), {}   )
  assertErrorMsgContains( msg[1], mth, 'scanl', cmatrix(2), 1    )
  assertErrorMsgContains( msg[1], mth, 'scanl', cmatrix(2), 1..2 )
  assertErrorMsgContains( msg[1], mth, 'scanl', cmatrix(2), cm   )
  assertErrorMsgContains( msg[3], mth, 'scanl', cmatrix(2), \x x, '')
  assertErrorMsgContains( msg[3], mth, 'scanl', cmatrix(2), \x x, 1 , {}   , {}   )
  assertErrorMsgContains( msg[3], mth, 'scanl', cmatrix(2), \x x, 1 , 1..2 , {}   )
  assertErrorMsgContains( msg[3], mth, 'scanl', cmatrix(2), \x x, 1 , cm   , {}   )
  assertErrorMsgContains( msg[3], mth, 'scanl', cmatrix(2), \x x, 1 , ''   , {}   )
  assertErrorMsgContains( msg[2], mth, 'scanl', cmatrix(2), \x x, 1 , "vec", ''   )
  assertErrorMsgContains( msg[2], mth, 'scanl', cmatrix(2), \x x, 1 , "vec", 1    )
  assertErrorMsgContains( msg[2], mth, 'scanl', cmatrix(2), \x x, 1 , "vec", \x x )

--[[

  for nr=1,5 do
  for nc=1,5 do
    m  =  matrix(nr,nc):fill(1..nr*nc)
    assertEquals( {m:scanl(\x x , "vec"):sizes()}, {nc*nr,1 } )
    assertEquals( {m:scanl(\x x , "row"):sizes()}, {nr   ,nc} )
    assertEquals( {m:scanl(\x x , "col"):sizes()}, {nr   ,nc} )
    assertEquals(  m:scanl(\x x), vector(nr*nc):fill(1) )
    assertEquals(  m:scanl(\x x), m:scanl(\x x, "vec" ) )
    mref = vector(nr)  for i=1,nr do mref:seti( i, m:geti((i-1)*nc+1)) end
    for i=1,nc do assertEquals( m:scanl(\x x, "row"):getcol(i), mref ) end
    mref = matrix(1,nc):fill(1..nc)
    for i=1,nr do assertEquals( m:scanl(\x x, "col"):getrow(i), mref ) end
    tref = {} for i=1,nr do for j=1,nc do  tref[(i-1)*nc+j] = (i-1)*nc+1 end end
    assertEquals( m:scanl(\x x, {}) , tref )

    cm = cmatrix(nr,nc):fill(1..nr*nc)
    assertEquals( {cm:scanl(\x x , "vec"):sizes()}, {nc*nr,1 } )
    assertEquals( {cm:scanl(\x x , "row"):sizes()}, {nr   ,nc} )
    assertEquals( {cm:scanl(\x x , "col"):sizes()}, {nr   ,nc} )
    assertEquals(  cm:scanl(\x x), cvector(nr*nc):fill(1) )
    assertEquals(  cm:scanl(\x x), cm:scanl(\x x, "vec" ) )
    cmref = cvector(nr) for i=1,nr do cmref:seti( i, cm:geti((i-1)*nc+1)) end
    for i=1,nc do assertEquals( cm:scanl(\x x, "row"):getcol(i), cmref )  end
    cmref = cmatrix(1,nc):fill(1..nc)
    for i=1,nr do assertEquals( cm:scanl(\x x, "col"):getrow(i), cmref )  end
    ctref = {} for i=1,nr do for j=1,nc do  ctref[(i-1)*nc+j] = complex((i-1)*nc+1,0) end end
    assertEquals( cm:scanl(\x x, {}) , ctref )

    assertTrue( is_cmatrix(m :scanl(\x x, cmatrix(5))) )
    assertTrue( is_matrix (cm:scanl(\x x,  matrix(5))) )
  end end
  ]]
end

function TestCMatrix:testScanr()
  local msg = {
    "invalid argument #2 (callable expected)"                    ,
    "invalid argument #5 (iterable expected)"                    ,
    "invalid argument #4 (string 'vec', 'row' or 'col' expected)",
    "invalid range member '1'"                                   ,
  }
  cm = cmatrix(2)
  assertErrorMsgContains( msg[1], mth, 'scanr', cmatrix(2), nil  )
  assertErrorMsgContains( msg[1], mth, 'scanr', cmatrix(2), NaN  )
  assertErrorMsgContains( msg[1], mth, 'scanr', cmatrix(2), ''   )
  assertErrorMsgContains( msg[1], mth, 'scanr', cmatrix(2), {}   )
  assertErrorMsgContains( msg[1], mth, 'scanr', cmatrix(2), 1    )
  assertErrorMsgContains( msg[1], mth, 'scanr', cmatrix(2), 1..2 )
  assertErrorMsgContains( msg[1], mth, 'scanr', cmatrix(2), cm   )
  assertErrorMsgContains( msg[3], mth, 'scanr', cmatrix(2), \x x, '')
  assertErrorMsgContains( msg[3], mth, 'scanr', cmatrix(2), \x x, 1 , {}   , {}   )
  assertErrorMsgContains( msg[3], mth, 'scanr', cmatrix(2), \x x, 1 , 1..2 , {}   )
  assertErrorMsgContains( msg[3], mth, 'scanr', cmatrix(2), \x x, 1 , cm   , {}   )
  assertErrorMsgContains( msg[3], mth, 'scanr', cmatrix(2), \x x, 1 , ''   , {}   )
  assertErrorMsgContains( msg[2], mth, 'scanr', cmatrix(2), \x x, 1 , "vec", ''   )
  assertErrorMsgContains( msg[2], mth, 'scanr', cmatrix(2), \x x, 1 , "vec", 1    )
  assertErrorMsgContains( msg[2], mth, 'scanr', cmatrix(2), \x x, 1 , "vec", \x x )
--[[
  for nr=1,5 do
  for nc=1,5 do
    cm = cmatrix(nr,nc):fill(1..nr*nc)
    assertTrue( is_cmatrix(m :scanr(\x x, cmatrix(5))) )
    assertTrue( is_matrix (cm:scanr(\x x,  matrix(5))) )
  end end
  ]]
end

function TestCMatrix:testFilter() --TODO: undertested for now
  local f, cm, cmref
  local msg = {
    "invalid argument #2 (callable expected)",
    "invalid argument #3 (iterable expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'filter', cmatrix(2), nil       )
  assertErrorMsgContains( msg[1], mth, 'filter', cmatrix(2), ''        )
  assertErrorMsgContains( msg[1], mth, 'filter', cmatrix(2), 1..2      )
  assertErrorMsgContains( msg[1], mth, 'filter', cmatrix(2), 1         )
  assertErrorMsgContains( msg[1], mth, 'filter', cmatrix(2), matrix(1) )
  assertErrorMsgContains( msg[1], mth, 'filter', cmatrix(2), { }       )
  assertErrorMsgContains( msg[2], mth, 'filter', cmatrix(2), \x x     , ''   )
  assertErrorMsgContains( msg[2], mth, 'filter', cmatrix(2), \x x     , 1    )
  assertErrorMsgContains( msg[2], mth, 'filter', cmatrix(2), \x x     , \x x )

  for nr=1,5 do
  for nc=1,5 do
    cm = cmatrix(nr,nc):fill(1..nr*nc):fill \x x+x*1i

    f=\x x==1+1i
    assertEquals( cm:filter(f,{}), {1+1i} )
    cmref = cvector(1):seti(1,1+1i)
    assertEquals( cm:filter(f   )          , cmref )
    assertEquals( cm:filter(f, cvector(25)), cmref )
  end end
end

function TestCMatrix:testFilter_out()
  local cm, f
  local msg = {
    "invalid argument #2 (callable expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'filter_out', cmatrix(2), nil        )
  assertErrorMsgContains( msg[1], mth, 'filter_out', cmatrix(2), ''         )
  assertErrorMsgContains( msg[1], mth, 'filter_out', cmatrix(2), 1..2       )
  assertErrorMsgContains( msg[1], mth, 'filter_out', cmatrix(2), 1          )
  assertErrorMsgContains( msg[1], mth, 'filter_out', cmatrix(2), cmatrix(1) )
  assertErrorMsgContains( msg[1], mth, 'filter_out', cmatrix(2), { }        )

  for nr=1,5 do
  for nc=1,5 do
    cm = cmatrix(nr,nc):fill(1..nr*nc):fill \x x+x*1i

    f=\x x<3
    --print( m, "\n" )
    --print( m:filter_out(f), "\n" )
    --print( m:filter(f), "\n" )
  end end
end

-- conversion -----------------------------------------------------------------o

function TestCMatrix:testTosting()
  local tostring in MAD
  local cm, c, r
  for nr=1,5 do
  for nc=1,5 do
    cm = cmatrix(nr,nc):fill(1..nr*nc)
    assertTrue( is_string(tostring(cm      )) )
    assertTrue( is_string(tostring(cm, ''  )) )
    assertTrue( is_string(tostring(cm, "\n")) )

    c, r = {}, {}
    for i=1,nr do for j=1,nc do c[j]=tostring((i-1)*nc+j) end r[i]=table.concat(c,' ')   end
    assertEquals( tostring(cm      ), table.concat(r, '\n') )
    for i=1,nr do for j=1,nc do c[j]=tostring((i-1)*nc+j) end r[i]=table.concat(c)       end
    assertEquals( tostring(cm, ''  ), table.concat(r, '\n') )
    for i=1,nr do for j=1,nc do c[j]=tostring((i-1)*nc+j) end r[i]=table.concat(c, "\n") end
    assertEquals( tostring(cm, '\n'), table.concat(r, '\n') )
  end end
end

function TestCMatrix:testTotable()
  local cm, ctref
  local msg = {
    "invalid argument #2 (table expected)"          ,
    "invalid argument #2 (table of tables expected)",
  }
  assertErrorMsgContains( msg[1], totable, cmatrix(2), ''         )
  assertErrorMsgContains( msg[1], totable, cmatrix(2), 1          )
  assertErrorMsgContains( msg[1], totable, cmatrix(2), true       )
  assertErrorMsgContains( msg[1], totable, cmatrix(2), 1..2       )
  assertErrorMsgContains( msg[1], totable, cmatrix(2), cmatrix(2) )
  assertErrorMsgContains( msg[2], totable, cmatrix(2),  {{},5}    )

  for nr=1,5 do
  for nc=1,5 do
    cm = cmatrix(nr,nc):fill(1..nr*nc)
    ctref = {}, {}
    if  nc ~=1 then
      for i=1,nr do ctref[i]={} for j=1,nc do ctref[i][j]=complex((i-1)*nc+j,0) end end
    else
      for i=1,nr do ctref[i]=complex((i-1)*nc+1,0) end
    end
    assertEquals( totable(cm)         , ctref )
    assertEquals( cmatrix(ctref)      , cm    )
    assertEquals( cmatrix(totable(cm)), cm    )
    assertTrue  ( is_table  (totable(cm)   )  )
    assertTrue  ( is_cmatrix(cmatrix(ctref))  )
  end end
end

-- special maps ---------------------------------------------------------------o

local v   = {
  num = { 1, 2 },
}

local ceil, floor, frac, trunc, round in MAD

function TestCMatrix:testCeil ()
  local m, v, nc, m1
  v = {{0.1, 0.3, 0.4, 0.5, 0.6}}
  m = matrix(v)

  nc = {m:sizes()}
  nc = nc[2]
  m1 = m:ceil()

  local mth  = \f,... f(...)
  local mth2 = \f,s,... s[f](s,...)

 -- for i=1,#v do for j=1,#v[i] do assertEquals( m1:geti((i-1)*nc+j), mth('ceil',v[i][j]) ) end end
end

--[[
function TestCMatrix:testFloor() end
function TestCMatrix:testFrac () end
function TestCMatrix:testTrunc() end
function TestCMatrix:testRound() end

function TestCMatrix:testAbs  () end
function TestCMatrix:testSqrt () end
function TestCMatrix:testExp  () end
function TestCMatrix:testLog  () end
function TestCMatrix:testLog10() end

function TestCMatrix:testSin () end
function TestCMatrix:testCos () end
function TestCMatrix:testTan () end
function TestCMatrix:testSinh() end
function TestCMatrix:testCosh() end
function TestCMatrix:testTanh() end

function TestCMatrix:testAsin () end
function TestCMatrix:testAcos () end
function TestCMatrix:testAtan () end
function TestCMatrix:testAsinh() end
function TestCMatrix:testAcosh() end
function TestCMatrix:testAtanh() end

function TestCMatrix:testErf   () end
function TestCMatrix:testTgamma() end
function TestCMatrix:testLgamma() end

function TestCMatrix:testCarg () end
function TestCMatrix:testReal () end
function TestCMatrix:testImag () end
function TestCMatrix:testConj () end
function TestCMatrix:testProj () end
function TestCMatrix:testRect () end
function TestCMatrix:testPolar() end
]]

-- special folds --------------------------------------------------------------o

function TestCMatrix:testSum() --TODO: check tables?
  local x, cm, cmref, ctref
  for nr=1,5 do
  for nc=1,5 do
    cm   = cmatrix(nr,nc):fill(1..nr*nc):fill \x x+x*1i
    cmref = 0 for i=1,nr*nc do cmref = complex(i,i)+cmref end
    assertEquals( cm:sum()     , cmref )
    cmref = cvector(nr)   for i=1,nr do x=0 for j=1,nc do x=complex((i-1)*nc+j,(i-1)*nc+j)+x end cmref:seti(i, x) end
    assertEquals( cm:sum("row"), cmref )
    cmref = cmatrix(1,nc) for i=1,nc do x=0 for j=1,nr do x=complex((j-1)*nc+i,(j-1)*nc+i)+x end cmref:seti(i, x) end
    assertEquals( cm:sum("col"), cmref )
    ctref = {}            for i=1,nr do x=0 for j=1,nc do x=complex((i-1)*nc+j,(i-1)*nc+j)+x end ctref[i] = x     end
 --   assertEquals( cm:sum({}   ),  ctref )
  end end
end

function TestCMatrix:testSumabs()
  local  x, cm, cmref, c
  for nr=1,5 do
  for nc=1,5 do
    cm    = cmatrix(nr,nc):fill(1..nr*nc):fill \x x+x*1i
    cmref = 0 for i=1,nr*nc do cmref = abs(complex(i,i))+cmref end
    assertEquals( cm:sumabs()     , cmref )
    assertEquals( cm:sumabs('vec'), cmref )
    cmref = cmatrix(1,nc) for j=1,nc do c=0; for i=1,nr do x=(i-1)*nc+j; c=abs(complex(x,x))+c end cmref:seti(j,c) end
    assertEquals( cm:sumabs('col'), cmref, "\n" )
    cmref = cvector(nr)   for i=1,nr do c=0; for j=1,nc do x=(i-1)*nc+j; c=abs(complex(x,x))+c end cmref:seti(i,c) end
    assertEquals( cm:sumabs('row'), cmref )
  end end
end

function TestCMatrix:testSumsqr()
  local x, cm, cmref
  for nr=1,5 do
  for nc=1,5 do
    cm    = cmatrix(nr,nc):fill(1..nr*nc):fill \x x+x*1i
    cmref = 0 for i=1,nr*nc do cmref = complex(i,i)*complex(i,i)+cmref end
    assertEquals( cm:sumsqr()     , cmref )
    assertEquals( cm:sumsqr('vec'), cmref )
    cmref = cmatrix(1,nc) for j=1,nc do c=0; for i=1,nr do x=(i-1)*nc+j; c=complex(x,x)*complex(x,x)+c end cmref:seti(j,c) end
    assertEquals( cm:sumsqr('col'), cmref, "\n" )
    cmref = cvector(nr)   for i=1,nr do c=0; for j=1,nc do x=(i-1)*nc+j; c=complex(x,x)*complex(x,x)+c end cmref:seti(i,c) end
    assertEquals( cm:sumsqr('row'), cmref )
  end end
end

function TestCMatrix:testProduct()
  local x, cm, cmref
  for nr=1,5 do
  for nc=1,5 do
    cm    = cmatrix(nr,nc):fill(1..nr*nc):fill \x x+x*1i
    cmref = 1 for i=1,nr*nc do cmref = complex(i,i)*cmref end
    assertEquals( cm:product()     , cmref )
    assertEquals( cm:product('vec'), cmref )
    cmref = cmatrix(1,nc) for j=1,nc do c=1; for i=1,nr do x=(i-1)*nc+j; c=complex(x,x)*c end cmref:seti(j,c) end
    assertEquals( cm:product('col'), cmref, "\n" )
    cmref = cvector(nr)   for i=1,nr do c=1; for j=1,nc do x=(i-1)*nc+j; c=complex(x,x)*c end cmref:seti(i,c) end
    assertEquals( cm:product('row'), cmref )

    if not (nr==5 and nc==5) then
      cm    = matrix(nr,nc):fill(nr*nc..1..-1 ):fill \x x+x*1i
      cmref = 1 for i=nr*nc,1,-1 do cmref=complex(i,i)*cmref end
      cmref = 1 for i=1,#cm do cmref=cm:geti(i)*cmref end
      assertEquals( cm:product(), cmref )
    end
  end end
end

function TestCMatrix:testAll()
  local cm, cmref
  local msg = {
    "invalid argument #2 (callable expected)",
    "cannot convert 'bool' to 'complex'"     ,
  }
  assertErrorMsgContains( msg[1], mth, 'all', cmatrix(2), nil        )
  assertErrorMsgContains( msg[1], mth, 'all', cmatrix(2), ''         )
  assertErrorMsgContains( msg[1], mth, 'all', cmatrix(2), 1..2       )
  assertErrorMsgContains( msg[1], mth, 'all', cmatrix(2), 1          )
  assertErrorMsgContains( msg[1], mth, 'all', cmatrix(2), cmatrix(1) )
  assertErrorMsgContains( msg[1], mth, 'all', cmatrix(2), { }        )
  assertErrorMsgContains( msg[2], mth, 'all', cmatrix(2), \x x==complex(1,1), 'row')
  assertErrorMsgContains( msg[2], mth, 'all', cmatrix(2), \x x==complex(1,1), 'col')

  for nr=1,5 do
  for nc=1,5 do
    cm = cmatrix(nr,nc):fill(1..nr*nc ):fill \x x+x*1i
    assertTrue  ( cmatrix(nr,nc):fill(complex(1,0)):all \x x==complex(1,0) )
    assertFalse ( cm:all \x x==complex(2,2))
    assertEquals( cm:all \x x==complex(2,2), cm:all( \x x==complex(2,2),'vec') )
  end end
end

function TestCMatrix:testAny()
  local cm, cmref
  local msg = {
    "invalid argument #2 (callable expected)",
    "cannot convert 'bool' to 'complex'"     ,
  }
  assertErrorMsgContains( msg[1], mth, 'any', cmatrix(2), nil        )
  assertErrorMsgContains( msg[1], mth, 'any', cmatrix(2), ''         )
  assertErrorMsgContains( msg[1], mth, 'any', cmatrix(2), 1..2       )
  assertErrorMsgContains( msg[1], mth, 'any', cmatrix(2), 1          )
  assertErrorMsgContains( msg[1], mth, 'any', cmatrix(2), cmatrix(1) )
  assertErrorMsgContains( msg[1], mth, 'any', cmatrix(2), { }        )
  assertErrorMsgContains( msg[2], mth, 'any', cmatrix(2), \x x==complex(1,1), 'row')
  assertErrorMsgContains( msg[2], mth, 'any', cmatrix(2), \x x==complex(1,1), 'col')

  for nr=1,5 do
  for nc=1,5 do
    cm = cmatrix(nr,nc):fill(1..nr*nc ):fill \x x+x*1i
    assertTrue  ( cm:any \x x==complex(1,1))
    assertFalse ( cm:any \x x==complex(1,0))
    assertEquals( cm:any \x x==complex(1,1), cm:any( \x x==complex(1,1),'vec') )

    --print( cm:any( \x x==complex(1,1), 'col') )
    --print( cm:any( \x x==complex(1,1), 'row') )
  end end
end

-- special scans --------------------------------------------------------------o
--[[
function TestCMatrix:testAccmin   () end
function TestCMatrix:testAccmax   () end
function TestCMatrix:testAccsum   () end
function TestCMatrix:testAccsumabs() end
function TestCMatrix:testAccsumsqr() end
function TestCMatrix:testAccprod  () end

function TestCMatrix:testAccsum() end

function TestCMatrix:testRaccmin   () end
function TestCMatrix:testRaccmax   () end
function TestCMatrix:testRaccsum   () end
function TestCMatrix:testRaccsumabs() end
function TestCMatrix:testRaccsumsqr() end
function TestCMatrix:testRaccprod  () end
]]

-- conjugate, transpose -------------------------------------------------------o

function TestCMatrix:testConjugate()
local cm
  for nr=1,5 do
  for nc=1,5 do
    cm = cmatrix(nr,nc):fill(1..nr*nc):fill \x x+x*1i
    assertEquals( cm:conj(), cmatrix(nr,nc):fill(1..nr*nc):fill \x  x-x*1i )
    cm = cmatrix(nr,nc):fill(-1..-nr*nc..-1):fill \x x+x*1i
    assertEquals( cm:conj(), cmatrix(nr,nc):fill(1..nr*nc):fill \x -x+x*1i )
  end end
end

function TestCMatrix:testTranspose()
  local cm1, cm2
  for nr=1,5 do
  for nc=1,5 do
    cm1 = cmatrix(nr,nc):fill(1..nr*nc ):fill \x x+x*1i
    cm2 = cmatrix(nr,nc):fill(1..nr*nc )
    assertEquals( {cm1:t():sizes()}     , {nc,nr}         )
    assertEquals(  cm1:t() :t()         , cm1             )
    assertEquals( (cm1+cm2):t()         , cm1:t()+cm2:t() )
    assertEquals( (2*cm2)  :t()         , 2*cm2:t()       )
    assertEquals(  cm1:t(false):t(false), cm1                       )
    assertEquals( (cm1+cm2):t(false)    , cm1:t(false)+cm2:t(false) )
    assertEquals( (2*cm2)  :t(false)    , 2*cm2:t(false)            )

    if nr == nc then
      assertEquals( (cm1*cm2):t(), cm1:t()*cm2:t() )
      cm1:t('in')                                       -- only if nr==nc (size)
      assertEquals( cm1, cmatrix(nr,nc):fill(1..nr*nc):fill \x x+x*1i :t() )
      cm1:t('in', false)
      assertEquals( cm1, cmatrix(nr,nc):fill(1..nr*nc):fill \x x-x*1i      )
      for i=1,nr do for j=1,nc do                      -- symmetric matrix test
        if i>j then cm1:set(i,j, cm1:get(j,i)) end
      end end
      assertEquals(  cm1:t():conj(), cm1 )
    end
  end end
end

function TestCMatrix:testTrace()
  local cm, cx
  for nr=1,5 do
  for nc=1,5 do
    cm = cmatrix(nr,nc):fill(1..nr*nc):fill \x x+x*1i
    cx = 0
    if nr==nc then
      for i=1,nr do for j=1,nc do
        if i==j then cx = cm:get(i,j) + cx end
      end end
      assertEquals( cm:tr(), cx )
    end
  end end
end

-- symplectic matrix ----------------------------------------------------------o

--[[
--need to create a symplectic matrix set and then work on it thorugh below test

function TestCMatrix:testSympinv()
  local msg = {
   "invalid argument #1 (2n matrix expected)",
  }
end

function TestCMatrix:testSymperr()
  local msg = {
    "invalid argument #1 (2n matrix expected)",
    "invalid argument #2 (different matrix expected)",
  }
end
]]

-- inner, cross, mixed, outer -------------------------------------------------o

function TestCMatrix:testInner()
  local cm1, cm2, m
  local msg = {
    "invalid argument #2 (matrix expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'inner', cmatrix(2), nil  )
  assertErrorMsgContains( msg[1], mth, 'inner', cmatrix(2), ''   )
  assertErrorMsgContains( msg[1], mth, 'inner', cmatrix(2), 1    )
  assertErrorMsgContains( msg[1], mth, 'inner', cmatrix(2), 1..2 )
  assertErrorMsgContains( msg[1], mth, 'inner', cmatrix(2), {}   )

  for nr=1,5 do
  for nc=1,5 do
    cm1 = cmatrix(nr,nc):fill(1..nr*nc)
    cm2 = cmatrix(nr,nc):fill(1..nr*nc)
    m   =  matrix(nr,nc):fill(1..nr*nc)
    assertEquals( cm1:inner(cm2), (cm1:t()*cm2):tr() )
    assertEquals( cm1:inner(m)  , (cm1:t()*m  ):tr() )
  end end
end

function TestCMatrix:testCross() --TODO: different size of second matrix tests
 --cross prod:  uxv = |u|.|v| sin(u^v) \vec{n}
  local m1, m2, m3, cm1, cm2, cm3
  local msg = {
    "invalid argument #2 (matrix expected)",
    "invalid matrix sizes"                 ,
  }
  assertErrorMsgContains( msg[1], mth, 'cross', cmatrix(3), nil  )
  assertErrorMsgContains( msg[1], mth, 'cross', cmatrix(3), ''   )
  assertErrorMsgContains( msg[1], mth, 'cross', cmatrix(3), 1    )
  assertErrorMsgContains( msg[1], mth, 'cross', cmatrix(3), 1..2 )
  assertErrorMsgContains( msg[1], mth, 'cross', cmatrix(3), {}   )
  assertErrorMsgContains( msg[2], mth, 'cross', cmatrix(2), cmatrix(3) )
  -- generalize
  m1 = vector {1,2,3}
  m2 = vector {3,2,1}
  m3 = matrix(3) -- skew-symmetric matrix
     :seti( 4, m1:geti(3)) :seti( 2,-m1:geti(3))
     :seti( 3, m1:geti(2)) :seti( 7,-m1:geti(2))
     :seti( 8, m1:geti(1)) :seti( 6,-m1:geti(1))
  assertEquals( m1:cross(m2), m3*m2 )
  m1:cross(m2, 'in')
  assertEquals( m1, m3*m2 )

  m1 = matrix(3,2):fill(1..3*2)
  m1:cross( matrix(3,2):fill(1), 'in')
  assertEquals( m1, matrix(3,2):fill(1..3*2):cross( matrix(3,2):fill(1)) )

  --print(matrix(3):fill(1..9):cross(matrix(2,1)))

  for nc=1,5 do
    assertEquals(  matrix(3,nc):fill(1..3*nc):cross( matrix(3,nc):fill(1..3*nc)), matrix(3,nc) )
    assertEquals(  matrix(3,nc):fill(1..3*nc):cross(cmatrix(3,nc):fill(1..3*nc)), matrix(3,nc) )
    assertEquals( cmatrix(3,nc):fill(1..3*nc):cross( matrix(3,nc):fill(1..3*nc)), matrix(3,nc) )
    assertEquals( cmatrix(3,nc):fill(1..3*nc):cross(cmatrix(3,nc):fill(1..3*nc)), matrix(3,nc) )
    assertEquals(  matrix(3,nc)              :cross( matrix(3,nc):fill(1..3*nc)), matrix(3,nc) )
    assertEquals(  matrix(3,nc)              :cross( matrix(3,nc))              , matrix(3,nc) )
    assertEquals(  matrix(3,nc)              :cross(cmatrix(3,nc):fill(1..3*nc)), matrix(3,nc) )

    m1  =  matrix(3,nc):fill(1..3*nc)
    m2  =  matrix(3,nc):fill(3*nc..1..-1)
    m3  =  matrix(3,nc):fill(3*nc..1..-1)
    cm1 = cmatrix(3,nc):fill(1..3*nc)
    cm2 = cmatrix(3,nc):fill(3*nc..1..-1)
    cm3 = cmatrix(3,nc):fill(3*nc..1..-1)
    assertEquals( m1 :cross( m2)  ,-m2  :cross( m1)              )
    assertEquals( cm1:cross( m2)  ,-m2  :cross(cm1)              )
    assertEquals( cm1:cross(cm2)  ,-cm2 :cross(cm1)              )
    assertEquals( m1 :cross(m2+m3), m1  :cross( m2)+m1:cross(m3) )
    assertEquals( (2*m1):cross(m2), m1  :cross( m2*2)            )
    assertEquals( (2*m1):cross(m2), 2*m1:cross( m2)              )
    assertEquals( (2*m1):cross(m2), 2*m1:cross( m2)              )
    --assertEquals( m1:cross(m2:cross(m3)) , m2*(m1*m3)-m3*(m1*m2)  ) -- fin after multiplication tests
  end
end

function TestCMatrix:testMixed() --TODO: 'in', r_ + r_ err
  -- mixed prod:  (uxv)'.w = u'.(vxw) = det(u,v,w)
  local m1, m2, m3
  local msg = {
    "invalid argument #2 (matrix expected)",
    "invalid argument #3 (matrix expected)",
    "invalid matrix sizes"                 ,
    "incompatible matrix sizes"            ,
  }
  m1 = matrix(3,1)
  assertErrorMsgContains( msg[1], mth, 'mixed', m1, nil  )
  assertErrorMsgContains( msg[1], mth, 'mixed', m1, ''   )
  assertErrorMsgContains( msg[1], mth, 'mixed', m1, 1    )
  assertErrorMsgContains( msg[1], mth, 'mixed', m1, 1..2 )
  assertErrorMsgContains( msg[1], mth, 'mixed', m1, {}   )
  assertErrorMsgContains( msg[2], mth, 'mixed', m1, m1  , nil  )
  assertErrorMsgContains( msg[2], mth, 'mixed', m1, m1  , ''   )
  assertErrorMsgContains( msg[2], mth, 'mixed', m1, m1  , 1    )
  assertErrorMsgContains( msg[2], mth, 'mixed', m1, m1  , 1..2 )
  assertErrorMsgContains( msg[2], mth, 'mixed', m1, m1  , {}   )
  assertErrorMsgContains( msg[3], mth, 'mixed', matrix(2,1), m1, m1 )
  assertErrorMsgContains( msg[4], mth, 'mixed', matrix(3,2), m1, m1 )
  assertErrorMsgContains( msg[4], mth, 'mixed', m1, matrix(2,1), m1 )
  assertErrorMsgContains( msg[4], mth, 'mixed', m1, matrix(3,2), m1 )
  assertErrorMsgContains( msg[4], mth, 'mixed', m1, m1 ,matrix(2,1) )
  assertErrorMsgContains( msg[4], mth, 'mixed', m1, m1 ,matrix(3,2) )
-- x.nr==3, y.nr==x.nr, z.nr==x.nr, y.nc==x.nc, z.nc==x.nc

  for nc=1,5 do
    m1 = matrix(3,nc):fill(1..nc*6..2)
    m2 = matrix(3,nc):fill(3*nc..1..-1)
    m3 = matrix(3,nc):fill(1..3*nc)
    -- vector vs number after inner
    --print( m1:mixed( m2, m3)     , "\n" )
    --print( m1:cross(m2):inner(m3), "\n" )
    --assertEquals( m1:mixed( m2, m3), m1:cross(m2):inner(m3) )
  end
end

function TestCMatrix:testOuter()
  -- x * y:t() without temporary --  outer prod:  u.v' = matrix
  local m1, m2, cm1, cm2
  local msg = {
    "invalid argument #2 (matrix expected)",
    "incompatible matrix sizes",
  }
  assertErrorMsgContains( msg[1], mth, 'outer', cmatrix(2,1), nil  )
  assertErrorMsgContains( msg[1], mth, 'outer', cmatrix(2,1), ''   )
  assertErrorMsgContains( msg[1], mth, 'outer', cmatrix(2,1), {}   )
  assertErrorMsgContains( msg[1], mth, 'outer', cmatrix(2,1), 1    )
  assertErrorMsgContains( msg[1], mth, 'outer', cmatrix(2,1), 1..2 )
  assertErrorMsgContains( msg[2], mth, 'outer', cmatrix(1,2), cmatrix(2,2) )
  assertErrorMsgContains( msg[2], mth, 'outer', cmatrix(2,2), cmatrix(1,2) )

  for nr=1,5 do
    m1  =  matrix(nr,1):fill(1..2*nr..2)
    m2  =  matrix(nr,1):fill(1..nr)
    cm1 = cmatrix(nr,1):fill(1..2*nr..2):fill \x x+x*1i
    cm2 = cmatrix(nr,1):fill(1..nr):fill \x x+x*1i
    assertEquals( cm1:outer(cm2), cm1*cm2:t() )
    assertEquals( cm1:outer( m2), cm1* m2:t() )

    if nr==1 then            -- size issue, can not be used with anything bigger
      cm1:outer(cm2, 'in')
      assertEquals( cm1, cmatrix(nr,1):fill(1..2*nr..2):fill(\x x+x*1i) *cm2:t() )
    end
  end
end

-- norm, unit, center, angle (in place) ---------------------------------------o

function TestCMatrix:testNorm()
  local cm
  for nr=1,5 do
  for nc=1,5 do
    cm = cmatrix(nr,nc):fill(1..nr*nc)
    if nr == 1 then
      assertEquals( complex(cm:norm(),0), (cm*cm:t()):sqrt():geti(1) )
    end
  end end
end

function TestCMatrix:testDistance()
  local msg, cm = {
    "invalid argument #2 (cmatrix expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'distance', cmatrix(2), nil  )
  assertErrorMsgContains( msg[1], mth, 'distance', cmatrix(2), 1..2 )
  assertErrorMsgContains( msg[1], mth, 'distance', cmatrix(2), ''   )
  assertErrorMsgContains( msg[1], mth, 'distance', cmatrix(2), {}   )
  --assertErrorMsgContains( msg[1], mth, 'distance', cmatrix(2), cmatrix(1) )

  for nr=1,5 do
  for nc=1,5 do
    cm = cmatrix(nr,nc):fill(1..nr*nc)
  end end
end

--[[
function TestCMatrix:testUnit()
  local msg = {
    "null matrix norm",
  }
end

function TestCMatrix:testCenter() end

function TestCMatrix:testAngle()
  local msg = {
    "null vector norm",
  }
end

-- operators ------------------------------------------------------------------o

function TestCMatrix:testEq() end

function TestCMatrix:testAddCPx() end
function TestCMatrix:testAdd()
  local msg = {
    "invalid arguments (unsupported matrix operation)",
  }
end

function TestCMatrix:testSubCPx() end
function TestCMatrix:testSub()
  local msg = {
    "invalid arguments (unsupported matrix operation)",
  }
end

function TestCMatrix:testMulCPx() end
function TestCMatrix:testMul()
  local msg = {
    "invalid arguments (unsupported matrix operation)",
  }
end

function TestCMatrix:testTmul()
  local msg = {
    "invalid arguments (unsupported matrix operation)",
  }
end

function TestCMatrix:testDivCPx() end

function TestCMatrix:testDiv()
  local msg = {
    "invalid arguments (unsupported matrix operation)",
  }
end

function TestCMatrix:testEmul()
  local msg = {
    "invalid argument #2 (matrix expected)",
  }
end

function TestCMatrix:testEdiv()
  local msg = {
    "invalid argument #2 (matrix expected)",
  }
end

-- linear algebra -------------------------------------------------------------o

function TestCMatrix:testSolve() end
function TestCMatrix:testSvd() end

function TestCMatrix:testEigen()
  local msg = {
    "matrix must be square",
  }
end

-- FFT, convolution, correlation, covrariance ---------------------------------o

function TestCMatrix:testFft() end
function TestCMatrix:testIfft() end

function TestCMatrix:testRfft()
  local msg = {
    "incompatible matrix sizes",
  }
end

function TestCMatrix:testIrfft()
  local msg = {
    "result matrix must be real",
    "incompatible matrix sizes" ,
  }
end

 -- convolution theorem
function TestCMatrix:testConv() end

 -- correlation theorem
function TestCMatrix:testCorr() end
function TestCMatrix:testCovar() end

-- concatenation --------------------------------------------------------------o

function TestCMatrix:testConcat()
  local msg = {
    "invalid argument #1 (matrix expected)"               ,
    "invalid argument #2 (matrix expected)"               ,
    "incompatible matrix sizes"                           ,
    "invalid argument #3 (string 'row' or 'col' expected)",
  }
end
]]
-- end ------------------------------------------------------------------------o
