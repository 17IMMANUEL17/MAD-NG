--[=[
 o-----------------------------------------------------------------------------o
 |
 | Complex module regression tests
 |
 | Methodical Accelerator Design - Copyright CERN 2015+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 |          A.Z. Teska, aleksandra.teska at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide regression test suites for the complex module.

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o
local assertEquals, assertAlmostEquals, assertTrue, assertFalse,
      assertErrorMsgContains, assertNil, assertNaN, assertIsString, assertInf
      in require 'luaunit'

local complex, infi, InfI, tiny, eps, huge, inf, nan, pi, Pi, is_complex,
      cos, sin,
      is_function in MAD

-- regression test suite ------------------------------------------------------o

TestComplex = {}

local values = {
  num  = {0, tiny, 2^-64, 2^-63, 2^-53, eps, 2^-52, 2*eps, 2^-32, 2^-31, 1e-9,
          0.1-eps, 0.1, 0.1+eps, 0.5, 0.7-eps, 0.7, 0.7+eps, 1-eps, 1, 1+eps,
          1.1, 1.7, 2, 10, 1e2, 1e3, 1e6, 1e9, 2^31, 2^32, 2^52, 2^53,
          2^63, 2^64, huge, inf},
  rad  = {0, eps, 2*eps, pi/180, pi/90, pi/36, pi/18, pi/12, pi/6, pi/4, pi/3, pi/2,
          pi-pi/3, pi-pi/4, pi-pi/6, pi-pi/12, pi},
  rad2 = {0, eps, 2*eps, pi/180, pi/90, pi/36, pi/18, pi/12, pi/6, pi/4, pi/3, pi/2},

  deg  = {0, eps, 2*eps, 1, 2, 5, 10, 15, 30, 45, 60, 90,
          120, 135, 150, 165, 180},
  deg2 = {0, eps, 2*eps, 1, 2, 5, 10, 15, 30, 45, 60, 90},
  unit = {},
}

local function unitCircle (r, n, val)
  local deg
  local z = {}
  if val ~= nil then
    for i,deg in ipairs(val) do
      z[i] = complex( r*cos( deg ), r*sin( deg ) )
    end
  else
    for i = 0,2*n do
      deg  = 2*pi*(i-1)/n
      z[i] = complex( r*cos( deg ), r*sin( deg ) )
    end
  end
  return z
end

function TestComplex:testUnitC()
  local z = {}
  z = unitCircle( 1, 2 )
  z = unitCircle( 1, 2, values.deg)
  --for i = 1,#z do print(z[i]) end
end

function TestComplex:testCtor()
  local msg = {
  "cannot convert 'string' to 'complex'",
  "cannot convert 'nil' to 'complex'"   ,
  "cannot convert 'string' to 'double'" ,
  "cannot convert 'nil' to 'double'"    ,
  }
  assertErrorMsgContains( msg[1], complex, ''  )
  assertErrorMsgContains( msg[2], complex, nil )
  assertErrorMsgContains( msg[3], complex, '' , ''  )
  assertErrorMsgContains( msg[3], complex, 1  , ''  )
  assertErrorMsgContains( msg[3], complex, '' , 1   )
  assertErrorMsgContains( msg[4], complex, nil, 1   )
  assertErrorMsgContains( msg[4], complex, 1  , nil )
  assertEquals( complex(0, 1),  1i )
  assertEquals( complex(0,-1), -1i )

  for _,v in ipairs(values.num) do
    assertTrue( is_complex( complex( 0, v) ) )
    assertTrue( is_complex( complex( 0,-v) ) )
    assertTrue( is_complex( complex(-v, 0) ) )
    assertTrue( is_complex( complex( v, 0) ) )
    assertTrue( is_complex( complex( v, v) ) )
    assertTrue( is_complex( complex(-v,-v) ) )
  end
end

function TestComplex:testCtorFields()
  assertNaN   ( complex(nan).re       )
  assertNaN   ( complex(nan, nan).re  )
  assertEquals( complex(1).re   ,   1 )
  assertEquals( complex(1).im   ,   0 )
  assertEquals( complex(0,1).re ,   0 )
  assertEquals( complex(0,1).im ,   1 )
  for _,v in ipairs(values.num) do
    assertEquals( complex( 0, v).re,  0 )
    assertEquals( complex( 0,-v).re,  0 )
    assertEquals( complex(-v, 0).re, -v )
    assertEquals( complex( v, 0).re,  v )
    assertEquals( complex( v, v).re,  v )
    assertEquals( complex(-v,-v).re, -v )

    assertEquals( complex( 0, v).im,  v )
    assertEquals( complex( 0,-v).im, -v )
    assertEquals( complex(-v, 0).im,  0 )
    assertEquals( complex( v, 0).im,  0 )
    assertEquals( complex( v, v).im,  v )
    assertEquals( complex(-v,-v).im, -v )
  end
end

-- generic functions

--[[
function TestComplex:testAngle() end

function TestComplex:testAbs() end
function TestComplex:testCeil() end
function TestComplex:testFloor() end
function TestComplex:testFrac() end
function TestComplex:testTrunc() end
function TestComplex:testRound() end

function TestComplex:testSqrt()
  assertEquals( complex(0,0):sqrt(), complex(0,0) )
  assertEquals( complex(0,2):sqrt(), complex(1,1) )
  assertEquals( complex(1,0):sqrt(), complex(1,0) )
end

function TestComplex:testExp()
  assertEquals( complex(0,0):exp(), complex(1,0) )
end

function TestComplex:testLog()
  assertEquals( complex( 1, 0):log(), complex( 0  , 0 ) )
  assertEquals( complex( 0, 0):log(), complex(-inf, 0 ) )
  assertEquals( complex(-1, 0):log(), complex( 0  , pi) )
  assertEquals( complex( 0, 1):log(), complex( 0  , 1.0/2 * pi) )
  assertEquals( complex( 0,-1):log(), complex( 0  ,-1.0/2 * pi) )
end

function TestComplex:testlog10() end

function TestComplex:testSin()
  assertEquals( complex(0,0):sin(), complex(0,0) )
end
function TestComplex:testCos()
  assertEquals( complex(0,0):cos(), complex(1,0) )
end
function TestComplex:testTan()
  assertEquals( complex(0,0):tan(), complex(0,0) )
end
function TestComplex:testSinh()
  assertEquals( complex(0,0):sinh(), complex(0,0) )
end
function TestComplex:testCosh()
  assertEquals( complex(0,0):cosh(), complex(1,0) )
end
function TestComplex:testTanh()
  assertEquals( complex(0,0):tanh(), complex(0,0) )
end

function TestComplex:testAsin()
  assertEquals( complex( 0, 0):asin(), complex( 0       ,0) )
  assertEquals( complex( 1, 0):asin(), complex( 1/2 * pi,0) )
  assertEquals( complex(-1, 0):asin(), complex(-1/2 * pi,0) )
end

function TestComplex:testAcos()
  assertEquals( complex( 1, 0):acos(), complex( 0 , 0) )
  assertEquals( complex(-1, 0):acos(), complex( pi, 0) )
  assertEquals( complex( 0, 0):acos(), complex( 1/2 * pi,0) )
end
function TestComplex:testAtan()
  --assertEquals( complex(0,0)   :atan(), nan )
  --assertEquals( complex(0,1)   :atan(), nan )
  --assertEquals( complex(0,-1)  :atan(), nan )

  assertEquals( complex( 0  , 0):atan(), complex( 0, 0  )  )
  assertEquals( complex( 0  , 1):atan(), complex( 0, inf)  )
  assertEquals( complex( 0  ,-1):atan(), complex( 0,-inf)  )
  assertEquals( complex( inf, 0):atan(), complex( 1/2*pi, 0) )
  assertEquals( complex(-inf, 0):atan(), complex(-1/2*pi, 0) )
end
function TestComplex:testAsinh()
  assertEquals( complex(0,0):asinh(), complex(0,0) )
end
function TestComplex:testAcosh() end
function TestComplex:testAtanh()
  assertEquals( complex(0,0):atanh(), complex(0,0) )
  --assertEquals( complex(0,0) :atanh(), nan )
  --assertEquals( complex(0,1) :atanh(), nan )
  --assertEquals( complex(0,-1):atanh(), nan )
end

function TestComplex:testErf() end
function TestComplex:testTgamma() end
function TestComplex:testLgamma() end

-- complex generic functions

function TestComplex:testCarg() end
function TestComplex:testReal() end
function TestComplex:testImag() end
function TestComplex:testConj() end
function TestComplex:testNorm() end
function TestComplex:testUnit() end
function TestComplex:testProj()
  assertEquals( complex( 1  , 2  ):proj(), complex( 1  , 2) )
  assertEquals( complex( inf,-1  ):proj(), complex( inf, 0) )
  assertEquals( complex( 0  ,-inf):proj(), complex( inf, 0) )
end
function TestComplex:testRect() end
function TestComplex:testPolar() end

function TestComplex:testUnm() end
function TestComplex:testAdd() end
function TestComplex:testSub() end
function TestComplex:testMul() end
function TestComplex:testDiv() end
function TestComplex:testMod() end

function TestComplex:testPow() end
function TestComplex:testEqual() end
]]


-- end ------------------------------------------------------------------------o