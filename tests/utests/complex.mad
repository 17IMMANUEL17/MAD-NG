--[=[
 o-----------------------------------------------------------------------------o
 |
 | Complex module regression tests
 |
 | Methodical Accelerator Design - Copyright CERN 2015+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 |          A.Z. Teska, aleksandra.teska at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide regression test suites for the complex module.

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o
local assertEquals, assertAlmostEquals, assertTrue, assertFalse,
      assertErrorMsgContains, assertNil, assertNaN, assertIsString, assertInf
      in require 'luaunit'

local complex, infi, InfI, tiny, eps, huge, inf, nan, pi, Pi, sqrt, cos, sin,
      tan, cosh, sinh, tanh, asinh, atanh, asin, atan, atan2, exp, log, frac,
      trunc, round, hypot, floor, abs, is_complex, is_function, is_table,
      _C in MAD

-- regression test suite ------------------------------------------------------o

TestComplex = {}

local values = {
  num  = {0, tiny, 2^-64, 2^-63, 2^-53, eps, 2^-52, 2*eps, 2^-32, 2^-31, 1e-9,
          0.1-eps, 0.1, 0.1+eps, 0.5, 0.7-eps, 0.7, 0.7+eps, 1-eps, 1, 1+eps,
          1.1, 1.7, 2, 10, 1e2, 1e3, 1e6, 1e9, 2^31, 2^32, 2^52, 2^53,
          2^63, 2^64, huge},
  rad  = {0, eps, 2*eps, pi/180, pi/90, pi/36, pi/18, pi/12, pi/6, pi/4, pi/3, pi/2,
          pi-pi/3, pi-pi/4, pi-pi/6, pi-pi/12, pi},
  rad2 = {0, eps, 2*eps, pi/180, pi/90, pi/36, pi/18, pi/12, pi/6, pi/4, pi/3, pi/2},
}

local function unitCircle (r, n)
  local rad
  local z = {}
  if is_table(n) then
    for i,rad in ipairs(n) do
      z[i] = complex( r*cos( rad ), r*sin( rad ) )
    end
  else
    for i = 0, 2*n do
      rad  = 2*pi*(i-1)/n
      z[i] = complex( r*cos( rad ), r*sin( rad ) )
    end
  end
  return z
end

function TestComplex:testCtor()
  local msg, c = {
  "cannot convert 'string' to 'complex'",
  "cannot convert 'nil' to 'complex'"   ,
  "cannot convert 'string' to 'double'" ,
  "cannot convert 'nil' to 'double'"    ,
  }
  assertErrorMsgContains( msg[1], complex, ''  )
  assertErrorMsgContains( msg[2], complex, nil )
  assertErrorMsgContains( msg[3], complex, '' , ''  )
  assertErrorMsgContains( msg[3], complex, 1  , ''  )
  assertErrorMsgContains( msg[3], complex, '' , 1   )
  assertErrorMsgContains( msg[4], complex, nil, 1   )
  assertErrorMsgContains( msg[4], complex, 1  , nil )
  assertEquals( complex(0, 1)  , 1i )
  assertEquals( complex(0,-1)  ,-1i )
  assertEquals( complex(0, 1)^2, complex(-1,0))

  for _,v in ipairs(values.num) do
    assertTrue( is_complex( complex( 0, v) ) )
    assertTrue( is_complex( complex( 0,-v) ) )
    assertTrue( is_complex( complex(-v, 0) ) )
    assertTrue( is_complex( complex( v, 0) ) )
    assertTrue( is_complex( complex( v, v) ) )
    assertTrue( is_complex( complex(-v,-v) ) )
  end

  assertNaN   ( complex(nan, 1  ).re    )
  assertEquals( complex(nan, 1  ).im, 1 )
  assertEquals( complex(1  , nan).re, 1 )
  assertNaN   ( complex(1  , nan).im    )
  assertNaN   ( complex(nan, nan).re    )
  assertNaN   ( complex(nan, nan).im    )
end

function TestComplex:testCtorFields()
  assertNaN   ( complex(nan).re       )
  assertNaN   ( complex(nan, nan).re  )
  assertEquals( complex(1).re   , 1   )
  assertEquals( complex(1).im   , 0   )
  assertEquals( complex(0,1).re , 0   )
  assertEquals( complex(0,1).im , 1   )
  for _,v in ipairs(values.num) do
    assertEquals( complex( 0, v).re,  0 )
    assertEquals( complex( 0,-v).re,  0 )
    assertEquals( complex(-v, 0).re, -v )
    assertEquals( complex( v, 0).re,  v )
    assertEquals( complex( v, v).re,  v )
    assertEquals( complex(-v,-v).re, -v )

    assertEquals( complex( 0, v).im,  v )
    assertEquals( complex( 0,-v).im, -v )
    assertEquals( complex(-v, 0).im,  0 )
    assertEquals( complex( v, 0).im,  0 )
    assertEquals( complex( v, v).im,  v )
    assertEquals( complex(-v,-v).im, -v )

    if v ~= inf then
      assertEquals( ( 0+ v*1i).re,  0 )
      assertEquals( ( 0+-v*1i).re,  0 )
    end
    assertEquals( (-v+ 0*1i).re, -v )
    assertEquals( ( v+ 0*1i).re,  v )
    assertEquals( ( 0+ v*1i).im,  v )
    assertEquals( ( 0+-v*1i).im, -v )
    assertEquals( (-v+ 0*1i).im,  0 )
    assertEquals( ( v+ 0*1i).im,  0 )
  end
    assertEquals( complex( 0  , inf).re,  0   )
    assertEquals( complex( 0  ,-inf).re,  0   )
    assertEquals( complex(-inf, 0  ).re, -inf )
    assertEquals( complex( inf, 0  ).re,  inf )
    assertEquals( complex( inf, inf).re,  inf )
    assertEquals( complex(-inf,-inf).re, -inf )

    assertEquals( complex( 0  , inf).im,  inf )
    assertEquals( complex( 0  ,-inf).im, -inf )
    assertEquals( complex(-inf, 0  ).im,  0   )
    assertEquals( complex( inf, 0  ).im,  0   )
    assertEquals( complex( inf, inf).im,  inf )
    assertEquals( complex(-inf,-inf).im, -inf )
end

-- generic functions

function TestComplex:testAngle()
  for _,z  in ipairs(unitCircle( 1, values.rad)) do
  for _,z1 in ipairs(unitCircle( 1, values.rad)) do
    assertEquals( z:angle( z1 ), atan2(z1.im, z1.re) - atan2(z.im, z.re) )
    assertEquals( complex( z.re, z.im):angle(complex( z.re, z.im)), 0 )
    assertEquals( complex( z.re,-z.im):angle(complex( z.re,-z.im)), 0 )
    assertEquals( complex(-z.re, z.im):angle(complex(-z.re, z.im)), 0 )
    assertEquals( complex(-z.re,-z.im):angle(complex(-z.re,-z.im)), 0 )
  end end
end

function TestComplex:testCeil()
  local x, y
  for _,x in ipairs(values.rad) do
    for _,y in ipairs(values.rad) do
      x, y = x/pi, y/pi
      if     x >  0 and y >  0 then assertEquals( complex(x,y):ceil(), complex(1,1) )
      elseif x <= 0 and y >  0 then assertEquals( complex(x,y):ceil(), complex(0,1) )
      elseif x >  0 and y <= 0 then assertEquals( complex(x,y):ceil(), complex(1,0) )
      else                          assertEquals( complex(x,y):ceil(), complex(0,0) ) end
    end
  end
end

function TestComplex:testFloor()
  local x, y
  for _,x in ipairs(values.rad) do
    for _,y in ipairs(values.rad) do
      x, y = x/pi, y/pi
      if     x <  1 and y <  1 then assertEquals( complex(x,y):floor(), complex(0,0) )
      elseif x >= 1 and y >= 1 then assertEquals( complex(x,y):floor(), complex(1,1) )
      elseif x >= 1 then            assertEquals( complex(x,y):floor(), complex(1,0) )
      else                          assertEquals( complex(x,y):floor(), complex(0,1) ) end
    end
  end
end

function TestComplex:testFrac()
  for _,z in ipairs(unitCircle( 1, values.rad)) do
    assertEquals( z:frac().re, frac(z.re) )
    assertEquals( z:frac().im, frac(z.im) )
  end
end

function TestComplex:testTrunc()
  for _,z in ipairs(unitCircle( 1, values.rad)) do
    assertEquals( z:trunc().re - trunc(z.re), 0, eps )
    assertEquals( z:trunc().im - trunc(z.im), 0, eps )
  end
end

function TestComplex:testRound()
  for _,z in ipairs(unitCircle( 1, values.rad)) do
    assertEquals( z:round().re - round(z.re), 0, eps )
    assertEquals( z:round().im - round(z.im), 0, eps )
  end
end

function TestComplex:testAbs()
  local x, y
  for _,x in ipairs(values.rad) do
    for _,y in ipairs(values.rad) do
      x, y = x/pi, y/pi
      assertAlmostEquals( complex(x,y):abs() - hypot(x,y), 0, eps )
    end
  end
  for _,x in ipairs(values.num) do
    if x ~= huge then assertAlmostEquals( complex(x,x):abs() - hypot(x,x), 0, 2*eps )
    else              assertInf( complex(x,x):abs() )  end
  end
  for _,z in ipairs(unitCircle( 1, values.rad)) do
    assertAlmostEquals( complex( z[1], z[2]):abs() - 1, 0, eps )
    assertAlmostEquals( complex(-z[1], z[2]):abs() - 1, 0, eps )
    assertAlmostEquals( complex( z[1],-z[2]):abs() - 1, 0, eps )
    assertAlmostEquals( complex(-z[1],-z[2]):abs() - 1, 0, eps )
  end
  for _,z in ipairs(unitCircle( 10, values.rad)) do
    assertAlmostEquals( z:abs() - 10, 0, 8*eps )
  end
end

function TestComplex:testSqrt()
  local r, z, rad2 = 1
  for i,z in ipairs(unitCircle( r, values.rad2)) do
    rad2 = values.rad2[i]
    assertAlmostEquals( z:sqrt().re - (sqrt(r)*complex( cos(rad2/2), sin(rad2/2))).re, 0, eps )
    assertAlmostEquals( z:sqrt().im - (sqrt(r)*complex( cos(rad2/2), sin(rad2/2))).im, 0, eps )
    assertEquals( complex( z.re, z.im):sqrt().re, (complex( z.re,-z.im):sqrt().re) )
    assertEquals( complex( z.re, z.im):sqrt().im,-(complex( z.re,-z.im):sqrt().im) )
  end
  assertEquals      ( complex( 0, 2):sqrt(), complex( 1, 1)   )
  assertEquals      ( complex( 1, 0):sqrt(), complex( 1, 0)   )
  assertEquals      ( complex( 0, 1):sqrt().re - sqrt(2)/2*(1+1i).re, 0      )
  assertAlmostEquals( complex( 0, 1):sqrt().im - sqrt(2)/2*(1+1i).im, 0, eps )
  assertEquals      ( complex(-2, 0):sqrt().re, 0 )
  assertAlmostEquals( complex(-2, 0):sqrt().im - 1.414213562373095  , 0, eps )

  assertEquals( 1/(complex( 0, 0):sqrt().re), inf )
  assertEquals( 1/(complex( 0, 0):sqrt().im), inf )
  assertEquals( 1/(complex(-0,-0):sqrt().re), inf )
  assertEquals( 1/(complex(-0,-0):sqrt().im),-inf )
  assertEquals( complex(-(0+eps), 0):sqrt().re, 0 )
  assertAlmostEquals( complex(-(0+eps), 0):sqrt().im - 1.49011611938477e-08, 0, eps )

  local ref = {
    0 - 1i,
    1.11022302462516e-16 - 1i                  ,
    2.22044604925031e-16 - 1i                  ,
    0.00872653549837393  - 0.99996192306417131i,
    0.0174524064372835   - 0.9998476951563913i ,
    0.0436193873653360   - 0.9990482215818578i ,
    0.0871557427476582   - 0.9961946980917455i ,
    0.130526192220052    - 0.991444861373810i  ,
    0.258819045102521    - 0.965925826289068i  ,
    0.382683432365090    - 0.923879532511287i  ,
    0.500000000000000    - 0.866025403784439i  ,
    0.707106781186547    - 0.707106781186548i  ,
    0 + 1i,
    1.11022302462516e-16 + 1i                  ,
    2.22044604925031e-16 + 1i                  ,
    0.00872653549837393  + 0.99996192306417131i,
    0.0174524064372835   + 0.9998476951563913i ,
    0.0436193873653360   + 0.9990482215818578i ,
    0.0871557427476582   + 0.9961946980917455i ,
    0.130526192220052    + 0.991444861373810i  ,
    0.258819045102521    + 0.965925826289068i  ,
    0.382683432365090    + 0.923879532511287i  ,
    0.500000000000000    + 0.866025403784439i  ,
    0.707106781186547    + 0.707106781186548i  ,
  }

  for i,z in ipairs(unitCircle( 1, values.rad2)) do
    assertAlmostEquals( complex(-z.re,-z.im):sqrt().re - ref[i]             .re, 0, 2*eps )
    assertAlmostEquals( complex(-z.re,-z.im):sqrt().im - ref[i]             .im, 0, 2*eps )
    assertAlmostEquals( complex(-z.re, z.im):sqrt().re - ref[i+#values.rad2].re, 0, 2*eps )
    assertAlmostEquals( complex(-z.re, z.im):sqrt().im - ref[i+#values.rad2].im, 0, 2*eps )
  end

  -- Check for IEEE:IEC 60559 compliance
  assertEquals( complex( 0, 0):sqrt(), complex( 0, 0 ) )
  for _,x in ipairs(values.rad) do
    assertEquals( complex( x  , inf):sqrt(), complex( inf, inf) )
    assertNaN   ( complex( x  , nan):sqrt().re      )
    assertNaN   ( complex( x  , nan):sqrt().im      )
    assertEquals( complex(-inf, x  ):sqrt(), complex( 0  , inf) )
    assertEquals( complex( inf, x  ):sqrt(), complex( inf, 0  ) )
    assertNaN   ( complex( nan, x  ):sqrt().re      )
    assertNaN   ( complex( nan, x  ):sqrt().im      )
  end
  assertNaN   ( complex(-inf, nan):sqrt().re      )
  assertEquals( complex(-inf, nan):sqrt().im,-inf )
  assertEquals( complex( inf, nan):sqrt().re, inf )
  assertNaN   ( complex( inf, nan):sqrt().im      )
  assertNaN   ( complex( nan, nan):sqrt().re      )
  assertNaN   ( complex( nan, nan):sqrt().im      )
end

function TestComplex:testExp()
  local x, z
  assertEquals      ( complex( 0, 2*pi):exp().re,  1        )
  assertAlmostEquals( complex( 0, 2*pi):exp().im,  0, 2*eps )
  for _,y in ipairs(values.rad) do
    z = complex(0,y)
    assertEquals( (sin(y) - (z:exp() - (-z):exp()) / 2i), complex(0,0) )
    assertEquals( (cos(y) - (z:exp() + (-z):exp()) / 2 ), complex(0,0) )
  end
  for _,y in ipairs(values.num) do
    z = complex(0,y)
    assertEquals( (sin(y) - (z:exp() - (-z):exp()) / 2i), complex(0,0) )
    assertEquals( (cos(y) - (z:exp() + (-z):exp()) / 2 ), complex(0,0) )
  end

  for i,z in ipairs(unitCircle( 1, values.rad)) do
    assertEquals( z      ,             complex( 0, values.rad[i]):exp() )
    assertEquals( z:exp(), exp(z.re) * complex( cos(z.im), sin(z.im))   )
  for i,z1 in ipairs(unitCircle( 1, values.rad)) do
    assertAlmostEquals( (z + z1):exp().re - (z:exp()*z1:exp()).re, 0, 12*eps )
    assertAlmostEquals( (z + z1):exp().im - (z:exp()*z1:exp()).im, 0,  8*eps )
  end end

  -- Check for IEEE:IEC 60559 compliance
  assertEquals( complex( 0, 0):exp(), complex( 1, 0) )
  for _,x in ipairs(values.rad) do
    x = x/pi
    assertNaN( complex( x, inf):exp().re )
    assertNaN( complex( x, inf):exp().im )
    assertNaN( complex( x, nan):exp().re )
    assertNaN( complex( x, nan):exp().im )
    if x > 0 then
      assertNaN   ( complex( nan, x):exp().re )
      assertNaN   ( complex( nan, x):exp().im )
      assertEquals( complex(-inf, x):exp(), complex( 0  , 0  ) )
      assertEquals( complex( inf, x):exp(), complex( inf, inf) )
    end
  end
  assertEquals( complex( inf, 0  ):exp(), complex( inf, 0) )
  assertEquals( complex(-inf, inf):exp(), complex( 0  , 0) )
  assertEquals( complex( inf, inf):exp().re, inf )
  assertNaN   ( complex( inf, inf):exp().im      )
  assertEquals( complex(-inf, nan):exp(), complex( 0  , 0) )
  assertEquals( complex( inf, nan):exp().re, inf )
  assertNaN   ( complex( inf, nan):exp().im      )
  assertNaN   ( complex( nan, 0  ):exp().re      )
  assertEquals( complex( nan, 0  ):exp().im, 0   )
  assertNaN   ( complex( nan, nan):exp().re      )
  assertNaN   ( complex( nan, nan):exp().im      )
end

function TestComplex:testLog()
  local z
  assertEquals( complex(  1     , 0):log(), complex( 0, 0    ) )
  assertEquals( complex(- 1     , 0):log(), complex( 0, pi   ) )
  assertEquals( complex(  0     , 1):log(), complex( 0, pi/2 ) )
  assertEquals( complex(  0     ,-1):log(), complex( 0,-pi/2 ) )
  assertEquals( complex(- 0     , 1):log(), complex( 0, pi/2 ) )
  assertEquals( complex(  0     , 1):log(), complex( 0, pi/2 ) )
  assertEquals( complex(-(0+eps), 0):log(), complex(-36.04365338911715, pi))
  assertEquals( complex(  0+eps , 0):log(), complex(-36.04365338911715, 0 ))

  assertAlmostEquals( complex( 0,  pi      ):log().re -  1.1447298858494002, 0, eps )
  assertAlmostEquals( complex( 0,- pi      ):log().re -  1.1447298858494002, 0, eps )
  assertAlmostEquals( complex( 0,  pi + 1  ):log().re -  1.4210804127942926, 0, eps )
  assertAlmostEquals( complex( 0,-(pi + 1) ):log().re -  1.4210804127942926, 0, eps )
  assertAlmostEquals( complex(-0,  pi      ):log().re -  1.1447298858494002, 0, eps )
  assertAlmostEquals( complex(-0,- pi      ):log().re -  1.1447298858494002, 0, eps )
  assertAlmostEquals( complex(-0,  pi + 1  ):log().re -  1.4210804127942926, 0, eps )
  assertAlmostEquals( complex(-0,-(pi + 1) ):log().re -  1.4210804127942926, 0, eps )

  assertAlmostEquals( complex( 0,  pi      ):log().im -  1.5707963267948966, 0, eps )
  assertAlmostEquals( complex( 0,- pi      ):log().im - -1.5707963267948966, 0, eps )
  assertAlmostEquals( complex( 0,  pi + 1  ):log().im -  1.5707963267948966, 0, eps )
  assertAlmostEquals( complex( 0,-(pi + 1) ):log().im - -1.5707963267948966, 0, eps )
  assertAlmostEquals( complex(-0,  pi      ):log().im -  1.5707963267948966, 0, eps )
  assertAlmostEquals( complex(-0,- pi      ):log().im - -1.5707963267948966, 0, eps )
  assertAlmostEquals( complex(-0,  pi + 1  ):log().im -  1.5707963267948966, 0, eps )
  assertAlmostEquals( complex(-0,-(pi + 1) ):log().im - -1.5707963267948966, 0, eps )

  for _,z in ipairs(unitCircle( 1, values.rad)) do
    assertAlmostEquals( (z:exp():log()).re - z.re, 0, eps )
    assertAlmostEquals( (z:exp():log()).im - z.im, 0, eps )
    assertAlmostEquals( (z:log():exp()).re - z.re, 0, eps )
    assertAlmostEquals( (z:log():exp()).im - z.im, 0, eps )

    assertAlmostEquals( (1/z):log().re - -(z:log()).re, 0, eps )
    assertEquals      ( (1/z):log().im,  -(z:log()).im         )
    assertEquals      ( z:log().re,      (-z):log().re )
    assertAlmostEquals( abs(z:log().im - (-z):log().im ) - pi, 0, 2*eps )
  end
  for _,z in ipairs(unitCircle( pi, values.rad)) do
    assertAlmostEquals( (z:exp():log()).re - z.re, 0, 2*eps )
    assertAlmostEquals( (z:exp():log()).im - z.im, 0,   eps )
    assertAlmostEquals( (z:log():exp()).re - z.re, 0, 4*eps )
    assertAlmostEquals( (z:log():exp()).im - z.im, 0, 2*eps )
  end
  for _,x in ipairs(values.num) do
    z = complex( x, x)
    if x < pi then
      assertAlmostEquals( (z:exp():log()).re - z.re, 0,   eps )
      assertAlmostEquals( (z:exp():log()).im - z.im, 0,   eps )
      assertAlmostEquals( (z:log():exp()).re - z.re, 0, 2*eps )
      assertAlmostEquals( (z:log():exp()).im - z.im, 0, 2*eps )
    end
  end

  -- Check for IEEE:IEC 60559 compliance
  assertEquals( complex(-0, 0):log(), complex(-inf, pi) ) --expected: -inf+pi*i, actual: -inf (JIT)
  assertEquals( complex( 0, 0):log(), complex(-inf, 0 ) )
  for _,x in ipairs(values.rad) do
    assertEquals( complex( x  , inf):log(), complex( inf, pi/2) )
    assertNaN   ( complex( x  , nan):log().re      )
    assertNaN   ( complex( x  , nan):log().im      )
    assertEquals( complex(-inf, x  ):log(), complex( inf, pi  ) )
    assertEquals( complex( inf, x  ):log(), complex( inf, 0   ) )
    assertNaN   ( complex( nan, x  ):log().re      )
    assertNaN   ( complex( nan, x  ):log().im      )
  end
  assertEquals( complex(-inf, inf):log(), complex( inf, 3*pi/4) )
  assertEquals( complex( inf, inf):log(), complex( inf,   pi/4) )
  assertEquals( complex( inf, nan):log().re, inf )
  assertNaN   ( complex( inf, nan):log().im      )
  assertEquals( complex( nan, inf):log().re, inf )
  assertNaN   ( complex( nan, inf):log().im      )
  assertNaN   ( complex( nan, nan):log().re      )
  assertNaN   ( complex( nan, nan):log().im      )
end

function TestComplex:testLog10()
  assertEquals      ( complex(  1     , 0):log10(), complex( 0, 0) )
  assertEquals      ( complex(- 1     , 0):log10().re,   0  )
  assertEquals      ( complex(  0     ,-1):log10().re,   0  )
  assertEquals      ( complex(  0     , 1):log10().re,   0  )
  assertEquals      ( complex(- 0     , 1):log10().re,   0  )
  assertAlmostEquals( complex(-(0+eps), 0):log10().re - -15.65355977452702, 0 , 8*eps )
  assertAlmostEquals( complex(  0+eps , 0):log10().re - -15.65355977452702, 0 , 8*eps )

  assertAlmostEquals( complex(- 1     , 0):log10().im -  1.364376353841841  , 0, eps )
  assertEquals      ( complex(  0     ,-1):log10().im,  -0.6821881769209206 )
  assertEquals      ( complex(  0     , 1):log10().im,   0.6821881769209206 )
  assertEquals      ( complex(- 0     , 1):log10().im,   0.6821881769209206 )
  assertAlmostEquals( complex(-(0+eps), 0):log10().im -  1.364376353841841  , 0, eps )
  assertEquals      ( complex(  0+eps , 0):log10().im,   0                  )

  for _,z in ipairs(unitCircle( 1, values.rad)) do
    assertAlmostEquals( (z:log10() - z:log()/log(10)).re, 0, eps )
    assertAlmostEquals( (z:log10() - z:log()/log(10)).im, 0, eps )
  end
end

function TestComplex:testSin()
  local z, c
  for _,z in ipairs(unitCircle( 1, values.rad)) do
    c = complex( sin( z.re)*cosh( z.im), cos( z.re)*sinh( z.im) )
    assertAlmostEquals( sin( z).re - c.re, 0, eps )
    assertAlmostEquals( sin( z).im - c.im, 0, eps )
    c = complex( sin(-z.re)*cosh(-z.im), cos(-z.re)*sinh(-z.im) )
    assertAlmostEquals( sin(-z).re - c.re, 0, eps )
    assertAlmostEquals( sin(-z).im - c.im, 0, eps )
    assertAlmostEquals( sin(z+2*pi).re - sin(z).re, 0, 3*eps)
  end
  for _,x in ipairs(values.num) do
    z = complex( x, x)
    if     x==10 then
      --assertAlmostEquals( (sin( z) - complex( sin( z.re)*cosh( z.im), cos( z.re)*sinh( z.im))).re, 0, 2*eps ) -- err  mac: e-12
      assertAlmostEquals( (sin( z) - complex( sin( z.re)*cosh( z.im), cos( z.re)*sinh( z.im))).im, 0, 2*eps )
      assertAlmostEquals( (sin(-z) - complex( sin(-z.re)*cosh(-z.im), cos(-z.re)*sinh(-z.im))).im, 0, 2*eps )
      --assertAlmostEquals( (sin(-z) - complex( sin(-z.re)*cosh(-z.im), cos(-z.re)*sinh(-z.im))).re, 0, 2*eps ) -- err  mac: e-12
    elseif x< 10 then
      assertAlmostEquals( (sin( z) - complex( sin( z.re)*cosh( z.im), cos( z.re)*sinh( z.im))).re, 0, 2*eps )
      assertAlmostEquals( (sin( z) - complex( sin( z.re)*cosh( z.im), cos( z.re)*sinh( z.im))).im, 0, 2*eps )
      assertAlmostEquals( (sin(-z) - complex( sin(-z.re)*cosh(-z.im), cos(-z.re)*sinh(-z.im))).im, 0, 2*eps )
      assertAlmostEquals( (sin(-z) - complex( sin(-z.re)*cosh(-z.im), cos(-z.re)*sinh(-z.im))).re, 0, 2*eps )
    else
      assertEquals( sin( z).re, complex( sin( z.re)*cosh( z.im), cos( z.re)*sinh( z.im)).re )
      assertEquals( sin( z).im, complex( sin( z.re)*cosh( z.im), cos( z.re)*sinh( z.im)).im )
      assertEquals( sin(-z).re, complex( sin(-z.re)*cosh(-z.im), cos(-z.re)*sinh(-z.im)).re )
      assertEquals( sin(-z).im, complex( sin(-z.re)*cosh(-z.im), cos(-z.re)*sinh(-z.im)).im )
    end
  end

  assertEquals( complex( 0   , 0   ):sin(), complex( 0   , 0   ) )
  assertEquals( complex( tiny, tiny):sin(), complex( tiny, tiny) )
  assertEquals( complex( huge, huge):sin(), complex( inf ,-inf ) )
  assertEquals( complex(-huge,-huge):sin(), complex(-inf , inf ) )
  assertNaN   ( complex(-inf ,-inf ):sin().re )
  --assertInf   ( complex(-inf ,-inf ):sin().im ) mac: nan
  assertNaN   ( complex( inf , inf ):sin().re )
  assertInf   ( complex( inf , inf ):sin().im )
  assertNaN   ( complex( nan , nan ):sin().re )
  assertNaN   ( complex( nan , nan ):sin().im )
end

function TestComplex:testCos()
  local z, c
  for _,z in ipairs(unitCircle( 1, values.rad)) do
    c = complex( cos( z.re)*cosh( z.im),-sin( z.re)*sinh( z.im) )
    assertAlmostEquals( cos( z).re - c.re, 0, eps )
    assertAlmostEquals( cos( z).im - c.im, 0, eps )
    c = complex( cos(-z.re)*cosh(-z.im),-sin(-z.re)*sinh(-z.im) )
    assertAlmostEquals( cos(-z).re - c.re, 0, eps )
    assertAlmostEquals( cos(-z).im - c.im, 0, eps )
    assertAlmostEquals( cos(z+2*pi).re - cos(z).re, 0, 3*eps)
  end
  for _,x in ipairs(values.num) do
    z = complex( x, x)
    if     x==10 then
      --assertAlmostEquals( (cos( z) - complex( cos( z.re)*cosh( z.im),-sin( z.re)*sinh( z.im)) ).re, 0,   eps ) -- err  mac: e-12
      assertAlmostEquals( (cos( z) - complex( cos( z.re)*cosh( z.im),-sin( z.re)*sinh( z.im)) ).im, 0, 2*eps )
      --assertAlmostEquals( (cos(-z) - complex( cos(-z.re)*cosh(-z.im),-sin(-z.re)*sinh(-z.im)) ).re, 0,   eps ) -- err  mac: e-12
      assertAlmostEquals( (cos(-z) - complex( cos(-z.re)*cosh(-z.im),-sin(-z.re)*sinh(-z.im)) ).im, 0, 2*eps )
    elseif x< 10 then
      assertAlmostEquals( (cos( z) - complex( cos( z.re)*cosh( z.im),-sin( z.re)*sinh( z.im)) ).re, 0,   eps )
      assertAlmostEquals( (cos( z) - complex( cos( z.re)*cosh( z.im),-sin( z.re)*sinh( z.im)) ).im, 0, 2*eps )
      assertAlmostEquals( (cos(-z) - complex( cos(-z.re)*cosh(-z.im),-sin(-z.re)*sinh(-z.im)) ).re, 0,   eps )
      assertAlmostEquals( (cos(-z) - complex( cos(-z.re)*cosh(-z.im),-sin(-z.re)*sinh(-z.im)) ).im, 0, 2*eps )
    else
      assertEquals( cos( z).re, complex( cos( z.re)*cosh( z.im),-sin( z.re)*sinh( z.im) ).re )
      assertEquals( cos( z).im, complex( cos( z.re)*cosh( z.im),-sin( z.re)*sinh( z.im) ).im )
      assertEquals( cos(-z).re, complex( cos(-z.re)*cosh(-z.im),-sin(-z.re)*sinh(-z.im) ).re )
      assertEquals( cos(-z).im, complex( cos(-z.re)*cosh(-z.im),-sin(-z.re)*sinh(-z.im) ).im )
    end
  end
  assertEquals( complex( 0   , 0   ):cos(), complex( 1  , 0  ) )
  assertEquals( complex( tiny, tiny):cos(), complex( 1  , 0  ) )
  assertEquals( complex( huge, huge):cos(), complex(-inf,-inf) )
  assertEquals( complex(-huge,-huge):cos(), complex(-inf,-inf) )
  --assertInf   ( complex(-inf ,-inf ):cos().re ) mac: nan
  assertNaN   ( complex(-inf ,-inf ):cos().im )
  assertNaN   ( complex( inf , inf ):cos().im )
  assertInf   ( complex( inf , inf ):cos().re )
  assertNaN   ( complex( nan , nan ):cos().im )
  assertNaN   ( complex( nan , nan ):cos().re )
end

function TestComplex:testTan()
  local x, y, z
  for _,x in ipairs(values.rad) do
    for _,y in ipairs(values.rad) do
      x, y = x/pi, y/pi
      z = complex(x,y)
      assertAlmostEquals( (z:tan() - z:sin() / z:cos() ).re, 0,   eps )
      assertAlmostEquals( (z:tan() - z:sin() / z:cos() ).im, 0, 4*eps )
    end
  end
  for _,z in ipairs(unitCircle( 1, values.rad)) do
    assertAlmostEquals( (z:tan() - z:sin() / z:cos() ).re, 0,     eps )
    assertAlmostEquals( (z:tan() - z:sin() / z:cos() ).im, 0,     eps )
  end
  for _,x in ipairs( values.num ) do
    z = complex( x, x)
    if x < 10e2 then
      assertAlmostEquals( (z:tan() - z:sin() / z:cos() ).re, 0,   eps )
      assertAlmostEquals( (z:tan() - z:sin() / z:cos() ).im, 0, 2*eps )
    end
  end

  assertEquals( complex( 0   , 0   ):tan(), complex( 0   , 0   ) )
  assertEquals( complex( tiny, tiny):tan(), complex( tiny, tiny) )
  assertEquals( complex( huge, huge):tan(), complex( 0   , 1   ) )
  assertEquals( complex(-huge,-huge):tan(), complex( 0   ,-1   ) )
  assertEquals( complex(-inf ,-inf ):tan(), complex( 0   ,-1   ) )
  assertEquals( complex( inf , inf ):tan(), complex( 0   , 1   ) )
  assertNaN   ( complex( nan , nan ):tan().im )
  assertNaN   ( complex( nan , nan ):tan().re )
end

function TestComplex:testSinh()
  local x, y, z
  for _,z in ipairs(unitCircle( 1, values.rad)) do
    assertAlmostEquals( (sinh( z) - (exp( z)-exp(-z))/2).re, 0, eps )
    assertAlmostEquals( (sinh(-z) - (exp(-z)-exp( z))/2).im, 0, eps )
    x = complex( sinh( z.re)*cos( z.im),cosh( z.re)*sin( z.im) )
    assertAlmostEquals( sinh( z).re - x.re, 0, eps )
    assertAlmostEquals( sinh( z).im - x.im, 0, eps )
  end
  for _,x in ipairs(values.num) do
    z = complex( x, x)
    if     x==10 then
      assertAlmostEquals( (sinh( z) - (exp( z)-exp(-z))/2).re, 0, 2*eps )
      --assertAlmostEquals( (sinh(-z) - (exp(-z)-exp( z))/2).im, 0, 2*eps ) -- err on mac: e-13
      assertAlmostEquals( (sinh( z) - complex( sinh( z.re)*cos( z.im),cosh( z.re)*sin( z.im) )).re, 0,   eps )
      --assertAlmostEquals( (sinh( z) - complex( sinh( z.re)*cos( z.im),cosh( z.re)*sin( z.im) )).im, 0, 2*eps )-- err on mac: e-13
    elseif x< 10 then
      assertAlmostEquals( (sinh( z) - (exp( z)-exp(-z))/2).re, 0, 2*eps )
      assertAlmostEquals( (sinh(-z) - (exp(-z)-exp( z))/2).im, 0, 2*eps )
      assertAlmostEquals( (sinh( z) - complex( sinh( z.re)*cos( z.im),cosh( z.re)*sin( z.im) )).re, 0,   eps )
      assertAlmostEquals( (sinh( z) - complex( sinh( z.re)*cos( z.im),cosh( z.re)*sin( z.im) )).im, 0, 2*eps )
    else
      --assertNaN( (sinh( z) - (exp( z)-exp(-z))/2).re ) --expected: NaN, acutal: zero
      --assertNaN( (sinh(-z) - (exp(-z)-exp( z))/2).im )
    end
  end

  -- Check for IEEE:IEC 60559 compliance
  assertEquals( complex( 0, 0  ):sinh(), complex( 0, 0) )
  assertEquals( complex( 0, inf):sinh().re, 0 )
  assertNaN   ( complex( 0, inf):sinh().im    )
  assertEquals( complex( 0, nan):sinh().re, 0 )
  assertNaN   ( complex( 0, nan):sinh().im    )
  for _,x in ipairs(values.rad) do
    x = x/pi
    if x > 0 then
      assertNaN   ( complex( x  , inf):sinh().re )
      assertNaN   ( complex( x  , inf):sinh().im )
      assertNaN   ( complex( x  , nan):sinh().re )
      assertNaN   ( complex( x  , nan):sinh().im )
      assertNaN   ( complex( nan, x  ):sinh().re )
      assertNaN   ( complex( nan, x  ):sinh().im )
      assertEquals( complex( inf, x  ):sinh(), complex( inf, inf) )
    end
  end
  assertEquals( complex( inf, 0  ):sinh(), complex( inf, 0) )
  assertEquals( complex( inf, inf):sinh().re, inf )
  assertNaN   ( complex( inf, inf):sinh().im      )
  assertEquals( complex( inf, nan):sinh().re, inf )
  assertNaN   ( complex( inf, nan):sinh().im      )
  assertNaN   ( complex( nan, 0  ):sinh().re      )
  assertEquals( complex( nan, 0  ):sinh().im, 0   )
  assertNaN   ( complex( nan, nan):sinh().re      )
  assertNaN   ( complex( nan, nan):sinh().im      )

  for _,x in ipairs(values.rad) do
    x = x/pi
    assertAlmostEquals( (complex(0,x):sin()  - 1i * sinh(x)).re, 0, eps )
    assertAlmostEquals( (complex(0,x):sin()  - 1i * sinh(x)).im, 0, eps )
    assertAlmostEquals( (complex(0,x):sinh() - 1i * sin (x)).re, 0, eps )
    assertAlmostEquals( (complex(0,x):sinh() - 1i * sin (x)).im, 0, eps )
    for _,y in ipairs(values.rad) do
      y = y/pi
      assertEquals( complex(x,y):sin(), -1i * (1i * complex(x,y)):sinh() )
    end
  end
end

function TestComplex:testCosh()
  local x, z
  for _,z in ipairs(unitCircle( 1, values.rad)) do
    assertAlmostEquals( (cosh( z) - (exp( z)+exp(-z))/2).re, 0, eps )
    assertAlmostEquals( (cosh(-z) - (exp(-z)+exp( z))/2).im, 0, eps )
  for _,z1 in ipairs(unitCircle( 1, values.rad)) do
    assertAlmostEquals( (z+z1):cosh().re - (cosh(z)*cosh(z1)+sinh(z)*sinh(z1)).re, 0,  6*eps )
    assertAlmostEquals( (z+z1):cosh().im - (cosh(z)*cosh(z1)+sinh(z)*sinh(z1)).im, 0,  4*eps )
  end end
  for _,x in ipairs(values.num) do
    z = complex( x, x)
    if x < 10e2 then
      assertAlmostEquals( (cosh( z) - (exp( z)+exp(-z))/2).re, 0,2*eps )
      assertAlmostEquals( (cosh(-z) - (exp(-z)+exp( z))/2).im, 0,2*eps )
    else
      assertNaN( (cosh( z) - (exp( z)+exp(-z))/2).re)
      assertNaN( (cosh(-z) - (exp(-z)+exp( z))/2).im)
    end
  end

  -- Check for IEEE:IEC 60559 compliance
  assertEquals( complex( 0, 0  ):cosh(), complex( 1, 0) )
  assertNaN   ( complex( 0, inf):cosh().re    )
  assertEquals( complex( 0, inf):cosh().im, 0 )
  assertNaN   ( complex( 0, nan):cosh().re    )
  assertEquals( complex( 0, nan):cosh().im, 0 )

  for _,x in ipairs(values.rad) do
    x = x/pi
    if x > 0 then
      assertNaN( complex( x  , inf):cosh().re )
      assertNaN( complex( x  , inf):cosh().im )
      assertNaN( complex( x  , nan):cosh().re )
      assertNaN( complex( x  , nan):cosh().im )
      assertNaN( complex( nan, x  ):cosh().re )
      assertNaN( complex( nan, x  ):cosh().im )
      assertEquals( complex( inf, x  ):cosh(), complex( inf, inf) )
    end
  end
  assertEquals( complex( inf, 0  ):cosh(), complex( inf, 0) )
  assertEquals( complex( inf, inf):cosh().re, inf )
  assertNaN   ( complex( inf, inf):cosh().im      )
  assertEquals( complex( inf, nan):cosh().re, inf )
  assertNaN   ( complex( inf, nan):cosh().im      )
  assertNaN   ( complex( nan, 0  ):cosh().re      )
  assertEquals( complex( nan, 0  ):cosh().im, 0   )
  assertNaN   ( complex( nan, nan):cosh().re      )
  assertNaN   ( complex( nan, nan):cosh().im      )

  for _,x in ipairs(values.rad) do
    x = x/pi
    assertAlmostEquals( (complex(0,x):cos()  - cosh(x)).re, 0, eps )
    assertAlmostEquals( (complex(0,x):cos()  - cosh(x)).im, 0, eps )
    assertEquals      ( (complex(0,x):cosh() - cos (x)), complex(0,0) )
    for _,y in ipairs(values.rad) do
      y =  y/pi
      assertEquals( complex(x,y):cos(), (1i * complex(x,y)):cosh() )
    end
  end
end

function TestComplex:testTanh()
  local x, y, z
  for _,x in ipairs(values.rad) do
    for _,y in ipairs(values.rad) do
      x = x/pi, y/pi
      z = complex(x,y)
      --assertAlmostEquals( (z:tanh() - z:sinh() / z:cosh() ).re, 0, 4*eps ) -- mac err: 7.62939453125e-06
      --assertAlmostEquals( (z:tanh() - z:sinh() / z:cosh() ).im, 0, 4*eps ) -- mac: exp: 0, recived: -2
    end
  end
  for _,z in ipairs(unitCircle( 1, values.rad)) do
    assertAlmostEquals( (z:tanh() - z:sinh() / z:cosh() ).re, 0, 2*eps )
    assertAlmostEquals( (z:tanh() - z:sinh() / z:cosh() ).im, 0,   eps )
  end
  for _,x in ipairs(values.num) do
    z = complex( x, x)
    if x < 10e2 then
      assertAlmostEquals( (z:tanh() - z:sinh() / z:cosh() ).re, 0, 2*eps )
      assertAlmostEquals( (z:tanh() - z:sinh() / z:cosh() ).im, 0, 4*eps )
    else
      assertNaN( (z:tanh() - z:sinh() / z:cosh() ).re )
      assertNaN( (z:tanh() - z:sinh() / z:cosh() ).im )
    end
  end

  -- Check for IEEE:IEC 60559 compliance
  assertEquals( complex( 0, 0  ):tanh(), complex( 0, 0) )
  for _,x in ipairs(values.rad) do
    assertNaN( complex( x, inf):tanh().re )
    assertNaN( complex( x, inf):tanh().im )
    assertNaN( complex( x, nan):tanh().re )
    assertNaN( complex( x, nan):tanh().im )
    if x > 0 then
      assertNaN   ( complex( nan, x):tanh().re )
      assertNaN   ( complex( nan, x):tanh().im )
      assertEquals( complex( inf, x):tanh(), complex( 1, 0) )
    end
  end
  assertEquals( complex( inf, inf):tanh(), complex( 1, 0) )
  assertEquals( complex( inf, nan):tanh(), complex( 1, 0) )
  assertNaN   ( complex( nan, 0  ):tanh().re      )
  assertEquals( complex( nan, 0  ):tanh().im, 0   )
  assertNaN   ( complex( nan, nan):tanh().re      )
  assertNaN   ( complex( nan, nan):tanh().im      )

  for _,x in ipairs(values.rad) do
    x = x/pi
    assertAlmostEquals( (complex(0,x):tan()  - 1i * tanh(x)).re, 0,   eps )
    assertAlmostEquals( (complex(0,x):tan()  - 1i * tanh(x)).im, 0, 2*eps )
    assertAlmostEquals( (complex(0,x):tanh() - 1i * tan (x)).re, 0,   eps )
    assertAlmostEquals( (complex(0,x):tanh() - 1i * tan (x)).im, 0, 2*eps )
    for _,y in ipairs(values.rad) do
      y = y/pi
      assertEquals( complex(x,y):tan(), -1i * (1i * complex(x,y)):tanh() )
    end
  end
end

function TestComplex:testAsin()
  local z
  assertNaN   ( complex( nan, nan):asin().re )
  assertNaN   ( complex( nan, nan):asin().im )
  assertEquals( complex( 0  , 0  ):asin(), complex( 0   , 0) )
  assertEquals( complex( 1  , 0  ):asin(), complex( pi/2, 0) )
  assertEquals( complex(-1  , 0  ):asin(), complex(-pi/2, 0) )

  for _,z in ipairs(unitCircle( 1, values.rad)) do
    assertAlmostEquals( (z:asin():sin() - z).re, 0, eps )
    assertAlmostEquals( (z:asin():sin() - z).im, 0, eps )
  end
  for _,x in ipairs(values.num) do
    z = complex( x, x)
    if x < pi/2 then
      assertAlmostEquals( (z:asin():sin() - z).re, 0,     eps )
      assertAlmostEquals( (z:asin():sin() - z).im, 0,   2*eps )
    elseif x < 10 then
      assertAlmostEquals( (z:asin():sin() - z).re, 0,   2*eps )
      assertAlmostEquals( (z:asin():sin() - z).im, 0,   2*eps )
    elseif x == 10  then
      assertAlmostEquals( (z:asin():sin() - z).re, 0,  16*eps )
      assertAlmostEquals( (z:asin():sin() - z).im, 0,  16*eps )
    elseif x == 100 then
      assertAlmostEquals( (z:asin():sin() - z).re, 0, 128*eps )
      assertAlmostEquals( (z:asin():sin() - z).im, 0, 128*eps )
    end
  end

  assertAlmostEquals( complex(  1        , 0):asin().re -  1.5707963267948966  , 0, eps )
  assertAlmostEquals( complex(  1        , 0):asin().im -  0                   , 0, eps )
  assertAlmostEquals( complex(- 1        , 0):asin().re - -1.5707963267948966  , 0, eps )
  assertAlmostEquals( complex(- 1        , 0):asin().im -  0                   , 0, eps )
  assertAlmostEquals( complex(  1+eps    , 0):asin().re -  1.5707963267948966  , 0, eps )
  assertAlmostEquals( complex(  1+eps    , 0):asin().im -  2.10734242278576e-08, 0, eps )
  assertAlmostEquals( complex(-(1+eps)   , 0):asin().re - -1.5707963267948966  , 0, eps )
  assertAlmostEquals( complex(-(1+eps)   , 0):asin().im -  2.10734242278576e-08, 0, eps )

  assertAlmostEquals( complex(  pi/2     , 0):asin().re -  1.5707963267948966, 0,   eps )
  assertAlmostEquals( complex(- pi/2     , 0):asin().re - -1.5707963267948966, 0,   eps )
  assertAlmostEquals( complex(  pi/2+eps , 0):asin().re -  1.5707963267948966, 0,   eps )
  assertAlmostEquals( complex(-(pi/2+eps), 0):asin().re - -1.5707963267948966, 0,   eps )
  assertAlmostEquals( complex(  pi/2     , 0):asin().im -  1.02322747854755  , 0, 3*eps )
  assertAlmostEquals( complex(- pi/2     , 0):asin().im -  1.02322747854755  , 0, 3*eps )
  assertAlmostEquals( complex(  pi/2+eps , 0):asin().im -  1.02322747854755  , 0, 3*eps )
  assertAlmostEquals( complex(-(pi/2+eps), 0):asin().im -  1.02322747854755  , 0, 3*eps )
end

function TestComplex:testAcos()
  local z
  assertEquals( complex( 1, 0 ):acos(), complex( 0 , 0) )
  assertEquals( complex(-1, 0 ):acos(), complex( pi, 0) )
  for _,z in ipairs(unitCircle( 1, values.rad)) do
    assertAlmostEquals( (z:acos():cos() - z).re, 0, 2*eps )
    assertAlmostEquals( (z:acos():cos() - z).im, 0,   eps )
  end
  for _,x in ipairs(values.num) do
    z = complex( x, x)
    if x < 10 then
      assertAlmostEquals( (z:acos():cos() - z).re, 0, 2*eps )
      assertAlmostEquals( (z:acos():cos() - z).im, 0, 2*eps )
    end
  end

  assertEquals      ( complex(  1     , 0):acos().re , 0  )
  assertEquals      ( complex(  1     , 0):acos().im , 0  )
  assertEquals      ( complex(- 1     , 0):acos().re , pi )
  assertEquals      ( complex(- 1     , 0):acos().im , 0  )
  assertEquals      ( complex(  1+eps , 0):acos().re , 0  )
  assertAlmostEquals( complex(  1+eps , 0):acos().im - -2.10734243388799e-08, 0, eps )
  assertAlmostEquals( complex(-(1+eps), 0):acos().re -  pi                  , 0, eps )
  assertAlmostEquals( complex(-(1+eps), 0):acos().im - -2.10734243388799e-08, 0, eps )
  assertAlmostEquals( complex(-(0+eps), 0):acos().re -  1.5707963267948966  , 0, eps )
  assertAlmostEquals( complex(-(0+eps), 0):acos().im - -2.46519032881566e-32, 0, eps )

  assertEquals      ( complex(  pi    , 0):acos().re ,  0 )
  assertEquals      ( complex(  pi+eps, 0):acos().re ,  0 )
  assertAlmostEquals( complex(- 0     , 0):acos().re -  1.5707963267948966, 0, eps )
  assertAlmostEquals( complex(  0     , 0):acos().re -  1.5707963267948966, 0, eps )
  assertAlmostEquals( complex(  pi    , 0):acos().im - -1.8115262724608531, 0, eps )
  assertAlmostEquals( complex(  pi+eps, 0):acos().im - -1.8115262724608531, 0, eps )
  assertEquals      ( complex(- 0     , 0):acos().im ,  0 )
  assertEquals      ( complex(  0     , 0):acos().im ,  0 )

-- Check for IEEE:IEC 60559 compliance
  assertEquals( complex( 0, 0  ):acos(), complex( pi/2, 0) )
  assertEquals( complex(-0, 0  ):acos(), complex( pi/2, 0) )
  assertEquals( complex( 0,-0  ):acos(), complex( pi/2, 0) )
  assertEquals( complex(-0,-0  ):acos(), complex( pi/2, 0) )
  assertEquals( complex( 0, nan):acos().re, pi/2 )
  assertNaN   ( complex( 0, nan):acos().im       )
  assertEquals( complex(-0, nan):acos().re, pi/2 )
  assertNaN   ( complex(-0, nan):acos().im       )
  assertEquals( complex( inf, inf):acos(), complex( pi/4 ,-inf) )
  for _,x in ipairs(values.rad) do
    assertEquals( complex( x, inf):acos(), complex( pi/2 ,-inf) )
    if x > 0 then
      assertNaN   ( complex( x  , nan):acos().im )
      assertNaN   ( complex( x  , nan):acos().re )
      assertEquals( complex(-inf, x  ):acos(), complex( pi,-inf) )
      assertEquals( complex( inf, x  ):acos(), complex( 0 ,-inf) )
      assertNaN   ( complex( nan, x):acos().im )
      assertNaN   ( complex( nan, x):acos().re )
    end
  end
  assertEquals( complex(-inf, inf):acos(), complex( 3*pi/4,-inf) )
  assertEquals( complex( inf, inf):acos(), complex(   pi/4,-inf) )
  assertNaN   ( complex( inf, nan):acos().re      )
  assertEquals( complex( inf, nan):acos().im, inf )
  assertNaN   ( complex(-inf, nan):acos().re      )
  assertEquals( complex(-inf, nan):acos().im, inf )
  assertNaN   ( complex( nan, inf):acos().re      )
  assertEquals( complex( nan, inf):acos().im,-inf )
  assertNaN   ( complex( nan, nan):acos().re      )
  assertNaN   ( complex( nan, nan):acos().im      )
end

function TestComplex:testAtan()
  local z
  assertNaN   ( complex( nan, nan):atan().re )
  assertNaN   ( complex( nan, nan):atan().im )
  assertEquals( complex( 0  , 0  ):atan(), complex( 0   , 0  ) )
  assertEquals( complex(-inf, 0  ):atan(), complex(-pi/2, 0  ) )
  assertEquals( complex( inf, 0  ):atan(), complex( pi/2, 0  ) )

  for _,z in ipairs(unitCircle( pi/2, values.rad)) do
    assertAlmostEquals( (z:atan():tan() - z).re     , 0, 2*eps )
    assertAlmostEquals( (z:atan():tan() - z).im     , 0, 2*eps )
    assertAlmostEquals( (z:atan() - -(-z:atan())).re, 0,   eps )
    assertAlmostEquals( (z:atan() - -(-z:atan())).im, 0,   eps )
    assertAlmostEquals( z:atan().re - (1/2*1i*((1-1i*z):log()-(1+1i*z):log())).re, 0, eps )
    assertAlmostEquals( z:atan().im - (1/2*1i*((1-1i*z):log()-(1+1i*z):log())).im, 0, eps )
  end

  for _,x in ipairs(values.num) do
    z = complex( x, x)
    if x < pi/2 then
      assertAlmostEquals( (z:atan():tan() - z).re     , 0,   eps )
      assertAlmostEquals( (z:atan():tan() - z).im     , 0, 2*eps )
      assertAlmostEquals( (z:atan() - -(-z:atan())).re, 0,   eps )
      assertAlmostEquals( (z:atan() - -(-z:atan())).im, 0,   eps )
      assertAlmostEquals( z:atan().re - (1/2*1i*((1-1i*z):log()-(1+1i*z):log())).re, 0, eps )
      assertAlmostEquals( z:atan().im - (1/2*1i*((1-1i*z):log()-(1+1i*z):log())).im, 0, eps )
    elseif x < 10 then
      assertAlmostEquals( (z:atan():tan() - z).re     , 0, 8*eps )
      assertAlmostEquals( (z:atan():tan() - z).im     , 0, 8*eps )
    end
  end

  --assertEquals      ( complex(  0,  1       ):atan(), complex( 0   , inf) ) --mac: inf+0.7853981633974483i
  --assertEquals      ( complex(  0,- 1       ):atan(), complex( 0   ,-inf) ) --mac: 0.7853981633974483-infi
  assertAlmostEquals( complex(  0, (1+eps)  ):atan().re -  1.5707963267948966    , 0,     eps )
  assertAlmostEquals( complex(  0, (1+eps)  ):atan().im -  1.83684002848386e+01  , 0, 225*eps )
  assertAlmostEquals( complex(  0,-(1+eps)  ):atan().re -  1.5707963267948966    , 0,     eps )
  assertAlmostEquals( complex(  0,-(1+eps)  ):atan().im - -1.83684002848386e+01  , 0, 225*eps )

  assertAlmostEquals( complex(  pi/2     , 0):atan().re -  1.00388482185389    , 0,  13*eps )
  assertAlmostEquals( complex(- pi/2     , 0):atan().re - -1.00388482185389    , 0,  13*eps )
  assertAlmostEquals( complex(  pi/2+eps , 0):atan().re -  1.00388482185389    , 0,  13*eps )
  assertAlmostEquals( complex(-(pi/2+eps), 0):atan().re - -1.00388482185389    , 0,  13*eps )
  assertAlmostEquals( complex(  pi/2     , 0):atan().im - -1.25193300684524e-17, 0,     eps )
  assertAlmostEquals( complex(- pi/2     , 0):atan().im - -1.25193300684524e-17, 0,     eps )
  assertAlmostEquals( complex(  pi/2+eps , 0):atan().im -  2.27190756013159e-17, 0,     eps )
  assertAlmostEquals( complex(-(pi/2+eps), 0):atan().im -  2.27190756013159e-17, 0,     eps )
end

function TestComplex:testAsinh()
  local x, y, z
  assertAlmostEquals( complex( 0,  1     ):asinh().re -  0                   , 0,    eps )
  assertAlmostEquals( complex( 0,- 1     ):asinh().re -  0                   , 0,    eps )
  assertAlmostEquals( complex( 0, (1+eps)):asinh().re -  2.10734243388799e-08, 0,    eps )
  assertAlmostEquals( complex( 0,-(1+eps)):asinh().re -  2.10734243388799e-08, 0,    eps )
  assertAlmostEquals( complex( 0, (1+1  )):asinh().re -  1.31695789692482    , 0, 16*eps )
  assertAlmostEquals( complex( 0,-(1+1  )):asinh().re -  1.31695789692482    , 0, 16*eps )
  assertAlmostEquals( complex( 0,  1     ):asinh().im -  1.5707963267948966  , 0,    eps )
  assertAlmostEquals( complex( 0,- 1     ):asinh().im - -1.5707963267948966  , 0,    eps )
  assertAlmostEquals( complex( 0, (1+eps)):asinh().im -  1.5707963267948966  , 0,    eps )
  assertAlmostEquals( complex( 0,-(1+eps)):asinh().im - -1.5707963267948966  , 0,    eps )
  assertAlmostEquals( complex( 0, (1+1  )):asinh().im -  1.5707963267948966  , 0,    eps )
  assertAlmostEquals( complex( 0,-(1+1  )):asinh().im - -1.5707963267948966  , 0,    eps )

  for _,z in ipairs(unitCircle( pi/2, values.rad)) do
    assertAlmostEquals( (z:asinh():sinh() - z).re, 0, 2*eps )
    assertAlmostEquals( (z:asinh():sinh() - z).im, 0,   eps )
  end
  for _,z in ipairs(unitCircle( pi, values.rad)) do
    assertAlmostEquals( (z:asinh():sinh() - z).re, 0, 2*eps )
    assertAlmostEquals( (z:asinh():sinh() - z).im, 0, 2*eps )
  end
  for _,x in ipairs(values.num) do
    z = complex( x, x)
    if x < pi/2 then
      assertAlmostEquals( (z:asinh():sinh() - z).re, 0, 2*eps )
      assertAlmostEquals( (z:asinh():sinh() - z).im, 0,   eps )
    elseif x < 10 then
      assertAlmostEquals( (z:asinh():sinh() - z).re, 0, 2*eps )
      assertAlmostEquals( (z:asinh():sinh() - z).im, 0, 2*eps )
    end
  end

  -- Check for IEEE:IEC 60559 compliance
  assertEquals( complex( 0, 0):asinh(), complex( 0, 0) )
  for _,x in ipairs(values.rad) do
    assertEquals( complex( x  , inf):asinh(), complex( inf, pi/2) )
    assertNaN   ( complex( x  , nan):asinh().re )
    assertNaN   ( complex( x  , nan):asinh().im )
    assertEquals( complex( inf, x  ):asinh(), complex( inf, 0   ) )
    if x > 0 then
      assertNaN ( complex( nan, x  ):asinh().re )
      assertNaN ( complex( nan, x  ):asinh().im )
    end
  end
  assertEquals( complex( inf, inf):asinh(), complex( inf, pi/4) )
  assertEquals( complex( inf, nan):asinh().re, inf )
  assertNaN   ( complex( inf, nan):asinh().im      )
  assertNaN   ( complex( nan, 0  ):asinh().re      )
  assertEquals( complex( nan, 0  ):asinh().im, 0   )
  assertNaN   ( complex( nan, inf):asinh().im      )
  assertInf   ( complex( nan, inf):asinh().re, inf )
  assertNaN   ( complex( nan, nan):asinh().im      )
  assertNaN   ( complex( nan, nan):asinh().re      )

  for _,x in ipairs(values.rad) do
    x = x/pi
    assertAlmostEquals( (complex(0,x):asin()  - 1i * asinh(x)).re, 0,   eps )
    assertAlmostEquals( (complex(0,x):asin()  - 1i * asinh(x)).im, 0,   eps )
    assertAlmostEquals( (complex(0,x):asinh() - 1i * asin (x)).re, 0,   eps )
    assertAlmostEquals( (complex(0,x):asinh() - 1i * asin (x)).im, 0, 2*eps )
    for _,y in ipairs(values.rad) do
      y = y/pi
      assertEquals( complex(x,y):asin(), -1i * (1i * complex(x,y)):asinh() )
    end
  end
end

function TestComplex:testAcosh()
  local x, y
  assertEquals      ( complex( 1    , 0 ):acosh(),  complex(0,0) )
  assertAlmostEquals( complex( 1-eps, 0 ):acosh().re -  5.50089919428296e-32, 0,   eps )
  assertAlmostEquals( complex( 1-eps, 0 ):acosh().im -  2.10734242554470e-08, 0,   eps )
  assertAlmostEquals( complex( 1-0.1, 0 ):acosh().re - -1.47835141691979e-17, 0,   eps )
  assertAlmostEquals( complex( 1-0.1, 0 ):acosh().im -  4.51026811796262e-01, 0, 2*eps )

  for _,z in ipairs(unitCircle( 1, values.rad)) do
    assertAlmostEquals( (z:acosh():cosh() - z).re, 0, 2*eps )
    assertAlmostEquals( (z:acosh():cosh() - z).im, 0,   eps )
  end
  for _,z in ipairs(unitCircle( 2*pi, values.rad)) do
    assertAlmostEquals( (z:acosh():cosh() - z).re, 0, 16*eps )
    assertAlmostEquals( (z:acosh():cosh() - z).im, 0, 16*eps )
  end
  for _,x in ipairs(values.num) do
    z = complex( x, x)
    if x < pi/2 then
      assertAlmostEquals( (z:acosh():cosh() - z).re, 0,   eps )
      assertAlmostEquals( (z:acosh():cosh() - z).im, 0,   eps )
    elseif x < 10 then
      assertAlmostEquals( (z:acosh():cosh() - z).re, 0, 2*eps )
      assertAlmostEquals( (z:acosh():cosh() - z).im, 0, 2*eps )
    end
  end

-- Check for IEEE:IEC 60559 compliance
  assertEquals( complex( 0, 0):acosh(), complex( 0, pi/2) )
  assertEquals( complex(-0, 0):acosh(), complex( 0, pi/2) )
  for _,x in ipairs(values.rad) do
    assertEquals( complex( x  , inf):acosh(), complex( inf, pi/2) )
    assertNaN   ( complex( x  , nan):acosh().re )
    assertNaN   ( complex( x  , nan):acosh().im )
    assertEquals( complex(-inf, x  ):acosh(), complex( inf, pi  ) )
    assertEquals( complex( inf, x  ):acosh(), complex( inf, 0   ) )
    assertNaN   ( complex( nan, x  ):acosh().re )
    assertNaN   ( complex( nan, x  ):acosh().im )
  end
  assertEquals( complex(-inf, inf):acosh(), complex( inf, 3*pi/4) )
  assertEquals( complex( inf, inf):acosh(), complex( inf,   pi/4) )
  assertEquals( complex( inf, nan):acosh().re, inf )
  assertNaN   ( complex( inf, nan):acosh().im      )
  assertEquals( complex(-inf, nan):acosh().re, inf )
  assertNaN   ( complex(-inf, nan):acosh().im      )
  assertNaN   ( complex( nan, inf):acosh().im      )
  assertInf   ( complex( nan, inf):acosh().re, inf )
  assertNaN   ( complex( nan, nan):acosh().im      )
  assertNaN   ( complex( nan, nan):acosh().re      )
end

function TestComplex:testAtanh()
  local x, y, z
  assertEquals      ( complex(  0     ,-1):atanh(), complex( 0  ,-pi/4) )
  --assertEquals      ( complex(- 1     , 0):atanh(), complex(-inf, 0   ) ) -- to be checked
  assertEquals      ( complex(-(1+eps), 0):atanh().re - -18.36840028483855 , 0         )
  assertAlmostEquals( complex(-(1+eps), 0):atanh().im -  1.5707963267948966, 0,    eps )
  assertEquals      ( complex( (1+eps), 0):atanh().re -  18.36840028483855 , 0         )
  assertAlmostEquals( complex( (1+eps), 0):atanh().im -  1.5707963267948966, 0,    eps )
  assertAlmostEquals( complex(-(1+0.1), 0):atanh().re - -1.52226121886171  , 0, 16*eps )
  assertAlmostEquals( complex(-(1+0.1), 0):atanh().im -  1.5707963267948966, 0,    eps )
  assertAlmostEquals( complex( (1+0.1), 0):atanh().re -  1.52226121886171  , 0, 16*eps )
  assertAlmostEquals( complex( (1+0.1), 0):atanh().im -  1.5707963267948966, 0,    eps )

  for _,z in ipairs(unitCircle( pi/2, values.rad)) do
    assertAlmostEquals( (z:atanh():tanh() - z).re, 0, 2*eps )
    assertAlmostEquals( (z:atanh():tanh() - z).im, 0, 2*eps )
    if z.im ~= 0 then
      assertAlmostEquals( z:atanh().re - (1/2*((1+z):log() - (1-z):log())).re, 0, 16*eps )
      assertAlmostEquals( z:atanh().im - (1/2*((1+z):log() - (1-z):log())).im, 0,    eps )
    end
  end
  for _,z in ipairs(unitCircle( pi, values.rad)) do
    assertAlmostEquals( (z:atanh():tanh() - z).re, 0, 8*eps )
    assertAlmostEquals( (z:atanh():tanh() - z).im, 0, 8*eps )
  end
  for _,x in ipairs(values.num) do
    z = complex( x, x)
    if x < pi/2 then
      assertAlmostEquals( (z:acosh():cosh() - z).im, 0,   eps )
      assertAlmostEquals( (z:acosh():cosh() - z).re, 0,   eps )
      assertAlmostEquals( z:atanh().re - (1/2*((1+z):log() - (1-z):log())).re, 0, eps )
      assertAlmostEquals( z:atanh().im - (1/2*((1+z):log() - (1-z):log())).im, 0, eps )
    elseif x < 10 then
      assertAlmostEquals( (z:acosh():cosh() - z).re, 0, 2*eps )
      assertAlmostEquals( (z:acosh():cosh() - z).im, 0, 2*eps )
    end
  end

-- Check for IEEE:IEC 60559 compliance
  assertEquals( complex( 0, 0  ):atanh(), complex( 0  , 0   ) )
  --assertEquals( complex( 0, nan):atanh().re, 0 ) -- mac: nan
  assertNaN   ( complex( 0, nan):atanh().im    )
  --assertEquals( complex( 1, 0  ):atanh(), complex( inf, 0   ) ) -- mac: inf+0.7853981633974483i
  for _,x in ipairs(values.rad) do
    assertEquals( complex( x, inf):atanh(), complex( 0, pi/2) )
    assertEquals( complex( inf, x):atanh(), complex( 0, pi/2) )
    assertNaN   ( complex( nan, x):atanh().re )
    assertNaN   ( complex( nan, x):atanh().im )
    if x > 0 then
      assertNaN ( complex( x, nan):atanh().re )
      assertNaN ( complex( x, nan):atanh().im )
    end
  end
  assertEquals( complex( inf, inf):atanh(), complex( 0, pi/2) )
  --assertEquals( complex( inf, nan):atanh().re, 0 ) --mac: nan
  --assertNaN   ( complex( inf, nan):atanh().im    ) --expected: nan, actual: 1.570796326794897
  --assertEquals( complex( nan, inf):atanh(), complex( 0, pi/2) )-- mac: nan+1.570796326794897i
  assertNaN   ( complex( nan, nan):atanh().im    )
  assertNaN   ( complex( nan, nan):atanh().re    )

  for _,x in ipairs(values.rad2) do
    x = x/pi
    assertAlmostEquals( (complex(0,x):atan()  - 1i * atanh(x)).re, 0,   eps )
    assertAlmostEquals( (complex(0,x):atan()  - 1i * atanh(x)).im, 0,   eps )
    assertAlmostEquals( (complex(0,x):atanh() - 1i * atan (x)).re, 0,   eps )
    assertAlmostEquals( (complex(0,x):atanh() - 1i * atan (x)).im, 0, 2*eps )
    for _,y in ipairs(values.rad2) do
      y = y/pi
      assertAlmostEquals( ( complex(x,y):atan() - (-1i) * (1i * complex(x,y)):atanh() ).re, 0, eps )
      assertAlmostEquals( ( complex(x,y):atan() - (-1i) * (1i * complex(x,y)):atanh() ).im, 0, eps )
    end
  end
end

--[[
function TestComplex:testErf()    end  --'NYI'
function TestComplex:testTgamma() end  --'NYI'
function TestComplex:testLgamma() end  --'NYI'
]]

-- complex generic functions

function TestComplex:testCarg()
  local x, y
  assertEquals( complex(- 0      , 0  ):carg(), pi   )
  assertEquals( complex(  0      , 0  ):carg(), 0    )
  assertEquals( complex(-(0+eps) , 0  ):carg(), pi   )
  assertEquals( complex(  0+eps  , 0  ):carg(), 0    )
  assertEquals( complex(- 0      , 1  ):carg(), pi/2 )
  assertEquals( complex(  0      , 1  ):carg(), pi/2 )
  assertAlmostEquals(complex(-(0+eps), 1):carg() - pi/2, 0, eps )
  assertAlmostEquals(complex(  0+eps , 1):carg() - pi/2, 0, eps )

  assertEquals( complex(  pi     , 0  ):carg(), 0    )
  assertEquals( complex(- pi     , 0  ):carg(), pi   )
  assertEquals( complex(  pi+eps , 0  ):carg(), 0    )
  assertEquals( complex(-(pi+eps), 0  ):carg(), pi   )
  assertNaN   ( complex(  nan    , nan):carg()       )
  assertEquals( complex(  inf    , inf):carg(), atan2(inf, inf) )

  for i,z in ipairs(unitCircle( pi, values.rad)) do
    assertAlmostEquals( z:carg() - atan2( z.im, z.re), 0, eps )
    assertAlmostEquals( z:carg() - values.rad[i]     , 0, eps )
  end
  for i,z in ipairs(unitCircle( 2*pi, values.rad)) do
    assertAlmostEquals( z:carg() - atan2( z.im, z.re), 0, eps )
    assertAlmostEquals( z:carg() - values.rad[i]     , 0, eps )
  end

  -- Check for IEEE:IEC 60559 compliance
  for _,x in ipairs(values.rad) do
    for _,y in ipairs(values.rad) do
      x, y = x/pi, y/pi
      assertEquals( complex( x, y):carg(), atan2( y, x) )
    end
  end
  for _,x in ipairs(values.num) do
    for _,y in ipairs(values.num) do
      assertEquals( complex( x, y):carg(), atan2( y, x) )
    end
  end
  for i,z in ipairs(unitCircle( 1, values.rad)) do
    assertEquals      ( z:carg() , atan2( z.im, z.re)    )
    assertAlmostEquals( z:carg() - values.rad[i], 0, eps )
  end
end

function TestComplex:testReal()
  assertNaN   (    complex( nan, nan):real()       )
  assertEquals(    complex( inf, inf):real() , inf )
  assertEquals(    complex(-inf,-inf):real() ,-inf )
  assertEquals( 1/(complex( 0  , 0  ):real()), inf )
  assertEquals( 1/(complex(-0  ,-0  ):real()),-inf )

  for _,z in ipairs(unitCircle( 1, values.rad)) do
    assertEquals( z:real()                   , z.re )
    assertEquals( complex(-z.re, z.im):real(),-z.re )
    assertEquals( complex( z.re,-z.im):real(), z.re )
    assertEquals( complex(-z.re,-z.im):real(),-z.re )
  end
end

function TestComplex:testImag()
  local c
  assertNaN   (    complex( nan, nan):imag()       )
  assertEquals(    complex( inf, inf):imag() , inf )
  assertEquals(    complex(-inf,-inf):imag() ,-inf )
  assertEquals( 1/(complex( 0  , 0  ):imag()), inf )
  assertEquals( 1/(complex(-0  ,-0  ):imag()),-inf )

  for _,z in ipairs(unitCircle( 1, values.rad)) do
    assertEquals( z:imag()                   , z.im )
    assertEquals( complex(-z.re, z.im):imag(), z.im )
    assertEquals( complex( z.re,-z.im):imag(),-z.im )
    assertEquals( complex(-z.re,-z.im):imag(),-z.im )
    assertEquals( complex(z:real(), z:imag()), z    )
  end

  for _,x in ipairs(values.num) do
    for _,y in ipairs(values.num) do
      c = complex( x, y)
      assertEquals( c, complex(c:real(), c:imag()) )
    end
  end
  c = complex( inf, inf)
  assertEquals( c, complex(c:real(), c:imag()) )
end

function TestComplex:testConj()
  local x, y, z
  for _,z in ipairs(unitCircle( 1, values.rad)) do
    assertEquals( z:conj()                   , complex( z.re,-z.im) )
    assertEquals( complex(-z.re, z.im):conj(), complex(-z.re,-z.im) )
    assertEquals( complex( z.re,-z.im):conj(), complex( z.re, z.im) )
    assertEquals( complex(-z.re,-z.im):conj(), complex(-z.re, z.im) )
  end
  for _,x in ipairs(values.num) do
    z = complex( x, x)
    assertEquals( z:conj()                   , complex( z.re,-z.im) )
    assertEquals( complex(-z.re, z.im):conj(), complex(-z.re,-z.im) )
    assertEquals( complex( z.re,-z.im):conj(), complex( z.re, z.im) )
    assertEquals( complex(-z.re,-z.im):conj(), complex(-z.re, z.im) )
  end
  -- Check for IEEE:IEC 60559 compliance
  for _,x in ipairs(values.rad) do
    for _,y in ipairs(values.rad) do
      x, y = x/pi, y/pi
      assertEquals( complex(x,y):conj():sqrt() , complex(x,y):sqrt() :conj() )
      assertEquals( complex(x,y):conj():exp()  , complex(x,y):exp()  :conj() )
      assertEquals( complex(x,y):conj():log()  , complex(x,y):log()  :conj() )
      assertEquals( complex(x,y):conj():sinh() , complex(x,y):sinh() :conj() )
      assertEquals( complex(x,y):conj():cosh() , complex(x,y):cosh() :conj() )
      assertEquals( complex(x,y):conj():tanh() , complex(x,y):tanh() :conj() )
      assertEquals( complex(x,y):conj():acos() , complex(x,y):acos() :conj() )
      assertEquals( complex(x,y):conj():acosh(), complex(x,y):acosh():conj() )
      assertEquals( complex(x,y):conj():acosh(), complex(x,y):acosh():conj() )
      assertEquals( complex(x,y):conj():atanh(), complex(x,y):atanh():conj() )
    end
  end
end

function TestComplex:testProj()
  local z
  for _,z in ipairs(unitCircle( 1, values.rad)) do
    assertEquals( complex( z.re, z.im):proj(), z )
    assertEquals( complex(-z.re,-z.im):proj(), complex(-z.re,-z.im) )
  end
  for _,x in ipairs(values.num) do
    z = complex( x, x)
    assertEquals( complex( z.re, z.im):proj(), z )
    assertEquals( complex(-z.re,-z.im):proj(), complex(-z.re,-z.im) )
  end
  assertEquals( complex( 1   , 2  ):proj(), complex( 1   , 2) )
  assertEquals( complex( inf ,-1  ):proj(), complex( inf , 0) )
  assertEquals( complex( 0   ,-inf):proj(), complex( inf , 0) )
  assertEquals( complex( 0   , 1  ):proj(), complex( 0   , 1) )
  assertEquals( complex( tiny, 1  ):proj(), complex( tiny, 1) )
  assertEquals( complex( 0.1 , 1  ):proj(), complex( 0.1 , 1) )
  assertEquals( complex( 1   , 1  ):proj(), complex( 1   , 1) )
  assertEquals( complex( huge, 1  ):proj(), complex( huge, 1) )
  assertEquals( complex( inf , 1  ):proj(), complex( inf , 0) )
  assertEquals( complex(-0   , 1  ):proj(), complex( 0   , 1) )
  assertEquals( complex(-tiny, 1  ):proj(), complex(-tiny, 1) )
  assertEquals( complex(-0.1 , 1  ):proj(), complex(-0.1 , 1) )
  assertEquals( complex(-1   , 1  ):proj(), complex(-1   , 1) )
  assertEquals( complex(-huge, 1  ):proj(), complex(-huge, 1) )
  assertEquals( complex(-inf , 1  ):proj(), complex( inf , 0) )
  assertEquals( complex( 1   , nan):proj().re, 1 )
  assertNaN   ( complex( nan , nan):proj().re    )
  assertNaN   ( complex( 1   , nan):proj().im    )
  assertNaN   ( complex( nan , nan):proj().im    )

  -- Check for IEEE:IEC 60559 compliance
  assertEquals( complex( inf , 2  ):proj(), complex( inf , 0) )
  assertEquals( complex( inf ,-2  ):proj(), complex( inf ,-0) )
  assertEquals( complex( 2   , inf):proj(), complex( inf , 0) )
  assertEquals( complex( 2   ,-inf):proj(), complex( inf ,-0) )
  assertEquals( complex( nan , inf):proj(), complex( inf , 0) )
  assertEquals( complex( nan , inf):proj(), complex( inf , 0) )
end

function TestComplex:testRect()
  local z
  assertEquals( complex( 0   , 0   ):rect(), complex( 0   , 0) )
  assertEquals( complex( tiny, tiny):rect(), complex( tiny, 0) )
  assertEquals( complex( tiny, 0   ):rect(), complex( tiny, 0) )
  assertNaN   ( complex( inf , inf ):rect().re )
  assertNaN   ( complex( inf , inf ):rect().im )
  assertNaN   ( complex(-inf ,-inf ):rect().re )
  assertNaN   ( complex(-inf ,-inf ):rect().im )
  assertNaN   ( complex( nan , nan ):rect().re )
  assertNaN   ( complex( nan , nan ):rect().im )

  for _,z in ipairs(unitCircle( 1, values.rad)) do
    assertEquals( z:rect(), complex( z.re*cos(z.im), z.re*sin(z.im) ) )
  end
  for _,x in ipairs(values.num) do
    z = complex( x, x)
    assertEquals( z:rect(), complex( z.re*cos(z.im), z.re*sin(z.im) ) )
  end
end

function TestComplex:testPolar()
  local z
  assertEquals( complex( 0   , 0   ):polar(), complex( 0  , 0 ) )
  assertEquals( complex( tiny, 0   ):polar(), complex( 0  , 0 ) )
  assertEquals( complex( 1   , 0   ):polar(), complex( 1  , 0 ) )
  assertEquals( complex(-1   , 0   ):polar(), complex( 1  , pi) )
  assertEquals( complex( tiny, tiny):polar(), complex( 0  , atan2(tiny,tiny)) )
  assertEquals( complex( inf , inf ):polar(), complex( inf, atan2( inf, inf)) )
  assertEquals( complex(-inf ,-inf ):polar(), complex( inf, atan2(-inf,-inf)) )
  assertNaN   ( complex( nan , nan ):polar().re )
  assertNaN   ( complex( nan , nan ):polar().im )
  assertInf   ( complex( huge, huge):polar().re )
  assertEquals( complex( huge, huge):polar().im, atan2( huge, huge) )
  assertInf   ( complex(-huge,-huge):polar().re )
  assertEquals( complex(-huge,-huge):polar().im, atan2(-huge,-huge) )

  for _,z in ipairs(unitCircle( 1, values.rad)) do
    assertAlmostEquals( (z:polar() - complex( hypot(z.re,z.im), atan2(z.im,z.re))).re, 0, eps )
    assertAlmostEquals( (z:polar() - complex( hypot(z.re,z.im), atan2(z.im,z.re))).im, 0, eps )
  end
  for _,x in ipairs(values.num) do
    z = complex( x, x)
    if x ~= huge then
      assertAlmostEquals( (z:polar() - complex( hypot(z.re,z.im), atan2(z.im,z.re))).re, 0, 2*eps )
      assertAlmostEquals( (z:polar() - complex( hypot(z.re,z.im), atan2(z.im,z.re))).im, 0,   eps )
    end
  end
end

-- complex non-generic functions

function TestComplex:testUnit()
  local z1 = unitCircle( 1, values.rad)
  for j=1,4,0.1 do
    for i,z in ipairs(unitCircle( j, values.rad)) do
      assertAlmostEquals( z:unit().re - z1[i].re, 0, eps )
      assertAlmostEquals( z:unit().im - z1[i].im, 0, eps )
    end
  end

  assertNaN   ( complex( inf , 1  ):unit().re    )
  assertEquals( complex( inf , 1  ):unit().im, 0 )
  assertNaN   ( complex( inf ,-1  ):unit().re    )
  assertEquals( complex( inf ,-1  ):unit().im, 0 )
  assertNaN   ( complex(-inf , 1  ):unit().re    )
  assertEquals( complex(-inf , 1  ):unit().im, 0 )
  assertNaN   ( complex( 1   ,-inf):unit().im    )
  assertEquals( complex( 1   ,-inf):unit().re, 0 )
  assertNaN   ( complex( 1   , inf):unit().im    )
  assertEquals( complex( 1   , inf):unit().re, 0 )
  assertNaN   ( complex( nan , inf):unit().re    )
  assertNaN   ( complex( nan , inf):unit().im    )
end

-- complex operators

function TestComplex:testUnm()
  assertEquals( 1/(complex( 0  , 0  ):unm()).re,-inf )
  assertEquals( 1/(complex( 0  , 0  ):unm()).im,-inf )
  assertEquals( 1/(complex(-0  ,-0  ):unm()).re, inf )
  assertEquals( 1/(complex(-0  ,-0  ):unm()).im, inf )
  assertEquals(    complex( inf, inf):unm(), complex(-inf,-inf) )
  assertEquals(    complex(-inf,-inf):unm(), complex( inf, inf) )
  assertNaN   (    complex( nan, nan):unm().re )
  assertNaN   (    complex( nan, nan):unm().im )

  for _,z in ipairs(unitCircle( 1, values.rad)) do
    assertEquals( z:unm()                   , complex(-z.re,-z.im) )
    assertEquals( complex(-z.re, z.im):unm(), complex( z.re,-z.im) )
    assertEquals( complex( z.re,-z.im):unm(), complex(-z.re, z.im) )
    assertEquals( complex(-z.re,-z.im):unm(), complex( z.re, z.im) )
  end
end

function TestComplex:testAdd()
  local z, z1
  assertEquals(  complex( 1, 1):add(complex( 0   , 0   )), complex( 1    , 1    ) )
  assertEquals(  complex( 1, 1):add(complex( inf , inf )), complex( inf  , inf  ) )
  assertEquals(  complex( 1, 1):add(complex(-inf ,-inf )), complex(-inf  ,-inf  ) )
  assertEquals(  complex( 1, 1):add(complex( huge, huge)), complex( huge , huge ) )
  assertEquals(  complex( 1, 1):add(complex(-huge,-huge)), complex(-huge ,-huge ) )
  assertEquals(  complex( 1, 1):add(complex( eps , eps )), complex( 1+eps, 1+eps) )
  assertEquals(  complex( 1, 1):add(complex(-eps ,-eps )), complex( 1-eps, 1-eps) )
  assertNaN   ( (complex( 1, 1):add(complex( nan , nan ))).re )
  assertNaN   ( (complex( 1, 1):add(complex( nan , nan ))).im )

  for _,z  in ipairs(unitCircle( 1, values.rad)) do
  for _,z1 in ipairs(unitCircle( 1, values.rad)) do
    assertEquals( complex( z.re, z.im):add(complex( z1.re, z1.im)), complex( z.re+z1.re, z.im+z1.im) )
    assertEquals( complex( z.re, 0   ):add(complex( z1.re, 0    )), complex( z.re+z1.re, 0         ) )
    assertEquals( complex( 0   , z.im):add(complex( 0    , z1.im)), complex( 0         , z.im+z1.im) )
    assertEquals( complex( z.re, z.im):add(complex( z1.re, 0    )), complex( z.re+z1.re, z.im      ) )
    assertEquals( complex( z.re, z.im):add(complex( 0    , z1.im)), complex( z.re      , z.im+z1.im) )

    assertEquals( complex(-z.re, z.im):add(complex( z1.re, z1.im)), complex(-z.re+z1.re, z.im+z1.im) )
    assertEquals( complex( z.re,-z.im):add(complex( z1.re, z1.im)), complex( z.re+z1.re,-z.im+z1.im) )
    assertEquals( complex(-z.re,-z.im):add(complex( z1.re, z1.im)), complex(-z.re+z1.re,-z.im+z1.im) )
  end end

  for _,x in ipairs(values.num) do
  for _,y in ipairs(values.num) do
    z  = complex( x, x)
    z1 = complex( y, y)
    assertEquals( complex( z.re, z.im):add(complex( z1.re, z1.im)), complex( z.re+z1.re, z.im+z1.im) )
    assertEquals( complex(-z.re,-z.im):add(complex( z1.re, z1.im)), complex(-z.re+z1.re,-z.im+z1.im) )
  end end
end

function TestComplex:testSub()
  local z, z1
  assertEquals(  complex( 1, 1):sub(complex( 0   , 0   )), complex( 1    , 1    ) )
  assertEquals(  complex( 1, 1):sub(complex( inf , inf )), complex(-inf  ,-inf  ) )
  assertEquals(  complex( 1, 1):sub(complex(-inf ,-inf )), complex( inf  , inf  ) )
  assertEquals(  complex( 1, 1):sub(complex( huge, huge)), complex(-huge ,-huge ) )
  assertEquals(  complex( 1, 1):sub(complex(-huge,-huge)), complex( huge , huge ) )
  assertEquals(  complex( 1, 1):sub(complex( eps , eps )), complex( 1-eps, 1-eps) )
  assertEquals(  complex( 1, 1):sub(complex(-eps ,-eps )), complex( 1+eps, 1+eps) )
  assertNaN   ( (complex( 1, 1):sub(complex( nan , nan ))).re )
  assertNaN   ( (complex( 1, 1):sub(complex( nan , nan ))).im )

  for _,z  in ipairs(unitCircle( 1, values.rad)) do
  for _,z1 in ipairs(unitCircle( 1, values.rad)) do
    assertEquals( complex( z.re, z.im):sub(complex( z1.re, z1.im)), complex( z.re-  z1.re , z.im-  z1.im ) )
    assertEquals( complex( z.re, z.im):sub(complex( z1.re, z1.im)), complex( z.re-  z1.re , z.im-  z1.im ) )
    assertEquals( complex( z.re, 0   ):sub(complex( z1.re, 0    )), complex( z.re-  z1.re , 0            ) )
    assertEquals( complex( 0   , z.im):sub(complex( 0    , z1.im)), complex( 0            , z.im-  z1.im ) )
    assertEquals( complex( z.re, z.im):sub(complex( z1.re, 0    )), complex( z.re-  z1.re , z.im         ) )
    assertEquals( complex( z.re, z.im):sub(complex( 0    , z1.im)), complex( z.re         , z.im-  z1.im ) )

    assertEquals( complex( z.re, z.im):sub(complex(-z1.re, z1.im)), complex( z.re-(-z1.re), z.im-  z1.im)  )
    assertEquals( complex( z.re, z.im):sub(complex( z1.re,-z1.im)), complex( z.re-  z1.re , z.im-(-z1.im)) )
    assertEquals( complex( z.re, z.im):sub(complex(-z1.re,-z1.im)), complex( z.re-(-z1.re), z.im-(-z1.im)) )
  end end
  for _,x in ipairs(values.num) do
  for _,y in ipairs(values.num) do
    z  = complex( x, x)
    z1 = complex( y, y)
    assertEquals( complex( z.re, z.im):sub(complex( z1.re, z1.im)), complex( z.re-  z1.re , z.im-  z1.im ) )
    assertEquals( complex( z.re, z.im):sub(complex(-z1.re,-z1.im)), complex( z.re-(-z1.re), z.im-(-z1.im)) )
  end end
end

function TestComplex:testMul()
  local c, z, z1
  assertNaN   ( (complex( 1, 1):mul(complex( inf , inf ))).re      )
  assertEquals( (complex( 1, 1):mul(complex( inf , inf ))).im, inf )
  assertNaN   ( (complex( 1, 1):mul(complex(-inf ,-inf ))).re      )
  assertEquals( (complex( 1, 1):mul(complex(-inf ,-inf ))).im,-inf )
  assertNaN   ( (complex( 1, 1):mul(complex( nan , nan ))).re      )
  assertNaN   ( (complex( 1, 1):mul(complex( nan , nan ))).im      )
  assertEquals(  complex( 1, 1):mul(complex( huge, huge)), complex( 0, inf  ) )
  assertEquals(  complex( 1, 1):mul(complex(-huge,-huge)), complex( 0,-inf  ) )
  assertEquals(  complex( 1, 1):mul(complex( eps , eps )), complex( 0, 2*eps) )
  assertEquals(  complex( 1, 1):mul(complex(-eps ,-eps )), complex( 0,-2*eps) )
  assertEquals(  complex( 1, 1):mul(complex( 0   , 0   )), complex( 0, 0    ) )

  for _,z  in ipairs(unitCircle( 1, values.rad)) do
    assertEquals( complex( z.re, z.im):mul(complex( 1   , 0   )) , complex( z.re, z.im) )
  for _,z1 in ipairs(unitCircle( 1, values.rad)) do
    c = complex( z.re*z1.re-  z.im*z1.im , z.re*z1.im+z1.re*z.im)
    assertEquals( complex( z.re, z.im):mul(complex( z1.re, z1.im)), c )
    c = complex(-z.re*z1.re-  z.im*z1.im ,-z.re*z1.im+z1.re*z.im)
    assertEquals( complex(-z.re, z.im):mul(complex( z1.re, z1.im)), c )
    c = complex( z.re*z1.re-(-z.im*z1.im), z.re*z1.im-z1.re*z.im)
    assertEquals( complex( z.re,-z.im):mul(complex( z1.re, z1.im)), c )
    c = complex(-z.re*z1.re-(-z.im*z1.im),-z.re*z1.im-z1.re*z.im)
    assertEquals( complex(-z.re,-z.im):mul(complex( z1.re, z1.im)), c )

    assertEquals( complex( z.re, 0   ):mul(complex( z1.re, 0   )), complex( z.re*z1.re, 0          ) )
    assertEquals( complex( 0   , z.im):mul(complex( 0   , z1.im)), complex(-z.im*z1.im, 0          ) )
    assertEquals( complex( z.re, z.im):mul(complex( z1.re, 0   )), complex( z.re*z1.re, z1.re*z.im ) )
    assertEquals( complex( z.re, z.im):mul(complex( 0   , z1.im)), complex(-z.im*z1.im, z.re *z1.im) )
  end end
  for _,x in ipairs(values.num) do
  for _,y in ipairs(values.num) do
    z  = complex( x, x)
    z1 = complex( y, y)
    assertEquals( complex( z.re, z.im):mul(complex( 0   , z1.im)), complex(-z.im*z1.im, z.re *z1.im) )
    c = complex( z.re*z1.re-  z.im*z1.im , z.re*z1.im+z1.re*z.im)
    if x < huge and y < huge then
      assertEquals( complex( z.re, z.im):mul(complex( z1.re, z1.im)), c )
    end
  end end
end

function TestComplex:testDiv()
  local c, z, z1
  assertEquals( (complex( 0   , 0  ):div(complex( 1   , 1   ))), complex(0,0) )
  assertInf   ( (complex( 1   , 1  ):div(complex( tiny, tiny))).re      )
  assertNaN   ( (complex( 1   , 1  ):div(complex( tiny, tiny))).im      )
  assertNaN   ( (complex( 1   , 1  ):div(complex( huge, huge))).re      )
  assertEquals( (complex( 1   , 1  ):div(complex( huge, huge))).im, 0   )
  assertNaN   ( (complex( 1   , 1  ):div(complex(-huge,-huge))).re      )
  assertEquals( (complex( 1   , 1  ):div(complex(-huge,-huge))).im, 0   )
  assertNaN   ( (complex( 1   , 1  ):div(complex( inf , inf ))).re      )
  assertNaN   ( (complex( 1   , 1  ):div(complex( inf , inf ))).im      )
  assertNaN   ( (complex( 1   , 1  ):div(complex(-inf ,-inf ))).re      )
  assertNaN   ( (complex( 1   , 1  ):div(complex(-inf ,-inf ))).im      )
  assertNaN   ( (complex( 1   , 1  ):div(complex( nan , nan ))).re      )
  assertNaN   ( (complex( 1   , 1  ):div(complex( nan , nan ))).im      )
  assertEquals( (complex(-inf ,-inf):div(complex( 1   , 1   ))).re,-inf )
  assertNaN   ( (complex(-inf ,-inf):div(complex( 1   , 1   ))).im      )
  assertNaN   ( (complex( nan , nan):div(complex( 1   , 1   ))).re      )
  assertNaN   ( (complex( nan , nan):div(complex( 1   , 1   ))).im      )

  assertNaN   ( (complex( 1   , 0  ):div(complex( 0   , 0   ))).re      )
  assertNaN   ( (complex( 1   , 0  ):div(complex( 0   , 0   ))).im      )
  assertNaN   ( (complex( 1   , 1  ):div(complex( 0   , 0   ))).re      )
  assertNaN   ( (complex( 1   , 1  ):div(complex( 0   , 0   ))).im      )
  assertNaN   ( (complex( 0   , 1  ):div(complex( 0   , 0   ))).re      )
  assertNaN   ( (complex( 0   , 1  ):div(complex( 0   , 0   ))).im      )
  assertEquals( (complex( 1   , 1  ):div(complex( 1   , 0   ))).re, 1   )
  assertEquals( (complex( 1   , 1  ):div(complex( 1   , 0   ))).im, 1   )
  assertEquals( (complex( 1   , 1  ):div(complex( 0   , 1   ))).re, 1   )
  assertEquals( (complex( 1   , 1  ):div(complex( 0   , 1   ))).im,-1   )

  for _,z  in ipairs(unitCircle( 1, values.rad)) do
  for _,z1 in ipairs(unitCircle( 1, values.rad)) do
    c = complex( z.re*z1.re +  z.im*z1.im , ( z.im*z1.re -  z.re*z1.im)) /(z1.im^2 + z1.re^2)
    assertEquals( complex( z.re, z.im):div(complex( z1.re, z1.im)), c )
    c = complex(-z.re*z1.re +  z.im*z1.im , ( z.im*z1.re -(-z.re*z1.im)))/(z1.im^2 + z1.re^2)
    assertEquals( complex(-z.re, z.im):div(complex( z1.re, z1.im)), c )
    c = complex( z.re*z1.re +(-z.im*z1.im), (-z.im*z1.re -  z.re*z1.im)) /(z1.im^2 + z1.re^2)
    assertEquals( complex( z.re,-z.im):div(complex( z1.re, z1.im)), c )
    c = complex(-z.re*z1.re +(-z.im*z1.im), (-z.im*z1.re -(-z.re*z1.im)))/(z1.im^2 + z1.re^2)
    assertEquals( complex(-z.re,-z.im):div(complex( z1.re, z1.im)), c )

    if z1.im > 0 then
      assertAlmostEquals( (complex( 0, z.im):div(complex( 0, z1.im)) - complex( z.im/z1.im, 0)).im, 0, eps )
      assertAlmostEquals( (complex( 0, z.im):div(complex( 0, z1.im)) - complex( z.im/z1.im, 0)).im, 0, eps )
      if(complex( z.im/z1.im, 0).re == 0) then
        assertEquals      ( (complex( 0, z.im):div(complex( 0, z1.im))).re - complex( z.im/z1.im, 0) .re, 0      )
        assertAlmostEquals( (complex( 0, z.im):div(complex( 0, z1.im))     - complex( z.im/z1.im, 0)).re, 0, eps )
      else
        assertAlmostEquals( (complex( 0, z.im):div(complex( 0, z1.im)) / complex( z.im/z1.im, 0)).re - 1, 0, 2*eps )
        assertAlmostEquals( (complex( 0, z.im):div(complex( 0, z1.im)) / complex( z.im/z1.im, 0)).re - 1, 0, 2*eps )
      end
      assertAlmostEquals( (complex(z.re, z.im):div(complex( 0, z1.im)) / complex( z.im/z1.im,-z.re/z1.im)).re -1, 0, 2*eps )
      assertAlmostEquals( (complex(z.re, z.im):div(complex( 0, z1.im)) / complex( z.im/z1.im,-z.re/z1.im)).im, 0, eps )
    end

    assertAlmostEquals( (complex(z.re, 0   ):div(complex(z1.re, 0)) / complex( z.re/z1.re, 0         )).re - 1, 0, eps )
    assertAlmostEquals( (complex(z.re, 0   ):div(complex(z1.re, 0)) - complex( z.re/z1.re, 0         )).im    , 0, eps )
    assertAlmostEquals( (complex(z.re, z.im):div(complex(z1.re, 0)) / complex( z.re/z1.re, z.im/z1.re)).re - 1, 0, eps )
    assertAlmostEquals( (complex(z.re, z.im):div(complex(z1.re, 0)) / complex( z.re/z1.re, z.im/z1.re)).im    , 0, eps )
  end end

  for _,x in ipairs(values.num) do
  for _,y in ipairs(values.num) do
    if x < huge and y < huge and x > tiny and y > tiny then
      z  = complex( x, x)
      z1 = complex( y, y)
      c = complex( z.re*z1.re +  z.im*z1.im , ( z.im*z1.re -  z.re*z1.im)) /(z1.im^2 + z1.re^2)
      assertEquals( complex( z.re, z.im):div(complex( z1.re, z1.im)), c )
      assertAlmostEquals( (complex( 0, z.im):div(complex( 0, z1.im)) - complex( z.im/z1.im, 0)).im, 0, eps )
      assertAlmostEquals( (complex( 0, z.im):div(complex( 0, z1.im)) - complex( z.im/z1.im, 0)).im, 0, eps )
      if(complex( z.im/z1.im, 0).re == 0) then
        assertEquals      ( (complex( 0, z.im):div(complex( 0, z1.im))).re - complex( z.im/z1.im, 0) .re, 0      )
        assertAlmostEquals( (complex( 0, z.im):div(complex( 0, z1.im))     - complex( z.im/z1.im, 0)).re, 0, eps )
      else
        assertAlmostEquals( (complex( 0, z.im):div(complex( 0, z1.im)) / complex( z.im/z1.im, 0)).re - 1, 0, 2*eps )
        assertAlmostEquals( (complex( 0, z.im):div(complex( 0, z1.im)) / complex( z.im/z1.im, 0)).re - 1, 0, 2*eps )
      end
      assertEquals( complex( z.re, z.im):div(complex( z1.re, z1.im)), c )
    end
  end end
end

function TestComplex:testMod()
  local a, b, d, z, z1
  local roundc =\x ->_C.round(x) or x:round() -- round imported from C

  for j,z  in ipairs(unitCircle( 1, values.rad)) do
  for i,z1 in ipairs(unitCircle( 1, values.rad)) do
    d = z/z1
    assertEquals( z:mod(z1), (z - (complex(roundc(d.re), roundc(d.im)))*z1) )
  end end
  for _,x in ipairs(values.rad) do
  for _,y in ipairs(values.rad) do
    if y > 0 and y < inf and x < inf then
      a, b = x/pi, y/pi
      z, z1 = complex(a,a), complex(b,b)
      d =  z/z1
      assertEquals( z:mod(z1), (z - (complex(roundc(d.re), roundc(d.im)))*z1) )
    end
  end end

  for _,x in ipairs(values.num) do
  for _,y in ipairs(values.num) do
    if x > tiny and x < 10 and y > tiny and y < 10 then
      a, b = complex(x,y), complex(x,y)
      assertAlmostEquals( a:mod(b).re - (a - round(a/b)*b ).re, 0, eps )
      assertAlmostEquals( a:mod(b).im - (a - round(a/b)*b ).im, 0, eps )
      a, b = complex(x,x), complex(y,y)
      assertAlmostEquals( a:mod(b).re - (a - round(a/b)*b ).re, 0, eps )
      assertAlmostEquals( a:mod(b).im - (a - round(a/b)*b ).im, 0, eps )
      a, b = complex(x,y), complex(y,x)
      assertAlmostEquals( a:mod(b).re - (a - round(a/b)*b ).re, 0,  eps )
      assertAlmostEquals( a:mod(b).im - (a - round(a/b)*b ).im, 0,2*eps )
    end
  end end

  assertNaN( complex( 1  , 1  ):mod(complex( 1  ,  inf)).re )
  assertNaN( complex( 1  , 1  ):mod(complex( 1  ,  inf)).im )
  assertNaN( complex( 1  , 1  ):mod(complex(-1  ,  inf)).re )
  assertNaN( complex( 1  , 1  ):mod(complex(-1  ,  inf)).im )
  assertNaN( complex( 1  , 1  ):mod(complex( 1  , -inf)).re )
  assertNaN( complex( 1  , 1  ):mod(complex( 1  , -inf)).im )
  assertNaN( complex( 1  , 1  ):mod(complex(-1  , -inf)).re )
  assertNaN( complex( 1  , 1  ):mod(complex(-1  , -inf)).im )
  assertNaN( complex( 1  , 1  ):mod(complex( inf,  inf)).re )
  assertNaN( complex( 1  , 1  ):mod(complex( inf,  inf)).im )
  assertNaN( complex( 1  , 1  ):mod(complex(-inf, -inf)).re )
  assertNaN( complex( 1  , 1  ):mod(complex(-inf, -inf)).im )
  assertNaN( complex( 1  , 1  ):mod(complex( inf,  nan)).re )
  assertNaN( complex( 1  , 1  ):mod(complex( inf,  nan)).im )
  assertNaN( complex( 1  , 1  ):mod(complex(-inf,  nan)).re )
  assertNaN( complex( 1  , 1  ):mod(complex(-inf,  nan)).im )
  assertNaN( complex( 1  , 1  ):mod(complex( nan,  nan)).re )
  assertNaN( complex( 1  , 1  ):mod(complex( nan,  nan)).im )
  assertNaN( complex( 1  , 1  ):mod(complex( 0  ,  0  )).re )
  assertNaN( complex( 1  , 1  ):mod(complex( 0  ,  0  )).im )
  assertNaN( complex( 1  , 1  ):mod(complex(-0  , -0  )).re )
  assertNaN( complex( 1  , 1  ):mod(complex(-0  , -0  )).im )
  assertNaN( complex( inf, nan):mod(complex( 1  ,  1  )).re )
  assertNaN( complex( inf, nan):mod(complex( 1  ,  1  )).im )
  assertNaN( complex(-inf, nan):mod(complex( 1  ,  1  )).re )
  assertNaN( complex(-inf, nan):mod(complex( 1  ,  1  )).im )
  assertNaN( complex( nan, nan):mod(complex( 1  ,  1  )).re )
  assertNaN( complex( nan, nan):mod(complex( 1  ,  1  )).im )
end

function TestComplex:testPow()
  local a
  assertEquals( complex(  0     , 1):pow(0), complex(  1     , 0 ) )
  assertEquals( complex(  0     , 1):pow(1), complex(  0     , 1) )
  assertEquals( complex(  0     ,-1):pow(1), complex(  0     ,-1) )
  assertEquals( complex(- 0     , 1):pow(1), complex(- 0     , 1) )
  assertEquals( complex(  0     , 1):pow(1), complex(  0     , 1) )
  assertEquals( complex(-(0+eps), 0):pow(1), complex(-(0+eps), 0) )
  assertEquals( complex(  0+eps , 0):pow(1), complex(  0+eps , 0) )

  assertTrue  ( (1i):pow(1i) == exp(-pi/2) )
  assertEquals( complex(1,1):pow( inf).re, inf   )
  assertNaN   ( complex(1,1):pow( inf).im, nan   )
  assertEquals( complex(1,1):pow(-inf).re, 0     )
  assertEquals( complex(1,1):pow(-inf).im, 0     )
  assertNaN   ( complex(1,1):pow( nan).re        )
  assertNaN   ( complex(1,1):pow( nan).im        )
  assertNaN   ( complex(1,1):pow(-nan).re        )
  assertNaN   ( complex(1,1):pow(-nan).im        )
  assertEquals( complex(1,1):pow(-1)  , 0.5-0.5i )
  assertAlmostEquals( complex(1,1):pow( 0.5).re - complex(1,1):sqrt().re, 0, eps )
  assertAlmostEquals( complex(1,1):pow( 0.5).re - complex(1,1):sqrt().re, 0, eps )

  for _,z  in ipairs(unitCircle( 1, values.rad)) do
    assertEquals( complex( z.re, z.im):pow(0), complex(1,0) )
    assertEquals( complex( z.re, z.im):pow(1), complex( z.re, z.im) )
    assertEquals( complex(-z.re,-z.im):pow(1), complex(-z.re,-z.im) )
    assertEquals( complex( z.re, z.im):pow(2), complex( z.re, z.im)*complex( z.re, z.im) )
    assertEquals      ( complex( z.re, z.im):pow(complex(0,0)), complex(1,0) )
    assertAlmostEquals( complex( z.re, z.im):pow(complex(1,0)).re - z.re, 0, eps )
    assertAlmostEquals( complex( z.re, z.im):pow(complex(1,0)).im - z.im, 0, eps )
  end
-- cpx ^ int
  for _,z in ipairs(unitCircle( 1, values.rad)) do
    assertAlmostEquals( (z:pow(2)*z:pow(3)).re - z:pow(2+3).re, 0,   eps )
    assertAlmostEquals( (z:pow(2)*z:pow(3)).im - z:pow(2+3).im, 0,   eps )
    assertAlmostEquals(  z:pow(3).re -  ( 3*z:log() ):exp().re, 0, 3*eps )
    assertAlmostEquals(  z:pow(3).im -  ( 3*z:log() ):exp().im, 0, 4*eps )
  end
-- cpx ^ cpx
  for _,z  in ipairs(unitCircle( 1, values.rad)) do
  for _,c  in ipairs(unitCircle( 1, values.rad)) do
    a = complex(z.re^2 + z.im^2, 0)
    assertAlmostEquals(z:pow(c).re - (a:pow(c/2)*(1i*c*z:carg()):exp()).re, 0, 12*eps )
    assertAlmostEquals(z:pow(c).im - (a:pow(c/2)*(1i*c*z:carg()):exp()).im, 0, 12*eps )
  end end
end

function TestComplex:testEqual()
  local c, z
  for _,z in ipairs(unitCircle( 1, values.rad)) do
    c = complex( z.re, z.im)   assertTrue ( z == c )
    c = complex(-z.re,-z.im)   assertTrue (-z == c )
    c = complex(-z.re, z.im)   assertFalse( z == c )
    if z.im ~= 0 then c = complex( z.re,-z.im)  assertFalse( z == c )
                 else c = complex( z.re,-z.im)  assertTrue ( z == c ) end
  end
  for _,x in ipairs(values.num) do
    z = complex( x, x)
    c = complex( z.re, z.im)   assertTrue ( z == c )
    c = complex(-z.re,-z.im)   assertTrue (-z == c )
    c = complex(-z.re, z.im) if x > 0 then      assertFalse( z == c )
                                      else      assertTrue ( z == c ) end
    if z.im ~= 0 then c = complex( z.re,-z.im)  assertFalse( z == c )
                 else c = complex( z.re,-z.im)  assertTrue ( z == c ) end
  end
end

-- end ------------------------------------------------------------------------o