--[=[
 o-----------------------------------------------------------------------------o
 |
 | Complex module regression tests
 |
 | Methodical Accelerator Design - Copyright CERN 2015+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: 
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide regression test suites for the complex module.

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local assertEquals, assertAlmostEquals, assertTrue, assertFalse 
      in require 'luaunit'
local eps, inf, nan, pi, tiny in require 'madl_gmath'
local dat = require 'complex_dat'       

local real, imag, conj, abs, arg, rect, polar, exp, log, sqrt, proj, sin, cos,
tan, sinh, cosh, tanh, asin, acos, atan, asinh, acosh, atanh, equal, unm, add, 
sub, mul, div, mod, pow, tostring in require 'madl_complex' 

local C   = require 'complex'

-- regression test suite ------------------------------------------------------o

TestComplex = {}

function TestComplex:testCtor()
  assertEquals( C(1).re     ,   1 )  
  assertEquals( C(1).im     ,   0 )
  assertEquals( C(0,1).re   ,   0 )
  assertEquals( C(0,1).im   ,   1 )
  assertEquals( C(-0.1,0).re,-0.1 )
  assertEquals( C(-0.1,0).im,   0 )
  assertEquals( C(0,-0.1).re,   0 )
  assertEquals( C(0,-0.1).im,-0.1 )
  assertEquals( C(0,1)      ,  1i )
  assertEquals( C(0,-1)     , -1i )
end

function TestComplex:testReal()
  assertEquals( C(1,1)   :real(),   1 )
  assertEquals( C(0,1)   :real(),   0 )
  assertEquals( C(1,0)   :real(),   1 )
  assertEquals( C(-0.1,1):real(),-0.1 )
end

function TestComplex:testImag()
  assertEquals( C(1,1)   :imag(),   1 )
  assertEquals( C(1,0)   :imag(),   0 )
  assertEquals( C(0,1)   :imag(),   1 )
  assertEquals( C(1,-0.1):imag(),-0.1 )
end

function TestComplex:testConj()
  assertEquals( C(1,1)   :conj(), C(1,-1)    )
  assertEquals( C(0,1)   :conj(), C(0,-1)    )
  assertEquals( C(1,0)   :conj(), C(1,-0)    )
  assertEquals( C(-0.1,1):conj(), C(-0.1,-1) )
end

function TestComplex:testAbs()
  assertEquals( C(0,-4):abs(), 4 )
  assertEquals( C(0,0) :abs(), 0 )
  assertEquals( C(1,0) :abs(), 1 )
  assertEquals( C(0,1) :abs(), 1 )
  assertEquals( C(1,1) :abs(), sqrt(2) )
end

function TestComplex:testArg()
  assertEquals( C(1,0) :arg(), 0.0   * pi )
  assertEquals( C(-1,0):arg(), 1.0   * pi )
  assertEquals( C(1,1) :arg(), 1.0/4 * pi )
  assertEquals( C(0,1) :arg(), 1.0/2 * pi )
  assertEquals( C(0,-1):arg(),-1.0/2 * pi )
end

function TestComplex:testExp()
  for i=1,#dat.z do
    local ref = dat.exp[i]
    local res = dat.z[i]:exp()

    assertAlmostEquals( res.re, ref.re, eps )
    assertAlmostEquals( res.im, ref.im, eps )
  end

  assertEquals( C(0,0):exp(), C(1,0) )
end

function TestComplex:testLog()
  for i=1,#dat.z do
    local ref = dat.log[i]
    local res = dat.z[i]:log()

    assertAlmostEquals( res.re, ref.re, eps )
    assertAlmostEquals( res.im, ref.im, eps )
  end

  assertEquals( C(1,0) :log(), C(0,0)           )
  assertEquals( C(0,0) :log(), C(-inf,0)        )
  assertEquals( C(-1,0):log(), C(0,pi)          )
  assertEquals( C(0,1) :log(), C(0, 1.0/2 * pi) )
  assertEquals( C(0,-1):log(), C(0,-1.0/2 * pi) )
end

function TestComplex:testSqrt()
  for i=1,#dat.z do
    local ref = dat.sqrt[i]
    local res = dat.z[i]:sqrt()

    assertAlmostEquals( res.re, ref.re, eps )
    assertAlmostEquals( res.im, ref.im, eps )
  end

  assertEquals( C(0,0):sqrt(), C(0,0) )
  assertEquals( C(0,2):sqrt(), C(1,1) )
  assertEquals( C(1,0):sqrt(), C(1,0) )
end


function TestComplex:testProj()
  assertEquals( C(1,2)    :proj(), C(1,2)     )
  assertEquals( C(inf,-1) :proj(), C(inf,-1)  )
  assertEquals( C(0, -inf):proj(), C(0 ,-inf) )
end

function TestComplex:testSin()
  for i=1,#dat.z do
    local ref = dat.sin[i]
    local res = dat.z[i]:sin()

    assertAlmostEquals( res.re, ref.re, eps )
    assertAlmostEquals( res.im, ref.im, eps )
  end

  assertEquals( C(0,0):sin(), C(0,0) )
end

function TestComplex:testCos()
  for i=1,#dat.z do
    local ref = dat.cos[i]
    local res = dat.z[i]:cos()

    assertAlmostEquals( res.re, ref.re, eps )
    assertAlmostEquals( res.im, ref.im, eps )
  end

  assertEquals( C(0,0):cos(), C(1,0) )
end

function TestComplex:testTan()
  for i=1,#dat.z do
    local ref = dat.tan[i]
    local res = dat.z[i]:tan()

    assertAlmostEquals( res.re, ref.re, eps )
    assertAlmostEquals( res.im, ref.im, eps )
  end

  assertEquals( C(0,0):tan(), C(0,0) )
end

function TestComplex:testSinh()
  for i=1,#dat.z do
    local ref = dat.sinh[i]
    local res = dat.z[i]:sinh()

    assertAlmostEquals( res.re, ref.re, eps )
    assertAlmostEquals( res.im, ref.im, eps )
  end

  assertEquals( C(0,0):sinh(), C(0,0) )
end

function TestComplex:testCosh()
  for i=1,#dat.z do
    local ref = dat.cosh[i]
    local res = dat.z[i]:cosh()

    assertAlmostEquals( res.re, ref.re, eps )
    assertAlmostEquals( res.im, ref.im, eps )
  end

  assertEquals( C(0,0):cosh(), C(1,0) )
end

function TestComplex:testTanh()
  for i=1,#dat.z do
    local ref = dat.tanh[i]
    local res = dat.z[i]:tanh()

    assertAlmostEquals( res.re, ref.re, eps )
    assertAlmostEquals( res.im, ref.im, eps )
  end

  assertEquals( C(0,0):tanh(), C(0,0) )
end

function TestComplex:testAsin()
  for i=1,#dat.z do
    local ref = dat.asin[i]
    local res = dat.z[i]:asin()

    assertAlmostEquals( res.re, ref.re, eps )
    assertAlmostEquals( res.im, ref.im, eps )
  end

  assertEquals( C(0,0) :asin(), C(0,0)         )
  assertEquals( C(1,0) :asin(), C(1/2 * pi,0)  )
  assertEquals( C(-1,0):asin(), C(-1/2 * pi,0) )
end

function TestComplex:testAcos()
  for i=1,#dat.z do
    local ref = dat.acos[i]
    local res = dat.z[i]:acos()

    assertAlmostEquals( res.re, ref.re, eps )
    assertAlmostEquals( res.im, ref.im, eps )
  end

  assertEquals( C(1,0) :acos(), C(0,0)        )
  assertEquals( C(-1,0):acos(), C(pi,0)       )
  assertEquals( C(0,0) :acos(), C(1/2 * pi,0) )
end

function TestComplex:testAtan()
  for i=1,#dat.z do
    local ref = dat.atan[i]
    local res = dat.z[i]:atan()

    if res.im==inf or res.im==-inf then
      assertEquals( res.re, ref.re )
      assertEquals( res.im, ref.im )
    else
      assertAlmostEquals( res.re, ref.re, eps )
      assertAlmostEquals( res.im, ref.im, eps )
    end
  end
  --assertEquals( C(0,0)   :atan(), nan )
  --assertEquals( C(0,1)   :atan(), nan ) 
  --assertEquals( C(0,-1)  :atan(), nan )
  
  assertEquals( C(0,0)   :atan(), C(0,0)       )
  assertEquals( C(0,1)   :atan(), C(0,inf)     )
  assertEquals( C(0,-1)  :atan(), C(0,-inf)    )
  assertEquals( C(inf,0) :atan(), C(1/2*pi,0)  )
  assertEquals( C(-inf,0):atan(), C(-1/2*pi,0) )
end

function TestComplex:testAsinh()
  for i=1,#dat.z do
    local ref = dat.asinh[i]
    local res = dat.z[i]:asinh()

    assertAlmostEquals( res.re, ref.re, eps )
    assertAlmostEquals( res.im, ref.im, eps )
  end

  assertEquals( C(0,0):asinh(), C(0,0) )
end

function TestComplex:testAcosh()
  for i=1,#dat.z do
    local ref = dat.acosh[i]
    local res = dat.z[i]:acosh()

    assertAlmostEquals( res.re, ref.re, eps )
    assertAlmostEquals( res.im, ref.im, eps )
  end
end

function TestComplex:testAtanh()
  for i=1,#dat.z do
    local ref = dat.atanh[i]
    local res = dat.z[i]:atanh()

    if res.re == inf or res.re==-inf then
      assertEquals( res.re, ref.re )
      assertEquals( res.im, ref.im )
    else
      assertAlmostEquals( res.re, ref.re, eps )
      assertAlmostEquals( res.im, ref.im, eps )
    end
  end

  assertEquals( C(0,0):atanh(), C(0,0) )
  --assertEquals( C(0,0) :atanh(), nan )
  --assertEquals( C(0,1) :atanh(), nan ) 
  --assertEquals( C(0,-1):atanh(), nan ) 
end

function TestComplex:testEqu()
  assertTrue ( C(1,1)    == C(1,1)    )
  assertTrue ( C(0,1)    == C(0,1)    )
  assertTrue ( C(1,0)    == 1         )
  assertTrue ( C(0,1)    == 1i        )
  assertTrue ( C(1,0)    == C(1,0)    )
  assertTrue ( C(-0.1,1) == C(-0.1,1) )
  assertFalse( C(1,-1)   == C(2,1)    )
  assertTrue ( equal(C(0,1)   , 1i       ) )
  assertTrue ( equal(C(1,0)   , C(1,0)   ) )
  assertTrue ( equal(C(-0.1,1), C(-0.1,1)) )
  assertFalse( equal(C(1,-1)  , C(2,1)   ) )
end

function TestComplex:testUnm()
  assertEquals( -C(1,1)   , C(-1,-1)  )
  assertEquals( -C(0,1)   , C(-0,-1)  )
  assertEquals( -C(1,0)   , C(-1,-0)  )
  assertEquals( -C(0,0)   , C(-0,-0)  )
  assertEquals( -C(-0.1,1), C(0.1,-1) )
end

function TestComplex:testAdd()
  assertEquals( C(1,1)    + C(1,1)    , C(2,2)   )
  assertEquals( C(0,1)    + C(0,1)    , C(0,2)   )
  assertEquals( C(1,0)    + C(1,0)    , C(2,0)   )
  assertEquals( C(1,-1)   + C(2,1)    , C(3,0)   )
  assertEquals( C(-0.1,1) + C(1,1)    , C(0.9,2) )
  assertEquals( add(C(1,1)   , C(1,1)), C(2,2)   )
  assertEquals( add(C(0,1)   , C(0,1)), C(0,2)   )
  assertEquals( add(C(1,0)   , C(1,0)), C(2,0)   )
  assertEquals( add(C(1,-1)  , C(2,1)), C(3,0)   )
  assertEquals( add(C(-0.1,1), C(1,1)), C(0.9,2) )
end

function TestComplex:testSub()
  assertEquals( C(1,1)    - C(1,1)    , C(0,0)    )
  assertEquals( C(0,1)    - C(0,1)    , C(0,0)    )
  assertEquals( C(1,0)    - C(1,0)    , C(0,0)    )
  assertEquals( C(1,-1)   - C(2,1)    , C(-1, -2) )
  assertEquals( C(-0.1,1) - C(1,1)    , C(-1.1,0) )
  assertEquals( sub(C(1,1)   , C(1,1)), C(0,0)    )
  assertEquals( sub(C(0,1)   , C(0,1)), C(0,0)    )
  assertEquals( sub(C(1,0)   , C(1,0)), C(0,0)    )
  assertEquals( sub(C(1,-1)  , C(2,1)), C(-1, -2) )
  assertEquals( sub(C(-0.1,1), C(1,1)), C(-1.1,0) )
end

function TestComplex:testMul()
  assertEquals( C(1,1)    * C(1,1)    , C(0,2)      )
  assertEquals( C(1,0)    * C(1,0)    , C(1,0)      )
  assertEquals( C(1,1)    * C(2,0)    , C(2,2)      )
  assertEquals( C(0,1)    * C(0,1)    , C(-1,0)     )
  assertEquals( C(1,-1)   * C(2,1)    , C(3, -1)    )
  assertEquals( C(-0.1,1) * C(1,1)    , C(-1.1,0.9) )
  assertEquals( mul(C(1,1)   , C(1,1)), C(0,2)      )
  assertEquals( mul(C(1,0)   , C(1,0)), C(1,0)      )
  assertEquals( mul(C(1,1)   , C(2,0)), C(2,2)      )
  assertEquals( mul(C(0,1)   , C(0,1)), C(-1,0)     )
  assertEquals( mul(C(1,-1)  , C(2,1)), C(3, -1)    )
  assertEquals( mul(C(-0.1,1), C(1,1)), C(-1.1,0.9) )
end

function TestComplex:testDiv()
  assertEquals( (C(1,1)/ C(0,0)):tostring() , C(nan,nan):tostring() )
  assertEquals( C(0,1)    / C(0,1)     , C(1,0)                  )
  assertEquals( C(6,3)    / C(7,-5)    , C(27/74, 51/74)         )
  assertEquals( C(1,0)    / C(1,5)     , C(1/26, (-5/26))        )
  assertEquals( C(-0.1,1) / C(1,1)     , C(0.45,0.55)            )
  assertEquals( C(0,1)    / C(0,10)    , C(0.1,0)                )
  assertEquals( C(0,10)   / C(0,3)     , C(3.3333333333333333,0) )
  assertEquals( div(C(0,1)   , C(0,1) ), C(1,0)                  )
  assertEquals( div(C(6,3)   , C(7,-5)), C(27/74, 51/74)         )
  assertEquals( div(C(1,0)   , C(1,5) ), C(1/26, (-5/26))        )
  assertEquals( div(C(-0.1,1), C(1,1) ), C(0.45,0.55)            )
  assertEquals( div(C(0,1)   , C(0,10)), C(0.1,0)                )
  assertEquals( div(C(0,10)  , C(0,3) ), C(3.3333333333333333,0) )
end

function TestComplex:testMod()
  local r = C(5,1) % C(1,-3)
  assertAlmostEquals( r.re, 2, tiny )
  assertEquals( r.im, 0 )
end

function TestComplex:testPow()
  assertTrue  ( C(1,1)^0      == 1 )
  assertTrue  ( pow(C(1,1),0) == 1 )
  assertEquals( C(1,1)^1     , C(1,1)  )
  assertEquals( C(1,1)^2     , C(0,2)  )
  assertEquals( C(1,1)^3     , C(-2,2) )
  assertEquals( pow(C(1,1),1), C(1,1)  )
  assertEquals( pow(C(1,1),2), C(0,2)  )
  assertEquals( pow(C(1,1),3), C(-2,2) )
end

--function TestComplex:testTostring()
--  assertIsString( C(0,0)   :tostring() )
--  assertIsString( C(1,1)   :tostring() )
--  assertIsString( C(0,0.1) :tostring() )
--  assertIsString( C(-0.1,0):tostring() )
--end

-- end ------------------------------------------------------------------------o