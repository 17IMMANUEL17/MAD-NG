local lu  = require 'luaunit'
local G   = require 'madl_gmath'
local eps, huge, I, inf, Inf, nan, NaN, pi, Pi, tiny, twopi in G
--local C   = require 'complex'
--local dat = require 'tests.complex_dat'

local isEqu    = lu.assertEquals
local isTrue   = lu.assertTrue
local isFalse  = lu.assertFalse
local isEquEps = lu.assertAlmostEquals
local isTable  = lu.assertIsTable
local isErrEqu = lu.assertErrorMsgEquals
local isNil    = lu.assertNil

TestIntable = {}

--function TestIntable:setUp()    end
--function TestIntable:tearDown() end

function TestIntable:testGmath() 
  local abs1, ceil1, floor1, max1 = math.abs, math.ceil, math.floor, math.max
  local abs, ceil, floor, max    in math
  
  local inp  = { 0.1, 2.2, -7, -2.1 }
  for i=1,#inp do
    isEqu( abs(inp[i])  , abs1(inp[i])   )
    isEqu( ceil(inp[i]) , ceil1(inp[i])  )
    isEqu( floor(inp[i]), floor1(inp[i]) )
    isEqu( max(inp[i])  , max1(inp[i])    )
  end
end

--function TestIntable:testTryg()
--  local sin1, cos1, tan1 = g.sin, g.cos, g.tan
--  local sin, cos, tan in g
--
--  for i=1,#dat.z do
--    local ref  = { dat.sin[i], dat.cos[i], dat.tan[i]}
--    local res  = { sin ( dat.z[i] ), cos ( dat.z[i] ), tan ( dat.z[i] ) }
--    local res1 = { sin1( dat.z[i] ), cos1( dat.z[i] ), tan1( dat.z[i] ) }
--
--    for j=1,#res do
--      isEquEps( res[j].re , ref[j].re, eps )
--      isEquEps( res[j].im , ref[j].im, eps )
--      isEquEps( res1[j].re, res[j].re, eps )
--      isEquEps( res1[j].im, res[j].im, eps )
--    end
--  end
--end

function TestIntable:testSinc() 
  local sinc1 = G.sinc
  local sinc  in G

  local abs, sin in G
  local function sinc2  (x) return abs(x) < 1e-10 and 1.0 or sin(x)/x end

  local dat = 
  {
  { 1e-11,  1.000000000000000e0    },
  { 1e-9 ,  1.000000000000000e0    },
  { 1e-7 ,  9.999999999999983e-1   },
  { 1e-5 ,  9.999999999833333e-1   },
  { 1e-3 ,  9.9999983333334167e-1  },
  { 1e-1 ,  9.9833416646828152e-1  },
  { 1e1  , -5.4402111088936981e-2  },
  { 1e3  ,  8.2687954053200256e-4  },
  { 1e5  ,  3.5748797972016509e-7  },
  { 1e7  ,  4.2054779319078249e-8  },
  { 1e9  ,  5.4584344944869956e-10 },
  { 1e11 ,  9.2869366049659195e-12 },
  { 1e13 , -2.8888529481752512e-14 },
  }
  
  for i=1,#dat do
    local ref  = dat[i][2]
    local inp  = sinc(dat[i][1])
    local inp1 = sinc1(dat[i][1])
    local inp2 = sinc2(dat[i][1])

    isEquEps( inp , ref, eps )
    isEquEps( inp1, inp, eps )
    isEquEps( inp2, inp, eps )
  end 
  
  for i=1,#dat do
    local ref  = -dat[i][2]
    local inp  = -sinc(dat[i][1])
    local inp1 = -sinc1(dat[i][1])
    local inp2 = -sinc2(dat[i][1])

    isEquEps( inp , ref, eps )
    isEquEps( inp1, inp, eps )
    isEquEps( inp2, inp, eps )
  end
end

function TestIntable:testLambda()
  local a  = { f=function (x,y) return x*y end, 3 } 
  local f in a
  local f1 = a.f
  isEqu( a.f(-2,1.1), f(-2,1.1) )
  isEqu( f(2,3)     , 6         )
  
  local a = { f=\x,y x+y, g=\x x*2 }
  local f,g in a
  isEqu( a.f(-2,1.1), f(-2,1.1) )
  isEqu( f(2,3)     , 5         )
   
  local a  = { f=\s,y s.x*y, x=3 }
  local f, x in a
  local f1 = a.f, a.x
  isEqu ( f, f1  )
  isEqu ( x, a.x )
  isTrue( x == 3 )
end

function TestIntable:testTables ()
  local a = { x=3, y=2, z="a" }
  local x,y,z in a
  isEqu ( x, a.x )
  isEqu ( y, a.y )
  isEqu ( z, a.z )
  
 -- local a = { f1=\x,y C(x,-y), b = 2, c = C(2,0) }
 -- local f1,b,c in a
 -- isEqu ( f1(2,1), a.f1(2,1) )
 -- isEqu ( b, a.b )
 -- isEqu ( c, a.c )
end

function TestIntable:testFunc() 
  local f=\x,y {a = x+y, b = x*y, 3*y }
  local d = f(2,2)
  local a,b,c in d
  isEqu( a, d.a )
  isEqu( b, d.b )
  isNil(c)
  
  local a,b in f(3,3)
  isEqu( a, 6 )
  isEqu( b, 9 )
end

function TestIntable:testObject() 
  local Object in MAD
  local O = Object  
  local Point = O 'Point' {}
  local p1 = Point 'p1' { x=3, y=2, z=1  }
  local x,y,z in p1
  isEqu ( x, 3    )
  isEqu ( y, 2    )
  isEqu ( z, 1    )
  isEqu ( x, p1.x )
  isEqu ( y, p1.y )
  isEqu ( z, p1.z )

  local p2 = p1 'p2' { y=\s 2*s.x }
  local x,y,z in p2
  isEqu ( x, 3 )
  isEqu ( y, 6 )
  isEqu ( z, 1 )

  local p3 = p2 'p3' { z={ 2, 4 }, k=1 } 
  local x,y,z,k,name in p3  
  isEqu ( x   , 3    )
  isEqu ( y   , 6    )
  isEqu ( z[1], 2    )
  isEqu ( z[2], 4    )
  isEqu ( k   , 1    )
  isEqu ( name, 'p3' )
end

--os.exit( lu.LuaUnit.run() ) 
 lu.LuaUnit.run() 