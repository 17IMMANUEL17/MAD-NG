--[=[
 o-----------------------------------------------------------------------------o
 |
 | Survey tests
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide regression test suites for the survey module.

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local assertNotNil, assertEquals, assertAlmostEquals, assertAllAlmostEquals,
      assertStrContains, assertErrorMsgContains                  in MAD.utest

local vector, matrix, mtable, option, filesys, plot              in MAD
local is_string                                                  in MAD.typeid
local eps, pi                                                    in MAD.constant

local E, G = MAD.element, MAD.geomap

local refdir = \s -> 'geomap_ref/'..s
local rundir = \s -> 'geomap_run/'..s

local doplot = false

-- helpers (adapted from survey) ----------------------------------------------o

local function mk_mtbl (title)
  return mtable 'geomap' {
    title=title,
    'name', 'kind', 's', 'l', 'angle', 'tilt',
    'x', 'y', 'z', 'theta', 'phi', 'psi', 'tdir',
  }
end

local function mk_mflw (title, X0, A0, spos, sdir, tdir)
  if not is_string(title) then
    X0, A0, spos, sdir, tdir = title, X0, A0, spos, sdir
  end
  X0, A0 = X0 or {}, A0 or {}

  local x     = X0[1] or X0.x     or 0
  local y     = X0[2] or X0.y     or 0
  local z     = X0[3] or X0.z     or 0
  local theta = A0[1] or A0.theta or 0
  local phi   = A0[2] or A0.phi   or 0
  local psi   = A0[3] or A0.psi   or 0
  local mtbl  = mk_mtbl(title)

  mtbl.sdir = sdir or 1

  local mflw = {
    mtbl=mtbl,
    spos=spos or 0,
    sdir=sdir or 1,
    tdir=tdir or 1,

    V=vector(3):fill{x,y,z},           -- displacement vector
    W=matrix(3):rotmad(theta,phi,psi), -- orientation matrix (rotations)
    A=vector(3):fill{theta,phi,psi},   -- oriented angles

    R=vector(3),                       -- displacement vector
    S=matrix(3),                       -- orientation matrix (rotations)
    T=matrix(3),                       -- transformation matrix if tilted
    U=vector(3),                       -- temporary vector for calculations
  }
  return mflw, mtbl
end

local function save (elm, mflw, lw)
  local name, kind, l, angle, tilt in elm

  local V, A, sdir, tdir, spos, mtbl in mflw
  local x, y, z      = V[1], V[2], V[3]
  local th, phi, psi = A[1], A[2], A[3]

  -- keep order!
  mtbl = mtbl + { name, kind, spos, l*lw*sdir, angle*lw*tdir, tilt*tdir,
                  x, y, z, th, phi, psi, tdir }
end

local function plot (mtbl)
  MAD.plot { table=mtbl, x1y1  = { s={'x','y','z'} },
                         x1y2  = { s={'theta','phi','psi'} },
                         colors= {x='blue', y='cyan', z='violet',
                                  theta='red', phi='orange', psi='green'} }
  io.write("press return to continue...")
  io.read()
end

local function plotxz (mtbl)
  if doplot ~= true then return end
  MAD.plot { table=mtbl, x1y1 = { x='z'} }
  io.write("press return to continue...")
  io.read()
end

-- regression test suite ------------------------------------------------------o

-- TODO: vary parameters nst, lw, sdir, tdir, spos, X0, A0, ...

TestGeomap = {}

function TestGeomap:setUp ()
  filesys.mkdir(rundir(''))
  self.optfmt = option.format
  option.format = "%-18.11g"
end

function TestGeomap:tearDown ()
  option.format = self.optfmt
end

function TestGeomap:testDrift ()
  local mflw, mtbl = mk_mflw('drift')
  local nst = 10
  local dft = E.drift 'dft' { l=1 }

    save(dft, mflw, 0)
  for i=1,nst do
    mflw.spos = mflw.spos + dft.l
    G.drift(dft, mflw, 1)
       save(dft, mflw, 1)
  end
  mtbl:write(rundir('geomap_drift'))
  assertEquals(#mtbl, nst+1)

  assertEquals(mtbl.    s[#mtbl], nst)
  assertEquals(mtbl.    x[#mtbl], 0  )
  assertEquals(mtbl.    y[#mtbl], 0  )
  assertEquals(mtbl.    z[#mtbl], nst)
  assertEquals(mtbl.theta[#mtbl], 0  )
  assertEquals(mtbl.phi  [#mtbl], 0  )
  assertEquals(mtbl.psi  [#mtbl], 0  )
  plotxz(mtbl)
end

function TestGeomap:testThin ()
  local mflw, mtbl = mk_mflw('thin')
  local nst = 20
  local dft = E.drift     'dft' { l=1 }
  local kck = E.multipole 'kck' { angle=2*pi/nst }

    save(dft, mflw, 0)
  for i=1,nst do
    mflw.spos = mflw.spos + dft.l
    G.drift(dft, mflw, 1)
       save(dft, mflw, 1)
    G.thin (kck, mflw, 1)
       save(kck, mflw, 1)
  end
  mtbl:write(rundir('geomap_thin'))
  assertEquals(#mtbl, 2*nst+1)

  assertEquals      (mtbl.    s[#mtbl], nst      )
  assertAlmostEquals(mtbl.    x[#mtbl], 0, 15*eps)
  assertEquals      (mtbl.    y[#mtbl], 0        )
  assertEquals      (mtbl.    z[#mtbl], 0        )
  assertEquals      (mtbl.theta[#mtbl], -2*pi    )
  assertEquals      (mtbl.phi  [#mtbl], 0        )
  assertEquals      (mtbl.psi  [#mtbl], 0        )
  plotxz(mtbl)
end

function TestGeomap:testThick ()
  local mflw, mtbl = mk_mflw('thick')
  local nst = 20
  local bnd = E.sbend 'sbend' { l=1, angle=2*pi/nst }

    save(bnd, mflw, 0)
  for i=1,nst do
    mflw.spos = mflw.spos + bnd.l
    G.thick(bnd, mflw, 1)
       save(bnd, mflw, 1)
  end
  mtbl:write(rundir('geomap_thick'))
  assertEquals(#mtbl, nst+1)

  assertEquals      (mtbl.    s[#mtbl], nst      )
  assertAlmostEquals(mtbl.    x[#mtbl], 0, 11*eps)
  assertEquals      (mtbl.    y[#mtbl], 0        )
  assertAlmostEquals(mtbl.    z[#mtbl], 0,  2*eps)
  assertEquals      (mtbl.theta[#mtbl], -2*pi    )
  assertEquals      (mtbl.phi  [#mtbl], 0        )
  assertEquals      (mtbl.psi  [#mtbl], 0        )
  plotxz(mtbl)
end

-- end ------------------------------------------------------------------------o
