--[=[
 o-----------------------------------------------------------------------------o
 |
 | Plot module regression tests
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 |          A. Bloch, aurelien.bloch at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide regression test suites for the plot module.

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local drift, marker, sbend, quadrupole, sequence, bline,
      instrument, translation, srotation, sextupole,
      octupole, decapole, solenoid, kicker, vkicker, rbend,
      tkicker, hkicker, elseparator, rfcavity, twcavity,
      collimator, crabcavity, combined                      in MAD.element
local tkicker                                               in MADX
local assertNotNil, assertEquals                            in MAD.utest
local Object, plot, gplot, mtable, vector, filesys, atexit  in MAD
local sequence, marker                                      in MAD.element
local observe                                               in MAD.element.flags
local tblcpy                                                in MAD.utility

local toolbox  = require "toolbox"
local generate = false                           -- false | true | "pdf" | "wxt"
local refdir   = \s -> "plot_ref/"..s
local rundir   = \s -> "plot_run/"..s
local id       = 0
local plotTest, reset                            -- Parametrized plot command
local bmtbl, lmtbl, seq                          -- data

-- helpers --------------------------------------------------------------------o

local function newSID ()
  id = id % 25 + 1
  return id
end

local function setPlotTest ()
  if plotTest then return end
  if generate == "pdf" then
    plotTest = plot "plotTest" { output = rundir("tests.pdf"), exec = false }
    reset    = \ gplot:write("reset")
    atexit(io.read)
  elseif generate == "wxt" then
    plotTest = plot "plotTest" { sid = newSID, exec = false }
    reset    = \ gplot:write("reset")
    atexit(io.read)
  else
    reset    = \ ()
    plotTest = plot "plotTest" { output = false, exec = false }
  end
end

local function loadLHC ()
  local lhcb1, lhcb2 = toolbox.loadLHC()
  lhcb1:select(observe)
  lhcb2:select(observe)
  assert(loadfile("../share/LHC/opt_inj.mad"),"unable to load the LHC opt_inj")()
  return lhcb1, lhcb2
end

local function createTbl ()
  if bmtbl then return end
  bmtbl = mtable { {"name"}, "x", "y", "z" }
  lmtbl = mtable { {"name"}, "x1", "x2", "y1", "y2", "y3", "y4" }
  for i=1, 25000 do
    bmtbl = bmtbl + {"A" .. i, i, i, 2*i+100 }
  end
  for i=1, 25 do
    lmtbl = lmtbl + {"A" .. i, i, i+10, i, i+10, i+20, i+30 }
  end
end

local function createSeq ()
  if seq then return end
  seq = sequence 'seq' {
    refer = 'entry',
    marker 'start'            { at = 1                              },
    srotation 'srotation'     { at = 5,   l = 3                     },
    translation 'translation' { at = 10,  l = 3                     },
    quadrupole 'quadrupole'   { at = 15,  l = 3, k1 = -1            },
    quadrupole 'quadrupole'   { at = 20,  l = 3, k1 = 1             },
    sextupole 'sextupole'     { at = 25,  l = 3, k2 = -1            },
    sextupole 'sextupole'     { at = 30,  l = 3, k2 =  1            },
    octupole 'octupole'       { at = 35,  l = 3, k3 = -1            },
    octupole 'octupole'       { at = 40,  l = 3, k3 =  1            },
    decapole 'decapole'       { at = 45,  l = 3, k4 = -1            },
    decapole 'decapole'       { at = 50,  l = 3, k4 =  1            },
    solenoid 'solenoid'       { at = 55,  l = 3, ks = -1            },
    solenoid 'solenoid'       { at = 60,  l = 3, ks =  1            },
    sbend 'sbend'             { at = 65,  l = 3, angle = -1         },
    sbend 'sbend'             { at = 70,  l = 3, angle = 1          },
    combined 'combined'       { at = 75,  l = 3, angle = 1, k1 = -1 },
    combined 'combined'       { at = 80,  l = 3, angle = 1, k1 =  1 },
    combined 'combined'       { at = 85,  l = 3, angle =-1, k1 = -1 },
    combined 'combined'       { at = 90,  l = 3, angle =-1, k1 =  1 },
    rbend 'rbend'             { at = 95,  l = 3                     },
    kicker 'kicker'           { at = 100, l = 3                     },
    tkicker 'tkicker'         { at = 105, l = 3, kind='tkicker'     },
    hkicker 'hkicker'         { at = 110, l = 3                     },
    vkicker 'vkicker'         { at = 115, l = 3                     },
    elseparator 'elseparator' { at = 120, l = 3                     },
    instrument 'instrument'   { at = 125, l = 3                     },
    rfcavity 'rfcavity'       { at = 130, l = 3                     },
    twcavity 'twcavity'       { at = 135, l = 3                     },
    crabcavity 'crabcavity'   { at = 140, l = 3                     },
    collimator 'collimator'   { at = 145, l = 3                     },
    drift 'drift'             { at = 150                            },
    marker 'end'              { at = 155                            },
  }
end

local function assertFiles (name)
  if generate then return end
  local ref     = assert(io.open(refdir(name), "r"))
  local run     = assert(io.open(rundir(name), "r"))
  local line    = 1
  while true do
    local refline  = ref:read("*line")
    local runline = run:read("*line")
    if refline == nil or runline == nil then break end
    if refline ~= runline then
      error(
        "expected: '" .. refline ..
        "', actual: '" .. runline ..
        "' at line: " .. line
      )
    end
    line = line + 1
  end
  if not generate then os.remove(rundir(name)) end
end

local function getEmptyPlot (name)
  return plotTest {
    title   = name,
    scrdump = rundir(name),
    exec    = false,
  }
end

-- regression test suite ------------------------------------------------------o

TestPlot = {}

function TestPlot:setUp ()
  createTbl()
  createSeq()
  setPlotTest()
  filesys.mkdir(rundir(""))
  self.id = 1
  reset()
end

function TestPlot:tearDown ()
  if not generate and self.testPassed then filesys.rmdir(rundir("")) end
end

function TestPlot:execTest (param)
  local name = self.testName .. self.id
  getEmptyPlot(name)(param)
  assertFiles(name)
  self.id = self.id + 1
end

function TestPlot:testEmptyPlot ()
  local param = { }
  self:execTest(param)
end

function TestPlot:testPrologEpilog ()
  local param = {
    prolog = "set multi",
    epilog = "unset multi",
  }
  self:execTest(param)
end

function TestPlot:testDataSelection ()
  local param1 = {table = lmtbl, x1y1 = { x1 = {"y1", "y2"}, x2 = {"y3", "y4"}}}
  local param2 = {table = lmtbl, x1y1 = { x1 = {"y1", "y2"}, x2 = "y3"}        }
  local param3 = {table = lmtbl, x1y1 = { x2 = {"y1", "y2"}, "y3"},            }
  local param4 = {table = lmtbl, x1y1 = { x1 = {"y1", "y2"}},                  }
  local param5 = {table = lmtbl, x1y1 = { x2 = "y1", "y2"},                    }
  local param6 = {table = lmtbl, x1y1 = { x1 = "y1"},                          }
  local param7 = {table = lmtbl, x1y1 = {"y1", "y2"},                          }
  local param8 = {table = lmtbl, x1y1 =  "y1",                                 }
  self:execTest(param1)
  self:execTest(param2)
  self:execTest(param3)
  self:execTest(param4)
  self:execTest(param5)
  self:execTest(param6)
  self:execTest(param7)
  self:execTest(param8)
end

function TestPlot:testAxisSelection ()
  local param1 = { table = lmtbl, x1y1 = { x1 = "y1" }, x1y2 = { x1 = "y2" } }
  local param2 = { table = lmtbl, x1y1 = { x1 = "y1" }, x2y1 = { x2 = "y2" } }
  local param3 = { table = lmtbl, x1y2 = { x1 = "y1" }, x2y1 = { x2 = "y2" } }
  local param4 = { table = lmtbl, x1y1 = { x1 = "y1" }, x2y2 = { x2 = "y2" } }
  local param5 = { table = lmtbl, x1y1 = { x1 = "y1" }, x2y2 = { x2 = "y2" },
                                  x1y2 = { x1 = "y3" }, x2y1 = { x2 = "y4" } }
  self:execTest(param1)
  self:execTest(param2)
  self:execTest(param3)
  self:execTest(param4)
  self:execTest(param5)
end

function TestPlot:testAxisLabel ()
  local param = {
    table   = lmtbl,
    x1y1    = { x1 = "y1" },
    x2y2    = { x2 = "y2" },
    xlabel  = "label X",
    x2label = "label X2",
    ylabel  = "label Y",
    y2label = "label Y2",
  }
  self:execTest(param)
end

function TestPlot:testAxisRange ()
  local param = {
    table   = lmtbl,
    x1y1    = { x1 = "y1" },
    x2y2    = { x2 = "y2" },
    xrange  = { 7  ,  12  },
    x2range = { 27 ,  32  },
    yrange  = { 8  ,  11  },
    y2range = { 28 ,  31  },
  }
  self:execTest(param)
end

function TestPlot:testTableOrData ()
  local x1, y2 = table.new(25,0), vector(25)
  for i=1,25 do
    x1[i] = 11 + i
    y2[i] = 22 + i
  end
  local param = {
    table = lmtbl,
    data  = { x1 = x1  , y2 = y2   },
    x1y1  = { x1 = "y1", x2 = "y2" },
  }
  self:execTest(param)
end

function TestPlot:testTableRange ()
  local x1, y1 = table.new(11,0),table.new(11,0)
  for i=1,11 do
    x1[i] = 41 + i
    y1[i] = 41 + i
  end
  local param1 = {
    table      = lmtbl,
    data       = { x1 = x1   },
    x1y1       = { x1 = "y1" },
    tablerange = { 13, 23    },
  }
  local param2 = {
    table      = lmtbl,
    data       = { y1 = y1   },
    x1y1       = { x1 = "y1" },
    tablerange = { 13, 23    },
  }
  self:execTest(param1)
  self:execTest(param2)
end

function TestPlot:testLegend ()
  local param = {
    table  = lmtbl,
    x1y1   = { x1 = {"y1", "y2" } },
  }
  param.legend = false                    ; self:execTest(tblcpy(param))
  param.legend = nil                      ; self:execTest(tblcpy(param))
  param.legend = {y1="legend1"}           ; self:execTest(tblcpy(param))
  param.legend = {y1="legend1", y2=false} ; self:execTest(tblcpy(param))
end

function TestPlot:testTitle ()
  local name    = self.testName .. self.id
  local pattern = "set title 'plotTest MAD %d+.%d+.%d+, %d+/%d+/%d+, %d+:%d+:%d+'"
  local line

  plotTest { scrdump = rundir(name), table = lmtbl, x1y1 = "y1" }

  local file = assert(io.open(rundir(name), "r"))
  repeat
    line = file:read("*line")
    if line and (string.find(line, pattern)) then
      if not generate then os.remove(rundir(name)) end
      return
    end
  until not line

  error("Default title doesn't contain : version, date, time")
end

function TestPlot:testPlotDecoration ()
  local param = {
    table      = lmtbl,
    x1y1       = { x1 = {"y1", "y4" } },
    font       = "Comic Sans MS",
    fontsize   = 31,              -- Not in script because no terminal are set
    titlefont  = "Arial Black",   -- Same (TODO with gnuplot ?)
    titlesize  = 21,
    legend = {
      y1 = "legend1 {/Symbol b} + \u{03b2}",
      y4 = "legend2 {/Symbol B} + \u{0392}",
    },
    legendfont = "Copperplate",
    legendsize = 11,
    legendpos  = "bottom right",
    grid       = false,
    border     = 3,
  }
  self:execTest(param)
end

function TestPlot:testPlotDataStyle ()
  local param1 = {
    table      = lmtbl,
    x1y1       = { x1 = {"y1", "y3", "y4" } },
    originx    = 0.3,
    originy    = 0.4,
    psizex     = 0.7,
    psizey     = 0.6,
    styles     = { y1 = "lines", y3 = "points", y4 = "linespoints" },
    colors     = { y1 = "red"  , y3 = "blue"  , y4 = "green"       },
    dashtypes  = { y1 = "..   ",                y4 = "--  "        },
    linewidths = { y1 = 2.3    ,                y4 = 3.2           },
    pointtypes = {               y3 = 2       , y4 = 3             },
    pointsizes = {               y3 = 2.0     , y4 = 4.1           },
  }
  local param2 = {
    table      = lmtbl,
    x1y1       = { x1 = {"y1", "y3", "y4" } },
    originx    = 0.3,
    originy    = 0.4,
    psizex     = 0.7,
    psizey     = 0.6,
    datastyles = {
      y1 = { style="lines", color="red", dashtype="..   ", linewidth=2.3 },
      y3 = { style="points", color="blue", pointtype=2, pointsize=2.0 },
      y4 = {
        style="linespoints", color="green", dashtype="--  ",
        linewidth=3.2, pointtype=3, pointsize=4.1
      }
    }
  }
  local param3 = {
    table      = lmtbl,
    x1y1       = { x1 = {"y1", "y4" } },
    styles     = "linespoints",
    colors     = "black",
    dashtypes  = ".-.-",
    linewidths = 4,
    pointtypes = 2,
    pointsizes = 3,
  }
  self:execTest(param1)
  self:execTest(param2)
  self:execTest(param3)
end

function TestPlot:testPlotConfig ()
  local data = {
    c1 = {6, 3, 0, 0, 0, 0}, c2 = {5, 2, 0, 0, 0, 1}, c3 = {4, 2, 0, 0, 1, 2},
    c4 = {3, 0, 0, 0, 2, 3}, c5 = {1, 0, 1, 2, 4, 4}, c6 = {0, 1, 0, 3, 3, 5},
  }
  local param1 = { -- simple splot example
    data    = data,
    x1y1    = { c1 = {'c2', 'c3', 'c4', 'c5', 'c6'} },
    plotcfg = "set pm3d map",
    plotcmd = "splot ${data1} matrix",
  }
  local param2 = { -- test all available interpolation variables + plotvar
    table      = lmtbl,
    x1y1       = { x1 = {"y1", "y3", "y4" } },
    styles     = { y1 = "lines", y3 = "points", y4 = "linespoints" },
    colors     = { y1 = "red"  , y3 = "blue"  , y4 = "green"       },
    dashtypes  = { y1 = "..   ",                y4 = "--  "        },
    linewidths = { y1 = 2.3    ,                y4 = 3.2           },
    pointtypes = {               y3 = 2       , y4 = 3             },
    pointsizes = {               y3 = 2.0     , y4 = 4.1           },
    plotvar    = { color3 ="linecolor 'pink' " },
    plotcmd    = "\z
      ${cmd1}${data1}${index1}${using1}with ${style1}${lines1}${points1}${color1}${title1}${axes1},\\\n\z
      ${cmd2}${data2}${index2}${using2}with ${style2}${lines2}${points2}${color2}${title2}${axes2},\\\n\z
      ${cmd3}${data3}${index3}${using3}with ${style3}${lines3}${points3}${color3}${title3}${axes3},\\\n\z
    "
  }
  -- TODO
  -- local T = \s\ctx -> s % ctx
  -- local param3 = { -- plotvar + fix-points
  --   table   = lmtbl,
  --   x1y1    = "y1",
  --   plotvar = Object { color3 = T"linecolor 'pink' " },
  -- }
  self:execTest(param1)
  self:execTest(param2)
  -- self:execTest(param3)
  -- io.read()
end

function TestPlot:testObjectShift ()
  local param = {
    sequence = sequence { l = 10, marker "middle" { at = 5 } },
    oshft    = 11,
  }
  self:execTest(param)
end

function TestPlot:testAllShapes ()
  local param = { sequence = seq, table = lmtbl, x1y1 = "y1" }
  self:execTest(param)
end

function TestPlot:testLaypos ()
  local param  = { sequence = seq, table = lmtbl, x1y1 = "y1" }
  param.laypos = "top"    ; self:execTest(tblcpy(param))
  param.laypos = "middle" ; self:execTest(tblcpy(param))
  param.laypos = "bottom" ; self:execTest(tblcpy(param))
  param.laypos = 0.25     ; self:execTest(tblcpy(param))
end

function TestPlot:testLaysize ()
  local param  = { sequence = seq, table = lmtbl, x1y1 = "y1", laysize=0.5 }
  param.laypos = "top"    ; self:execTest(tblcpy(param))
  param.laypos = "middle" ; self:execTest(tblcpy(param))
  param.laypos = "bottom" ; self:execTest(tblcpy(param))
  param.laypos = 0.25     ; self:execTest(tblcpy(param))
end

function TestPlot:testElemName ()
  local param  = { sequence = seq, table = lmtbl, x1y1 = "y1" }
  param.elemname = true  ; self:execTest(tblcpy(param))
  param.elemname = false ; self:execTest(tblcpy(param))
end

function TestPlot:testKindColor ()
  local param  = { sequence = seq, table = lmtbl, x1y1 = "y1" }
  param.kindcolor = true  ; self:execTest(tblcpy(param))
  param.kindcolor = false ; self:execTest(tblcpy(param))
  param.kindcolor = {
    quadrupole = "blue",
    sbend      = { fillcolor = "red"  ,                         },
    rbend      = {                      fillstyle = "pattern 1" },
    instrument = { fillcolor = "green", fillstyle = "pattern 2" },
  } ;
  self:execTest(tblcpy(param))
end

function TestPlot:testSeqOnly ()
  local param = { sequence = seq }
  self:execTest(param)
end

function TestPlot:testSeqRange()
  local param = { sequence = seq, table = lmtbl, x1y1 = "y1" }
  param.range = { "quadrupole", "elseparator" } ; self:execTest(tblcpy(param))
  param.range = { 15          , 120           } ; self:execTest(tblcpy(param))
end

function TestPlot:testSeqDist ()
  local param = { sequence = { seq, seq, seq }, table = lmtbl, x1y1 = "y1" }
  param.seqdisty = 0.2          ; self:execTest(tblcpy(param))
  param.seqdisty = { 0.2, 0.4 } ; self:execTest(tblcpy(param))
  param.seqdistx = 10           ; self:execTest(tblcpy(param))
  param.seqdistx = { 5  , 10  } ; self:execTest(tblcpy(param))
  param.seqshift = 20           ; self:execTest(tblcpy(param))
  param.seqshift = 20           ; self:execTest(tblcpy(param))
end

function TestPlot:testSeqNturn ()
  local param = { sequence = seq, table = lmtbl, x1y1 = "y1", nturn = 1 }
  self:execTest(param)
end

function TestPlot:testElemSize ()
  local lhcb1, lhcb2 = loadLHC()
  local param = {
    table    = lmtbl,
    x1y1     = "y1",
    sequence = { lhcb1, lhcb2 },
    range    = { {"E.DS.L1.B1", "S.DS.R1.B1"}, {"E.DS.L1.B2", "S.DS.R1.B2"} },
    seqdisty = lhcb2["E.DS.L1.B2"].mech_sep,
  }
  self:execTest(tblcpy(param, nil, { elemscale = 2   }))
  self:execTest(tblcpy(param, nil, { elemwidth = 0.2 }))
end

function TestPlot:testElemFilter()
  local lhcb1, lhcb2 = loadLHC()
  local param = {
    table    = lmtbl,
    x1y1     = "y1",
    sequence = { lhcb1, lhcb2 },
    range    = { {"E.DS.L1.B1", "S.DS.R1.B1"}, {"E.DS.L1.B2", "S.DS.R1.B2"} },
    seqdisty = lhcb2["E.DS.L1.B2"].mech_sep
  }
  self:execTest(tblcpy(param, nil, { kindselect = {"quadrupole", "sbend"} }))
  self:execTest(tblcpy(param, nil, { elemminlen = 1 }))
end

function TestPlot:testLayangle()
  local lhcb1 = loadLHC()
  local param = {
    table    = lmtbl,
    x1y1     = "y1",
    sequence = lhcb1,
    range    = {"E.DS.L1.B1", "S.DS.R1.B1"},
  }
  param.layangle = true  ; self:execTest(tblcpy(param))
  param.layangle = false ; self:execTest(tblcpy(param))
end

function TestPlot:testIP1IP5 ()
  local lhcb1, lhcb2 = loadLHC()
  local param = {
    table    = lmtbl,
    x1y1     = "y1",
    sequence = { lhcb1, lhcb2, lhcb1, lhcb2 },
    range    = {
      {"E.DS.L1.B1", "S.DS.R1.B1"},{"E.DS.L1.B2", "S.DS.R1.B2"},
      {"E.DS.L5.B1", "S.DS.R5.B1"},{"E.DS.L5.B2", "S.DS.R5.B2"},
    },
    seqdisty = {
      lhcb2["E.DS.L1.B2"].mech_sep,
      -0.4,
      -0.4 + lhcb2['E.DS.L5.B2'].mech_sep
    },
  }
  self:execTest(param)
end

function TestPlot:testLHC ()
  local lhcb1, lhcb2 = loadLHC()
  local param = {
    sequence = { lhcb1, lhcb2 },
    table    = bmtbl,
    x1y1     = { x = "y" },
  }
  self:execTest(param)
end

function TestPlot:testLHCInPlot ()
  local lhcb1, lhcb2 = loadLHC()
  local param = {
    sequence = { lhcb1, lhcb2 },
    laypos   = "in",
  }
  self:execTest(param)
end

-- end ------------------------------------------------------------------------o
