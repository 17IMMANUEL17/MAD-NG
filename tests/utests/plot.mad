--[=[
 o-----------------------------------------------------------------------------o
 |
 | Plot module regression tests
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 |          A. Bloch, aurelien.bloch at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide regression test suites for the plot module.

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local assertNotNil, assertEquals                            in MAD.utest
local plot, gplot, mtable, vector                           in MAD
local sequence, marker                                      in MAD.element
local observe                                               in MAD.element.flags
local is_sequence                                           in MAD.typeid

local toolbox  = require 'toolbox'
local generate = false
local refdir   = \s -> 'plot_ref/'..s
local rundir   = \s -> 'plot_run/'..s
local bmtbl, lmtbl

-- helpers --------------------------------------------------------------------o

local function loadLHC ()
  local lhcb1, lhcb2 = toolbox.loadLHC()
  lhcb1:select(observe)
  lhcb2:select(observe)
  return lhcb1, lhcb2
end

local function createTbl ()
  if bmtbl then return end
  bmtbl = mtable { {'name'}, 'x', 'y', 'z' }
  lmtbl = mtable { {'name'}, 'x1', 'x2', 'y1', 'y2', 'y3', 'y4' }
  for i=1, 25000 do
    bmtbl = bmtbl + {'A' .. i, i, i, 2*i+100 }
  end
  for i=1, 25 do
    lmtbl = lmtbl + {'A' .. i, i, i+10, i, i+10, i+20, i+30 }
  end
end

local function assertFiles (name)
  if generate then return end
  local ref  = assert(io.open(refdir(name), "r"))
  local test = assert(io.open(rundir(name), "r"))
  local line = 1
  while true do
    local refline  = ref:read("*line")
    local testline = test:read("*line")
    if refline == nil or testline == nil then break end
    if refline ~= testline then
      error(
        "expected: '" .. refline ..
        "', actual: '" .. testline ..
        "' at line: " .. line
      )
    end
    line = line + 1
  end
  if not generate then os.remove(rundir(name)) end
end

local function getEmptyPlot (name)
  return plot {
    title   = name,
    output  = false,
    scrdump = rundir(name),
    exec    = false,
  }
end

local function execTest (name, param)
  getEmptyPlot(name)(param)
  assertFiles(name)
end

-- regression test suite ------------------------------------------------------o

TestPlot = {}

function TestPlot:setUp ()
  createTbl()
  os.execute("mkdir -p " .. rundir(''))         -- TODO Cleaner + cross platform
end

function TestPlot:tearDown ()
  if not generate then os.remove(rundir('')) end
end

function TestPlot:testEmptyPlot ()
  local param = { }
  execTest("testEmptyPlot", param)
end

function TestPlot:testPrologEpilog ()
  local param = {
    prolog = "set multi",
    epilog = "unset multi \nunset out",
  }
  execTest("testPrologEpilog", param)
end

function TestPlot:testAxisName ()
  local param1 = {table = lmtbl, x1y1 = { x1 = {'y1', 'y2'}, x2 = {'y3', 'y4'}}}
  local param2 = {table = lmtbl, x1y1 = { x1 = {'y1', 'y2'}, x2 = 'y3'}        }
  local param3 = {table = lmtbl, x1y1 = { x1 = {'y1', 'y2'}},                  }
  local param4 = {table = lmtbl, x1y1 = { x1 = 'y1'},                          }
  local param5 = {table = lmtbl, x1y1 = {'y1', 'y2'},                          }
  local param6 = {table = lmtbl, x1y1 =  'y1',                                 }
  execTest("testAxisName1", param1)
  execTest("testAxisName2", param2)
  execTest("testAxisName3", param3)
  execTest("testAxisName4", param4)
  execTest("testAxisName5", param5)
  execTest("testAxisName6", param6)
end

function TestPlot:testAxisSelection ()
  local param1 = { table = lmtbl, x1y1 = { x1 = 'y1' }, x1y2 = { x1 = 'y2' } }
  local param2 = { table = lmtbl, x1y1 = { x1 = 'y1' }, x2y1 = { x2 = 'y2' } }
  local param3 = { table = lmtbl, x1y2 = { x1 = 'y1' }, x2y1 = { x2 = 'y2' } }
  local param4 = { table = lmtbl, x1y1 = { x1 = 'y1' }, x2y2 = { x2 = 'y2' } }
  local param5 = { table = lmtbl, x1y1 = { x1 = 'y1' }, x2y2 = { x2 = 'y2' },
                                  x1y2 = { x1 = 'y3' }, x2y1 = { x2 = 'y4' } }
  execTest("testAxisSelection1", param1)
  execTest("testAxisSelection2", param2)
  execTest("testAxisSelection3", param3)
  execTest("testAxisSelection4", param4)
  execTest("testAxisSelection5", param5)
end

function TestPlot:testAxisLabel ()
  local param = {
    table   = lmtbl,
    x1y1    = { x1 = 'y1' },
    x2y2    = { x2 = 'y2' },
    xlabel  = "label X",
    x2label = "label X2",
    ylabel  = "label Y",
    y2label = "label Y2",
  }
  execTest("testAxisLabel", param)
end

function TestPlot:testAxisRange ()
  local param = {
    table   = lmtbl,
    x1y1    = { x1 = 'y1' },
    x2y2    = { x2 = 'y2' },
    xrange  = { 7  ,  12  },
    x2range = { 27 ,  32  },
    yrange  = { 8  ,  11  },
    y2range = { 28 ,  31  },
  }
  execTest("testAxisRange", param)
end

function TestPlot:testTableOrData ()
  local x1, y2 = table.new(25,0), vector(25)
  for i=1,25 do
    x1[i] = 11 + i
    y2[i] = 22 + i
  end
  local param = {
    table = lmtbl,
    data  = { x1 = x1  , y2 = y2   },
    x1y1  = { x1 = 'y1', x2 = 'y2' },
  }
  execTest("testTableOrData", param)
end

function TestPlot:testTableRange ()
  local x1, y1 = table.new(11,0),table.new(11,0)
  for i=1,11 do
    x1[i] = 41 + i
    y1[i] = 41 + i
  end
  local param1 = {
    table      = lmtbl,
    data       = { x1 = x1   },
    x1y1       = { x1 = 'y1' },
    tablerange = { 13, 23    },
  }
  local param2 = {
    table      = lmtbl,
    data       = { y1 = y1   },
    x1y1       = { x1 = 'y1' },
    tablerange = { 13, 23    },
  }
  execTest("testTableRange1", param1)
  execTest("testTableRange2", param2)
end

function TestPlot:testPlotDecoration()
  local param = {
    table       = lmtbl,
    x1y1        = { x1 = {'y1', 'y4' } },
    font        = "Comic Sans MS",
    fontsize    = 31,              -- Not in script because no terminal are set
    titlefont   = "Arial Black",   -- Same (TODO with gnuplot ?)
    titlesize   = 21,
    legend = {
      y1="legend1 {/Symbol b} + \u{03b2}",
      y4="legend2 {/Symbol B} + \u{0392}",
    },
    legendfont  = "Copperplate",
    legendsize  = 11,
    legendpos   = "bottom right",
    grid        = false,
    border      = 3,
  }
  execTest("testPlotDecoration", param)
end

function TestPlot:testPlotStyle()
  local param1 = {
    table      = lmtbl,
    x1y1       = { x1 = {'y1', 'y3', 'y4' } },
    originx    = 0.3,
    originy    = 0.4,
    psizex     = 0.7,
    psizey     = 0.6,
    styles     = { y1 = "lines", y3 = "points", y4 = "linespoints" },
    colors     = { y1 = 'red'  , y3 = "blue"  , y4 = 'green'       },
    dashtypes  = { y1 = "..   ",                y4 = "--  "        },
    linewidths = { y1 = 2.3    ,                y4 = 3.2           },
    pointtypes = {               y3 = 2       , y4 = 3             },
    pointsizes = {               y3 = 2.0     , y4 = 4.1           },
  }
  local param2 = {
    table      = lmtbl,
    x1y1       = { x1 = {'y1', 'y4' } },
    styles     = 'linespoints',
    colors     = 'black',
    dashtypes  = '.-.-',
    linewidths = 4,
    pointtypes = 2,
    pointsizes = 3,
  }
  execTest("testPlotStyle1", param1)
  execTest("testPlotStyle2", param2)
end

function TestPlot:testObjectShift ()
  local param = {
    sequence = sequence { l = 10, marker 'middle' { at = 5 } },
    oshft    = 11,
  }
  execTest("testObjectShift", param)
end

function TestPlot:testLHC()
  local lhcb1, lhcb2 = loadLHC()
  local param = {
    sequence = { lhcb1, lhcb2 },
    table    = bmtbl,
    x1y1     = { x = 'y' },
  }
  local flg  = MADX.option.warn
  MADX.option.warn = false
    execTest("testLHC", param)
  MADX.option.warn = flg
end

function TestPlot:testLHCInPlot ()
  local lhcb1, lhcb2 = loadLHC()
  local param = {
    sequence = { lhcb1, lhcb2 },
    laypos   = "in",
  }
  local flg  = MADX.option.warn
  MADX.option.warn = false
  execTest("testLHCInPlot", param)
  MADX.option.warn = flg
end

-- end ------------------------------------------------------------------------o
