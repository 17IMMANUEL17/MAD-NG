--[=[
 o-----------------------------------------------------------------------------o
 |
 | Plot module regression tests
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 |          A. Bloch, aurelien.bloch at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide regression test suites for the plot module.

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local drift, marker, sbend, quadrupole, sequence, bline,
      instrument, translation, srotation, sextupole,
      octupole, decapole, solenoid, kicker, vkicker, rbend,
      tkicker, hkicker, elseparator, rfcavity, twcavity,
      collimator, crabcavity, combined                            in MAD.element
local tkicker                                                     in MADX
local assertNotNil, assertNotEquals, assertEquals,
      assertErrorMsgContains, assertTrue, assertFalse,
      assertAlmostEquals                                          in MAD.utest
local Object, plot, gplot, mtable, vector, filesys, atexit        in MAD
local flags, sequence, marker                                     in MAD.element
local observe                                                     in flags
local tblcpy, fileexists, sleep                                   in MAD.utility
local pi, eps, min, abs                                           in MAD.gmath
local is_number                                                   in MAD.typeid

local toolbox  = require "toolbox"
local generate = false                           -- false | true | "pdf" | "wxt"
local refdir   = \s -> "plot_ref/"..(s or '')
local rundir   = \s -> "plot_run/"..(s or '')
local id       = 0
local plotTest, reset                            -- Parametrized plot command
local bmtbl, lmtbl, seq                          -- data

-- helpers --------------------------------------------------------------------o

local function newSID ()
  id = id % 25 + 1
  return id
end

local function setPlotTest ()
  if plotTest then return end
  if generate == "pdf" then
    plotTest = plot "plotTest" { output = rundir("tests.pdf"), exec = false }
    reset    = \ gplot:write("reset")
    atexit(io.read)
  elseif generate == "wxt" then
    plotTest = plot "plotTest" { sid = newSID, exec = false }
    reset    = \ ()
    atexit(io.read)
  else
    reset    = \ ()
    plotTest = plot "plotTest" { output = false, exec = false }
  end
end

local function loadLHC ()
  local lhcb1, lhcb2 = toolbox.loadLHC()
  lhcb1:select(observe)
  lhcb2:select(observe)
  assert(loadfile("../share/LHC/opt_inj.mad"),"unable to load the LHC opt_inj")()
  return lhcb1, lhcb2
end

local function createTbl ()
  if bmtbl then return end
  bmtbl = mtable { {"name"}, "x", "y", "z" }
  lmtbl = mtable { {"name"}, "x1", "x2", "y1", "y2", "y3", "y4" }
  for i=1, 25000 do
    bmtbl = bmtbl + {"A" .. i, i, i, 2*i+100 }
  end
  for i=1, 25 do
    lmtbl = lmtbl + {"A" .. i, i, i+10, i, i+10, i+20, i+30 }
  end
end

local function createSeq ()
  if seq then return end
  seq = sequence "seq" {
    refer = "entry",
    marker      "start"       { at = 1                               },
    srotation   "srotation"   { at = 5,   l = 3                      },
    translation "translation" { at = 10,  l = 3                      },
    quadrupole  "quadrupole"  { at = 15,  l = 3, k1    = -1          },
    quadrupole  "quadrupole"  { at = 20,  l = 3, k1    = 1           },
    sextupole   "sextupole"   { at = 25,  l = 3, k2    = -1          },
    sextupole   "sextupole"   { at = 30,  l = 3, k2    = 1           },
    octupole    "octupole"    { at = 35,  l = 3, k3    = -1          },
    octupole    "octupole"    { at = 40,  l = 3, k3    = 1           },
    decapole    "decapole"    { at = 45,  l = 3, k4    = -1          },
    decapole    "decapole"    { at = 50,  l = 3, k4    = 1           },
    solenoid    "solenoid"    { at = 55,  l = 3, ks    = -1          },
    solenoid    "solenoid"    { at = 60,  l = 3, ks    = 1           },
    sbend       "sbend"       { at = 65,  l = 3, angle = -1          },
    sbend       "sbend"       { at = 70,  l = 3, angle = 1           },
    combined    "combined"    { at = 75,  l = 3, angle = 1 , k1 = -1 },
    combined    "combined"    { at = 80,  l = 3, angle = 1 , k1 =  1 },
    combined    "combined"    { at = 85,  l = 3, angle = -1, k1 = -1 },
    combined    "combined"    { at = 90,  l = 3, angle = -1, k1 =  1 },
    rbend       "rbend"       { at = 95,  l = 3                      },
    kicker      "kicker"      { at = 100, l = 3                      },
    tkicker     "tkicker"     { at = 105, l = 3, kind="tkicker"      },
    hkicker     "hkicker"     { at = 110, l = 3                      },
    vkicker     "vkicker"     { at = 115, l = 3                      },
    elseparator "elseparator" { at = 120, l = 3                      },
    instrument  "instrument"  { at = 125, l = 3                      },
    rfcavity    "rfcavity"    { at = 130, l = 3                      },
    twcavity    "twcavity"    { at = 135, l = 3                      },
    crabcavity  "crabcavity"  { at = 140, l = 3                      },
    collimator  "collimator"  { at = 145, l = 3                      },
    drift       "drift"       { at = 150                             },
    marker      "end"         { at = 155                             },
  }
end

local function assertFiles (name)
  if generate then return end
  local ref  = assert(io.open(refdir(name), "r"))
  local run  = assert(io.open(rundir(name), "r"))
  local reftbl, sref = string.splitall(ref:read("*all"), " \n,:;[]")
  local runtbl, srun = string.splitall(run:read("*all"), " \n,:;[]")
  assertEquals(srun, sref)
  for i=1,sref do
    reftbl[i] = tonumber(reftbl[i]) or reftbl[i]
    runtbl[i] = tonumber(runtbl[i]) or runtbl[i]
    if is_number(reftbl[i]) then
      local approx = abs(runtbl[i]-reftbl[i])
      if 14*eps < approx then
        local div = min(runtbl[i], reftbl[i])
        if div == 0 then
          assertAlmostEquals(approx, 0, 1.1e-5)
        else
          assertAlmostEquals((runtbl[i]-reftbl[i])/div, 0, 1.1e-6)
        end
      end
    else
      assertEquals(runtbl[i], reftbl[i])
    end
  end
  if not generate then os.remove(rundir(name)) end
end

local function getEmptyPlot (name)
  return plotTest {
    title   = name,
    scrdump = rundir(name),
    exec    = false,
  }
end

-- plot regression test suite -------------------------------------------------o

TestPlotScript = {}

function TestPlotScript:setUp ()
  createTbl()
  createSeq()
  setPlotTest()
  filesys.mkdir(rundir())
  self.id = 1
  reset()
end

function TestPlotScript:tearDown ()
  if not generate and self.testPassed then filesys.rmdir(rundir()) end
end

function TestPlotScript:execTest (param)
  local name = self.testName .. self.id
  getEmptyPlot(name)(param)
  assertFiles(name)
  self.id = self.id + 1
end

function TestPlotScript:testEmptyPlot ()
  local print_s = print
  print = \s -> assertEquals(s,
    "MAD Plot Warning : no scrdump nor output provided - Nothing done")
  plotTest { }
  print = print_s
end

function TestPlotScript:testEmptyPlotScript ()
  local param = { }
  self:execTest(param)
end

function TestPlotScript:testPrologEpilog ()
  local param = {
    prolog = "set multi",
    epilog = "unset multi",
  }
  self:execTest(param)
end

function TestPlotScript:testDataSelection ()
  local param1 = {table = lmtbl, x1y1 = { x1 = {"y1", "y2"}, x2 = {"y3", "y4"}}}
  local param2 = {table = lmtbl, x1y1 = { x1 = {"y1", "y2"}, x2 = "y3"}        }
  local param3 = {table = lmtbl, x1y1 = { x2 = {"y1", "y2"}, "y3"},            }
  local param4 = {table = lmtbl, x1y1 = { x1 = {"y1", "y2"}},                  }
  local param5 = {table = lmtbl, x1y1 = { x2 = "y1", "y2"},                    }
  local param6 = {table = lmtbl, x1y1 = { x1 = "y1"},                          }
  local param7 = {table = lmtbl, x1y1 = {"y1", "y2"},                          }
  local param8 = {table = lmtbl, x1y1 =  "y1",                                 }
  self:execTest(param1)
  self:execTest(param2)
  self:execTest(param3)
  self:execTest(param4)
  self:execTest(param5)
  self:execTest(param6)
  self:execTest(param7)
  self:execTest(param8)
end

function TestPlotScript:testAxisSelection ()
  local param1 = { table = lmtbl, x1y1 = { x1 = "y1" }, x1y2 = { x1 = "y2" } }
  local param2 = { table = lmtbl, x1y1 = { x1 = "y1" }, x2y1 = { x2 = "y2" } }
  local param3 = { table = lmtbl, x1y2 = { x1 = "y1" }, x2y1 = { x2 = "y2" } }
  local param4 = { table = lmtbl, x1y1 = { x1 = "y1" }, x2y2 = { x2 = "y2" } }
  local param5 = { table = lmtbl, x1y1 = { x1 = "y1" }, x2y2 = { x2 = "y2" },
                                  x1y2 = { x1 = "y3" }, x2y1 = { x2 = "y4" } }
  self:execTest(param1)
  self:execTest(param2)
  self:execTest(param3)
  self:execTest(param4)
  self:execTest(param5)
end

function TestPlotScript:testAxisLabel ()
  local param = {
    table   = lmtbl,
    x1y1    = { x1 = "y1" },
    x2y2    = { x2 = "y2" },
    xlabel  = "label X",
    x2label = "label X2",
    ylabel  = "label Y",
    y2label = "label Y2",
  }
  self:execTest(param)
end

function TestPlotScript:testAxisRange ()
  local param = {
    table   = lmtbl,
    x1y1    = { x1 = "y1" },
    x2y2    = { x2 = "y2" },
    xrange  = { 7  ,  12  },
    x2range = { 27 ,  32  },
    yrange  = { 8  ,  11  },
    y2range = { 28 ,  31  },
  }
  self:execTest(param)
end

function TestPlotScript:testTableOrData ()
  local x1, y2 = table.new(25,0), vector(25)
  for i=1,25 do
    x1[i] = 11 + i
    y2[i] = 22 + i
  end
  local param = {
    table = lmtbl,
    data  = { x1 = x1  , y2 = y2   },
    x1y1  = { x1 = "y1", x2 = "y2" },
  }
  self:execTest(param)
end

function TestPlotScript:testTableRange ()
  local x1, y1 = table.new(11,0),table.new(11,0)
  for i=1,11 do
    x1[i] = 41 + i
    y1[i] = 41 + i
  end
  local param1 = {
    table      = lmtbl,
    data       = { x1 = x1   },
    x1y1       = { x1 = "y1" },
    tablerange = { 13, 23    },
  }
  local param2 = {
    table      = lmtbl,
    data       = { y1 = y1   },
    x1y1       = { x1 = "y1" },
    tablerange = { 13, 23    },
  }
  self:execTest(param1)
  self:execTest(param2)
end

function TestPlotScript:testLegend ()
  local param = {
    table  = lmtbl,
    x1y1   = { x1 = {"y1", "y2" } },
  }
  param.legend = false                    ; self:execTest(tblcpy(param))
  param.legend = nil                      ; self:execTest(tblcpy(param))
  param.legend = {y1="legend1"}           ; self:execTest(tblcpy(param))
  param.legend = {y1="legend1", y2=false} ; self:execTest(tblcpy(param))
end

function TestPlotScript:testTitle ()
  local name    = self.testName .. self.id
  local pattern = "set title 'plotTest MAD %d+.%d+.%d+, %d+/%d+/%d+, %d+:%d+:%d+'"
  local line, file

  plotTest { scrdump = rundir(name), table = lmtbl, x1y1 = "y1" }

  local t0 = os.clock()
  while not file and os.clock() - t0 < 1 do
    file = io.open(rundir(name), "r")
    sleep(100)
  end
  repeat
    line = file:read("*line")
    if line and (string.find(line, pattern)) then
      if not generate then os.remove(rundir(name)) end
      return
    end
  until not line

  error("Default title doesn't contain : version, date, time")
end

function TestPlotScript:testPlotDecoration ()
  local param = {
    table      = lmtbl,
    x1y1       = { x1 = {"y1", "y4" } },
    titlefont  = "Arial Black",
    titlesize  = 21,
    legend = {
      y1 = "legend1 {/Symbol b} + \u{03b2}",
      y4 = "legend2 {/Symbol B} + \u{0392}",
    },
    legendfont = "Aclonica",
    legendsize = 11,
    legendpos  = "bottom right",
    grid       = false,
    border     = 3,
  }
  self:execTest(param)
end

function TestPlotScript:testPlotDataStyle ()
  local param1 = {
    table      = lmtbl,
    x1y1       = { x1 = {"y1", "y3", "y4" } },
    originx    = 0.3,
    originy    = 0.4,
    psizex     = 0.7,
    psizey     = 0.6,
    styles     = { y1 = "lines", y3 = "points", y4 = "linespoints" },
    colors     = { y1 = "red"  , y3 = "blue"  , y4 = "green"       },
    dashtypes  = { y1 = "..   ",                y4 = "--  "        },
    linewidths = { y1 = 2.3    ,                y4 = 3.2           },
    pointtypes = {               y3 = 2       , y4 = 3             },
    pointsizes = {               y3 = 2.0     , y4 = 4.1           },
  }
  local param2 = {
    table      = lmtbl,
    x1y1       = { x1 = {"y1", "y3", "y4" } },
    originx    = 0.3,
    originy    = 0.4,
    psizex     = 0.7,
    psizey     = 0.6,
    datastyles = {
      y1 = { style="lines", color="red", dashtype="..   ", linewidth=2.3 },
      y3 = { style="points", color="blue", pointtype=2, pointsize=2.0 },
      y4 = {
        style="linespoints", color="green", dashtype="--  ",
        linewidth=3.2, pointtype=3, pointsize=4.1
      }
    }
  }
  local param3 = {
    table      = lmtbl,
    x1y1       = { x1 = {"y1", "y4" } },
    styles     = "linespoints",
    colors     = "black",
    dashtypes  = ".-.-",
    linewidths = 4,
    pointtypes = 2,
    pointsizes = 3,
  }
  self:execTest(param1)
  self:execTest(param2)
  self:execTest(param3)
end

function TestPlotScript:testPlotConfig ()
  local data = {
    c1 = {6, 3, 0, 0, 0, 0}, c2 = {5, 2, 0, 0, 0, 1}, c3 = {4, 2, 0, 0, 1, 2},
    c4 = {3, 0, 0, 0, 2, 3}, c5 = {1, 0, 1, 2, 4, 4}, c6 = {0, 1, 0, 3, 3, 5},
  }
  local param1 = { -- simple splot example
    data    = data,
    x1y1    = { c1 = {"c2", "c3", "c4", "c5", "c6"} },
    plotcfg = "set pm3d map",
    plotcmd = "splot ${data1} matrix",
  }
  local param2 = { -- test all available interpolation variables + plotvar
    table      = lmtbl,
    x1y1       = { x1 = {"y1", "y3", "y4" } },
    styles     = { y1 = "lines", y3 = "points", y4 = "linespoints" },
    colors     = { y1 = "red"  , y3 = "blue"  , y4 = "green"       },
    dashtypes  = { y1 = "..   ",                y4 = "--  "        },
    linewidths = { y1 = 2.3    ,                y4 = 3.2           },
    pointtypes = {               y3 = 2       , y4 = 3             },
    pointsizes = {               y3 = 2.0     , y4 = 4.1           },
    plotvar    = { color3 ="linecolor 'pink' " },
    plotcmd    = "\z
      ${cmd1}${data1}${index1}${using1}with ${style1}${lines1}${points1}${color1}${title1}${axes1},\\\n\z
      ${cmd2}${data2}${index2}${using2}with ${style2}${lines2}${points2}${color2}${title2}${axes2},\\\n\z
      ${cmd3}${data3}${index3}${using3}with ${style3}${lines3}${points3}${color3}${title3}${axes3},\\\n\z
    "
  }
  local T = \s\ctx -> s % ctx
  local param3 = { -- plotvar + lambda T resolution example
    table   = lmtbl,
    x1y1    = {"y1", "y2"},
    plotvar = {
      title2  = T"title '${mytitle}' ",
      mytitle = T"title for command (${cmd1}) on axes (${axes2})",
    },
  }
  self:execTest(param1)
  self:execTest(param2)
  self:execTest(param3)
end

function TestPlotScript:testObjectShift ()
  local param = {
    sequence = sequence { l = 10, marker "middle" { at = 5 } },
    oshft    = 11,
  }
  self:execTest(param)
end

function TestPlotScript:testAllShapes ()
  local param = { sequence = seq, table = lmtbl, x1y1 = "y1" }
  self:execTest(param)
end

function TestPlotScript:testLaypos ()
  local param  = { sequence = seq, table = lmtbl, x1y1 = "y1" }
  param.laypos = 0.25     ; self:execTest(tblcpy(param)) -- order matters
  param.laypos = "middle" ; self:execTest(tblcpy(param))
  param.laypos = "top"    ; self:execTest(tblcpy(param))
  param.laypos = "bottom" ; self:execTest(tblcpy(param))
end

function TestPlotScript:testLaysize ()
  local param  = { sequence = seq, table = lmtbl, x1y1 = "y1", laysize=0.5 }
  param.laypos = 0.25     ; self:execTest(tblcpy(param)) -- order matters
  param.laypos = "middle" ; self:execTest(tblcpy(param))
  param.laypos = "top"    ; self:execTest(tblcpy(param))
  param.laypos = "bottom" ; self:execTest(tblcpy(param))
end

function TestPlotScript:testElemName ()
  local param  = { sequence = seq, table = lmtbl, x1y1 = "y1" }
  param.elemname = true  ; self:execTest(tblcpy(param))
  param.elemname = false ; self:execTest(tblcpy(param))
end

function TestPlotScript:testKindColor ()
  local param  = { sequence = seq, table = lmtbl, x1y1 = "y1" }
  param.kindcolor = true  ; self:execTest(tblcpy(param))
  param.kindcolor = false ; self:execTest(tblcpy(param))
  param.kindcolor = {
    quadrupole = "blue",
    sbend      = { fillcolor = "red"  ,                         },
    rbend      = {                      fillstyle = "pattern 1" },
    instrument = { fillcolor = "green", fillstyle = "pattern 2" },
  } ;
  self:execTest(tblcpy(param))
end

function TestPlotScript:testSeqOnly ()
  local param = { sequence = seq }
  self:execTest(param)
end

function TestPlotScript:testSeqRange()
  local param = { sequence = seq, table = lmtbl, x1y1 = "y1" }
  param.range = { "quadrupole", "elseparator" } ; self:execTest(tblcpy(param))
  param.range = { 15          , 120           } ; self:execTest(tblcpy(param))
end

function TestPlotScript:testSeqDist ()
  local param = { sequence = { seq, seq, seq }, table = lmtbl, x1y1 = "y1" }
  param.seqdisty = 0.2          ; self:execTest(tblcpy(param))
  param.seqdisty = { 0.2, 0.4 } ; self:execTest(tblcpy(param))
  param.seqdistx = 10           ; self:execTest(tblcpy(param))
  param.seqdistx = { 5  , 10  } ; self:execTest(tblcpy(param))
  param.seqshift = 20           ; self:execTest(tblcpy(param))
  param.seqshift = 20           ; self:execTest(tblcpy(param))
end

function TestPlotScript:testSeqNturn ()
  local param = { sequence = seq, table = lmtbl, x1y1 = "y1", nturn = 1 }
  self:execTest(param)
end

function TestPlotScript:testSeqKeep()
  local param1 = { sid = 1, sequence = seq   , table = lmtbl, x1y1 = "y1" }
  local param2 = { sid = 1, sequence = "keep", table = lmtbl, x1y1 = "y2" }
  self:execTest(param1)
  self:execTest(param2)
end

function TestPlotScript:testElemSize ()
  local lhcb1, lhcb2 = loadLHC()
  local param = {
    table    = lmtbl,
    x1y1     = "y1",
    sequence = { lhcb1, lhcb2 },
    range    = { {"E.DS.L1.B1", "S.DS.R1.B1"}, {"E.DS.L1.B2", "S.DS.R1.B2"} },
    seqdisty = lhcb2["E.DS.L1.B2"].mech_sep,
  }
  self:execTest(tblcpy(param, nil, { elemscale = 2   }))
  self:execTest(tblcpy(param, nil, { elemwidth = 0.2 }))
end

function TestPlotScript:testElemFilter()
  local lhcb1, lhcb2 = loadLHC()
  local param = {
    table    = lmtbl,
    x1y1     = "y1",
    sequence = { lhcb1, lhcb2 },
    range    = { {"E.DS.L1.B1", "S.DS.R1.B1"}, {"E.DS.L1.B2", "S.DS.R1.B2"} },
    seqdisty = lhcb2["E.DS.L1.B2"].mech_sep
  }
  self:execTest(tblcpy(param, nil, { kindselect = {"quadrupole", "sbend"} }))
  self:execTest(tblcpy(param, nil, { elemminlen = 1 }))
end

function TestPlotScript:testLayangle()
  local lhcb1 = loadLHC()
  local param = {
    table    = lmtbl,
    x1y1     = "y1",
    sequence = lhcb1,
    range    = {"E.DS.L1.B1", "S.DS.R1.B1"},
  }
  param.layangle = true  ; self:execTest(tblcpy(param))
  param.layangle = false ; self:execTest(tblcpy(param))
end

function TestPlotScript:testSurveySimple()
  local seq = sequence { refer = "entry", instrument { at = 0, l = 3 } }
  seq:select(observe)
  local param = {
    sequence  = seq,
    table     = lmtbl,
    laypos    = "in",
    x1y1      = "y1",
  }
  self:execTest(tblcpy(param))
  param.A0 = { -pi/2 , 0 , 0 }
  self:execTest(tblcpy(param))
end

function TestPlotScript:testSurvey()
  local seq = sequence { refer = "entry",
    sbend { at = 0,  l = 1, angle = pi/10 },
    sbend { at = 1,  l = 1, angle = pi/10 },
    sbend { at = 2,  l = 1, angle = pi/10 },
    sbend { at = 3,  l = 1, angle = pi/10 },
    sbend { at = 4,  l = 1, angle = pi/10 },
    sbend { at = 5,  l = 1, angle = pi/10 },
    sbend { at = 6,  l = 1, angle = pi/10 },
    sbend { at = 7,  l = 1, angle = pi/10 },
    sbend { at = 8,  l = 1, angle = pi/10 },
    sbend { at = 9,  l = 1, angle = pi/10 },
    sbend { at = 10, l = 1, angle = pi/10 },
    sbend { at = 11, l = 1, angle = pi/10 },
    sbend { at = 12, l = 1, angle = pi/10 },
    sbend { at = 13, l = 1, angle = pi/10 },
    sbend { at = 14, l = 1, angle = pi/10 },
    sbend { at = 15, l = 1, angle = pi/10 },
    sbend { at = 16, l = 1, angle = pi/10 },
    sbend { at = 17, l = 1, angle = pi/10 },
    sbend { at = 18, l = 1, angle = pi/10 },
    sbend { at = 19, l = 1, angle = pi/10 },
  }
  seq:select(observe)
  local param = {
    sequence  = seq,
    table     = lmtbl,
    laypos    = "in",
    x1y1      = "y1",
  }
  self:execTest(param)
end

function TestPlotScript:testSurveyNturn()
  local seq = sequence { refer = "entry",
    sbend { at = 0, l = 1, angle = pi/10 },
    sbend { at = 1, l = 1, angle = pi/10 },
    sbend { at = 2, l = 1, angle = pi/10 },
    sbend { at = 3, l = 1, angle = pi/10 },
    sbend { at = 4, l = 1, angle = pi/10 },
    sbend { at = 5, l = 1, angle = pi/10 },
    sbend { at = 6, l = 1, angle = pi/10 },
    sbend { at = 7, l = 1, angle = pi/10 },
    sbend { at = 8, l = 1, angle = pi/10 },
    sbend { at = 9, l = 1, angle = pi/10 },
  }
  seq:select(observe)
  local param = {
    sequence = seq,
    table    = lmtbl,
    laypos   = "in",
    x1y1     = "y1",
    nturn    = 1,
  }
  self:execTest(param)
end

function TestPlotScript:testSurveyInput()
  local lhcb1 = loadLHC()
  local param = {
    sequence  = lhcb1,
    table     = lmtbl,
    laypos    = "in",
    x1y1      = "y1",
    xrange    = { -8510.46, 101.011    },
    yrange    = { -405.75 , 4605.54    },
    range     = { "IP2"   , "IP4"      },
    X0        = { -1231.18, 0, 2970.46 },
    A0        = { -pi/4   , 0, 0       },
  }
  self:execTest(param)
end

function TestPlotScript:testIP1IP5 ()
  local lhcb1, lhcb2 = loadLHC()
  local param = {
    table    = lmtbl,
    x1y1     = "y1",
    sequence = { lhcb1, lhcb2, lhcb1, lhcb2 },
    range    = {
      {"E.DS.L1.B1", "S.DS.R1.B1"},{"E.DS.L1.B2", "S.DS.R1.B2"},
      {"E.DS.L5.B1", "S.DS.R5.B1"},{"E.DS.L5.B2", "S.DS.R5.B2"},
    },
    seqdisty = {
      lhcb2["E.DS.L1.B2"].mech_sep,
      -0.4,
      -0.4 + lhcb2["E.DS.L5.B2"].mech_sep
    },
  }
  self:execTest(param)
end

function TestPlotScript:testLHC ()
  local lhcb1, lhcb2 = loadLHC()
  local param = {
    sequence = { lhcb1, lhcb2 },
    table    = bmtbl,
    x1y1     = { x = "y" },
  }
  self:execTest(param)
end

function TestPlotScript:testSurveyLHC ()
  local lhcb1, lhcb2 = loadLHC()
  local param = {
    sequence = { lhcb1, lhcb2 },
    laypos   = "in",
  }
  self:execTest(param)
end

function TestPlotScript:testOutput ()
  gplot:set_methods {
    printf = \s,... =>
      local match = string.match(string.format(...), "system '(.+)'")
      if match then os.execute(match) end
    end,
    write  = \ error("call to write in gplot"),
  }
  local param = {
    sid      = 12,
    output   = 2,
    term     = "qt",
    wsizex   = 300,
    wsizey   = 300,
    font     = "Comic Sans MS",
    fontsize = 31,
  }
  assertEquals(gplot.sid, 1)
  self:execTest(tblcpy(param))
  param.output="plot.pdf"
  self:execTest(tblcpy(param))
  assertEquals(gplot.sid, 12)

  gplot.printf, gplot.write = nil, nil
end

-- gplot regression test suite -------------------------------------------------o

TestPlotGplot = {}

function TestPlotGplot:setUp ()
  filesys.mkdir(rundir())
end

function TestPlotGplot:tearDown ()
  if not generate and self.testPassed then filesys.rmdir(rundir()) end
end

function TestPlotGplot:testSid()
  local gplot = gplot {}

  for i=1, 25 do
    gplot:set_sid(i)
    assertEquals(gplot.sid, i)
  end

  local msg = {
    "invalid argument #1 (number expected)",
    "invalid argument #1 (number should be comprise between 1 and 25)",
  }

  assertErrorMsgContains(msg[1], gplot.set_sid, gplot, ""  )
  assertErrorMsgContains(msg[1], gplot.set_sid, gplot, \ ())
  assertErrorMsgContains(msg[1], gplot.set_sid, gplot, {}  )
  assertErrorMsgContains(msg[2], gplot.set_sid, gplot, 0   )
  assertErrorMsgContains(msg[2], gplot.set_sid, gplot, 26  )
end

function TestPlotGplot:testWritePrintf()
  local gplot = gplot {}
  local fname = rundir("test.gp")

  os.remove(fname)
  gplot:write(string.format("save '%s'", fname)) ; sleep(200)
  assertTrue(fileexists(fname))
  os.remove(fname)

  assertFalse(fileexists(fname))
  gplot:printf("save '%s'", fname) ; sleep(200)
  assertTrue(fileexists(fname))
  os.remove(fname)
end

function TestPlotGplot:testIsBusy()
  local gplot = gplot {}
  plot { prolog = "pause 0.2" }
  assertTrue(gplot:is_busy())

  sleep(500)
  for i=1, 25 do
    gplot:set_sid(i)
    assertFalse(gplot:is_busy())
  end
end

function TestPlotGplot:testCleanTmpFile()
  local gplot = gplot {}
  local tmp = "TMP_MAD_PLOT/madplot-"
  filesys.mkdir("TMP_MAD_PLOT")

  for i=1,25 do assert(io.open(tmp..i, "w")):close()   end
  gplot:clean_tmpfile()
  for i=1,25 do assertFalse(fileexists(tmp..i))        end

  for i=1,25 do plot { sid = i, prolog = "pause 0.3" } end
  gplot:clean_tmpfile()
  for i=1,25 do assertTrue(fileexists(tmp..i))         end

end
-- end ------------------------------------------------------------------------o
