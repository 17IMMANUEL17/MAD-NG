local lu = require 'luaunit'
local XR = require 'madl_xrange'
--local V  = require 'vector'

local isEqu    = lu.assertEquals
local isTrue   = lu.assertTrue
local isFalse  = lu.assertFalse
local isEquEps = lu.assertAlmostEquals
local isStr    = lu.assertIsString
local isTable  = lu.assertIsTable
local isNil    = lu.assertIsNil
local isErrEqu = lu.assertErrorMsgEquals

local pi  = math.pi
local nan = 0.0/0.0
local inf = 1.0/0.0
local eps = 1e-16

TestXrange = {}

--function TestXrange:setUp()    end
--function TestXrange:tearDown() end

function TestXrange:testCtor()
  --isErrEqu( "tests/xrange.lua:25: attempt to get length of 'xrange'", #(1..20) )
  local a = 1..20..0
  local b = XR(1,20,0)
  isFalse( a[1] )
  isFalse( b[1] )

  local a = 20..1
  local b = XR(20,1)
  isFalse( a[1] )
  isFalse( b[1] )

  local a = XR(2)
  isEqu( a[1], 2 )

  local b = XR(2,10)
  isEqu(b[1], 2)

  local a = { 1..20   , 1..20   , 1..20     , 1..20..0.5  , 5..1..-0.5  , 1..20..0.01   }
  local b = { 1..20..1, XR(1,20), XR(1,20,1), XR(1,20,0.5), XR(5,1,-0.5), XR(1,20,0.01) }
  for i=1, #a do
    local res = a[i]
    local ref = b[i]
    for j=1, a[i]:size() do isEqu( res[j], ref[j] ) end
  end
end

function TestXrange:testIs_range()
  isTrue( is_range(XR(1,20))  )
  isTrue( is_range(1..20)     )
  isTrue( is_range(20..0..-2) )
  isTrue( is_range(20..0)     )
  isTrue( is_range(1..20..0)  )
end

function TestXrange:testRange()
  local start, stop, step = XR(1,10,1):range()
  isEqu( start , 1  )
  isEqu( stop  , 10 )
  isEqu( step  , 1  )

  local start, stop, step = XR(20.1,1,-0.1):range()
  isEqu( start , 20.1 )
  isEqu( stop  , 1    )
  isEqu( step  ,-0.1  )

  local start, stop, step = (-1..2.2..-0.1):range()
  isEqu( start ,-1   )
  isEqu( stop  , 2.2 )
  isEqu( step  ,-0.1 )

  local start, stop, step = XR(-1,-20,1):range()
  isEqu( start ,-1  )
  isEqu( stop  ,-20 )
  isEqu( step  , 1  )
end

function TestXrange:testGet()
  isEqu   ( (1..20..1)   :get(1) , 1     )
  isEqu   ( (1..20..1)   :get(2) , 2     )
  isEqu   ( XR(2,40,2)   :get(2) , 4     )
  isEqu   ( (2..-2..-0.1):get(2) , 1.9   )
  isEqu   ( (1..20..1)   :get(1) , 1     )
  isEqu   ( (2..-2..-0.1):get(50), false )
  isEqu   ( (1..20..1)   :get(-4), false )
  isEqu   ( (1..20..1)   :get(22), false )
  isEqu   ( XR(2,40,2)   :get(0) , false )
  isEqu   ( XR(2,40,2)   :get(22), false )
  isEqu   ( XR(2,40,2)   :get(-4), false )
  isEqu   ( (2..-2..-0.1):get(0) , false )
  isEquEps( (2..-2..-0.1):get(22), -0.1, eps )
end

function TestXrange:testValue()
  isEqu   ( XR(10,20,0.1):value(2) ,  10.1 )
  isEqu   ( XR(2,20,2)   :value(10),  20   )
  isEqu   ( XR(2,20,2)   :value(-3), -6    )
  isEqu   ( (1..20..1)   :value(1) ,  1    )
  isEqu   ( XR(2,20,2)   :value(-2), -4    )
  isEqu   ( XR(2,20,2)   :value(13),  26   )
  isEquEps( XR(1,-2,-0.1):value(13), -0.2 , eps )
end

function TestXrange:testSize()
  isTrue ( XR(1,20,1)     :size() == (2..40..2):size() )
  isEqu  ( XR(1,10,2)     :len()  , 5   )
  isEqu  ( XR(-1.1,10,0.1):len()  , 112 )
  isEqu  ( (10..-1..-1)   :len()  , 12  )
  isEqu  ( (2..1..0.1)    :len()  , 0   )
  isEqu  ( (1..10..2)     :size() , 5   )
  isEqu  ( (10..1..-2)    :size() , 5   )
  isEqu  ( XR(1,1.95,0.1) :size() , 10  )
  isEqu  ( XR(2,1,-0.1)   :size() , 11  )

  local a = (10..0.1..-2)
  isEqu  ( a:size(), a:len() )
end

function TestXrange:testIndex()
  isEqu( XR(-1,2,0.1) :index(-0.9) , 2   )
  isEqu( XR(10,20,0.1):index(10.3) , 4   )
  isEqu( XR(1,-2,-0.1):index(-1.1) , 22  )
  isEqu( XR(1,2,0.1)  :index(0)    , nil )
  isEqu( XR(1,2,0.1)  :index(3)    , nil )
  isEqu( XR(2,1,0.1)  :index(-3)   , nil )
end

function TestXrange:testFirst()
  isEqu( XR(1,10,2)     :first() , 1   )
  isEqu( XR(-1.1,10,0.1):first() ,-1.1 )
  isEqu( XR(2,1,0.1)    :first() , 2   )
  isEqu( XR(2,-1,-0.1)  :first() , 2   )
  isEqu( XR(2,1,0.1)    :first() , XR(2,1,0.1):last() )
end

function TestXrange:testLast()
  isEqu   ( XR(1,10,2)       :last() , 9  )
  isEqu   ( XR(2,-1,-0.1)    :last() ,-1  )
  isEqu   ( XR(2,1,0.1)      :last() , 2  )
  isEqu   ( (1..11..2)       :last() , 11 )
  isEqu   ( (2..-4..-0.1)    :last() ,-4  )
  isEqu   ( (2..12..0.1)     :last() , 12 )
  isEquEps( XR(-1.1,10.1,0.1):last() , 10.1, eps )
end

function TestXrange:testMinmax()
  local min,max = XR(1,2,0.1):minmax()
  isEqu( min , 1 )
  isEqu( max , 2 )

  local min,max = XR(-2,2,0.1):minmax()
  isEqu( min ,-2 )
  isEqu( max , 2 )

  local min,max = XR(-2,-2.2,-0.1):minmax()
  isEqu( min ,-2.2 )
  isEqu( max ,-2   )

  local min,max = XR(2,-2.2,-0.1):minmax()
  isEqu( min ,-2.2 )
  isEqu( max , 2 )

  local min,max = XR(2,1,0.1):minmax()
  isEqu( min , 2 )
  isEqu( max , 2 )
end

function TestXrange:testBounds()
  local start,stop = XR(1,2,0.1):bounds()
  isEqu( start , 1 )
  isEqu( stop  , 2 )

  local start,stop = XR(-2,2,0.1):bounds()
  isEqu( start ,-2 )
  isEqu( stop  , 2 )

  local start,stop = XR(-2,-2.2,-0.1):bounds()
  isEqu( start ,-2.2 )
  isEqu( stop  ,-2   )

  local start,stop = XR(-2,0,0):bounds()
  isEqu( start ,-2 )
  isEqu( stop  , 0 )

  local start,stop = XR(2,-2.2,-0.1):bounds()
  isEqu( start ,-2.2 )
  isEqu( stop  , 2   )

  local start,stop = XR(2,1,0.1):bounds()
  isEqu( start , 2 )
  isEqu( stop  , 1 )
end

function TestXrange:testOverlap()
  isTrue ( XR(1,3,1)   :overlap(XR(3,1,-1))  )
  isTrue ( XR(5.1,1,-1):overlap(XR(1,4,1))   )
  isTrue ( XR(-6,1,1)  :overlap(XR(-21,4,1)) )
  isFalse( XR(2,1,0.1) :overlap(XR(4,1,-1))  )
  isFalse( XR(6,9,1)   :overlap(XR(5,1,-1))  )
end

function TestXrange:testEqual()
  isTrue ( XR(1,3,1)       :equal(XR(1,3,1)       ) )
  isTrue ( XR(-2,-2.2,-0.1):equal(XR(-2,-2.2,-0.1)) )
  isTrue ( XR(2,2.6,0.1)   :equal(XR(2,2.6,0.1)   ) )
  isTrue ( XR(2,1,0.1)     :equal(XR(2,1,0.1)     ) )
  isFalse( XR(2,10,0.1)    :equal(XR(2,11,0.1)    ) )
  isTrue ( XR(1,3,1)        == (1..3..1)            )
  isTrue ( XR(-2,-2.2,-0.1) == (-2..-2.2..-0.1)     )
  isTrue ( XR(2,2.6,0.1)    == (2..2.6..0.1)        )
  isTrue ( XR(2,1,0.1)      == (2..1..0.1)          )
  isFalse( XR(-2,-2.2,-0.1) == (-2..-22..-0.1)      )
  isFalse( XR(2,10,0.1)     == (2..11..0.1)         )
end

function TestXrange:testTostring()
  isStr( XR(2,2.2)       :tostring() )
  isStr( XR(-2,-2.2,-0.1):tostring() )
  isStr( XR(2,2.6,0.1)   :tostring() )
  isStr( XR(2,1,0.1)     :tostring() )
  isStr( (1..11..2)      :tostring() )
  isStr( (2..-4..-0.1)   :tostring() )
  isStr( (2..12..0.1)    :tostring() )
end

function TestXrange:testTotable()
  isTable( XR(2,2.2)       :totable() )
  isTable( XR(-2,-2.2,-0.1):totable() )
  isTable( XR(2,2.6,0.1)   :totable() )
  isTable( XR(2,1,0.1)     :totable() )
  isTable( (1..11..2)      :totable() )
  isTable( (2..-4..-0.1)   :totable() )
  isTable( (2..12..0.1)    :totable() )
end


-- 'attempt to write to constant location'
--function TestXrange:testScale()
--  isEqu( XR(1,20,1)   :scale(2)   , XR(1,40,2)    )
--  isEqu( XR(1,20,1)   :scale(-3)  , XR(1,-60,-3)  )
--  isEqu( XR(-1,20,1)  :scale(2.1) , XR(-1,42,2.1) )
--  isEqu( XR(2,-20,-2) :scale(2)   , XR(2,-40,-4)  )
--  isEqu( XR(-1,-20,-1):scale(-2)  , XR(-1,40,2)   )
--  isEqu( XR(-1,-20,1) :scale(2)   , XR(-1,-40,2)  )
--  --isErrMsgEq( "invalid range argument", R(-1,-20,-1):scale(0) )
--end
--
--function TestXrange:testTranslate()
--  isEqu( XR(1,20,2)    :translate(4)   , XR(5,24,2)       )
--  isEqu( XR(1,20,2)    :translate(-4)  , XR(-3,16,2)      )
--  isEqu( XR(-1,20,2)   :translate(-4)  , XR(-5,16,2)      )
--  isEqu( XR(1,-20,-2)  :translate(4.1) , XR(5.1,-15.9,-2) )
--  isEqu( XR(1,20,2)    :translate(0)   , XR(1,20,2)       )
--  isEqu( XR(-1,-20,1)  :translate(1)   , XR(0,-19,1)      )
--  isEqu( XR(1,-20.2,-2):translate(-2)  , XR(-1,-22.2,-2)  )
--end

--function TestXrange:testReverse()
--  isEqu( XR(1,20,2)     :reverse() , XR(20,1,-2)      )
--  isEqu( XR(3,-30,-2)   :reverse() , XR(-30,3,2)      )
--  isEqu( XR(-1,-20,-2)  :reverse() , XR(-20,-1,2)     )
--  isEqu( XR(-1.1,20.2,2):reverse() , XR(20.2,-1.1,-2) )
--  isEqu( XR(-1,-20,1)   :reverse() , XR(-20,-1,-1)    )
--end
