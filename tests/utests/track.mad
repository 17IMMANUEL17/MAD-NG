--[=[
 o-----------------------------------------------------------------------------o
 |
 | Track tests
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: I. Tecker, irina.tecker at cern.ch
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide regression test suites for the track module.

 o-----------------------------------------------------------------------------o
]=]

--[[
chg  = particle charge
dir  = sequence direction (e.g. lhcb2, dir=-1)
sdir = tracking s-direction
tdir = tracking t-direction (=dir*sdir)
bdir = tracking b-direction (=dir*sdir*chg)

      dir   sdir  chg  |  tdir  bdir
FODO   1     1     1   |   1     1
FODO  -1     1     1   |  -1    -1
ODOF   1    -1     1   |  -1    -1
ODOF  -1    -1     1   |   1     1

DOFO   1     1    -1   |   1    -1
DOFO  -1     1    -1   |  -1     1
OFOD   1    -1    -1   |  -1     1
OFOD  -1    -1    -1   |   1    -1

Usage of directions:
  - lengths        are multiplied by sdir
  - bending angles are multiplied by tdir
  - strengths      are multiplied by bdir
--]]

-- locals ---------------------------------------------------------------------o

local assertTrue, assertEquals, assertAllAlmostEquals           in MAD.utest
local printf, openfile                                          in MAD.utility
local eps, pi                                                   in MAD.constant

local track, beam, element, sequence, option, filesys           in MAD
local fnone, ftrue                                              in MAD.gfunc

local marker, drift, quadrupole, rbend, multipole               in element
local observe                                                   in element.flags

local refdir = \s -> 'track_ref/'..(s or '')
local rundir = \s -> 'track_run/'..(s or '')

-- helpers --------------------------------------------------------------------o

local doplot = false

if doplot then
  MAD.atexit(MAD.utility.pause, true)
end

local function plot (mtbl)
  if not doplot then return end
  MAD.plot { table=mtbl, title=mtbl.title,
             x1y1 = { s={'x','px','y','py','t','pt'} } }
end

local function plotxy (mtbl)
  if not doplot then return end
  MAD.plot { table=mtbl, title=mtbl.title, x1y1 = { x='x', y='y'} }
end

-- local -------------------------o

local tbl_col = {'name','s','x','px','y','py','t','pt'}
local tbl_hdr = {'title','type','origin','date','time'}

local slc_10p = {0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1}

-- QUAD Testsuite -------------------------------------------------------------o

local quad_x0  = {0, 1e-6, 0, 5e-7, 0, 0}

local quad_xs  = {1.4600656220217e-05, 2.3588119782185e-06, 1.7943847978254e-06, -3.9372067136230e-07, -1.4531875702772e-11, 0}
local quad_xt  = {1.4606200539093e-05, 2.3602690620606e-06, 1.7977500040831e-06, -3.9282268749294e-07, -1.4538426018618e-11, 0}
local quad_x4  = {1.4607603046229e-05, 2.3604497079904e-06, 1.7977728935816e-06, -3.9292618283356e-07, -1.4541645665389e-11, 0}
local quad_x6  = {1.4607613705636e-05, 2.3604524793349e-06, 1.7977644418495e-06, -3.9292873471424e-07, -1.4541645665389e-11, 0}
local quad_x8  = {1.4607613712814e-05, 2.3604524808132e-06, 1.7977644446180e-06, -3.9292873420957e-07, -1.4541812198843e-11, 0}

local quad_xst = {1.4607613712814e-05, 2.3604524808134e-06, 1.7977644446181e-06, -3.9292873420967e-07, -1.4268142223273e-11, 0}
local quad_xtt = {1.4607613712814e-05, 2.3604524808133e-06, 1.7977644446178e-06, -3.9292873420968e-07, -1.4544476734102e-11, 0}
local quad_x4t = {1.4607613712814e-05, 2.3604524808133e-06, 1.7977644446178e-06, -3.9292873420967e-07, -1.4538148462861e-11, 0}
local quad_x6t = {1.4607613712814e-05, 2.3604524808133e-06, 1.7977644446178e-06, -3.9292873420968e-07, -1.4541257087330e-11, 0}
local quad_x8t = {1.4607613712814e-05, 2.3604524808133e-06, 1.7977644446178e-06, -3.9292873420968e-07, -1.4542589354960e-11, 0}

local quad_ptc = {1.4607613712814E-05, 2.3604524808134E-06, 1.7977644446181E-06, -3.9292873420967E-07, -1.4269030401692E-11, 0}
local quad_mdx = {1.460761371e-05    , 2.360452481e-06    , 1.797764445e-06    , -3.929287342e-07    , -1.454192453e-11    , 0}

-- ptc_create_layout, model=2, method=2, nst=1, time=true, exact=true;
-- ptc_track, icase=56, closed_orbit=false, dump, onetable, element_by_element, file="ptctrack_quad_madx.";

local function mkQUAD (dir_, chg_)
  local dir   = dir_ or 1 -- sequence direction
  local chg   = chg_ or 1 -- particle charge
  local k1_qf =  0.2110222185*dir*chg
  local k1_qd = -0.2110222186*dir*chg
  local seq = sequence 'seq' { l=10, refer='entry', dir=dir,
    quadrupole 'm1' {at=0  , l=1.5, k1:=k1_qf}, -- [1]=multipole{at=0.5}},
    drift      'd1' {at=1.5, l=3.5},
    quadrupole 'm2' {at=5  , l=1.5, k1:=k1_qd}, -- [1]=multipole{at=0.5}},
    drift      'd2' {at=6.5, l=3.5},
  }
  return seq   -- seq:dumpseq()
end

TestTrackQUAD = {}

function TestTrackQUAD:setUp ()
  filesys.mkdir(rundir())
  self.optfmt = option.format
  option.format = "%-.16e"
end

function TestTrackQUAD:tearDown ()
  option.format = self.optfmt
end

-- DKD model ---------------o

function TestTrackQUAD:testDKD10S () -- simple
  local seq = mkQUAD()
  local X0 = quad_x0
  local mtbl, mflw = track {sequence=seq, beam=beam, X0=X0, observe=0, model='DKD', nslice=10 }

  mtbl:write(rundir('quad_dkd10s'), tbl_col, tbl_hdr)

  local row = mtbl[#mtbl]
  local res = {row.x, row.px, row.y, row.py, row.t, row.pt}
  local ref = quad_xs
  assertAllAlmostEquals(res, ref, eps)
end

function TestTrackQUAD:testDKD10SB () -- simple, backward
  local seq = mkQUAD()
  local X0 = quad_xs
  local mtbl, mflw = track {sequence=seq, beam=beam, X0=X0, observe=0, model='DKD', nslice=10, dir=-1 }

  mtbl:write(rundir('quad_dkd10sb'), tbl_col, tbl_hdr)

  local row = mtbl[#mtbl]
  local res = {row.x, row.px, row.y, row.py, row.t, row.pt}
  local ref = quad_x0
  assertAllAlmostEquals(res, ref, eps)
end

function TestTrackQUAD:testDKD10SP () -- simple, positions
  local seq = mkQUAD()
  local X0 = quad_x0
  local mtbl, mflw = track {sequence=seq, beam=beam, X0=X0, observe=0, model='DKD', nslice=slc_10p }

  mtbl:write(rundir('quad_dkd10s'), tbl_col, tbl_hdr)

  local row = mtbl[#mtbl]
  local res = {row.x, row.px, row.y, row.py, row.t, row.pt}
  local ref = quad_xs
  assertAllAlmostEquals(res, ref, eps)
end

function TestTrackQUAD:testDKD10SR () -- simple, reversed
  local seq = mkQUAD(-1)
  local X0 = quad_x0
  local mtbl, mflw = track {sequence=seq, beam=beam, X0=X0, observe=0, model='DKD', nslice=10 }

  mtbl:write(rundir('quad_dkd10sr'), tbl_col, tbl_hdr)

  local row = mtbl[#mtbl]
  local res = {row.x, row.px, row.y, row.py, row.t, row.pt}
  local ref = quad_xs
  assertAllAlmostEquals(res, ref, eps)
end

function TestTrackQUAD:testDKD10SBR () -- simple, backward, reverse
  local seq = mkQUAD(-1)
  local X0 = quad_xs
  local mtbl, mflw = track {sequence=seq, beam=beam, X0=X0, observe=0, model='DKD', nslice=10, dir=-1 }

  mtbl:write(rundir('quad_dkd10sbr'), tbl_col, tbl_hdr)

  local row = mtbl[#mtbl]
  local res = {row.x, row.px, row.y, row.py, row.t, row.pt}
  local ref = quad_x0
  assertAllAlmostEquals(res, ref, eps)
end

function TestTrackQUAD:testDKD10SN () -- simple, negative
  local seq, beam = mkQUAD(1,-1), beam { particle='electron' }
  local X0 = quad_x0
  local mtbl, mflw = track {sequence=seq, beam=beam, X0=X0, observe=0, model='DKD', nslice=10 }

  mtbl:write(rundir('quad_dkd10sn'), tbl_col, tbl_hdr)

  local row = mtbl[#mtbl]
  local res = {row.x, row.px, row.y, row.py, row.t, row.pt}
  local ref = quad_xs
  assertAllAlmostEquals(res, ref, eps)
end

function TestTrackQUAD:testDKD10SBN () -- simple, backward, negative
  local seq, beam = mkQUAD(1,-1), beam { particle='electron' }
  local X0 = quad_xs
  local mtbl, mflw = track {sequence=seq, beam=beam, X0=X0, observe=0, model='DKD', nslice=10, dir=-1 }

  mtbl:write(rundir('quad_dkd10sbn'), tbl_col, tbl_hdr)

  local row = mtbl[#mtbl]
  local res = {row.x, row.px, row.y, row.py, row.t, row.pt}
  local ref = quad_x0
  assertAllAlmostEquals(res, ref, eps)
end

function TestTrackQUAD:testDKD10SRN () -- simple, reversed, negative
  local seq, beam = mkQUAD(-1,-1), beam { particle='electron' }
  local X0 = quad_x0
  local mtbl, mflw = track {sequence=seq, beam=beam, X0=X0, observe=0, model='DKD', nslice=10 }

  mtbl:write(rundir('quad_dkd10srn'), tbl_col, tbl_hdr)

  local row = mtbl[#mtbl]
  local res = {row.x, row.px, row.y, row.py, row.t, row.pt}
  local ref = quad_xs
  assertAllAlmostEquals(res, ref, eps)
end

function TestTrackQUAD:testDKD10SBRN () -- simple, backward, reverse, negative
  local seq, beam = mkQUAD(-1,-1), beam { particle='electron' }
  local X0 = quad_xs
  local mtbl, mflw = track {sequence=seq, beam=beam, X0=X0, observe=0, model='DKD', nslice=10, dir=-1 }

  mtbl:write(rundir('quad_dkd10sbrn'), tbl_col, tbl_hdr)

  local row = mtbl[#mtbl]
  local res = {row.x, row.px, row.y, row.py, row.t, row.pt}
  local ref = quad_x0
  assertAllAlmostEquals(res, ref, eps)
end

function TestTrackQUAD:testDKD10T () -- teapot
  local seq = mkQUAD()
  local X0 = quad_x0
  local mtbl, mflw = track {sequence=seq, beam=beam, X0=X0, observe=0, model='DKD', method='teapot', nslice=10 }

  mtbl:write(rundir('quad_dkd10t'), tbl_col, tbl_hdr)

  local row = mtbl[#mtbl]
  local res = {row.x, row.px, row.y, row.py, row.t, row.pt}
  local ref = quad_xt
  assertAllAlmostEquals(res, ref, eps)
end

function TestTrackQUAD:testDKD10TB () -- teapot, backward
  local seq = mkQUAD()
  local X0 = quad_xt
  local mtbl, mflw = track {sequence=seq, beam=beam, X0=X0, observe=0, model='DKD', method='teapot', nslice=10, dir=-1 }

  mtbl:write(rundir('quad_dkd10tb'), tbl_col, tbl_hdr)

  local row = mtbl[#mtbl]
  local res = {row.x, row.px, row.y, row.py, row.t, row.pt}
  local ref = quad_x0
  assertAllAlmostEquals(res, ref, eps)
end

function TestTrackQUAD:testDKD10Y4 () -- yoshida4
  local seq = mkQUAD()
  local X0 = quad_x0
  local mtbl, mflw = track {sequence=seq, beam=beam, X0=X0, observe=0, model='DKD', method='yoshida4', nslice=10 }

  mtbl:write(rundir('quad_dkd10y4'), tbl_col, tbl_hdr)

  local row = mtbl[#mtbl]
  local res = {row.x, row.px, row.y, row.py, row.t, row.pt}
  local ref = quad_x4
  assertAllAlmostEquals(res, ref, eps)
end

function TestTrackQUAD:testDKD10Y4B () -- yoshida4, backward
  local seq = mkQUAD()
  local X0 = quad_x4
  local mtbl, mflw = track {sequence=seq, beam=beam, X0=X0, observe=0, model='DKD', method='yoshida4', nslice=10, dir=-1 }

  mtbl:write(rundir('quad_dkd10y4b'), tbl_col, tbl_hdr)

  local row = mtbl[#mtbl]
  local res = {row.x, row.px, row.y, row.py, row.t, row.pt}
  local ref = quad_x0
  assertAllAlmostEquals(res, ref, eps)
end

function TestTrackQUAD:testDKD10Y4P () -- yoshida4
  local seq = mkQUAD()
  local X0 = quad_x0
  local mtbl, mflw = track {sequence=seq, beam=beam, X0=X0, observe=0, model='DKD', method='yoshida4', nslice=slc_10p }

  mtbl:write(rundir('quad_dkd10y4'), tbl_col, tbl_hdr)

  local row = mtbl[#mtbl]
  local res = {row.x, row.px, row.y, row.py, row.t, row.pt}
  local ref = quad_x4
  assertAllAlmostEquals(res, ref, eps)
end

function TestTrackQUAD:testDKD10Y6 () -- yoshida6
  local seq = mkQUAD()
  local X0 = quad_x0
  local mtbl, mflw = track {sequence=seq, beam=beam, X0=X0, observe=0, model='DKD', method='yoshida6', nslice=10 }

  mtbl:write(rundir('quad_dkd10y6'), tbl_col, tbl_hdr)

  local row = mtbl[#mtbl]
  local res = {row.x, row.px, row.y, row.py, row.t, row.pt}
  local ref = quad_x6
  assertAllAlmostEquals(res, ref, eps)
end

function TestTrackQUAD:testDKD10Y6B () -- yoshida6, backward
  local seq = mkQUAD()
  local X0 = quad_x6
  local mtbl, mflw = track {sequence=seq, beam=beam, X0=X0, observe=0, model='DKD', method='yoshida6', nslice=10, dir=-1 }

  mtbl:write(rundir('quad_dkd10y6b'), tbl_col, tbl_hdr)

  local row = mtbl[#mtbl]
  local res = {row.x, row.px, row.y, row.py, row.t, row.pt}
  local ref = quad_x0
  assertAllAlmostEquals(res, ref, eps)
end

function TestTrackQUAD:testDKD10Y6P () -- yoshida6, positions
  local seq = mkQUAD()
  local X0 = quad_x0
  local mtbl, mflw = track {sequence=seq, beam=beam, X0=X0, observe=0, model='DKD', method='yoshida6', nslice=slc_10p }

  mtbl:write(rundir('quad_dkd10y6'), tbl_col, tbl_hdr)

  local row = mtbl[#mtbl]
  local res = {row.x, row.px, row.y, row.py, row.t, row.pt}
  local ref = quad_x6
  assertAllAlmostEquals(res, ref, eps)
end

function TestTrackQUAD:testDKD10Y8 () -- yoshida8
  local seq = mkQUAD()
  local X0 = quad_x0
  local mtbl, mflw = track {sequence=seq, beam=beam, X0=X0, observe=0, model='DKD', method='yoshida8', nslice=10 }

  mtbl:write(rundir('quad_dkd10y8'), tbl_col, tbl_hdr)

  local row = mtbl[#mtbl]
  local res = {row.x, row.px, row.y, row.py, row.t, row.pt}
  local ref = quad_x8
  assertAllAlmostEquals(res, ref, eps)
end

function TestTrackQUAD:testDKD10Y8B () -- yoshida8, backward
  local seq = mkQUAD()
  local X0 = quad_x8
  local mtbl, mflw = track {sequence=seq, beam=beam, X0=X0, observe=0, model='DKD', method='yoshida8', nslice=10, dir=-1 }

  mtbl:write(rundir('quad_dkd10y8b'), tbl_col, tbl_hdr)

  local row = mtbl[#mtbl]
  local res = {row.x, row.px, row.y, row.py, row.t, row.pt}
  local ref = quad_x0
  assertAllAlmostEquals(res, ref, eps)
end

function TestTrackQUAD:testDKD10Y8P() -- yoshida8, positions
  local seq = mkQUAD()
  local X0 = quad_x0
  local mtbl, mflw = track {sequence=seq, beam=beam, X0=X0, observe=0, model='DKD', method='yoshida8', nslice=slc_10p }

  mtbl:write(rundir('quad_dkd10y8'), tbl_col, tbl_hdr)

  local row = mtbl[#mtbl]
  local res = {row.x, row.px, row.y, row.py, row.t, row.pt}
  local ref = quad_x8
  assertAllAlmostEquals(res, ref, eps)
end

-- TKT model ---------------o

function TestTrackQUAD:testTKT1S () -- simple
  local seq = mkQUAD()
  local X0 = quad_x0
  local mtbl, mflw = track {sequence=seq, beam=beam, X0=X0, observe=0 }

  mtbl:write(rundir('quad_tkt1s'), tbl_col, tbl_hdr)

  local row = mtbl[#mtbl]
  local res = {row.x, row.px, row.y, row.py, row.t, row.pt}
  local ref = quad_xst
  assertAllAlmostEquals(res, ref, eps)
end

function TestTrackQUAD:testTKT1SB () -- simple, backward
  local seq = mkQUAD()
  local X0 = quad_xst
  local mtbl, mflw = track {sequence=seq, beam=beam, X0=X0, observe=0, dir=-1 }

  mtbl:write(rundir('quad_tkt1s'), tbl_col, tbl_hdr)

  local row = mtbl[#mtbl]
  local res = {row.x, row.px, row.y, row.py, row.t, row.pt}
  local ref = quad_x0
  assertAllAlmostEquals(res, ref, eps)
end

function TestTrackQUAD:testTKT1SR () -- simple, reversed
  local seq = mkQUAD(-1)
  local X0 = quad_x0
  local mtbl, mflw = track {sequence=seq, beam=beam, X0=X0, observe=0 }

  mtbl:write(rundir('quad_tkt1sr'), tbl_col, tbl_hdr)

  local row = mtbl[#mtbl]
  local res = {row.x, row.px, row.y, row.py, row.t, row.pt}
  local ref = quad_xst
  assertAllAlmostEquals(res, ref, eps)
end

function TestTrackQUAD:testTKT1SBR () -- simple, backward, reverse
  local seq = mkQUAD(-1)
  local X0 = quad_xst
  local mtbl, mflw = track {sequence=seq, beam=beam, X0=X0, observe=0, dir=-1 }

  mtbl:write(rundir('quad_tkt1sbr'), tbl_col, tbl_hdr)

  local row = mtbl[#mtbl]
  local res = {row.x, row.px, row.y, row.py, row.t, row.pt}
  local ref = quad_x0
  assertAllAlmostEquals(res, ref, eps)
end

function TestTrackQUAD:testTKT1SN () -- simple, negative
  local seq, beam = mkQUAD(1,-1), beam { particle='electron' }
  local X0 = quad_x0
  local mtbl, mflw = track {sequence=seq, beam=beam, X0=X0, observe=0 }

  mtbl:write(rundir('quad_tkt1sn'), tbl_col, tbl_hdr)

  local row = mtbl[#mtbl]
  local res = {row.x, row.px, row.y, row.py, row.t, row.pt}
  local ref = quad_xst
  assertAllAlmostEquals(res, ref, eps)
end

function TestTrackQUAD:testTKT1SBN () -- simple, backward, negative
  local seq, beam = mkQUAD(1,-1), beam { particle='electron' }
  local X0 = quad_xst
  local mtbl, mflw = track {sequence=seq, beam=beam, X0=X0, observe=0, dir=-1 }

  mtbl:write(rundir('quad_tkt1sbn'), tbl_col, tbl_hdr)

  local row = mtbl[#mtbl]
  local res = {row.x, row.px, row.y, row.py, row.t, row.pt}
  local ref = quad_x0
  assertAllAlmostEquals(res, ref, eps)
end

function TestTrackQUAD:testTKT1SRN () -- simple, reversed, negative
  local seq, beam = mkQUAD(-1,-1), beam { particle='electron' }
  local X0 = quad_x0
  local mtbl, mflw = track {sequence=seq, beam=beam, X0=X0, observe=0 }

  mtbl:write(rundir('quad_tkt1srn'), tbl_col, tbl_hdr)

  local row = mtbl[#mtbl]
  local res = {row.x, row.px, row.y, row.py, row.t, row.pt}
  local ref = quad_xst
  assertAllAlmostEquals(res, ref, eps)
end

function TestTrackQUAD:testTKT1SBRN () -- simple, backward, reverse, negative
  local seq, beam = mkQUAD(-1,-1), beam { particle='electron' }
  local X0 = quad_xst
  local mtbl, mflw = track {sequence=seq, beam=beam, X0=X0, observe=0, dir=-1 }

  mtbl:write(rundir('quad_tkt1sbrn'), tbl_col, tbl_hdr)

  local row = mtbl[#mtbl]
  local res = {row.x, row.px, row.y, row.py, row.t, row.pt}
  local ref = quad_x0
  assertAllAlmostEquals(res, ref, eps)
end

function TestTrackQUAD:testTKT10T () -- teapot
  local seq = mkQUAD()
  local X0 = quad_x0
  local mtbl, mflw = track {sequence=seq, beam=beam, X0=X0, observe=0, method='teapot', nslice=10 }

  mtbl:write(rundir('quad_dkd10t'), tbl_col, tbl_hdr)

  local row = mtbl[#mtbl]
  local res = {row.x, row.px, row.y, row.py, row.t, row.pt}
  local ref = quad_xtt
  assertAllAlmostEquals(res, ref, eps)
end

function TestTrackQUAD:testTKT10TB () -- teapot, backward
  local seq = mkQUAD()
  local X0 = quad_xtt
  local mtbl, mflw = track {sequence=seq, beam=beam, X0=X0, observe=0, method='teapot', nslice=10, dir=-1 }

  mtbl:write(rundir('quad_tkt10tb'), tbl_col, tbl_hdr)

  local row = mtbl[#mtbl]
  local res = {row.x, row.px, row.y, row.py, row.t, row.pt}
  local ref = quad_x0
  assertAllAlmostEquals(res, ref, eps)
end

function TestTrackQUAD:testTKT1Y4 () -- yoshida4
  local seq = mkQUAD()
  local X0 = quad_x0
  local mtbl, mflw = track {sequence=seq, beam=beam, X0=X0, observe=0, method='yoshida4' }

  mtbl:write(rundir('quad_tkt1y4'), tbl_col, tbl_hdr)

  local row = mtbl[#mtbl]
  local res = {row.x, row.px, row.y, row.py, row.t, row.pt}
  local ref = quad_x4t
  assertAllAlmostEquals(res, ref, eps)
end

function TestTrackQUAD:testTKT1Y4B () -- yoshida4, backward
  local seq = mkQUAD()
  local X0 = quad_x4t
  local mtbl, mflw = track {sequence=seq, beam=beam, X0=X0, observe=0, method='yoshida4', dir=-1 }

  mtbl:write(rundir('quad_tkt1y4b'), tbl_col, tbl_hdr)

  local row = mtbl[#mtbl]
  local res = {row.x, row.px, row.y, row.py, row.t, row.pt}
  local ref = quad_x0
  assertAllAlmostEquals(res, ref, eps)
end

function TestTrackQUAD:testTKT1Y6 () -- yoshida6
  local seq = mkQUAD()
  local X0 = quad_x0
  local mtbl, mflw = track {sequence=seq, beam=beam, X0=X0, observe=0, method='yoshida6' }

  mtbl:write(rundir('quad_tkt1y6'), tbl_col, tbl_hdr)

  local row = mtbl[#mtbl]
  local res = {row.x, row.px, row.y, row.py, row.t, row.pt}
  local ref = quad_x6t
  assertAllAlmostEquals(res, ref, eps)
end

function TestTrackQUAD:testTKT1Y6B () -- yoshida6, backward
  local seq = mkQUAD()
  local X0 = quad_x6t
  local mtbl, mflw = track {sequence=seq, beam=beam, X0=X0, observe=0, method='yoshida6', dir=-1 }

  mtbl:write(rundir('quad_tkt1y6b'), tbl_col, tbl_hdr)

  local row = mtbl[#mtbl]
  local res = {row.x, row.px, row.y, row.py, row.t, row.pt}
  local ref = quad_x0
  assertAllAlmostEquals(res, ref, eps)
end

function TestTrackQUAD:testTKT1Y8 () -- yoshida8
  local seq = mkQUAD()
  local X0 = quad_x0
  local mtbl, mflw = track {sequence=seq, beam=beam, X0=X0, observe=0, method='yoshida8' }

  mtbl:write(rundir('quad_tkt1y8'), tbl_col, tbl_hdr)

  local row = mtbl[#mtbl]
  local res = {row.x, row.px, row.y, row.py, row.t, row.pt}
  local ref = quad_x8t
  assertAllAlmostEquals(res, ref, eps)
end

function TestTrackQUAD:testTKT1Y8B () -- yoshida8, backward
  local seq = mkQUAD()
  local X0 = quad_x8t
  local mtbl, mflw = track {sequence=seq, beam=beam, X0=X0, observe=0, method='yoshida8', dir=-1 }

  mtbl:write(rundir('quad_tkt1y8b'), tbl_col, tbl_hdr)

  local row = mtbl[#mtbl]
  local res = {row.x, row.px, row.y, row.py, row.t, row.pt}
  local ref = quad_x0
  assertAllAlmostEquals(res, ref, 2*eps)
end

-- RBEND Testsuite ------------------------------------------------------------o

local rbend_x0  = {0, 1e-6, 0, 5e-7, 0, 0}

local rbend_xs  = {1.4600656220217e-05, 2.3588119782185e-06, 1.7943847978254e-06, -3.9372067136230e-07, -1.4531875702772e-11, 0}
local rbend_xt  = {1.4606200539093e-05, 2.3602690620606e-06, 1.7977500040831e-06, -3.9282268749294e-07, -1.4538426018618e-11, 0}
local rbend_x4  = {1.4607603046229e-05, 2.3604497079904e-06, 1.7977728935816e-06, -3.9292618283356e-07, -1.4541645665389e-11, 0}
local rbend_x6  = {1.4607613705636e-05, 2.3604524793349e-06, 1.7977644418495e-06, -3.9292873471424e-07, -1.4541645665389e-11, 0}
local rbend_x8  = {1.4607613712814e-05, 2.3604524808132e-06, 1.7977644446180e-06, -3.9292873420957e-07, -1.4541812198843e-11, 0}

local rbend_xst = {1.4607613712814e-05, 2.3604524808134e-06, 1.7977644446181e-06, -3.9292873420967e-07, -1.4268142223273e-11, 0}
local rbend_xtt = {1.4607613712814e-05, 2.3604524808133e-06, 1.7977644446178e-06, -3.9292873420968e-07, -1.4544476734102e-11, 0}
local rbend_x4t = {1.4607613712814e-05, 2.3604524808133e-06, 1.7977644446178e-06, -3.9292873420967e-07, -1.4538148462861e-11, 0}
local rbend_x6t = {1.4607613712814e-05, 2.3604524808133e-06, 1.7977644446178e-06, -3.9292873420968e-07, -1.4541257087330e-11, 0}
local rbend_x8t = {1.4607613712814e-05, 2.3604524808133e-06, 1.7977644446178e-06, -3.9292873420968e-07, -1.4542589354960e-11, 0}

local rbend_ptc = {9.9991224821975E-06, 9.9999999996978E-07, 4.9823188081225E-06,  4.9620128226007E-07,  2.0944553602575E-07, 0}
local rbend_mdx = {}
-- ptc_create_layout, model=2, method=2, nst=1, time=true, exact=true;
-- ptc_track, icase=56, closed_orbit=false, dump, onetable, element_by_element, file="ptctrack_rbend_madx.";

local function mkRBEND (dir_, chg_)
  local dir   = dir_ or 1 -- sequence direction
  local chg   = chg_ or 1 -- particle charge
  local k0_qf =  2*pi/1e2/1.5*dir*chg
  local k0_qd = -2*pi/1e2/1.5*dir*chg
  local seq = sequence 'seq' { l=10, refer='entry', dir=dir,
    rbend 'm1' {at=0  , l=1.5, k0:=k0_qf, angle:=k0_qf},
    drift 'd1' {at=1.5, l=3.5},
    rbend 'm2' {at=5  , l=1.5, k0:=k0_qd, angle:=k0_qd},
    drift 'd2' {at=6.5, l=3.5},
  }
  return seq   -- seq:dumpseq()
end

TestTrackRBEND = {}

function TestTrackRBEND:setUp ()
  filesys.mkdir(rundir())
  self.optfmt = option.format
  option.format = "%-.16e"
end

function TestTrackRBEND:tearDown ()
  option.format = self.optfmt
end

-- DKD model ---------------o

function TestTrackRBEND:testDKD10S () -- simple
  local seq = mkRBEND()
  local X0 = rbend_x0
  local mtbl, mflw = track {sequence=seq, beam=beam, X0=X0, observe=0, model='DKD', nslice=10 }

  mtbl:write(rundir('rbend_dkd10s'), tbl_col, tbl_hdr)

  local row = mtbl[#mtbl]
  local res = {row.x, row.px, row.y, row.py, row.t, row.pt}
  local ref = rbend_xs
--  assertAllAlmostEquals(res, ref, eps)
end

-- Drift ----------------------------------------------------------------------o

--[[ TO REVIEW

TestTrackDrift = {}

local function prt_map_info (elm, m, l, i)
  io.write(elm.name, "[", i, "]: ", m.x, ", ", m.y, ", ", m.t, "\n")
end

local function fill_tbl (elm, m, l, i)
  local mtable in m
  -- keep order!
  mtable = mtable + { elm.name..'..'..i, elm.kind,
                      m.s+l*i, l, m.x, m.px, m.y, m.py, m.t, m.pt }
end

local function fill_tbl_1000 (elm, m, l, i)
  local mtable in m
  -- keep order!
  if i % 1000 == 0 then
    mtable = mtable + { elm.name..'..'..i, elm.kind,
                        m.s+l*i, l, m.x, m.px, m.y, m.py, m.t, m.pt }
  end
end

function TestTrackDrift:setUp ()
  self.optfmt = option.format
  option.format = "%-18.11g"
end

function TestTrackDrift:tearDown ()
  option.format = self.optfmt
end

function TestTrackDrift:testSimple()
  local seq = sequence 'seq' { refer='entry', drift 'df' { l=1 } }
  seq:select(observe)

  local beam = beam { particle='proton', energy=100 }
  local tbl = track { sequence=seq, beam=beam, X0={1, 0.1, -1, -0.1, 0, 0.1} }
  assertEquals(#tbl, 3)
  print()
  tbl:write(io.stdout)
end

function TestTrackDrift:testBacktrack()
  local seq = sequence 'seq' { refer='entry', drift 'df' { l=1 } }
  seq:select(observe)

  local beam = beam { particle='proton', energy=100 }
  local tbl = track { sequence=seq, beam=beam, X0={1, 0.1, -1, -0.1, 0, 0.1}, dir=-1 }
  assertEquals(#tbl, 3)
  print()
  tbl:write(io.stdout)
end

function TestTrackDrift:testBackAndForth()
  local seq = sequence 'seq' { refer='entry', drift 'df' { l=1 } }
  seq:select(observe)

  local beam = beam { particle='proton', energy=100 }
  local tbl, map = track { sequence=seq, beam=beam, X0={1, 0.1, -1, -0.1, 0, 0.1} }
  track { dir=-1, mtable=tbl, mflow=map }
  assertEquals(#tbl, 3*2)
  print()
  tbl:write(io.stdout)
end

function TestTrackDrift:testNST()
  local seq = sequence 'seq' { refer='entry', drift 'df' { l=1, nstep=10 }}
  seq:select(observe)
  seq.df:set_methods { naction=fill_tbl }
  seq.df:deselect(observe)

  local beam = beam { particle='proton', energy=100 }
  local tbl = track { sequence=seq, beam=beam, X0={1, 0.1, -1, -0.1, 0, 0.1} }
  assertEquals(#tbl, 3+seq.df.nstep)
  print()
  tbl:write(io.stdout)
end

function TestTrackDrift:testBacktrackNST()
  local seq = sequence 'seq' { refer='entry', drift 'df' { l=1, nstep=10 }}
  seq:select(observe)
  seq.df:set_methods { naction=fill_tbl }
  seq.df:deselect(observe)

  local beam = beam { particle='proton', energy=100 }
  local tbl = track { sequence=seq, beam=beam, X0={1, 0.1, -1, -0.1, 0, 0.1}, dir=-1 }
  assertEquals(#tbl, 3+seq.df.nstep)
  print()
  tbl:write(io.stdout)
end

function TestTrackDrift:testBackAndForthNST()
  local seq = sequence 'seq' { refer='entry', drift 'df' { l=1, nstep=10 }}
  seq:select(observe)
  seq.df:set_methods { naction=fill_tbl }
  seq.df:deselect(observe)

  local beam = beam { particle='proton', energy=100 }
  local tbl, map = track { sequence=seq, beam=beam, X0={1, 0.1, -1, -0.1, 0, 0.1} }
  track { dir=-1, mtable=tbl, mflow=map }
  assertEquals(#tbl, (3+seq.df.nstep)*2)
  print()
  tbl:write(io.stdout)
end

function TestTrackDrift:testManyNST()
  local seq = sequence 'seq' { refer='entry', drift 'df' { l=1, nstep=1e4 }}
  seq:select(observe)
  seq.df:set_methods { naction=fill_tbl_1000 }
  seq.df:deselect(observe)

  local beam = beam { particle='proton', energy=100 }
  local tbl = track { sequence=seq, beam=beam, X0={1, 0.1, -1, -0.1, 0, 0.1} }
  assertEquals(#tbl, 3+seq.df.nstep/1e3)
  print()
  tbl:write(io.stdout)
end

function TestTrackDrift:testBacktrackManyNST()
  local seq = sequence 'seq' { refer='entry', drift 'df' { l=1, nstep=1e4 }}
  seq:select(observe)
  seq.df:set_methods { naction=fill_tbl_1000 }
  seq.df:deselect(observe)

  local beam = beam { particle='proton', energy=100 }
  local tbl = track { sequence=seq, beam=beam, X0={1, 0.1, -1, -0.1, 0, 0.1}, dir=-1 }
  assertEquals(#tbl, 3+seq.df.nstep/1e3)
  print()
  tbl:write(io.stdout)
end

function TestTrackDrift:testBackAndForthManyNST()
  local seq = sequence 'seq' { refer='entry', drift 'df' { l=1, nstep=1e4 }}
  seq:select(observe)
  seq.df:set_methods { naction=fill_tbl_1000 }
  seq.df:deselect(observe)

  local beam = beam { particle='proton', energy=100 }
  local tbl, map = track { sequence=seq, beam=beam, X0={1, 0.1, -1, -0.1, 0, 0.1} }
  track { dir=-1, mtable=tbl, mflow=map }
  assertEquals(#tbl, (3+seq.df.nstep/1e3)*2)
  print()
  tbl:write(io.stdout)
end

function TestTrackDrift:testBackAndForthAccuracy()
  local seq = sequence 'seq' { refer='entry', drift 'df' { l=1, nstep=10 } }
  seq.df:select(observe)

  local beam = beam { particle='proton', energy=100 }
  local tbl, map = track { sequence=seq, beam=beam, X0={1e-3, 1e-8, -1e-3, -1e-8, 0, 1e-8} }
  for i=1,999 do
    track { dir=-map.mdir, mtable=tbl, mflow=map }
  end
  assertEquals(#tbl, 1000)
  print()
  tbl:write(io.stdout)
end

function TestTrackDrift:testManyTurnsBackAndForthAccuracy()
  local seq = sequence 'seq' { refer='entry', drift 'df' { l=1, nstep=10 } }
  seq.df:select(observe)

  local beam = beam { particle='proton', energy=100 }
  local X0 = {1e-3, 1e-9, -1e-3, -1e-9, 0, 1e-6}
  local tbl, map = track { sequence=seq, beam=beam, X0=X0, nturn=999 }
  track { dir=-1, mtable=tbl, mflow=map, nturn=999 }
  assertEquals(#tbl, 2000)
  local res = tbl[-1]
  print()
  for i=1,#res do print('res:',i,res[i]) end

  assertAllAlmostEquals(tbl[-1], X0, 1e-14)
--  print()
--  tbl:write(io.stdout)
end

]]

-- end ------------------------------------------------------------------------o
