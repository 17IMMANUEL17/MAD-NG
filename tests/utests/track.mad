--[=[
 o-----------------------------------------------------------------------------o
 |
 | Track tests
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: I. Tecker, irina.tecker at cern.ch
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide regression test suites for the track module.

 o-----------------------------------------------------------------------------o
]=]

--[[
chg  = particle charge
edir = element direction (e.g. lhcb2, dir=-1)
sdir = tracking s-direction
tdir = tracking time direction (=edir*sdir)
bdir = tracking beam direction (=edir*sdir*chg)

      edir  sdir  chg  |  tdir  bdir
FODO   1     1     1   |   1     1
FODO  -1     1     1   |  -1    -1
ODOF   1    -1     1   |  -1    -1
ODOF  -1    -1     1   |   1     1

DOFO   1     1    -1   |   1    -1
DOFO  -1     1    -1   |  -1     1
OFOD   1    -1    -1   |  -1     1
OFOD  -1    -1    -1   |   1    -1

Usage of directions:
  - lengths        are multiplied by sdir
  - bending angles are multiplied by tdir
  - strengths      are multiplied by bdir
--]]

-- locals ---------------------------------------------------------------------o

local assertTrue, assertEquals, assertAllAlmostEquals           in MAD.utest
local printf, openfile, collectlocal                            in MAD.utility
local is_number                                                 in MAD.typeid
local eps, pi                                                   in MAD.constant

local track, beam, element, sequence, option, filesys           in MAD
local fnil, ftrue                                               in MAD.gfunc

local marker, drift, kicker, multipole, sbend, rbend,
      quadrupole, sextupole, octupole, decapole, dodecapole,
      solenoid, rfcavity                                        in element
local observe                                                   in element.flags

local dat = assert(loadfile('data/track.dat'))()

local refdir = \s -> 'track_ref/'..(s or '')
local rundir = \s -> 'track_run/'..(s or '')

local tenv = setmetatable(collectlocal(),{__index=_G}) -- ; show(tenv)

filesys.mkdir(rundir()) -- create xxx_run

-- helpers --------------------------------------------------------------------o

local doplot = false

if doplot then
  local pause, atexit in MAD.utility
  atexit(pause, true)
end

local function plot (mtbl)
  if not doplot then return end
  MAD.plot { table=mtbl, title=mtbl.title,
             x1y1 = { s={'x','px','y','py','t','pt'} } }
end

local function plotxy (mtbl)
  if not doplot then return end
  MAD.plot { table=mtbl, title=mtbl.title, x1y1 = { x='x', y='y'} }
end

-- local -------------------------o

local tblcol = {'name','s','x','px','y','py','t','pt'}
local tblhdr = {'title','type','origin','date','time'}

local slc_p1  = {1}
local slc_p2  = {0.5, 0.5}
local slc_p3  = {1/3, 1/3, 1/3}
local slc_p10 = {0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1}

-- sequences ---------------------o

local function mkDRIFT (dir_, chg_)
  local dir = dir_ or 1 -- sequence direction
  local seq = sequence 'seq' { l=10, refer='entry', dir=dir,
    drift 'd1' {at=0, l=1.5},
    drift 'd2' {at=5, l=1.5},
  }
  return seq   -- seq:dumpseq()
end

local function mkMULT (dir_, chg_)
  local dir = dir_ or 1 -- sequence direction
  local chg = chg_ or 1 -- particle charge
  local k0f =  2*pi/1e2/1.5*dir*chg
  local k0d = -2*pi/1e2/1.5*dir*chg
  local k1f =  0.2110222185*dir*chg
  local k1d = -0.2110222186*dir*chg
  local seq = sequence 'seq' { l=10, refer='entry', dir=dir,
    multipole 'm1' {at=0, lrad=1.5, knl={k0f*1.5,k1f*1.5}, angle=k0f*chg*1.5},
    multipole 'm2' {at=5, lrad=1.5, knl={k0d*1.5,k1d*1.5}, angle=k0d*chg*1.5},
  }
  return seq   -- seq:dumpseq()
end

local function mkSBEND (dir_, chg_, mul)
  local dir = dir_ or 1 -- sequence direction
  local chg = chg_ or 1 -- particle charge
  local k0f =  2*pi/1e2/1.5*dir*chg
  local k0d = -2*pi/1e2/1.5*dir*chg
  local seq = sequence 'seq' { l=10, refer='entry', dir=dir,
    sbend 'm1' {at=0, l=1.5, k0=k0f*(1-mul), knl={k0f*mul*1.5}, angle=k0f*chg*1.5,
                kill_ent_fringe=true, kill_exi_fringe=true},
    sbend 'm2' {at=5, l=1.5, k0=k0d*(1-mul), knl={k0d*mul*1.5}, angle=k0d*chg*1.5,
                kill_ent_fringe=true, kill_exi_fringe=true},
  }
  return seq   -- seq:dumpseq()
end

local function mkSBENDfr (dir_, chg_, mul)
  local dir = dir_ or 1 -- sequence direction
  local chg = chg_ or 1 -- particle charge
  local k0f =  2*pi/1e2/1.5*dir*chg
  local k0d = -2*pi/1e2/1.5*dir*chg
  local seq = sequence 'seq' { l=10, refer='entry', dir=dir,
    sbend 'm1' {at=0, l=1.5, k0=k0f*(1-mul), knl={k0f*mul*1.5}, angle=k0f*chg*1.5},
    sbend 'm2' {at=5, l=1.5, k0=k0d*(1-mul), knl={k0d*mul*1.5}, angle=k0d*chg*1.5},
  }
  return seq   -- seq:dumpseq()
end

local function mkSBENDfr2 (dir_, chg_, mul)
  local dir = dir_ or 1 -- sequence direction
  local chg = chg_ or 1 -- particle charge
  local k0f =  2*pi/1e2/1.5*dir*chg
  local k0d = -2*pi/1e2/1.5*dir*chg
  local e1  = \s -> s.angle/2
  local e2  = \s -> s.angle/1.5
  local seq = sequence 'seq' { l=10, refer='entry', dir=dir,
    sbend 'm1' {at=0, l=1.5, k0=k0f*(1-mul), knl={k0f*mul*1.5}, angle=k0f*chg*1.5,
                             hgap=0.03, e1=e1, e2=e2},
    sbend 'm2' {at=5, l=1.5, k0=k0d*(1-mul), knl={k0d*mul*1.5}, angle=k0d*chg*1.5,
                             hgap=0.03, e1=e1, e2=e2},
  }
  return seq   -- seq:dumpseq()
end

local function mkRBEND (dir_, chg_, mul) -- MAD-X like RBEND
  local dir = dir_ or 1 -- sequence direction
  local chg = chg_ or 1 -- particle charge
  local k0f =  2*pi/1e2/1.5*dir*chg
  local k0d = -2*pi/1e2/1.5*dir*chg
  local seq = sequence 'seq' { l=10, refer='entry', dir=dir,
    rbend 'm1' {at=0, l=1.5, k0=k0f*(1-mul), knl={k0f*mul*1.5}, angle=k0f*chg*1.5,
                kill_ent_fringe=true, kill_exi_fringe=true},
    rbend 'm2' {at=5, l=1.5, k0=k0d*(1-mul), knl={k0d*mul*1.5}, angle=k0d*chg*1.5,
                kill_ent_fringe=true, kill_exi_fringe=true},
  }
  return seq   -- seq:dumpseq()
end

local function mkRBENDfr (dir_, chg_, mul) -- MAD-X like RBEND
  local dir = dir_ or 1 -- sequence direction
  local chg = chg_ or 1 -- particle charge
  local k0f =  2*pi/1e2/1.5*dir*chg
  local k0d = -2*pi/1e2/1.5*dir*chg
  local seq = sequence 'seq' { l=10, refer='entry', dir=dir,
    rbend 'm1' {at=0, l=1.5, k0=k0f*(1-mul), knl={k0f*mul*1.5}, angle=k0f*chg*1.5},
    rbend 'm2' {at=5, l=1.5, k0=k0d*(1-mul), knl={k0d*mul*1.5}, angle=k0d*chg*1.5},
  }
  return seq   -- seq:dumpseq()
end

local function mkQUAD (dir_, chg_, mul, skw)
  local dir = dir_ or 1 -- sequence direction
  local chg = chg_ or 1 -- particle charge
  local tlt =  pi/4        *dir*skw
  local k1f =  0.2110222185*dir*chg
  local k1d = -0.2110222186*dir*chg
  local seq = sequence 'seq' { l=10, refer='entry', dir=dir,
    quadrupole 'm1' {at=0, l=1.5, k1  =  k1f*(1-skw)*(1-mul),
                                  k1s =  k1f*   skw *(1-mul),
                                  knl={0,k1f*(1-skw)*   mul*1.5},
                                  ksl={0,k1f*   skw *   mul*1.5}, tilt=tlt},
    quadrupole 'm2' {at=5, l=1.5, k1  =  k1d*(1-skw)*(1-mul),
                                  k1s =  k1d*   skw *(1-mul),
                                  knl={0,k1d*(1-skw)*   mul*1.5},
                                  ksl={0,k1d*   skw *   mul*1.5}, tilt=tlt},
  }
  return seq   -- seq:dumpseq()
end

local function mkSEXT (dir_, chg_, mul, skw)
  local dir = dir_ or 1 -- sequence direction
  local chg = chg_ or 1 -- particle charge
  local tlt =  pi/6*dir*skw
  local k2f =  0.25*dir*chg
  local k2d = -0.2 *dir*chg
  local seq = sequence 'seq' { l=10, refer='entry', dir=dir,
    sextupole 'm1' {at=0, l=1.5, k2  =    k2f*(1-skw)*(1-mul),
                                 k2s =    k2f*   skw *(1-mul),
                                 knl={0,0,k2f*(1-skw)*   mul*1.5},
                                 ksl={0,0,k2f*   skw *   mul*1.5}, tilt=tlt},
    sextupole 'm1' {at=5, l=1.5, k2  =    k2d*(1-skw)*(1-mul),
                                 k2s =    k2d*   skw *(1-mul),
                                 knl={0,0,k2d*(1-skw)*   mul*1.5},
                                 ksl={0,0,k2d*   skw *   mul*1.5}, tilt=tlt},
  }
  return seq   -- seq:dumpseq()
end

local function mkOCTU (dir_, chg_, mul, skw)
  local dir = dir_ or 1 -- sequence direction
  local chg = chg_ or 1 -- particle charge
  local tlt =  pi/8*dir*skw
  local k3f =  0.25*dir*chg
  local k3d = -0.2 *dir*chg
  local seq = sequence 'seq' { l=10, refer='entry', dir=dir,
    octupole 'm1' {at=0, l=1.5, k3  =      k3f*(1-skw)*(1-mul),
                                k3s =      k3f*   skw *(1-mul),
                                knl={0,0,0,k3f*(1-skw)*   mul*1.5},
                                ksl={0,0,0,k3f*   skw *   mul*1.5}, tilt=tlt},
    octupole 'm1' {at=5, l=1.5, k3  =      k3d*(1-skw)*(1-mul),
                                k3s =      k3d*   skw *(1-mul),
                                knl={0,0,0,k3d*(1-skw)*   mul*1.5},
                                ksl={0,0,0,k3d*   skw *   mul*1.5}, tilt=tlt},
  }
  return seq   -- seq:dumpseq()
end

local function mkDECA (dir_, chg_, mul, skw)
  local dir = dir_ or 1 -- sequence direction
  local chg = chg_ or 1 -- particle charge
  local tlt =  pi/10*dir*skw
  local k4f =  0.25 *dir*chg
  local k4d = -0.2  *dir*chg
  local seq = sequence 'seq' { l=10, refer='entry', dir=dir,
    decapole 'm1' {at=0, l=1.5, k4  =        k4f*(1-skw)*(1-mul),
                                k4s =        k4f*   skw *(1-mul),
                                knl={0,0,0,0,k4f*(1-skw)*   mul*1.5},
                                ksl={0,0,0,0,k4f*   skw *   mul*1.5}, tilt=tlt},
    decapole 'm1' {at=5, l=1.5, k4  =        k4d*(1-skw)*(1-mul),
                                k4s =        k4d*   skw *(1-mul),
                                knl={0,0,0,0,k4d*(1-skw)*   mul*1.5},
                                ksl={0,0,0,0,k4d*   skw *   mul*1.5}, tilt=tlt},
  }
  return seq   -- seq:dumpseq()
end

local function mkDODECA (dir_, chg_, mul, skw)
  local dir = dir_ or 1 -- sequence direction
  local chg = chg_ or 1 -- particle charge
  local tlt =  pi/12*dir*skw
  local k5f =  0.25 *dir*chg
  local k5d = -0.2  *dir*chg
  local seq = sequence 'seq' { l=10, refer='entry', dir=dir,
    dodecapole 'm1' {at=0, l=1.5, k5  =          k5f*(1-skw)*(1-mul),
                                  k5s =          k5f*   skw *(1-mul),
                                  knl={0,0,0,0,0,k5f*(1-skw)*   mul*1.5},
                                  ksl={0,0,0,0,0,k5f*   skw *   mul*1.5}, tilt=tlt},
    dodecapole 'm1' {at=5, l=1.5, k5  =          k5d*(1-skw)*(1-mul),
                                  k5s =          k5d*   skw *(1-mul),
                                  knl={0,0,0,0,0,k5d*(1-skw)*   mul*1.5},
                                  ksl={0,0,0,0,0,k5d*   skw *   mul*1.5}, tilt=tlt},
  }
  return seq   -- seq:dumpseq()
end

local function mkKICK (dir_, chg_)
  local dir = dir_ or 1 -- sequence direction
  local chg = chg_ or 1 -- particle charge
  local hk  = 0.25*1e-4*dir*chg
  local vk  = -0.2*1e-4*dir*chg
  local seq = sequence 'seq' { l=10, refer='entry', dir=dir,
    kicker 'm1' {at=0, l=1.5, hkick=hk, vkick=vk},
    kicker 'm2' {at=5, l=1.5, hkick=hk, vkick=vk},
  }
  return seq   -- seq:dumpseq()
end

local function mkSOL (dir_, chg_, mul)
  local dir = dir_ or 1 -- sequence direction
  local chg = chg_ or 1 -- particle charge
  local ksf =  0.25*dir*chg
  local ksd = -0.2 *dir*chg
  local seq = sequence 'seq' { l=10, refer='entry', dir=dir,
    solenoid 'm1' {at=0, l=1.5, ks=ksf*(1-mul), ksi=ksf*mul*1.5},
    solenoid 'm2' {at=5, l=1.5, ks=ksd*(1-mul), ksi=ksd*mul*1.5},
  }
  return seq   -- seq:dumpseq()
end

local function mkCAV (dir_, chg_)
  local dir = dir_ or 1 -- sequence direction
  local chg = chg_ or 1 -- particle charge
  local volt = 8*dir*chg -- MV
  local freq = 400       -- Mhz
  local lag  = 0.5       -- 2pi unit
  local seq = sequence 'seq' { l=10, refer='entry', dir=dir,
    rfcavity 'm1' {at=0, l=1.5, volt=volt, freq=freq, lag=lag},
    rfcavity 'm2' {at=5, l=1.5, volt=volt, freq=freq, lag=lag},
  }
  return seq   -- seq:dumpseq()
end

-- Generate All Testsuites ----------------------------------------------------o

local dofil = false
local doprt = true
local dochk = false

local t = 'teapot'

collectlocal(1, tenv) -- collect locals

local TODO    = {RBENDptc=true}
local has_TKT = {SBEND=true, SBENDfr=true, SBENDfr2=true,
                 RBEND=true, RBENDfr=true, RBENDptc=true, SOL=true, CAV=true,
                 QUAD=true}
local has_MUL = {SBEND=true, SBENDfr=true, SBENDfr2=true,
                 RBEND=true, RBENDfr=true, RBENDptc=true, SOL=true,
                 QUAD=true, SEXT=true, OCTU=true, DECA=true, DODECA=true}
local has_SKW = {QUAD=true, SEXT=true, OCTU=true, DECA=true, DODECA=true}
local max_ORD = {DRIFT=2, MULT=2}

for _,e in ipairs{'DRIFT','MULT','SBEND','SBENDfr','SBENDfr2','RBEND','RBENDfr',
                  'QUAD','SEXT','OCTU','DECA','DODECA','KICK','SOL','CAV'} do

if not TODO[e] then -- prevent to run tests not yet finalized

  -- generate prelude
  local s = [[
  _G['TestTrack${e}'] = {}

  function TestTrack${e}:setUp ()
    self.optfmt, option.format = option.format, "%-.16e"
  end

  function TestTrack${e}:tearDown ()
    option.format = self.optfmt
  end
  ]] % { e=e }

  -- load prelude within the current context
  local f = assert(loadstring(s)) ; setfenv(f, tenv) ; f()

for _,d in ipairs{0, 2} do                   -- mapdef
for _,o in ipairs{2,'t',4,6,8} do            -- orders
for _,m in ipairs{'DKD', 'TKT'} do           -- models

-- discard invalid combinations
if m == 'DKD' or m == 'TKT' and has_TKT[e] then

for _,z in ipairs{'K', 'M'} do               -- strength/multipoles

-- discard invalid combinations
if z == 'K' or z == 'M' and has_MUL[e] then

for _,w in ipairs{'N', 'S'} do               -- normal/skew

-- discard invalid combinations
if w == 'N' or w == 'S' and has_SKW[e] then

for _,k in ipairs{'',                 -- simple
                  'B', 'R', 'N', 'P', -- backward, reverse, negative, position
                  'BR', 'BN', 'BP', 'RN', 'RP', 'NP',
                  'BRN', 'BRP', 'BNP', 'RNP', 'BRNP'} do

-- discard invalid combinations (e.g. teapot and slices position)
if not (o == 't' and string.find(k,'P',1,true)) then

  -- generate test (adjust DKD2N0K first)
  local s = [[
 assert( TestTrack${e}.test${m}${o}${w}${d}${z}${k} == nil )
function TestTrack${e}:test${m}${o}${w}${d}${z}${k} ()
  local seq  = mk${e}(${r},${s},${y},${j})
  local beam = beam { particle = ${s}>0 and 'positron' or 'electron' }
  for i=1,#dat.X0 do
    local X0   = ${b}>0 and dat.X0[i] or dat.${e}.x${o}${t}[i]
    local mtbl = track {sequence=seq, beam=beam, X0=X0, observe=0, dir=${b},
                        mapdef=${a}, model='${i}', method=${o},
                        nslice=${p}${n}, save='atbody'}
    local row = mtbl[#mtbl]
    local res = {row.x, row.px, row.y, row.py, row.t, row.pt}
    local ref = ${b}<0 and dat.X0[i] or dat.${e}.x${o}${t}[i]
    if dofil then
      mtbl:write(rundir('${e}_${w}${z}${m}${n}D${d}M${o}${k}'..i),tblcol,tblhdr)
    end
    if doprt then
      if i == 1 then io.write('\n') end
      io.write(string.format("% 2d {% .16e,% .16e,% .16e,% .16e,% .16e,% .16e},\n",
                                 i, res[1],res[2],res[3],res[4],res[5],res[6]))
    end
    if dochk then
      assertAllAlmostEquals(res, ref, ${c}*eps)
    end
  end
end]]
% { e=e, d=d, o=o, m=m, k=k, w=w, z=z,
    i=({DKD='DKD', TKT='TKT'})[m],
    n=({DKD=3    , TKT=1    })[m],
    t=({DKD=''   , TKT='t'  })[m],
    j=({N=0      , S=1      })[w],
    y=({K=0      , M=1      })[z],
    a=({[0]=false, [2]=true})[d],
    b = string.find(k,'B',1,true) and -1 or 1,        -- track dir
    r = string.find(k,'R',1,true) and -1 or 1,        -- sequ  dir
    s = string.find(k,'N',1,true) and -1 or 1,        -- charge sign
    p = string.find(k,'P',1,true) and 'slc_p' or '',  -- position
    c = d >  0   and 'dat.'..e..'.eps_t' or           -- eps_{t,s,b,_}
        w == 'S' and 'dat.'..e..'.eps_s' or
        string.find(k,'B',1,true) and 'dat.'..e..'.eps_b' or
        'dat.'..e..'.eps',
  }

  -- load test within the current context
  local f = assert(loadstring(s)) ; setfenv(f, tenv) ; f()

end -- if  o is 't'
end -- for k
end -- if  w
end -- for w
end -- if  z
end -- for z
end -- if  m
end -- for m

-- stop at max order
if o == max_ORD[e] then break end

end -- for o
end -- for d
end -- if  e
end -- for e

-- end ------------------------------------------------------------------------o
