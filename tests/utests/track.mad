--[=[
 o-----------------------------------------------------------------------------o
 |
 | Track tests
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: I. Tecker, irina.tecker at cern.ch
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide regression test suites for the track module.

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local assertTrue, assertEquals, assertAllAlmostEquals           in MAD.utest
local printf, openfile                                          in MAD.utility
local eps                                                       in MAD.constant

local track, beam, element, sequence, option, filesys           in MAD
local fnone, ftrue                                              in MAD.gfunc

local marker, drift, quadrupole                                 in element
local observe                                                   in element.flags

local refdir = \s -> 'track_ref/'..(s or '')
local rundir = \s -> 'track_run/'..(s or '')

-- helpers --------------------------------------------------------------------o

local doplot = false

if doplot then
  MAD.atexit(MAD.utility.pause, true)
end

local function plot (mtbl)
  if not doplot then return end
  MAD.plot { table=mtbl, title=mtbl.title,
             x1y1 = { s={'x','px','y','py','t','pt'} } }
end

local function plotxy (mtbl)
  if not doplot then return end
  MAD.plot { table=mtbl, title=mtbl.title, x1y1 = { x='x', y='y'} }
end

-- FODO -----------------------------------------------------------------------o

-- local -------------------------o

local fodo_col = {'name','s','x','px','y','py','t','pt'}
local fodo_hdr = {'title','type','origin','date','time'}

local fodo_x0  = { 0, 1e-6, 0, 5e-7, 0, 0 }
local fodo_xs  = {1.5433238607360e-05, 2.3753333674496e-06, 1.6583524641784e-06, -3.2690002614600e-07, -1.5589363133728e-11, 0}
local fodo_xt  = {1.5436743243861e-05, 2.3761795220549e-06, 1.6604086350613e-06, -3.2640098568520e-07, -1.5593804025826e-11, 0}
local fodo_x4  = {1.5437395791143e-05, 2.3762576659292e-06, 1.6604080673547e-06, -3.2644362408505e-07, -1.5594858737700e-11, 0}
local fodo_x6  = {1.5437401007418e-05, 2.3762588823733e-06, 1.6604045783414e-06, -3.2644454015065e-07, -1.5594858737700e-11, 0}
local fodo_x8  = {1.5437401009067e-05, 2.3762588827028e-06, 1.6604045790120e-06, -3.2644454002437e-07, -1.5594858737700e-11, 0}
local fodo_xe  = {1.5437401009067e-05, 2.3762588827029e-06, 1.6604045790121e-06, -3.2644454002439e-07, -1.5440981826487e-11, 0}
local fodo_ptc = {1.543740101e-05    , 2.376258883e-06    , 1.660404579e-06    , -3.2644454e-07      , -1.544098183e-11    , 0}
-- ptc_create_layout, model=2, method=2, nst=1, time=true, exact=true;
-- ptc_track, icase=56, closed_orbit=false, dump, onetable, element_by_element, file="ptctrack_fodo_madx.";

local function mkFODO (dir_, chg_)
  local dir    = dir_ or 1
  local chg    = chg_ or 1
  local mqf_k1 =  0.3037241107*dir*chg
  local mqd_k1 = -0.3037241107*dir*chg
  local seq = sequence 'seq' { l=10, refer='entry', dir=dir,
    quadrupole 'mqf' {at=0, l=1, k1:=mqf_k1},
    drift      'dff' {at=1, l=4},
    quadrupole 'mqd' {at=5, l=1, k1:=mqd_k1},
    drift      'dfd' {at=6, l=4},
  }
  return seq   -- seq:dumpseq()
end

-- Testsuite ---------------------o

TestTrackFODO = {}

function TestTrackFODO:setUp ()
  filesys.mkdir(rundir())
  self.optfmt = option.format
  option.format = "%-.10g"
end

function TestTrackFODO:tearDown ()
  option.format = self.optfmt
end

-- DKD model

function TestTrackFODO:testDKD10S () -- simple
  local seq = mkFODO()
  local X0 = fodo_x0
  local mtbl, mflw = track {sequence=seq, beam=beam, X0=X0, observe=0, model='DKD', nslice=10 }

  mtbl:write(rundir('fodo_dkd10s'), fodo_col, fodo_hdr)

  local row = mtbl[#mtbl]
  local res = {row.x, row.px, row.y, row.py, row.t, row.pt}
  local ref = fodo_xs
  assertAllAlmostEquals(res, ref, eps)
end

function TestTrackFODO:testDKD10SB () -- simple, backward
  local seq = mkFODO()
  local X0 = fodo_xs
  local mtbl, mflw = track {sequence=seq, beam=beam, X0=X0, observe=0, model='DKD', nslice=10, dir=-1 }

  mtbl:write(rundir('fodo_dkd10sb'), fodo_col, fodo_hdr)

  local row = mtbl[#mtbl]
  local res = {row.x, row.px, row.y, row.py, row.t, row.pt}
  local ref = fodo_x0
  assertAllAlmostEquals(res, ref, eps)
end

function TestTrackFODO:testDKD10SR () -- simple, reversed
  local seq = mkFODO(-1)
  local X0 = fodo_x0
  local mtbl, mflw = track {sequence=seq, beam=beam, X0=X0, observe=0, model='DKD', nslice=10 }

  mtbl:write(rundir('fodo_dkd10sr'), fodo_col, fodo_hdr)

  local row = mtbl[#mtbl]
  local res = {row.x, row.px, row.y, row.py, row.t, row.pt}
  local ref = fodo_xs
  assertAllAlmostEquals(res, ref, eps)
end

function TestTrackFODO:testDKD10SBR () -- simple, backward, reverse
  local seq = mkFODO(-1)
  local X0 = fodo_xs
  local mtbl, mflw = track {sequence=seq, beam=beam, X0=X0, observe=0, model='DKD', nslice=10, dir=-1 }

  mtbl:write(rundir('fodo_dkd10sbr'), fodo_col, fodo_hdr)

  local row = mtbl[#mtbl]
  local res = {row.x, row.px, row.y, row.py, row.t, row.pt}
  local ref = fodo_x0
  assertAllAlmostEquals(res, ref, eps)
end

function TestTrackFODO:testDKD10SN () -- simple, negative
  local seq, beam = mkFODO(1,-1), beam { particle='electron' }
  local X0 = fodo_x0
  local mtbl, mflw = track {sequence=seq, beam=beam, X0=X0, observe=0, model='DKD', nslice=10 }

  mtbl:write(rundir('fodo_dkd10sn'), fodo_col, fodo_hdr)

  local row = mtbl[#mtbl]
  local res = {row.x, row.px, row.y, row.py, row.t, row.pt}
  local ref = fodo_xs
  assertAllAlmostEquals(res, ref, eps)
end

function TestTrackFODO:testDKD10SBN () -- simple, backward, negative
  local seq, beam = mkFODO(1,-1), beam { particle='electron' }
  local X0 = fodo_xs
  local mtbl, mflw = track {sequence=seq, beam=beam, X0=X0, observe=0, model='DKD', nslice=10, dir=-1 }

  mtbl:write(rundir('fodo_dkd10sbn'), fodo_col, fodo_hdr)

  local row = mtbl[#mtbl]
  local res = {row.x, row.px, row.y, row.py, row.t, row.pt}
  local ref = fodo_x0
  assertAllAlmostEquals(res, ref, eps)
end

function TestTrackFODO:testDKD10SRN () -- simple, reversed, negative
  local seq, beam = mkFODO(-1,-1), beam { particle='electron' }
  local X0 = fodo_x0
  local mtbl, mflw = track {sequence=seq, beam=beam, X0=X0, observe=0, model='DKD', nslice=10 }

  mtbl:write(rundir('fodo_dkd10srn'), fodo_col, fodo_hdr)

  local row = mtbl[#mtbl]
  local res = {row.x, row.px, row.y, row.py, row.t, row.pt}
  local ref = fodo_xs
  assertAllAlmostEquals(res, ref, eps)
end

function TestTrackFODO:testDKD10SBRN () -- simple, backward, reverse, negative
  local seq, beam = mkFODO(-1,-1), beam { particle='electron' }
  local X0 = fodo_xs
  local mtbl, mflw = track {sequence=seq, beam=beam, X0=X0, observe=0, model='DKD', nslice=10, dir=-1 }

  mtbl:write(rundir('fodo_dkd10sbrn'), fodo_col, fodo_hdr)

  local row = mtbl[#mtbl]
  local res = {row.x, row.px, row.y, row.py, row.t, row.pt}
  local ref = fodo_x0
  assertAllAlmostEquals(res, ref, eps)
end

function TestTrackFODO:testDKD10T () -- teapot
  local seq = mkFODO()
  local X0 = fodo_x0
  local mtbl, mflw = track {sequence=seq, beam=beam, X0=X0, observe=0, model='DKD', method='teapot', nslice=10 }

  mtbl:write(rundir('fodo_dkd10t'), fodo_col, fodo_hdr)

  local row = mtbl[#mtbl]
  local res = {row.x, row.px, row.y, row.py, row.t, row.pt}
  local ref = fodo_xt
  assertAllAlmostEquals(res, ref, eps)
end

function TestTrackFODO:testDKD10TB () -- teapot, backward
  local seq = mkFODO()
  local X0 = fodo_xt
  local mtbl, mflw = track {sequence=seq, beam=beam, X0=X0, observe=0, model='DKD', method='teapot', nslice=10, dir=-1 }

  mtbl:write(rundir('fodo_dkd10tb'), fodo_col, fodo_hdr)

  local row = mtbl[#mtbl]
  local res = {row.x, row.px, row.y, row.py, row.t, row.pt}
  local ref = fodo_x0
  assertAllAlmostEquals(res, ref, eps)
end

function TestTrackFODO:testDKD10Y4 () -- yoshida4
  local seq = mkFODO()
  local X0 = fodo_x0
  local mtbl, mflw = track {sequence=seq, beam=beam, X0=X0, observe=0, model='DKD', method='yoshida4', nslice=10 }

  mtbl:write(rundir('fodo_dkd10y4'), fodo_col, fodo_hdr)

  local row = mtbl[#mtbl]
  local res = {row.x, row.px, row.y, row.py, row.t, row.pt}
  local ref = fodo_x4
  assertAllAlmostEquals(res, ref, eps)
end

function TestTrackFODO:testDKD10Y4B () -- yoshida4, backward
  local seq = mkFODO()
  local X0 = fodo_x4
  local mtbl, mflw = track {sequence=seq, beam=beam, X0=X0, observe=0, model='DKD', method='yoshida4', nslice=10, dir=-1 }

  mtbl:write(rundir('fodo_dkd10y4b'), fodo_col, fodo_hdr)

  local row = mtbl[#mtbl]
  local res = {row.x, row.px, row.y, row.py, row.t, row.pt}
  local ref = fodo_x0
  assertAllAlmostEquals(res, ref, eps)
end

function TestTrackFODO:testDKD10Y6 () -- yoshida6
  local seq = mkFODO()
  local X0 = fodo_x0
  local mtbl, mflw = track {sequence=seq, beam=beam, X0=X0, observe=0, model='DKD', method='yoshida6', nslice=10 }

  mtbl:write(rundir('fodo_dkd10y6'), fodo_col, fodo_hdr)

  local row = mtbl[#mtbl]
  local res = {row.x, row.px, row.y, row.py, row.t, row.pt}
  local ref = fodo_x6
  assertAllAlmostEquals(res, ref, eps)
end

function TestTrackFODO:testDKD10Y6B () -- yoshida6, backward
  local seq = mkFODO()
  local X0 = fodo_x6
  local mtbl, mflw = track {sequence=seq, beam=beam, X0=X0, observe=0, model='DKD', method='yoshida6', nslice=10, dir=-1 }

  mtbl:write(rundir('fodo_dkd10y6b'), fodo_col, fodo_hdr)

  local row = mtbl[#mtbl]
  local res = {row.x, row.px, row.y, row.py, row.t, row.pt}
  local ref = fodo_x0
  assertAllAlmostEquals(res, ref, eps)
end

function TestTrackFODO:testDKD10Y8 () -- yoshida8
  local seq = mkFODO()
  local X0 = fodo_x0
  local mtbl, mflw = track {sequence=seq, beam=beam, X0=X0, observe=0, model='DKD', method='yoshida8', nslice=10 }

  mtbl:write(rundir('fodo_dkd10y8'), fodo_col, fodo_hdr)

  local row = mtbl[#mtbl]
  local res = {row.x, row.px, row.y, row.py, row.t, row.pt}
  local ref = fodo_x8
  assertAllAlmostEquals(res, ref, eps)
end

function TestTrackFODO:testDKD10Y8B () -- yoshida8, backward
  local seq = mkFODO()
  local X0 = fodo_x8
  local mtbl, mflw = track {sequence=seq, beam=beam, X0=X0, observe=0, model='DKD', method='yoshida8', nslice=10, dir=-1 }

  mtbl:write(rundir('fodo_dkd10y8b'), fodo_col, fodo_hdr)

  local row = mtbl[#mtbl]
  local res = {row.x, row.px, row.y, row.py, row.t, row.pt}
  local ref = fodo_x0
  assertAllAlmostEquals(res, ref, eps)
end

-- TKT model

function TestTrackFODO:testTKT1S () -- simple
  local seq = mkFODO()
  local X0 = fodo_x0
  local mtbl, mflw = track {sequence=seq, beam=beam, X0=X0, observe=0 }

  mtbl:write(rundir('fodo_tkt1s'), fodo_col, fodo_hdr)

  local row = mtbl[#mtbl]
  local res = {row.x, row.px, row.y, row.py, row.t, row.pt}
  local ref = fodo_xe
  assertAllAlmostEquals(res, ref, eps)
end

function TestTrackFODO:testTKT1SB () -- simple, backward
  local seq = mkFODO()
  local X0 = fodo_xe
  local mtbl, mflw = track {sequence=seq, beam=beam, X0=X0, observe=0, dir=-1 }

  mtbl:write(rundir('fodo_tkt1s'), fodo_col, fodo_hdr)

  local row = mtbl[#mtbl]
  local res = {row.x, row.px, row.y, row.py, row.t, row.pt}
  local ref = fodo_x0
  assertAllAlmostEquals(res, ref, eps)
end

-- Drift ----------------------------------------------------------------------o

--[[ TO REVIEW

TestTrackDrift = {}

local function prt_map_info (elm, m, l, i)
  io.write(elm.name, "[", i, "]: ", m.x, ", ", m.y, ", ", m.t, "\n")
end

local function fill_tbl (elm, m, l, i)
  local mtable in m
  -- keep order!
  mtable = mtable + { elm.name..'..'..i, elm.kind,
                      m.s+l*i, l, m.x, m.px, m.y, m.py, m.t, m.pt }
end

local function fill_tbl_1000 (elm, m, l, i)
  local mtable in m
  -- keep order!
  if i % 1000 == 0 then
    mtable = mtable + { elm.name..'..'..i, elm.kind,
                        m.s+l*i, l, m.x, m.px, m.y, m.py, m.t, m.pt }
  end
end

function TestTrackDrift:setUp ()
  self.optfmt = option.format
  option.format = "%-18.11g"
end

function TestTrackDrift:tearDown ()
  option.format = self.optfmt
end

function TestTrackDrift:testSimple()
  local seq = sequence 'seq' { refer='entry', drift 'df' { l=1 } }
  seq:select(observe)

  local beam = beam { particle='proton', energy=100 }
  local tbl = track { sequence=seq, beam=beam, X0={1, 0.1, -1, -0.1, 0, 0.1} }
  assertEquals(#tbl, 3)
  print()
  tbl:write(io.stdout)
end

function TestTrackDrift:testBacktrack()
  local seq = sequence 'seq' { refer='entry', drift 'df' { l=1 } }
  seq:select(observe)

  local beam = beam { particle='proton', energy=100 }
  local tbl = track { sequence=seq, beam=beam, X0={1, 0.1, -1, -0.1, 0, 0.1}, dir=-1 }
  assertEquals(#tbl, 3)
  print()
  tbl:write(io.stdout)
end

function TestTrackDrift:testBackAndForth()
  local seq = sequence 'seq' { refer='entry', drift 'df' { l=1 } }
  seq:select(observe)

  local beam = beam { particle='proton', energy=100 }
  local tbl, map = track { sequence=seq, beam=beam, X0={1, 0.1, -1, -0.1, 0, 0.1} }
  track { dir=-1, mtable=tbl, mflow=map }
  assertEquals(#tbl, 3*2)
  print()
  tbl:write(io.stdout)
end

function TestTrackDrift:testNST()
  local seq = sequence 'seq' { refer='entry', drift 'df' { l=1, nstep=10 }}
  seq:select(observe)
  seq.df:set_methods { naction=fill_tbl }
  seq.df:deselect(observe)

  local beam = beam { particle='proton', energy=100 }
  local tbl = track { sequence=seq, beam=beam, X0={1, 0.1, -1, -0.1, 0, 0.1} }
  assertEquals(#tbl, 3+seq.df.nstep)
  print()
  tbl:write(io.stdout)
end

function TestTrackDrift:testBacktrackNST()
  local seq = sequence 'seq' { refer='entry', drift 'df' { l=1, nstep=10 }}
  seq:select(observe)
  seq.df:set_methods { naction=fill_tbl }
  seq.df:deselect(observe)

  local beam = beam { particle='proton', energy=100 }
  local tbl = track { sequence=seq, beam=beam, X0={1, 0.1, -1, -0.1, 0, 0.1}, dir=-1 }
  assertEquals(#tbl, 3+seq.df.nstep)
  print()
  tbl:write(io.stdout)
end

function TestTrackDrift:testBackAndForthNST()
  local seq = sequence 'seq' { refer='entry', drift 'df' { l=1, nstep=10 }}
  seq:select(observe)
  seq.df:set_methods { naction=fill_tbl }
  seq.df:deselect(observe)

  local beam = beam { particle='proton', energy=100 }
  local tbl, map = track { sequence=seq, beam=beam, X0={1, 0.1, -1, -0.1, 0, 0.1} }
  track { dir=-1, mtable=tbl, mflow=map }
  assertEquals(#tbl, (3+seq.df.nstep)*2)
  print()
  tbl:write(io.stdout)
end

function TestTrackDrift:testManyNST()
  local seq = sequence 'seq' { refer='entry', drift 'df' { l=1, nstep=1e4 }}
  seq:select(observe)
  seq.df:set_methods { naction=fill_tbl_1000 }
  seq.df:deselect(observe)

  local beam = beam { particle='proton', energy=100 }
  local tbl = track { sequence=seq, beam=beam, X0={1, 0.1, -1, -0.1, 0, 0.1} }
  assertEquals(#tbl, 3+seq.df.nstep/1e3)
  print()
  tbl:write(io.stdout)
end

function TestTrackDrift:testBacktrackManyNST()
  local seq = sequence 'seq' { refer='entry', drift 'df' { l=1, nstep=1e4 }}
  seq:select(observe)
  seq.df:set_methods { naction=fill_tbl_1000 }
  seq.df:deselect(observe)

  local beam = beam { particle='proton', energy=100 }
  local tbl = track { sequence=seq, beam=beam, X0={1, 0.1, -1, -0.1, 0, 0.1}, dir=-1 }
  assertEquals(#tbl, 3+seq.df.nstep/1e3)
  print()
  tbl:write(io.stdout)
end

function TestTrackDrift:testBackAndForthManyNST()
  local seq = sequence 'seq' { refer='entry', drift 'df' { l=1, nstep=1e4 }}
  seq:select(observe)
  seq.df:set_methods { naction=fill_tbl_1000 }
  seq.df:deselect(observe)

  local beam = beam { particle='proton', energy=100 }
  local tbl, map = track { sequence=seq, beam=beam, X0={1, 0.1, -1, -0.1, 0, 0.1} }
  track { dir=-1, mtable=tbl, mflow=map }
  assertEquals(#tbl, (3+seq.df.nstep/1e3)*2)
  print()
  tbl:write(io.stdout)
end

function TestTrackDrift:testBackAndForthAccuracy()
  local seq = sequence 'seq' { refer='entry', drift 'df' { l=1, nstep=10 } }
  seq.df:select(observe)

  local beam = beam { particle='proton', energy=100 }
  local tbl, map = track { sequence=seq, beam=beam, X0={1e-3, 1e-8, -1e-3, -1e-8, 0, 1e-8} }
  for i=1,999 do
    track { dir=-map.mdir, mtable=tbl, mflow=map }
  end
  assertEquals(#tbl, 1000)
  print()
  tbl:write(io.stdout)
end

function TestTrackDrift:testManyTurnsBackAndForthAccuracy()
  local seq = sequence 'seq' { refer='entry', drift 'df' { l=1, nstep=10 } }
  seq.df:select(observe)

  local beam = beam { particle='proton', energy=100 }
  local X0 = {1e-3, 1e-9, -1e-3, -1e-9, 0, 1e-6}
  local tbl, map = track { sequence=seq, beam=beam, X0=X0, nturn=999 }
  track { dir=-1, mtable=tbl, mflow=map, nturn=999 }
  assertEquals(#tbl, 2000)
  local res = tbl[-1]
  print()
  for i=1,#res do print('res:',i,res[i]) end

  assertAllAlmostEquals(tbl[-1], X0, 1e-14)
--  print()
--  tbl:write(io.stdout)
end

]]

-- end ------------------------------------------------------------------------o
