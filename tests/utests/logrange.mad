--[=[
 o-----------------------------------------------------------------------------o
 |
 | Range module regression tests - logrange
 |
 | Methodical Accelerator Design - Copyright CERN 2015+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: A.Z. Teska, aleksandra.teska at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide regression test suites for the range module.

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local assertEquals, assertAlmostEquals, assertTrue, assertFalse,
      assertErrorMsgContains, assertNil, assertNaN, assertIsString
      in require 'luaunit'

local range   , nrange   , irange   , is_range,
      logrange, nlogrange, ilogrange, is_logrange, log,
      tiny, eps, huge, inf, nan in MAD
local is_function in MAD
local exp         in math

-- regression test suite ------------------------------------------------------o

TestLogrange = {}

local values = {
  limit = { huge, tiny, inf },
  num   = {2^-64, 2^-63, 2^-53, eps, 2^-52, 2*eps, 2^-32, 2^-31, 1e-9,
          0.1-eps, 0.1, 0.1+eps, 0.5, 0.7-eps, 0.7, 0.7+eps, 1-eps, 1, 1+eps,
          1.1, 1.7, 2, 10, 1e2, 1e3, 1e6, 1e9, 2^31, 2^32, 2^52, 2^53,
          2^63, 2^64 },
  lrng =   {
           { 10^5, 1    , 0.1},
           { 1   , 10^5 , 10 },
           { 1   , 10^-5, 0.1},
           },
  lempty = {
           { 10^5, 1    , 10 },
           { 1   , 10^5 , 0.1},
           { 1   , 10^-5, 10 },
           },
}

function TestLogrange:testConstructor()
    local a = 2
  local msg = {
    "invalid argument #1 (positive number expected)",
    "invalid argument #2 (positive number expected)",
    "invalid argument #3 (positive number expected)",
    "cannot convert 'string' to 'const double'"     ,
  }
  assertErrorMsgContains( msg[1],  logrange            )
  assertErrorMsgContains( msg[1],  logrange,-1         )
  assertErrorMsgContains( msg[1],  logrange, nil, 1    )
  assertErrorMsgContains( msg[1],  logrange, 1..10..2  )
  assertErrorMsgContains( msg[1],  logrange, ''        )
  assertErrorMsgContains( msg[2],  logrange, 1, ''     )
  assertErrorMsgContains( msg[3],  logrange, 1, 10, '' )
  assertErrorMsgContains( msg[1],  logrange,-a,-a      )
  assertErrorMsgContains( msg[1],  logrange,-a,-a,-a   )
  assertErrorMsgContains( msg[3],  logrange, 1  , 10 , nan )
  assertErrorMsgContains( msg[2],  logrange, 1  , nan, nan )
  assertErrorMsgContains( msg[1],  logrange, nan, nan, nan )
  assertErrorMsgContains( msg[3],  logrange, 1  , 10 ,-nan )
  assertErrorMsgContains( msg[2],  logrange, 1  , nan,-nan )
  assertErrorMsgContains( msg[1],  logrange,-nan,-nan,-nan )
  assertErrorMsgContains( msg[3],  logrange, 1  , 10^5,-10 )
  assertErrorMsgContains( msg[2],  logrange, 1  ,-10^5, 10 )
  assertErrorMsgContains( msg[1],  logrange,-1  , 10^5, 10 )
  assertErrorMsgContains( msg[3],  logrange, 1  , 10^5, 0  )
  assertErrorMsgContains( msg[3], nlogrange, 1  , 10^5,-1  )
  assertErrorMsgContains( msg[3], nlogrange, 1  , 10^5, 0  )
  assertErrorMsgContains( msg[2], nlogrange, 1  , 0   , 1  )
  assertErrorMsgContains( msg[1], nlogrange, 0  , 10^5, 1  )

  assertTrue( is_logrange( logrange(1)       ) )
  assertTrue( is_logrange( logrange(1,10)    ) )
  assertTrue( is_logrange( logrange( a, a)   ) )
  assertTrue( is_logrange( logrange( a, a, a)) )

  for _,v in ipairs(values.lrng) do
    assertTrue( is_logrange( logrange(v[1],v[2],v[3]) ) )
  end
  for _,v in ipairs(values.lempty) do
    assertTrue( is_logrange( logrange(v[1],v[2],v[3]) ) )
  end
  for _,v in ipairs(values.limit) do
    assertTrue( is_logrange(logrange( 1,  10, v)) )
    assertTrue( is_logrange(logrange( 1 , v , v)) )
    assertTrue( is_logrange(logrange( v , v , v)) )
  end
end

function TestLogrange:testFields()
--diffrent output for range() /.start /.stop /.start

  assertEquals( {logrange( 1 ):range()}, { 1, 1, exp(1)} )
  assertEquals( logrange( 1 ).start, log(1) )
  assertEquals( logrange( 1 ).stop , log(1) )
  assertEquals( logrange( 1 ).step , 1      )

  --assertEquals( {logrange( 1, 10 ):range()}, { 1, 10, exp(1)} )
  --assertEquals( logrange( 1, 10 ).start, log(1)  )
  --assertEquals( logrange( 1, 10 ).stop , log(10) )
  --assertEquals( logrange( 1, 10 ).step , 1       )

  --for _,v in ipairs(values.lempty) do
  --  assertEquals( {range(v[1],v[2],v[3]):range()}, {v[1],v[2],v[3]} )
  --end
  --for _,v in ipairs(values.lrng)do
  --  assertEquals( {range(v[1],v[2],v[3]):range()}, {v[1],v[2],v[3]} )
  --end
  --for _,v in ipairs(values.limit) do
  --  assertEquals( {logrange( 1 ,10, v):range()}, { exp(1),exp(10), exp(v)} )
  --  assertEquals( {logrange( 1, v , v):range()}, { exp(1),exp(v ), exp(v)} )
  --  assertEquals( {logrange( v, v , v):range()}, { exp(v),exp(v ), exp(v)} )
  --end
end

function TestLogrange:testReadonly()
    local f1, f2, f3
  local msg = {
    "attempt to write to constant location",
  }
  for _,v in ipairs(values.num) do
    f1=\r,v => r.start = v end
    assertErrorMsgContains( msg[1], f1, logrange(1,10,0.1), v )
    assertErrorMsgContains( msg[1], f1, nlogrange(1,10,10), v )
    f2=\r,v => r.stop  = v end
    assertErrorMsgContains( msg[1], f2, logrange(1,10,0.1), v )
    assertErrorMsgContains( msg[1], f2, nlogrange(1,10,10), v )
    f3=\r,v => r.step  = v end
    assertErrorMsgContains( msg[1], f3, logrange(1,10,0.1), v )
    assertErrorMsgContains( msg[1], f3, nlogrange(1,10,10), v )
  end
end

-- function TestLogrange:testIsLogrange()
-- end

function TestLogrange:testRange()
  local r
 -- r =  logrange(1)       assertEquals( { r:range() }, {exp(r.start), exp(r.stop), exp(r.step)} )
  r =  logrange(1,10,10) assertEquals( { r:range() }, {exp(r.start), exp(r.stop), exp(r.step)} )
  r = nlogrange(1,10,10) assertEquals( { r:range() }, {exp(r.start), exp(r.stop), exp(r.step)} )

  for _,v in ipairs(values.lempty) do
    r = logrange(v[1],v[2],v[3]) assertEquals( { r:range() }, {exp(r.start), exp(r.stop), exp(r.step)} )
  end
  for _,v in ipairs(values.lrng) do
    r = logrange(v[1],v[2],v[3]) assertEquals( { r:range() }, {exp(r.start), exp(r.stop), exp(r.step)} )
  end
  for _,v in ipairs(values.num) do
    r = logrange( 1 ,10, v)      assertEquals( { r:range() }, {exp(r.start), exp(r.stop), exp(r.step)} )
  end
  --for _,v in ipairs(values.limit) do
  --  r = logrange( 1 ,10, v)  assertEquals( { r:range() }, {r.start, r.stop, r.step} )
  --  r = logrange( 1, v , v)  assertEquals( { r:range() }, {r.start, r.stop, r.step} )
  --  r = logrange( v, v , v)  assertEquals( { r:range() }, {r.start, r.stop, r.step} )
  --  r = logrange(-v,-v ,-v)  assertEquals( { r:range() }, {r.start, r.stop, r.step} )
  --end
end

function TestLogrange:testIsEmpty() -- fix fun
  for _,v in ipairs(values.lempty) do
    assertTrue ( logrange(v[1],v[2],v[3]):is_empty() )
  end
  for _,v in ipairs(values.lrng) do
    assertFalse( logrange(v[1],v[2],v[3]):is_empty() )
  end
  assertFalse( logrange(1)          :is_empty() )
  assertFalse( logrange(1,10)       :is_empty() )
  assertFalse( nlogrange(2, 10, 0.1):is_empty() )
  assertFalse( nlogrange(2, 10, nan):is_empty() )

 --[[for _,v in ipairs(values.num) do
    if v~=0 then
      assertFalse( logrange( 1 , 10, v):is_empty() )
      assertFalse(nlogrange( 1 , 10, v):is_empty() )
    end
  end
  for _,v in ipairs(values.limit) do
    assertFalse( logrange( 1 , 10, v):is_empty() )
    assertFalse( logrange( v , v , v):is_empty() )
  end
end

function TestLogrange:testNConstructor()
  --assertEquals( {nlogrange( 1 )    :range()}, {1,1 ,50 } )

end

function TestLogrange:testSize()
 end

function TestLogrange:testGet()
  local lr
]]
end

--[[
function TestLogrange:testNCnstrFields()
end
function TestLogrange:testValue()
end
function TestLogrange:testIndex()
end
function TestLogrange:testEqual()
end
function TestLogrange:testReverse()
end
function TestLogrange:testNsteplog()
end
function TestLogrange:testBounds()
end
function TestLogrange:testOverlap()
end
function TestLogrange:testIlogrange()
end

-- performance test suite -----------------------------------------------------o

Test_Logrange = {}
function Test_Logrange:testIrange()
end

-- end ------------------------------------------------------------------------o
]]
