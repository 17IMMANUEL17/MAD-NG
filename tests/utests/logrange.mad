--[=[
 o-----------------------------------------------------------------------------o
 |
 | Range module regression tests - logrange
 |
 | Methodical Accelerator Design - Copyright CERN 2015+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: A.Z. Teska, aleksandra.teska at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide regression test suites for the range module.

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local assertEquals, assertAlmostEquals, assertTrue, assertFalse,
      assertErrorMsgContains, assertNil, assertNaN, assertIsString
      in require 'luaunit'

local range   , nrange   , irange   , is_range,
      logrange, nlogrange, ilogrange, is_logrange, log,
      tiny, eps, huge, inf, nan in MAD
local is_function in MAD

-- regression test suite ------------------------------------------------------o

TestLogrange = {}

local values = {
  special = { huge, tiny, inf },
  num   = {0, 2^-64, 2^-63, 2^-53, eps, 2^-52, 2*eps, 2^-32, 2^-31, 1e-9,
          0.1-eps, 0.1, 0.1+eps, 0.5, 0.7-eps, 0.7, 0.7+eps, 1-eps, 1, 1+eps,
          1.1, 1.7, 2, 10, 1e2, 1e3, 1e6, 1e9, 2^31, 2^32, 2^52, 2^53,
          2^63, 2^64 },
  lempty = {
           { 10^5, 1    , 10 },
           { 10^5,-1    , 10 },
           {-10^5, 1    , 10 },
           {-10^5,-1    , 10 },
           {-1   , 10^5 , 10 },
           {-1   ,-10^5 , 0.1},
           { 1   , 10^5 , 0.1},
           { 1   ,-10^5 , 10 },
           { 1   , 10^-5, 10 },
           {-1   ,-10^-5, 10 },
           {-1   , 10^-5, 10 },
           { 1   ,-10^-5, 10 },
           },
  lrng =   {
           { 10^5, 1    , 0.1},
           {-10^5,-1    , 0.1},
           { 1   , 10^5 , 10 },
           {-1   ,-10^5 , 10 },
           {-1   ,-10^-5, 0.1},
           { 1   , 10^-5, 0.1},
           },
  mrng =   {
           { 1   ,-10^5 , 0.1},
           { 10^5,-1    , 0.1},
           {-10^5, 1    , 0.1},
           { 1   ,-10^-5, 0.1},
           {-1   , 10^-5, 0.1},
           {-1   , 10^5 , 0.1},
           },

           --{ 0   , 0   , 0  }, -- to be decided if empty, rather y
           --{ 0   , 0   ,-0  },
--[[ -- to be splited and cleaned up
  altser = {
           { 10^5, 1    ,-10 },
           { 10^5,-1    ,-10 },
           {-10^5, 1    ,-10 },
           {-10^5,-1    ,-10 },
           {-1   , 10^5 ,-10 },
           {-1   ,-10^5 ,-0.1},
           { 1   , 10^5 ,-0.1},
           { 1   ,-10^5 ,-10 },
           { 1   , 10^-5,-10 },
           { 10^5, 1    ,-0.1},
           {-10^5,-1    ,-0.1},
           { 10^5,-1    ,-0.1},
           {-10^5, 1    ,-0.1},
           { 1   , 10^5 ,-10 },
           {-1   ,-10^5 ,-10 },
           { 1   ,-10^5 ,-0.1},
           {-1   , 10^5 ,-0.1},
           {-1   ,-10^-5,-10 },
           { 1   ,-10^-5,-0.1},
           {-1   , 10^-5,-0.1},
           {-1   , 10^-5,-10 },
           {-1   ,-10^-5,-0.1},
           { 1   , 10^-5,-0.1},
           { 1   ,-10^-5,-10 },
    }]]
}

--special values:
  --log(1..10.. 1)
  --log(1..10..-1)
--function TestLogrange:testGrpBld()
---local lr
--  print("non-empty")
--  for _,v in ipairs(values.lrng) do
--    lr = logrange(v[1],v[2],v[3])
--    print( lr:is_empty(), lr:value(0), lr:get(0), lr:range() )
--  end
--  print("\n","empty")
--  for _,v in ipairs(values.lempty) do
--    lr = logrange(v[1],v[2],v[3])
--    print( lr:is_empty(), lr:value(0), lr:get(0), lr:range() )
--  end
--end

function TestLogrange:testConstructor()
    local a = 2
  local msg = {
    "invalid argument #1 (number expected)",
    "cannot convert 'string' to 'const double'",
  }
  assertErrorMsgContains( msg[1], logrange            )
  assertErrorMsgContains( msg[1], logrange, nil, 1    )
  assertErrorMsgContains( msg[1], logrange, 1..10..2  )
  assertErrorMsgContains( msg[1], logrange, ''        )
  assertErrorMsgContains( msg[2], logrange, 1, ''     )
  assertErrorMsgContains( msg[2], logrange, 1, 10, '' )

  assertTrue( is_logrange(logrange(1))           )
  assertTrue( is_logrange(logrange(1,10))        )

  assertTrue( is_logrange( logrange( a, a)   ) )
  assertTrue( is_logrange( logrange(-a,-a)   ) )
  assertTrue( is_logrange( logrange( a, a, a)) )
  assertTrue( is_logrange( logrange(-a,-a,-a)) )

  for _,v in ipairs(values.lrng) do
    assertTrue( is_logrange( logrange(v[1],v[2],v[3]) ) )
  end
  for _,v in ipairs(values.lempty) do
    assertTrue( is_logrange( logrange(v[1],v[2],v[3]) ) )
  end
  for _,v in ipairs(values.special) do
    assertTrue( is_logrange(logrange( 1,  10, v)) )
    assertTrue( is_logrange(logrange( 10, 1 ,-v)) )
    assertTrue( is_logrange(logrange( 1 , v , v)) )
    assertTrue( is_logrange(logrange( 1 ,-v ,-v)) )
    assertTrue( is_logrange(logrange( v , v , v)) )
    assertTrue( is_logrange(logrange(-v ,-v ,-v)) )
  end

  assertTrue( is_logrange(logrange( 1  , 10 , nan)) )
  assertTrue( is_logrange(logrange( 10 , 1  ,-nan)) )
  assertTrue( is_logrange(logrange( 1  , nan, nan)) )
  assertTrue( is_logrange(logrange( 1  ,-nan,-nan)) )
  assertTrue( is_logrange(logrange( nan, nan, nan)) )
  assertTrue( is_logrange(logrange(-nan,-nan,-nan)) )
end

function TestLogrange:testFields()
  assertEquals( {logrange( 1 )    :range()}, {1 ,1 ,2} )
  assertEquals( {logrange( 1 ,10) :range()}, {1 ,10,2} )
  assertEquals( {logrange( 10,1 ) :range()}, {10,1 ,2} )

  for _,v in ipairs(values.lempty) do
    assertEquals( {range(v[1],v[2],v[3]):range()}, {v[1],v[2],v[3]} )
  end
  for _,v in ipairs(values.lrng)do
    assertEquals( {range(v[1],v[2],v[3]):range()}, {v[1],v[2],v[3]} )
  end
  for _,v in ipairs(values.special) do
    assertEquals( {logrange( 1 ,10, v):range()}, { 1,10, v} )
    assertEquals( {logrange( 10, 1,-v):range()}, {10, 1,-v} )
    assertEquals( {logrange( 1, v , v):range()}, { 1, v, v} )
    assertEquals( {logrange( 1,-v ,-v):range()}, { 1,-v,-v} )
    assertEquals( {logrange( v, v , v):range()}, { v, v, v} )
    assertEquals( {logrange(-v,-v ,-v):range()}, {-v,-v,-v} )
  end
  assertNaN( logrange( nan, nan, nan).start )
  assertNaN( logrange( nan, nan, nan).stop  )
  assertNaN( logrange( nan, nan, nan).step  )
  assertNaN( logrange(-nan,-nan,-nan).start )
  assertNaN( logrange(-nan,-nan,-nan).stop  )
  assertNaN( logrange(-nan,-nan,-nan).step  )

  assertEquals(  range( 1, nan, nan).start, 1  )
  assertNaN   (  range( 1, nan, nan).stop      )
  assertNaN   (  range( 1, nan, nan).step      )
  assertEquals(  range( 1, 10 , nan).start, 1  )
  assertEquals(  range( 1, 10 , nan).stop , 10 )
  assertNaN   (  range( 1, 10 , nan).step      )
  assertEquals(  range( 1, 10 ,-nan).start, 1  )
  assertEquals(  range( 1, 10 ,-nan).stop , 10 )
  assertNaN   (  range( 1, 10 ,-nan).step      )
  assertEquals(  range( 1, nan, 10 ).start, 1  )
  assertNaN   (  range( 1, nan, 10 ).stop      )
  assertEquals(  range( 1, nan, 10 ).step ,10  )
  assertEquals(  range( 1,-nan, 10 ).start, 1  )
  assertNaN   (  range( 1,-nan, 10 ).stop      )
  assertEquals(  range( 1,-nan, 10 ).step ,10  )
end

function TestLogrange:testReadonly()
    local f1, f2, f3
  local msg = {
    "attempt to write to constant location",
  }
  for _,v in ipairs(values.num) do
    f1=\r,v => r.start = v end
    assertErrorMsgContains( msg[1], f1, logrange(1,10,0.1), v )
    assertErrorMsgContains( msg[1], f1, nlogrange(1,10,10), v )
    f2=\r,v => r.stop  = v end
    assertErrorMsgContains( msg[1], f2, logrange(1,10,0.1), v )
    assertErrorMsgContains( msg[1], f2, nlogrange(1,10,10), v )
    f3=\r,v => r.step  = v end
    assertErrorMsgContains( msg[1], f3, logrange(1,10,0.1), v )
    assertErrorMsgContains( msg[1], f3, nlogrange(1,10,10), v )
  end
end

-- function TestLogrange:testIsLogrange()
-- end

function TestLogrange:testRange()
  local r
  r =  logrange(1)       assertEquals( { r:range() }, {r.start, r.stop, r.step} )
  r =  logrange(1,10,10) assertEquals( { r:range() }, {r.start, r.stop, r.step} )
  r = nlogrange(1,10,10) assertEquals( { r:range() }, {r.start, r.stop, r.step} )

  for _,v in ipairs(values.lempty) do
    r = logrange(v[1],v[2],v[3]) assertEquals( { r:range() }, {r.start, r.stop, r.step} )
  end
  for _,v in ipairs(values.lrng) do
    r = logrange(v[1],v[2],v[3]) assertEquals( { r:range() }, {r.start, r.stop, r.step} )
  end
  for _,v in ipairs(values.num) do
    r = logrange( 1 ,10, v)  assertEquals( { r:range() }, {r.start, r.stop, r.step} )
    r = logrange( 10, 1,-v)  assertEquals( { r:range() }, {r.start, r.stop, r.step} )
  end
  --for _,v in ipairs(values.special) do
  --  r = logrange( 1 ,10, v)  assertEquals( { r:range() }, {r.start, r.stop, r.step} )
  --  r = logrange( 10, 1,-v)  assertEquals( { r:range() }, {r.start, r.stop, r.step} )
  --  r = logrange( 1, v , v)  assertEquals( { r:range() }, {r.start, r.stop, r.step} )
  --  r = logrange( 1,-v ,-v)  assertEquals( { r:range() }, {r.start, r.stop, r.step} )
  --  r = logrange( v, v , v)  assertEquals( { r:range() }, {r.start, r.stop, r.step} )
  --  r = logrange(-v,-v ,-v)  assertEquals( { r:range() }, {r.start, r.stop, r.step} )
  --end
end

function TestLogrange:testIsEmpty() -- fix fun
  local lr

-- for i=0,3 do print (lr:value(i)) end
 --[[print ("\n step == 1")
  lr = logrange( 1   , 10  , 1  )  print("expect: true", lr:is_empty(),"  lr:", lr:range() )

  print ("\n step > 0")
    print ("step > 1, start >= 0 and start <= stop")
    lr = logrange( 1   , 10^3, 10 )  print("expect: false", lr:is_empty(),"  lr:", lr:range() )
    lr = logrange( 0   , 10^3, 10 )  print("expect: false", lr:is_empty(),"  lr:", lr:range() )
    print ("\n step > 1, start <  0 and start >= stop")
    lr = logrange(-1   ,-10^3, 10 )  print("expect: false", lr:is_empty(),"  lr:", lr:range() )
    lr = logrange(-10^-3,-1  , 10 )  print("expect: false", lr:is_empty(),"  lr:", lr:range() )
    lr = logrange(-10^3,-1   , 10 )  print("expect: true ", lr:is_empty(),"  lr:", lr:range() )
    lr = logrange(-10^3, 1   , 10 )  print("expect: true ", lr:is_empty(),"  lr:", lr:range() )
    print ("\n step < 1, start >= 0 and start >= stop")
    lr = logrange( 10^3, 1   , 0.1)  print("expect: false", lr:is_empty(),"  lr:", lr:range() )
    lr = logrange( 1   , 1   , 0.1)  print("expect: false", lr:is_empty(),"  lr:", lr:range() )
    print ("\n step < 1, start <  0 and start <= stop")
    lr = logrange(-1   ,-10^3, 0.1)  print("expect: true ", lr:is_empty(),"  lr:", lr:range() )
    lr = logrange(-10^3,-1   , 0.1)  print("expect: false", lr:is_empty(),"  lr:", lr:range() )
    lr = logrange(-10^3, 0.01, 0.1)  print("expect: false", lr:is_empty(),"  lr:", lr:range() )
    lr = logrange(-10^3, 1   , 0.1)  print("expect: false", lr:is_empty(),"  lr:", lr:range() )
    lr = logrange(-10^3, 1   , 0.1)  print("expect: false", lr:is_empty(),"  lr:", lr:range() )
    lr = logrange(-10^3,-1   , 0.1)  print("expect: false", lr:is_empty(),"  lr:", lr:range() )

    local abs in MAD
  print ("\n step< 0")
    print ("|step| > 1, start >= 0 and start <= stop")
    lr = logrange( 1   , 10^3,-10 )  print("expect: false", lr:is_empty(),"  lr:", lr:range() )-- for i=0,3 do print (lr:value(i)) end--even -- true
    lr = logrange( 1   , 10^4,-10 )  print("expect: true ", lr:is_empty(),"  lr:", lr:range() )-- for i=0,4 do print (lr:value(i)) end--odd  -- false

    print ("|step| > 1, start >= 0 and start >= stop") -- difrent set / even or odd case
    lr = logrange( 10^3, 1   ,-10 )  print("expect: true ", lr:is_empty(),"  lr:", lr:range() )  --always empty
    lr = logrange( 10^4, 1   ,-10 )  print("expect: true ", lr:is_empty(),"  lr:", lr:range() )  --always empty

    lr = logrange( 1   ,-10^3,-10 )  print("expect: false", lr:is_empty(),"  lr:", lr:range() )-- for i=0,3 do print (lr:value(i)) end --even --false
    lr = logrange( 1   ,-10^4,-10 )  print("expect: true ", lr:is_empty(),"  lr:", lr:range() )-- for i=0,3 do print (lr:value(i)) end --odd  --true

    print ("\n |step| > 1, start <  0 and start <= stop") -- difrent set/ even or odd case
    lr = logrange(-1   , 10^3,-10 )  print("expect: false", lr:is_empty(),"  lr:", lr:range() )-- for i=0,3 do print (lr:value(i)) end --even --false
    lr = logrange(-1   , 10^4,-10 )  print("expect: true ", lr:is_empty(),"  lr:", lr:range() )-- for i=0,3 do print (lr:value(i)) end --odd  --true

    lr = logrange(-10^3,-1   ,-10 )  print("expect: true ", lr:is_empty(),"  lr:", lr:range() )-- always empty
    lr = logrange(-10^4,-1   ,-10 )  print("expect: true ", lr:is_empty(),"  lr:", lr:range() )-- always empty

    print ("\n |step| > 1, start <  0 and start >= stop")-- even or odd case
    lr = logrange(-1   ,-10^3,-10 )  print("expect: true ", lr:is_empty(),"  lr:", lr:range() )-- for i=0,3 do print (lr:value(i)) end --even --true
    lr = logrange(-1   ,-10^4,-10 )  print("expect: false", lr:is_empty(),"  lr:", lr:range() )-- for i=0,3 do print (lr:value(i)) end --odd  --false

    print ("\n |step| < 1, start >= 0 and start >= stop") --depending on the sign of stop
    lr = logrange( 10^3,-1   ,-0.1)  print("expect: false", lr:is_empty(),"  lr:", lr:range() )-- for i=0,3 do print (lr:value(i)) end --even --false
    lr = logrange( 10^4,-1   ,-0.1)  print("expect: true ", lr:is_empty(),"  lr:", lr:range() )-- for i=0,5 do print (lr:value(i)) end --odd  --true

    print ("\n |step| < 1, start <  0 and start <= stop")
    lr = logrange(-10^3, 1   ,-0.1)  print("expect: false", lr:is_empty(),"  lr:", lr:range() ) -- for i=0,3 do print (lr:value(i)) end --even --false
    lr = logrange(-10^4, 1   ,-0.1)  print("expect: false", lr:is_empty(),"  lr:", lr:range() ) -- for i=0,5 do print (lr:value(i)) end --odd  --true

    lr = logrange(-10^3,-1   ,-0.1)  print("expect: true ", lr:is_empty(),"  lr:", lr:range() )-- for i=0,5 do print (lr:value(i)) end
    ]]


    --print ("\n |step| < 1, start >= 0 and start <= stop") -- should return empty
    --print ("\n |step| < 1, start <  0 and start >= stop") -- should return empty
end

function TestLogrange:testNConstructor()
  --assertEquals( {nlogrange( 1 )    :range()}, {1,1 ,50 } )

end

function TestLogrange:testSize()
  --for _,v in ipairs(values.lempty) do
  --  assertEquals( logrange(v[1],v[2],v[3]):size(), 0 )
  --end

  assertEquals( logrange( 10^5, 1    , 0.1):size(), 6 )
  assertEquals( logrange(-10^5,-1    , 0.1):size(), 6 )
  assertEquals( logrange( 1   , 10^5 , 10 ):size(), 6 )
  assertEquals( logrange(-1   ,-10^5 , 10 ):size(), 6 )
  assertEquals( logrange(-1   ,-10^-5, 0.1):size(), 6 )
  assertEquals( logrange( 1   , 10^-5, 0.1):size(), 6 )

  --print( logrange( 1   ,-10^5 , 0.1):size() )
  --print( logrange( 10^5,-1    , 0.1):size() )
  --print( logrange(-10^5, 1    , 0.1):size() )
  --print( logrange( 1   ,-10^-5, 0.1):size() )
  --print( logrange(-1   , 10^-5, 0.1):size() )
  --print( logrange(-1   , 10^5 , 0.1):size() )

  assertEquals( logrange( 10^5, 1    , 10 ):size(), 0 )
  assertEquals( logrange( 10^5,-1    , 10 ):size(), 0 )
  assertEquals( logrange(-10^5, 1    , 10 ):size(), 0 )
  assertEquals( logrange(-10^5,-1    , 10 ):size(), 0 )
  assertEquals( logrange(-1   ,-10^5 , 0.1):size(), 0 )
  assertEquals( logrange( 1   , 10^5 , 0.1):size(), 0 )
  assertEquals( logrange( 1   , 10^-5, 10 ):size(), 0 )
  assertEquals( logrange(-1   ,-10^-5, 10 ):size(), 0 )
  assertEquals( logrange(-1   , 10^-5, 10 ):size(), 0 )
  assertEquals( logrange( 1   ,-10^-5, 10 ):size(), 0 )
  --assertEquals( logrange(-1   , 10^5 , 10 ):size(), 0 )
  --assertEquals( logrange( 1   ,-10^5 , 10 ):size(), 0 )
end

function TestLogrange:testGet()
  local lr

  --lr = nlogrange(1,100,10) for i=1,#lr do print( lr:get(i-1) ) end
  --lr = nlogrange(1,10,10)  for i=1,#lr do print( lr:get(i-1) ) end
  --lr = nlogrange(1,10 ,10) assertAlmostEquals( lr:get(#lr-1) - lr.stop, 0, eps     )
--  print( lr:get(#lr-1) - lr.stop)

  lr = nlogrange(1,100,10)    assertAlmostEquals( lr:get(9) - lr.stop, 0, 130*eps )
  lr = nlogrange(1,10 ,10)    assertAlmostEquals( lr:get(9) - lr.stop, 0, eps     )
  lr = nlogrange(100,1,10)    assertAlmostEquals( lr:get(9) - lr.stop, 0, 2*eps   )
  lr = nlogrange(10 ,1,10)    assertAlmostEquals( lr:get(9) - lr.stop, 0, 3*eps   )
  lr = nlogrange(1,0.01  ,10) assertAlmostEquals( lr:get(9) - lr.stop, 0, eps     )
  lr = nlogrange(1,0.0001,10) assertAlmostEquals( lr:get(9) - lr.stop, 0, eps     )
  lr = nlogrange(0.01  ,1,10) assertAlmostEquals( lr:get(9) - lr.stop, 0, eps     )
  lr = nlogrange(0.0001,1,10) assertAlmostEquals( lr:get(9) - lr.stop, 0, 2*eps   )

  lr = logrange( 10^5, 1    , 0.1)  assertAlmostEquals( lr:get(5) - lr.stop, 0, eps )
  lr = logrange(-10^5,-1    , 0.1)  assertAlmostEquals( lr:get(5) - lr.stop, 0, eps )
  lr = logrange( 1   , 10^5 , 10 )  assertAlmostEquals( lr:get(5) - lr.stop, 0, eps )
  lr = logrange(-1   ,-10^5 , 10 )  assertAlmostEquals( lr:get(5) - lr.stop, 0, eps )
  lr = logrange(-1   ,-10^-5, 0.1)  assertAlmostEquals( lr:get(5) - lr.stop, 0, eps )
  lr = logrange( 1   , 10^-5, 0.1)  assertAlmostEquals( lr:get(5) - lr.stop, 0, eps )

--print("\n cross sign")
--  lr = logrange( 1   ,-10^5 , 0.1)  print( #lr, lr:get(24), lr.stop )
--  lr = logrange( 10^5,-1    , 0.1)  print( #lr, lr:get(24), lr.stop )
--  lr = logrange(-10^5, 1    , 0.1)  print( #lr, lr:get(24), lr.stop )
--  lr = logrange( 1   ,-10^-5, 0.1)  print( #lr, lr:get(24), lr.stop )
--  lr = logrange(-1   , 10^-5, 0.1)  print( #lr, lr:get(24), lr.stop )
--  lr = logrange(-1   , 10^5 , 0.1)  print( #lr, lr:get(24), lr.stop )

  assertNil( logrange( 10^5, 1    , 10 ):get(0) )
  assertNil( logrange( 10^5,-1    , 10 ):get(0) )
  assertNil( logrange(-10^5, 1    , 10 ):get(0) )
  assertNil( logrange(-10^5,-1    , 10 ):get(0) )
  assertNil( logrange(-1   , 10^5 , 10 ):get(0) )
  assertNil( logrange(-1   ,-10^5 , 0.1):get(0) )
  assertNil( logrange( 1   , 10^5 , 0.1):get(0) )
  assertNil( logrange( 1   ,-10^5 , 10 ):get(0) )

--  assertNil( logrange(-1   , 10^-5, 10 ):get(0) )
--  assertNil( logrange( 1   ,-10^-5, 10 ):get(0) )
--  assertNil( logrange( 1   , 10^-5, 10 ):get(0) )
--  assertNil( logrange(-1   ,-10^-5, 10 ):get(0) )
-- lr = logrange( 1   ,-10^-5, 10) print (lr:value(4), lr.stop)
-- lr = logrange( 1   , 10^-5, 10) print (lr:value(4), lr.stop)
-- lr = logrange(-1   ,-10^-5, 10) print (lr:value(4), lr.stop)
-- lr = logrange(-1   , 10^-5, 10) print (lr:value(4), lr.stop)


--[[  --TO DO after deciding what about the size%2
print("\n minus step")
  lr = logrange( 10^5, 1    ,-10 )  print( lr:get(5), lr.stop )
  lr = logrange( 10^5,-1    ,-10 )  print( lr:get(5), lr.stop )
  lr = logrange(-10^5, 1    ,-10 )  print( lr:get(5), lr.stop )
  lr = logrange(-10^5,-1    ,-10 )  print( lr:get(5), lr.stop )
  lr = logrange(-1   , 10^5 ,-10 )  print( lr:get(5), lr.stop )
  lr = logrange(-1   ,-10^5 ,-0.1)  print( lr:get(5), lr.stop )
  lr = logrange( 1   , 10^5 ,-0.1)  print( lr:get(5), lr.stop )
  lr = logrange( 1   ,-10^5 ,-10 )  print( lr:get(5), lr.stop )
  lr = logrange( 1   , 10^-5,-10 )  print( lr:get(5), lr.stop )
  lr = logrange( 10^5, 1    ,-0.1)  print( lr:get(5), lr.stop )
  lr = logrange(-10^5,-1    ,-0.1)  print( lr:get(5), lr.stop )
  lr = logrange( 10^5,-1    ,-0.1)  print( lr:get(5), lr.stop )
  lr = logrange(-10^5, 1    ,-0.1)  print( lr:get(5), lr.stop )
  lr = logrange( 1   , 10^5 ,-10 )  print( lr:get(5), lr.stop )
  lr = logrange(-1   ,-10^5 ,-10 )  print( lr:get(5), lr.stop )
  lr = logrange( 1   ,-10^5 ,-0.1)  print( lr:get(5), lr.stop )
  lr = logrange(-1   , 10^5 ,-0.1)  print( lr:get(5), lr.stop )
  lr = logrange(-1   ,-10^-5,-10 )  print( lr:get(5), lr.stop )
  lr = logrange( 1   ,-10^-5,-0.1)  print( lr:get(5), lr.stop )
  lr = logrange(-1   , 10^-5,-0.1)  print( lr:get(5), lr.stop )
  lr = logrange(-1   , 10^-5,-10 )  print( lr:get(5), lr.stop )
  lr = logrange(-1   ,-10^-5,-0.1)  print( lr:get(5), lr.stop )
  lr = logrange( 1   , 10^-5,-0.1)  print( lr:get(5), lr.stop )
  lr = logrange( 1   ,-10^-5,-10 )  print( lr:get(5), lr.stop )
]]
end

--[[
function TestLogrange:testNCnstrFields()
end
function TestLogrange:testValue()
end
function TestLogrange:testIndex()
end
function TestLogrange:testEqual()
end
function TestLogrange:testReverse()
end
function TestLogrange:testNsteplog()
end
function TestLogrange:testBounds()
end
function TestLogrange:testOverlap()
end
function TestLogrange:testIlogrange()
end

-- performance test suite -----------------------------------------------------o

Test_Logrange = {}
function Test_Logrange:testIrange()
end

-- end ------------------------------------------------------------------------o
]]
