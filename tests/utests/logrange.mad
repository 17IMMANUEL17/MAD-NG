--[=[
 o-----------------------------------------------------------------------------o
 |
 | Range module regression tests - logrange
 |
 | Methodical Accelerator Design - Copyright CERN 2015+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: A.Z. Teska, aleksandra.teska at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide regression test suites for the range module.

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local assertEquals, assertAlmostEquals, assertTrue, assertFalse,
      assertErrorMsgContains, assertNil, assertNaN, assertIsString, assertInf
      in require 'luaunit'

local range   , nrange   , irange   , inrange   , is_range,
      logrange, nlogrange, ilogrange, inlogrange, is_logrange,
      tiny, eps, huge, inf, nan, log,
      is_function in MAD
local exp         in math

-- regression test suite ------------------------------------------------------o

TestLogrange = {}

local values = {
  limit  = { huge, tiny, eps },
  num    = {2^-64, 2^-63, 2^-53, eps, 2^-52, 2*eps, 2^-32, 2^-31, 1e-9,
            0.1-eps, 0.1, 0.1+eps, 0.5, 0.7-eps, 0.7, 0.7+eps, 1-eps, 1, 1+eps,
            1.1, 1.7, 2, 10, 1e2, 1e3, 1e6, 1e9, 2^31, 2^32, 2^52, 2^53,
            2^63, 2^64 },
  lrng =   {
           { 10^5, 1    , 0.1},
           { 1   , 10^5 , 10 },
           { 1   , 10^-5, 0.1},
           },
  lempty = {
           { 10^5, 1    , 10 },
           { 1   , 10^5 , 0.1},
           { 1   , 10^-5, 10 },
           },
  nlrng =  {
           { 10^5, 1    , 100 },
           { 1   , 10^5 , 100 },
           { 1   , 10^-5, 100 },
           },
}

function TestLogrange:testRawCtor()
  assertTrue( is_logrange( log(0..9..0.5)) )

  assertTrue( is_logrange(log(0..9..0.5)     ) )
  assertTrue( is_logrange(log(0..9..0.5)     ) )
  assertTrue( is_logrange(log(0..9.. .5)     ) )
  assertTrue( is_logrange(log(0..0.9..0.5)   ) )
  assertTrue( is_logrange(log(0.. .9.. .5)   ) )
  assertTrue( is_logrange(log(0.1..0.9..0.5) ) )
  assertTrue( is_logrange(log( .1.. .9.. .5) ) )
  assertTrue( is_logrange(log(0..9..-0.5)    ) )
  assertTrue( is_logrange(log(0..9..- .5)    ) )
  assertTrue( is_logrange(log(0..-0.9..0.5)  ) )
  assertTrue( is_logrange(log(0..- .9.. .5)  ) )
  assertTrue( is_logrange(log(-0.1..0.9..0.5)) )
  assertTrue( is_logrange(log(- .1.. .9.. .5)) )
end

function TestLogrange:testFields()
  local lr
  --lr = log( 1..10 )
  --assertEquals( lr.logstart, 0  )
  --assertEquals( lr.logstop , 10 )
  --assertEquals( lr.logstep , 1  )

  lr = { log(1..10):ranges() }
  assertAlmostEquals( lr[1] / 1      - 1, 0,   eps )
  assertAlmostEquals( lr[2] / 10     - 1, 0, 9*eps )
--  assertAlmostEquals( lr[3] / exp(1) - 1, 0,   eps )
  lr = { log(1..10..huge):ranges() }
  assertAlmostEquals( lr[1] / 1  - 1, 0,   eps )
  assertAlmostEquals( lr[2] / 10 - 1, 0, 9*eps )
  --assertAlmostEquals( lr[3] - huge  , 0,   eps )
  lr = { log( 1..10..tiny ):ranges() }
  assertAlmostEquals( lr[1] / 1    - 1, 0,     eps )
  assertAlmostEquals( lr[2] / 10   - 1, 0,   9*eps )
  assertAlmostEquals( lr[3] / tiny - 1, 0, 124*eps )

  for _,v in ipairs(values.lempty) do
    lr = { log(v[1]..v[2]..v[3]):ranges() }
    assertAlmostEquals( lr[1] / v[1] -1, 0, 2*eps )
    assertAlmostEquals( lr[2] / v[2] -1, 0, 2*eps )
    assertAlmostEquals( lr[3] / v[3] -1, 0, 2*eps )
  end
  for _,v in ipairs(values.lrng)do
    lr = { log(v[1]..v[2]..v[3]):ranges() }
    assertAlmostEquals( lr[1] / v[1] -1, 0, 2*eps )
    assertAlmostEquals( lr[2] / v[2] -1, 0, 2*eps )
    assertAlmostEquals( lr[3] / v[3] -1, 0, 2*eps )
  end
end

function TestLogrange:testRanges()
  local r
  r =  log( 1..10..10)
  assertEquals( {r:ranges()}, {exp(r.logstart), exp(r.logstop), exp(r.logstep)} )
  for _,v in ipairs(values.lempty) do
    r = log(v[1]..v[2]..v[3])
    assertEquals( {r:ranges()}, {exp(r.logstart), exp(r.logstop), exp(r.logstep)} )
  end
  for _,v in ipairs(values.lrng) do
    r = log(v[1]..v[2]..v[3])
    assertEquals( {r:ranges()}, {exp(r.logstart), exp(r.logstop), exp(r.logstep)} )
  end
  for _,v in ipairs(values.num) do
    r = log( 1..10..v)
    assertEquals( {r:ranges()}, {exp(r.logstart), exp(r.logstop), exp(r.logstep)} )
  end
end

function TestLogrange:testReadonly()
  local f1, f2, f3
  local msg = {
    "attempt to write to constant location",
  }
  for _,v in ipairs(values.num) do
    f1=\r,v => r.logstart = v end
    assertErrorMsgContains( msg[1], f1,  log( 1..10..0.1), v )
    f2=\r,v => r.logstop  = v end
    assertErrorMsgContains( msg[1], f1,  log( 1..10..0.1), v )
    f3=\r,v => r.logstep  = v end
    assertErrorMsgContains( msg[1], f1,  log( 1..10..0.1), v )
  end
end

function TestLogrange:testNanAndInf() end

function TestLogrange:testIsEmpty()
  assertFalse(  log( 1..10 )      :is_empty() )
  assertTrue (  log( 1..10^5..0.1):is_empty() )
  assertFalse(  log( 1..10  ..1)  :is_empty() )

  for _,v in ipairs(values.lempty) do
    assertTrue ( log(v[1]..v[2]..v[3]):is_empty() )
  end
  for _,v in ipairs(values.lrng) do
    assertFalse( log(v[1]..v[2]..v[3]):is_empty() )
  end
 for _,v in ipairs(values.num) do
    if v > 1 then
      assertFalse( log( 1 ..10..v):is_empty() )
      assertTrue ( log( 10..1 ..v):is_empty() )
    elseif v < 1 then
      assertTrue ( log( 1 ..10..v):is_empty() )
      assertFalse( log( 10..1 ..v):is_empty() )
    else
      assertFalse( log( 10..1 ..v):is_empty() )
      assertFalse( log( 1 ..10..v):is_empty() )
    end
  end
  assertFalse(  log( 1..10..huge ):is_empty() )
  assertTrue (  log( 1..10..tiny ):is_empty() )
end

function TestLogrange:testIsLogrange()
  assertFalse( is_logrange('') )
  assertFalse( is_logrange(2)  )
  assertFalse( is_logrange(range(1)) )
  assertFalse( is_logrange(1..10)    )
  assertFalse( is_logrange(nrange(1,10,1)) )

  assertTrue ( is_logrange( log( 10^5..1    ..0.1)) )
  assertTrue ( is_logrange( log( 1   ..10^5 ..10 )) )
  assertTrue ( is_logrange( log( 1   ..10^-5..0.1)) )
end

function TestLogrange:testValue()
  local lr
  assertNaN   ( log( 10..1 ..1   ):value( inf) )
  assertNaN   ( log( 10..1 ..1   ):value(-inf) )
  assertNaN   ( log( 1 ..10..1   ):value( nan) )
  assertEquals( log( 1 ..10..huge):value(0), 1 )
  assertEquals( log( 1 ..10..tiny):value(0), 1 )
  assertAlmostEquals( log(0..1..0.1):value(eps) / exp(eps), 0, eps )

  for _,v in ipairs(values.lrng) do
    assertAlmostEquals(  log(v[1]..v[2]..v[3]):value(0) / v[1] - 1, 0, eps )
  end
  for _,v in ipairs(values.lempty) do
    assertAlmostEquals(  log(v[1]..v[2]..v[3]):value(0) / v[1] -1 , 0, eps )
  end

  lr = log( 1 ..10^5.. 10) assertAlmostEquals( lr:value(#lr) / 10^6 -1, 0, 6*eps )
  lr = log( 10..10^5.. 10) assertAlmostEquals( lr:value(-1)  / 1 -1   , 0, 2*eps )
end

function TestLogrange:testGet()
  local lr
  assertEquals( log( 1..10   ..huge):get( 0), 1 )
  assertNil   ( log( 1..10   ..tiny):get( 0) )
  assertNil   ( log( 1..10^-5..0.1 ):get(-1) )
  assertNil   ( log( 1..10^-5..0.1 ):get( 6) )

  for _,v in ipairs(values.lempty) do
    lr = log(v[1]..v[2]..v[3])
    assertNil( lr:get(0)     )
    assertNil( lr:get(#lr-1) )
  end
  for _,v in ipairs(values.lrng) do
    lr = log(v[1]..v[2]..v[3])
    assertAlmostEquals( lr:get(0)     / v[1] - 1, 0,   eps )
    --assertAlmostEquals( lr:get(#lr-1) / v[2] - 1, 0, 8*eps )
  end

  assertAlmostEquals( log(10^5..1..0.1):get(0) / 10^5 - 1, 0, eps )
  lr =  log( 1..10^-5..0.1)
  assertAlmostEquals( lr:get(0)     / 1 - 1    , 0,   eps )
  assertAlmostEquals( lr:get(#lr-1) / 10^-5 - 1, 0, 7*eps )
  lr =  log( 1..10^5 ..10 )
  assertAlmostEquals( lr:get(0)     / 1 - 1    , 0,   eps )
  --assertAlmostEquals( lr:get(#lr-1) / 10^5 - 1 , 0, 7*eps )
end

function TestLogrange:testIndex()
  local lr
  assertEquals( log( 1..10   ..huge)[ 1], 1 )
  assertNil   ( log( 1..10   ..tiny)[ 1] )
  assertNil   ( log( 1..10^-5..0.1 )[-1] )
  assertNil   ( log( 1..10^-5..0.1 )[ 7] )

  for _,v in ipairs(values.lempty) do
    lr = log(v[1]..v[2]..v[3])
    assertNil( lr[1]     )
    assertNil( lr[#lr] )
  end
  for _,v in ipairs(values.lrng) do
    lr = log(v[1]..v[2]..v[3])
    assertAlmostEquals( lr[1]   / v[1] - 1, 0,   eps )
    --assertAlmostEquals( lr[#lr] / v[2] - 1, 0, 8*eps )
  end

  assertAlmostEquals( log(10^5..1..0.1):get(0) / 10^5 - 1, 0, eps )
  lr =  log( 1..10^-5..0.1)
  assertAlmostEquals( lr[1]   / 1 - 1    , 0,   eps )
  assertAlmostEquals( lr[#lr] / 10^-5 - 1, 0, 7*eps )
  lr =  log( 1..10^5 ..10 )
  assertAlmostEquals( lr[1]   / 1 - 1    , 0,   eps )
  --assertAlmostEquals( lr[#lr] / 10^5  - 1, 0, 7*eps )
end

function TestLogrange:testReverse()
  local lr1, lr2
  lr1 = { log( 10^5..1   ..10 ):reverse():ranges() }
  lr2 = { log( 1   ..10^5..0.1):ranges() }
  assertAlmostEquals( lr1[1]/lr2[1] - 1, 0,   eps )
  assertAlmostEquals( lr1[2]/lr2[2] - 1, 0,   eps )
  assertAlmostEquals( lr1[3]/lr2[3] - 1, 0, 2*eps )
  lr1 = { log( 10^5..1   ..10 ):ranges() }
  lr2 = { log( 1   ..10^5..0.1):reverse():ranges() }
  assertAlmostEquals( lr2[1]/lr1[1] - 1, 0,   eps )
  assertAlmostEquals( lr2[2]/lr1[2] - 1, 0,   eps )
  assertAlmostEquals( lr2[3]/lr1[3] - 1, 0, 4*eps )

end

function TestLogrange:testEqual()
  local r, rs
  for _,v in ipairs(values.lempty) do
    r = log(v[1]..v[2]..v[3])
    rs = {r:ranges()} assertTrue( log(rs[1]..rs[2]..rs[3]) == r )
  end
  for _,v in ipairs(values.lrng) do
    r = log(v[1]..v[2]..v[3])
    rs = {r:ranges()} assertTrue( log(rs[1]..rs[2]..rs[3]) == r )
  end
end

function TestLogrange:testSize()
  assertEquals( log( 2   ..10..huge):size(), 1 )
  assertEquals( log( 10^5..1  )     :size(), -huge )

  for _,v in ipairs(values.lempty) do
    assertEquals(  log(v[1]..v[2]..v[3]):size(), 0 )
  end
  for _,v in ipairs(values.lrng) do
    assertEquals(  log(v[1]..v[2]..v[3]):size(), 6 )
  end
end

function TestLogrange:testIlogrange()
  local s, r, ir
  ir = { ilogrange( 1, 10^5, 10) }
  assertTrue( is_function(ir[1]) )
  assertTrue( is_logrange(ir[2]) )
  assertTrue( ir[3] == 0         )

  for _,v in ipairs(values.lrng) do
  --  r =  log(v[1]..v[2]..v[3]) for i,v in  ilogrange(v[1],v[2],v[3]) do assertAlmostEquals(r[i]/v-1, 0, 8*eps) end
  end
  for _,v in ipairs(values.lempty) do
    r,s = log(v[1]..v[2]..v[3]),0 for i,v in ilogrange(v[1],v[2],v[3]) do s=s+1; assertEquals(s, 0) end
  end
end

function TestLogrange:testConstructor()
  local r
  local msg = {
    "invalid argument #1 (positive finite number expected)",
    "invalid argument #2 (positive finite number expected)",
    "invalid argument #3 (positive finite number expected)",
  }
  assertErrorMsgContains( msg[1],  logrange            )
  assertErrorMsgContains( msg[1],  logrange,-1         )
  assertErrorMsgContains( msg[1],  logrange, nil, 1    )
  assertErrorMsgContains( msg[1],  logrange, 1..10..2  )
  assertErrorMsgContains( msg[1],  logrange, ''        )
  assertErrorMsgContains( msg[2],  logrange, 1  , ''   )
  assertErrorMsgContains( msg[3],  logrange, 1  , 10    , ''  )
  assertErrorMsgContains( msg[3],  logrange, 1  , 10    , nan )
  assertErrorMsgContains( msg[2],  logrange, 1  , nan   , nan )
  assertErrorMsgContains( msg[1],  logrange, nan, nan   , nan )
  assertErrorMsgContains( msg[3],  logrange, 1  , 10    ,-nan )
  assertErrorMsgContains( msg[2],  logrange, 1  , nan   ,-nan )
  assertErrorMsgContains( msg[1],  logrange,-nan,-nan   ,-nan )
  assertErrorMsgContains( msg[3],  logrange, 1  , 10^5  ,-10  )
  assertErrorMsgContains( msg[2],  logrange, 1  ,-10^5  , 10  )
  assertErrorMsgContains( msg[1],  logrange,-1  , 10^5  , 10  )
  assertErrorMsgContains( msg[3],  logrange, 1  , 10^5  , 0   )
  assertErrorMsgContains( msg[3],  logrange, 1  , 10    , inf )
  assertErrorMsgContains( msg[2],  logrange, 1  , inf   , inf )
  assertErrorMsgContains( msg[1],  logrange, inf, inf   , inf )
  assertErrorMsgContains( msg[3],  logrange, 1  , 10    ,-inf )
  assertErrorMsgContains( msg[2],  logrange, 1  , inf   ,-inf )
  assertErrorMsgContains( msg[1],  logrange,-inf,-inf   ,-inf )
  assertErrorMsgContains( msg[2],  logrange, 2 ,  2^1024, 2   )

  assertTrue( is_logrange( logrange( 1)     ) )
  assertTrue( is_logrange( logrange( 1, 10) ) )

  for _,v in ipairs(values.lrng) do
    assertTrue( is_logrange( logrange(v[1],v[2],v[3]) ) )
  end
  for _,v in ipairs(values.lempty) do
    assertTrue( is_logrange( logrange(v[1],v[2],v[3]) ) )
  end
  for _,v in ipairs(values.limit) do
    assertTrue( is_logrange(logrange( 1, 10, v)) )
    assertTrue( is_logrange(logrange( 1, v , v)) )
    assertTrue( is_logrange(logrange( v, v , v)) )
  end
  assertFalse(  logrange( 1)           :is_empty() )

  --assertEquals( logrange( 1 ).logstart, log(1)  )
  --assertEquals( logrange( 1 ).logstop , log(1)  )
  --assertEquals( logrange( 1 ).logstep , 1       )
  r =  logrange( 1 )
  assertEquals( {r:ranges()}, {exp(r.logstart), exp(r.logstop), exp(r.logstep)} )
  assertEquals( {logrange( 1 ):ranges()}, { 1, 1, exp(1)} )
  assertEquals(  logrange( 1 ):value(0) , 1 )
  assertEquals(  logrange( 1 ):size()   , 1 )
end

function TestLogrange:testNConstructor()
  local lr, lr1
  local msg = {
    "invalid argument #3 (positive number expected)",
  }
  assertErrorMsgContains( msg[1], nlogrange, 1  , 10 ,-1   )
  assertErrorMsgContains( msg[1], nlogrange, 1  , 10 , nan )
  assertErrorMsgContains( msg[1], nlogrange, 1  , nan, nan )
  assertErrorMsgContains( msg[1], nlogrange, nan, nan, nan )
  assertErrorMsgContains( msg[1], nlogrange, 1  , 10 , ''  )
  assertErrorMsgContains( msg[1], nlogrange, 1  , 10^5,-1  )

  assertTrue( is_logrange(nlogrange( 1 ))       )
  assertTrue( is_logrange(nlogrange( 1, 10  ))  )
  assertTrue( is_logrange(nlogrange( 1, 10, 0)) )
  assertTrue( is_logrange(nlogrange( 1, 10, 1)) )

  for _,v in ipairs(values.num) do
    assertTrue( is_logrange( nlogrange( 1, 10, v)) )
  end
  for _,v in ipairs(values.limit) do
    assertTrue( is_logrange( nlogrange( 1, 10, v)) )
  end
  for _,v in ipairs(values.nlrng) do
    assertTrue( is_logrange( nlogrange(v[1],v[2],v[3]) ) )
  end
  assertEquals( nlogrange( 1 , 1 , 1    ).logstep, huge )
  assertEquals( nlogrange( 1 , 10, 0    ).logstep,-huge )
  assertEquals( nlogrange( 1 , 10, 0.1  ).logstep, huge )
  assertEquals( nlogrange( 1 , 10, 1    ).logstep, huge )
  assertEquals( nlogrange( 1 , 10, tiny ).logstep, huge )
  assertEquals( nlogrange( 1 , 10, eps  ).logstep, huge )
  assertEquals( nlogrange( 1 , 10, inf  ).logstep, 0    )
  assertEquals( nlogrange( 10, 10, 2    ).logstep, 0    )

  local lr1, lr
  lr  = logrange( 1, 1e3, 10 )
  lr1 = logrange( 1, 1e3, 10, 4 )
  assertTrue( lr == lr1 )
  assertTrue( lr.logstep / lr1.logstep - 1 < 2*eps)

  lr  = logrange( 1, 1e6, 100 )
  lr1 = logrange( 1, 1e6, 100, 4 )
  assertTrue( lr == lr1 )
  assertTrue( lr.logstep / lr1.logstep - 1 < 2*eps)
  assertNaN   ( nlogrange( 1, 10, 1)    :value( nan) )

  for _,v in ipairs(values.nlrng) do
    lr = nlogrange(v[1],v[2],v[3])
    assertAlmostEquals( lr:value(0)   / v[1] - 1, 0,   eps )
    assertAlmostEquals( lr:value(0)   / v[1] - 1, 0,   eps )
    assertAlmostEquals( lr:get(0)     / v[1] - 1, 0,   eps )
    assertAlmostEquals( lr:get(#lr-1) / v[2] - 1, 0, 8*eps )
    assertAlmostEquals( lr[1]         / v[1] - 1, 0,   eps )
    assertAlmostEquals( lr[#lr]       / v[2] - 1, 0, 8*eps )
  end
  lr = nlogrange( 1, 10^5 , 6  )
  assertAlmostEquals( lr[1]   / 1 - 1    , 0,   eps )
  assertAlmostEquals( lr[#lr] / 10^5 - 1 , 0, 7*eps )
  assertAlmostEquals( lr:get(0)     / 1 - 1    , 0,   eps )
  assertAlmostEquals( lr:get(#lr-1) / 10^5 - 1 , 0, 7*eps )

  assertEquals( nlogrange( 1   , 10, 0.1 ):size(), 1   )
  assertEquals( nlogrange( 10^5, 1 , 1   ):size(), 1   )
  assertEquals( nlogrange( 10^5, 1  )     :size(), 100 )
  for _,v in ipairs(values.nlrng) do
    assertEquals( nlogrange(v[1],v[2],v[3]):size(), 100 )
  end
  for _,v in ipairs(values.nlrng) do
    r = nlogrange(v[1],v[2],v[3]) for i,v in inlogrange(v[1],v[2],v[3]) do assertEquals(r[i], v) end
  end
  r = nlogrange( 1, 10, 10)
  assertEquals( {r:ranges()}, {exp(r.logstart), exp(r.logstop), exp(r.logstep)} )

  assertFalse( nlogrange( 2, 10, 0.1)  :is_empty() )
  for _,v in ipairs(values.num) do
    assertFalse( nlogrange( 1 , 10, v):is_empty() )
    assertFalse( nlogrange( 10, 1 , v):is_empty() )
  end
  assertFalse( nlogrange( 1, 10, huge ):is_empty() )
  assertFalse( nlogrange( 1, 10, tiny ):is_empty() )
  assertTrue ( is_logrange(nlogrange( 1   , 10   ,10  )) )

  lr1 = {nlogrange( 10^5, 1   , 1000):reverse():ranges()}
  lr2 = {nlogrange( 1   , 10^5, 1000):ranges()}
  assertAlmostEquals( lr2[1]/lr1[1] - 1, 0,   eps )
  assertAlmostEquals( lr2[2]/lr1[2] - 1, 0,   eps )
  assertAlmostEquals( lr2[3]/lr1[3] - 1, 0, 2*eps )

  lr1 = { nlogrange(10^5, 1   , 1000):ranges() }
  lr2 = { nlogrange(1   , 10^5, 1000):reverse():ranges() }
  assertAlmostEquals( lr2[1]/lr1[1] - 1, 0,   eps )
  assertAlmostEquals( lr2[2]/lr1[2] - 1, 0,   eps )
  assertAlmostEquals( lr2[3]/lr1[3] - 1, 0, 2*eps )

  for _,v in ipairs(values.nlrng) do
    r = nlogrange(v[1],v[2],v[3]) assertTrue( logrange(r:ranges()) == r )
  end
end

function TestLogrange:testNCnstrFields()
  assertTrue( is_logrange(nlogrange( 1, 10 ))   )
  assertTrue( is_logrange(nlogrange( 1, 10, 1)) )

  for _,v in ipairs(values.nlrng)do
    lr = { nlogrange(v[1],v[2],v[3]):ranges() }
    assertAlmostEquals( lr[1] / v[1] - 1, 0,   eps )
    assertAlmostEquals( lr[2] / v[2] - 1, 0, 2*eps )
   end
end

function TestLogrange:testAdjust() end

function TestLogrange:testBounds()
local lr
  assertEquals( { logrange( 10^5, 1    , 10  ):bounds()}, { nil, nil, nil} )
  assertEquals( { logrange( 1   , 10^5 , 0.1 ):bounds()}, { nil, nil, nil} )
  assertEquals( { logrange( 1   , 10^-5, 10  ):bounds()}, { nil, nil, nil} )

  lr = { logrange( 1   , 10^-5, 0.2 ):bounds()}
  assertAlmostEquals( lr[1] / 1.28e-05 - 1, 0, eps )
  assertAlmostEquals( lr[2] / 1 - 1       , 0, eps )
  assertAlmostEquals( lr[3] / 5 - 1       , 0, eps )
  lr = { logrange( 10^5, 1, 0.1 ):bounds()}
  assertAlmostEquals( lr[1] / 1    - 1 , 0, 8*eps )
  assertAlmostEquals( lr[2] / 10^5 - 1 , 0,   eps )
  --assertAlmostEquals( lr[3] / 0.1  - 1 , 0,   eps )
  lr = { logrange( 1   , 10^5 , 10  ):bounds()}
  assertAlmostEquals( lr[1] / 1    - 1 , 0,   eps )
  assertAlmostEquals( lr[2] / 10^5 - 1 , 0, 7*eps )
  assertAlmostEquals( lr[3] / 10   - 1 , 0,   eps )
  lr = { logrange( 1   , 10^-5, 0.1 ):bounds()}
  assertAlmostEquals( lr[1] / 10^-5 - 1, 0, 7*eps )
  assertAlmostEquals( lr[2] / 1     - 1, 0,   eps )
  --assertAlmostEquals( lr[3] / 0.1   - 1, 0,   eps )

  lr = {nlogrange( 10^5, 1    , 100 ):bounds()}
  assertAlmostEquals( lr[1] / 1    - 1 , 0,   eps )
  assertAlmostEquals( lr[2] / 10^5 - 1 , 0,   eps )
  lr = {nlogrange( 1   , 10^-5, 100 ):bounds()}
  assertAlmostEquals( lr[1] / 10^-5 - 1, 0, 2*eps )
  assertAlmostEquals( lr[2] / 1     - 1, 0,   eps )

  lr = { logrange( 1   , 10^-5, 1 ):bounds()}
  assertAlmostEquals( lr[1] / 1 - 1    , 0, 2*eps )
  assertAlmostEquals( lr[2] / 1 - 1    , 0,   eps )
  lr = {nlogrange( 1   , 10^-5, 1 ):bounds()}
  assertAlmostEquals( lr[1] / 1 - 1    , 0, 2*eps )
  assertAlmostEquals( lr[2] / 1 - 1    , 0,   eps )
  lr = {nlogrange( 1   , 10^5 , 100 ):bounds()}
  assertAlmostEquals( lr[1] / 1    - 1 , 0,   eps )
  assertAlmostEquals( lr[2] / 10^5 - 1 , 0,   eps )
end

function TestLogrange:testOverlap()
  local lr, nr
  assertFalse(  logrange( 10^5, 1    , 10 ):overlap(logrange( 1, 10^5 , 10 )) )
  assertFalse(  logrange( 1   , 10^5 , 0.1):overlap(logrange( 1, 10^5 , 10 )) )
  assertFalse(  logrange( 1   , 10^-5, 10 ):overlap(logrange( 1, 10^5 , 10 )) )
  assertFalse( nlogrange( 10^5, 1    , 1  ):overlap(logrange( 1, 10^5 , 10 )) )
  assertFalse( nlogrange( 10^5, 1    , 1  ):overlap(logrange( 1, 10^-5, 0.1)) )

  lr = logrange( 10^5, 1, 0.1 )
  assertTrue ( lr:overlap( logrange(    1, 10^5 , 10  )) )
  assertFalse( lr:overlap( logrange(    1, 10^-5, 0.1 )) )
  lr = logrange( 1, 10^5 , 10)
  assertTrue ( lr:overlap( logrange( 10^5, 1    , 0.1 )) )
  assertTrue ( lr:overlap( logrange( 1   , 10^-5, 0.1 )) )
  lr = logrange( 1, 10^-5, 0.1)
  assertTrue ( lr:overlap( logrange( 1   , 10^-5, 0.1 )) )
  assertFalse( lr:overlap( logrange( 10^5, 1    , 0.1 )) )

  nr = nlogrange(10^5, 1 , 6)
  assertTrue ( nr:overlap( logrange( 1   , 10^5 , 10  )) )
  assertTrue ( nr:overlap( logrange( 10^5, 1    , 0.1 )) )
  assertTrue ( nr:overlap(nlogrange( 1   , 10^5 , 6   )) )
  assertFalse( nr:overlap( logrange( 1   , 10^-5, 0.1 )) )
  assertFalse( nr:overlap(nlogrange( 1   , 10^-5, 6   )) )

  nr = nlogrange(1   , 10^5 , 6)
  assertTrue ( nr:overlap( logrange( 1   , 10^5 , 10  )) )
  assertTrue ( nr:overlap( logrange( 1   , 10^-5, 0.1 )) )
  assertTrue ( nr:overlap( logrange( 10^5, 1    , 0.1 )) )
  assertTrue ( nr:overlap(nlogrange( 10^5, 1    , 6   )) )
  assertTrue ( nr:overlap(nlogrange( 1   , 10^-5, 6   )) )

  nr = nlogrange(1   , 10^-5, 6)
  assertTrue ( nr:overlap( logrange( 1   , 10^5 , 10  )) )
  assertTrue ( nr:overlap( logrange( 1   , 10^-5, 0.1 )) )
  assertTrue ( nr:overlap(nlogrange( 1   , 10^5 , 6   )) )
  assertFalse( nr:overlap( logrange( 10^5, 1    , 0.1 )) )
  assertFalse( nr:overlap(nlogrange( 10^5, 1    , 6   )) )
end

-- performance test suite -----------------------------------------------------o

Test_Logrange = {}

function Test_Logrange:testIrange()
  local s = 4^8
  s = 1023
  local lr = logrange(2, 2^s, 2)
  local t0 = os.clock()
  for j = 1,15e3 do
    for i,v in ilogrange(2, 2^s, 2) do assert(lr[i], v) end
  end
  local dt = os.clock() - t0
  assertAlmostEquals( dt, 0.5, 1 )
end

-- end ------------------------------------------------------------------------o