--[=[
 o-----------------------------------------------------------------------------o
 |
 | Range module regression tests - logrange
 |
 | Methodical Accelerator Design - Copyright CERN 2015+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: A.Z. Teska, aleksandra.teska at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide regression test suites for the range module.

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local assertEquals, assertAlmostEquals, assertTrue, assertFalse,
      assertErrorMsgContains, assertNil, assertNaN, assertIsString
      in require 'luaunit'

local range   , nrange   , irange   , is_range,
      logrange, nlogrange, ilogrange, is_logrange, log,
      tiny, eps, huge, inf, nan in MAD
local is_function in MAD

-- regression test suite ------------------------------------------------------o

TestLogrange = {}

local values = {
  special = { huge, tiny, inf },
  num   = {0, 2^-64, 2^-63, 2^-53, eps, 2^-52, 2*eps, 2^-32, 2^-31, 1e-9,
          0.1-eps, 0.1, 0.1+eps, 0.5, 0.7-eps, 0.7, 0.7+eps, 1-eps, 1, 1+eps,
          1.1, 1.7, 2, 10, 1e2, 1e3, 1e6, 1e9, 2^31, 2^32, 2^52, 2^53,
          2^63, 2^64 },

  lempty = {
           { 10^5, 1   , 10 },
           { 10^5,-1   , 10 },
           { 10^5, 1   ,-10 },
           { 10^5,-1   ,-10 },
           {-10^5, 1   , 10 },
           {-10^5,-1   , 10 },
           {-10^5, 1   ,-10 },
           {-10^5,-1   ,-10 },
           {-1   , 10^5, 10 },
           {-1   , 10^5,-10 },
           {-1   ,-10^5, 0.1},
           {-1   ,-10^5,-0.1},
           { 1   , 10^5, 0.1},
           { 1   , 10^5,-0.1},
           { 1   ,-10^5, 10 },
           { 1   ,-10^5,-10 },
           },
  lrng  =  {
           { 10^5, 1   , 0.1},
           {-10^5,-1   , 0.1},
           { 10^5,-1   , 0.1},
           {-10^5, 1   , 0.1},
           { 10^5, 1   ,-0.1},
           {-10^5,-1   ,-0.1},
           { 10^5,-1   ,-0.1},
           {-10^5, 1   ,-0.1},
           { 1   , 10^5, 10 },
           {-1   ,-10^5, 10 },
           { 1   ,-10^5, 0.1},
           {-1   , 10^5, 0.1},
           { 1   , 10^5,-10 },
           {-1   ,-10^5,-10 },
           { 1   ,-10^5,-0.1},
           {-1   , 10^5,-0.1},
           },
           --{ 0   , 0   , 0  }, -- to be decided if empty, rather y
           --{ 0   , 0   ,-0  },
}

--special values:
  --log(1..10.. 1)
  --log(1..10..-1)
--function TestLogrange:testGrpBld()
---local lr
--  print("non-empty")
--  for _,v in ipairs(values.lrng) do
--    lr = logrange(v[1],v[2],v[3])
--    print( lr:is_empty(), lr:value(0), lr:get(0), lr:range() )
--  end
--  print("\n","empty")
--  for _,v in ipairs(values.lempty) do
--    lr = logrange(v[1],v[2],v[3])
--    print( lr:is_empty(), lr:value(0), lr:get(0), lr:range() )
--  end
--end

function TestLogrange:testConstructor()
    local a = 2
  local msg = {
    "invalid argument #1 (number expected)",
    "cannot convert 'string' to 'const double'",
  }
  assertErrorMsgContains( msg[1], logrange            )
  assertErrorMsgContains( msg[1], logrange, nil, 1    )
  assertErrorMsgContains( msg[1], logrange, 1..10..2  )
  assertErrorMsgContains( msg[1], logrange, ''        )
  assertErrorMsgContains( msg[2], logrange, 1, ''     )
  assertErrorMsgContains( msg[2], logrange, 1, 10, '' )

  assertTrue( is_logrange(logrange(1))           )
  assertTrue( is_logrange(logrange(1,10))        )

  assertTrue( is_logrange( logrange( a, a)   ) )
  assertTrue( is_logrange( logrange(-a,-a)   ) )
  assertTrue( is_logrange( logrange( a, a, a)) )
  assertTrue( is_logrange( logrange(-a,-a,-a)) )

  for _,v in ipairs(values.lrng) do
    assertTrue( is_logrange( logrange(v[1],v[2],v[3]) ) )
  end
  for _,v in ipairs(values.lempty) do
    assertTrue( is_logrange( logrange(v[1],v[2],v[3]) ) )
  end
  --for _,v in ipairs(values.num) do
  --  assertTrue( is_logrange(logrange( 1, 10, v)) )
  --  assertTrue( is_logrange(logrange( 1, 10,-v)) )
  --end
  for _,v in ipairs(values.special) do
    assertTrue( is_logrange(logrange( 1,  10, v)) )
    assertTrue( is_logrange(logrange( 10, 1 ,-v)) )
    assertTrue( is_logrange(logrange( 1 , v , v)) )
    assertTrue( is_logrange(logrange( 1 ,-v ,-v)) )
    assertTrue( is_logrange(logrange( v , v , v)) )
    assertTrue( is_logrange(logrange(-v ,-v ,-v)) )
  end

  assertTrue( is_logrange(logrange( 1  , 10 , nan)) )
  assertTrue( is_logrange(logrange( 10 , 1  ,-nan)) )
  assertTrue( is_logrange(logrange( 1  , nan, nan)) )
  assertTrue( is_logrange(logrange( 1  ,-nan,-nan)) )
  assertTrue( is_logrange(logrange( nan, nan, nan)) )
  assertTrue( is_logrange(logrange(-nan,-nan,-nan)) )
end


function TestLogrange:testConcatCtor()
  local a = 2
  assertTrue( is_logrange( log(10..1..0.1)      ) )
  assertTrue( is_logrange( log(10..1.. .1)      ) )
  assertTrue( is_logrange( log(10..0.1..0.1)    ) )
  assertTrue( is_logrange( log(10.. .1.. .1)    ) )
  assertTrue( is_logrange( log(0.1..0.001..0.1) ) )
  assertTrue( is_logrange( log( .1.. .001.. .1) ) )
  assertTrue( is_logrange( log(0.1..0.001..-0.1)) )
  assertTrue( is_logrange( log(0.1..0.001..- .1)) )
  assertTrue( is_logrange( log(0..-0.001..0.1)  ) )
  assertTrue( is_logrange( log(0..- .001.. .1)  ) )
  assertTrue( is_logrange( log(-0.1..0.001..0.1)) )
  assertTrue( is_logrange( log(- .1.. .001.. .1)) )

  --assertEquals( log( 1..10    ), logrange(1,10)     ) --diff cdata
  --assertEquals( log( a..a     ), logrange( a, a)    ) --diff cdata
  --assertEquals( log(-a..-a    ), logrange(-a,-a)    ) --diff cdata
  assertEquals( log( a..a..a  ), logrange( a, a, a) )
  assertEquals( log(-a..-a..-a), logrange(-a,-a,-a) )

  --  print(v[1],v[2],v[3])
  for _,v in ipairs(values.lempty) do
    assertEquals( logrange(v[1],v[2],v[3]), log(v[1]..v[2]..v[3])  )
  end
  for _,v in ipairs(values.lrng)do
    assertEquals( logrange(v[1],v[2],v[3]), log(v[1]..v[2]..v[3])  )
  end

  --for _,v in ipairs(values.num) do
  --  assertEquals( range( 1, 10, v),  1..10.. v )
  --  assertEquals( range( 1, 10,-v),  1..10..-v )
  --end
  for _,v in ipairs(values.special) do
    assertEquals( logrange( 1 , 10, v ), log( 1.. 10.. v) )
    assertEquals( logrange( 10, 1 ,-v ), log( 10..1 ..-v) )
    assertEquals( logrange( 1 , v , v ), log( 1.. v .. v) )
    assertEquals( logrange( 1 ,-v ,-v ), log( 1..-v ..-v) )
    assertEquals( logrange( v , v , v ), log( v.. v .. v) )
    assertEquals( logrange(-v ,-v ,-v ), log(-v..-v ..-v) )
  end
end

function TestLogrange:testFields()
  assertEquals( {logrange( 1 )    :range()}, {1 ,1 ,2} )
  assertEquals( {logrange( 1 ,10) :range()}, {1 ,10,2} )
  assertEquals( {logrange( 10,1 ) :range()}, {10,1 ,2} )

  for _,v in ipairs(values.lempty) do
    assertEquals( {range(v[1],v[2],v[3]):range()}, {v[1],v[2],v[3]} )
  end
  for _,v in ipairs(values.lrng)do
    assertEquals( {range(v[1],v[2],v[3]):range()}, {v[1],v[2],v[3]} )
  end
  for _,v in ipairs(values.special) do
    assertEquals( {logrange( 1 ,10, v):range()}, { 1,10, v} )
    assertEquals( {logrange( 10, 1,-v):range()}, {10, 1,-v} )
    assertEquals( {logrange( 1, v , v):range()}, { 1, v, v} )
    assertEquals( {logrange( 1,-v ,-v):range()}, { 1,-v,-v} )
    assertEquals( {logrange( v, v , v):range()}, { v, v, v} )
    assertEquals( {logrange(-v,-v ,-v):range()}, {-v,-v,-v} )
  end
  assertNaN( logrange( nan, nan, nan).start )
  assertNaN( logrange( nan, nan, nan).stop  )
  assertNaN( logrange( nan, nan, nan).step  )
  assertNaN( logrange(-nan,-nan,-nan).start )
  assertNaN( logrange(-nan,-nan,-nan).stop  )
  assertNaN( logrange(-nan,-nan,-nan).step  )

  assertEquals(  range( 1, nan, nan).start, 1  )
  assertNaN   (  range( 1, nan, nan).stop      )
  assertNaN   (  range( 1, nan, nan).step      )
  assertEquals(  range( 1, 10 , nan).start, 1  )
  assertEquals(  range( 1, 10 , nan).stop , 10 )
  assertNaN   (  range( 1, 10 , nan).step      )
  assertEquals(  range( 1, 10 ,-nan).start, 1  )
  assertEquals(  range( 1, 10 ,-nan).stop , 10 )
  assertNaN   (  range( 1, 10 ,-nan).step      )
  assertEquals(  range( 1, nan, 10 ).start, 1  )
  assertNaN   (  range( 1, nan, 10 ).stop      )
  assertEquals(  range( 1, nan, 10 ).step ,10  )
  assertEquals(  range( 1,-nan, 10 ).start, 1  )
  assertNaN   (  range( 1,-nan, 10 ).stop      )
  assertEquals(  range( 1,-nan, 10 ).step ,10  )
end

function TestLogrange:testReadonly()
    local f1, f2, f3
  local msg = {
    "attempt to write to constant location",
  }
  for _,v in ipairs(values.num) do
    f1=\r,v => r.start = v end
    assertErrorMsgContains( msg[1], f1, log(1..10..0.1)   , v )
    assertErrorMsgContains( msg[1], f1, logrange(1,10,0.1), v )
    assertErrorMsgContains( msg[1], f1, nlogrange(1,10,10), v )
    f2=\r,v => r.stop  = v end
    assertErrorMsgContains( msg[1], f2, log(1..10..0.1)   , v )
    assertErrorMsgContains( msg[1], f2, logrange(1,10,0.1), v )
    assertErrorMsgContains( msg[1], f2, nlogrange(1,10,10), v )
    f3=\r,v => r.step  = v end
    assertErrorMsgContains( msg[1], f3, log(1..10..0.1)   , v )
    assertErrorMsgContains( msg[1], f3, logrange(1,10,0.1), v )
    assertErrorMsgContains( msg[1], f3, nlogrange(1,10,10), v )
  end
end

-- function TestLogrange:testIsLogrange()
-- end
function TestLogrange:testRange()
  local r
  r =  logrange(1)       assertEquals( { r:range() }, {r.start, r.stop, r.step} )
  r =  logrange(1,10,10) assertEquals( { r:range() }, {r.start, r.stop, r.step} )
  r = nlogrange(1,10,10) assertEquals( { r:range() }, {r.start, r.stop, r.step} )

  for _,v in ipairs(values.lempty) do
    r = logrange(v[1],v[2],v[3]) assertEquals( { r:range() }, {r.start, r.stop, r.step} )
  end
  for _,v in ipairs(values.lrng) do
    r = logrange(v[1],v[2],v[3]) assertEquals( { r:range() }, {r.start, r.stop, r.step} )
  end
  for _,v in ipairs(values.num) do
    r = logrange( 1 ,10, v)  assertEquals( { r:range() }, {r.start, r.stop, r.step} )
    r = logrange( 10, 1,-v)  assertEquals( { r:range() }, {r.start, r.stop, r.step} )
  end
  --for _,v in ipairs(values.special) do
  --  r = logrange( 1 ,10, v)  assertEquals( { r:range() }, {r.start, r.stop, r.step} )
  --  r = logrange( 10, 1,-v)  assertEquals( { r:range() }, {r.start, r.stop, r.step} )
  --  r = logrange( 1, v , v)  assertEquals( { r:range() }, {r.start, r.stop, r.step} )
  --  r = logrange( 1,-v ,-v)  assertEquals( { r:range() }, {r.start, r.stop, r.step} )
  --  r = logrange( v, v , v)  assertEquals( { r:range() }, {r.start, r.stop, r.step} )
  --  r = logrange(-v,-v ,-v)  assertEquals( { r:range() }, {r.start, r.stop, r.step} )
  --end
end

function TestLogrange:testIsEmpty() -- to be fixed
  for _,v in ipairs(values.lempty) do
    assertTrue ( logrange(v[1],v[2],v[3]):is_empty() )
  end
  assertTrue ( nlogrange(2,10,-1) :is_empty() )
  assertTrue ( nlogrange(2,10, 0) :is_empty() )

  for _,v in ipairs(values.lrng) do
    assertFalse( logrange(v[1],v[2],v[3]):is_empty() )
  end
  assertFalse( logrange(1)          :is_empty() )
  assertFalse( logrange(1,10)       :is_empty() )
  --assertFalse( log(0.. 1.. eps)     :is_empty() )
  assertFalse( log(0..-1..-eps)     :is_empty() )
  --assertFalse( nlogrange(2, 10, 0.1):is_empty() )
  assertFalse( nlogrange(0, 9 , 10) :is_empty() )
  --assertFalse( nlogrange(2, 10, nan):is_empty() )

  --for _,v in ipairs(values.num) do
  --  if v~=0 then
  --    assertFalse( logrange( 1 , 10, v):is_empty() )
  --    assertFalse( logrange( 10, 1 ,-v):is_empty() )
  --    assertTrue ( logrange( 1 , 10,-v):is_empty() )
  --    assertFalse(nlogrange( 1 , 10, v):is_empty() )
  --  end
  --end
  --for _,v in ipairs(values.special) do
  --  assertFalse(  logrange( 1 , 10, v):is_empty() )
  --  assertFalse(  logrange( 10, 1 ,-v):is_empty() )
  --  assertFalse(  logrange( 1 ,-v ,-v):is_empty() )
  --  assertFalse(  logrange( v , v , v):is_empty() )
  --  assertFalse(  logrange(-v ,-v ,-v):is_empty() )
  --  assertTrue ( nlogrange( 10, 1 ,-v):is_empty() )
  --end
  assertFalse(  logrange( 1, inf , inf ):is_empty() )
  assertFalse(  logrange( 1, huge, huge):is_empty() )
 -- assertTrue (  logrange( 1, tiny, tiny):is_empty() )
  assertTrue ( nlogrange( 2, 10  , inf ):is_empty() )
  --assertFalse( nlogrange( 2, 10  , huge):is_empty() )
 -- assertFalse( nlogrange( 2, 10  , tiny):is_empty() )

  assertTrue ( logrange( 1  , 10 , nan) :is_empty() )
  assertTrue ( logrange( 1  , 10 ,-nan) :is_empty() )
  assertTrue ( logrange( 1  , nan, nan) :is_empty() )
  assertTrue ( logrange( 1  ,-nan,-nan) :is_empty() )
  assertTrue ( logrange( nan, nan, nan) :is_empty() )
  assertTrue ( logrange(-nan,-nan,-nan) :is_empty() )
end

function TestLogrange:testIsEmpty2() -- fix fun
--what about step == 1
-- maybe smth with not abs step

  local lr
  lr = logrange(1,10,1)
  print( lr:is_empty(), lr:value(0), lr:range() )

end

--[[




function TestLogrange:testNConstructor()
end

function TestLogrange:testNCnstrFields()
end

function TestLogrange:testValue()
  end

function TestLogrange:testGet()
end

function TestLogrange:testIndex()
end

function TestLogrange:testSize()
end

function TestLogrange:testEqual()
end

function TestLogrange:testReverse()
end

function TestLogrange:testNsteplog()
end

function TestLogrange:testBounds()
end

function TestLogrange:testOverlap()
end

function TestLogrange:testIlogrange()
end

-- performance test suite -----------------------------------------------------o

Test_Logrange = {}
function Test_Logrange:testIrange()
end
-- end ------------------------------------------------------------------------o
]]
