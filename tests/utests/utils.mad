--[=[
 o-----------------------------------------------------------------------------o
 |
 | Utils regression tests
 |
 | Methodical Accelerator Design - Copyright CERN 2015+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide regression test suites for the utils module.

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local assertNil, assertNotNil, assertTrue, assertFalse in require 'luaunit'

local is_nil, is_boolean, is_number, is_string, is_function, is_table,
      is_cdata, is_xrange, is_complex, is_integer, is_scalar, is_rawtable,
      is_iterable, is_indexable, is_callable, is_comparable, is_ordered,
      identity, compose, compose_bottom, getmetatable in MAD

local sm, gm = setmetatable, getmetatable

-- regression test suite ------------------------------------------------------o

TestUtils = {}

local types = {
['nil']      = { nil, __, ___ },
  boolean    = { false, true, 1==1, 0<1, 1<0 },
  number     = { 0.1, 0.01, -0.1, -0.01, 2^-32, 2^-53, 2^52+1, -2^52-1 },
  string     = { '', '""', "''", "\"", '\'', '0', 'inf', 'nan', 'false' },
['function'] = { \ (), \ false, \ 0, \ '0', \\ (), \{}, \\{}, \ 0..0, \ 0i },
  table      = { {}, {false}, {0}, {'0'}, {\ ()}, {{}}, {\{}}, {0..0}, {0i} },
  xrange     = { 0..0, 0..0.1, 0.1..0, 1..2..0.1, -0.2..-0.1..0.1 },
  complex    = { 0i, 1i, 10i, 0.1i, -0i, -1i, -10i, -0.1i },
  integer    = { 0, 1, 2^32, 2^52, -0, -1, -2^32, -2^52, 2^52+0.1 },
}

local function assertTypes (tkey, tfunc, tskip)
  tkey = is_string(tkey) and {tkey} or tkey
  tskip = is_nil(tskip) and {} or tskip
  for _,s in ipairs(tkey) do
    tkey[s] = assertTrue
  end
  for k,t in pairs(types) do
    if is_nil(tskip[k]) then
      for i,v in ipairs(t) do
        !if tfunc(v) ~= (tkey[k] and true or false) then
        !  print(k,i,v,tfunc(v)) ! uncomment to find the faulty case
        !end
        (tkey[k] or assertFalse) ( tfunc(v) )
      end
    end
  end
end

function TestUtils:testIsNil()
  assertTypes( 'nil', is_nil )
end

function TestUtils:testIsBoolean()
  assertTypes( 'boolean', is_boolean )
end

function TestUtils:testIsNumber()
  assertTypes( {'number', 'integer'}, is_number )
end

function TestUtils:testIsNumber2()
  local t = {'nil', 'number', 'complex', 'integer'}
  local f = compose(is_number, tonumber)
  assertTypes( t, f, {string=true} )

  assertFalse( f(types.string[1]) )
  assertFalse( f(types.string[2]) )
  assertFalse( f(types.string[3]) )
  assertFalse( f(types.string[4]) )
  assertFalse( f(types.string[5]) )
  assertTrue ( f(types.string[6]) )
  assertTrue ( f(types.string[7]) )
  assertTrue ( f(types.string[8]) )
  assertFalse( f(types.string[9]) )
end

function TestUtils:testIsString()
  assertTypes( 'string', is_string )
end

function TestUtils:testIsString2()
  local t = {} ; for k in pairs(types) do t[#t+1] = k end
  assertTypes( t, compose(is_string, tostring) )
end

function TestUtils:testIsFunction()
  assertTypes( 'function', is_function )
end

function TestUtils:testIsTable()
  assertTypes( 'table', is_table )
end

function TestUtils:testIsCData()
  assertTypes( {'complex', 'xrange'}, is_cdata )
end

function TestUtils:testIsXRange()
  assertTypes( 'xrange', is_xrange )
end

function TestUtils:testIsComplex()
  assertTypes( 'complex', is_complex )
end

function TestUtils:testIsInteger()
  assertTypes( 'integer', is_integer )
end

function TestUtils:testIsRawtable()
  assertTypes( 'table', is_rawtable )
  assertFalse( is_rawtable(sm({},{})) )
end

function TestUtils:testIsScalar()
  assertTypes( {'number', 'complex', 'integer'}, is_scalar )
end

function TestUtils:testIsIterable()
  assertTypes( {'table', 'xrange'}, is_iterable )
  assertTrue ( is_iterable(sm({},{})) ) ! fake: tables are always iterable
  assertTrue ( is_iterable(sm({},{__ipair=\ ()})) )
  assertTrue ( is_iterable(sm({},{__pairs=\ ()})) )
end

function TestUtils:testIndexable()
  assertTypes( {'string', 'table', 'xrange'}, is_indexable )
  assertTrue ( is_indexable(sm({},{})) ) ! fake: tables are always indexable
  assertTrue ( is_indexable(sm({},{__index=\ ()})) )
  assertTrue ( is_indexable(sm({},{__newindex=\ ()})) )
end

function TestUtils:testIsCallable()
  assertTypes( {'function'}, is_callable )
  assertFalse( is_callable(sm({},{})) )
  assertTrue ( is_callable(sm({},{__call=\ ()})) )
end

function TestUtils:testIsComparable()
  assertTypes( {'number', 'string', 'xrange', 'integer'}, is_comparable )
  assertFalse( is_comparable(sm({},{})) )
  assertTrue ( is_comparable(sm({},{__eq=\ ()})) )
end

function TestUtils:testIsOrdered()
  assertTypes( {'number', 'string', 'integer'}, is_ordered )
  assertFalse( is_ordered(sm({},{})) )
  assertTrue ( is_ordered(sm({},{__lt=\ ()})) )
  assertTrue ( is_ordered(sm({},{__le=\ ()})) )
end

function TestUtils:testCompose()
  local id, id1, id4 = \n,...(n+1,...), \...(1,...), \n n==4
  local f = compose(id4,compose(id,compose(id,compose(id,id1))))
  local t = {} ; for k in pairs(types) do t[#t+1] = k end
  assertTypes( t, f )
end

function TestUtils:testComposeBottom()
  local id, id1, id4, _ = \n,...(n+1,...), \...(1,...), \n n==4, compose_bottom
  local f = id4^id^id^id^id1^_
  local t = {} ; for k in pairs(types) do t[#t+1] = k end
  assertTypes( t, f )
end

function TestUtils:testGetmetatable()
  local t = {'nil', 'boolean', 'number', 'function', 'table', 'integer'}
  assertTypes( t, compose(is_nil, gm) )
  assertTypes( {'string', 'complex', 'xrange'}, \a gm(a)~=nil )
  assertTypes( 'complex', \a gm(a)==gm(0i) )
  assertTypes( 'xrange' , \a gm(a)==gm(0..0) )
end

-- end ------------------------------------------------------------------------o
