--[=[
 o-----------------------------------------------------------------------------o
 |
 | Sequence tests
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide regression test suites for the sequence module.

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local assertFalse, assertNil, assertNotNil, assertEquals, assertStrContains,
      assertErrorMsgContains      in MAD.utest

local drift, marker, sbend, quadrupole, sequence, bline in MAD.element

-- helpers --------------------------------------------------------------------o

local mth = \f,s,... s[f](s,...)

local function dumpseq (seq)
  local fmt = MAD.option.format
  MAD.option.format = "%.5g"
  print()
  print('sequence:', seq.name)
  print('i', 'name', 'L', 'S (s)', 'S (e)')
  seq:foreach \e,i => print(i, e.name, e.l, seq.s_pos[i], seq.e_pos[i]) end
  MAD.option.format = fmt
end

-- regression test suite ------------------------------------------------------o

TestSequence = {}

function TestSequence:tearDown()
  if MADX:is_open_env() == true then
    MADX:reset_env()
  end
end

function TestSequence:testNegativeDrift()
  local msg = "invalid element position at s = 0.5m (negative drift -0.5m) "..
              "in sequence 'ndrift' for element 'marker' at index 2"
  local no_error, error_msg =
    pcall(sequence, 'ndrift',  { marker { at=1 }, marker { at=0.5 } })
  assertFalse(no_error)
  assertStrContains(error_msg, msg)
end

function TestSequence:testSimple01()
  local marker, quadrupole, sequence in MAD.element
  local ip = marker 'ip' {}
  local qf = quadrupole 'qf' { l=6 }
  local lcell = 10

  local seq = sequence 'simple01' {
    l = lcell, direction=1, refer = 'entry',
    ip 'IP1' { at = 0 },
    qf 'QF1' { at = 0 },
    ip 'IP2' { at = lcell },
  }

  -- dumpseq(seq)
  assertEquals(#seq, 3)
  assertEquals(seq.s_pos[#seq], lcell)
end

function TestSequence:testSPSDef()
  local ds = drift      'ds' {}
  local dl = drift      'dl' {}
  local dm = drift      'dm' {}
  local b1 = sbend      'b1' {}
  local b2 = sbend      'b2' {}
  local qf = quadrupole 'qf' {}
  local qd = quadrupole 'qd' {}

  local pf  = bline 'pf'  {qf,2*b1,2*b2,ds}           -- # = 6
  local pd  = bline 'pd'  {qd,2*b2,2*b1,ds}           -- # = 6
  local p24 = bline 'p24' {qf,dm,2*b2,ds,pd}          -- # = 11 (5+6)
  local p42 = bline 'p42' {pf,qd,2*b2,dm,ds}          -- # = 11 (6+5)
  local p00 = bline 'p00' {qf,dl,qd,dl}               -- # = 4
  local p44 = bline 'p44' {pf,pd}                     -- # = 12 (6+6)
  local insert = bline 'insert' {p24,2*p00,p42}       -- # = 30 (11+2*4+11)
  local super  = bline 'super'  {7*p44,insert,7*p44}  -- # = 198 (7*12+30+7*12)
  local SPS = sequence 'SPS' {6*super}                -- # = 1188 (6*198)

  assertEquals(#SPS, 1188)
  assertEquals(SPS.s_pos[#SPS], 0)
end

function TestSequence:testConvertFiveCell2File()
  MADX.option.warn = false
  MADX:load("../share/fivecell/fivecell.seq", "fivecell_gen.mad")
  MADX.option.warn = true

  assertNotNil(require'fivecell_gen')

  local fivecell, ins in MADX
--  dumpseq(ins)
--  dumpseq(fivecell)
  assertEquals(#fivecell, 79)
  assertEquals(fivecell.s_pos[#fivecell], 534.6)
end

function TestSequence:testConvertFiveCell2Mem()
  MADX.option.warn = false
  MADX:load("../share/fivecell/fivecell.seq")
  MADX.option.warn = true

  local fivecell in MADX
  assertEquals(#fivecell, 79)
  assertEquals(fivecell.s_pos[#fivecell], 534.6)
end

function TestSequence:testLoadFiveCell()
  assertNotNil(require'fivecell_gen')

  local fivecell in MADX
  assertEquals(#fivecell, 79)
  assertEquals(fivecell.s_pos[#fivecell], 534.6)
end

function TestSequence:testConvertLHC2Files()
  MADX.option.warn = false
  MADX:load("../share/LHC/lhc_as-built.seq", "lhc_as-built_gen.mad")
  MADX:load("../share/LHC/opt_inj.madx"    , "opt_inj_gen.mad"     )
  MADX.option.warn = true

  assertNotNil(require'lhc_as-built_gen')
  assertNotNil(require'opt_inj_gen'     )

  local lhcb1, lhcb2 in MADX
  assertEquals(#lhcb1, 6675)
  assertEquals(#lhcb2, 6674)
  assertEquals(lhcb1.s_pos[#lhcb1], 26658.8832)
  assertEquals(lhcb2.s_pos[#lhcb2], 26658.8832)
end

function TestSequence:testConvertLHC2Mem()
  MADX.option.warn = false
  MADX:load("../share/LHC/lhc_as-built.seq")
  MADX:load("../share/LHC/opt_inj.madx"    )
  MADX.option.warn = true

  local lhcb1, lhcb2 in MADX
  assertEquals(#lhcb1, 6675)
  assertEquals(#lhcb2, 6674)
  assertEquals(lhcb1.s_pos[#lhcb1], 26658.8832)
  assertEquals(lhcb2.s_pos[#lhcb2], 26658.8832)
end

function TestSequence:testLoadLHC()
  assertNotNil(require'lhc_as-built_gen')
--  assertNotNil(require'lhc_as-built_set')
--  assertNotNil(require'lhc_undefvar'    )
--  assertNotNil(require'opt_inj_gen'     )

  local lhcb1, lhcb2 in MADX
  assertEquals(#lhcb1, 6675)
  assertEquals(#lhcb2, 6674)
  assertEquals(lhcb1.s_pos[#lhcb1], 26658.8832)
  assertEquals(lhcb2.s_pos[#lhcb2], 26658.8832)
end

-- forwarded meta-functions ---------------------------------------------------o

local ip = marker     'ip' {}
local qf = quadrupole 'qf' { l=1 }
local ds = drift      'ds' {}
local b1 = sbend      'b1' {}
local bl = sbend + drift

local seq = sequence 'seq' {
  direction=1, refer = 'entry',
  ip 'IP1' { at = 0 },
  qf 'QF1' { at = 0 },
  ip 'IP2' { at = lcell },
  ds 'DS1' { from = 3},
  b1 'B11' { from = 3},
}

local seq2 = sequence 'seq2' {
  l = lcell, direction=1, refer = 'entry',
  ip 'IP1' { at = 0 },
  qf 'QF1' { at = 0 },
  ip 'IP2' { at = lcell },
  ds 'DS1' { at = 3},
  b1 'B11' { at = 5},
}

function TestSequence:testSequence_init()
  local def, s = {
    kind='sequence', is_sequence=true, direction=1, refer='centre', l=0,
  }
  local msg = {
    "invalid argument #1 (non-empty sequence expected)",
  }
  assertErrorMsgContains( msg[1], sequence,      {}    )
  assertErrorMsgContains( msg[1], sequence, 's', {}    )
  assertErrorMsgContains( msg[1], sequence, 's', {l=0} )
  s = sequence 's'
  s = sequence 's' { marker }                  assertEquals( s.refer, 'centre')
  for k,v in pairs(def) do assertEquals( v, s[k] ) end
  s = sequence 's' { refer='entry', marker }   assertEquals( s.refer, 'entry' )
  s = sequence 's' { refer='exit' , marker }   assertEquals( s.refer, 'exit'  )
end

function TestSequence:testFlatten_sequ ()
  local vector in MAD
  local msg = {
    "unexpected corrupted flat sequence",
  }
  assertErrorMsgContains( msg[1], sequence, {bl {at=0}} )
  assertErrorMsgContains( msg[1], sequence, {ip, {}}    )

  local seqbl = sequence 'seq' {
    l = lcell, direction=1, refer = 'entry',
    ip 'IP1' { at = 0 },
    qf 'QF1' { at = 0 },
    ip 'IP2' { at = lcell },
    ds 'DS1' { at = 3},
    ip 'IP1' { at = 4},
    b1 'B11' { at = 5},
  }
  local seqs = sequence 'seq' {
    l = lcell, direction=1, refer = 'entry',
    ip 'IP1' {at=0},
    seq2     {at=0},
  }

  local bl = sbend + drift + vector(3)
  --local seq3 =  sequence {refer = 'entry', ip, qf, vector{1} } -- 351 line no indx in flatten_sequ
  --local seq3 =  sequence {refer = 'entry', ip, qf, bl        } -- 332 -> seq_err again
end

function TestSequence:testAdjust_len ()
  assertEquals( sequence { l= 2, ds {at=3}}.l, 3 )
  assertEquals( sequence { l=-1, ds {at=3}}.l, 3 )
  assertEquals( sequence { l= 5, ds {at=3}}.l, 5 )
  assertEquals( sequence {       ip       }.l, 0 )
  assertEquals( seq2     { l=2            }.l, 2 )
end

function TestSequence:testSequence_len()
  assertEquals( sequence {ip}.l, 0 )
  assertEquals( seq      {  }.l, 1 )
  assertEquals( seq2     {  }.l, 5 )
end

-- helpers --------------------------------------------------------------------o

function TestSequence:testIndex_of()
  -- name[count] (case of multiple occurences)
  -- #s or #S (idx=1), #e or #E (idx=#seq)
  local s = sequence {  refer = 'entry', ip 'IP1' {}, ds, qf, ds }
  assertEquals( s:index_of('IP1'), 1   )
  assertEquals( s:index_of( 1   ), 1   )
  assertEquals( s:index_of(-1   ), #s  )
  assertEquals( s:index_of(ip   ), nil )
  assertEquals( s:index_of(qf   ), 3   )
  assertEquals( s:index_of(ds   ), nil ) -- (case of multiple occurences) tbf
  --assertEquals( s:index_of(ds[1]), nil   )
  --print( s[ds.name] )
  --print( s:index_of(ds[1]) )
  for i=1,#seq do
    local name = seq[i].name
    assertEquals( seq:index_of( name), i        )
    assertEquals( seq:index_of( i   ), i        )
    assertEquals( seq:index_of(-i   ), #seq-i+1 )
  end
end

function TestSequence:testSfind_index()
  --for i=1,#s_pos do
  --  local s = seq.s_pos[i]
  --  print( seq:sfind_index(s) )
  --end
end

function TestSequence:testLfind_index()
  for i=1,#seq do
    local name = seq[i].kind
    --print( seq:lfind_index() )
  end
end

-- methods --------------------------------------------------------------------o

function TestSequence:testRange_index()
  local msg = {
    "invalid range, start > stop",
    "invalid range start"        ,
    "invalid range stop"         ,
  }
  assertErrorMsgContains( msg[1], mth, 'range_index', seq, {-1,1} )
  assertErrorMsgContains( msg[1], mth, 'range_index', seq, { 2,1} )
  assertErrorMsgContains( msg[1], mth, 'range_index', seq,  '2/1' )

  assertEquals( {seq:range_index( 1,5 )}, {1,1   } )
  assertEquals( {seq:range_index( 1   )}, {1,1   } )

  assertEquals( {seq:range_index()     }, {1,#seq} )
  assertEquals( {seq:range_index('1/5')}, {1,#seq} )
  assertEquals( {seq:range_index({1,5})}, {1,#seq} )
end

function TestSequence:testEpos_of() -- based on index_of
  local msg = {
    "invalid argument #2 (index, string or element expected)",
    "invalid argument #2 (valid key expected)"               ,
  }
  assertErrorMsgContains( msg[1], mth, 'pos_of', seq, nil )
  --assertErrorMsgContains( msg[2], mth, 'pos_of', seq, nil )

--  print( seq:epos_of(1) )
end

function TestSequence:testSpos_of()
  local msg = {
    "invalid argument #2 (valid key expected)",
  }
end

function TestSequence:testForeach()
  local msg = {
    "invalid argument #2 (callable expected)",
  }
end

function TestSequence:testFilter()
  local msg = {
    "invalid argument #2 (callable expected)",
  }
end

function TestSequence:testSelect()
  local msg = {
    "invalid argument #2 (callable expected)",
  }
end

function TestSequence:testUnique()
  local msg = {
    "unexpected corrupted dictionnary",
  }
end

function TestSequence:testTie()
local msg = {
  "invalid argument #2 (sequence expected)",
  "invalid shared element (must be unique)",
}
end


function TestSequence:testDeselect() end

function TestSequence:testIs_selected() end

-- end ------------------------------------------------------------------------o