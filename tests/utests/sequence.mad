--[=[
 o-----------------------------------------------------------------------------o
 |
 | Sequence tests
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 |          A. Bloch,  aurelien.bloch at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide regression test suites for the sequence module.

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o
local filesys, mtable                                   in MAD
local assertTrue, assertFalse, assertNil, assertNotNil, assertEquals,
      assertErrorMsgContains                            in MAD.utest
local is_sequence                                       in MAD.typeid
local drift, marker, sbend, quadrupole, sequence, bline in MAD.element

local srcdir = \s -> '../share/'    ..s
local refdir = \s -> 'sequence_ref/'..s
local rundir = \s -> 'sequence_run/'..s
local _msg   = {
  "invalid write access to readonly mtable",
  "nil reference value",
  "no reference column found",
}
-- helpers --------------------------------------------------------------------o

local function dumpseq (seq)
  local optfmt = MAD.option.format
  MAD.option.format = "%.5g"
  print()
  print('sequence:', seq.name, 'l=', seq.l)
  print('i', 'name', 'L', 'S (s)', 'S (e)')
  seq:foreach \e,i => print(i, e.name, e.l, seq:spos(i), seq:epos(i)) end
  MAD.option.format = optfmt
end

local function getIdxSeq()
  local seq = sequence {
    l = 5,
    marker "name1" { at = 1 },
    marker "name2" { at = 2 },
    marker "name1" { at = 3 },
    marker "name1" { at = 4 },
  }
  return seq
 end

-- regression test suite ------------------------------------------------------o

TestSequence = {}

function TestSequence:testIsSequence()
  local seq1  = sequence "seq1"  { marker {} }
  local seq12 = seq1     "seq12" { }
  assertTrue (is_sequence(sequence))
  assertTrue (is_sequence(seq1))
  assertTrue (is_sequence(seq12))
  assertFalse(is_sequence({}))
  assertFalse(is_sequence(mtable {}))
end

function TestSequence:testIsOwner()
  local seq1  = sequence "seq1"  { marker {} }
  local seq12 = seq1     "seq12" { }
  assertTrue (sequence:is_owner())
  assertTrue (seq1    :is_owner())
  assertFalse(seq12   :is_owner())
end

function TestSequence:testIsView()
  local seq1  = sequence "seq1"  { marker {} }
  local seq12 = seq1     "seq12" { }
  assertFalse(sequence:is_view())
  assertFalse(seq1    :is_view())
  assertTrue (seq12   :is_view())
end

function TestSequence:testIndexOfNum()
  local seq  = getIdxSeq()
  assertNil(seq:index_of(6   ))
  assertNil(seq:index_of(-6  ))
  assertNil(seq:index_of(100 ))
  assertNil(seq:index_of(-100))
  assertEquals(seq:index_of( 0)  , 1)
  assertEquals(seq:index_of( 1)  , 2)
  assertEquals(seq:index_of( 2)  , 3)
  assertEquals(seq:index_of(-3)  , 3)
  assertEquals(seq:index_of( 4)  , 5)
  assertEquals(seq:index_of(-1)  , 5)
  assertEquals(seq:index_of(4.4) , 6)
  assertEquals(seq:index_of(-0.1), 6)
  assertEquals(seq:index_of(-0.1), 6)
end

function TestSequence:testIndexOfString()
  local seq = getIdxSeq()
  local msg = {
    "invalid argument #2 (non-zero count expected)",
  }
  assertNil   (seq:index_of("name100  "   )   )
  assertNil   (seq:index_of("name1[4] "   )   )
  assertNil   (seq:index_of("name2[2] "   )   )
  assertNil   (seq:index_of("name1[-4]"   )   )
  assertNil   (seq:index_of("name2[-2]"   )   )
  assertNil   (seq:index_of("name1{3} ", 3)   )
  assertNil   (seq:index_of("name1{3} ",-4)   )
  assertNil   (seq:index_of("name1{-2}", 2)   )
  assertNil   (seq:index_of("name1{-2}",-5)   )
  assertNil   (seq:index_of("name1{-3}", 4)   )
  assertNil   (seq:index_of("name1{-3}",-3)   )
  assertEquals(seq:index_of("name1"       ), 2)
  assertEquals(seq:index_of("name2"       ), 3)
  assertEquals(seq:index_of("name1[1]"    ), 2)
  assertEquals(seq:index_of("name2[1]"    ), 3)
  assertEquals(seq:index_of("name1[2]"    ), 4)
  assertEquals(seq:index_of("name1[3]"    ), 5)
  assertEquals(seq:index_of("name1[-1]"   ), 5)
  assertEquals(seq:index_of("name2[-1]"   ), 3)
  assertEquals(seq:index_of("name1[-3]"   ), 2)
  assertEquals(seq:index_of("name1{1}" , 2), 2)
  assertEquals(seq:index_of("name1{1}" ,-5), 2)
  assertEquals(seq:index_of("name1{1}" , 3), 4)
  assertEquals(seq:index_of("name1{1}" ,-4), 4)
  assertEquals(seq:index_of("name1{2}" , 3), 5)
  assertEquals(seq:index_of("name1{2}" ,-4), 5)
  assertEquals(seq:index_of("name1{-1}", 3), 2)
  assertEquals(seq:index_of("name1{-1}",-4), 2)
  assertEquals(seq:index_of("name1{-1}", 2), 2)
  assertEquals(seq:index_of("name1{-1}",-5), 2)
  assertEquals(seq:index_of("name1{-2}", 4), 2)
  assertEquals(seq:index_of("name1{-2}",-3), 2)
  assertEquals(seq:index_of("name1{-1}", 4), 4)
  assertEquals(seq:index_of("name1{-1}",-3), 4)
  assertEquals(seq:index_of("name1{-2}", 5), 4)
  assertEquals(seq:index_of("name1{-2}",-2), 4)
  assertEquals(seq:index_of("name1{-3}", 5), 2)
  assertEquals(seq:index_of("name1{-3}",-2), 2)
  assertEquals(seq:index_of("name2{-1}", 4), 3)
  assertEquals(seq:index_of("name2{-1}",-3), 3)
  assertErrorMsgContains(msg[1], sequence.index_of, seq, "name1{0}", 2)
end

function TestSequence:testIndexOfElem()
  local mk1 = marker "name1" { }
  local mk2 = marker "name2" { at = 2, l = 1 }
  local mk3 = marker "name1" { }
  local mk4 = marker "name3" { }
  local mk5 = marker "name1" { }
  local seq = sequence {
    l = 5, refer = "entry",
    mk1,mk2,mk1,mk1,mk3
  }
  assertNil(seq:index_of(mk4)   )
  assertNil(seq:index_of(mk5)   )
  assertNil(seq:index_of(mk1, 6))
  assertEquals(seq:index_of(mk1)   , 2)
  assertEquals(seq:index_of(mk2)   , 3)
  assertEquals(seq:index_of(mk3)   , 6)
  assertEquals(seq:index_of(mk3, 3), 6)
  assertEquals(seq:index_of(mk1, 2), 2)
  assertEquals(seq:index_of(mk1,-6), 2)
  assertEquals(seq:index_of(mk1, 3), 4)
  assertEquals(seq:index_of(mk1,-5), 4)
end

function TestSequence:testIndexOfInvalid()
  local msg = {
    "invalid argument #2 (number, string or element expected)"
  }
  local seq = sequence {}
  assertErrorMsgContains(msg[1], sequence.index_of, seq, {})
  assertErrorMsgContains(msg[1], sequence.index_of, seq, nil)
  assertErrorMsgContains(msg[1], sequence.index_of, seq, \ ())
end

-------------------------------------------------------------------------------o

-- end ------------------------------------------------------------------------o