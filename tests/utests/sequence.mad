--[=[
 o-----------------------------------------------------------------------------o
 |
 | Sequence tests
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 |          A. Bloch,  aurelien.bloch at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide regression test suites for the sequence module.

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o
local filesys, mtable, Object                                     in MAD
local assertTrue, assertFalse, assertNil, assertNotNil,
      assertEquals, assertErrorMsgContains, assertIs              in MAD.utest
local is_sequence, is_element                                     in MAD.typeid
local tblcpy                                                      in MAD.utility
local drift, marker, sbend, quadrupole, sequence, bline, flags    in MAD.element
local selected                                                    in flags

local srcdir = \s -> '../share/'    ..s
local refdir = \s -> 'sequence_ref/'..s
local rundir = \s -> 'sequence_run/'..s
local _msg   = {
  "invalid write access to readonly mtable",
  "nil reference value",
  "no reference column found",
}
-- helpers --------------------------------------------------------------------o

local function dumpseq (seq)
  local optfmt = MAD.option.format
  MAD.option.format = "%.5g"
  print()
  print('sequence:', seq.name, 'l=', seq.l)
  print('i', 'name', 'L', 'S (s)', 'S (e)')
  seq:foreach \e,i => print(i, e.name, e.l, seq:spos(i), seq:epos(i)) end
  MAD.option.format = optfmt
end

local function getIdxSeq()
  local seq = sequence {
    l = 5,
    marker     "name1" { at = 1, eid = 2 },
    quadrupole "name2" { at = 2, eid = 3 },
    quadrupole "name1" { at = 3, eid = 4 },
    marker     "name1" { at = 4, eid = 5 },
  }
  seq[1].eid = 1
  seq[6].eid = 6
  return seq
end

local function assertElem(actual, expected)
  assertTrue(is_element(actual  ))
  assertTrue(is_element(expected))
  assertEquals(actual, expected)
end

-- regression test suite ------------------------------------------------------o

TestSequence = {}

function TestSequence:testIsSequence()
  local seq1  = sequence "seq1"  { marker {} }
  local seq12 = seq1     "seq12" { }
  assertTrue (is_sequence(sequence))
  assertTrue (is_sequence(seq1))
  assertTrue (is_sequence(seq12))
  assertFalse(is_sequence({}))
  assertFalse(is_sequence(mtable {}))
end

function TestSequence:testIsOwner()
  local seq1  = sequence "seq1"  { marker {} }
  local seq12 = seq1     "seq12" { }
  assertTrue (sequence:is_owner())
  assertTrue (seq1    :is_owner())
  assertFalse(seq12   :is_owner())
end

function TestSequence:testIsView()
  local seq1  = sequence "seq1"  { marker {} }
  local seq12 = seq1     "seq12" { }
  assertFalse(sequence:is_view())
  assertFalse(seq1    :is_view())
  assertTrue (seq12   :is_view())
end

function TestSequence:testView()
  local seq1  = getIdxSeq()
  local seq12 = seq1 "seq12" { }
  seq12:check_index()
  for i=1,#seq1 do assertIs(seq12[i], seq1[i]) end
  assertEquals(#seq12, #seq1)
end

function TestSequence:testInit()
  local seq1 = sequence "seq1" {
    marker { eid = 1 },
  }
  local seq2 = sequence "seq2" {
    marker { eid = 1 },
    marker { eid = 2 },
    marker { eid = 3 },
    marker { eid = 4 },
  }
  assertEquals(#seq1, 3)
  assertEquals(#seq2, 6)
  for i=1,3 do assertIs(seq1[i], seq1:elem(i)) end
  for i=1,6 do assertIs(seq2[i], seq2:elem(i)) end

  assertTrue  (seq1[1].is_marker)
  assertEquals(seq2[2].eid, 1)
  for i=2,5 do
    assertTrue  (seq2[i].is_marker)
    assertEquals(seq2[i].eid, i-1)
  end
end

function TestSequence:testInitOwner()
  local seq1 = sequence { owner = true }
  local seq2 = sequence { marker { } }
  local seq3 = seq2 { owner = true }
  assertTrue(seq1:is_owner())
  assertTrue(seq3:is_owner())
  assertEquals(#seq1, 2)
  assertEquals(#seq3, 2)
end

function TestSequence:testInitSimpleSpos()
  local seq = sequence "seq" {
    l = 10,
    marker { at = 1 },
    marker { at = 2 },
    marker { at = 3 },
    marker { at = 4 },
  }
  for i=2,5 do
    assertEquals(seq:spos(i), seq[i].at)
    assertEquals(seq:epos(i), seq[i].at)
  end
  assertEquals(seq:spos(1), 0 )
  assertEquals(seq:spos(6), 10)
end

function TestSequence:testInitInvalidElem()
  local msg = {
    "invalid element detected",
  }
  assertErrorMsgContains(msg[1], sequence, "seq", { 1     })
  assertErrorMsgContains(msg[1], sequence, "seq", { true  })
  assertErrorMsgContains(msg[1], sequence, "seq", { \ ()  })
  assertErrorMsgContains(msg[1], sequence, "seq", { "seq" })
end

function TestSequence:testInitElemReferPos()
  local epos  = { 1, 2, 3 }
  local sposs = {
    entry  = { 1  , 2  , 3   },
    centre = { 0.5, 1.5, 2.5 },
    exit   = { 0  , 1  , 2   },
  }

  for refer,spos in pairs(sposs) do
    local seq1 = sequence "seq" {
      refer = refer,
      drift "prv" { l = 1, at = 1 },
      drift "elm" { l = 1, at = 2 },
      drift "nxt" { l = 1, at = 3 },
    }
    local seq2 = sequence "seq" {
      drift "prv" { l = 1, at = 1, refpos = refer },
      drift "elm" { l = 1, at = 2, refpos = refer },
      drift "nxt" { l = 1, at = 3, refpos = refer },
    }
    for i=2,4 do
      assertEquals(seq1:spos(i), spos[i-1])
      assertEquals(seq1:epos(i), epos[i-1])
      assertEquals(seq2:spos(i), spos[i-1])
      assertEquals(seq2:epos(i), epos[i-1])
    end
  end
end

function TestSequence:testInitElemFromPos()
  local prv   = drift "prv" { l = 1, at = 1 }
  local elm   = drift "elm" { l = 1         }
  local nxt   = drift "nxt" { l = 1, at = 3 }
  local froms = {
    start      = 2,
    prev       = 0,
    next       =-1,
    ["end"]    =-2,
    prv        = 1,
    nxt        =-1,
    ["$start"] = 2,
    ["$end"]   =-2,
  }

  for from, at in pairs(froms) do
    elm.from  = from
    elm.at    = at
    local seq = sequence "seq" { l = 4, refer = "entry", prv, elm, nxt }
    print(seq.l)
    assertEquals(seq:epos(3), 2)
  end
end

function TestSequence:testInitElemFromPosWithName()
  local params = {
    ["name1"    ] = 1,
    ["name1[1]" ] = 1,
    ["name1[2]" ] =-1,
    ["name1[3]" ] =-2,
    ["name1[-1]"] =-2,
    ["name1[-2]"] =-1,
    ["name1[-3]"] = 1,
    ["name1{1}" ] =-1,
    ["name1{-1}"] = 1,
  }

  for from,at in pairs(params) do
    local seq = sequence "seq" {
      l = 5,
      drift "name1" { l = 1, at = 1               },
      drift "name2" { l = 1, at = at, from = from },
      drift "name1" { l = 1, at = 3               },
      drift "name1" { l = 1, at = 4               },
    }
    assertEquals(seq:spos(3), 2)
  end
end

function TestSequence:testInitElemFromPosInvalid()
  local newParam = \ -> { refer = "entry",
    drift "prv" { l = 1, at = 1 },
    drift "elm" { l = 1, at = 1 },
    drift "nxt" { l = 1, at = 3 },
  }
  local param
  local msg   = {
    "invalid from='selected' detected in sequence \z
      'seq' for element 'elm' at index 3",
    "invalid element position at s = 3m (negative drift -1m) \z
      in sequence 'seq' for element 'nxt' at index 4",
    "cycling dependencies detected in sequence 'seq' for element '?' at index 3",
    "invalid refer to subelement (NYI)",
    "invalid from of 'none' in sequence 'seq' for element '?' at index ?",
  }
  param = newParam();
  param[2].from = "selected"
  assertErrorMsgContains(msg[1], sequence, "seq", param)
  param = newParam();
  param[2].from = "prev"
  assertErrorMsgContains(msg[2], sequence, "seq", param)
  param         = newParam();
  param[2].from = "next"
  param[3].from = "prev"
  assertErrorMsgContains(msg[3], sequence, "seq", param)
  param       = newParam();
  param.refer = "invalid"
  assertErrorMsgContains(msg[4], sequence, "seq", param)
  param         = newParam();
  param[2].from = "none"
  assertErrorMsgContains(msg[5], sequence, "seq", param)
end

function TestSequence:testInitDebug()
  local debug = MAD.option.debug
  MAD.option.debug = 3
  local seq = getIdxSeq()
  MAD.option.debug = debug
end

function TestSequence:testInitFlattenTable()
  local line1 = {     drift {}, quadrupole {}  , drift {}  , quadrupole {} }
  local line2 = { {   drift {}, quadrupole {} }, drift {}  , quadrupole {} }
  local line3 = { { { drift {}, quadrupole {} }, drift {} }, quadrupole {} }
  local seq   = sequence {
    line1,
    line2,
    drift {},
    line3,
  }
  assertEquals(#seq, 15)
  local idrift      = { 2, 4, 6, 8, 10, 11, 13 }
  local iquadrupole = { 3, 5, 7, 9, 12, 14     }
  for _,i in ipairs(idrift)      do assertEquals(seq[i].kind, "drift")      end
  for _,i in ipairs(iquadrupole) do assertEquals(seq[i].kind, "quadrupole") end
end

function TestSequence:testInitFlattenbline()
  local line1 = bline { drift {}     , quadrupole {} }
  local line2 = bline { quadrupole {}, drift {}      }
  local line3 = bline { line1        ,-line2         }
  local seq   = sequence {
    line3 * 2,
    drift {} ,
    2 * line1,
  }
  assertEquals(#seq, 15)
  local idrift      = { 2, 4, 6, 8, 10, 11, 13 }
  local iquadrupole = { 3, 5, 7, 9, 12, 14     }
  for _,i in ipairs(idrift)      do assertEquals(seq[i].kind, "drift")      end
  for _,i in ipairs(iquadrupole) do assertEquals(seq[i].kind, "quadrupole") end
end

function TestSequence:testInitFlattenSeqSimple()
  local seq1 = sequence { drift {}, quadrupole {}  , drift {}  , quadrupole {} }
  local seq2 = sequence {
    sequence   { drift {}, quadrupole {} },
    drift      { },
    quadrupole { },
  }
  local seq3 = sequence {
    sequence {
      sequence { drift {}, quadrupole {} },
      drift    { },
    },
    quadrupole {},
  }
  local seq   = sequence {
    seq1,
    seq2,
    drift {},
    seq3,
  }
  assertEquals(#seq, 15)
  local idrift      = { 2, 4, 6, 8, 10, 11, 13 }
  local iquadrupole = { 3, 5, 7, 9, 12, 14     }
  for _,i in ipairs(idrift)      do assertEquals(seq[i].kind, "drift")      end
  for _,i in ipairs(iquadrupole) do assertEquals(seq[i].kind, "quadrupole") end
end

function TestSequence:testInitFlattenSeqLine()
  local line1 =          { drift {}     , quadrupole {}           }
  local line2 = sequence { quadrupole {}, drift {}                }
  local line3 = bline    { line1        ,-line2                   }
  local line4 = sequence { quadrupole {}, drift {}, direction =-1 }
  local seq   = sequence {
    line3 * 2,
    drift {},
    line1,
    line4,
  }
  assertEquals(#seq, 17)
  local idrift      = { 2 , 4, 6, 8, 10, 11, 15 }
  local iquadrupole = { 3 , 5, 7, 9, 12, 14 }
  local ichangedir  = { 13, 16 }
  for _,i in ipairs(idrift)      do assertEquals(seq[i].kind, "drift")      end
  for _,i in ipairs(iquadrupole) do assertEquals(seq[i].kind, "quadrupole") end
  for _,i in ipairs(ichangedir)  do assertEquals(seq[i].kind, "changedir")  end
end

function TestSequence:testInitFlattenSeq()
  local case = {
    { at = 1                                  },
    { at =-4, from = "d2'"                    },
    { at =-2, from = "d2'", refpos = "d2"     },
    { at = 3, l    = 4    , refpos = "centre" },
  }
  local elms = {
    drift "d1" { l = 1, at = 1 },
    drift "d2" { l = 1, at = 2 },
    drift "d3" { l = 1, at = 3 },
  }
  for _,v in pairs(case) do
    local param = tblcpy(elms, nil, tblcpy(v))
    local seq = sequence "seq" {
      drift "d1'" { l = 1, at = 1 },
      sequence("sub", param),
      drift "d2'" { l = 1, at = 5 },
    }
    for i=2,6 do assertEquals(seq:spos(i), i-1) end
  end
end

function TestSequence:testInitFlattenInvalid()
  local line1 = bline { drift {}     , quadrupole {} }
  local line2 = bline { quadrupole {}, drift {}      }
  local line3 = bline { line1        ,-line2         }
  local param = {
    line3 * 2,
    drift {} ,
    2 * line1,
  }
  local msg = {
    "invalid element detected",
  }
  assertErrorMsgContains(msg[1], sequence, "seq", {       { 1     } } )
  assertErrorMsgContains(msg[1], sequence, "seq", {       { true  } } )
  assertErrorMsgContains(msg[1], sequence, "seq", {       { \ ()  } } )
  assertErrorMsgContains(msg[1], sequence, "seq", {       { "seq" } } )
  assertErrorMsgContains(msg[1], sequence, "seq", { bline { 1     } } )
  assertErrorMsgContains(msg[1], sequence, "seq", { bline { true  } } )
  assertErrorMsgContains(msg[1], sequence, "seq", { bline { \ ()  } } )
  assertErrorMsgContains(msg[1], sequence, "seq", { bline { "seq" } } )
end

function TestSequence:testIndexOfNum()
  local seq  = getIdxSeq()
  assertNil(seq:index_of( 6  ))
  assertNil(seq:index_of(-6  ))
  assertNil(seq:index_of( 100))
  assertNil(seq:index_of(-100))
  assertEquals(seq:index_of( 0)  , 1)
  assertEquals(seq:index_of( 1)  , 2)
  assertEquals(seq:index_of( 2)  , 3)
  assertEquals(seq:index_of(-3)  , 3)
  assertEquals(seq:index_of( 4)  , 5)
  assertEquals(seq:index_of(-1)  , 5)
  assertEquals(seq:index_of( 4.4), 6)
  assertEquals(seq:index_of(-0.1), 6)
  assertEquals(seq:index_of(-0.1), 6)
end

function TestSequence:testIndexOfString()
  local seq = getIdxSeq()
  local msg = {
    "invalid argument #2 (non-zero count expected)",
  }
  assertNil   (seq:index_of("name100  "   )   )
  assertNil   (seq:index_of("name1[4] "   )   )
  assertNil   (seq:index_of("name2[2] "   )   )
  assertNil   (seq:index_of("name1[-4]"   )   )
  assertNil   (seq:index_of("name2[-2]"   )   )
  assertNil   (seq:index_of("name1{3} ", 3)   )
  assertNil   (seq:index_of("name1{3} ",-4)   )
  assertNil   (seq:index_of("name1{-2}", 2)   )
  assertNil   (seq:index_of("name1{-2}",-5)   )
  assertNil   (seq:index_of("name1{-3}", 4)   )
  assertNil   (seq:index_of("name1{-3}",-3)   )
  assertEquals(seq:index_of("name1"       ), 2)
  assertEquals(seq:index_of("name2"       ), 3)
  assertEquals(seq:index_of("name1[1]"    ), 2)
  assertEquals(seq:index_of("name2[1]"    ), 3)
  assertEquals(seq:index_of("name1[2]"    ), 4)
  assertEquals(seq:index_of("name1[3]"    ), 5)
  assertEquals(seq:index_of("name1[-1]"   ), 5)
  assertEquals(seq:index_of("name2[-1]"   ), 3)
  assertEquals(seq:index_of("name1[-3]"   ), 2)
  assertEquals(seq:index_of("name1{1}" , 2), 2)
  assertEquals(seq:index_of("name1{1}" ,-5), 2)
  assertEquals(seq:index_of("name1{1}" , 3), 4)
  assertEquals(seq:index_of("name1{1}" ,-4), 4)
  assertEquals(seq:index_of("name1{2}" , 3), 5)
  assertEquals(seq:index_of("name1{2}" ,-4), 5)
  assertEquals(seq:index_of("name1{-1}", 3), 2)
  assertEquals(seq:index_of("name1{-1}",-4), 2)
  assertEquals(seq:index_of("name1{-1}", 2), 2)
  assertEquals(seq:index_of("name1{-1}",-5), 2)
  assertEquals(seq:index_of("name1{-2}", 4), 2)
  assertEquals(seq:index_of("name1{-2}",-3), 2)
  assertEquals(seq:index_of("name1{-1}", 4), 4)
  assertEquals(seq:index_of("name1{-1}",-3), 4)
  assertEquals(seq:index_of("name1{-2}", 5), 4)
  assertEquals(seq:index_of("name1{-2}",-2), 4)
  assertEquals(seq:index_of("name1{-3}", 5), 2)
  assertEquals(seq:index_of("name1{-3}",-2), 2)
  assertEquals(seq:index_of("name2{-1}", 4), 3)
  assertEquals(seq:index_of("name2{-1}",-3), 3)
  assertErrorMsgContains(msg[1], sequence.index_of, seq, "name1{0}", 2)
end

function TestSequence:testIndexOfElem()
  local mk1 = marker "name1" { }
  local mk2 = marker "name2" { at = 2, l = 1 }
  local mk3 = marker "name1" { }
  local mk4 = marker "name3" { }
  local mk5 = marker "name1" { }
  local seq = sequence {
    l = 5, refer = "entry",
    mk1,mk2,mk1,mk1,mk3
  }
  assertNil(seq:index_of(mk4)   )
  assertNil(seq:index_of(mk5)   )
  assertNil(seq:index_of(mk1, 6))
  assertEquals(seq:index_of(mk1)   , 2)
  assertEquals(seq:index_of(mk2)   , 3)
  assertEquals(seq:index_of(mk3)   , 6)
  assertEquals(seq:index_of(mk3, 3), 6)
  assertEquals(seq:index_of(mk1, 2), 2)
  assertEquals(seq:index_of(mk1,-6), 2)
  assertEquals(seq:index_of(mk1, 3), 4)
  assertEquals(seq:index_of(mk1,-5), 4)
end

function TestSequence:testIndexOfInvalid()
  local msg = {
    "invalid argument #2 (number, string or element expected)"
  }
  local seq = sequence {}
  assertErrorMsgContains(msg[1], sequence.index_of, seq, {})
  assertErrorMsgContains(msg[1], sequence.index_of, seq, nil)
  assertErrorMsgContains(msg[1], sequence.index_of, seq, \ ())
end

function TestSequence:testIndex()
  local seq  = getIdxSeq()
  assertNil(seq:index( 0  ))
  assertNil(seq:index( 7  ))
  assertNil(seq:index( 100))
  assertNil(seq:index(-100))
  assertEquals(seq:index( 1), 1)
  assertEquals(seq:index( 6), 6)
  assertEquals(seq:index(-1), 6)
  assertEquals(seq:index(-3), 4)
end

function TestSequence:testNameOfDirect()
  local seq = sequence {
    marker "name1" { },
    marker "name2" { },
    marker "name3" { },
    marker "name4" { },
  }
  local msg = {
    "invalid argument #2 (integer expected)",
  }
  assertNil(seq:name_of( 7  ))
  assertNil(seq:name_of(-7  ))
  assertNil(seq:name_of( 100))
  assertNil(seq:name_of(-100))
  assertEquals(seq:name_of( 1), "$start")
  assertEquals(seq:name_of( 2), "name1" )
  assertEquals(seq:name_of( 5), "name4" )
  assertEquals(seq:name_of( 6), "$end"  )
  assertEquals(seq:name_of(-2), "name4" )
  assertEquals(seq:name_of(-4), "name2" )
  assertErrorMsgContains(msg[1], sequence.name_of, seq, 1.5)
end

function TestSequence:testNameOfCnt()
  local seq = getIdxSeq()
  assertEquals(seq:name_of(3   ), "name2"    )
  assertEquals(seq:name_of(2   ), "name1[1]" )
  assertEquals(seq:name_of(4   ), "name1[2]" )
  assertEquals(seq:name_of(5   ), "name1[3]" )
  assertEquals(seq:name_of(2, 1), "name1{1}" )
  assertEquals(seq:name_of(2,-6), "name1{1}" )
  assertEquals(seq:name_of(4, 3), "name1{1}" )
  assertEquals(seq:name_of(4,-4), "name1{1}" )
  assertEquals(seq:name_of(5, 3), "name1{2}" )
  assertEquals(seq:name_of(5,-4), "name1{2}" )
  assertEquals(seq:name_of(2, 3), "name1{-1}")
  assertEquals(seq:name_of(2,-4), "name1{-1}")
  assertEquals(seq:name_of(2, 4), "name1{-1}")
  assertEquals(seq:name_of(2,-3), "name1{-1}")
  assertEquals(seq:name_of(2, 5), "name1{-2}")
  assertEquals(seq:name_of(2,-2), "name1{-2}")
end

function TestSequence:testRangeOfNum()
  local seq = getIdxSeq()
  local msg = {
    "invalid range start",
    "invalid argument #2 (integer, string, table or range expected)",
  }
  assertEquals(table.pack(seq:range_of(1 )), {1,1, n=2})
  assertEquals(table.pack(seq:range_of(4 )), {4,4, n=2})
  assertEquals(table.pack(seq:range_of(-3)), {4,4, n=2})
  assertEquals(table.pack(seq:range_of(-5)), {2,2, n=2})
  assertErrorMsgContains(msg[1], sequence.range_of, seq, 0  )
  assertErrorMsgContains(msg[1], sequence.range_of, seq, 7  )
  assertErrorMsgContains(msg[1], sequence.range_of, seq, 100)
  assertErrorMsgContains(msg[1], sequence.range_of, seq,-100)
  assertErrorMsgContains(msg[2], sequence.range_of, seq, 1.5)
end

function TestSequence:testRangeOfStringNum()
  local seq = getIdxSeq()
  assertEquals(table.pack(seq:range_of(" 1/ 1")), {2,2, n=2})
  assertEquals(table.pack(seq:range_of(" 2/ 2")), {3,3, n=2})
  assertEquals(table.pack(seq:range_of("-1/ 1")), {5,2, n=2})
  assertEquals(table.pack(seq:range_of("-1/ 4")), {5,5, n=2})
  assertEquals(table.pack(seq:range_of(" 1/-1")), {2,5, n=2})
  assertEquals(table.pack(seq:range_of(" 4/-1")), {5,5, n=2})
end

function TestSequence:testRangeOfStringPositive()
  local seq = getIdxSeq()
  assertEquals(table.pack(seq:range_of("name1    /name1    "   )), {2,2, n=2})
  assertEquals(table.pack(seq:range_of("name1    /name2    "   )), {2,3, n=2})
  assertEquals(table.pack(seq:range_of("name1[2] /name1[2] "   )), {4,4, n=2})
  assertEquals(table.pack(seq:range_of("name1[-2]/name1[-2]"   )), {4,4, n=2})
  assertEquals(table.pack(seq:range_of("name1[1] /name1[3] "   )), {2,5, n=2})
  assertEquals(table.pack(seq:range_of("name1[-3]/name1[-1]"   )), {2,5, n=2})
  assertEquals(table.pack(seq:range_of("name1[2] /name1[3] "   )), {4,5, n=2})
  assertEquals(table.pack(seq:range_of("name1[-2]/name1[-1]"   )), {4,5, n=2})
  assertEquals(table.pack(seq:range_of("name1[1] /name1[-1]"   )), {2,5, n=2})
  assertEquals(table.pack(seq:range_of("name1{1} /name1{2} ", 3)), {4,5, n=2})
  assertEquals(table.pack(seq:range_of("name1{1} /name1{2} ",-4)), {4,5, n=2})
  assertEquals(table.pack(seq:range_of("name1{1} /name1{2} ", 4)), {4,5, n=2})
  assertEquals(table.pack(seq:range_of("name1{1} /name1{2} ",-3)), {4,5, n=2})
  assertEquals(table.pack(seq:range_of("name1{-1}/name1{1} ", 4)), {4,4, n=2})
  assertEquals(table.pack(seq:range_of("name1{-1}/name1{1} ",-3)), {4,4, n=2})
  assertEquals(table.pack(seq:range_of("name1{-2}/name1{-1}", 5)), {4,5, n=2})
  assertEquals(table.pack(seq:range_of("name1{-2}/name1{-1}",-2)), {4,5, n=2})
  assertEquals(table.pack(seq:range_of("name1{-1}/name1{1} ", 3)), {2,4, n=2})
  assertEquals(table.pack(seq:range_of("name1{-1}/name1{1} ",-4)), {2,4, n=2})
  assertEquals(table.pack(seq:range_of("name1{-1}/name1{2} ", 3)), {2,5, n=2})
  assertEquals(table.pack(seq:range_of("name1{-1}/name1{2} ",-4)), {2,5, n=2})
  assertEquals(table.pack(seq:range_of("name1[2] /name1{2} ", 3)), {4,5, n=2})
  assertEquals(table.pack(seq:range_of("name1[2] /name1{2} ",-4)), {4,5, n=2})
  assertEquals(table.pack(seq:range_of("name1[-2]/name1{2} ", 3)), {4,5, n=2})
  assertEquals(table.pack(seq:range_of("name1[-2]/name1{2} ",-4)), {4,5, n=2})
  assertEquals(table.pack(seq:range_of("name1{-1}/name1[3] ", 3)), {2,5, n=2})
  assertEquals(table.pack(seq:range_of("name1{-1}/name1[3] ",-4)), {2,5, n=2})
  assertEquals(table.pack(seq:range_of("name1{1} /name1[3] ", 3)), {4,5, n=2})
  assertEquals(table.pack(seq:range_of("name1{1} /name1[3] ",-4)), {4,5, n=2})
end

function TestSequence:testRangeOfStringNegative()
  local seq = getIdxSeq()
  assertEquals(table.pack(seq:range_of("name2    /name1    "   )), {3,2, n=2})
  assertEquals(table.pack(seq:range_of("name1[3] /name1[1] "   )), {5,2, n=2})
  assertEquals(table.pack(seq:range_of("name1[-1]/name1[-3]"   )), {5,2, n=2})
  assertEquals(table.pack(seq:range_of("name1[3] /name1[2] "   )), {5,4, n=2})
  assertEquals(table.pack(seq:range_of("name1[-1]/name1[-2]"   )), {5,4, n=2})
  assertEquals(table.pack(seq:range_of("name1[-1]/name1[1] "   )), {5,2, n=2})
  assertEquals(table.pack(seq:range_of("name1{2} /name1{1} ", 3)), {5,4, n=2})
  assertEquals(table.pack(seq:range_of("name1{2} /name1{1} ",-4)), {5,4, n=2})
  assertEquals(table.pack(seq:range_of("name1{2} /name1{1} ", 4)), {5,4, n=2})
  assertEquals(table.pack(seq:range_of("name1{2} /name1{1} ",-3)), {5,4, n=2})
  assertEquals(table.pack(seq:range_of("name1{-1}/name1{-2}", 5)), {5,4, n=2})
  assertEquals(table.pack(seq:range_of("name1{-1}/name1{-2}",-2)), {5,4, n=2})
  assertEquals(table.pack(seq:range_of("name1{1} /name1{-1}", 3)), {4,2, n=2})
  assertEquals(table.pack(seq:range_of("name1{1} /name1{-1}",-4)), {4,2, n=2})
  assertEquals(table.pack(seq:range_of("name1{2} /name1{-1}", 3)), {5,2, n=2})
  assertEquals(table.pack(seq:range_of("name1{2} /name1{-1}",-4)), {5,2, n=2})
  assertEquals(table.pack(seq:range_of("name1{2} /name1[2] ", 3)), {5,4, n=2})
  assertEquals(table.pack(seq:range_of("name1{2} /name1[2] ",-4)), {5,4, n=2})
  assertEquals(table.pack(seq:range_of("name1{2} /name1[-2]", 3)), {5,4, n=2})
  assertEquals(table.pack(seq:range_of("name1{2} /name1[-2]",-4)), {5,4, n=2})
  assertEquals(table.pack(seq:range_of("name1[3] /name1{-1}", 3)), {5,2, n=2})
  assertEquals(table.pack(seq:range_of("name1[3] /name1{-1}",-4)), {5,2, n=2})
  assertEquals(table.pack(seq:range_of("name1[3] /name1{1} ", 3)), {5,4, n=2})
  assertEquals(table.pack(seq:range_of("name1[3] /name1{1} ",-4)), {5,4, n=2})
end

function TestSequence:testRangeOfStringInvalid()
  local seq      = getIdxSeq()
  local range_of = sequence.range_of
  local msg = {
    "invalid range start",
    "invalid range stop",
    "invalid argument #2 (number, string or element expected)",
  }
  assertErrorMsgContains(msg[3], range_of, seq, "                   "   )
  assertErrorMsgContains(msg[1], range_of, seq, "         /         "   )
  assertErrorMsgContains(msg[2], range_of, seq, "name1    /         "   )
  assertErrorMsgContains(msg[1], range_of, seq, "name100  /name1    "   )
  assertErrorMsgContains(msg[2], range_of, seq, "name1    /name200  "   )
  assertErrorMsgContains(msg[1], range_of, seq, "name100  /name200  "   )
  assertErrorMsgContains(msg[1], range_of, seq, "name1[-4]/name1[3] "   )
  assertErrorMsgContains(msg[2], range_of, seq, "name1[1] /name1[4] "   )
  assertErrorMsgContains(msg[1], range_of, seq, "name1[4] /name1[3] "   )
  assertErrorMsgContains(msg[2], range_of, seq, "name1[1] /name1[-4]"   )
  assertErrorMsgContains(msg[1], range_of, seq, "name1{-2}/name1{1} ", 3)
  assertErrorMsgContains(msg[2], range_of, seq, "name1{-1}/name1{3} ", 3)
  assertErrorMsgContains(msg[1], range_of, seq, "name1{3} /name1{1} ", 3)
  assertErrorMsgContains(msg[2], range_of, seq, "name1{-1}/name1{-3}", 3)
end

function TestSequence:testRangeOfTableIdx()
  local seq = getIdxSeq()
  local range_of = sequence.range_of
  local msg = {
    "invalid argument #2 (range of integers expected)",
  }
  assertEquals(table.pack(seq:range_of({ 1, 1, "idx"})), {1,1, n=2})
  assertEquals(table.pack(seq:range_of({ 1,-1, "idx"})), {1,6, n=2})
  assertEquals(table.pack(seq:range_of({ 2, 2, "idx"})), {2,2, n=2})
  assertEquals(table.pack(seq:range_of({-1, 1, "idx"})), {6,1, n=2})
  assertEquals(table.pack(seq:range_of({-1, 4, "idx"})), {6,4, n=2})
  assertEquals(table.pack(seq:range_of({ 4,-1, "idx"})), {4,6, n=2})
end

function TestSequence:testRangeOfTableNum()
  local seq = getIdxSeq()
  assertEquals(table.pack(seq:range_of({  1, 1  })), {2,2, n=2})
  assertEquals(table.pack(seq:range_of({  1,-1  })), {2,5, n=2})
  assertEquals(table.pack(seq:range_of({  2, 2  })), {3,3, n=2})
  assertEquals(table.pack(seq:range_of({ -1, 1  })), {5,2, n=2})
  assertEquals(table.pack(seq:range_of({ -1, 4  })), {5,5, n=2})
  assertEquals(table.pack(seq:range_of({  4,-1  })), {5,5, n=2})
  assertEquals(table.pack(seq:range_of({1.1,-1.1})), {3,5, n=2})
end

function TestSequence:testRangeOfTableStringNum()
  local seq = getIdxSeq()
  assertEquals(table.pack(seq:range_of({" 1", " 1"})), {2,2, n=2})
  assertEquals(table.pack(seq:range_of({" 1", "-1"})), {2,5, n=2})
  assertEquals(table.pack(seq:range_of({" 2", " 2"})), {3,3, n=2})
  assertEquals(table.pack(seq:range_of({"-1", " 1"})), {5,2, n=2})
  assertEquals(table.pack(seq:range_of({"-1", " 4"})), {5,5, n=2})
  assertEquals(table.pack(seq:range_of({" 4", "-1"})), {5,5, n=2})
  assertEquals(table.pack(seq:range_of({" 1", " 1"})), {2,2, n=2})
  assertEquals(table.pack(seq:range_of({"-1", " 1"})), {5,2, n=2})
  assertEquals(table.pack(seq:range_of({" 2", " 2"})), {3,3, n=2})
  assertEquals(table.pack(seq:range_of({" 1", "-1"})), {2,5, n=2})
  assertEquals(table.pack(seq:range_of({" 4", "-1"})), {5,5, n=2})
  assertEquals(table.pack(seq:range_of({"-1", " 4"})), {5,5, n=2})
end

function TestSequence:testRangeOfTableStringPositiveAbsolute()
  local seq = getIdxSeq()
  assertEquals(table.pack(seq:range_of({"name1    ", "name1    "})), {2,2, n=2})
  assertEquals(table.pack(seq:range_of({"name1    ", "name2    "})), {2,3, n=2})
  assertEquals(table.pack(seq:range_of({"name1[2] ", "name1[2] "})), {4,4, n=2})
  assertEquals(table.pack(seq:range_of({"name1[-2]", "name1[-2]"})), {4,4, n=2})
  assertEquals(table.pack(seq:range_of({"name1[1] ", "name1[3] "})), {2,5, n=2})
  assertEquals(table.pack(seq:range_of({"name1[-3]", "name1[-1]"})), {2,5, n=2})
  assertEquals(table.pack(seq:range_of({"name1[2] ", "name1[3] "})), {4,5, n=2})
  assertEquals(table.pack(seq:range_of({"name1[-2]", "name1[-1]"})), {4,5, n=2})
  assertEquals(table.pack(seq:range_of({"name1[1] ", "name1[-1]"})), {2,5, n=2})
end

function TestSequence:testRangeOfTableStringPositiveRelative()
  local seq   = getIdxSeq()
  local tpack = table.pack
  assertEquals(tpack(seq:range_of({"name1{1} ", "name1{2} "}, 3)), {4,5, n=2})
  assertEquals(tpack(seq:range_of({"name1{1} ", "name1{2} "},-4)), {4,5, n=2})
  assertEquals(tpack(seq:range_of({"name1{1} ", "name1{2} "}, 4)), {4,5, n=2})
  assertEquals(tpack(seq:range_of({"name1{1} ", "name1{2} "},-3)), {4,5, n=2})
  assertEquals(tpack(seq:range_of({"name1{-1}", "name1{1} "}, 4)), {4,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{-1}", "name1{1} "},-3)), {4,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{-2}", "name1{-1}"}, 5)), {4,5, n=2})
  assertEquals(tpack(seq:range_of({"name1{-2}", "name1{-1}"},-2)), {4,5, n=2})
  assertEquals(tpack(seq:range_of({"name1{-1}", "name1{1} "}, 3)), {2,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{-1}", "name1{1} "},-4)), {2,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{-1}", "name1{2} "}, 3)), {2,5, n=2})
  assertEquals(tpack(seq:range_of({"name1{-1}", "name1{2} "},-4)), {2,5, n=2})
  assertEquals(tpack(seq:range_of({"name1[2] ", "name1{2} "}, 3)), {4,5, n=2})
  assertEquals(tpack(seq:range_of({"name1[2] ", "name1{2} "},-4)), {4,5, n=2})
  assertEquals(tpack(seq:range_of({"name1[-2]", "name1{2} "}, 3)), {4,5, n=2})
  assertEquals(tpack(seq:range_of({"name1[-2]", "name1{2} "},-4)), {4,5, n=2})
  assertEquals(tpack(seq:range_of({"name1{-1}", "name1[3] "}, 3)), {2,5, n=2})
  assertEquals(tpack(seq:range_of({"name1{-1}", "name1[3] "},-4)), {2,5, n=2})
  assertEquals(tpack(seq:range_of({"name1{1} ", "name1[3] "}, 3)), {4,5, n=2})
  assertEquals(tpack(seq:range_of({"name1{1} ", "name1[3] "},-4)), {4,5, n=2})
  assertEquals(tpack(seq:range_of({"name1{1} ", "name1{2} ", 3})), {4,5, n=2})
  assertEquals(tpack(seq:range_of({"name1{1} ", "name1{2} ",-4})), {4,5, n=2})
  assertEquals(tpack(seq:range_of({"name1{1} ", "name1{2} ", 4})), {4,5, n=2})
  assertEquals(tpack(seq:range_of({"name1{1} ", "name1{2} ",-3})), {4,5, n=2})
  assertEquals(tpack(seq:range_of({"name1{-1}", "name1{1} ", 4})), {4,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{-1}", "name1{1} ",-3})), {4,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{-2}", "name1{-1}", 5})), {4,5, n=2})
  assertEquals(tpack(seq:range_of({"name1{-2}", "name1{-1}",-2})), {4,5, n=2})
  assertEquals(tpack(seq:range_of({"name1{-1}", "name1{1} ", 3})), {2,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{-1}", "name1{1} ",-4})), {2,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{-1}", "name1{2} ", 3})), {2,5, n=2})
  assertEquals(tpack(seq:range_of({"name1{-1}", "name1{2} ",-4})), {2,5, n=2})
  assertEquals(tpack(seq:range_of({"name1[2] ", "name1{2} ", 3})), {4,5, n=2})
  assertEquals(tpack(seq:range_of({"name1[2] ", "name1{2} ",-4})), {4,5, n=2})
  assertEquals(tpack(seq:range_of({"name1[-2]", "name1{2} ", 3})), {4,5, n=2})
  assertEquals(tpack(seq:range_of({"name1[-2]", "name1{2} ",-4})), {4,5, n=2})
  assertEquals(tpack(seq:range_of({"name1{-1}", "name1[3] ", 3})), {2,5, n=2})
  assertEquals(tpack(seq:range_of({"name1{-1}", "name1[3] ",-4})), {2,5, n=2})
  assertEquals(tpack(seq:range_of({"name1{1} ", "name1[3] ", 3})), {4,5, n=2})
  assertEquals(tpack(seq:range_of({"name1{1} ", "name1[3] ",-4})), {4,5, n=2})
end

function TestSequence:testRangeOfTableStringNegativeAbsolute()
  local seq   = getIdxSeq()
  assertEquals(table.pack(seq:range_of({"name1    ", "name1    "})), {2,2, n=2})
  assertEquals(table.pack(seq:range_of({"name2    ", "name1    "})), {3,2, n=2})
  assertEquals(table.pack(seq:range_of({"name1[2] ", "name1[2] "})), {4,4, n=2})
  assertEquals(table.pack(seq:range_of({"name1[-2]", "name1[-2]"})), {4,4, n=2})
  assertEquals(table.pack(seq:range_of({"name1[3] ", "name1[1] "})), {5,2, n=2})
  assertEquals(table.pack(seq:range_of({"name1[-1]", "name1[-3]"})), {5,2, n=2})
  assertEquals(table.pack(seq:range_of({"name1[3] ", "name1[2] "})), {5,4, n=2})
  assertEquals(table.pack(seq:range_of({"name1[-1]", "name1[-2]"})), {5,4, n=2})
  assertEquals(table.pack(seq:range_of({"name1[-1]", "name1[1] "})), {5,2, n=2})
end

function TestSequence:testRangeOfTableStringNegativeRelative()
  local seq   = getIdxSeq()
  local tpack = table.pack
  assertEquals(tpack(seq:range_of({"name1{2} ", "name1{1} "}, 3)), {5,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{2} ", "name1{1} "},-4)), {5,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{2} ", "name1{1} "}, 4)), {5,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{2} ", "name1{1} "},-3)), {5,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{1} ", "name1{-1}"}, 4)), {4,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{1} ", "name1{-1}"},-3)), {4,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{-1}", "name1{-2}"}, 5)), {5,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{-1}", "name1{-2}"},-2)), {5,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{1} ", "name1{-1}"}, 3)), {4,2, n=2})
  assertEquals(tpack(seq:range_of({"name1{1} ", "name1{-1}"},-4)), {4,2, n=2})
  assertEquals(tpack(seq:range_of({"name1{2} ", "name1{-1}"}, 3)), {5,2, n=2})
  assertEquals(tpack(seq:range_of({"name1{2} ", "name1{-1}"},-4)), {5,2, n=2})
  assertEquals(tpack(seq:range_of({"name1{2} ", "name1[2] "}, 3)), {5,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{2} ", "name1[2] "},-4)), {5,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{2} ", "name1[-2]"}, 3)), {5,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{2} ", "name1[-2]"},-4)), {5,4, n=2})
  assertEquals(tpack(seq:range_of({"name1[3] ", "name1{-1}"}, 3)), {5,2, n=2})
  assertEquals(tpack(seq:range_of({"name1[3] ", "name1{-1}"},-4)), {5,2, n=2})
  assertEquals(tpack(seq:range_of({"name1[3] ", "name1{1} "}, 3)), {5,4, n=2})
  assertEquals(tpack(seq:range_of({"name1[3] ", "name1{1} "},-4)), {5,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{2} ", "name1{1} ", 3})), {5,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{2} ", "name1{1} ",-4})), {5,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{2} ", "name1{1} ", 4})), {5,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{2} ", "name1{1} ",-3})), {5,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{1} ", "name1{-1}", 4})), {4,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{1} ", "name1{-1}",-3})), {4,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{-1}", "name1{-2}", 5})), {5,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{-1}", "name1{-2}",-2})), {5,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{1} ", "name1{-1}", 3})), {4,2, n=2})
  assertEquals(tpack(seq:range_of({"name1{1} ", "name1{-1}",-4})), {4,2, n=2})
  assertEquals(tpack(seq:range_of({"name1{2} ", "name1{-1}", 3})), {5,2, n=2})
  assertEquals(tpack(seq:range_of({"name1{2} ", "name1{-1}",-4})), {5,2, n=2})
  assertEquals(tpack(seq:range_of({"name1{2} ", "name1[2] ", 3})), {5,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{2} ", "name1[2] ",-4})), {5,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{2} ", "name1[-2]", 3})), {5,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{2} ", "name1[-2]",-4})), {5,4, n=2})
  assertEquals(tpack(seq:range_of({"name1[3] ", "name1{-1}", 3})), {5,2, n=2})
  assertEquals(tpack(seq:range_of({"name1[3] ", "name1{-1}",-4})), {5,2, n=2})
  assertEquals(tpack(seq:range_of({"name1[3] ", "name1{1} ", 3})), {5,4, n=2})
  assertEquals(tpack(seq:range_of({"name1[3] ", "name1{1} ",-4})), {5,4, n=2})
end

function TestSequence:testRangeOfTableInvalid()
  local seq      = getIdxSeq()
  local range_of = sequence.range_of
  local msg      = {
    "invalid range start",
    "invalid range stop",
    "invalid argument #2 (number, string or element expected)",
    "invalid argument #2 (range of integers expected)",
  }
  assertErrorMsgContains(msg[1], range_of, seq, { 0         , 2  , "idx" }   )
  assertErrorMsgContains(msg[2], range_of, seq, { 1         , 7  , "idx" }   )
  assertErrorMsgContains(msg[1], range_of, seq, {-100       , 2  , "idx" }   )
  assertErrorMsgContains(msg[2], range_of, seq, { 1         , 100, "idx" }   )
  assertErrorMsgContains(msg[4], range_of, seq, { 1.5       , 2  , "idx" }   )
  assertErrorMsgContains(msg[4], range_of, seq, { 1         , 2.5, "idx" }   )
  assertErrorMsgContains(msg[2], range_of, seq, { 1         , 7          }   )
  assertErrorMsgContains(msg[1], range_of, seq, {-7         , 5          }   )
  assertErrorMsgContains(msg[1], range_of, seq, {-100       , 2          }   )
  assertErrorMsgContains(msg[2], range_of, seq, { 1         , 100        }   )
  assertErrorMsgContains(msg[1], range_of, seq, {"         ", "         "}   )
  assertErrorMsgContains(msg[2], range_of, seq, {"name1    ", "         "}   )
  assertErrorMsgContains(msg[1], range_of, seq, {"name100  ", "name1    "}   )
  assertErrorMsgContains(msg[2], range_of, seq, {"name1    ", "name200  "}   )
  assertErrorMsgContains(msg[1], range_of, seq, {"name100  ", "name200  "}   )
  assertErrorMsgContains(msg[1], range_of, seq, {"name1[-4]", "name1[3] "}   )
  assertErrorMsgContains(msg[2], range_of, seq, {"name1[1] ", "name1[4] "}   )
  assertErrorMsgContains(msg[1], range_of, seq, {"name1[4] ", "name1[3] "}   )
  assertErrorMsgContains(msg[2], range_of, seq, {"name1[1] ", "name1[-4]"}   )
  assertErrorMsgContains(msg[1], range_of, seq, {"name1{-2}", "name1{1} "}, 3)
  assertErrorMsgContains(msg[2], range_of, seq, {"name1{-1}", "name1{3} "}, 3)
  assertErrorMsgContains(msg[1], range_of, seq, {"name1{3} ", "name1{1} "}, 3)
  assertErrorMsgContains(msg[2], range_of, seq, {"name1{-1}", "name1{-3}"}, 3)
  assertErrorMsgContains(msg[1], range_of, seq, {"name1{-2}", "name1{1} ", 3})
  assertErrorMsgContains(msg[2], range_of, seq, {"name1{-1}", "name1{3} ", 3})
  assertErrorMsgContains(msg[1], range_of, seq, {"name1{3} ", "name1{1} ", 3})
  assertErrorMsgContains(msg[2], range_of, seq, {"name1{-1}", "name1{-3}", 3})
end

function TestSequence:testRangeOfRange()
  local seq = getIdxSeq()
  assertEquals(table.pack(seq:range_of( 1 ..  4 )), {2,5, n=2})
  assertEquals(table.pack(seq:range_of(-4 .. -1 )), {2,5, n=2})
  assertEquals(table.pack(seq:range_of( 2 ..  3 )), {3,4, n=2})
  assertEquals(table.pack(seq:range_of( 4 ..  1 )), {5,2, n=2})
  assertEquals(table.pack(seq:range_of(-1 .. -4 )), {5,2, n=2})
  assertEquals(table.pack(seq:range_of( 3 ..  2 )), {4,3, n=2})
end

function TestSequence:testLengthOf0TrnPositive()
  local seq       = getIdxSeq()
  local length_of = sequence.length_of
  local msg       = {
    "invalid range start",
    "invalid range stop",
  }
  assertEquals(seq:length_of(                               ), 6)
  assertEquals(seq:length_of( "1         /  4       "       ), 4)
  assertEquals(seq:length_of( "name1[1]  /  name1[3]"       ), 4)
  assertEquals(seq:length_of({"name1[1] ", "name1[3]"   }   ), 4)
  assertEquals(seq:length_of({"name1{-1}", "name1{2}", 3}   ), 4)
  assertEquals(seq:length_of({2          , 3            }   ), 2)
  assertEquals(seq:length_of( nil                        , 0), 6)
  assertEquals(seq:length_of( "1         /  4       "    , 0), 4)
  assertEquals(seq:length_of( "name1[1]  /  name1[3]"    , 0), 4)
  assertEquals(seq:length_of({"name1[1] ", "name1[3]"   }, 0), 4)
  assertEquals(seq:length_of({"name1{-1}", "name1{2}", 3}, 0), 4)
  assertEquals(seq:length_of({2          , 3            }, 0), 2)
  assertErrorMsgContains(msg[1], length_of, seq,  "name1[-4] / name1[3] "    )
  assertErrorMsgContains(msg[2], length_of, seq, {"name1{-1}","name1{-3}", 3})
end

function TestSequence:testLengthOf0TrnNegative()
  local seq       = getIdxSeq()
  local length_of = sequence.length_of
  local msg       = {
    "invalid range start",
    "invalid range stop",
  }
  assertEquals(seq:length_of( "4        /  1       "        ), 4)
  assertEquals(seq:length_of( "name1[3] /  name1[1]"        ), 4)
  assertEquals(seq:length_of({3         , 2             }   ), 6)
  assertEquals(seq:length_of({"name1[3]", "name1[1] "   }   ), 4)
  assertEquals(seq:length_of({"name1{2}", "name1{-1}", 3}   ), 4)
  assertEquals(seq:length_of( "4        /  1        "    , 0), 4)
  assertEquals(seq:length_of( "name1[3] /  name1[1] "    , 0), 4)
  assertEquals(seq:length_of({"name1[3]", "name1[1] "   }, 0), 4)
  assertEquals(seq:length_of({"name1{2}", "name1{-1}", 3}, 0), 4)
  assertEquals(seq:length_of({3          , 2            }, 0), 6)
  assertErrorMsgContains(msg[1], length_of, seq, {"name1{-3}","name1{-1}", 3})
  assertErrorMsgContains(msg[2], length_of, seq,  "name1[3] / name1[-4] "    )
end

function TestSequence:testLengthOfNTrnPositive()
  local seq = getIdxSeq()
  assertEquals(seq:length_of( nil                        , 5), 36)
  assertEquals(seq:length_of( "1         /  4       "    , 5), 34)
  assertEquals(seq:length_of( "name1[1]  /  name1[3]"    , 5), 34)
  assertEquals(seq:length_of({"name1[1] ", "name1[3]"   }, 5), 34)
  assertEquals(seq:length_of({"name1{-1}", "name1{2}", 3}, 5), 34)
  assertEquals(seq:length_of({2          , 3            }, 5), 32)
end

function TestSequence:testLengthOfNTrnNegative()
  local seq = getIdxSeq()
  assertEquals(seq:length_of( "4        /  1        "    , 5), 34)
  assertEquals(seq:length_of( "name1[3] /  name1[1] "    , 5), 34)
  assertEquals(seq:length_of({"name1[3]", "name1[1] "   }, 5), 34)
  assertEquals(seq:length_of({"name1{2}", "name1{-1}", 3}, 5), 34)
  assertEquals(seq:length_of({3         , 2             }, 5), 36)
end

function TestSequence:testIterOne()
  local mk  = marker { at = 1 }
  local seq = sequence "seq" { l=2, refer="entry", mk }
  local i   = 1
  for j,elm,s in seq:iter() do
    assertIs(elm, seq[j])
    assertEquals(i, j)
    assertEquals(s, seq:spos(j))
    i = i + 1
  end
  assertEquals(i, 4)
end

function TestSequence:testIter()
  local seq = getIdxSeq()
  local i = 1
  for j,elm,s in seq:iter() do
    assertIs(elm, seq[j])
    assertEquals(i, j)
    assertEquals(s, seq:spos(j))
    i = i + 1
  end
  assertEquals(i, 7)
end

function TestSequence:testIterRangeTableNum()
  local seq, i = getIdxSeq()
  -- first/last iterator
  i = 1
  for j,elm,s in seq:iter{0,-0.1} do
    assertIs    (elm, seq[j]     )
    assertEquals(i  , j          )
    assertEquals(s  , seq:spos(j))
    i = i + 1
  end
  assertEquals(i, 7)

  -- 2nd/3rd iterator
  i = 2
  for j,elm,s in seq:iter{1,-4} do
    assertIs    (elm, seq[j]       )
    assertEquals(i  , j            )
    assertEquals(s  , seq:spos(j)-1)
    i = i + 1
  end
  assertEquals(i, 3)
end

function TestSequence:testIterRangeStringNum()
  local seq, i = getIdxSeq()
  -- first/last iterator
  i = 1
  for j,elm,s in seq:iter("0/-0.1") do
    assertIs    (elm, seq[j]     )
    assertEquals(j  , i          )
    assertEquals(s  , seq:spos(j))
    i = i + 1
  end
  assertEquals(i, 7)

  -- 2nd/3rd iterator
  i = 2
  for j,elm,s in seq:iter("1/-4") do
    assertIs    (elm, seq[j]       )
    assertEquals(j  , i            )
    assertEquals(s  , seq:spos(j)-1)
    i = i + 1
  end
  assertEquals(i, 3)
end

function TestSequence:testIterRangeRange()
  local seq, i = getIdxSeq()
  -- first/last iterator
  i = 1
  for j,elm,s in seq:iter(0..-0.1) do
    assertIs    (elm, seq[j]     )
    assertEquals(j  , i          )
    assertEquals(s  , seq:spos(j))
    i = i + 1
  end
  assertEquals(i, 7)

  -- 2nd/3rd iterator
  i = 2
  for j,elm,s in seq:iter(1..-4) do
    assertIs    (elm, seq[j]       )
    assertEquals(j  , i            )
    assertEquals(s  , seq:spos(j)-1)
    i = i + 1
  end
  assertEquals(i, 3)
end

function TestSequence:testIterRangeName()
  local seq, i = getIdxSeq()

  i = 2
  for j,elm,s in seq:iter("name1[1]/name1[3]") do
    assertIs    (elm, seq[j]       )
    assertEquals(j  , i            )
    assertEquals(s  , seq:spos(j)-1)
    i = i + 1
  end
  assertEquals(i, 6)

  i = 3
  for j,elm,s in seq:iter{"name2", "name1{1}", 3} do
    assertIs    (elm, seq[j]       )
    assertEquals(j  , i            )
    assertEquals(s  , seq:spos(j)-2)
    i = i + 1
  end
  assertEquals(i, 5)
end

function TestSequence:testIterRangeSingle()
  local seq, i = getIdxSeq(), 3
  for j,elm,s in seq:iter{2,2} do
    assertIs    (elm, seq[j]       )
    assertEquals(j  , i            )
    assertEquals(s  , seq:spos(j)-2)
    i = i + 1
  end
  assertEquals(i, 4)
end

function TestSequence:testIterCycle()
  local seq, i = getIdxSeq(), 1
  local idx  = {3, 4, 5, 6, 1, 2}
  local spos = {0, 1, 2, 3, 3, 4}
  for j,elm,s in seq:iter{2,1} do
    assertIs    (elm   , seq[j] )
    assertEquals(idx[i], j      )
    assertEquals(s     , spos[i])
    i = i + 1
  end
  assertEquals(i, 7)
end

function TestSequence:testIterNturn()
  local seq, i, spos = getIdxSeq()

  spos, i = {0, 1, 2, 3, 4, 5, 5, 6, 7, 8, 9, 10, 10, 11, 12, 13, 14, 15}, 0
  for j,elm,s in seq:iter(nil,2) do
    assertIs    (elm    , seq[j]   )
    assertEquals(i%6 + 1, j        )
    assertEquals(s      , spos[i+1])
    i = i + 1
  end
  assertEquals(i, 18)

  spos, i = {0, 1, 2, 2, 3, 4, 5, 6, 7, 7, 8, 9, 10, 11, 12, 12, 13, 14}, 3
  for j,elm,s in seq:iter({3,2},2) do
    assertIs    (elm    , seq[j]   )
    assertEquals(i%6 + 1, j        )
    assertEquals(s      , spos[i-2])
    i = i + 1
  end
  assertEquals(i, 21)
end

function TestSequence:testIterDir()
  local seq, i, spos = getIdxSeq()
  local idx = {3, 2, 1, 6, 5, 4}
  -- last/first iterator decreasing
  i, spos = 6, 0
  for j,elm,s in seq:iter(nil,nil,-1) do
    assertIs    (elm, seq[j])
    assertEquals(j  , i     )
    assertEquals(s  , spos  )
    spos, i = spos-1, i-1
  end
  assertEquals(i, 0)

  -- 2nd/3rd iterator decreasing
  spos, i = {0, -1, -2, -2, -3, -4}, 1
  for j,elm,s in seq:iter({2, 3}, nil, -1) do
    assertIs    (elm   , seq[j] )
    assertEquals(idx[i], j      )
    assertEquals(s     , spos[i])
    i = i + 1
  end
  assertEquals(i, 7)
end

function TestSequence:testCycleNum()
  local seq = getIdxSeq()
  local idx = {3, 4, 5, 6, 1, 2}
  local i
  i = 1
  seq:cycle(2)
  for j,elm in seq:iter() do
    assertIs    (elm   , seq[j])
    assertEquals(idx[i], j     )
    i = i + 1
  end
  assertEquals(i, 7)

  i = 1
  seq:cycle(-3)
  for j,elm in seq:iter() do
    assertIs    (elm   , seq[j])
    assertEquals(idx[i], j     )
    i = i + 1
  end
  assertEquals(i, 7)
end

function TestSequence:testCycleName()
  local seq  = getIdxSeq()
  local idx1 = { 3, 4, 5, 6, 1, 2 }
  local idx2 = { 4, 5, 6, 1, 2, 3 }
  local i
  i = 1
  seq:cycle("name2")
  for j,elm in seq:iter() do
    assertIs    (elm    , seq[j])
    assertEquals(idx1[i], j     )
    i = i + 1
  end
  assertEquals(i, 7)

  i = 1
  seq:cycle("name1[2]")
  for j,elm in seq:iter() do
    assertIs    (elm    , seq[j])
    assertEquals(idx2[i], j     )
    i = i + 1
  end
  assertEquals(i, 7)
end

function TestSequence:testCycleInvalid()
  local seq = getIdxSeq()
  local msg = {
    "invalid argument #2 (reference expected)",
  }
  assertErrorMsgContains(msg[1], sequence.cycle, seq, 5.1   )
  assertErrorMsgContains(msg[1], sequence.cycle, seq,-5.1   )
  assertErrorMsgContains(msg[1], sequence.cycle, seq, "none")
end

function TestSequence:testForeach()
  local seq = getIdxSeq()
  local i   = 1
  local act = \elm,idx =>
    assertIs    (elm, seq[idx])
    assertEquals(idx, i       )
    i = i + 1
  end
  seq:foreach(act)
  assertEquals(i, 7)
end

function TestSequence:testForeachNot()
  local seq = getIdxSeq()
  local i   = 1
  local act = \=> i=i+1 end
  seq:foreach(act, nil, nil, true)
  assertEquals(i, 1)
end

function TestSequence:testForeachRangeNum()
  local seq = getIdxSeq()
  local i   = 1
  local act = \elm,idx =>
    assertIs    (elm, seq[idx])
    assertEquals(idx, i       )
    i = i + 1
  end

  i = 3
  seq:foreach(act, { 2, 4})
  assertEquals(i, 6)

  i = 3
  seq:foreach(act, {-3,-1})
  assertEquals(i, 6)

  i = 3
  seq:foreach(act, { 2, 4}, nil, nil, true)
  assertEquals(i, 6)

  i = 3
  seq:foreach(act, {-3,-1}, nil, nil, true)
  assertEquals(i, 6)
end

function TestSequence:testForeachRangeName()
  local seq = getIdxSeq()
  local i   = 1
  local act = \elm,idx =>
    assertIs    (elm, seq[idx])
    assertEquals(idx, i       )
    i = i + 1
  end

  i = 3
  seq:foreach(act, {"name2", "name1[3]"})
  assertEquals(i, 6)

  i = 3
  seq:foreach(act, "name2/name1[3]")
  assertEquals(i, 6)

  i = 3
  seq:foreach(act, {"name2", "name1{2}", 3})
  assertEquals(i, 6)
end

function TestSequence:testForeachFlags()
  local seq     = getIdxSeq()
  local flg, i  = 31, 2
  local act     = \elm,idx =>
    assertIs    (elm, seq[idx])
    assertEquals(idx, i       )
    i = i + 1
  end

  for i=2,4 do seq[i]:select(flg) end
  seq:foreach(act, nil, flg)
  assertEquals(i, 5)
end

function TestSequence:testForeachPattern()
  local seq  = getIdxSeq()
  local idxs = { 2, 4, 5 }
  local i    = 1
  local act  = \elm,idx =>
    assertIs    (elm, seq[idxs[i]])
    assertEquals(idx, idxs[i]     )
    i = i + 1
  end
  seq:foreach(act, nil, "name1")
  assertEquals(i, 4)
end

function TestSequence:testForeachClass()
  local seq = getIdxSeq()
  local i   = 3
  local act = \elm,idx =>
    assertIs    (elm, seq[idx])
    assertEquals(idx, i       )
    i = i + 1
  end

  seq:foreach(act, nil, quadrupole)
  assertEquals(i, 5)
end

function TestSequence:testForeachSelect()
  local seq = getIdxSeq()
  local i   = 1
  local act = \elm,idx =>
    assertIs    (elm, seq[idx])
    assertEquals(idx, i       )
    i = i + 1
  end

  -- select using i
  i = 3
  seq:foreach(act, {2, 4}, \e,i -> i < 5)
  assertEquals(i, 5)

  -- select using e
  i = 3
  seq[5].var = true
  seq:foreach(act, {2, 4}, \e,i -> not e.var)
  assertEquals(i, 5)
end

function TestSequence:testForeachTable()
  local seq = getIdxSeq()
  local i   = 1
  local act = \elm,idx =>
    assertIs    (elm, seq[idx])
    assertEquals(idx, i       )
    i = i + 1
  end
  seq:foreach{action=act}
  assertEquals(i, 7)
end

function TestSequence:testForeachTableNot()
  local seq = getIdxSeq()
  local i   = 1
  local act = \=> i=i+1 end
  seq:foreach{action=act, default=true  }
  seq:foreach{action=act, default="none"}
  assertEquals(i, 1)
end

function TestSequence:testForeachTableRangeNum()
  local seq = getIdxSeq()
  local i   = 1
  local act = \elm,idx =>
    assertIs    (elm, seq[idx])
    assertEquals(idx, i       )
    i = i + 1
  end

  i = 3
  seq:foreach{action=act, range={ 2, 4}}
  assertEquals(i, 6)

  i = 3
  seq:foreach{action=act, range={-3,-1}}
  assertEquals(i, 6)

  i = 3
  seq:foreach{action=act, range={ 2, 4}, default=true}
  assertEquals(i, 6)

  i = 3
  seq:foreach{action=act, range={-3,-1}, default=true}
  assertEquals(i, 6)

  i = 3
  seq:foreach{action=act, range={ 2, 4}, default="none"}
  assertEquals(i, 6)

  i = 3
  seq:foreach{action=act, range={-3,-1}, default="none"}
  assertEquals(i, 6)
end

function TestSequence:testForeachTableRangeName()
  local seq = getIdxSeq()
  local i   = 1
  local act = \elm,idx =>
    assertIs    (elm, seq[idx])
    assertEquals(idx, i       )
    i = i + 1
  end

  i = 3
  seq:foreach{action=act, range={"name2", "name1[3]"}}
  assertEquals(i, 6)

  i = 3
  seq:foreach{action=act, range="name2/name1[3]"}
  assertEquals(i, 6)

  i = 3
  seq:foreach{action=act, range={"name2", "name1{2}", 3}}
  assertEquals(i, 6)
end

function TestSequence:testForeachTableSelect()
  local seq = getIdxSeq()
  local i   = 1
  local act = \elm,idx =>
    assertIs    (elm, seq[idx])
    assertEquals(idx, i       )
    i = i + 1
  end

  -- select using i
  i = 3
  seq:foreach{action=act, range={2, 4}, select=\e,i -> i < 5}
  assertEquals(i, 5)

  -- select using e
  i = 3
  seq[5].var = true
  seq:foreach{action=act, range={2, 4}, select=\e,i -> not e.var}
  assertEquals(i, 5)
end

function TestSequence:testForeachTableClass()
  local seq = getIdxSeq()
  local i   = 3
  local act = \elm,idx =>
    assertIs    (elm, seq[idx])
    assertEquals(idx, i       )
    i = i + 1
  end

  seq:foreach{action=act, class=quadrupole}
  assertEquals(i, 5)
end

function TestSequence:testForeachTablePattern()
  local seq  = getIdxSeq()
  local idxs = { 2, 4, 5 }
  local i    = 1
  local act  = \elm,idx =>
    assertIs    (elm, seq[idxs[i]])
    assertEquals(idx, idxs[i]     )
    i = i + 1
  end
  seq:foreach{action=act, pattern="name1"}
  assertEquals(i, 4)
end

function TestSequence:testForeachTableFlags()
  local seq     = getIdxSeq()
  local flg, i  = 31, 2
  local act     = \elm,idx =>
    assertIs    (elm, seq[idx])
    assertEquals(idx, i       )
    i = i + 1
  end

  for i=2,4 do seq[i]:select(flg) end
  seq:foreach{action=act, flag=flg}
  assertEquals(i, 5)
end

function TestSequence:testSelect()
  local seq = getIdxSeq()
  local flg = 31
  local assertSelect = \seq,min,max =>
    for i=1,#seq do
      if min <= i and i < max
      then assertTrue (seq[i]:is_selected(flg))
      else assertFalse(seq[i]:is_selected(flg))
      end
    end
    for i=1,#seq do seq[i]:deselect(flg) end
  end

  assertSelect(seq:select(flg)                                  , 1, 7)
  assertSelect(seq:select(flg, nil  , nil, true)                , 1, 1)
  assertSelect(seq:select(flg, {2,4})                           , 3, 6)
  assertSelect(seq:select(flg, {2,4}, nil, true)                , 3, 6)
  assertSelect(seq:select(flg, nil  , \e,i -> 2 < i and i < 4)  , 3, 4)
  assertSelect(seq:select(flg, {2,4}, \e,i -> 1 < i and i < 4)  , 3, 4)
  assertSelect(seq:select(flg, nil  , \e,i -> e.at and e.at >=4), 5, 6)
  assertSelect(seq:select(flg, nil, quadrupole)                 , 3, 5)

  local _flg = 30
  seq[3]:select(_flg); seq[4]:select(_flg)
  assertSelect(seq:select(flg, nil, _flg), 3, 5)
end

function TestSequence:testSelectTable()
  local seq = getIdxSeq()
  local flg = 31
  local assertSelect = \seq,min,max =>
    for i=1,#seq do
      if min <= i and i < max
      then assertTrue (seq[i]:is_selected(flg))
      else assertFalse(seq[i]:is_selected(flg))
      end
    end
    for i=1,#seq do seq[i]:deselect(flg) end
  end

  assertSelect(seq:select(flg, {})                                      , 1, 7)
  assertSelect(seq:select(flg, {default=true})                          , 1, 1)
  assertSelect(seq:select(flg, {default="none"})                        , 1, 1)
  assertSelect(seq:select(flg, {range={2,4} })                          , 3, 6)
  assertSelect(seq:select(flg, {range={2,4}, default=true })            , 3, 6)
  assertSelect(seq:select(flg, {range={2,4}, default="none" })          , 3, 6)
  assertSelect(seq:select(flg, {select=\e,i -> 2 < i and i < 4 })       , 3, 4)
  assertSelect(seq:select(flg, {range={2,4}, select=\e,i ->1<i and i<4}), 3, 4)
  assertSelect(seq:select(flg, {select=\e,i -> e.at and e.at >=4 })     , 5, 6)
  assertSelect(seq:select(flg, {class=quadrupole})                      , 3, 5)

  local _flg = 30
  seq[3]:select(_flg); seq[4]:select(_flg)
  assertSelect(seq:select(flg, {flag=_flg}), 3, 5)
end

function TestSequence:testSelectPattern()
  local seq  = getIdxSeq()
  local test = { false, true, false, true, true, false }
  local flg  = 31
  local assertSelect = \seq =>
    for i=1,#seq do
      if test[i]
      then assertTrue (seq[i]:is_selected(flg))
      else assertFalse(seq[i]:is_selected(flg))
      end
    end
    for i=1,#seq do seq[i]:deselect(flg) end
  end

  assertSelect(seq:select(flg, {pattern = "name1"}))
  assertSelect(seq:select(flg, nil, "name1"))
end

function TestSequence:testSelectDefaultFlag()
  local seq = getIdxSeq()
  local assertSelect = \seq,min,max =>
    for i=1,#seq do
      if min <= i and i < max
      then assertTrue (seq[i]:is_selected())
      else assertFalse(seq[i]:is_selected())
      end
    end
    for i=1,#seq do seq[i]:deselect() end
  end

  assertSelect(seq:select(nil,  {2,4},         "name1"), 4, 6)
  assertSelect(seq:select{range={2,4}, pattern="name1"}, 4, 6)
end

function TestSequence:testDeselect()
  local seq = getIdxSeq()
  local flg = 31
  local assertDeselect = \seq,min,max =>
    for i=1,#seq do
      if min <= i and i < max
      then assertFalse(seq[i]:is_selected(flg))
      else assertTrue (seq[i]:is_selected(flg))
      end
    end
    for i=1,#seq do seq[i]:select(flg) end
  end

  for i=1,#seq do seq[i]:select(flg) end
  assertDeselect(seq:deselect(flg)                                  , 1, 7)
  assertDeselect(seq:deselect(flg, nil  , nil, true)                , 1, 1)
  assertDeselect(seq:deselect(flg, {2,4})                           , 3, 6)
  assertDeselect(seq:deselect(flg, {2,4}, nil, true)                , 3, 6)
  assertDeselect(seq:deselect(flg, nil  , \e,i -> 2 < i and i < 4)  , 3, 4)
  assertDeselect(seq:deselect(flg, {2,4}, \e,i -> 1 < i and i < 4)  , 3, 4)
  assertDeselect(seq:deselect(flg, nil  , \e,i -> e.at and e.at >=4), 5, 6)
  assertDeselect(seq:deselect(flg, nil, quadrupole)                 , 3, 5)

  local _flg = 30
  seq[3]:select(_flg); seq[4]:select(_flg)
  assertDeselect(seq:deselect(flg, nil, _flg), 3, 5)
end

function TestSequence:testDeselectTable()
  local seq = getIdxSeq()
  local flg = 31
  local assertDeselect = \seq,min,max =>
    for i=1,#seq do
      if min <= i and i < max
      then assertFalse(seq[i]:is_selected(flg))
      else assertTrue (seq[i]:is_selected(flg))
      end
    end
    for i=1,#seq do seq[i]:select(flg) end
  end

  for i=1,#seq do seq[i]:select(flg) end
  assertDeselect(seq:deselect(flg, {})                                      , 1, 7)
  assertDeselect(seq:deselect(flg, {default=true})                          , 1, 1)
  assertDeselect(seq:deselect(flg, {default="none"})                        , 1, 1)
  assertDeselect(seq:deselect(flg, {range={2,4} })                          , 3, 6)
  assertDeselect(seq:deselect(flg, {range={2,4}, default=true })            , 3, 6)
  assertDeselect(seq:deselect(flg, {range={2,4}, default="none" })          , 3, 6)
  assertDeselect(seq:deselect(flg, {select=\e,i -> 2 < i and i < 4 })       , 3, 4)
  assertDeselect(seq:deselect(flg, {range={2,4}, select=\e,i ->1<i and i<4}), 3, 4)
  assertDeselect(seq:deselect(flg, {select=\e,i -> e.at and e.at >=4 })     , 5, 6)
  assertDeselect(seq:deselect(flg, {class=quadrupole})                      , 3, 5)

  local _flg = 30
  seq[3]:select(_flg); seq[4]:select(_flg)
  assertDeselect(seq:deselect(flg, {flag=_flg}), 3, 5)
end

function TestSequence:testDeselectPattern()
  local seq  = getIdxSeq()
  local test = { false, true, false, true, true, false }
  local flg  = 31
  local assertDeselect = \seq =>
    for i=1,#seq do
      if test[i]
      then assertFalse(seq[i]:is_selected(flg))
      else assertTrue (seq[i]:is_selected(flg))
      end
    end
    for i=1,#seq do seq[i]:select(flg) end
  end

  for i=1,#seq do seq[i]:select(flg) end
  assertDeselect(seq:deselect(flg, {pattern = "name1"}))
  assertDeselect(seq:deselect(flg, nil, "name1"))
end

function TestSequence:testDeselectDefaultFlag()
  local seq = getIdxSeq()
  local assertDeselect = \seq,min,max =>
    for i=1,#seq do
      if min <= i and i < max
      then assertFalse(seq[i]:is_selected())
      else assertTrue (seq[i]:is_selected())
      end
    end
    for i=1,#seq do seq[i]:select() end
  end

  for i=1,#seq do seq[i]:select() end
  assertDeselect(seq:deselect(nil,  {2,4},         "name1"), 4, 6)
  assertDeselect(seq:deselect{range={2,4}, pattern="name1"}, 4, 6)
end

function TestSequence:testFilter()
  local seq = getIdxSeq()
  local assertFilter = \idx,min,max =>
    local j = 1
    for i=min,max-1 do
      assertEquals(idx[j], i)
      j = j + 1
    end
  end

  assertFilter(seq:filter()                                , 1, 7)
  assertFilter(seq:filter(nil  , nil, true)                , 1, 1)
  assertFilter(seq:filter({2,4})                           , 3, 6)
  assertFilter(seq:filter({2,4}, nil, true)                , 3, 6)
  assertFilter(seq:filter(nil  , \e,i -> 2 < i and i < 4)  , 3, 4)
  assertFilter(seq:filter({2,4}, \e,i -> 1 < i and i < 4)  , 3, 4)
  assertFilter(seq:filter(nil  , \e,i -> e.at and e.at >=4), 5, 6)
  assertFilter(seq:filter(nil, quadrupole)                 , 3, 5)

  local flg = 31
  seq[3]:select(flg); seq[4]:select(flg)
  assertFilter(seq:filter(nil, flg), 3, 5)
end

function TestSequence:testFilterTable()
  local seq = getIdxSeq()
  local assertFilter = \idx,min,max =>
    local j = 1
    for i=min,max-1 do
      assertEquals(idx[j], i)
      j = j + 1
    end
  end

  assertFilter(seq:filter({})                                      , 1, 7)
  assertFilter(seq:filter({default=true})                          , 1, 1)
  assertFilter(seq:filter({default="none"})                        , 1, 1)
  assertFilter(seq:filter({range={2,4} })                          , 3, 6)
  assertFilter(seq:filter({range={2,4}, default=true })            , 3, 6)
  assertFilter(seq:filter({range={2,4}, default="none" })          , 3, 6)
  assertFilter(seq:filter({select=\e,i -> 2 < i and i < 4 })       , 3, 4)
  assertFilter(seq:filter({range={2,4}, select=\e,i ->1<i and i<4}), 3, 4)
  assertFilter(seq:filter({select=\e,i -> e.at and e.at >=4 })     , 5, 6)
  assertFilter(seq:filter({class=quadrupole})                      , 3, 5)

  local flg = 31
  seq[3]:select(flg); seq[4]:select(flg)
  assertFilter(seq:filter{flag=flg}, 3, 5)
end

function TestSequence:testFilterPattern()
  local seq  = getIdxSeq()
  local test = { 2, 4, 5 }
  local assertFilter = \idx =>
    for i,v in ipairs(test) do
      assertEquals(idx[i], v)
    end
  end

  assertFilter(seq:filter{pattern = "name1"})
  assertFilter(seq:filter(nil,      "name1"))
end

function TestSequence:testCopy()
  local seq = getIdxSeq()
  local cpy = seq:copy()
  assertEquals(#cpy, #seq)
  for i=1,6 do
    assertElem(cpy[i], seq[i])
  end
  assertTrue(cpy:is_owner())
end

function TestSequence:testCopyView()
  local seq  = getIdxSeq()
  local view = seq "view" { var1=42, var2="test", var3=true, var4=false }
  local cpy  = view:copy()
  assertEquals(cpy.var1, 42    )
  assertEquals(cpy.var2, "test")
  assertEquals(cpy.var3, true  )
  assertEquals(cpy.var4, false )
  for i=1,6 do
    assertElem(cpy[i], seq[i])
  end
  assertTrue(cpy:is_view())
end

function TestSequence:testCopyViewName()
  local seq  = getIdxSeq()
  local cpy1 = seq:copy()
  local cpy2 = seq:copy("seq2")
  assertEquals(cpy1.name, seq.name)
  assertEquals(cpy2.name, "seq2")
end

function TestSequence:testCopyViewOwner()
  local seq  = getIdxSeq()
  local view = seq "view" { }
  local cpy1 = view:copy()
  local cpy2 = view:copy(nil, true)
  local cpy3 = view:copy(true)      -- shift right
  for _,cpy in ipairs{cpy1, cpy2, cpy3} do
    assertEquals(#cpy, #seq)
    for i=1,4 do
      assertElem(cpy[i], seq[i])
    end
  end
  assertTrue(cpy1:is_view())
  assertTrue(cpy2:is_owner())
  assertTrue(cpy3:is_owner())
end

function TestSequence:testCopyDict()
  local seq = getIdxSeq()
  local cpy = seq:copy()
  cpy:check_index()
  assertEquals(cpy:index_of("name1")   , seq:index_of("name1")   )
  assertEquals(cpy:index_of("name1[3]"), seq:index_of("name1[3]"))
end

function TestSequence:testRemoveNothing()
  local seq = getIdxSeq()
  seq:remove()
  assertEquals(#seq, 6)
end

function TestSequence:testRemoveInt()
  local seq = getIdxSeq()
  local ref = getIdxSeq()
  seq:remove(2)
  seq:check_index()
  assertElem(seq[1], ref[1])
  for i=2,5 do assertElem(seq[i], ref[i+1]) end
  assertEquals(#seq, 5)
end

function TestSequence:testRemoveRange()
  local seq = getIdxSeq()
  local ref = getIdxSeq()
  local idx = { 1, 2, 5, 6 }
  seq:remove({2,3})
  seq:check_index()
  for i=1,#seq do
    assertElem(seq[i], ref[idx[i]])
  end
  assertEquals(#seq, 4)
end

function TestSequence:testRemoveSelect()
  local seq = getIdxSeq()
  local ref = getIdxSeq()
  local idx = { 1, 2, 5, 6 }

  seq:remove(nil, \r,i -> 2 < i and i < 5)
  seq:check_index()
  for i=1,#seq do
    assertElem(seq[i], ref[idx[i]])
  end
  assertEquals(#seq, 4)
end

function TestSequence:testRemoveMarker()
  local seq = getIdxSeq()
  local msg = {
    "invalid range, $start marker selected",
    "invalid range, $end marker selected",
  }

  assertErrorMsgContains(msg[1], seq.remove, seq, 1                    )
  assertErrorMsgContains(msg[2], seq.remove, seq, 6                    )
  assertErrorMsgContains(msg[1], seq.remove, seq, {0, 4}               )
  assertErrorMsgContains(msg[2], seq.remove, seq, {2, 5}               )
  assertErrorMsgContains(msg[1], seq.remove, seq, nil   , \r,i -> i < 3)
  assertErrorMsgContains(msg[2], seq.remove, seq, nil   , \r,i -> i > 3)
  seq:check_index()
  assertEquals(#seq, 6)
end

function TestSequence:testFlags()
  local clr, set = Object.clear_flags, Object.set_flags
  local seq = getIdxSeq()
  for i=1,#seq do clr(seq[i],-1);      set(seq[i], i*4 ) end; seq:save_flags()
  for i=1,#seq do clr(seq[i],-1);      set(seq[i], i*8 ) end; seq:save_flags()
  for i=1,#seq do clr(seq[i],-1);      set(seq[i], i*16) end; seq:save_flags()
  for i=1,#seq do clr(seq[i],-1);      set(seq[i], i*32) end
  for i=1,#seq do assertEquals(seq[i]:get_flags(), i*32) end; seq:restore_flags()
  for i=1,#seq do assertEquals(seq[i]:get_flags(), i*16) end
  seq:drop_flags(); seq:restore_flags()
  for i=1,#seq do assertEquals(seq[i]:get_flags(), i*4 ) end
end

function TestSequence:testFlagsInvalid()
  local seq = getIdxSeq()
  local msg = {
    "saved flags not found",
  }
  assertErrorMsgContains(msg[1], sequence.drop_flags   , seq)
  assertErrorMsgContains(msg[1], sequence.restore_flags, seq)
  seq:save_flags(); seq:drop_flags()
  assertErrorMsgContains(msg[1], sequence.drop_flags   , seq)
  assertErrorMsgContains(msg[1], sequence.restore_flags, seq)
end

-------------------------------------------------------------------------------o

function TestSequence:testInstallSingleEmpty()
  local seq = sequence "seq" { l = 10, owner = true }
  local df  = drift    "df"  { l = 1 , at = 1, from = "prev" }
  seq:install(df)
  assertEquals(#seq, 3)
  assertEquals(seq:spos(2), 1)
end

function TestSequence:testInstallSingle()
  local seq = sequence "seq" { drift "d1" { at = 1 }, l = 10 }
  local df  = drift    "d2"  { l = 1 , at = -1, from = "next" }
  seq:install(df)
  assertEquals(#seq, 4)
  assertEquals(seq:spos(3), 9)
end

function TestSequence:testInstallMulti()
  local seq  = sequence "seq" { l = 10, owner = true }
  local line = drift "df" { } * 2
  local tbl  = {
    drift "df2" { l = 1 , at = -3, from = "$end" },
    drift "df3" { l = 1 , at = -1, from = "$end" },
    drift "df4" { at = 10 },
  }
  seq:install(line)
  seq:install(tbl)
  local spos = { 0       , 0   , 0   , 7    , 9    , 10   , 10     }
  local name = { "$start", "df", "df", "df2", "df3", "df4", "$end" }
  for i=1,#seq do
    assertEquals(seq[i].name, name[i])
    assertEquals(seq:spos(i), spos[i])
  end
  assertEquals(#seq, 7)
end

-- end ------------------------------------------------------------------------o
