--[=[
 o-----------------------------------------------------------------------------o
 |
 | Sequence tests
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 |          A. Bloch,  aurelien.bloch at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide regression test suites for the sequence module.

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o
local filesys, mtable                                   in MAD
local assertTrue, assertFalse, assertNil, assertNotNil, assertEquals,
      assertErrorMsgContains, assertIs                  in MAD.utest
local is_sequence                                       in MAD.typeid
local drift, marker, sbend, quadrupole, sequence, bline in MAD.element

local srcdir = \s -> '../share/'    ..s
local refdir = \s -> 'sequence_ref/'..s
local rundir = \s -> 'sequence_run/'..s
local _msg   = {
  "invalid write access to readonly mtable",
  "nil reference value",
  "no reference column found",
}
-- helpers --------------------------------------------------------------------o

local function dumpseq (seq)
  local optfmt = MAD.option.format
  MAD.option.format = "%.5g"
  print()
  print('sequence:', seq.name, 'l=', seq.l)
  print('i', 'name', 'L', 'S (s)', 'S (e)')
  seq:foreach \e,i => print(i, e.name, e.l, seq:spos(i), seq:epos(i)) end
  MAD.option.format = optfmt
end

local function getIdxSeq()
  local seq = sequence {
    l = 5,
    marker "name1" { at = 1 },
    marker "name2" { at = 2 },
    marker "name1" { at = 3 },
    marker "name1" { at = 4 },
  }
  return seq
 end

-- regression test suite ------------------------------------------------------o

TestSequence = {}

function TestSequence:testIsSequence()
  local seq1  = sequence "seq1"  { marker {} }
  local seq12 = seq1     "seq12" { }
  assertTrue (is_sequence(sequence))
  assertTrue (is_sequence(seq1))
  assertTrue (is_sequence(seq12))
  assertFalse(is_sequence({}))
  assertFalse(is_sequence(mtable {}))
end

function TestSequence:testIsOwner()
  local seq1  = sequence "seq1"  { marker {} }
  local seq12 = seq1     "seq12" { }
  assertTrue (sequence:is_owner())
  assertTrue (seq1    :is_owner())
  assertFalse(seq12   :is_owner())
end

function TestSequence:testIsView()
  local seq1  = sequence "seq1"  { marker {} }
  local seq12 = seq1     "seq12" { }
  assertFalse(sequence:is_view())
  assertFalse(seq1    :is_view())
  assertTrue (seq12   :is_view())
end

function TestSequence:testIndexOfNum()
  local seq  = getIdxSeq()
  assertNil(seq:index_of( 6  ))
  assertNil(seq:index_of(-6  ))
  assertNil(seq:index_of( 100))
  assertNil(seq:index_of(-100))
  assertEquals(seq:index_of( 0)  , 1)
  assertEquals(seq:index_of( 1)  , 2)
  assertEquals(seq:index_of( 2)  , 3)
  assertEquals(seq:index_of(-3)  , 3)
  assertEquals(seq:index_of( 4)  , 5)
  assertEquals(seq:index_of(-1)  , 5)
  assertEquals(seq:index_of( 4.4), 6)
  assertEquals(seq:index_of(-0.1), 6)
  assertEquals(seq:index_of(-0.1), 6)
end

function TestSequence:testIndexOfString()
  local seq = getIdxSeq()
  local msg = {
    "invalid argument #2 (non-zero count expected)",
  }
  assertNil   (seq:index_of("name100  "   )   )
  assertNil   (seq:index_of("name1[4] "   )   )
  assertNil   (seq:index_of("name2[2] "   )   )
  assertNil   (seq:index_of("name1[-4]"   )   )
  assertNil   (seq:index_of("name2[-2]"   )   )
  assertNil   (seq:index_of("name1{3} ", 3)   )
  assertNil   (seq:index_of("name1{3} ",-4)   )
  assertNil   (seq:index_of("name1{-2}", 2)   )
  assertNil   (seq:index_of("name1{-2}",-5)   )
  assertNil   (seq:index_of("name1{-3}", 4)   )
  assertNil   (seq:index_of("name1{-3}",-3)   )
  assertEquals(seq:index_of("name1"       ), 2)
  assertEquals(seq:index_of("name2"       ), 3)
  assertEquals(seq:index_of("name1[1]"    ), 2)
  assertEquals(seq:index_of("name2[1]"    ), 3)
  assertEquals(seq:index_of("name1[2]"    ), 4)
  assertEquals(seq:index_of("name1[3]"    ), 5)
  assertEquals(seq:index_of("name1[-1]"   ), 5)
  assertEquals(seq:index_of("name2[-1]"   ), 3)
  assertEquals(seq:index_of("name1[-3]"   ), 2)
  assertEquals(seq:index_of("name1{1}" , 2), 2)
  assertEquals(seq:index_of("name1{1}" ,-5), 2)
  assertEquals(seq:index_of("name1{1}" , 3), 4)
  assertEquals(seq:index_of("name1{1}" ,-4), 4)
  assertEquals(seq:index_of("name1{2}" , 3), 5)
  assertEquals(seq:index_of("name1{2}" ,-4), 5)
  assertEquals(seq:index_of("name1{-1}", 3), 2)
  assertEquals(seq:index_of("name1{-1}",-4), 2)
  assertEquals(seq:index_of("name1{-1}", 2), 2)
  assertEquals(seq:index_of("name1{-1}",-5), 2)
  assertEquals(seq:index_of("name1{-2}", 4), 2)
  assertEquals(seq:index_of("name1{-2}",-3), 2)
  assertEquals(seq:index_of("name1{-1}", 4), 4)
  assertEquals(seq:index_of("name1{-1}",-3), 4)
  assertEquals(seq:index_of("name1{-2}", 5), 4)
  assertEquals(seq:index_of("name1{-2}",-2), 4)
  assertEquals(seq:index_of("name1{-3}", 5), 2)
  assertEquals(seq:index_of("name1{-3}",-2), 2)
  assertEquals(seq:index_of("name2{-1}", 4), 3)
  assertEquals(seq:index_of("name2{-1}",-3), 3)
  assertErrorMsgContains(msg[1], sequence.index_of, seq, "name1{0}", 2)
end

function TestSequence:testIndexOfElem()
  local mk1 = marker "name1" { }
  local mk2 = marker "name2" { at = 2, l = 1 }
  local mk3 = marker "name1" { }
  local mk4 = marker "name3" { }
  local mk5 = marker "name1" { }
  local seq = sequence {
    l = 5, refer = "entry",
    mk1,mk2,mk1,mk1,mk3
  }
  assertNil(seq:index_of(mk4)   )
  assertNil(seq:index_of(mk5)   )
  assertNil(seq:index_of(mk1, 6))
  assertEquals(seq:index_of(mk1)   , 2)
  assertEquals(seq:index_of(mk2)   , 3)
  assertEquals(seq:index_of(mk3)   , 6)
  assertEquals(seq:index_of(mk3, 3), 6)
  assertEquals(seq:index_of(mk1, 2), 2)
  assertEquals(seq:index_of(mk1,-6), 2)
  assertEquals(seq:index_of(mk1, 3), 4)
  assertEquals(seq:index_of(mk1,-5), 4)
end

function TestSequence:testIndexOfInvalid()
  local msg = {
    "invalid argument #2 (number, string or element expected)"
  }
  local seq = sequence {}
  assertErrorMsgContains(msg[1], sequence.index_of, seq, {})
  assertErrorMsgContains(msg[1], sequence.index_of, seq, nil)
  assertErrorMsgContains(msg[1], sequence.index_of, seq, \ ())
end

function TestSequence:testIndex()
  local seq  = getIdxSeq()
  assertNil(seq:index( 0  ))
  assertNil(seq:index( 7  ))
  assertNil(seq:index( 100))
  assertNil(seq:index(-100))
  assertEquals(seq:index( 1), 1)
  assertEquals(seq:index( 6), 6)
  assertEquals(seq:index(-1), 6)
  assertEquals(seq:index(-3), 4)
end

function TestSequence:testNameOfDirect()
  local seq = sequence {
    marker "name1" { },
    marker "name2" { },
    marker "name3" { },
    marker "name4" { },
  }
  local msg = {
    "invalid argument #2 (integer expected)",
  }
  assertNil(seq:name_of( 7  ))
  assertNil(seq:name_of(-7  ))
  assertNil(seq:name_of( 100))
  assertNil(seq:name_of(-100))
  assertEquals(seq:name_of( 1), "$start")
  assertEquals(seq:name_of( 2), "name1" )
  assertEquals(seq:name_of( 5), "name4" )
  assertEquals(seq:name_of( 6), "$end"  )
  assertEquals(seq:name_of(-2), "name4" )
  assertEquals(seq:name_of(-4), "name2" )
  assertErrorMsgContains(msg[1], sequence.name_of, seq, 1.5)
end

function TestSequence:testNameOfCnt()
  local seq = getIdxSeq()
  assertEquals(seq:name_of(3   ), "name2"    )
  assertEquals(seq:name_of(2   ), "name1[1]" )
  assertEquals(seq:name_of(4   ), "name1[2]" )
  assertEquals(seq:name_of(5   ), "name1[3]" )
  assertEquals(seq:name_of(2, 1), "name1{1}" )
  assertEquals(seq:name_of(2,-6), "name1{1}" )
  assertEquals(seq:name_of(4, 3), "name1{1}" )
  assertEquals(seq:name_of(4,-4), "name1{1}" )
  assertEquals(seq:name_of(5, 3), "name1{2}" )
  assertEquals(seq:name_of(5,-4), "name1{2}" )
  assertEquals(seq:name_of(2, 3), "name1{-1}")
  assertEquals(seq:name_of(2,-4), "name1{-1}")
  assertEquals(seq:name_of(2, 4), "name1{-1}")
  assertEquals(seq:name_of(2,-3), "name1{-1}")
  assertEquals(seq:name_of(2, 5), "name1{-2}")
  assertEquals(seq:name_of(2,-2), "name1{-2}")
end

function TestSequence:testRangeOfNum()
  local seq = getIdxSeq()
  local msg = {
    "invalid range start",
    "invalid argument #2 (integer, string, table or range expected)",
  }
  assertEquals(table.pack(seq:range_of(1 )), {1,1, n=2})
  assertEquals(table.pack(seq:range_of(4 )), {4,4, n=2})
  assertEquals(table.pack(seq:range_of(-3)), {4,4, n=2})
  assertEquals(table.pack(seq:range_of(-5)), {2,2, n=2})
  assertErrorMsgContains(msg[1], sequence.range_of, seq, 0  )
  assertErrorMsgContains(msg[1], sequence.range_of, seq, 7  )
  assertErrorMsgContains(msg[1], sequence.range_of, seq, 100)
  assertErrorMsgContains(msg[1], sequence.range_of, seq,-100)
  assertErrorMsgContains(msg[2], sequence.range_of, seq, 1.5)
end

function TestSequence:testRangeOfStringNum()
  local seq = getIdxSeq()
  assertEquals(table.pack(seq:range_of(" 1/ 1")), {2,2, n=2})
  assertEquals(table.pack(seq:range_of(" 2/ 2")), {3,3, n=2})
  assertEquals(table.pack(seq:range_of("-1/ 1")), {5,2, n=2})
  assertEquals(table.pack(seq:range_of("-1/ 4")), {5,5, n=2})
  assertEquals(table.pack(seq:range_of(" 1/-1")), {2,5, n=2})
  assertEquals(table.pack(seq:range_of(" 4/-1")), {5,5, n=2})
end

function TestSequence:testRangeOfStringPositive()
  local seq = getIdxSeq()
  assertEquals(table.pack(seq:range_of("name1    /name1    "   )), {2,2, n=2})
  assertEquals(table.pack(seq:range_of("name1    /name2    "   )), {2,3, n=2})
  assertEquals(table.pack(seq:range_of("name1[2] /name1[2] "   )), {4,4, n=2})
  assertEquals(table.pack(seq:range_of("name1[-2]/name1[-2]"   )), {4,4, n=2})
  assertEquals(table.pack(seq:range_of("name1[1] /name1[3] "   )), {2,5, n=2})
  assertEquals(table.pack(seq:range_of("name1[-3]/name1[-1]"   )), {2,5, n=2})
  assertEquals(table.pack(seq:range_of("name1[2] /name1[3] "   )), {4,5, n=2})
  assertEquals(table.pack(seq:range_of("name1[-2]/name1[-1]"   )), {4,5, n=2})
  assertEquals(table.pack(seq:range_of("name1[1] /name1[-1]"   )), {2,5, n=2})
  assertEquals(table.pack(seq:range_of("name1{1} /name1{2} ", 3)), {4,5, n=2})
  assertEquals(table.pack(seq:range_of("name1{1} /name1{2} ",-4)), {4,5, n=2})
  assertEquals(table.pack(seq:range_of("name1{1} /name1{2} ", 4)), {4,5, n=2})
  assertEquals(table.pack(seq:range_of("name1{1} /name1{2} ",-3)), {4,5, n=2})
  assertEquals(table.pack(seq:range_of("name1{-1}/name1{1} ", 4)), {4,4, n=2})
  assertEquals(table.pack(seq:range_of("name1{-1}/name1{1} ",-3)), {4,4, n=2})
  assertEquals(table.pack(seq:range_of("name1{-2}/name1{-1}", 5)), {4,5, n=2})
  assertEquals(table.pack(seq:range_of("name1{-2}/name1{-1}",-2)), {4,5, n=2})
  assertEquals(table.pack(seq:range_of("name1{-1}/name1{1} ", 3)), {2,4, n=2})
  assertEquals(table.pack(seq:range_of("name1{-1}/name1{1} ",-4)), {2,4, n=2})
  assertEquals(table.pack(seq:range_of("name1{-1}/name1{2} ", 3)), {2,5, n=2})
  assertEquals(table.pack(seq:range_of("name1{-1}/name1{2} ",-4)), {2,5, n=2})
  assertEquals(table.pack(seq:range_of("name1[2] /name1{2} ", 3)), {4,5, n=2})
  assertEquals(table.pack(seq:range_of("name1[2] /name1{2} ",-4)), {4,5, n=2})
  assertEquals(table.pack(seq:range_of("name1[-2]/name1{2} ", 3)), {4,5, n=2})
  assertEquals(table.pack(seq:range_of("name1[-2]/name1{2} ",-4)), {4,5, n=2})
  assertEquals(table.pack(seq:range_of("name1{-1}/name1[3] ", 3)), {2,5, n=2})
  assertEquals(table.pack(seq:range_of("name1{-1}/name1[3] ",-4)), {2,5, n=2})
  assertEquals(table.pack(seq:range_of("name1{1} /name1[3] ", 3)), {4,5, n=2})
  assertEquals(table.pack(seq:range_of("name1{1} /name1[3] ",-4)), {4,5, n=2})
end

function TestSequence:testRangeOfStringNegative()
  local seq = getIdxSeq()
  assertEquals(table.pack(seq:range_of("name2    /name1    "   )), {3,2, n=2})
  assertEquals(table.pack(seq:range_of("name1[3] /name1[1] "   )), {5,2, n=2})
  assertEquals(table.pack(seq:range_of("name1[-1]/name1[-3]"   )), {5,2, n=2})
  assertEquals(table.pack(seq:range_of("name1[3] /name1[2] "   )), {5,4, n=2})
  assertEquals(table.pack(seq:range_of("name1[-1]/name1[-2]"   )), {5,4, n=2})
  assertEquals(table.pack(seq:range_of("name1[-1]/name1[1] "   )), {5,2, n=2})
  assertEquals(table.pack(seq:range_of("name1{2} /name1{1} ", 3)), {5,4, n=2})
  assertEquals(table.pack(seq:range_of("name1{2} /name1{1} ",-4)), {5,4, n=2})
  assertEquals(table.pack(seq:range_of("name1{2} /name1{1} ", 4)), {5,4, n=2})
  assertEquals(table.pack(seq:range_of("name1{2} /name1{1} ",-3)), {5,4, n=2})
  assertEquals(table.pack(seq:range_of("name1{-1}/name1{-2}", 5)), {5,4, n=2})
  assertEquals(table.pack(seq:range_of("name1{-1}/name1{-2}",-2)), {5,4, n=2})
  assertEquals(table.pack(seq:range_of("name1{1} /name1{-1}", 3)), {4,2, n=2})
  assertEquals(table.pack(seq:range_of("name1{1} /name1{-1}",-4)), {4,2, n=2})
  assertEquals(table.pack(seq:range_of("name1{2} /name1{-1}", 3)), {5,2, n=2})
  assertEquals(table.pack(seq:range_of("name1{2} /name1{-1}",-4)), {5,2, n=2})
  assertEquals(table.pack(seq:range_of("name1{2} /name1[2] ", 3)), {5,4, n=2})
  assertEquals(table.pack(seq:range_of("name1{2} /name1[2] ",-4)), {5,4, n=2})
  assertEquals(table.pack(seq:range_of("name1{2} /name1[-2]", 3)), {5,4, n=2})
  assertEquals(table.pack(seq:range_of("name1{2} /name1[-2]",-4)), {5,4, n=2})
  assertEquals(table.pack(seq:range_of("name1[3] /name1{-1}", 3)), {5,2, n=2})
  assertEquals(table.pack(seq:range_of("name1[3] /name1{-1}",-4)), {5,2, n=2})
  assertEquals(table.pack(seq:range_of("name1[3] /name1{1} ", 3)), {5,4, n=2})
  assertEquals(table.pack(seq:range_of("name1[3] /name1{1} ",-4)), {5,4, n=2})
end

function TestSequence:testRangeOfStringInvalid()
  local seq      = getIdxSeq()
  local range_of = sequence.range_of
  local msg = {
    "invalid range start",
    "invalid range stop",
    "invalid argument #2 (number, string or element expected)",
  }
  assertErrorMsgContains(msg[3], range_of, seq, "                   "   )
  assertErrorMsgContains(msg[1], range_of, seq, "         /         "   )
  assertErrorMsgContains(msg[2], range_of, seq, "name1    /         "   )
  assertErrorMsgContains(msg[1], range_of, seq, "name100  /name1    "   )
  assertErrorMsgContains(msg[2], range_of, seq, "name1    /name200  "   )
  assertErrorMsgContains(msg[1], range_of, seq, "name100  /name200  "   )
  assertErrorMsgContains(msg[1], range_of, seq, "name1[-4]/name1[3] "   )
  assertErrorMsgContains(msg[2], range_of, seq, "name1[1] /name1[4] "   )
  assertErrorMsgContains(msg[1], range_of, seq, "name1[4] /name1[3] "   )
  assertErrorMsgContains(msg[2], range_of, seq, "name1[1] /name1[-4]"   )
  assertErrorMsgContains(msg[1], range_of, seq, "name1{-2}/name1{1} ", 3)
  assertErrorMsgContains(msg[2], range_of, seq, "name1{-1}/name1{3} ", 3)
  assertErrorMsgContains(msg[1], range_of, seq, "name1{3} /name1{1} ", 3)
  assertErrorMsgContains(msg[2], range_of, seq, "name1{-1}/name1{-3}", 3)
end

function TestSequence:testRangeOfTableIdx()
  local seq = getIdxSeq()
  local range_of = sequence.range_of
  local msg = {
    "invalid argument #2 (range of integers expected)",
  }
  assertEquals(table.pack(seq:range_of({ 1, 1, "idx"})), {1,1, n=2})
  assertEquals(table.pack(seq:range_of({ 1,-1, "idx"})), {1,6, n=2})
  assertEquals(table.pack(seq:range_of({ 2, 2, "idx"})), {2,2, n=2})
  assertEquals(table.pack(seq:range_of({-1, 1, "idx"})), {6,1, n=2})
  assertEquals(table.pack(seq:range_of({-1, 4, "idx"})), {6,4, n=2})
  assertEquals(table.pack(seq:range_of({ 4,-1, "idx"})), {4,6, n=2})
end

function TestSequence:testRangeOfTableNum()
  local seq = getIdxSeq()
  assertEquals(table.pack(seq:range_of({  1, 1  })), {2,2, n=2})
  assertEquals(table.pack(seq:range_of({  1,-1  })), {2,5, n=2})
  assertEquals(table.pack(seq:range_of({  2, 2  })), {3,3, n=2})
  assertEquals(table.pack(seq:range_of({ -1, 1  })), {5,2, n=2})
  assertEquals(table.pack(seq:range_of({ -1, 4  })), {5,5, n=2})
  assertEquals(table.pack(seq:range_of({  4,-1  })), {5,5, n=2})
  assertEquals(table.pack(seq:range_of({1.1,-1.1})), {3,5, n=2})
end

function TestSequence:testRangeOfTableStringNum()
  local seq = getIdxSeq()
  assertEquals(table.pack(seq:range_of({" 1", " 1"})), {2,2, n=2})
  assertEquals(table.pack(seq:range_of({" 1", "-1"})), {2,5, n=2})
  assertEquals(table.pack(seq:range_of({" 2", " 2"})), {3,3, n=2})
  assertEquals(table.pack(seq:range_of({"-1", " 1"})), {5,2, n=2})
  assertEquals(table.pack(seq:range_of({"-1", " 4"})), {5,5, n=2})
  assertEquals(table.pack(seq:range_of({" 4", "-1"})), {5,5, n=2})
  assertEquals(table.pack(seq:range_of({" 1", " 1"})), {2,2, n=2})
  assertEquals(table.pack(seq:range_of({"-1", " 1"})), {5,2, n=2})
  assertEquals(table.pack(seq:range_of({" 2", " 2"})), {3,3, n=2})
  assertEquals(table.pack(seq:range_of({" 1", "-1"})), {2,5, n=2})
  assertEquals(table.pack(seq:range_of({" 4", "-1"})), {5,5, n=2})
  assertEquals(table.pack(seq:range_of({"-1", " 4"})), {5,5, n=2})
end

function TestSequence:testRangeOfTableStringPositiveAbsolute()
  local seq = getIdxSeq()
  assertEquals(table.pack(seq:range_of({"name1    ", "name1    "})), {2,2, n=2})
  assertEquals(table.pack(seq:range_of({"name1    ", "name2    "})), {2,3, n=2})
  assertEquals(table.pack(seq:range_of({"name1[2] ", "name1[2] "})), {4,4, n=2})
  assertEquals(table.pack(seq:range_of({"name1[-2]", "name1[-2]"})), {4,4, n=2})
  assertEquals(table.pack(seq:range_of({"name1[1] ", "name1[3] "})), {2,5, n=2})
  assertEquals(table.pack(seq:range_of({"name1[-3]", "name1[-1]"})), {2,5, n=2})
  assertEquals(table.pack(seq:range_of({"name1[2] ", "name1[3] "})), {4,5, n=2})
  assertEquals(table.pack(seq:range_of({"name1[-2]", "name1[-1]"})), {4,5, n=2})
  assertEquals(table.pack(seq:range_of({"name1[1] ", "name1[-1]"})), {2,5, n=2})
end

function TestSequence:testRangeOfTableStringPositiveRelative()
  local seq   = getIdxSeq()
  local tpack = table.pack
  assertEquals(tpack(seq:range_of({"name1{1} ", "name1{2} "}, 3)), {4,5, n=2})
  assertEquals(tpack(seq:range_of({"name1{1} ", "name1{2} "},-4)), {4,5, n=2})
  assertEquals(tpack(seq:range_of({"name1{1} ", "name1{2} "}, 4)), {4,5, n=2})
  assertEquals(tpack(seq:range_of({"name1{1} ", "name1{2} "},-3)), {4,5, n=2})
  assertEquals(tpack(seq:range_of({"name1{-1}", "name1{1} "}, 4)), {4,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{-1}", "name1{1} "},-3)), {4,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{-2}", "name1{-1}"}, 5)), {4,5, n=2})
  assertEquals(tpack(seq:range_of({"name1{-2}", "name1{-1}"},-2)), {4,5, n=2})
  assertEquals(tpack(seq:range_of({"name1{-1}", "name1{1} "}, 3)), {2,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{-1}", "name1{1} "},-4)), {2,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{-1}", "name1{2} "}, 3)), {2,5, n=2})
  assertEquals(tpack(seq:range_of({"name1{-1}", "name1{2} "},-4)), {2,5, n=2})
  assertEquals(tpack(seq:range_of({"name1[2] ", "name1{2} "}, 3)), {4,5, n=2})
  assertEquals(tpack(seq:range_of({"name1[2] ", "name1{2} "},-4)), {4,5, n=2})
  assertEquals(tpack(seq:range_of({"name1[-2]", "name1{2} "}, 3)), {4,5, n=2})
  assertEquals(tpack(seq:range_of({"name1[-2]", "name1{2} "},-4)), {4,5, n=2})
  assertEquals(tpack(seq:range_of({"name1{-1}", "name1[3] "}, 3)), {2,5, n=2})
  assertEquals(tpack(seq:range_of({"name1{-1}", "name1[3] "},-4)), {2,5, n=2})
  assertEquals(tpack(seq:range_of({"name1{1} ", "name1[3] "}, 3)), {4,5, n=2})
  assertEquals(tpack(seq:range_of({"name1{1} ", "name1[3] "},-4)), {4,5, n=2})
  assertEquals(tpack(seq:range_of({"name1{1} ", "name1{2} ", 3})), {4,5, n=2})
  assertEquals(tpack(seq:range_of({"name1{1} ", "name1{2} ",-4})), {4,5, n=2})
  assertEquals(tpack(seq:range_of({"name1{1} ", "name1{2} ", 4})), {4,5, n=2})
  assertEquals(tpack(seq:range_of({"name1{1} ", "name1{2} ",-3})), {4,5, n=2})
  assertEquals(tpack(seq:range_of({"name1{-1}", "name1{1} ", 4})), {4,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{-1}", "name1{1} ",-3})), {4,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{-2}", "name1{-1}", 5})), {4,5, n=2})
  assertEquals(tpack(seq:range_of({"name1{-2}", "name1{-1}",-2})), {4,5, n=2})
  assertEquals(tpack(seq:range_of({"name1{-1}", "name1{1} ", 3})), {2,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{-1}", "name1{1} ",-4})), {2,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{-1}", "name1{2} ", 3})), {2,5, n=2})
  assertEquals(tpack(seq:range_of({"name1{-1}", "name1{2} ",-4})), {2,5, n=2})
  assertEquals(tpack(seq:range_of({"name1[2] ", "name1{2} ", 3})), {4,5, n=2})
  assertEquals(tpack(seq:range_of({"name1[2] ", "name1{2} ",-4})), {4,5, n=2})
  assertEquals(tpack(seq:range_of({"name1[-2]", "name1{2} ", 3})), {4,5, n=2})
  assertEquals(tpack(seq:range_of({"name1[-2]", "name1{2} ",-4})), {4,5, n=2})
  assertEquals(tpack(seq:range_of({"name1{-1}", "name1[3] ", 3})), {2,5, n=2})
  assertEquals(tpack(seq:range_of({"name1{-1}", "name1[3] ",-4})), {2,5, n=2})
  assertEquals(tpack(seq:range_of({"name1{1} ", "name1[3] ", 3})), {4,5, n=2})
  assertEquals(tpack(seq:range_of({"name1{1} ", "name1[3] ",-4})), {4,5, n=2})
end

function TestSequence:testRangeOfTableStringNegativeAbsolute()
  local seq   = getIdxSeq()
  assertEquals(table.pack(seq:range_of({"name1    ", "name1    "})), {2,2, n=2})
  assertEquals(table.pack(seq:range_of({"name2    ", "name1    "})), {3,2, n=2})
  assertEquals(table.pack(seq:range_of({"name1[2] ", "name1[2] "})), {4,4, n=2})
  assertEquals(table.pack(seq:range_of({"name1[-2]", "name1[-2]"})), {4,4, n=2})
  assertEquals(table.pack(seq:range_of({"name1[3] ", "name1[1] "})), {5,2, n=2})
  assertEquals(table.pack(seq:range_of({"name1[-1]", "name1[-3]"})), {5,2, n=2})
  assertEquals(table.pack(seq:range_of({"name1[3] ", "name1[2] "})), {5,4, n=2})
  assertEquals(table.pack(seq:range_of({"name1[-1]", "name1[-2]"})), {5,4, n=2})
  assertEquals(table.pack(seq:range_of({"name1[-1]", "name1[1] "})), {5,2, n=2})
end

function TestSequence:testRangeOfTableStringNegativeRelative()
  local seq   = getIdxSeq()
  local tpack = table.pack
  assertEquals(tpack(seq:range_of({"name1{2} ", "name1{1} "}, 3)), {5,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{2} ", "name1{1} "},-4)), {5,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{2} ", "name1{1} "}, 4)), {5,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{2} ", "name1{1} "},-3)), {5,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{1} ", "name1{-1}"}, 4)), {4,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{1} ", "name1{-1}"},-3)), {4,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{-1}", "name1{-2}"}, 5)), {5,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{-1}", "name1{-2}"},-2)), {5,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{1} ", "name1{-1}"}, 3)), {4,2, n=2})
  assertEquals(tpack(seq:range_of({"name1{1} ", "name1{-1}"},-4)), {4,2, n=2})
  assertEquals(tpack(seq:range_of({"name1{2} ", "name1{-1}"}, 3)), {5,2, n=2})
  assertEquals(tpack(seq:range_of({"name1{2} ", "name1{-1}"},-4)), {5,2, n=2})
  assertEquals(tpack(seq:range_of({"name1{2} ", "name1[2] "}, 3)), {5,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{2} ", "name1[2] "},-4)), {5,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{2} ", "name1[-2]"}, 3)), {5,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{2} ", "name1[-2]"},-4)), {5,4, n=2})
  assertEquals(tpack(seq:range_of({"name1[3] ", "name1{-1}"}, 3)), {5,2, n=2})
  assertEquals(tpack(seq:range_of({"name1[3] ", "name1{-1}"},-4)), {5,2, n=2})
  assertEquals(tpack(seq:range_of({"name1[3] ", "name1{1} "}, 3)), {5,4, n=2})
  assertEquals(tpack(seq:range_of({"name1[3] ", "name1{1} "},-4)), {5,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{2} ", "name1{1} ", 3})), {5,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{2} ", "name1{1} ",-4})), {5,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{2} ", "name1{1} ", 4})), {5,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{2} ", "name1{1} ",-3})), {5,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{1} ", "name1{-1}", 4})), {4,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{1} ", "name1{-1}",-3})), {4,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{-1}", "name1{-2}", 5})), {5,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{-1}", "name1{-2}",-2})), {5,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{1} ", "name1{-1}", 3})), {4,2, n=2})
  assertEquals(tpack(seq:range_of({"name1{1} ", "name1{-1}",-4})), {4,2, n=2})
  assertEquals(tpack(seq:range_of({"name1{2} ", "name1{-1}", 3})), {5,2, n=2})
  assertEquals(tpack(seq:range_of({"name1{2} ", "name1{-1}",-4})), {5,2, n=2})
  assertEquals(tpack(seq:range_of({"name1{2} ", "name1[2] ", 3})), {5,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{2} ", "name1[2] ",-4})), {5,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{2} ", "name1[-2]", 3})), {5,4, n=2})
  assertEquals(tpack(seq:range_of({"name1{2} ", "name1[-2]",-4})), {5,4, n=2})
  assertEquals(tpack(seq:range_of({"name1[3] ", "name1{-1}", 3})), {5,2, n=2})
  assertEquals(tpack(seq:range_of({"name1[3] ", "name1{-1}",-4})), {5,2, n=2})
  assertEquals(tpack(seq:range_of({"name1[3] ", "name1{1} ", 3})), {5,4, n=2})
  assertEquals(tpack(seq:range_of({"name1[3] ", "name1{1} ",-4})), {5,4, n=2})
end

function TestSequence:testRangeOfTableInvalid()
  local seq      = getIdxSeq()
  local range_of = sequence.range_of
  local msg      = {
    "invalid range start",
    "invalid range stop",
    "invalid argument #2 (number, string or element expected)",
    "invalid argument #2 (range of integers expected)",
  }
  assertErrorMsgContains(msg[1], range_of, seq, { 0         , 2  , "idx" }   )
  assertErrorMsgContains(msg[2], range_of, seq, { 1         , 7  , "idx" }   )
  assertErrorMsgContains(msg[1], range_of, seq, {-100       , 2  , "idx" }   )
  assertErrorMsgContains(msg[2], range_of, seq, { 1         , 100, "idx" }   )
  assertErrorMsgContains(msg[4], range_of, seq, { 1.5       , 2  , "idx" }   )
  assertErrorMsgContains(msg[4], range_of, seq, { 1         , 2.5, "idx" }   )
  assertErrorMsgContains(msg[2], range_of, seq, { 1         , 7          }   )
  assertErrorMsgContains(msg[1], range_of, seq, {-7         , 5          }   )
  assertErrorMsgContains(msg[1], range_of, seq, {-100       , 2          }   )
  assertErrorMsgContains(msg[2], range_of, seq, { 1         , 100        }   )
  assertErrorMsgContains(msg[1], range_of, seq, {"         ", "         "}   )
  assertErrorMsgContains(msg[2], range_of, seq, {"name1    ", "         "}   )
  assertErrorMsgContains(msg[1], range_of, seq, {"name100  ", "name1    "}   )
  assertErrorMsgContains(msg[2], range_of, seq, {"name1    ", "name200  "}   )
  assertErrorMsgContains(msg[1], range_of, seq, {"name100  ", "name200  "}   )
  assertErrorMsgContains(msg[1], range_of, seq, {"name1[-4]", "name1[3] "}   )
  assertErrorMsgContains(msg[2], range_of, seq, {"name1[1] ", "name1[4] "}   )
  assertErrorMsgContains(msg[1], range_of, seq, {"name1[4] ", "name1[3] "}   )
  assertErrorMsgContains(msg[2], range_of, seq, {"name1[1] ", "name1[-4]"}   )
  assertErrorMsgContains(msg[1], range_of, seq, {"name1{-2}", "name1{1} "}, 3)
  assertErrorMsgContains(msg[2], range_of, seq, {"name1{-1}", "name1{3} "}, 3)
  assertErrorMsgContains(msg[1], range_of, seq, {"name1{3} ", "name1{1} "}, 3)
  assertErrorMsgContains(msg[2], range_of, seq, {"name1{-1}", "name1{-3}"}, 3)
  assertErrorMsgContains(msg[1], range_of, seq, {"name1{-2}", "name1{1} ", 3})
  assertErrorMsgContains(msg[2], range_of, seq, {"name1{-1}", "name1{3} ", 3})
  assertErrorMsgContains(msg[1], range_of, seq, {"name1{3} ", "name1{1} ", 3})
  assertErrorMsgContains(msg[2], range_of, seq, {"name1{-1}", "name1{-3}", 3})
end

function TestSequence:testRangeOfRange()
  local seq = getIdxSeq()
  assertEquals(table.pack(seq:range_of( 1 ..  4 )), {2,5, n=2})
  assertEquals(table.pack(seq:range_of(-4 .. -1 )), {2,5, n=2})
  assertEquals(table.pack(seq:range_of( 2 ..  3 )), {3,4, n=2})
  assertEquals(table.pack(seq:range_of( 4 ..  1 )), {5,2, n=2})
  assertEquals(table.pack(seq:range_of(-1 .. -4 )), {5,2, n=2})
  assertEquals(table.pack(seq:range_of( 3 ..  2 )), {4,3, n=2})
end

function TestSequence:testLengthOf0TrnPositive()
  local seq       = getIdxSeq()
  local length_of = sequence.length_of
  local msg       = {
    "invalid range start",
    "invalid range stop",
  }
  assertEquals(seq:length_of(                               ), 6)
  assertEquals(seq:length_of( "1         /  4       "       ), 4)
  assertEquals(seq:length_of( "name1[1]  /  name1[3]"       ), 4)
  assertEquals(seq:length_of({"name1[1] ", "name1[3]"   }   ), 4)
  assertEquals(seq:length_of({"name1{-1}", "name1{2}", 3}   ), 4)
  assertEquals(seq:length_of({2          , 3            }   ), 2)
  assertEquals(seq:length_of( nil                        , 0), 6)
  assertEquals(seq:length_of( "1         /  4       "    , 0), 4)
  assertEquals(seq:length_of( "name1[1]  /  name1[3]"    , 0), 4)
  assertEquals(seq:length_of({"name1[1] ", "name1[3]"   }, 0), 4)
  assertEquals(seq:length_of({"name1{-1}", "name1{2}", 3}, 0), 4)
  assertEquals(seq:length_of({2          , 3            }, 0), 2)
  assertErrorMsgContains(msg[1], length_of, seq,  "name1[-4] / name1[3] "    )
  assertErrorMsgContains(msg[2], length_of, seq, {"name1{-1}","name1{-3}", 3})
end

function TestSequence:testLengthOf0TrnNegative()
  local seq       = getIdxSeq()
  local length_of = sequence.length_of
  local msg       = {
    "invalid range start",
    "invalid range stop",
  }
  assertEquals(seq:length_of( "4        /  1       "        ), 4)
  assertEquals(seq:length_of( "name1[3] /  name1[1]"        ), 4)
  assertEquals(seq:length_of({3         , 2             }   ), 6)
  assertEquals(seq:length_of({"name1[3]", "name1[1] "   }   ), 4)
  assertEquals(seq:length_of({"name1{2}", "name1{-1}", 3}   ), 4)
  assertEquals(seq:length_of( "4        /  1        "    , 0), 4)
  assertEquals(seq:length_of( "name1[3] /  name1[1] "    , 0), 4)
  assertEquals(seq:length_of({"name1[3]", "name1[1] "   }, 0), 4)
  assertEquals(seq:length_of({"name1{2}", "name1{-1}", 3}, 0), 4)
  assertEquals(seq:length_of({3          , 2            }, 0), 6)
  assertErrorMsgContains(msg[1], length_of, seq, {"name1{-3}","name1{-1}", 3})
  assertErrorMsgContains(msg[2], length_of, seq,  "name1[3] / name1[-4] "    )
end

function TestSequence:testLengthOfNTrnPositive()
  local seq = getIdxSeq()
  assertEquals(seq:length_of( nil                        , 5), 36)
  assertEquals(seq:length_of( "1         /  4       "    , 5), 34)
  assertEquals(seq:length_of( "name1[1]  /  name1[3]"    , 5), 34)
  assertEquals(seq:length_of({"name1[1] ", "name1[3]"   }, 5), 34)
  assertEquals(seq:length_of({"name1{-1}", "name1{2}", 3}, 5), 34)
  assertEquals(seq:length_of({2          , 3            }, 5), 32)
end

function TestSequence:testLengthOfNTrnNegative()
  local seq = getIdxSeq()
  assertEquals(seq:length_of( "4        /  1        "    , 5), 34)
  assertEquals(seq:length_of( "name1[3] /  name1[1] "    , 5), 34)
  assertEquals(seq:length_of({"name1[3]", "name1[1] "   }, 5), 34)
  assertEquals(seq:length_of({"name1{2}", "name1{-1}", 3}, 5), 34)
  assertEquals(seq:length_of({3         , 2             }, 5), 36)
end

function TestSequence:testIterOne()
  local mk  = marker { at = 1 }
  local seq = sequence "seq" { l=2, refer="entry", mk }
  local i   = 1
  for j,elm,s in seq:iter() do
    assertIs(elm, seq[j])
    assertEquals(i, j)
    assertEquals(s, seq:spos(j))
    i = i + 1
  end
  assertEquals(i, 4)
end

function TestSequence:testIter()
  local seq = getIdxSeq()
  local i = 1
  for j,elm,s in seq:iter() do
    assertIs(elm, seq[j])
    assertEquals(i, j)
    assertEquals(s, seq:spos(j))
    i = i + 1
  end
  assertEquals(i, 7)
end

function TestSequence:testIterRangeTableNum()
  local seq, i = getIdxSeq()
  -- first/last iterator
  i = 1
  for j,elm,s in seq:iter{0,-0.1} do
    assertIs    (elm, seq[j]     )
    assertEquals(i  , j          )
    assertEquals(s  , seq:spos(j))
    i = i + 1
  end
  assertEquals(i, 7)

  -- 2nd/3rd iterator
  i = 2
  for j,elm,s in seq:iter{1,-4} do
    assertIs    (elm, seq[j]       )
    assertEquals(i  , j            )
    assertEquals(s  , seq:spos(j)-1)
    i = i + 1
  end
  assertEquals(i, 3)
end

function TestSequence:testIterRangeStringNum()
  local seq, i = getIdxSeq()
  -- first/last iterator
  i = 1
  for j,elm,s in seq:iter("0/-0.1") do
    assertIs    (elm, seq[j]     )
    assertEquals(j  , i          )
    assertEquals(s  , seq:spos(j))
    i = i + 1
  end
  assertEquals(i, 7)

  -- 2nd/3rd iterator
  i = 2
  for j,elm,s in seq:iter("1/-4") do
    assertIs    (elm, seq[j]       )
    assertEquals(j  , i            )
    assertEquals(s  , seq:spos(j)-1)
    i = i + 1
  end
  assertEquals(i, 3)
end

function TestSequence:testIterRangeRange()
  local seq, i = getIdxSeq()
  -- first/last iterator
  i = 1
  for j,elm,s in seq:iter(0..-0.1) do
    assertIs    (elm, seq[j]     )
    assertEquals(j  , i          )
    assertEquals(s  , seq:spos(j))
    i = i + 1
  end
  assertEquals(i, 7)

  -- 2nd/3rd iterator
  i = 2
  for j,elm,s in seq:iter(1..-4) do
    assertIs    (elm, seq[j]       )
    assertEquals(j  , i            )
    assertEquals(s  , seq:spos(j)-1)
    i = i + 1
  end
  assertEquals(i, 3)
end

function TestSequence:testIterRangeName()
  local seq, i = getIdxSeq()

  i = 2
  for j,elm,s in seq:iter("name1[1]/name1[3]") do
    assertIs    (elm, seq[j]       )
    assertEquals(j  , i            )
    assertEquals(s  , seq:spos(j)-1)
    i = i + 1
  end
  assertEquals(i, 6)

  i = 3
  for j,elm,s in seq:iter{"name2", "name1{1}", 3} do
    assertIs    (elm, seq[j]       )
    assertEquals(j  , i            )
    assertEquals(s  , seq:spos(j)-2)
    i = i + 1
  end
  assertEquals(i, 5)
end

function TestSequence:testIterRangeSingle()
  local seq, i = getIdxSeq(), 3
  for j,elm,s in seq:iter{2,2} do
    assertIs    (elm, seq[j]       )
    assertEquals(j  , i            )
    assertEquals(s  , seq:spos(j)-2)
    i = i + 1
  end
  assertEquals(i, 4)
end

function TestSequence:testIterCycle()
  local seq, i = getIdxSeq(), 1
  local idx  = {3, 4, 5, 6, 1, 2}
  local spos = {0, 1, 2, 3, 3, 4}
  for j,elm,s in seq:iter{2,1} do
    assertIs    (elm   , seq[j] )
    assertEquals(idx[i], j      )
    assertEquals(s     , spos[i])
    i = i + 1
  end
  assertEquals(i, 7)
end

function TestSequence:testIterNturn()
  local seq, i, spos = getIdxSeq()

  spos, i = {0, 1, 2, 3, 4, 5, 5, 6, 7, 8, 9, 10, 10, 11, 12, 13, 14, 15}, 0
  for j,elm,s in seq:iter(nil,2) do
    assertIs    (elm    , seq[j]   )
    assertEquals(i%6 + 1, j        )
    assertEquals(s      , spos[i+1])
    i = i + 1
  end
  assertEquals(i, 18)

  spos, i = {0, 1, 2, 2, 3, 4, 5, 6, 7, 7, 8, 9, 10, 11, 12, 12, 13, 14}, 3
  for j,elm,s in seq:iter({3,2},2) do
    assertIs    (elm    , seq[j]   )
    assertEquals(i%6 + 1, j        )
    assertEquals(s      , spos[i-2])
    i = i + 1
  end
  assertEquals(i, 21)
end

function TestSequence:testIterDir()
  local seq, i, spos = getIdxSeq()
  local idx = {3, 2, 1, 6, 5, 4}
  -- last/first iterator decreasing
  i, spos = 6, 0
  for j,elm,s in seq:iter(nil,nil,-1) do
    assertIs    (elm, seq[j])
    assertEquals(j  , i     )
    assertEquals(s  , spos  )
    spos, i = spos-1, i-1
  end
  assertEquals(i, 0)

  -- 2nd/3rd iterator decreasing
  spos, i = {0, -1, -2, -2, -3, -4}, 1
  for j,elm,s in seq:iter({2, 3}, nil, -1) do
    assertIs    (elm   , seq[j] )
    assertEquals(idx[i], j      )
    assertEquals(s     , spos[i])
    i = i + 1
  end
  assertEquals(i, 7)
end

function TestSequence:testCycleNum()
  local seq = getIdxSeq()
  local idx = {3, 4, 5, 6, 1, 2}
  local i
  i = 1
  seq:cycle(2)
  for j,elm in seq:iter() do
    assertIs    (elm   , seq[j])
    assertEquals(idx[i], j     )
    i = i + 1
  end
  assertEquals(i, 7)

  i = 1
  seq:cycle(-3)
  for j,elm in seq:iter() do
    assertIs    (elm   , seq[j])
    assertEquals(idx[i], j     )
    i = i + 1
  end
  assertEquals(i, 7)
end

function TestSequence:testCycleName()
  local seq  = getIdxSeq()
  local idx1 = { 3, 4, 5, 6, 1, 2 }
  local idx2 = { 4, 5, 6, 1, 2, 3 }
  local i
  i = 1
  seq:cycle("name2")
  for j,elm in seq:iter() do
    assertIs    (elm    , seq[j])
    assertEquals(idx1[i], j     )
    i = i + 1
  end
  assertEquals(i, 7)

  i = 1
  seq:cycle("name1[2]")
  for j,elm in seq:iter() do
    assertIs    (elm    , seq[j])
    assertEquals(idx2[i], j     )
    i = i + 1
  end
  assertEquals(i, 7)
end

function TestSequence:testCycleInvalid()
  local seq = getIdxSeq()
  local msg = {
    "invalid argument #2 (reference expected)",
  }
  assertErrorMsgContains(msg[1], sequence.cycle, seq, 5.1   )
  assertErrorMsgContains(msg[1], sequence.cycle, seq,-5.1   )
  assertErrorMsgContains(msg[1], sequence.cycle, seq, "none")
end

-------------------------------------------------------------------------------o

-- end ------------------------------------------------------------------------o