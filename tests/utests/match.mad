--[=[
 o-----------------------------------------------------------------------------o
 |
 | Match tests
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide regression test suites for the match module.

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local assertNotNil, assertEquals, assertAlmostEquals, assertAllAlmostEquals,
      assertTrue, assertStrContains, assertErrorMsgContains      in MAD.utest

local beam, sequence, twiss, match, plot,
      option, filesys, atexit                                    in MAD
local ftrue                                                      in MAD.gfunc
local marker, drift, sbend, quadrupole, multipole                in MAD.element
local eps, inf, pi                                               in MAD.constant
local sqrt                                                       in MAD.gmath

local refdir = \s -> 'match_ref/'..(s or '')
local rundir = \s -> 'match_run/'..(s or '')

-- helpers --------------------------------------------------------------------o

local doplot != true

if doplot then
  local pause, atexit in MAD.utility
  atexit(pause, true)
end

-- Tests ----------------------------------------------------------------------o

TestMatch = {}

function TestMatch:setUp ()
  filesys.mkdir(rundir())
  self.optfmt = option.numfmt
  self.optdbg = option.debug
  option.numfmt = "%-.10g"
  option.debug = 1
end

function TestMatch:tearDown ()
  option.numfmt = self.optfmt
  option.debug  = self.optdbg
end

-- FODO matching --------------------------------------------------------------o

function TestMatch:testMatchThinFODO ()
  local knobs = { k1qf =  0.2828427125,   --  0.3037241107,
                  k1qd = -0.2828427125, } -- -0.3037241107, }

  local function thinFODO () -- TODO: simplify the fodo
    local seq
    local nsl = 1 -- 10 -- for madx row by row compatibility
    local nth = 10
    local dl  = 1/nth
    local mk1 = marker    'mk1' {}
    local mk2 = marker    'mk2' {}
    local df1 = drift     'df1' { l=4, nslice=nsl }
    local df2 = drift     'df2' { l=4, nslice=nsl }
    local mq1 = multipole 'mq1' { knl := {0, knobs.k1qf/nth} }
    local mq2 = multipole 'mq2' { knl := {0, knobs.k1qd/nth} }

    seq = sequence 'seq' { l=10, refer='entry', -- dir=-1,
                  mq1 {at=0+dl/2              },
        (nth/2-1)*mq1 {at=dl    , from='prev' },
                  mk1 {at=0+dl/2, from='prev' },
                  mq1 {at=0+dl/2, from='prev' },
        (nth/2-1)*mq1 {at=dl    , from='prev' },
  --                df1 {at=1}, -- for madx row by row compatibility

                  mq2 {at=5+dl/2              },
        (nth/2-1)*mq2 {at=dl    , from='prev' },
                  mk2 {at=0+dl/2, from='prev' },
                  mq2 {at=0+dl/2, from='prev' },
        (nth/2-1)*mq2 {at=dl    , from='prev' },
  --                df2 {at=6}, -- for madx row by row compatibility
    }
    seq.beam  = beam

    return seq
  end

  local fodo = thinFODO()

  -- match test
  local status, fmin, ncall = match {

    command := twiss { sequence=fodo, observe=1 },

    variables = {
      { var = 'knobs.k1qf', min= 0.2, max= 0.4 },
      { var = 'knobs.k1qd', min=-0.4, max=-0.2 },
    },

    equalities = {
      { kind = 'mu1', expr = \t -> t.mu1[#t]-0.25 },
      { kind = 'mu2', expr = \t -> t.mu2[#t]-0.25 },
    },

    objective = { fmin = 1e-8, maxcall = 50, !summary=true
    },
  }

--  print('status=', status, 'fmin=', fmin, 'ncall=', ncall)
--  print('k1_qf=', knobs.k1qf, 'k1_qd=', knobs.k1qd)

  assertEquals      (status    ,  'NLOPT_FMIN_REACHED'   )
  assertEquals      (ncall     ,  27                     )
  assertAlmostEquals(fmin      ,  3.6561472710708e-12, 1e-24)
  assertAlmostEquals(knobs.k1qf,  0.30372411066053, 1e-12)
  assertAlmostEquals(knobs.k1qd, -0.30372411066158, 1e-12)
end

function TestMatch:testMatchFODO ()
  -- classes
  local mb = sbend { l=2, angle=2*pi/50 }
  local mq = quadrupole { l=1 }
  local var = { k1f=0.28, k1d=-0.28 }

  -- sequence
  local seq = sequence 'seq' {
    l=10, refer='entry', beam=beam,
    mq 'mq1' { at=0, k1 := var.k1f },
    mb 'mb1' { at=2, k0 =\s s.angle/s.l },
    mq 'mq2' { at=5, k1 := var.k1d },
    mb 'mb2' { at=7, k0 =\s s.angle/s.l },
  }

  -- twiss
  if doplot then
    local mtbl = twiss {sequence=seq, nslice=10, save='atbody'}
    plot { table=mtbl, sequence=seq, fontsize=18, styles='lines',
           x1y1 = { s={'beta11','beta22'} },
           x1y2 = { s={'mu1'   ,'mu2'   } } }
  end

  -- match phase advance
  local status, fmin, ncall = match {
    command := twiss { sequence=seq, observe=1 },
    variables = {
      { var = 'var.k1f', min= 0.2, max= 0.4 },
      { var = 'var.k1d', min=-0.4, max=-0.2 },
    },
    equalities = {
      { expr = \t -> assert(t).mu1[#t]-0.25 },
      { expr = \t -> assert(t).mu2[#t]-0.25 },
    },
    objective = {
      fmin = 1e-8, maxcall = 50, !summary=2, debug=1
    },
  }

!  MAD.utility.printf("var.k1f = % -.16e\n", var.k1f)
!  MAD.utility.printf("var.k1d = % -.16e\n", var.k1d)

  -- check results
  assertEquals      (status ,  'NLOPT_FMIN_REACHED'   )
  assertEquals      (ncall  ,  31                     )
  assertAlmostEquals(fmin   ,  1.4720925152e-15, 1e-16)
  assertAlmostEquals(var.k1f,  0.29599989525034, 1e-12)
  assertAlmostEquals(var.k1d, -0.30241971341642, 1e-12)

  if doplot then
    -- plot betas and phases
    local mtbl = twiss {sequence=seq, nslice=10, save='atbody'}
    plot { table=mtbl, sequence=seq, fontsize=18, styles='lines',
           x1y1 = { s={'beta11','beta22'} },
           x1y2 = { s={'mu1'   ,'mu2'   } } }
    plot { table=mtbl, sequence=seq, fontsize=18, !styles='lines',
           x1y1 = { s={'beta11','beta22'} },
           x1y2 = { s={'mu1'   ,'mu2'   } } }
  end
end

function TestMatch:testMatchFODOLocVar ()
  -- classes
  local mb = sbend { l=2, angle=2*pi/50 }
  local mq = quadrupole { l=1 }
  local k1f= 0.28
  local k1d=-0.28

  -- sequence
  local seq = sequence 'seq' {
    l=10, refer='entry', beam=beam,
    mq 'mq1' { at=0, k1 := k1f },
    mb 'mb1' { at=2, k0 =\s s.angle/s.l },
    mq 'mq2' { at=5, k1 := k1d },
    mb 'mb2' { at=7, k0 =\s s.angle/s.l },
  }

  -- twiss
  if doplot then
    local mtbl = twiss {sequence=seq, nslice=10, save='atbody'}
    plot { table=mtbl, sequence=seq, fontsize=18, styles='lines',
           x1y1 = { s={'beta11','beta22'} },
           x1y2 = { s={'mu1'   ,'mu2'   } } }
  end

  -- match phase advance
  local status, fmin, ncall = match {
    command := twiss { sequence=seq, observe=1 },
    variables = { nowarn=true,
      { var = 'k1f', min= 0.2, max= 0.4 },
      { var = 'k1d', min=-0.4, max=-0.2 },
    },
    equalities = {
      { expr = \t -> assert(t).mu1[#t]-0.25 },
      { expr = \t -> assert(t).mu2[#t]-0.25 },
    },
    objective = {
      fmin = 1e-8, maxcall = 50, !summary=2,
    },
  }

  -- check results
  assertEquals      (status,  'NLOPT_FMIN_REACHED'   )
  assertEquals      (ncall ,  31                     )
  assertAlmostEquals(fmin  ,  1.4720925152e-15, 1e-16)
  assertAlmostEquals(k1f   ,  0.29599989525034, 1e-12)
  assertAlmostEquals(k1d   , -0.30241971341642, 1e-12)


  if doplot then
    -- plot betas and phases
    local mtbl = twiss {sequence=seq, nslice=10, save='atbody'}
    plot { table=mtbl, sequence=seq, fontsize=18, styles='lines',
           x1y1 = { s={'beta11','beta22'} },
           x1y2 = { s={'mu1'   ,'mu2'   } } }
    plot { table=mtbl, sequence=seq, fontsize=18, !styles='lines',
           x1y1 = { s={'beta11','beta22'} },
           x1y2 = { s={'mu1'   ,'mu2'   } } }
  end
end

function TestMatch:testMatchFODONoVar ()
  -- classes
  local mb = sbend { l=2, angle=2*pi/50 }
  local mq = quadrupole { l=1 }

  -- sequence
  local seq = sequence 'seq' {
    l=10, refer='entry', beam=beam,
    mq 'mq1' { at=0, k1 = 0.28 },
    mb 'mb1' { at=2, k0 =\s s.angle/s.l },
    mq 'mq2' { at=5, k1 = -0.28 },
    mb 'mb2' { at=7, k0 =\s s.angle/s.l },
  }

  -- twiss
  if doplot then
    local mtbl = twiss {sequence=seq, nslice=10, save='atbody'}
    plot { table=mtbl, sequence=seq, fontsize=18, styles='lines',
           x1y1 = { s={'beta11','beta22'} },
           x1y2 = { s={'mu1'   ,'mu2'   } } }
  end

  -- match phase advance
  local status, fmin, ncall = match {
    command := twiss { sequence=seq, observe=1 },
    variables = {
      { var = 'seq.mq1.k1', min= 0.2, max= 0.4 },
      { var = 'seq.mq2.k1', min=-0.4, max=-0.2 },
    },
    equalities = {
      { expr = \t -> t['$end'].mu1-0.25 },
      { expr = \t -> t['$end'].mu2-0.25 },
    },
    objective = {
      fmin = 1e-8, maxcall = 50, !summary=2,
    },
  }

  -- check results
  assertEquals      (status    ,  'NLOPT_FMIN_REACHED'   )
  assertEquals      (ncall     ,  31                     )
  assertAlmostEquals(fmin      ,  1.4720925152e-15, 1e-16)
  assertAlmostEquals(seq.mq1.k1,  0.29599989525034, 1e-12)
  assertAlmostEquals(seq.mq2.k1, -0.30241971341642, 1e-12)

  if doplot then
    -- plot betas and phases
    local mtbl = twiss {sequence=seq, nslice=10, save='atbody'}
    plot { table=mtbl, sequence=seq, fontsize=18, styles='lines',
           x1y1 = { s={'beta11','beta22'} },
           x1y2 = { s={'mu1'   ,'mu2'   } } }
    plot { table=mtbl, sequence=seq, fontsize=18, !styles='lines',
           x1y1 = { s={'beta11','beta22'} },
           x1y2 = { s={'mu1'   ,'mu2'   } } }
  end
end

-- Function matching ----------------------------------------------------------o

-- Example from NLOpt tutorial

function TestMatch:testMatchFunc ()
  local x_ = {1.234, 5.678}

  local printf in MAD.utility

  local function myfn (x, grad)
    if grad then
      grad[1] = 0.0
      grad[2] = 0.5 / sqrt(x[2])
    end
    return sqrt(x[2])
  end

  local function myle (r, x, grad)
    local a, b = 2, 0
    if grad then
      grad[1] = 3 * a * (a*x[1] + b) * (a*x[1] + b)
      grad[2] = -1.0
    end
    r[1] = ((a*x[1] + b) * (a*x[1] + b) * (a*x[1] + b) - x[2])

    local a, b = -1, 1
    if grad then
      grad[3] = 3 * a * (a*x[1] + b) * (a*x[1] + b)
      grad[4] = -1.0
    end
    r[2] = ((a*x[1] + b) * (a*x[1] + b) * (a*x[1] + b) - x[2])
  end

  -- match test
  local status, fmin, ncall = match {
    variables = {
      { var = 'x_[1]', min = -inf },
      { var = 'x_[2]', min =  0   },
      tol = 1e-4, -- relative tolerance for all variables
    },
    inequalities = {
      {}, {}, tol = 1e-8,
      exec = myle,
    },
    objective = {
      method = 'NLOPT_LD_MMA', fmin = 1e-8, maxcall = 100, !debug=1, !summary=2,
      exec = myfn,
    },
  }

  assertEquals      (status, 'NLOPT_XTOL_REACHED')
  assertEquals      (ncall , 11)
  assertAlmostEquals(fmin  , 0.54433104738223, 1e-15)
  assertAlmostEquals(x_[1] , 0.33333333482478, 1e-12)
  assertAlmostEquals(x_[2] , 0.29629628914424, 1e-12)
end

-- Example from Octave tutorial (unstable!!)
-- Note: Octave does not succeed to find a solution

function TestMatch:testMatchFunc2 ()
  local vector in MAD
  local exp    in math

  local x = vector {-1.8, 1.7, 1.9, -0.8, -0.8}

  local status, fmin, ncall = match {
    variables = {
      { var = 'x[1]' },
      { var = 'x[2]' },
      { var = 'x[3]' },
      { var = 'x[4]' },
      { var = 'x[5]' },
    },
    equalities = {
      { expr := x:sumsqr() - 10         },
      { expr := x[2]*x[3] - 5*x[4]*x[5] },
      { expr := x[1]^3+x[2]^3+1         },
    },
    objective = {
      fmin = 1e-15, maxcall = 500, !summary=2, debug=2,
      exec := exp(x:prod()) - 0.5*(x[1]^3+x[2]^3+1)^2,
    },
  }

  assertEquals      (status, 'NLOPT_FMIN_REACHED')
  assertAlmostEquals(fmin  , 8.53e-16, 1e-15)
  assertTrue        (ncall <= 250)
end

-- end ------------------------------------------------------------------------o
