--[=[
 o-----------------------------------------------------------------------------o
 |
 | Range module regression tests
 |
 | Methodical Accelerator Design - Copyright CERN 2015+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 |          A.Z. Teska, aleksandra.teska at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

	Purpose:
	- Provide regression test suites for the range module.

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local assertEquals, assertAlmostEquals, assertTrue, assertFalse,
			assertErrorMsgContains, assertNil, assertNaN, assertIsString
			in require 'luaunit'

local range   , nrange   , irange   , is_range,
			logrange, nlogrange, ilogrange, is_logrange,
			tiny, eps, huge, inf, nan in MAD
local is_function in MAD

-- regression test suite ------------------------------------------------------o

TestRange = {}

local values = {
  lim   = { tiny, eps, huge },
  num   = {0, tiny, 2^-64, 2^-63, 2^-53, eps, 2^-52, 2*eps, 2^-32, 2^-31, 1e-9,
          0.1-eps, 0.1, 0.1+eps, 0.5, 0.7-eps, 0.7, 0.7+eps, 1-eps, 1, 1+eps,
          1.1, 1.7, 2, 10, 1e2, 1e3, 1e6, 1e9, 2^31, 2^32, 2^52, 2^53,
          2^63, 2^64, huge },
	rng   = {
			 	  { 1 , 10, 0.1}, { 1 ,-10,-0.1}, {-1 , 10, 0.1}, {-1 ,-10,-0.1},
			    { 10, 1 ,-0.1}, { 10,-1 ,-0.1}, {-10, 1 , 0.1}, {-10,-1 , 0.1},
			    { 10, 10, 0.1}, {-10,-10,-0.1},
			    },
  empty = {
				  { 1 , 10,-0.1}, { 1 ,-10, 0.1}, {-1 ,-10, 0.1}, {-1 , 10,-0.1},
				  { 10, 1 , 0.1}, { 10,-1 , 0.1}, {-10, 1 ,-0.1}, {-10,-1 ,-0.1},
				  },
  zeros = {
				  { 0 , 0 , 0  }, {-0 ,-0 ,-0  }, { 1 , 10, 0  }, { 1 , 10,-0  },
				  },
}

function TestRange:testConcatCtor()
	local a = 2
	assertTrue( is_range(0..9..0.5)      )
	assertTrue( is_range(0..9.. .5)      )
	assertTrue( is_range(0..0.9..0.5)    )
	assertTrue( is_range(0.. .9.. .5)    )
	assertTrue( is_range(0.1..0.9..0.5)  )
	assertTrue( is_range( .1.. .9.. .5)  )
	assertTrue( is_range(0..9..-0.5)     )
	assertTrue( is_range(0..9..- .5)     )
	assertTrue( is_range(0..-0.9..0.5)   )
	assertTrue( is_range(0..- .9.. .5)   )
	assertTrue( is_range(-0.1..0.9..0.5) )
	assertTrue( is_range(- .1.. .9.. .5) )
  assertEquals( 1..10     , range(1,10)     )
	assertEquals(  a..a     , range( a, a)    )
	assertEquals( -a..-a    , range(-a,-a)    )
	assertEquals(  a..a..a  , range( a, a, a) )
	assertEquals( -a..-a..-a, range(-a,-a,-a) )

	for _,v in ipairs(values.rng) do
		assertEquals( range(v[1],v[2],v[3]), v[1]..v[2]..v[3]  )
	end
	for _,v in ipairs(values.empty) do
		assertEquals( range(v[1],v[2],v[3]), v[1]..v[2]..v[3]  )
	end
	for _,v in ipairs(values.zeros)do
		assertEquals( range(v[1],v[2],v[3]), v[1]..v[2]..v[3]  )
	end
	for _,v in ipairs(values.num) do
		assertEquals( range( 1, 10, v),  1..10.. v )
		assertEquals( range( 1, 10,-v),  1..10..-v )
	end
  for _,v in ipairs(values.lim) do
    assertEquals( range( 1 , 10, v ),  1.. 10.. v )
    assertEquals( range( 10, 1 ,-v ),  10..1 ..-v )
    assertEquals( range( 1 , v , v ),  1.. v .. v )
    assertEquals( range( 1 ,-v ,-v ),  1..-v ..-v )
    assertEquals( range( v , v , v ),  v.. v .. v )
    assertEquals( range(-v ,-v ,-v ), -v..-v ..-v )
	end

	assertIsString( 1..''    )
	assertIsString( 1..10..'')
	assertIsString( a..a..'' )
end

function TestRange:testConstructor()
	local a = 2
	local msg = {
		"invalid argument #1 (finite number expected)",
		"invalid argument #2 (finite number expected)",
		"invalid argument #3 (finite number expected)",
	}
	assertErrorMsgContains( msg[1], range                )
	assertErrorMsgContains( msg[1], range, nil, 1        )
	assertErrorMsgContains( msg[1], range, 1..10..2      )
	assertErrorMsgContains( msg[1], range, ''            )
	assertErrorMsgContains( msg[2], range, 1  , ''       )
	assertErrorMsgContains( msg[3], range, 1  , 10 , ''  )
	assertErrorMsgContains( msg[3], range, 1  , 10 , nan )
	assertErrorMsgContains( msg[3], range, 10 , 1  ,-nan )
	assertErrorMsgContains( msg[2], range, 1  , nan, nan )
	assertErrorMsgContains( msg[2], range, 1  ,-nan,-nan )
	assertErrorMsgContains( msg[1], range, nan, nan, nan )
	assertErrorMsgContains( msg[1], range, nan,-nan,-nan )
	assertErrorMsgContains( msg[3], range, 1  , 10 , inf )
	assertErrorMsgContains( msg[3], range, 10 , 1  ,-inf )
	assertErrorMsgContains( msg[2], range, 1  , inf, inf )
	assertErrorMsgContains( msg[2], range, 1  ,-inf,-inf )
	assertErrorMsgContains( msg[1], range, inf, inf, inf )
	assertErrorMsgContains( msg[1], range, inf,-inf,-inf )

	assertTrue( is_range( range( a, a)   ) )
	assertTrue( is_range( range(-a,-a)   ) )
	assertTrue( is_range( range( a, a, a)) )
	assertTrue( is_range( range(-a,-a,-a)) )

	for _,v in ipairs(values.rng) do
		assertTrue( is_range( range(v[1],v[2],v[3]) ) )
	end
	for _,v in ipairs(values.empty) do
		assertTrue( is_range( range(v[1],v[2],v[3]) ) )
	end
	for _,v in ipairs(values.zeros) do
		assertTrue( is_range( range(v[1],v[2],v[3]) ) )
	end
	for _,v in ipairs(values.num) do
		assertTrue( is_range(range( 1, 10, v)) )
		assertTrue( is_range(range( 1, 10,-v)) )
	end
  for _,v in ipairs(values.lim) do
		assertTrue( is_range(range( 1,  10, v)) )
		assertTrue( is_range(range( 10, 1 ,-v)) )
		assertTrue( is_range(range( 1 , v , v)) )
		assertTrue( is_range(range( 1 ,-v ,-v)) )
		assertTrue( is_range(range( v , v , v)) )
		assertTrue( is_range(range(-v ,-v ,-v)) )
	end
end

function TestRange:testFields()
	assertEquals( {range( 1 )          :range()}, { 1 , 1  , 1}   )
	assertEquals( {     ( 10..1 )      :range()}, { 10, 1  , 1}   )
	assertEquals( {range( 0 ,1  , eps) :range()}, { 0 , 1  , eps} )
	assertEquals( {range( 1 ,0  ,-eps) :range()}, { 1 , 0  ,-eps} )
	assertEquals( {range( 0 ,0.5, eps) :range()}, { 0 , 0.5, eps} )
	assertEquals( {range( 1 ,0.5,-eps) :range()}, { 1 , 0.5,-eps} )

	for _,v in ipairs(values.rng)do
		assertEquals( {range(v[1],v[2],v[3]):range()}, {v[1],v[2],v[3]} )
	end
	for _,v in ipairs(values.empty) do
		assertEquals( {(v[1]..v[2]..v[3])   :range()}, {v[1],v[2],v[3]} )
	end
	for _,v in ipairs(values.zeros) do
		assertEquals( {range(v[1],v[2],v[3]):range()}, {v[1],v[2],v[3]} )
	end
	for _,v in ipairs(values.num) do
		assertEquals( {range( 1 , 10, v):range()}, { 1 , 10, v} )
		assertEquals( {range( 10, 1 ,-v):range()}, { 10, 1 ,-v} )
	end
	local r
	for _,v in ipairs(values.lim) do
		assertEquals( {range( 1 , 10, v):range()}, { 1 , 10, v} )
		assertEquals( {range( 10, 1 ,-v):range()}, { 10, 1 ,-v} )
		assertEquals( {range( 1 ,-v ,-v):range()}, { 1 ,-v ,-v} )
		assertEquals( {range( v , v , v):range()}, { v , v , v} )
		assertEquals( {range(-v ,-v ,-v):range()}, {-v ,-v ,-v} )
		r = { range( 1, v , v):range() }
		assertEquals( r[1], 1 )
		assertAlmostEquals( r[2], v, eps )
		assertAlmostEquals( r[3], v, eps )
	end
end

function TestRange:testReadonly()
	local f1, f2, f3
	local msg = {
		"attempt to write to constant location",
	}
	for _,v in ipairs(values.num) do
		f1=\r,v => r.start = v end
		assertErrorMsgContains( msg[1], f1,  1..10..0.1        , v )
		assertErrorMsgContains( msg[1], f1,  range( 1, 10, 0.1), v )
		assertErrorMsgContains( msg[1], f1, nrange( 1, 10, 10 ), v )
		f2=\r,v => r.stop  = v end
		assertErrorMsgContains( msg[1], f2,  1..10..0.1        , v )
		assertErrorMsgContains( msg[1], f2,  range( 1, 10, 0.1), v )
		assertErrorMsgContains( msg[1], f2, nrange( 1, 10, 10 ), v )
		f3=\r,v => r.step  = v end
		assertErrorMsgContains( msg[1], f3,  1..10..0.1        , v )
		assertErrorMsgContains( msg[1], f3,  range( 1, 10, 0.1), v )
		assertErrorMsgContains( msg[1], f3, nrange( 1, 10, 10 ), v )
	end
end

function TestRange:testValue()
  assertNaN( nrange( 1, 10, 1):value( nan) )
  assertNaN(  range( 1, 10, 1):value( nan) )
  assertNaN(  range( 1, 10, 0):value( inf) )
  assertNaN(  range( 1, 10, 0):value( inf) )

	for _,v in ipairs(values.empty) do
		assertEquals( range(v[1],v[2],v[3]):value(0), v[1] )
	end
	for _,v in ipairs(values.zeros) do
		assertEquals( range(v[1],v[2],v[3]):value(0), v[1] )
		assertEquals( range(v[1],v[2],v[3]):value(1), v[1] )
	end
	for _,v in ipairs(values.rng) do
		assertEquals( range(v[1],v[2],v[3]):value(0), v[1] )
	end
  for _,v in ipairs(values.num) do
    assertAlmostEquals( (0.. 1.. v) :value(1)-  v, 0, eps )
    assertAlmostEquals( (0..-1..-v) :value(1)- -v, 0, eps )
  end

  assertEquals(  range( 1, 10, 0.1) :value(-1 ) , 0.9   )
  assertEquals(  range( 1, 10, 0.1) :value( 11) , 2.1   )
  assertEquals(  range( 1, 10, 0  ) :value( 1 ) , 1     )
  assertEquals( nrange( 1, 10, 1  ) :value( 1 ) , huge  )

  assertEquals(  (-2..2 .. 0.1)     :value( 0 ) ,-2     )
  assertEquals(  (-2..2 .. 0.1)     :value(-0 ) ,-2     )
  assertEquals(  ( 1..20.. 0.1)     :value( 1 ) , 1.1   )
  assertEquals(  ( 1..20.. 0.1)     :value( 1.1), 1.11  )
  assertEquals(  ( 1..10..-1  )     :value( 0 ) , 1     )
  assertEquals(  ( 1..10..-1  )     :value( 2 ) ,-1     )
  assertEquals(  range( 1, 100, 1  ):value( 99) , 100   )
  assertEquals(  range( 0, 1  , eps):value( 1 ) ,   eps )
  assertEquals(  range( 0, 0.5, eps):value( 2 ) , 2*eps )
  assertEquals( nrange( 1, 100, 100):value( 99) , 100   )
  assertAlmostEquals( (2..-2..-0.1) :value( 22)- -0.2, 0, eps )

	assertEquals( nrange( 1 , 10, 1)  :value( inf) , inf  )
  assertEquals(  range( 10, 1 , 1)  :value( inf) , inf  )
  assertEquals(  range( 10, 1 , 1)  :value(-inf) ,-inf  )
  assertEquals( (0..10)             :value( tiny), tiny )
  assertEquals( (0..10)             :value(-tiny),-tiny )
  assertEquals( (0..10)             :value( huge), huge )
	assertEquals( (0..10)             :value(-huge),-huge )
  assertEquals( (1..0..-0.1)        :value(-eps) , 1    )
  assertAlmostEquals( (0..1..0.1)   :value( eps) - eps, 0, eps )
end

function TestRange:testSize()
  assertEquals( range( 0 , 0 , 0 )  :size(), huge )
	assertEquals( range(-0 ,-0 ,-0 )  :size(), huge )
  assertEquals( range( 1 , 1 , 0 )  :size(), huge )
  assertEquals( range( 9 , 9 , 0 )  :size(), huge )
  assertEquals( range( 1 , 10, 0 )  :size(), huge )
  assertEquals( range( 1 )          :size(), 1    )
  assertEquals( range( 2 , 10, huge):size(), 1    )
  assertEquals( range( 10,  2,-huge):size(), 1    )

  for _,v in ipairs(values.empty) do
    assertEquals( range(v[1],v[2],v[3]):size(), 0 )
  end

  assertAlmostEquals( range( eps, 1  , eps):size() - 1/eps      , 0, eps )
  assertAlmostEquals( range( 1  , eps,-eps):size() - 1/eps      , 0, eps )
  assertAlmostEquals( range( eps, 0.5, eps):size() - 0.5/eps    , 0, eps )
  assertAlmostEquals( range( 0.5, eps,-eps):size() - 0.5/eps    , 0, eps )
  assertAlmostEquals( range( 0  , 1  , eps):size() - 1/eps - 1  , 0, eps )
  assertAlmostEquals( range( 1  , 0  ,-eps):size() - 1/eps - 1  , 0, eps )
  assertAlmostEquals( range( 0  , 0.5, eps):size() - 0.5/eps - 1, 0, eps )
  assertAlmostEquals( range( 0.5, 0  ,-eps):size() - 0.5/eps - 1, 0, eps )

  assertEquals( range( 1 , 10   )  :size(), 10   )
  assertEquals( range(-1 ,-10,-1)  :size(), 10   )
  assertEquals( range( 10, 1 ,-1)  :size(), 10   )
  assertEquals( range(-10,-1    )  :size(), 10   )
  assertEquals( range( 1 ,-10,-1)  :size(), 12   )
  assertEquals( range(-1 , 10   )  :size(), 12   )
  assertEquals( range( 10,-1 ,-1)  :size(), 12   )
  assertEquals( range(-10, 1    )  :size(), 12   )

  assertEquals( range( 1 , 10, 0.1):size(), 91   )
  assertEquals( range(-1 ,-10,-0.1):size(), 91   )
  assertEquals( range( 10, 1 ,-0.1):size(), 91   )
  assertEquals( range(-10,-1 , 0.1):size(), 91   )
  assertEquals( range( 1 ,-10,-0.1):size(), 111  )
  assertEquals( range(-1 , 10, 0.1):size(), 111  )
  assertEquals( range( 10,-1 ,-0.1):size(), 111  )
  assertEquals( range(-10, 1 , 0.1):size(), 111  )
  assertEquals( range( 1 , 10, 0.5):size(), 19   )
  assertEquals( range( 1 ,-10,-0.5):size(), 23   )

  assertEquals( (0..2.1 ..1)       :size(), 3    )
  assertEquals( (0..2.9 ..1)       :size(), 3    )
  assertEquals( (1..10^3..1)       :size(), 10^3 )
  assertEquals( (1..10^3..2)       :size(), 500  )
  assertEquals( nrange(2, 10, nil) :size(), 100  )
  assertEquals( nrange(2, 10, 1.1) :size(), 2    )
  assertEquals( nrange(1, 32, 9  ) :size(), 9    )
  assertEquals( nrange(1, 32, 10 ) :size(), 10   )

  local r, nr, v
  v  = {
    { 1  , 100, 100},
    { 1  , 100, 10 },
    { 100, 1  , 10 },
    { 1  ,-100, 10 },
    { 100,-1  , 10 },
    {-1  , 100, 10 },
    {-100, 1  , 10 },
    {-1  ,-100, 10 },
    {-100,-1  , 10 },
    { 1  , 0  , 1/eps },
    { 0.5, 1  , 1/eps },
  }
  for _,v in ipairs(v) do
    nr = nrange(v[1],v[2],v[3])
    for i = 0,100 do
      nr = nrange(v[1],v[2],( nr:size()) )
      assertEquals( nr:size(), v[3] )
      i = i + 1
    end
  end

  assertEquals( (0..24..4)        :size(), #(0..24..4)      )
  assertEquals( nrange(1,32,9)    :size(), #nrange(1,32,9)  )
  assertTrue( (1 .. 20.. 1.9):size() == (-1..-20..-1.9):size() )
  assertTrue( (1 .. 22.. 2.1):size() == (-1..-22..-2.1):size() )
end

function TestRange:testStep()
  assertEquals( nrange( 1 , 1 , 1    ).step, huge )
  assertEquals( nrange( 1 , 10, 0    ).step,-huge )
  assertEquals( nrange( 1 , 10, 0.1  ).step, huge )
  assertEquals( nrange( 1 , 10, 1    ).step, huge )
  assertEquals( nrange( 1 , 10, 2    ).step, 9    )
  assertEquals( nrange(-1 ,-10, 1    ).step,-huge )
  assertEquals( nrange( 1 , 10, tiny ).step, huge )
  assertEquals( nrange( 1 , 10, eps  ).step, huge )
  assertEquals( nrange( 1 , 10, inf  ).step, 0    )
  assertEquals( nrange( 10, 10, 2    ).step, 0    )
  assertEquals( nrange(-10,-10, 2    ).step, 0    )
  assertEquals( nrange( 1 , 10, 10   ).step, 1    )
  assertEquals( nrange( 1 , 10, 1+eps).step, 9    )
  assertEquals( nrange( 1 , 10, 1.1  ).step, 9    )

  assertAlmostEquals( nrange( 1, 10, 1e6).step, 9.000009000009e-06, eps )
  assertAlmostEquals( nrange( 1, 10, 1e9).step, 9.000000009e-09   , eps )
  --assertEquals( nrange( 1, 10, huge).step, 5.0064161816412e-308 )
end

function TestRange:testStepEq()
  local r, cr, r1, v
  r  = range( 1, 10, tiny)
  r1 = range( 1, 10, tiny, r:size())
  cr = 1..10..tiny
  assertFalse( r  == r1 )
  assertFalse( cr == r1 )
  assertTrue ( r  == cr )

  r  = range( 1, 10, eps)
  r1 = range( 1, 10, eps, r:size())
  cr = 1..10..eps
  assertTrue ( r  == r1 )
  assertTrue ( cr == r1 )
  assertTrue ( r  == cr )

  r  = range( 1, 10, huge)
  r1 = range( 1, 10, huge, r:size())
  cr = 1..10..huge
  assertTrue ( r  == r1 )
  assertTrue ( cr == r1 )
  assertTrue ( r  == cr )

  v = { 2, 10, 1e2, 1e3, 1e6, 1e9, 2^31, 2^32, 2^52, 2^53, 2^63, 2^64 }
  for _,v in ipairs(v) do
    r1 = range( 1, v, 1, v)
    r  = range( 1, v, 1)
    assertTrue( r == r1 )
  end

  v = { { 0.1+eps, 90 }, { 0.7-eps, 13 }, { 0.7, 13 }, { 0.7+eps, 13 },
        { 1  +eps, 9  }, { 1.1    , 9  }, { 1.7, 6  }, { 2      , 5  },}
  for _,v in ipairs(v) do
    r1 = range( 1, 10, v[1], v[2])
    r  = range( 1, 10, v[1]      )
    assertEquals( r:size(), v[2] )
    assertFalse( r == r1 )
  end

  v = { { 0.5, 19 }, { 1 - eps, 10 }, { 1, 10 },}
  for _,v in ipairs(v) do
    r1 = range( 1, 10, v[1], v[2])
    r  = range( 1, 10, v[1]      )
    assertEquals( r:size(), v[2] )
    assertTrue( r == r1 )
  end
end

function TestRange:testAdjust()
  -- to be done in this fun: clean up, range(1,10,1,v), difrent values, all the ideas, maybe movin it to cnstr
  local r, cr, r1, v
  v = { { 0.1+eps, 90 ,0.0011235955056177 },
        { 0.7-eps, 13 ,0.05   },
        { 0.7    , 13 ,0.05   },
        { 0.7+eps, 13 ,0.05   },
        { 1  +eps, 9  ,0.125  },
        { 1.1    , 9  ,0.025  },
        { 1.7    , 6  ,0.1    },
        { 2      , 5  ,0.25   },
      }
  for _,v in ipairs(v) do
    r  = range( 1, 10, v[1])
    cr = 1..10..v[1]
    r1 = range( 1, 10, v[1], v[2])
    assertEquals( r.step  , cr.step )
    assertAlmostEquals( r.step - r1.step + v[3], 0,2*eps )
  end

  v = { { 0.5, 19 }, { 1 - eps, 10 }, { 1, 10 },}
  for _,v in ipairs(v) do
    r  = range( 1, 10, v[1])
    cr = 1..10..v[1]
    r1 = range( 1, 10, v[1], v[2])
    assertEquals( r.step, cr.step )
    assertAlmostEquals( r.step - r1.step, 0, eps )
  end
  v = {1e2, 1e3, 1e6, 1e9, 2^31, 2^32, 2^52, 2^53, 2^63, 2^64, huge }
for _,v in ipairs(v) do
    r  = range( 1, 10, v)
    cr = 1..10..v
    r1 = range( 1, 10, v, 1)
    assertEquals( r.step, cr.step )
    assertEquals( r1.step, huge )
    --assertAlmostEquals( r.step - r1.step, 0, eps )
  end

  for _,v in ipairs(values.rng) do
    r  = range(v[1],v[2],v[3])
    cr = v[1]..v[2]..v[3]
    assertEquals( r.step , cr.step  )
  end
  for _,v in ipairs(values.zeros)do
    r  = range(v[1],v[2],v[3])
    cr = v[1]..v[2]..v[3]
    assertEquals( r.step , cr.step  )
  end
  for _,v in ipairs(values.empty) do
    r  = range(v[1],v[2],v[3])
    cr = v[1]..v[2]..v[3]
    assertAlmostEquals( r.step - cr.step, 0, eps )
  end
  for _,v in ipairs(values.lim)
    do
    r  = range( 1, 10, v)
    r1 = range( 0, 10, v, r:size())
    cr = 1..10..v
    assertAlmostEquals( r.step - cr.step, 0, eps )
    assertAlmostEquals( r.step - r1.step, 0, eps )
    r  = range( 10, 1 ,-v)
    r  = range( 10, 1 ,-v, r:size())
    cr = 10..1..-v
    assertAlmostEquals( r.step - cr.step, 0, eps )
  end
end

function TestRange:testIsEmpty()
  for _,v in ipairs(values.empty) do
    assertTrue ( range(v[1],v[2],v[3]):is_empty() )
  end
  for _,v in ipairs(values.zeros) do
    assertFalse( range(v[1],v[2],v[3]):is_empty() )
  end
  for _,v in ipairs(values.rng) do
    assertFalse( range(v[1],v[2],v[3]):is_empty() )
  end
  assertFalse( range( 1 )             :is_empty() )
  assertFalse( range( 1, 10)          :is_empty() )
  assertFalse( (0.. 1.. eps)          :is_empty() )
  assertFalse( (0..-1..-eps)          :is_empty() )
  assertFalse( nrange( 2, 10, 0.1)    :is_empty() )
  assertFalse( nrange( 0, 9 , 10 )    :is_empty() )

  for _,v in ipairs(values.num) do
    if v~=0 then
      assertFalse( range( 1 , 10, v)  :is_empty() )
      assertFalse( range( 10, 1 ,-v)  :is_empty() )
      assertTrue ( range( 1 , 10,-v)  :is_empty() )
      assertFalse(nrange( 1 , 10, v)  :is_empty() )
    end
  end
  for _,v in ipairs(values.lim) do
    assertFalse(  range( 1 , 10, v)  :is_empty() )
    assertFalse(  range( 10, 1 ,-v)  :is_empty() )
    assertFalse(  range( 1 ,-v ,-v)  :is_empty() )
    assertFalse(  range( v , v , v)  :is_empty() )
    assertFalse(  range(-v ,-v ,-v)  :is_empty() )
    assertFalse( nrange( 10, 1 , v)  :is_empty() )
  end

  assertFalse(  range( 1, huge, huge):is_empty() )
  assertTrue (  range( 1, tiny, tiny):is_empty() )
  assertFalse( nrange( 2, 10  , inf ):is_empty() )
  assertFalse( nrange( 2, 10  , huge):is_empty() )
  assertFalse( nrange( 2, 10  , tiny):is_empty() )
end

function TestRange:testNCnstrFields()
  assertEquals( {nrange( 1, 100 )     :range()}, { 1, 100, 1   } )
  assertEquals( {nrange( 1, 10 , 0.1 ):range()}, { 1, 10 , huge} )
  assertEquals( {nrange( 1, 10 , 1   ):range()}, { 1, 10 , huge} )
  assertEquals( {nrange( 1, 10 , 1.1 ):range()}, { 1, 10 , 9   } )
  assertEquals( {nrange( 1, 10 , 2   ):range()}, { 1, 10 , 9   } )
  assertEquals( {nrange( 1, 0  , huge):range()}, { 1 ,0  ,-0   } )
  assertEquals( {nrange( 1, 0  , tiny):range()}, { 1 ,0  ,-huge} )

  assertEquals( {nrange( 100, 1 )     :range()}, { 100, 1,- 1  } )
  assertEquals( {nrange( 10 , 1, 0.1 ):range()}, { 10 , 1,-huge} )
  assertEquals( {nrange( 10 , 1, 1   ):range()}, { 10 , 1,-huge} )
  assertEquals( {nrange( 10 , 1, 1.1 ):range()}, { 10 , 1,- 9  } )
  assertEquals( {nrange( 10 , 1, 2   ):range()}, { 10 , 1,- 9  } )
  assertEquals( {nrange( 10 , 1, 10  ):range()}, { 10 , 1,- 1  } )

  assertAlmostEquals( nrange( 0, 1  , 1/eps).step -  eps, 0, eps )
  assertAlmostEquals( nrange( 1, 0  , 1/eps).step - -eps, 0, eps )
  assertAlmostEquals( nrange( 0, 0.5, 1/eps).step -  eps, 0, eps )
  assertAlmostEquals( nrange( 1, 0.5, 1/eps).step - -eps, 0, eps )
  assertEquals(  nrange( 1 , 32, 9).step, 3.875 )
  assertEquals(  nrange( 32, 1 , 9).step,-3.875 )
end

function TestRange:testEqual()
  local r, nr
  r = range( 1 , 20, 0  ) assertTrue( range(r:range()) == r )
  r = range( 1 , 20, 0.1) assertTrue( range(r:range()) == r )
  r = nrange(1 , 10, 1  ) assertTrue( range(r:range()) == r )

  for _,v in ipairs(values.num) do
    r = range( 1 , 10, v) assertTrue( range(r:range()) == r )
    r = range( 10, 1 ,-v) assertTrue( range(r:range()) == r )
    r = range( 1 , v , v) assertTrue( range(r:range()) == r )
    r = range( 1 ,-v ,-v) assertTrue( range(r:range()) == r )
    r = range( v , v , v) assertTrue( range(r:range()) == r )
    r = range(-v ,-v ,-v) assertTrue( range(r:range()) == r )
    r = range(-v ,-v ,-v) assertTrue( range(r:range()) == r )
  end

  for _,v in ipairs(values.empty) do
    r = range(v[1],v[2],v[3]) assertTrue( range(r:range()) == r )
  end
  for _,v in ipairs(values.zeros) do
    r = range(v[1],v[2],v[3]) assertTrue( range(r:range()) == r )
  end
  for _,v in ipairs(values.rng) do
    r = range(v[1],v[2],v[3]) assertTrue( range(r:range()) == r )
  end
end

function TestRange:testBounds()
  -- should test specific values
  local b
  for _,v in ipairs(values.num) do
    if v == 0 or v == tiny or v == huge or v > 20 then
      assertEquals( { range( 1 , 20, v):bounds()}, { 1 , 1 } )
      assertEquals( { range( 20, 1 ,-v):bounds()}, { 20, 20} )
    elseif v <= 0.1 then
      b = { range( 1 ,20, v):bounds() }
      assertAlmostEquals( b[1] - 1 , 0,     eps )
      assertAlmostEquals( b[2] - 20, 0, 200*eps )
      b = { range( 20, 1,-v):bounds() }
      assertAlmostEquals( b[1] - 1 , 0, 200*eps )
      assertAlmostEquals( b[2] - 20, 0, 200*eps )
    end
  end

  b = { range( 1 , 20, 0.1+eps):bounds() }
  assertAlmostEquals( b[2] - 19.9, 0, 220*eps )
  b = { range( 1 , 20, 0.7-eps):bounds() }
  assertAlmostEquals( b[2] - 19.9, 0, 100*eps )
  b = { range( 1 , 20, 0.7 )   :bounds() }
  assertAlmostEquals( b[2] - 19.9, 0, 100*eps )
  b = { range( 1 , 20, 0.7+eps):bounds() }
  assertAlmostEquals( b[2] - 19.9, 0, 100*eps )
  b = { range( 1 , 20, 1 - eps):bounds() }
  assertAlmostEquals( b[2] - 20  , 0,  50*eps )
  b = { range( 1 , 20, 1 + eps):bounds() }
  assertAlmostEquals( b[2] - 19  , 0,  50*eps )
  b = { range( 1 , 20, 1.1 )   :bounds() }
  assertAlmostEquals( b[2] - 19.7, 0,  20*eps )

  assertEquals( { range( 1 , 20, 0.5):bounds()}, {1 , 20   } )
  assertEquals( { range( 1 , 20, 1  ):bounds()}, {1 , 20   } )
  assertEquals( { range( 1 , 20, 1.7):bounds()}, {1 , 19.7 } )
  assertEquals( { range( 1 , 20, 2  ):bounds()}, {1 , 19   } )
  assertEquals( { range( 1 , 20, 10 ):bounds()}, {1 , 11   } )

  for _,v in ipairs(values.num) do
    if v == 0 then
      assertEquals( {nrange( 1 , 20, v):bounds()}, {nil,nil} )
    elseif v <= 1 then
      assertEquals( {nrange( 1 , 20, v):bounds()}, {1 , 1 } )
      assertEquals( {nrange( 20, 1 , v):bounds()}, {20, 20})
    else
    end
  end
  for _,v in ipairs(values.rng) do
    if v[3] < 0 then
      assertEquals( {range(v[1],v[2],v[3]):bounds()}, {v[2],v[1]})
    else
      assertEquals( {range(v[1],v[2],v[3]):bounds()}, {v[1],v[2]})
    end
  end
  for _,v in ipairs(values.empty) do
    assertEquals( {range(v[1],v[2],v[3])  :bounds()}, {nil,nil})
  end
  for _,v in ipairs(values.zeros) do
    assertEquals( {range(v[1],v[2],v[3]):bounds()}, {v[1],v[1]})
  end
  assertEquals( { range( 1 )          :bounds()}, { 1  , 1  } )
  assertEquals( { range( 1 , 0 )      :bounds()}, { nil, nil} )
  assertEquals( { range( 1 , 20, huge):bounds()}, { 1  , 1  } )
  assertEquals( {nrange( 1 , 20, huge):bounds()}, { 1  , 20 } )
  assertEquals( {nrange( 1 , 20, tiny):bounds()}, { 1  , 1  } )
end

function TestRange:testIsRange()
  assertFalse( is_range('') )
  assertFalse( is_range(2)  )
  assertFalse( is_range(logrange(1,10^6,10)) )
  assertFalse( is_range(nlogrange(1,10,10))  )
  assertTrue ( is_range(range(1))            )
  assertTrue ( is_range(1..10)               )
  assertTrue ( is_range(1..10..0.1)          )
  assertTrue ( is_range(nrange( 1, 10, 10))  )
  assertTrue ( is_range(nrange( 1, 10, 1 ))  )
end
