--[=[
 o-----------------------------------------------------------------------------o
 |
 | Range module regression tests
 |
 | Methodical Accelerator Design - Copyright CERN 2015+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 |          A.Z. Teska, aleksandra.teska at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

	Purpose:
	- Provide regression test suites for the range module.

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local assertEquals, assertAlmostEquals, assertTrue, assertFalse,
			assertErrorMsgContains, assertNil, assertNaN, assertIsString
			in require 'luaunit'

local range   , nrange   , irange   , inrange   , is_range,
      logrange, nlogrange, ilogrange, inlogrange, is_logrange, log,
      tiny, eps, huge, inf, nan in MAD
local is_function in MAD

-- regression test suite ------------------------------------------------------o

TestRange = {}

local values = {
  lim   = { tiny, eps, huge },
  num   = {0, tiny, 2^-64, 2^-63, 2^-53, eps, 2^-52, 2*eps, 2^-32, 2^-31, 1e-9,
          0.1-eps, 0.1, 0.1+eps, 0.5, 0.7-eps, 0.7, 0.7+eps, 1-eps, 1, 1+eps,
          1.1, 1.7, 2, 10, 1e2, 1e3, 1e6, 1e9, 2^31, 2^32, 2^52, 2^53,
          2^63, 2^64, huge },
	rng   = {
			 	  { 1 , 10, 0.1}, { 1 ,-10,-0.1}, {-1 , 10, 0.1}, {-1 ,-10,-0.1},
			    { 10, 1 ,-0.1}, { 10,-1 ,-0.1}, {-10, 1 , 0.1}, {-10,-1 , 0.1},
			    { 10, 10, 0.1}, {-10,-10,-0.1},
			    },
  empty = {
				  { 1 , 10,-0.1}, { 1 ,-10, 0.1}, {-1 ,-10, 0.1}, {-1 , 10,-0.1},
				  { 10, 1 , 0.1}, { 10,-1 , 0.1}, {-10, 1 ,-0.1}, {-10,-1 ,-0.1},
				  },
  zeros = {
				  { 0 , 0 , 0  }, {-0 ,-0 ,-0  }, { 1 , 10, 0  }, { 1 , 10,-0  },
				  },
}

function TestRange:testRawCtor()
	local a = 2
	assertTrue( is_range(0..9..0.5)      )
	assertTrue( is_range(0..9.. .5)      )
	assertTrue( is_range(0..0.9..0.5)    )
	assertTrue( is_range(0.. .9.. .5)    )
	assertTrue( is_range(0.1..0.9..0.5)  )
	assertTrue( is_range( .1.. .9.. .5)  )
	assertTrue( is_range(0..9..-0.5)     )
	assertTrue( is_range(0..9..- .5)     )
	assertTrue( is_range(0..-0.9..0.5)   )
	assertTrue( is_range(0..- .9.. .5)   )
	assertTrue( is_range(-0.1..0.9..0.5) )
	assertTrue( is_range(- .1.. .9.. .5) )

	assertIsString( 1..''    )
	assertIsString( 1..10..'')
	assertIsString( a..a..'' )
end

function TestRange:testFields()
  assertEquals( {( 10..1 )        :range()}, { 10, 1  , 1}   )
  assertEquals( {( 0 ..1  .. eps) :range()}, { 0 , 1  , eps} )
  assertEquals( {( 1 ..0  ..-eps) :range()}, { 1 , 0  ,-eps} )
  assertEquals( {( 0 ..0.5.. eps) :range()}, { 0 , 0.5, eps} )
  assertEquals( {( 1 ..0.5..-eps) :range()}, { 1 , 0.5,-eps} )

  for _,v in ipairs(values.rng)do
    assertEquals( {(v[1]..v[2]..v[3]):range()}, { v[1], v[2], v[3] } )
  end
  for _,v in ipairs(values.empty) do
    assertEquals( {(v[1]..v[2]..v[3]):range()}, { v[1], v[2], v[3] } )
  end
  for _,v in ipairs(values.zeros) do
    assertEquals( {(v[1]..v[2]..v[3]):range()}, { v[1], v[2], v[3] } )
  end
  for _,v in ipairs(values.num) do
    assertEquals( {( 1 .. 10.. v):range()}, { 1 , 10, v} )
    assertEquals( {( 10.. 1 ..-v):range()}, { 10, 1 ,-v} )
  end
  local r
  for _,v in ipairs(values.lim) do
    assertEquals( {( 1 .. 10.. v):range()}, { 1 , 10, v} )
    assertEquals( {( 10.. 1 ..-v):range()}, { 10, 1 ,-v} )
    assertEquals( {( 1 ..-v ..-v):range()}, { 1 ,-v ,-v} )
    assertEquals( {( v .. v .. v):range()}, { v , v , v} )
    assertEquals( {(-v ..-v ..-v):range()}, {-v ,-v ,-v} )
    r = { (1..v..v):range() }
    assertEquals( r[1], 1 )
    assertAlmostEquals( r[2], v, eps )
    assertAlmostEquals( r[3], v, eps )
  end
end

function TestRange:testRange()
  local r
  r =  1..10..1 assertEquals( {r:range()}, {r.start, r.stop, r.step} )

  for _,v in ipairs(values.rng) do
    r = v[1]..v[2]..v[3] assertEquals( {r:range()}, {r.start,r.stop,r.step} )
  end
  for _,v in ipairs(values.empty) do
    r = v[1]..v[2]..v[3] assertEquals( {r:range()}, {r.start,r.stop,r.step} )
  end
  for _,v in ipairs(values.zeros) do
    r = v[1]..v[2]..v[3] assertEquals( {r:range()}, {r.start,r.stop,r.step} )
  end
  for _,v in ipairs(values.num) do
    r = 1 ..10.. v  assertEquals( {r:range()}, {r.start, r.stop, r.step} )
    r = 10..1 ..-v  assertEquals( {r:range()}, {r.start, r.stop, r.step} )
  end
  for _,v in ipairs(values.lim) do
    r =  1 .. 10.. v  assertEquals( {r:range()}, {r.start, r.stop, r.step} )
    r =  10.. 1 ..-v  assertEquals( {r:range()}, {r.start, r.stop, r.step} )
    r =  1 .. v .. v  assertEquals( {r:range()}, {r.start, r.stop, r.step} )
    r =  1 ..-v ..-v  assertEquals( {r:range()}, {r.start, r.stop, r.step} )
    r =  v .. v .. v  assertEquals( {r:range()}, {r.start, r.stop, r.step} )
    r = -v ..-v ..-v  assertEquals( {r:range()}, {r.start, r.stop, r.step} )
  end
end

function TestRange:testReadonly()
  local f1, f2, f3
  local msg = {
    "attempt to write to constant location",
  }
  for _,v in ipairs(values.num) do
    f1=\r,v => r.start = v end
    assertErrorMsgContains( msg[1], f1,  1..10..0.1        , v )
    assertErrorMsgContains( msg[1], f1,  range( 1, 10, 0.1), v )
    assertErrorMsgContains( msg[1], f1, nrange( 1, 10, 10 ), v )
    f2=\r,v => r.stop  = v end
    assertErrorMsgContains( msg[1], f2,  1..10..0.1        , v )
    assertErrorMsgContains( msg[1], f2,  range( 1, 10, 0.1), v )
    assertErrorMsgContains( msg[1], f2, nrange( 1, 10, 10 ), v )
    f3=\r,v => r.step  = v end
    assertErrorMsgContains( msg[1], f3,  1..10..0.1        , v )
    assertErrorMsgContains( msg[1], f3,  range( 1, 10, 0.1), v )
    assertErrorMsgContains( msg[1], f3, nrange( 1, 10, 10 ), v )
  end
end

function TestRange:testNanAndInf()
  --print( (1  .. ''        ):range())
  --print( (1  .. 10 .. ''  ):range())

  --print( (1  .. 10 .. nan ):range() )
  --print( (10 .. 1  ..-nan ):range() )
  --print( (1  .. nan.. nan ):range() )
  --print( (1  ..-nan..-nan ):range() )
  --print( (nan.. nan.. nan ):range() )
  --print( (nan..-nan..-nan ):range() )
  --print( (1  .. 10 .. inf ):range() )
  --print( (10 .. 1  ..-inf ):range() )
  --print( (1  .. inf.. inf ):range() )
  --print( (1  ..-inf..-inf ):range() )
  --print( (inf.. inf.. inf ):range() )
  --print( (inf..-inf..-inf ):range() )
end

function TestRange:testIsEmpty()
  for _,v in ipairs(values.empty) do
    assertTrue ( (v[1]..v[2]..v[3]):is_empty() )
  end
  for _,v in ipairs(values.zeros) do
    assertFalse( (v[1]..v[2]..v[3]):is_empty() )
  end
  for _,v in ipairs(values.rng) do
    assertFalse( (v[1]..v[2]..v[3]):is_empty() )
  end
  for _,v in ipairs(values.num) do
    if v~=0 then
      assertFalse( ( 1 .. 10..  v) :is_empty() )
      assertFalse( ( 10.. 1 .. -v) :is_empty() )
      assertTrue ( ( 1 .. 10.. -v) :is_empty() )
    end
  end
  for _,v in ipairs(values.lim) do
    assertFalse(  ( 1 .. 10.. v)  :is_empty() )
    assertFalse(  ( 10.. 1 ..-v)  :is_empty() )
    assertFalse(  ( 1 ..-v ..-v)  :is_empty() )
    assertFalse(  ( v .. v .. v)  :is_empty() )
    assertFalse(  (-v ..-v ..-v)  :is_empty() )
  end

  assertFalse( (1..huge..huge):is_empty() )
  assertTrue ( (1..tiny..tiny):is_empty() )
  assertFalse( (0.. 1  .. eps):is_empty() )
  assertFalse( (0..-1  ..-eps):is_empty() )
end


function TestRange:testValue()
  assertEquals( nrange( 1, 10, 1  ) :value( 1 ) , huge  )
  assertEquals( nrange( 1, 100, 100):value( 99) , 100   )
  assertEquals( nrange( 1 , 10, 1)  :value( inf) , inf  )
  assertEquals( nrange( 1, 10, 0)   :value( inf), -inf )
  assertNaN( nrange( 1, 10, 1):value( nan) )
  assertNaN(  range( 1, 10, 1):value( nan) )
  assertNaN(  range( 1, 10, 0):value( inf) )

  assertNaN( ( 1..10..1):value( nan) )
  assertNaN( ( 1..10..0):value( inf) )

  for _,v in ipairs(values.empty) do
    assertEquals( (v[1]..v[2]..v[3]):value(0), v[1] )
  end
  for _,v in ipairs(values.zeros) do
    assertEquals( (v[1]..v[2]..v[3]):value(0), v[1] )
    assertEquals( (v[1]..v[2]..v[3]):value(1), v[1] )
  end
  for _,v in ipairs(values.rng) do
    assertEquals( (v[1]..v[2]..v[3]):value(0), v[1] )
  end
  for _,v in ipairs(values.num) do
    assertAlmostEquals( (0.. 1.. v) :value(1)-  v, 0, eps )
    assertAlmostEquals( (0..-1..-v) :value(1)- -v, 0, eps )
  end

  assertEquals(  ( 1..10..0.1) :value(-1 ) , 0.9   )
  assertEquals(  ( 1..10..0.1) :value( 11) , 2.1   )
  assertEquals(  ( 1..10..0  ) :value( 1 ) , 1     )

  assertEquals(  (-2..2 .. 0.1)     :value( 0 ) ,-2     )
  assertEquals(  (-2..2 .. 0.1)     :value(-0 ) ,-2     )
  assertEquals(  ( 1..20.. 0.1)     :value( 1 ) , 1.1   )
  assertEquals(  ( 1..20.. 0.1)     :value( 1.1), 1.11  )
  assertEquals(  ( 1..10..-1  )     :value( 0 ) , 1     )
  assertEquals(  ( 1..10..-1  )     :value( 2 ) ,-1     )
  assertEquals(  ( 1..100..1  )     :value( 99) , 100   )
  assertEquals(  ( 0..1  ..eps)     :value( 1 ) ,   eps )
  assertEquals(  ( 0..0.5..eps)     :value( 2 ) , 2*eps )
  assertAlmostEquals( (2..-2..-0.1) :value( 22)- -0.2, 0, eps )

  assertEquals( ( 10..1..1)  :value( inf) , inf  )
  assertEquals( ( 10..1..1)  :value(-inf) ,-inf  )
  assertEquals( (0..10)             :value( tiny), tiny )
  assertEquals( (0..10)             :value(-tiny),-tiny )
  assertEquals( (0..10)             :value( huge), huge )
  assertEquals( (0..10)             :value(-huge),-huge )
  assertEquals( (1..0..-0.1)        :value(-eps) , 1    )
  assertAlmostEquals( (0..1..0.1)   :value( eps) - eps, 0, eps )
end

function TestRange:testGet()
  local r, res, ref
  assertNil( (10.. 1 ..-1  ):get(11)  )
  assertNil( (1 .. 10.. 0.1):get(-1)  )
  assertNil( (1 .. 10.. 0.1):get(101) )

  for _,v in ipairs(values.empty) do
    assertNil ( (v[1]..v[2]..v[3]):get(0) )
  end
  for _,v in ipairs(values.zeros) do
    assertEquals( (v[1]..v[2]..v[3]):get(0), v[1] )
    assertEquals( (v[1]..v[2]..v[3]):get(1), v[1] )
  end
  for _,v in ipairs(values.rng) do
    r = (v[1]..v[2]..v[3])
    assertEquals( r:get(0), v[1] )
    assertAlmostEquals( r:get(#r-1) - v[2], 0, eps )
  end
  assertEquals( (-2..2..0.1)        :get(0)  ,-2    )
  assertEquals( (1..20..0.1)        :get(1.1), 1.11 )
  assertAlmostEquals( (2..-2..-0.1) :get(22)- -0.2, 0, eps )
  assertAlmostEquals( (0..1..0.1)   :get(eps)- eps, 0, eps )

  res = 1..5
  ref = {1, 2, 3, 4, 5}
  for i=1,#res do assertEquals(res:get(i-1), ref[i]) end

  res = 1..10..2
  ref = {1, 3, 5, 7, 9}
  for i=1,#res do assertEquals(res:get(i-1), ref[i]) end

  res = 0.5..0..-0.1
  ref = {0.5, 0.4, 0.3, 0.2, 0.1, 0}
  for i=1,#res do assertAlmostEquals(res:get(i-1) - ref[i], 0, eps) end

  res = 10..-1..-0.7
  ref = {10 , 9.3, 8.6, 7.9, 7.2, 6.5, 5.8, 5.1,
         4.4, 3.7, 3  , 2.3, 1.6, 0.9, 0.2,-0.5 }
  for i=1,#res do
    assertAlmostEquals(res[i] - ref[i], 0, 6*eps) -- 6 eps @ 1.6
  end
end

function TestRange:testIndex()
  local r, res, ref
  assertNil( (1 .. 10.. 0.1)[ 0]   )
  assertNil( (10.. 1 ..-1  )[ 11]  )
  assertNil( (1 .. 10.. 0.1)[-1]   )
  assertNil( (1 .. 10.. 0.1)[ 100] )
  assertNil( (10.. 1 ..-1  )[ 11]  )
  assertNil( (1 .. 10.. 0.1)[ 0.1] )
  for _,v in ipairs(values.empty) do
    assertNil( (v[1]..v[2]..v[3])[1] )
  end
  for _,v in ipairs(values.zeros) do
    assertEquals( (v[1]..v[2]..v[3])[1], v[1] )
    assertEquals( (v[1]..v[2]..v[3])[2], v[1] )
  end
  for _,v in ipairs(values.rng) do
    r = v[1]..v[2]..v[3]
    assertEquals( r[1], v[1] )
    assertAlmostEquals( r[#r] - v[2], 0, eps )
  end
  assertEquals( (1..20..0.1)[2]  , 1.1  )
  assertEquals( (1..20..0.1)[2.1], 1.11 )
  assertAlmostEquals( (2..-2..-0.1)[23]- -0.2, 0, eps )

  res = 1..5
  ref = {1, 2, 3, 4, 5}
  for i=1,#res do assertEquals(res[i], ref[i]) end

  res = 1..10..2
  ref = {1, 3, 5, 7, 9}
  for i=1,#res do assertEquals(res[i], ref[i]) end

  res = 0.5..0..-0.1
  ref = {0.5, 0.4, 0.3, 0.2, 0.1, 0}
  for i=1,#res do assertAlmostEquals(res[i] - ref[i], 0, eps) end

  res = 10..-1..-0.7
  ref = {10 , 9.3, 8.6, 7.9, 7.2, 6.5, 5.8, 5.1,
         4.4, 3.7, 3  , 2.3, 1.6, 0.9, 0.2,-0.5 }
  for i=1,#res do
    assertAlmostEquals(res[i] - ref[i], 0, 6*eps) -- 6 eps @ 1.6
  end
end

function TestRange:testReverse()
  for _,v in ipairs(values.rng) do
    assertEquals( (v[1]..v[2]..v[3]):reverse(), v[2]..v[1]..-v[3] )
  end
  for _,v in ipairs(values.empty) do
    assertEquals( (v[1]..v[2]..v[3]):reverse(), v[2]..v[1]..-v[3] )
  end
  for _,v in ipairs(values.zeros) do
    assertEquals( (v[1]..v[2]..v[3]):reverse(), v[2]..v[1]..-v[3] )
  end
  for _,v in ipairs(values.num) do
    assertEquals( ( 0.. 1.. v):reverse(),  1.. 0..-  v )
    assertEquals( ( 1.. 0..-v):reverse(),  0.. 1..- -v )
    assertEquals( ( 0.. v.. v):reverse(),  v.. 0..-  v )
    assertEquals( ( 0..-v..-v):reverse(), -v.. 0..- -v )
    assertEquals( ( v.. v.. v):reverse(),  v.. v..-  v )
    assertEquals( (-v..-v..-v):reverse(), -v..-v..- -v )
  end
  assertEquals( ( 2..20..-1  )      :reverse(), 20.. 2.. 1   )
  assertEquals( ( 1 .. 10.. 0  )    :reverse(), 10.. 1..-0   )
  assertEquals( ( 1 .. 10.. 0.1)    :reverse(), 10.. 1..-0.1 )
  assertEquals( (-20..-2 .. 2  )    :reverse(), -2..-20..-2  )
  assertEquals( ( 1 .. 10.. huge )  :reverse(), 10..1..-huge )

  --assertEquals( ( 1 .. 10.. 100 ):reverse(), 10..1..-huge )
end

-- for sure? how to change?
function TestRange:testEqual()
  local r
  r = 1.. 20.. 0   assertTrue( range(r:range()) == r )
  r = 1.. 20.. 0.1 assertTrue( range(r:range()) == r )

  for _,v in ipairs(values.num) do
    r = range( 1 , 10, v) assertTrue( range(r:range()) == r )
    r = range( 10, 1 ,-v) assertTrue( range(r:range()) == r )
    r = range( 1 , v , v) assertTrue( range(r:range()) == r )
    r = range( 1 ,-v ,-v) assertTrue( range(r:range()) == r )
    r = range( v , v , v) assertTrue( range(r:range()) == r )
    r = range(-v ,-v ,-v) assertTrue( range(r:range()) == r )
    r = range(-v ,-v ,-v) assertTrue( range(r:range()) == r )
  end

  for _,v in ipairs(values.empty) do
    r = range(v[1],v[2],v[3]) assertTrue( range(r:range()) == r )
  end
  for _,v in ipairs(values.zeros) do
    r = range(v[1],v[2],v[3]) assertTrue( range(r:range()) == r )
  end
  for _,v in ipairs(values.rng) do
    r = range(v[1],v[2],v[3]) assertTrue( range(r:range()) == r )
  end
end

function TestRange:testSize()
  assertEquals( range( 0 , 0 , 0 )  :size(), huge )
  assertEquals( range(-0 ,-0 ,-0 )  :size(), huge )
  assertEquals( range( 1 , 1 , 0 )  :size(), huge )
  assertEquals( range( 9 , 9 , 0 )  :size(), huge )
  assertEquals( range( 1 , 10, 0 )  :size(), huge )
  assertEquals( range( 1 )          :size(), 1    )
  assertEquals( range( 2 , 10, huge):size(), 1    )
  assertEquals( range( 10,  2,-huge):size(), 1    )

  assertEquals( ( 0 .. 0 .. 0 )  :size(), huge )
  assertEquals( (-0 ..-0 ..-0 )  :size(), huge )
  assertEquals( ( 1 .. 1 .. 0 )  :size(), huge )
  assertEquals( ( 9 .. 9 .. 0 )  :size(), huge )
  assertEquals( ( 1 .. 10.. 0 )  :size(), huge )
  assertEquals( ( 2 .. 10.. huge):size(), 1    )
  assertEquals( ( 10..  2..-huge):size(), 1    )

  for _,v in ipairs(values.empty) do
    assertEquals( (v[1]..v[2]..v[3]):size(), 0 )
  end

  assertAlmostEquals( ( eps..1  .. eps):size() - 1/eps      , 0, eps )
  assertAlmostEquals( ( 1  ..eps..-eps):size() - 1/eps      , 0, eps )
  assertAlmostEquals( ( eps..0.5.. eps):size() - 0.5/eps    , 0, eps )
  assertAlmostEquals( ( 0.5..eps..-eps):size() - 0.5/eps    , 0, eps )
  assertAlmostEquals( ( 0  ..1  .. eps):size() - 1/eps - 1  , 0, eps )
  assertAlmostEquals( ( 1  ..0  ..-eps):size() - 1/eps - 1  , 0, eps )
  assertAlmostEquals( ( 0  ..0.5.. eps):size() - 0.5/eps - 1, 0, eps )
  assertAlmostEquals( ( 0.5..0  ..-eps):size() - 0.5/eps - 1, 0, eps )

  assertEquals( range( 1 .. 10    )  :size(), 10   )
  assertEquals( range(-1 ..-10..-1)  :size(), 10   )
  assertEquals( range( 10.. 1 ..-1)  :size(), 10   )
  assertEquals( range(-10..-1     )  :size(), 10   )
  assertEquals( range( 1 ..-10..-1)  :size(), 12   )
  assertEquals( range(-1 .. 10    )  :size(), 12   )
  assertEquals( range( 10..-1 ..-1)  :size(), 12   )
  assertEquals( range(-10.. 1     )  :size(), 12   )

  assertEquals( range( 1 .. 10.. 0.1):size(), 91   )
  assertEquals( range(-1 ..-10..-0.1):size(), 91   )
  assertEquals( range( 10.. 1 ..-0.1):size(), 91   )
  assertEquals( range(-10..-1 .. 0.1):size(), 91   )
  assertEquals( range( 1 ..-10..-0.1):size(), 111  )
  assertEquals( range(-1 .. 10.. 0.1):size(), 111  )
  assertEquals( range( 10..-1 ..-0.1):size(), 111  )
  assertEquals( range(-10.. 1 .. 0.1):size(), 111  )
  assertEquals( range( 1 .. 10.. 0.5):size(), 19   )
  assertEquals( range( 1 ..-10..-0.5):size(), 23   )

  assertEquals( (0..2.1 ..1)       :size(), 3    )
  assertEquals( (0..2.9 ..1)       :size(), 3    )
  assertEquals( (1..10^3..1)       :size(), 10^3 )
  assertEquals( (1..10^3..2)       :size(), 500  )

  assertTrue( (1 .. 20.. 1.9):size() == (-1..-20..-1.9):size() )
  assertTrue( (1 .. 22.. 2.1):size() == (-1..-22..-2.1):size() )
  assertEquals( (0..24..4)        :size(), #(0..24..4)      )

  assertEquals( nrange(2, 10, nil) :size(), 100  )
  assertEquals( nrange(2, 10, 1.1) :size(), 2    )
  assertEquals( nrange(1, 32, 9  ) :size(), 9    )
  assertEquals( nrange(1, 32, 10 ) :size(), 10   )

  local r, nr, v
  v  = {
    { 1  , 100, 100},
    { 1  , 100, 10 },
    { 100, 1  , 10 },
    { 1  ,-100, 10 },
    { 100,-1  , 10 },
    {-1  , 100, 10 },
    {-100, 1  , 10 },
    {-1  ,-100, 10 },
    {-100,-1  , 10 },
    { 1  , 0  , 1/eps },
    { 0.5, 1  , 1/eps },
  }
  for _,v in ipairs(v) do
    nr = nrange(v[1],v[2],v[3])
    for i = 0,100 do
      nr = nrange(v[1],v[2],( nr:size()) )
      assertEquals( nr:size(), v[3] )
      i = i + 1
    end
  end

end