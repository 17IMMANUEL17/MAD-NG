--[=[
 o-----------------------------------------------------------------------------o
 |
 | Range module regression tests
 |
 | Methodical Accelerator Design - Copyright CERN 2015+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors:
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide regression test suites for the range module.

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local assertEquals, assertAlmostEquals, assertTrue, assertFalse,
      assertErrorMsgContains, assertNil, assertIsString in require 'luaunit'
local eps, inf, nan in require 'madl_gmath'

local range,  nrange, irange, is_range, is_cdata, is_function in MAD
local is_empty in range 

-- regression test suite ------------------------------------------------------o

TestRange = {}

function TestRange:testConcatCtor() 
  assertTrue( is_cdata(1..10)    )
  assertTrue( is_cdata(1..10..1) )
  assertTrue( is_cdata(10..1)    )

  assertEquals( (1..10).start   , 1  )  
  assertEquals( (1..10).stop    , 10 )
  assertEquals( (1..10).step    , 1  )
  assertEquals( (1..10..1).start, 1  )  
  assertEquals( (1..10..1).stop , 10 )
  assertEquals( (1..10..1).step , 1  )

  assertEquals( (10..1).start   , 10 )  
  assertEquals( (10..1).stop    , 1  )
  assertEquals( (10..1).step    , 1  )
  assertEquals( (1..10..0).start, 1  )  
  assertEquals( (1..10..0).stop , 10 )
  assertEquals( (1..10..0).step , 0  )

  assertIsString(1..10..'')
end

function TestRange:testConstructor()
  local msg = { "invalid argument #1 (expect number)",  
                "cannot convert 'string' to 'double'", }
  assertErrorMsgContains( msg[1], range            )
  assertErrorMsgContains( msg[1], range, ''        )
  assertErrorMsgContains( msg[1], range,(1..10..1) )
  assertErrorMsgContains( msg[2], range, 1, ''     )
  assertErrorMsgContains( msg[2], range, 1, 10, '' )

  assertTrue( is_cdata(range(1))       )
  assertTrue( is_cdata(range(1,10))    )
  assertTrue( is_cdata(range(1,10,1))  )
  assertTrue( is_cdata(range(1,10,0))  )
  assertTrue( is_cdata(range(1,10,-1)) )

  assertEquals( range(1).start     , 1  )
  assertEquals( range(1).stop      , 1  )
  assertEquals( range(1).step      , 1  )
  assertEquals( range(1,10).start  , 1  )
  assertEquals( range(1,10).stop   , 10 )
  assertEquals( range(1,10).step   , 1  )
  assertEquals( range(1,10,1).start, 1  )
  assertEquals( range(1,10,1).stop , 10 )
  assertEquals( range(1,10,1).step , 1  )
end

function TestRange:testNConstructor()
  local msg = { "invalid argument #1 (expect number)"            ,
                "invalid argument #1, #2 or #3 (number expected)", }
  assertErrorMsgContains( msg[1], nrange             )
  assertErrorMsgContains( msg[1], nrange,  nil, 1    )
  assertErrorMsgContains( msg[2], nrange,  nil, 1, 1 )
  assertErrorMsgContains( msg[1], nrange, ''         )
  assertErrorMsgContains( msg[1], nrange, '', ''     )
  assertErrorMsgContains( msg[2], nrange, '', 1 , 1  )
  assertErrorMsgContains( msg[2], nrange, '', '', 1  )
  assertErrorMsgContains( msg[2], nrange, 1 , 2 , '' )
  assertErrorMsgContains( msg[1], nrange,(1..10..1)  )

  assertTrue( is_cdata(nrange(1))      )
  assertTrue( is_cdata(nrange(1,10))   )
  assertTrue( is_cdata(nrange(1,10,1)) )
  assertTrue( is_cdata(nrange(1,10,0)) )

  assertEquals( nrange(1).start     , 1  )
  assertEquals( nrange(1).stop      , 1  )
  assertEquals( nrange(1).step      , 1  )
  assertEquals( nrange(1,10).start  , 1  )
  assertEquals( nrange(1,10).stop   , 10 )
  assertEquals( nrange(1,10).step   , 1  )

  assertEquals( nrange(1,10,1).start, 1   )
  assertEquals( nrange(1,10,1).stop , 10  )
  assertEquals( nrange(1,10,1).step , inf )
  assertEquals( nrange(1,10,0).step , 0   )
  
  assertEquals( nrange(1,10,10).start, 1  )
  assertEquals( nrange(1,10,10).stop , 10 )
  assertEquals( nrange(1,10,10).step , 1  )
end

function TestRange:testReadonly() 
  local msg = { "attempt to write to constant location", }
  local f=\r,v => r.start = v end   
  assertErrorMsgContains( msg[1], f, (1..10..1)     , 1 )
  assertErrorMsgContains( msg[1], f, range(1,10,1)  , 1 )
  assertErrorMsgContains( msg[1], f, nrange(1,10,10), 1 )
  local f=\r,v => r.stop  = v end   
  assertErrorMsgContains( msg[1], f, (1..10..1)     , 1 )
  assertErrorMsgContains( msg[1], f, range(1,10,1)  , 1 )
  assertErrorMsgContains( msg[1], f, nrange(1,10,10), 1 )
  local f=\r,v => r.step  = v end   
  assertErrorMsgContains( msg[1], f, (1..10..1)     , 1 )
  assertErrorMsgContains( msg[1], f, range(1,10,1)  , 1 )
  assertErrorMsgContains( msg[1], f, nrange(1,10,10), 1 )
end

function TestRange:testIsRange()
  assertTrue( is_range(1..0)     ) 
  assertTrue( is_range(1..10..0) ) 
  assertTrue( is_range(1..0..10) ) 
  assertTrue( is_range(10..1)    ) 
  assertTrue( is_range(1..10)    ) 
  assertTrue( is_range(range(1,10))     )
  assertTrue( is_range(nrange(1,10,10)) )
  assertTrue( is_range(nrange(1,10,0))  )
end

function TestRange:testRange()
  assertEquals( {range(1,10)    :range()}, {1,10,1}      )
  assertEquals( {range(1,10,1)  :range()}, {1,10,1}      )
  assertEquals( {(1..10)        :range()}, {1,10,1}      )
  assertEquals( {(1..2.2..0.1)  :range()}, {1, 2.2, 0.1} )
  assertEquals( {nrange(1,10,10):range()}, {1,10,1}      )
  assertEquals( {nrange(1,10,1) :range()}, {1,10,inf}    )
  assertEquals( {(1..0)         :range()}, {1,0,1}       )
  assertEquals( {(1..10..0)     :range()}, {1,10,0}      )
end

function TestRange:testGet()
  assertNil( range(1,10,1) :get(-1) )
  assertNil( range(1,10,1) :get(11) )
  assertNil( range(1,10,0) :get(1)  )
  assertNil( range(10,1,1) :get(1)  )
  assertNil( nrange(1,10,1):get(1)  )

  assertEquals( range(1,10,1)    :get(0)   , 1   )
  assertEquals( (1..20..1)       :get(1)   , 2   )
  assertEquals( (1..20..1)       :get(1.1) , 2.1 )
  assertEquals( range(1,100,1)   :get(99)  , 100 )
  assertEquals( nrange(1,100,100):get(99)  , 100 )
  assertAlmostEquals( (2..-2..-0.1):get(22)- -0.2, 0, eps )
end

function TestRange:testValue()
  assertEquals( range(1,10,1) :value(-1), 0   )
  assertEquals( range(1,10,1) :value(11), 12  )
  assertEquals( range(1,10,0) :value(1) , 1   )
  assertEquals( range(10,1,1) :value(1) , 11  )
  assertEquals( nrange(1,10,1):value(1) , inf )

  assertEquals( (-2..2..0.1)     :value(0)   ,-2   )
  assertEquals( (1..20..1)       :value(1)   , 2   )
  assertEquals( (1..20..1)       :value(1.1) , 2.1 )
  assertEquals( range(1,100,1)   :value(99)  , 100 )
  assertEquals( nrange(1,100,100):value(99)  , 100 )
  assertAlmostEquals( (2..-2..-0.1):value(22)- -0.2, 0, eps )
end

function TestRange:testIndex()  
  assertNil( (10..1..-1)[11]   , nil )
  assertNil( (10..1..-1)[0]    , nil )
  assertNil( range(1,10,1)[11] , nil )
  assertNil( range(1,10,1)[0]  , nil )
  assertNil( nrange(1,10,1)[10], nil )

  assertEquals( range(1,10,1)[1] , 1   )
  assertEquals( range(1,10,1)[10], 10  )
  assertEquals( (10..1..-1)[1]   , 10  )
  assertEquals( (10..1..-1)[10]  , 1   )

  res = 1..5
  ref = {1, 2, 3, 4, 5}
  for i=1,#res do assertEquals(res[i], ref[i]) end
end

function TestRange:testSize()
  assertTrue  ( range(1,20,1)    :size() == (2..40..2):size() )
  assertEquals( range(1,10)      :size(), 10 )
  assertEquals( range(1,-20,-1)  :size(), 22 )
  assertEquals( range(1,-20,-2)  :size(), 11 )
  assertEquals( range(1, 20, 2)  :size(), 10 )
  assertEquals( range(1,1.95,0.1):size(), 10 )
  assertEquals( range(2,1,-0.1)  :size(), 11 )
  assertEquals( nrange(1,10,10)  :size(), 10 )
  assertEquals( nrange(1,20,9)   :size(), 8  )
end

function TestRange:testIsEmpty()
  assertFalse( is_empty( range(1,10,0)  :range() ) )
  assertFalse( is_empty( range(1,10,1)  :range() ) )
  assertFalse( is_empty( range(1,-10,-1):range() ) )
  assertFalse( is_empty( nrange(1,10,0) :range() ) )
  assertFalse( is_empty( nrange(1,10,-1):range() ) )
  
  assertTrue ( is_empty( range(1,10,-1) :range() ) )
  assertTrue ( is_empty( range(1,-10,1) :range() ) )
  assertFalse( is_empty( nrange(1,10,1) :range() ) ) -- empty range(r.step=inf)?
end

function TestRange:testReverse()
  assertEquals( (1..10..0.1)  :reverse(), (10..1..-0.1)  )
  assertEquals( range(2,20,-1):reverse(), range(20,2,1)  )
  assertEquals( range(2,20,2) :reverse(), range(20,2,-2) )
  assertEquals( nrange(1,2,2) :reverse(), nrange(2,1,2)  )
end

function TestRange:testBounds()
  assertEquals( {range(1,10,1)    :bounds()}, {1,10}      )
  assertEquals( {range(10,1,-1)   :bounds()}, {1,10}      )
  assertEquals( {range(10,1,1)    :bounds()}, {10,1}      )
  assertEquals( {range(1,10,-1)   :bounds()}, {10,1}      )
  assertEquals( {range(1,10,0)    :bounds()}, {nil,nil}   )
  assertEquals( {nrange(1,20,0)   :bounds()}, {nil,nil}   )
  assertEquals( {range(20,-2,-0.2):bounds()}, {-2,20,nil} )
  assertEquals( {(1..0)           :bounds()}, {1,0}       )      
end

function TestRange:testEqual()
  assertTrue ( range(1,20)      == 1..20      )
  assertTrue ( range(1,20,0.1)  == 1..20..0.1 )
  assertTrue ( range(-1,-20,-1) ==-1..-20..-1 )
  assertTrue ( nrange(1,20,20)  == 1..20      )

  assertTrue ( range(1,20,0)    == 1..20..0   )
  assertTrue ( range(10,1)      == 10..1      )
  assertFalse( nrange(1,1,1)    == 1..1       )
end

function TestRange:testIrange() 
  local r = range(1,10,2)
  for i,v in irange(1,10,2)   do assertEquals(r[i], v) end
  local r = range(10,-1,-1)
  for i,v in irange(10,-1,-1) do assertEquals(r[i], v) end

  local ir = {irange(1,10,1)}
  assertTrue( is_function(ir[1]) )
  assertTrue( is_range(ir[2])    )
  assertTrue( ir[3] == 0         )

  local ir = {irange(1,10,0)}
  assertFalse( ir[1] and ir[2] and ir[3] )  

  local ir = {irange(10,1)}  -- should return nil?
  --assertFalse( ir[1] and ir[2] and ir[3] )  
  --for i,v in irange(10,1) do print(i,v) end
end


-- end ------------------------------------------------------------------------o
