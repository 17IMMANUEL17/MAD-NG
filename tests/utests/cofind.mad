--[=[
 o-----------------------------------------------------------------------------o
 |
 | Close orbit finder tests
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide regression test suites for the cofind module.

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local assertNotNil, assertEquals, assertAlmostEquals, assertAllAlmostEquals,
      assertStrContains, assertErrorMsgContains                  in MAD.utest

local beam, sequence, survey, track, cofind,
      plot, option, filesys                                      in MAD
local fnone, ftrue                                               in MAD.gfunc
local marker, drift, sbend, quadrupole, multipole                in MAD.element
local eps, pi                                                    in MAD.constant
local openfile                                                   in MAD.utility

local refdir = \s -> 'cofind_ref/'..(s or '')
local rundir = \s -> 'cofind_run/'..(s or '')

-- Tests ----------------------------------------------------------------------o

TestCOFind = {}

function TestCOFind:setUp ()
  filesys.mkdir(rundir())
  self.optfmt = option.format
  option.format = "%-.10g"
end

function TestCOFind:tearDown ()
  option.format = self.optfmt
end

  -- TODO: 6D case

function TestCOFind:testCOThinFODOda ()
  local nsl = 10
  local dl  = 1/nsl
  local k1l = 0.3037241107
  local mq1 = multipole 'mq1' { knl := {0,  k1l/nsl} }
  local mq2 = multipole 'mq2' { knl := {0, -k1l/nsl} }
  local seq = sequence 'seq' { l=10, refer='entry', -- dir=-1,
                mq1 {at=0+dl/2}, (nsl-1)*mq1 {at=dl, from='prev'},
                mq2 {at=5+dl/2}, (nsl-1)*mq2 {at=dl, from='prev'} }

! -- debug
! seq:dumpseq()
! survey { sequence=seq } :write(rundir('surv'))--, sv_col, tbl_hdr)
! local mtbl = track { sequence=seq, beam=beam, X0=X0, mapdef=true, save=true, observe=false }
! mtbl:print()
! option.debug = 3

  local X0 = { 1e-3, -1e-4, -1e-3, 1e-4, 0, 0 }
  local _, mflw, X0 = cofind { sequence=seq, beam=beam, X0=X0, mapdef=true }

! -- trace
! print("X0=", X0[1]:totable())
! print("X1=", mflw[1]:get0():totable())

  -- closed orbit
  local X0r = {-1.4475660719678e-24, -2.0679515313826e-25, 5.1698788284564e-25, -1.0339757656913e-25, 0, 0}
  -- orbit at the end for last closed orbit iteration
  local Xr = {2.4693305178798e-25, 1.3180087738943e-25, -4.9325471913103e-27, -1.5490162505571e-25, 0, 0}

  assertEquals(mflw.npar, 1)
  assertEquals(mflw[1].status, 'stable')
  assertEquals(mflw[1].rank, 4)
  assertEquals(mflw[1].coiter, 3)
  assertAllAlmostEquals(mflw[1]:get0():totable(), Xr, eps)
  assertAllAlmostEquals(X0[1]:totable(), X0r, eps)
end

function TestCOFind:testCOThinFODO ()
  local nsl = 10
  local dl  = 1/nsl
  local k1l = 0.3037241107
  local mq1 = multipole 'mq1' { knl := {0,  k1l/nsl} }
  local mq2 = multipole 'mq2' { knl := {0, -k1l/nsl} }
  local seq = sequence 'seq' { l=10, refer='entry', -- dir=-1,
                mq1 {at=0+dl/2}, (nsl-1)*mq1 {at=dl, from='prev'},
                mq2 {at=5+dl/2}, (nsl-1)*mq2 {at=dl, from='prev'} }

! -- debug
! survey { sequence=seq } :write(rundir('surv'))--, sv_col, tbl_hdr)
! option.debug = 3

  local X0 = { 1e-3, -1e-4, -1e-3, 1e-4, 0, 0 }
  local _, mflw, X0 = cofind { sequence=seq, beam=beam, X0=X0, mapdef=false }

! -- trace
! print("X0=", X0[1]:totable())
! print("X1=", mflw[1])

  -- closed orbit
  local X0r = {-8.689767776876e-10,-3.5049787128639e-10,-8.4345204280113e-10,1.9198191254506e-10,0,0}
  -- orbit at the end for closed orbit
  local Xr = {x=-3.3452077429363e-09,px=-4.5855617056283e-10,y=8.5298366201266e-11,py=2.3748991349275e-10,t=0,pt=0}

  assertEquals(mflw.npar, 1)
  assertEquals(mflw[1].status, 'stable')
  assertEquals(mflw[1].rank, 4)
  assertEquals(mflw[1].coiter, 2)
  assertAllAlmostEquals(mflw[1], Xr, eps)
  assertAllAlmostEquals(X0[1]:totable(), X0r, eps)
end

function TestCOFind:testCOSimpleRingda ()
  local k1f, k1d, ang = 0.2959998954, -0.3024197136, 2*pi/50

  local mb = sbend      { l=2, k0=\s s.angle/s.l }
  local mq = quadrupole { l=1 }
  local cell = sequence 'cell' { l=10, refer='entry',
      mq 'mq1' { at=0, k1=k1f    },
      mb 'mb1' { at=2, angle=ang },
      mq 'mq2' { at=5, k1=k1d    },
      mb 'mb2' { at=7, angle=ang } }
  local seq = sequence 'seq' { beam=beam, 25*cell }
  assertEquals(seq.l, 250)

! -- debug
! survey { sequence=seq } :write(rundir('surv'))--, sv_col, tbl_hdr)
! option.debug = 3

  local X0 = { -1e-3, 1e-4, -1e-4, 1e-3, 0, 0 }
  local _, mflw, X0 = cofind { sequence=seq, beam=beam, X0=X0, mapdef=true }

! -- trace
! print("X0=", X0[1]:totable())
! print("X1=", mflw[1]:get0():totable())

  -- closed orbit
  local X0r = {1.1855262759272e-13, 1.2898238779424e-14, 1.7108751680557e-14, -1.4566570383627e-15, 0, 0}
  -- orbit at the end for closed orbit
  local Xr = {-6.4440506441168e-14, -1.8255228616761e-14, 6.148967360117e-15, -6.3047422924128e-15, -1.2434497875802e-14, 0}

  assertEquals(mflw.npar, 1)
  assertEquals(mflw[1].status, 'stable')
  assertEquals(mflw[1].rank, 4)
  assertEquals(mflw[1].coiter, 3)
  assertAllAlmostEquals(mflw[1]:get0():totable(), Xr, eps)
  assertAllAlmostEquals(X0[1]:totable(), X0r, eps)
end

function TestCOFind:testCOSimpleRing ()
  local k1f, k1d, ang = 0.2959998954, -0.3024197136, 2*pi/50

  local mb = sbend      { l=2, k0=\s s.angle/s.l }
  local mq = quadrupole { l=1 }
  local cell = sequence 'cell' { l=10, refer='entry',
      mq 'mq1' { at=0, k1=k1f    },
      mb 'mb1' { at=2, angle=ang },
      mq 'mq2' { at=5, k1=k1d    },
      mb 'mb2' { at=7, angle=ang } }
  local seq = sequence 'seq' { beam=beam, 25*cell }
  assertEquals(seq.l, 250)

! -- debug
! seq:dumpseq()
! survey { sequence=seq } :write(rundir('surv'))
! option.debug = 3

  local X0 = {-1e-3, 1e-4, -1e-4, 1e-3, 0, 0}
  local _, mflw, X0 = cofind { sequence=seq, beam=beam, X0=X0, mapdef=false }

! -- trace
! print("X0=", X0[1])
! print("X1=", mflw[1])

  -- closed orbit
  local X0r = {1.8419820988894e-06, 2.997224580688e-07, 4.2404735273875e-07, -8.2481058426591e-08, 0, 0}
  -- orbit at the end for closed orbit
  local Xr = {x=3.6264195823226e-07, px=-6.7785280026098e-08, y=-2.5712557338088e-09, py=-1.2640259321423e-07, t=-2.2994048642921e-07, pt=0}

  assertEquals(mflw.npar, 1)
  assertEquals(mflw[1].status, 'stable')
  assertEquals(mflw[1].rank, 4)
  assertEquals(mflw[1].coiter, 2)
  assertAllAlmostEquals(mflw[1], Xr, eps)
  assertAllAlmostEquals(X0[1]:totable(), X0r, eps)
end

-- end ------------------------------------------------------------------------o
