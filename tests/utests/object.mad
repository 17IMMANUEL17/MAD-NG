local lu = require 'luaunit'
local G  = require 'madl_gmath'
local eps, huge, I, inf, Inf, nan, NaN, pi, Pi, tiny, twopi in G

local Object in MAD
local O = Object

local isEqu    = lu.assertEquals
local isTrue   = lu.assertTrue
local isFalse  = lu.assertFalse
local isEquEps = lu.assertAlmostEquals
local isTable  = lu.assertIsTable
local isErrEqu = lu.assertErrorMsgEquals
local isNotEqu = lu.assertNotEquals
local isFun    = lu.assertIsFunction
local isTable  = lu.assertIsTable

TestObject = {}

--function TestObject:setUp()    end
--function TestObject:tearDown() end

function TestObject:testCtor()
  --isErrEqu( "incomplete object initialization", )
  --isErrEqu( "incomplete object initialization", )
  --isErrEqu( "private object", )
  --isErrEqu( "private const object", )
  local Point = O 'Point' {}
  local p1 = Point 'p1' { x=3, y=2, z=1  }
  local p2 = p1    'p2' { x=2, y=1 }
  local p3 = p2    'p3' { x=1  }
  local p4 = p3    'p4' { }
  local p5 = p1    'p5' { x=nil, y='a', k=1}
  isEqu( p2.z   , p1.z )
  isEqu( p2.z   , 1    )
  isEqu( p2.x   , 2    )
  isEqu( p2.y   , 1    )
  isEqu( p3.y   , p2.y )
  isEqu( p3.z   , p2.z )
  isEqu( p3.z   , p1.z )
  isEqu( p3.name, "p3" )
  isEqu( p3.x   , 1    )
  isEqu( p4.x   , p3.x )
  isEqu( p4.y   , p2.y )
  isEqu( p4.z   , p1.z )
  isEqu( p5.x   , p1.x )
  isEqu( p5.y   , 'a'  )
  isEqu( p5.z   , p1.z )
  isEqu( p5.k   , 1    )
end

function TestObject:testLambda()
  local Po = O  'Po' {}
  local p1 = Po 'p1' { x=3, y=2, z=1  }
  local p2 = p1 'p2' { y=\s 2*s.x }
  local p3 = p2 'p3' { y={ 0, \s 3*s.x } }
  local p4 = p1 'p4' { y=\s {2*s.x, 2*s.z} }
  local p5 = p4 'p5' { z=\s s.x*2}
  isEqu( p2.z   , p1.z )
  isEqu( p3.z   , p1.z )
  isEqu( p2.x   , p1.x )
  isEqu( p3.x   , p1.x )
  isEqu( p2.y   , 6    )
  isEqu( p3.y[1], 0    )
  isEqu( p4.x   , 3    )
  isEqu( p4.z   , 1    )
  isEqu( p4.y[1], 6    )
  isEqu( p4.y[2], 2    )
  isEqu( p5.x   , 3    )
  isEqu( p5.z   , 6    )
  isEqu( p5.y[1], 6    )
  isEqu( p5.y[2], 12   )

  p2.x =4
  p2.a =2
  isEqu( p2.x, 4 )
  isEqu( p2.y, 8 )
  isEqu( p2.a, 2 )

  local a = O ''{}
  isEqu( a.name, '' )
  local a = O { x=1 }
  local b = a {}
  isEqu( a.name, 'Object' )
  isEqu( b.x   , a.x      )
  b.x = 2
  isEqu( b.x , 2 )
end

--[[function TestObject:testInput() --To be uncommented after integration
  local XR = require 'madl_xrange'
  local m  = require 'madl_matrix'
  local cm = require 'madl_cmatrix'
  local C  = require 'madl_complex'
  local g  = require 'madl_gmath'
  local ob1 = O    'ob1' { x=3, y=2, z=1 }
  local ob2 = ob1  'ob1' { x=3, y=2, z=1 }
  isEqu ( ob1, ob2 )

  local ob3 = ob1 'ob3' { y=C(2,1) }
  local ob4 = ob3 'ob4' { y=C(-2,-1.1), z=m(2,2) }
  local obj = O   'obj' { x=cm(2,3)   , y=XR(1,10,2), z=1..20 }
  isEqu( ob3.x   , 3          )
  isEqu( ob3.y.re, 2          )
  isEqu( ob3.y.im, 1          )
  isEqu( ob3.z   , 1          )
  isEqu( ob4.x   , ob3.x      )
  isEqu( ob4.x   , ob1.x      )
  isEqu( ob4.y.re, -2         )
  isEqu( ob4.y.im, -1.1       )
  for i=1,#ob4.z do isEqu( ob4.z[i], 0      ) end
  for i=1,#obj.x do isEqu( obj.x[i], C(0,0) ) end

  local a = XR(1,10,2)
  local l = obj.y:size()
  for i=1,l do  isEqu( obj.y[i], a[i] ) end

  local a = 1..20
  local l = obj.x:size()
  for i=1,l do  isEqu( obj.z[i], a[i] ) end

  local p3 = ob1 'p3' { x=3       , y=2 , z=1 }
  local p4 = ob1 'p4' { y=\s 2*s.x, z=p3 }
  isEqu( p4.z.x, p3.x )
  isEqu( p4.z.y, p3.y )
  isEqu( p4.z.z, p3.z )
  isEqu( p4.x  , p3.x )
  isEqu( p4.__var.z, p4.z)

  local p4 = ob1 'p4' { x=0, y=\s 2*s.x, z=p3, a=\s g.sin(s.x) }
  isEqu( p4.a, 0)
end]]

function TestObject:testIsa( )
  local Po = O 'Po' {}
  local p1 = Po 'p1' { x=3, y=2, z=1  }
  local p2 = p1 'p2' { y=\s 2*s.x }
  local isa = O.isa
  local a = O { x=1 }
  isTrue ( p1:isa(Po) )
  isTrue ( p2:isa(Po) )
  isTrue ( p2:isa(p1) )
  isTrue ( p1:isa(Po) )
  isFalse( Po:isa(p1) )
  isFalse( Po:isa(p2) )
  isFalse( Po:isa(a)  )
  isTrue ( p1:is_instanceOf(Po) )
  isFalse( Po:is_instanceOf(p1) )
end

function TestObject:testRawset()
  local o0 = O  'o0' { a= 0.1, b =0.2 , c=0.3 }
  local o1 = o0 'o1' { a=-1.1, b={}           }
  local o2 = o1 'o2' { a=-1.1, b=\s s.a*2     }
  isEqu( o2.a, -1.1)
  rawset( o2, 'a', o0.a )
  rawset( o2, 'c', 3    )
  rawset( o2, 'b', nil  )
  isEqu( o2.a, 0.1 )
  isEqu( o2.c, 3   )
  isEqu( o2.b, 0.2 )
  o2.__var.a = nil
  isEqu( o2.a, 0.1 )
  rawset( o2, '__var.a', nil  )
  isEqu ( o2.__var.a, -1.1 )
end

function TestObject:testSet_function( )
  --isErrEqu( "invalid 'self' argument, valid object expected", )
  --isErrEqu( "invalid 'func' argument, not callable"         , )
  local G = require 'madl_gmath'
  local Point = O  'Point' { x=1, y=3        }
  local o1    = O  'o1'    { x=2, y=\s 2*s.x }
  local o2    = Point 'o2' { z=1             }
  local o3    = o1 'o3'    { z=\s s.x/2+s.y  }
  local f=\x x*x
  local y=\x,y x*y

  --o1:set_function( '__mul', f )  -- you can change methamethod with this function -- test missing if you really can
  Point:set_function({y=f}, true)
  o1:set_function ({y=y}, true)
  o1:set_function {sin=G.sin}
  isEqu( Point.y(9),  81 )
  isEqu( o1.y(2,-2), -4  )
  isEqu( o1.sin(0) ,  0  )

  o3:set_function { f=\x,y   (x+y, x-y)         }
  o2:set_function { g=\s,x,y (x+y, x-y, s.name) }
  local a,b = o3.f(2, 1)
  isEqu( a, 3 )
  isEqu( b, 1 )
  local a,b = o2.g(o2, 2, 5)
  isEqu( o2.g(o2, 2, 5), 7 )
  isEqu( a,  7 )
  isEqu( b, -3 )

  local a, b = o3.f(-2,1)
  isEqu( a, -1 )
  isEqu( b, -3 )
  local a,b,c = o2.g( o2, -1.2, 1.2)
  isEqu( a, 0    )
  isEqu( b, -2.4 )
  isEqu( c, 'o2' )
end

function TestObject:testSet_method( )  --test of set_method setting it as primary
  local Point = O 'Point' { x=1, y=3        }
  local o1    = O 'o1'    { x=2, y=\s 2*s.x }
  local f=\x x*x
  local y=\x,y (x*y, 2*x+2*y)
  --isErrEqu( "invalid 'self' argument, valid object expected", )
  --isErrEqu( "invalid 'func' argument, not callable"         , )
  --isErrEqu( "object.lua:264: invalid 'name' argument, metamethod detected", o1:set_method( '__add', f ) )

  o1:set_method {f=f}
  o1:set_method {y=y}
  isEqu( o1.f(2), 4 )
  local a,b = o1.y(2,2)
  isEqu( a, 4 )
  isEqu( b, 8 )

  local fig = O 'fig' { len = 0, width = 0 }
  local f =\s s.len * s.width
  fig:set_method {field=f}
  fig:set_function {f=f}
  isTable(fig.f)
  isFun(fig.field)

  local sq = fig 'sq' { field =\s s.len*s.len }
  sq:set_method {field=f}
  isFun(sq.field)
end

function TestObject:testSet_metamethod( )
  local o0 = O  'o0' { a= 0.1, b =0.2 , c=0.3 }
  local o1 = o0 'o1' { a=-1.1, b={}           }

  --o0:set_metamethod('__eq', )
end

--[[function TestObject:testSet_metamethod2( )
  --isErrEqu("cannot override inherited behavior", )
  --isErrEqu( "invalid 'self' argument, valid object expected", )
  --isErrEqu( "invalid 'name' argument, not a metamethod"     , )
  --isErrEqu( "invalid 'func' argument, not callable"         , )

  local p1 = O  'p1' { x=1, y=2  }
  local p2 = p1 'p2' { x=2, y=-1, z=0 }
  local p3 = p2 'p3' { x=3  }

  local function trace (fp, self, k, v)
    fp:write("object: '", self.name,
             "' is updated for key: '", tostring(k),
             "' with value: ")
    if type(v) == "string"
      then fp:write(": '", tostring(v), "'\n")
      else fp:write(":  ", tostring(v),  "\n") end
  end

  local function set_notification (self, file)
    local fp = file or io.stdout
    local nwidx = rawget(getmetatable(self) or {}, '__newindex')
    local mm = function (self, k, v)
      trace(fp, self, k, v) -- logging
      nwidx(    self, k, v) -- forward
    end
    self:set_metamethod('__newindex', mm, true) -- override!
  end

  set_notification(p2) -- new metamethod created, metatable is cloned
  p2.x = 3 -- new behavior, notify about update
  p3.x = 4 -- created before set_metamethod (bad!), old behavior

  local p4 = p2 'p4' { x=3 } -- new, inherit metatable
  p4.x = 5 -- new behavior, notify about update if you really can
end]]

function TestObject:testCount() --subtest of set_methamethod
  local oO = O '' {}
  local count = 0
  local function set_counter (self)
    local mm = function (self)
      count = count + 1
      return self
    end
    self:set_metamethod {__init = mm}
  end
  o0 = O 'o0' {}
  set_counter(o0)

  local o1 = o0 'o1' { a = 2 }
  isEqu( count, 1 )
  local o2 = o1 'o2' { a = 2 }
  isEqu( count, 2 )
  local a = O 'a' { x = o2.a }
  isEqu( count, 2 )
end

function TestObject:testSet_parent( )
  --isErrEqu( "'Object' must stay the root of objects", )
  --isErrEqu( "invalid 'self' argument, table or object expected", )
  --isErrEqu( "invalid 'obj' argument, valid object expected", )
  local Po = O  'Po' { x=1, y=3       }
  local p1 = Po 'p1' { x=3, y=2, z=1  }
  local p2 = p1 'p2' { y=\s 2*s.x     }
  local p3 = p2 'p3' { x=2, y=1, z=x  }
  isEqu( p2.x, p1.x )
  isEqu( p2.z, p1.z )

  p2:set_parent( Po )
  isEqu( p2.x, Po.x )
  isEqu( p2.z, Po.z )
  isEqu( p2.z, nil  )

  p1:set_parent( p3 )
  isNotEqu( p1.x, p3.x )
  isNotEqu( p1.y, p3.y )
  isNotEqu( p1.z, p3.z )
  isEqu( p1.x, 3 )
  isEqu( p1.y, 2 )
  isEqu( p1.z, 1 )

  local ob = O '' {}
  ob:set_parent( p1 )
  isEqu( ob.x, p1.x )
  isEqu( ob.y, p1.y )
  isEqu( ob.z, p1.z )
end
