--[=[
 o-----------------------------------------------------------------------------o
 |
 | Object model regression tests
 |
 | Methodical Accelerator Design - Copyright CERN 2015+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide regression test suites for the object module.

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local assertNil, assertTrue, assertFalse, assertEquals, assertNotEquals,
      assertAlmostEquals, assertErrorMsgContains in require 'luaunit'
local is_function, is_table, is_object, is_instanceOf, is_readonly, Object
      in MAD
local sin in math

-- regression test suite ------------------------------------------------------o

TestObject = {}

function TestObject:testConstructor()
  local p0 = Object 'p0' {}
  local p1 = Object {}
  local p2 = Object 'p2'
  local p3 = Object
  local p4 = Object('p4',{})

  local p00 = p0 'p00' {}
  local p01 = p0 {}
  local p02 = p0 'p02'
  local p03 = p0
  local p04 = p0('p04',{})

  local get = \s,k s[k]
  local set = \s,k,v => s[k]=v end
  local msg = {
    "forbidden read access to incomplete object",
    "forbidden write access to incomplete object",
    "forbidden write access to readonly object",
    "invalid argument #1 to constructor (string or raw table expected)",
    "invalid argument #2 to constructor (raw table expected)"
  }

  -- invalid ctor argument
  assertErrorMsgContains(msg[4], Object, true)
  assertErrorMsgContains(msg[4], Object, 1)
  assertErrorMsgContains(msg[4], Object, \ ())
  assertErrorMsgContains(msg[4], Object, Object)
  assertErrorMsgContains(msg[5], Object, 'p', true)
  assertErrorMsgContains(msg[5], Object, 'p', 1)
  assertErrorMsgContains(msg[5], Object, 'p', '1')
  assertErrorMsgContains(msg[5], Object, 'p', \ ())
  assertErrorMsgContains(msg[5], Object, 'p', Object)

  -- ctor equivalence
  assertEquals(p04, Object 'p04' {})

  -- read
  assertNil( p0.a )
  assertNil( p1.a )
  assertErrorMsgContains(msg[1], get, p2, a)
  assertNil( p3.a )
  assertNil( p4.a )

  -- write
  p0.a = ''   assertEquals( p0.a, '' )
  p1.a = ''   assertEquals( p1.a, '' )
  assertErrorMsgContains(msg[2], set, p2, a, '')
  assertErrorMsgContains(msg[3], set, p3, a, '')
  p4.a = ''   assertEquals( p4.a, '' )

  -- read child
  assertEquals( p00.a, '' )
  assertEquals( p01.a, '' )
  assertErrorMsgContains(msg[1], get, p02, a)
  assertEquals( p03.a, '' )
  assertEquals( p04.a, '' )

  -- write child
  p00.a = '0'   assertEquals( p00.a, '0' )
  p01.a = '0'   assertEquals( p01.a, '0' )
  assertErrorMsgContains(msg[2], set, p02, a, '')
  p03.a = '0'   assertEquals( p03.a, '0' )
  p04.a = '0'   assertEquals( p04.a, '0' )
end

function TestObject:testIsObject()
  local p0 = Object 'p0' {}
  local p1 = Object {}
  local p2 = Object 'p2'
  local p3 = Object

  local p00 = p0 'p00' {}
  local p01 = p0 {}
  local p02 = p0 'p02'
  local p03 = p0

  assertTrue ( is_object(p0) )
  assertTrue ( is_object(p1) )
  assertTrue ( is_object(p2) )
  assertTrue ( is_object(p3) )
  assertTrue ( is_object(p00) )
  assertTrue ( is_object(p01) )
  assertTrue ( is_object(p02) )
  assertTrue ( is_object(p03) )
  assertFalse( is_object(nil)  )
  assertFalse( is_object(1)    )
  assertFalse( is_object({})   )
  assertFalse( is_object(\ ()) )
end

function TestObject:testIsReadonly()
  local p0 = Object 'p0' {}
  local p1 = Object {}
  local p2 = Object 'p2'
  local p3 = Object

  local p00 = p0 'p00' {}
  local p01 = p0 {}
  local p02 = p0 'p02'
  local p03 = p0

  local msg = {
    "invalid argument #1 (forbidden access to 'Object')",
    "invalid argument #2 (boolean or nil expected)",
    "invalid argument #1 (forbidden access to 'ro_obj')",
  }

  assertFalse( is_readonly(p0)  )
  assertFalse( is_readonly(p1)  )
  assertFalse( is_readonly(p2)  )
  assertTrue ( is_readonly(p3)  )
  assertFalse( is_readonly(p00) )
  assertFalse( is_readonly(p01) )
  assertFalse( is_readonly(p02) )
  assertFalse( is_readonly(p03) )
  assertTrue ( is_readonly(p03:set_readonly(true)) )
  p0:set_readonly(true)
  assertTrue ( is_readonly(p0)  )
  assertFalse( is_readonly(p00) )
  assertErrorMsgContains(msg[1], Object.set_readonly, Object, true)
  assertErrorMsgContains(msg[1], Object.set_readonly, Object, false)
  assertErrorMsgContains(msg[2], p0.set_readonly, p0, 1)
  assertErrorMsgContains(msg[2], p00.set_readonly, p0, '')
end

function TestObject:testInheritance()
  local p0 = Object {}
  local p1 = p0 { x=3, y=2, z=1  }
  local p2 = p1 { x=2, y=1 }
  local p3 = p2 { x=1  }
  local p4 = p3 { }

  assertEquals   ( p0 , {} )
  assertEquals   ( p1 , { x=3, y=2, z=1 } )
  assertNotEquals( p1 , { x=3, y=2 } )
  assertEquals   ( p2 , { x=2, y=1, z=1 } )
  assertEquals   ( p2 , { x=2, y=1 } )
  assertNotEquals( p2 , { x=2 } )
  assertEquals   ( p3 , { x=1, y=1, z=1 } )
  assertEquals   ( p3 , { x=1, y=1 } )
  assertEquals   ( p3 , { x=1 } )
  assertNotEquals( p3 , {} )
  assertEquals   ( p4 , { x=1, y=1, z=1 } )
  assertEquals   ( p4 , { x=1, y=1 } )
  assertEquals   ( p4 , { x=1 } )
  assertEquals   ( p4 , {} )
  p2:set{x=5, y=6}  p4:set{y=5, z=6}
  assertEquals   ( p0 , {} )
  assertEquals   ( p1 , { x=3, y=2, z=1 } )
  assertNotEquals( p1 , { x=3, y=2 } )
  assertEquals   ( p2 , { x=5, y=6, z=1 } )
  assertEquals   ( p2 , { x=5, y=6 } )
  assertNotEquals( p2 , { x=5 } )
  assertEquals   ( p3 , { x=1, y=6, z=1 } )
  assertEquals   ( p3 , { x=1, y=6 } )
  assertEquals   ( p3 , { x=1 } )
  assertNotEquals( p3 , {} )
  assertEquals   ( p4 , { x=1, y=5, z=6 } )
  assertEquals   ( p4 , { y=5, z=6 } )
  assertNotEquals( p4 , { z=6 } )
end

function TestObject:testIsInstanceOf()
  local p0 = Object {}
  local p1 = p0 { }
  local p2 = p1 { }
  local p3 = p1 { }
  local p4 = p3 { }

  local msg = {
    "invalid argument #2 (object expected)",
  }

  assertTrue ( Object:is_instanceOf(Object) )

  assertTrue ( p0:is_instanceOf(Object) )
  assertTrue ( p0:is_instanceOf(p0) )
  assertFalse( p0:is_instanceOf(p1) )
  assertFalse( p0:is_instanceOf(p2) )
  assertFalse( p0:is_instanceOf(p3) )
  assertFalse( p0:is_instanceOf(p4) )

  assertTrue ( p1:is_instanceOf(Object) )
  assertTrue ( p1:is_instanceOf(p0) )
  assertTrue ( p1:is_instanceOf(p1) )
  assertFalse( p1:is_instanceOf(p2) )
  assertFalse( p1:is_instanceOf(p3) )
  assertFalse( p1:is_instanceOf(p4) )

  assertTrue ( p2:is_instanceOf(Object) )
  assertTrue ( p2:is_instanceOf(p0) )
  assertTrue ( p2:is_instanceOf(p1) )
  assertTrue ( p2:is_instanceOf(p2) )
  assertFalse( p2:is_instanceOf(p3) )
  assertFalse( p2:is_instanceOf(p4) )

  assertTrue ( p3:is_instanceOf(Object) )
  assertTrue ( p3:is_instanceOf(p0) )
  assertTrue ( p3:is_instanceOf(p1) )
  assertFalse( p3:is_instanceOf(p2) )
  assertTrue ( p3:is_instanceOf(p3) )
  assertFalse( p3:is_instanceOf(p4) )

  assertTrue ( p4:is_instanceOf(Object) )
  assertTrue ( p4:is_instanceOf(p0) )
  assertTrue ( p4:is_instanceOf(p1) )
  assertFalse( p4:is_instanceOf(p2) )
  assertTrue ( p4:is_instanceOf(p3) )
  assertTrue ( p4:is_instanceOf(p4) )

  assertFalse( is_instanceOf(0 , p0) )
  assertFalse( is_instanceOf('', p0) )
  assertFalse( is_instanceOf({}, p0) )

  assertErrorMsgContains(msg[1], is_instanceOf, p0, 0)
  assertErrorMsgContains(msg[1], is_instanceOf, p0, '')
  assertErrorMsgContains(msg[1], is_instanceOf, p0, {})
end

function TestObject:testValueSemantic() -- TODO
  local Po = Object 'Po' {}
  local p1 = Po 'p1' { x=3, y=2, z=1  }
  local p2 = p1 'p2' { y=\s 2*s.x }
  local p3 = p2 'p3' { y={ 0, \s 3*s.x } }
  local p4 = p1 'p4' { y=\s {2*s.x, 2*s.z} }
  local p5 = p4 'p5' { z=\s s.x*2}
  assertEquals( p2.z   , p1.z )
  assertEquals( p3.z   , p1.z )
  assertEquals( p2.x   , p1.x )
  assertEquals( p3.x   , p1.x )
  assertEquals( p2.y   , 6    )
  assertEquals( p3.y[1], 0    )
  assertEquals( p4.x   , 3    )
  assertEquals( p4.z   , 1    )
  assertEquals( p4.y[1], 6    )
  assertEquals( p4.y[2], 2    )
  assertEquals( p5.x   , 3    )
  assertEquals( p5.z   , 6    )
  assertEquals( p5.y[1], 6    )
  assertEquals( p5.y[2], 12   )

  p2.x =4
  p2.a =2
  assertEquals( p2.x, 4 )
  assertEquals( p2.y, 8 )
  assertEquals( p2.a, 2 )

  local a = Object '' {}
  assertEquals( a.name, '' )
  local a = Object { x=1 }
  local b = a {}
  assertEquals( a.name, 'Object' )
  assertEquals( b.x   , a.x      )
  b.x = 2
  assertEquals( b.x , 2 )
end

function TestObject:testVariable()
end

function TestObject:testSpecialVariable()
end

function TestObject:testSetVariable()
  local o0 = Object 'o0' { a= 0.1, b =0.2 , c=0.3 }
  local o1 = o0 'o1' { a=-1.1, b={}           }
  local o2 = o1 'o2' { a=-1.1, b=\s s.a*2     }
  assertEquals( o2.a, -1.1)
  rawset( o2, 'a', o0.a )
  rawset( o2, 'c', 3    )
  rawset( o2, 'b', nil  )
  assertEquals( o2.a, 0.1 )
  assertEquals( o2.c, 3   )
  assertEquals( o2.b, 0.2 )
  o2.__var.a = nil
  assertEquals( o2.a, 0.1 )
  rawset( o2, '__var.a', nil  )
  assertEquals ( o2.__var.a, -1.1 )
end

function TestObject:testVariableInheritance()
end

function TestObject:testSetFunction()
  local Point = Object 'Point' { x=1, y=3        }
  local o1    = Object 'o1'    { x=2, y=\s 2*s.x }
  local o2    = Point 'o2' { z=1             }
  local o3    = o1 'o3'    { z=\s s.x/2+s.y  }
  local f=\x x*x
  local y=\x,y x*y

  --o1:set_function( '__mul', f )  -- you can change methamethod with this function -- test missing if you really can
  Point:set_function({y=f}, true)
  o1:set_function ({y=y}, true)
  o1:set_function {sin=sin}
  assertEquals( Point.y(9),  81 )
  assertEquals( o1.y(2,-2), -4  )
  assertEquals( o1.sin(0) ,  0  )

  o3:set_function { f=\x,y   (x+y, x-y)         }
  o2:set_function { g=\s,x,y (x+y, x-y, s.name) }
  local a,b = o3.f(2, 1)
  assertEquals( a, 3 )
  assertEquals( b, 1 )
  local a,b = o2.g(o2, 2, 5)
  assertEquals( o2.g(o2, 2, 5), 7 )
  assertEquals( a,  7 )
  assertEquals( b, -3 )

  local a, b = o3.f(-2,1)
  assertEquals( a, -1 )
  assertEquals( b, -3 )
  local a,b,c = o2.g( o2, -1.2, 1.2)
  assertEquals( a, 0    )
  assertEquals( b, -2.4 )
  assertEquals( c, 'o2' )

  --isErrEqu( "invalid 'self' argument, valid object expected", )
  --isErrEqu( "invalid 'func' argument, not callable"         , )
end

function TestObject:testFunctionInheritance()
end

--[[
function TestObject:testSetMethod()
  local Point = Object 'Point' { x=1, y=3        }
  local o1    = Object 'o1'    { x=2, y=\s 2*s.x }
  local f=\x x*x
  local y=\x,y (x*y, 2*x+2*y)
  --isErrEqu( "invalid 'self' argument, valid object expected", )
  --isErrEqu( "invalid 'func' argument, not callable"         , )
  --isErrEqu( "object.lua:264: invalid 'name' argument, metamethod detected", o1:set_method( '__add', f ) )

  o1:set_method {f=f}
  o1:set_method {y=y}
  assertEquals( o1.f(2), 4 )
  local a,b = o1.y(2,2)
  assertEquals( a, 4 )
  assertEquals( b, 8 )

  local fig = Object 'fig' { len = 0, width = 0 }
  local f =\s s.len * s.width
  fig:set_method {field=f}
  fig:set_function {f=f}
  assertTrue( is_table(fig.f) )
  assertTrue( is_function(fig.field) )

  local sq = fig 'sq' { field =\s s.len*s.len }
  sq:set_method {field=f}
  assertTrue( is_function(sq.field) )
end

function TestObject:testMethodInheritance()
end
]]

function TestObject:testSetMetamethod()
  local o0 = Object 'o0' { a= 0.1, b =0.2 , c=0.3 }
  local o1 = o0 'o1' { a=-1.1, b={}           }

  --o0:set_metamethod('__eq', )
end

function TestObject:testMetamethodSharing()
  --isErrEqu("cannot override inherited behavior", )
  --isErrEqu( "invalid 'self' argument, valid object expected", )
  --isErrEqu( "invalid 'name' argument, not a metamethod"     , )
  --isErrEqu( "invalid 'func' argument, not callable"         , )
end

function TestObject:testMetamethodForwarding()
  local msg = {
    "invalid argument #1 (forbidden access to 'ro_obj')",
    "invalid argument #2 (boolean or nil expected)",
  }

  local ro_obj = Object {} :set_readonly(true)
  local parent = ro_obj.parent
  ro_obj:set_function {
    set_readonly = \s,f =>
      assert(s ~= ro_obj, msg[1])
      return parent.set_readonly(s,f)
    end
  }
  ro_obj:set_metamethod {__init = \s -> s:set_readonly(true) }

  assertErrorMsgContains(msg[1], ro_obj.set_readonly, ro_obj, true)

  local ro_chld = ro_obj {}
  assertTrue ( is_readonly(ro_chld) )
  assertFalse( is_readonly(ro_chld:set_readonly(false)) )
  assertErrorMsgContains(msg[2], ro_chld.set_readonly, ro_chld, 1)
end

function TestObject:testMetamethodNotification()
  local p1 = Object 'p1' { x=1, y=2  }
  local p2 = p1 'p2' { x=2, y=-1, z=0 }
  local p3 = p2 'p3' { x=3  }

  local function trace (fp, self, k, v)
--[[    fp:write("object: '", self.name,
             "' is updated for key: '", tostring(k),
             "' with value: ")
    if type(v) == "string"
      then fp:write(": '", tostring(v), "'\n")
      else fp:write(":  ", tostring(v),  "\n") end
]]  end

  local function set_notification (self, file)
    local fp = file or io.stdout
    local mt = getmetatable(self)
    local nwidx = mt and rawget(mt, '__newindex')
    local mm = function (self, k, v)
      trace(fp, self, k, v) -- logging
      nwidx(    self, k, v) -- forward
    end
    self:set_metamethod({__newindex=mm}, true) -- override!
  end

  set_notification(p2) -- new metamethod created, metatable is cloned
  p2.x = 3 -- new behavior, notify about update
  p3.x = 4 -- created before set_metamethod (bad!), old behavior

  local p4 = p2 'p4' { x=3 } -- new, inherit metatable
  p4.x = 5 -- new behavior, notify about update if you really can
end

function TestObject:testMetamethodCounting()
  local count = 0
  local set_counter = \s s:setmm { __init =\=> count=count+1 end }

  local o0 = Object 'o0' {}
  set_counter(o0)
  local o1 = o0 'o1' { a = 2 }
  assertEquals( count, 1 )
  local o2 = o1 'o2' { a = 2 }
  assertEquals( count, 2 )
  local a = Object 'a' { x = o2.a }
  assertEquals( count, 2 )
end

-- performance test suite -----------------------------------------------------o

Test_Object = {}

function Test_Object:testPrimes()
  local Primes = Object {}

  Primes:set_function {
    isPrimeDivisible = \s,c =>
      for i=3, s.prime_count do
        if s.primes[i] * s.primes[i] > c then break end
        if c % s.primes[i] == 0 then return true end
      end
      return false
    end,

    addPrime = \s,c =>
      s.prime_count = s.prime_count + 1
      s.primes[s.prime_count] = c
    end,

    getPrimes = \s,n =>
      s.prime_count, s.primes = 3, { 1,2,3 }
      local c = 5
      while s.prime_count < n do
        if not s:isPrimeDivisible(c) then
          s:addPrime(c)
        end
        c = c + 2
      end
    end
  }

  local p = Primes {}
  local t0 = os.clock()
  p:getPrimes(2e5)
  local dt = os.clock() - t0
  assertEquals( p.primes[p.prime_count], 2750131 )
  assertAlmostEquals( dt , 0.5, 1 )
end

function Test_Object:testDuplicates()
  local DupFinder = Object {}

  DupFinder:set_function {
    find_duplicates = \s,res =>
      for _,v in ipairs(s) do
        res[v] = res[v] and res[v]+1 or 1
      end
      for _,v in ipairs(s) do
        if res[v] and res[v] > 1 then
          res[#res+1] = v
        end
        res[v] = nil
      end
    end,

    clear = \s =>
      for i=1,#s do s[i]=nil end
      return s
    end
  }

  local inp = DupFinder {'b','a','c','c','e','a','c','d','c','d'}
  local out = DupFinder {'a','c','d'}
  local res = DupFinder {}

  local t0 = os.clock()
  for i=1,5e5 do inp:find_duplicates(res:clear()) end
  local dt = os.clock() - t0
  assertEquals( res, out )
  assertAlmostEquals( dt , 0.5, 1 )
end

function Test_Object:testLinkedList()
  local List = Object {}
  local nxt = {}

  local function generate(n)
    local t = List {x=1}
    for j=1,n do t = List {[nxt]=t} end
    return t
  end

  local function find(t,k)
    if t[k] ~= nil then return t[k] end
    return find(t[nxt],k)
  end

  local l, s, n = generate(10), 0, 1e6
  local t0 = os.clock()
  for i=1,n do s = s + find(l, 'x') end
  local dt = os.clock() - t0
  assertEquals( s, n )
  assertAlmostEquals( dt, 0.5, 1 )
end


-- end ------------------------------------------------------------------------o
