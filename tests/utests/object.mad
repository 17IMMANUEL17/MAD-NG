--[=[
 o-----------------------------------------------------------------------------o
 |
 | Object model regression tests
 |
 | Methodical Accelerator Design - Copyright CERN 2015+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide regression test suites for the object module.

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local assertNil, assertTrue, assertFalse, assertEquals, assertNotEquals,
      assertAlmostEquals in require 'luaunit'
local is_function, is_table, Object in MAD
local sin in math

-- regression test suite ------------------------------------------------------o

TestObject = {}

function TestObject:testConstructor()
  --isErrEqu( "incomplete object initialization", )
  --isErrEqu( "incomplete object initialization", )
  --isErrEqu( "private object", )
  --isErrEqu( "private const object", )
  local Point = Object 'Point' {}
  local p1 = Point 'p1' { x=3, y=2, z=1  }
  local p2 = p1    'p2' { x=2, y=1 }
  local p3 = p2    'p3' { x=1  }
  local p4 = p3    'p4' { }
  local p5 = p1    'p5' { x=nil, y='a', k=1}
  assertEquals( p2.z   , p1.z )
  assertEquals( p2.z   , 1    )
  assertEquals( p2.x   , 2    )
  assertEquals( p2.y   , 1    )
  assertEquals( p3.y   , p2.y )
  assertEquals( p3.z   , p2.z )
  assertEquals( p3.z   , p1.z )
  assertEquals( p3.name, 'p3' )
  assertEquals( p3.x   , 1    )
  assertEquals( p4.x   , p3.x )
  assertEquals( p4.y   , p2.y )
  assertEquals( p4.z   , p1.z )
  assertEquals( p5.x   , p1.x )
  assertEquals( p5.y   , 'a'  )
  assertEquals( p5.z   , p1.z )
  assertEquals( p5.k   , 1    )
end

function TestObject:testIsObject()
end

function TestObject:testInheritance()
end

function TestObject:testIsInstanceOf()
  local Po = Object 'Po' {}
  local p1 = Po 'p1' { x=3, y=2, z=1  }
  local p2 = p1 'p2' { y=\s 2*s.x }
  local a = Object { x=1 }
  assertTrue ( p1:isa(Po) )
  assertTrue ( p2:isa(Po) )
  assertTrue ( p2:isa(p1) )
  assertTrue ( p1:isa(Po) )
  assertFalse( Po:isa(p1) )
  assertFalse( Po:isa(p2) )
  assertFalse( Po:isa(a)  )
  assertTrue ( p1:is_instanceOf(Po) )
  assertFalse( Po:is_instanceOf(p1) )
end

function TestObject:testValueSemantic()
  local Po = Object 'Po' {}
  local p1 = Po 'p1' { x=3, y=2, z=1  }
  local p2 = p1 'p2' { y=\s 2*s.x }
  local p3 = p2 'p3' { y={ 0, \s 3*s.x } }
  local p4 = p1 'p4' { y=\s {2*s.x, 2*s.z} }
  local p5 = p4 'p5' { z=\s s.x*2}
  assertEquals( p2.z   , p1.z )
  assertEquals( p3.z   , p1.z )
  assertEquals( p2.x   , p1.x )
  assertEquals( p3.x   , p1.x )
  assertEquals( p2.y   , 6    )
  assertEquals( p3.y[1], 0    )
  assertEquals( p4.x   , 3    )
  assertEquals( p4.z   , 1    )
  assertEquals( p4.y[1], 6    )
  assertEquals( p4.y[2], 2    )
  assertEquals( p5.x   , 3    )
  assertEquals( p5.z   , 6    )
  assertEquals( p5.y[1], 6    )
  assertEquals( p5.y[2], 12   )

  p2.x =4
  p2.a =2
  assertEquals( p2.x, 4 )
  assertEquals( p2.y, 8 )
  assertEquals( p2.a, 2 )

  local a = Object '' {}
  assertEquals( a.name, '' )
  local a = Object { x=1 }
  local b = a {}
  assertEquals( a.name, 'Object' )
  assertEquals( b.x   , a.x      )
  b.x = 2
  assertEquals( b.x , 2 )
end

function TestObject:testVariable()
end

function TestObject:testSpecialVariable()
end

function TestObject:testSetVariable()
  local o0 = Object 'o0' { a= 0.1, b =0.2 , c=0.3 }
  local o1 = o0 'o1' { a=-1.1, b={}           }
  local o2 = o1 'o2' { a=-1.1, b=\s s.a*2     }
  assertEquals( o2.a, -1.1)
  rawset( o2, 'a', o0.a )
  rawset( o2, 'c', 3    )
  rawset( o2, 'b', nil  )
  assertEquals( o2.a, 0.1 )
  assertEquals( o2.c, 3   )
  assertEquals( o2.b, 0.2 )
  o2.__var.a = nil
  assertEquals( o2.a, 0.1 )
  rawset( o2, '__var.a', nil  )
  assertEquals ( o2.__var.a, -1.1 )
end

function TestObject:testVariableInheritance()
end

function TestObject:testSetFunction()
  local Point = Object 'Point' { x=1, y=3        }
  local o1    = Object 'o1'    { x=2, y=\s 2*s.x }
  local o2    = Point 'o2' { z=1             }
  local o3    = o1 'o3'    { z=\s s.x/2+s.y  }
  local f=\x x*x
  local y=\x,y x*y

  --o1:set_function( '__mul', f )  -- you can change methamethod with this function -- test missing if you really can
  Point:set_function({y=f}, true)
  o1:set_function ({y=y}, true)
  o1:set_function {sin=sin}
  assertEquals( Point.y(9),  81 )
  assertEquals( o1.y(2,-2), -4  )
  assertEquals( o1.sin(0) ,  0  )

  o3:set_function { f=\x,y   (x+y, x-y)         }
  o2:set_function { g=\s,x,y (x+y, x-y, s.name) }
  local a,b = o3.f(2, 1)
  assertEquals( a, 3 )
  assertEquals( b, 1 )
  local a,b = o2.g(o2, 2, 5)
  assertEquals( o2.g(o2, 2, 5), 7 )
  assertEquals( a,  7 )
  assertEquals( b, -3 )

  local a, b = o3.f(-2,1)
  assertEquals( a, -1 )
  assertEquals( b, -3 )
  local a,b,c = o2.g( o2, -1.2, 1.2)
  assertEquals( a, 0    )
  assertEquals( b, -2.4 )
  assertEquals( c, 'o2' )

  --isErrEqu( "invalid 'self' argument, valid object expected", )
  --isErrEqu( "invalid 'func' argument, not callable"         , )
end

function TestObject:testFunctionInheritance()
end

function TestObject:testSetMethod()
  local Point = Object 'Point' { x=1, y=3        }
  local o1    = Object 'o1'    { x=2, y=\s 2*s.x }
  local f=\x x*x
  local y=\x,y (x*y, 2*x+2*y)
  --isErrEqu( "invalid 'self' argument, valid object expected", )
  --isErrEqu( "invalid 'func' argument, not callable"         , )
  --isErrEqu( "object.lua:264: invalid 'name' argument, metamethod detected", o1:set_method( '__add', f ) )

  o1:set_method {f=f}
  o1:set_method {y=y}
  assertEquals( o1.f(2), 4 )
  local a,b = o1.y(2,2)
  assertEquals( a, 4 )
  assertEquals( b, 8 )

  local fig = Object 'fig' { len = 0, width = 0 }
  local f =\s s.len * s.width
  fig:set_method {field=f}
  fig:set_function {f=f}
  assertTrue( is_table(fig.f) )
  assertTrue( is_function(fig.field) )

  local sq = fig 'sq' { field =\s s.len*s.len }
  sq:set_method {field=f}
  assertTrue( is_function(sq.field) )
end

function TestObject:testMethodInheritance()
end

function TestObject:testSetMetamethod()
  local o0 = Object 'o0' { a= 0.1, b =0.2 , c=0.3 }
  local o1 = o0 'o1' { a=-1.1, b={}           }

  --o0:set_metamethod('__eq', )
end

function TestObject:testMetamethodInheritance()
  --isErrEqu("cannot override inherited behavior", )
  --isErrEqu( "invalid 'self' argument, valid object expected", )
  --isErrEqu( "invalid 'name' argument, not a metamethod"     , )
  --isErrEqu( "invalid 'func' argument, not callable"         , )

  local p1 = Object 'p1' { x=1, y=2  }
  local p2 = p1 'p2' { x=2, y=-1, z=0 }
  local p3 = p2 'p3' { x=3  }

  local function trace (fp, self, k, v)
--[[    fp:write("object: '", self.name,
             "' is updated for key: '", tostring(k),
             "' with value: ")
    if type(v) == "string"
      then fp:write(": '", tostring(v), "'\n")
      else fp:write(":  ", tostring(v),  "\n") end
]]  end

  local function set_notification (self, file)
    local fp = file or io.stdout
    local mt = getmetatable(self)
    local nwidx = mt and rawget(mt, '__newindex')
    local mm = function (self, k, v)
      trace(fp, self, k, v) -- logging
      nwidx(    self, k, v) -- forward
    end
    self:set_metamethod({__newindex=mm}, true) -- override!
  end

  set_notification(p2) -- new metamethod created, metatable is cloned
  p2.x = 3 -- new behavior, notify about update
  p3.x = 4 -- created before set_metamethod (bad!), old behavior

  local p4 = p2 'p4' { x=3 } -- new, inherit metatable
  p4.x = 5 -- new behavior, notify about update if you really can
end

function TestObject:testCount() --subtest of set_methamethod
  local oO = Object '' {}
  local count = 0
  local function set_counter (self)
    local mm = function (self)
      count = count + 1
      return self
    end
    self:set_metamethod {__init = mm}
  end
  o0 = Object 'o0' {}
  set_counter(o0)

  local o1 = o0 'o1' { a = 2 }
  assertEquals( count, 1 )
  local o2 = o1 'o2' { a = 2 }
  assertEquals( count, 2 )
  local a = Object 'a' { x = o2.a }
  assertEquals( count, 2 )
end

function TestObject:testSetParent()
  local Po = Object 'Po' { x=1, y=3       }
  local p1 = Po 'p1' { x=3, y=2, z=1  }
  local p2 = p1 'p2' { y=\s 2*s.x     }
  local p3 = p2 'p3' { x=2, y=1, z=x  }
  assertEquals( p2.x, p1.x )
  assertEquals( p2.z, p1.z )

  p2:set_parent( Po )
  assertEquals( p2.x, Po.x )
  assertEquals( p2.z, Po.z )
  assertEquals( p2.z, nil  )

  p1:set_parent( p3 )
  assertNotEquals( p1.x, p3.x )
  assertNotEquals( p1.y, p3.y )
  assertNotEquals( p1.z, p3.z )
  assertEquals( p1.x, 3 )
  assertEquals( p1.y, 2 )
  assertEquals( p1.z, 1 )

  local ob = Object '' {}
  ob:set_parent( p1 )
  assertEquals( ob.x, p1.x )
  assertEquals( ob.y, p1.y )
  assertEquals( ob.z, p1.z )

  --isErrEqu( "'Object' must stay the root of objects", )
  --isErrEqu( "invalid 'self' argument, table or object expected", )
  --isErrEqu( "invalid 'obj' argument, valid object expected", )
end

-- performance test suite -----------------------------------------------------o

Test_Object = {}

function Test_Object:testPrimes()
  local Primes = Object {}

  Primes:set_function {
    isPrimeDivisible = \s,c =>
      for i=3, s.prime_count do
        if s.primes[i] * s.primes[i] > c then break end
        if c % s.primes[i] == 0 then return true end
      end
      return false
    end,

    addPrime = \s,c =>
      s.prime_count = s.prime_count + 1
      s.primes[s.prime_count] = c
    end,

    getPrimes = \s,n =>
      s.prime_count, s.primes = 3, { 1,2,3 }
      local c = 5
      while s.prime_count < n do
        if not s:isPrimeDivisible(c) then
          s:addPrime(c)
        end
        c = c + 2
      end
    end
  }

  local p = Primes {}
  local t0 = os.clock()
  p:getPrimes(2e5)
  local dt = os.clock() - t0
  assertAlmostEquals( dt , 0.5, 1 )
  assertEquals( p.primes[p.prime_count], 2750131 )
end

function Test_Object:testDuplicates()
  local DupFinder = Object {}

  DupFinder:set_method {
    find_duplicates = \s,res =>
      for _,v in ipairs(s) do
        res[v] = res[v] and res[v]+1 or 1
      end
      for _,v in ipairs(s) do
        if res[v] and res[v] > 1 then
          res[#res+1] = v
        end
        res[v] = nil
      end
    end,

    clear = \s =>
      for i=1,#s do s[i]=nil end
      return s
    end
  }

  local inp = DupFinder {'b','a','c','c','e','a','c','d','c','d'}
  local out = DupFinder {'a','c','d'}
  local res = DupFinder {}

  local t0 = os.clock()
  for i=1,5e5 do inp:find_duplicates(res:clear()) end
  local dt = os.clock() - t0
  assertAlmostEquals( dt , 0.5, 1 )
  assertEquals( res, out )
end

-- end ------------------------------------------------------------------------o
