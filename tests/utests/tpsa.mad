--[=[
 o-----------------------------------------------------------------------------o
 |
 | GTPSA module unit tests - real tpsa
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: 
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide regression test suites for the tpsa module.

 o-----------------------------------------------------------------------------o
]=]

local vector, tpsa, ctpsa, gtpsad, tpsa_eqn, monomial            in MAD
local eps, abs, pi                                               in MAD.constant
local abs                                                        in MAD.gmath
local ident                                                      in MAD.gfunc
local assertTrue, assertEquals, assertAlmostEquals, 
      assrtIsFalse, assertErrorMsgContains, 
      assertError, assertNil, assertFalse                        in MAD.utest
local is_tpsa, is_ctpsa, is_gtpsad, is_number, is_complex        in MAD.typeid

-- locals ---------------------------------------------------------------------o

local dat = assert(loadfile('data/tpsa.dat'))()

local ord = {1,2,3,4,5,6,7,10,12,15}

-- regression test suites -----------------------------------------------------o

local Data = {}
Data.t1v = {}
Data.t2v = {}
Data.ct1v = {}
Data.ct2v = {}
local d1v = gtpsad(1,5)
local d2v = gtpsad(2,5)
local d3v = gtpsad(3,5)

TestTPSACtor     = {}
TestTPSA2Index   = {}
TestTPSAGet      = {}
TestTPSASet      = {}
TestTPSALinComb  = {}
TestTPSALogicOps = {}

for nv=1,2 do
  for key, ord in pairs(ord) do
    local d = gtpsad(nv,ord)
    Data.t1v[#Data.t1v+1]   = tpsa( )
    Data.ct1v[#Data.ct1v+1] = ctpsa()
    Data.t2v[#Data.t1v+1]   = tpsa( )
    Data.ct2v[#Data.ct1v+1] = ctpsa()
  end
end


function TestTPSACtor:testCtor()
  for nv = 1, 2 do
    local d   = gtpsad(nv, 15)
    local t1  = tpsa  (      )
    local t2  = tpsa  (     d)
    local t3  = tpsa  (    t1)
    local ct1 = ctpsa (      )
    local ct2 = ctpsa (     d)
    local ct3 = ctpsa (   ct1)

    assertEquals(t1 :nv()  , nv)
    assertEquals(t1 :mord(), 15)
    assertEquals(t2 :nv()  , nv)
    assertEquals(t2 :mord(), 15)
    assertEquals(t3 :nv()  , nv)
    assertEquals(t3 :mord(), 15)
    assertEquals(ct1:nv()  , nv)
    assertEquals(ct1:mord(), 15)
    assertEquals(ct2:nv()  , nv)
    assertEquals(ct2:mord(), 15)
    assertEquals(ct3:nv()  , nv)
    assertEquals(ct3:mord(), 15)
  end
end


function TestTPSACtor:testCtorMo()
  for nv = 1, 2 do
    local d   = gtpsad(nv, 15)
    for o=0, d:maxord() + 1 do
      local t1  = tpsa (     o)
      local t2  = tpsa (d,   o)
      local t3  = tpsa (t1,  o)
      local ct1 = ctpsa(     o)
      local ct2 = ctpsa(d  , o)
      local ct3 = ctpsa(ct1, o)
      if o < 15 then
        assertEquals(t1 :nv(),   nv)
        assertEquals(t2 :nv(),   nv)
        assertEquals(t3 :nv(),   nv)
        assertEquals(ct1:nv(),   nv)
        assertEquals(ct2:nv(),   nv)
        assertEquals(ct3:nv(),   nv)
        assertEquals(t1 :mord(),  o)
        assertEquals(t2 :mord(),  o)
        assertEquals(t3 :mord(),  o)
        assertEquals(ct1:mord(),  o)
        assertEquals(ct2:mord(),  o)
        assertEquals(ct3:mord(),  o)
      else  --check that if we create a tpsa with ord > d.maxord() is not allowed
        assertEquals(t1 :mord(),  d:maxord())
        assertEquals(t2 :mord(),  d:maxord())
        assertEquals(t3 :mord(),  d:maxord())
        assertEquals(ct1:mord(),  d:maxord())
        assertEquals(ct2:mord(),  d:maxord())
        assertEquals(ct3:mord(),  d:maxord())
      end
    end
  end
end


function TestTPSA2Index:testTPSAMonoStr2IndexSingVar()
  local d = gtpsad(1,50)
  local t = tpsa()
  local ct = ctpsa()

  assertEquals(t :get_idx(monomial(1,  2)),  t:get_idx("2"))
  assertEquals(ct:get_idx(monomial(1,  2)), ct:get_idx("2"))
  assertEquals(t :get_idx(monomial(1, 21)),  t:get_idx("L"))
  assertEquals(ct:get_idx(monomial(1, 21)), ct:get_idx("L"))
  assertEquals(t :get_idx(monomial(1, 42)),  t:get_idx("g"))
  assertEquals(ct:get_idx(monomial(1, 42)), ct:get_idx("g"))
  assertEquals(t :get_idx(monomial({16} )),  t:get_idx("G"))
  assertEquals(ct:get_idx(monomial({16} )), ct:get_idx("G"))
  assertEquals(t :get_idx(monomial("a"  )),  t:get_idx("a"))
  assertEquals(ct:get_idx(monomial("a"  )), ct:get_idx("a"))
end


function TestTPSA2Index:testTPSAMonoStr2IndexMultVar()
  local d = gtpsad(2,50)
  local t = tpsa()
  local ct = ctpsa()

  assertEquals(t :get_idx(monomial(2,     2)),  t:get_idx("22"))
  assertEquals(ct:get_idx(monomial(2,     2)), ct:get_idx("22"))
  assertEquals(t :get_idx(monomial(2,    21)),  t:get_idx("LL"))
  assertEquals(ct:get_idx(monomial(2,    21)), ct:get_idx("LL"))
  assertEquals(t :get_idx(monomial(2,    25)),  t:get_idx("PP"))
  assertEquals(ct:get_idx(monomial(2,    25)), ct:get_idx("PP"))
  assertEquals(t :get_idx(monomial({16, 15})),  t:get_idx("GF"))
  assertEquals(ct:get_idx(monomial({16, 15})), ct:get_idx("GF"))
  assertEquals(t :get_idx(monomial("AB"    )),  t:get_idx("AB"))
  assertEquals(ct:get_idx(monomial("AB"    )), ct:get_idx("AB"))
end


function TestTPSA2Index:testTPSAMono2IndexSingVar()
  local t = tpsa(d1v)
  local ct = ctpsa(d1v)
  
  --check that non valid orders return index 0
  assertEquals(t :get_idx(monomial(1,d1v:maxord() + 1)), 0)
  assertEquals(ct:get_idx(monomial(1,              -1)), 0)
  for ord = 0, d1v:maxord() do
    assertEquals(t :get_idx(monomial(1,ord)), ord + 1)
    assertEquals(ct:get_idx(monomial(1,ord)), ord + 1)
  end
end


function TestTPSA2Index:testTPSAMono2IndexMultVar()
  local t = tpsa(d2v)
  local ct = ctpsa(d2v)
  local count = 0
  
  --check that non valid orders return index 0
  assertEquals(t :get_idx(monomial({1           ,  d1v:maxord()})), 0)
  assertEquals(t :get_idx(monomial({d1v:maxord(),             1})), 0)
  assertEquals(t :get_idx(monomial({-1          ,             0})), 0)
  assertEquals(t :get_idx(monomial({0           ,            -1})), 0)
  for ord = 0, d1v:maxord() do
    for idx = 0, ord  do  --scanning all the coeff of a given order
      assertEquals(t :get_idx(monomial({ord - idx, idx})), count + 1)
      count = count + 1
    end
  end
end


function TestTPSAGet:testGet0()
  for _,d in ipairs{d1v,d2v} do
    local t  =  tpsa(d,1):set0(   1)
    local ct = ctpsa(d,1):set0(1+1i)

    assertEquals(t :get0(),    1)
    assertEquals(ct:get0(), 1+1i)
  end
end


function TestTPSAGet:testGetIdx()
  for _,d in ipairs{d1v,d2v} do
    local n  = d:maxlen()
    local t  = tpsa (d):fill(1..n)
    local ct = ctpsa(d):fill(1..n)*1i
  
    for i=1,n do
      assertEquals(t :get(i),  i   )
      assertEquals(ct:get(i),  i*1i)
    end

    assertError(t .get,  t,  -1)
    assertError(ct.get, ct,  -1)
    assertError(t .get,  t, n+1)
    assertError(ct.get, ct, n+1)
  end
end


function TestTPSAGet:testGetIdxMo()
  for _,d in ipairs{d1v,d2v} do
    for o=0, d:maxord() + 1 do
      local n  =  tpsa(d,o):mlen()
      print(n)
      local t  =  tpsa (d,o):fill(1..n)
      local ct =  ctpsa(d,o):fill(1..n)*1i

      for i=1, n do
        assertEquals(t :get(i), i   )
        assertEquals(ct:get(i), i*1i)
      end

      if o < 5 then
        assertError (t .get,  t, -1)
        assertError (ct.get, ct, -1)
        assertEquals(t :get(    n+1),       0)
        assertEquals(ct:get(    n+1),  0 + 0i)
      else
        assertError (t .get,  t,   0)
        assertError (ct.get, ct,   0)
        assertError (t .get,  t, n+1)
        assertError (ct.get, ct, n+1)
      end
    end
  end
end


function TestTPSAGet:testGetVecSingVar()
  local sz_t = d1v:maxlen()
  local t    = tpsa (d1v,4):set(3,  1):set(4,  2):set(5,  3)
  local ct   = ctpsa(d1v,4):set(3, 1i):set(4, 2i):set(5, 3i)

  assertEquals(t :getvec(2,1), vector(1):fill(0..0)   )
  assertEquals(ct:getvec(2,1), vector(1):fill(0..0)*1i)
  assertEquals(t :getvec(2,2), vector(2):fill(0..1)   )
  assertEquals(ct:getvec(2,2), vector(2):fill(0..1)*1i)
  assertEquals(t :getvec(3,3), vector(3):fill(1..3)   )
  assertEquals(ct:getvec(3,3), vector(3):fill(1..3)*1i)
  assertEquals(t :getvec(4,3), vector(3):fill({2,3,0})   )
  assertEquals(ct:getvec(4,3), vector(3):fill({2,3,0})*1i)
  assertEquals(t :getvec(2,5), vector(5):fill({0,1,2,3,0})   )
  assertEquals(ct:getvec(2,5), vector(5):fill({0,1,2,3,0})*1i)
  assertError(t .getvec,      0, 1)
  assertError(ct.getvec,      0, 1)
  assertError(t .getvec, sz_t+1, 1)
  assertError(ct.getvec, sz_t+1, 1)
end

function TestTPSAGet:testGetVecMultVar()
  local sz_t = d3v:maxlen()
  local t    = tpsa (d3v):setvec(5,1..sz_t-25)   --filling all the orders but the first and last ones
  local ct   = ctpsa(d3v):setvec(5,1..sz_t-25)*1i
  local vec = (vector(2):zeros():concat(vector(sz_t-25):fill(1..sz_t-25), "vec")):concat(vector(1):set(1,1,0), "vec")
 
  assertEquals(t :getvec( 2,      3), vector( 3):fill({0,0,0})   )
  assertEquals(ct:getvec( 2,      3), vector( 3):fill({0,0,0})*1i)
  assertEquals(t :getvec( 3,      2), vector( 2):fill({0,0})   )
  assertEquals(t :getvec( 3,      2), vector( 2):fill({0,0})*1i)
  assertEquals(t :getvec( 3,      4), vector( 4):fill({0,0,1,2})   )
  assertEquals(ct:getvec( 3,      4), vector( 4):fill({0,0,1,2})*1i)
  assertEquals(t :getvec( 3,     34), vec   )
  assertEquals(ct:getvec( 3,     34), vec*1i)
  assertEquals(t :getvec( 6,     21), vector( 21):fill(2 ..22)   )
  assertEquals(ct:getvec( 6,     21), vector( 21):fill(2 ..22)*1i)
  assertEquals(t :getvec(33,      5), vector(5):fill({29,30,31,0,0})   )
  assertEquals(ct:getvec(33,      5), vector(5):fill({29,30,31,0,0})*1i)
  assertEquals(t :getvec(36,      5), vector(5):zeros()   )
  assertEquals(ct:getvec(36,      5), vector(5):zeros()*1i)
  assertEquals(t :getvec(39,      5), vector(5):zeros()   )
  assertEquals(ct:getvec(39,      5), vector(5):zeros()*1i)
  assertEquals(t :getvec(36,sz_t-35), vector(sz_t-35):zeros()   )
  assertEquals(ct:getvec(36,sz_t-35), vector(sz_t-35):zeros()*1i)
  assertError(t .getvec,      0, 1)
  assertError(ct.getvec,      0, 1)
  assertError(t .getvec, sz_t+1, 1)
  assertError(ct.getvec, sz_t+1, 1)
end


function TestTPSASet:testTPSASet0SingVar()
  for _,d in ipairs{d1v,d2v} do
    local t1  =  tpsa(d,1):set0(   1)
    local ct1 = ctpsa(d,1):set0(1+1i)
    local t2  =  tpsa(d,1):set0(   1):set0(   2,   3)
    local ct2 = ctpsa(d,1):set0(   1):set0(2+1i, 3+1i)

    assertEquals(t1 :get0(),    1)
    assertEquals(ct1:get0(), 1+1i)
    assertEquals(t2 :get0(),    5)
    assertEquals(ct2:get0(), 5+2i)
  end
end


function TestTPSASet:testSetStrSingVar()
  local t  = tpsa (d1v)
  local ct = ctpsa(d1v)

  assertEquals(t :set("2" ,   1):mord(true), 2)
  assertEquals(ct:set("2" ,  1i):mord(true), 2)
  assertEquals(t :set("4" ,   1):mord(true), 4)
  assertEquals(ct:set("4" ,  1i):mord(true), 4)
  assertEquals(t :get("1"),  0)
  assertEquals(ct:get("1"), 0i)
  assertEquals(t :get("2"),  1)
  assertEquals(ct:get("2"), 1i)
  assertEquals(t :get("3"),  0)
  assertEquals(ct:get("3"), 0i)
  assertEquals(t :get("4"),  1)
  assertEquals(ct:get("4"), 1i)
  assertEquals(t :get("5"),  0)
  assertEquals(ct:get("5"), 0i)
  assertError (t .set,   t, "-1", 1)
  assertError (ct.set,  ct, "-1", 1)
  assertError (t .set,   t,  "6", 1)
  assertError (ct.set,  ct,  "6", 1)
end


function TestTPSASet:testSetStrMultVar()
  local t    = tpsa (d3v)
  local ct   = ctpsa(d3v)
  local sz_t = t:mlen()
  local vec = vector(sz_t):zeros():set(5,1,1):set(7,1,1):set(10,1,1):set(21,1,1):set(28,1,1):set(35,1,1)
 
  assertEquals(t :set("200", 1):mord(true), 2)  
  assertEquals(ct:set("200",1i):mord(true), 2)
  assertEquals(t :set("020", 1):mord(true), 2)  
  assertEquals(ct:set("020",1i):mord(true), 2)
  assertEquals(t :set("002", 1):mord(true), 2)  
  assertEquals(ct:set("002",1i):mord(true), 2)
  assertEquals(t :set("400", 1):mord(true), 4)
  assertEquals(ct:set("400",1i):mord(true), 4)
  assertEquals(t :set("121", 1):mord(true), 4)
  assertEquals(ct:set("121",1i):mord(true), 4)
  assertEquals(t :set("004", 1):mord(true), 4)
  assertEquals(ct:set("004",1i):mord(true), 4)
  assertEquals(t :get("000"),    0)
  assertEquals(ct:get("000"),   0i)
  assertEquals(t :get("200"),    1)
  assertEquals(ct:get("200"),   1i)
  assertEquals(t :get("020"),    1)
  assertEquals(ct:get("020"),   1i)
  assertEquals(t :get("002"),    1)
  assertEquals(ct:get("002"),   1i)
  assertEquals(t :get("400"),    1)
  assertEquals(ct:get("400"),   1i)
  assertEquals(t :get("121"),    1)
  assertEquals(ct:get("121"),   1i)
  assertEquals(t :get("004"),    1)
  assertEquals(ct:get("004"),   1i)
  assertEquals(t :getvec(1, sz_t), vec  )
  assertEquals(ct:getvec(1, sz_t), vec*1i)
  assertError (t .set, t , "-1",1)
  assertError (ct.set, ct, "-1",1)
  assertError (t .set, t ,  "6",1)
  assertError (ct.set, ct,  "6",1)
end


function TestTPSASet:testSetVec ()
  local d = gtpsad(5,4)
  local t,v = tpsa, vector
  local mo, nc = d:maxord(), d:maxlen()
  local idx = {[0]=0} for o=0,mo do idx[o+1] = d:maxlen(o)+1 end

  -- helpers to setvec tpsas and vectors within start..end
  local mkt = \s,e -> (s, v(e-s+1):fill(s..e))
  local mkv = \s,e -> (s..e, s..e)

  -- ref tpsa, see cases in mad_tpsa.c
  local r = t(d):setvec(idx[2], idx[2]..idx[4]-1)

--   0   1     lo=2      hi=3        mo=4
--  [.|?????|........|..........|????????????]
--  [ |i...n|        |          |            ]
  assertTrue( r:copy():setvec(mkt(idx[1]  , idx[2]-1)):getvec(1,nc)
              == v(nc):setvec(mkv(idx[1]  , idx[4]-1)) )
--  [ |0i..n|        |          |            ]
  assertTrue( r:copy():setvec(mkt(idx[1]+1, idx[2]-1)):getvec(1,nc)
              == v(nc):setvec(mkv(idx[1]+1, idx[4]-1)) )
--  [ |0i.n0|        |          |            ]
  assertTrue( r:copy():setvec(mkt(idx[1]+1, idx[2]-2)):getvec(1,nc)
              == v(nc):setvec(mkv(idx[1]+1, idx[4]-1)):set(idx[2]-1,1,0) )
--  [ |0i...|....n   |          |            ]
  assertTrue( r:copy():setvec(mkt(idx[1]+1, idx[3]-4)):getvec(1,nc)
              == v(nc):setvec(mkv(idx[1]+1, idx[4]-1)) )
--  [ |0i...|........|..........|.......n0000]
  assertTrue( r:copy():setvec(mkt(idx[1]+1, idx[5]-4)):getvec(1,nc)
              == v(nc):setvec(mkv(idx[1]+1, idx[5]-4)) )
--  [ |     |  i.....|......n   |            ]
  assertTrue( r:copy():setvec(mkt(idx[2]+2, idx[3]-3)):getvec(1,nc)
              == v(nc):setvec(mkv(idx[2]  , idx[4]-1)) )
--  [ |     |        |   i......|.......n0000]
  assertTrue( r:copy():setvec(mkt(idx[3]+3, idx[5]-5)):getvec(1,nc)
              == v(nc):setvec(mkv(idx[2]  , idx[5]-5)) )
--  [ |     |        |          |i......n0000]
  assertTrue( r:copy():setvec(mkt(idx[4]  , idx[5]-5)):getvec(1,nc)
              == v(nc):setvec(mkv(idx[2]  , idx[5]-5)) )
--  [ |     |        |          |0i.....n0000]
  assertTrue( r:copy():setvec(mkt(idx[4]+1, idx[5]-5)):getvec(1,nc)
              == v(nc):setvec(mkv(idx[2]  , idx[5]-5)):set(idx[4],1,0) )
--  [ |     |        |          |i..........n]
  assertTrue( r:copy():setvec(mkt(idx[4]  , idx[5]-1)):getvec(1,nc)
              == v(nc):setvec(mkv(idx[2]  , idx[5]-1)) )
end


function TestTPSALogicOps:testEqu()
  for _,d in ipairs{d1v,d2v,d3v} do
  
    for o = 1, d:maxord() do
      assertFalse(       nil           ==          tpsa(d,o))
      assertFalse( tpsa(d,o)           ==                nil)
      assertFalse(       nil           ==         ctpsa(d,o))
      assertFalse(ctpsa(d,o)           ==                nil)
      assertTrue (         0           ==          tpsa(d,o))
      assertTrue ( tpsa(d,o)           ==                  0)
      assertTrue (        0i           ==         ctpsa(d,o))
      assertTrue (ctpsa(d,o)           ==                 0i)
      assertFalse(         1           ==          tpsa(d,o))
      assertFalse( tpsa(d,o)           ==                  1)
      assertFalse(        1i           ==         ctpsa(d,o))
      assertFalse(ctpsa(d,o)           ==                 1i)
      assertFalse(        1i           ==         ctpsa(d,o))
      assertTrue ( tpsa(d  ):set(o, 1) ==  tpsa(d):set(o, 1))
      assertTrue (ctpsa(d  ):set(o,1i) == ctpsa(d):set(o,1i))
      assertFalse( tpsa(d  ):set(o, 1) ==  tpsa(d):set(o, 2))
      assertFalse(ctpsa(d  ):set(o,1i) == ctpsa(d):set(o,2i))
      assertFalse( tpsa(d  ):set(o, 1) ==  tpsa(d):set(o, 2))
      assertFalse(ctpsa(d  ):set(o,1i) == ctpsa(d):set(o,2i))
      assertTrue ( tpsa(d  ):set(o, 1) == ctpsa(d):set(o, 1))
      assertTrue (ctpsa(d  ):set(o, 1) == ctpsa(d):set(o, 1))
      assertError( tpsa(d,o).__eq , tpsa(d), 1, 'err')
      assertError(ctpsa(d,o).__eq ,ctpsa(d), 1, 'err')
    end

    for o = 1, d:maxord()-1 do
      assertFalse( tpsa(d    ):set(o  , 1)    ==  tpsa(d    ):set(o+1, 1))
      assertFalse( tpsa(d    ):set(o+1, 1)    ==  tpsa(d    ):set(o  , 1))
      assertFalse(ctpsa(d    ):set(o  ,1i)    == ctpsa(d    ):set(o+1,1i))
      assertFalse(ctpsa(d    ):set(o+1,1i)    == ctpsa(d    ):set(o  ,1i))
      assertFalse(ctpsa(d    ):set(o  ,1i)    ==  tpsa(d    ):set(o+1,1i))
      assertFalse(ctpsa(d    ):set(o+1,1i)    == ctpsa(d    ):set(o  ,1i))
      assertTrue ( tpsa(d,  o):set(o  , 1)    ==  tpsa(d,o+1):set(o  , 1))
      assertTrue ( tpsa(d,o+1):set(o  , 1)    ==  tpsa(d,  o):set(o  , 1))
      assertTrue (ctpsa(d,  o):set(o  ,1i)    == ctpsa(d,o+1):set(o  ,1i))
      assertTrue (ctpsa(d,o+1):set(o  ,1i)    == ctpsa(d,  o):set(o  ,1i))
    end
  end
end


function TestTPSALinComb:testAxpbypc1V()
  local t0   =  tpsa(d1v):set("0",1)
  local t1   =  tpsa(d1v):set("1",2)
  local t12  =  tpsa(d1v):set("1",2):set("2",3)
  local t15  =  tpsa(d1v):setvec(2, {2,3,4,5,6})
  local t24  =  tpsa(d1v):setvec(3, {3,4,5})
  local t45  =  tpsa(d1v):setvec(5, {5,6})
  local t5   =  tpsa(d1v):set("5", 6)

  assertTrue(t0  :axpbypc(t0  ,2,3,4) == tpsa(d1v):setvec(1,{9, 0, 0, 0, 0, 0}))
  assertTrue(t1  :axpbypc(t0  ,2,3,4) == tpsa(d1v):setvec(1,{7, 4, 0, 0, 0, 0}))
  assertTrue(t0  :axpbypc(t1  ,3,2,4) == tpsa(d1v):setvec(1,{7, 4, 0, 0, 0, 0}))
  assertTrue(t12 :axpbypc(t0  ,2,3,4) == tpsa(d1v):setvec(1,{7, 4, 6, 0, 0, 0}))
  assertTrue(t0  :axpbypc(t12 ,3,2,4) == tpsa(d1v):setvec(1,{7, 4, 6, 0, 0, 0}))
  assertTrue(t15 :axpbypc(t0  ,2,3,4) == tpsa(d1v):setvec(1,{7, 4, 6, 8,10,12}))
  assertTrue(t0  :axpbypc(t15 ,3,2,4) == tpsa(d1v):setvec(1,{7, 4, 6, 8,10,12}))
  assertTrue(t5  :axpbypc(t0  ,2,3,4) == tpsa(d1v):setvec(1,{7, 0, 0, 0, 0,12}))
  assertTrue(t0  :axpbypc(t5  ,3,2,4) == tpsa(d1v):setvec(1,{7, 0, 0, 0, 0,12}))
  assertTrue(t5  :axpbypc(t0  ,2,3,4) == tpsa(d1v):setvec(1,{7, 0, 0, 0, 0,12}))
  assertTrue(t0  :axpbypc(t5  ,3,2,4) == tpsa(d1v):setvec(1,{7, 0, 0, 0, 0,12}))
  assertTrue(t1  :axpbypc(t1  ,2,3,4) == tpsa(d1v):setvec(1,{4,10, 0, 0, 0, 0}))
  assertTrue(t12 :axpbypc(t1  ,2,3,4) == tpsa(d1v):setvec(1,{4,10, 6, 0, 0, 0}))
  assertTrue(t1  :axpbypc(t12 ,3,2,4) == tpsa(d1v):setvec(1,{4,10, 6, 0, 0, 0}))
  assertTrue(t24 :axpbypc(t1  ,2,3,4) == tpsa(d1v):setvec(1,{4, 6, 6, 8,10, 0}))
  assertTrue(t1  :axpbypc(t24 ,3,2,4) == tpsa(d1v):setvec(1,{4, 6, 6, 8,10, 0}))
  assertTrue(t45 :axpbypc(t1  ,2,3,4) == tpsa(d1v):setvec(1,{4, 6, 0, 0,10,12}))
  assertTrue(t1  :axpbypc(t45 ,3,2,4) == tpsa(d1v):setvec(1,{4, 6, 0, 0,10,12}))
  assertTrue(t5  :axpbypc(t1  ,2,3,4) == tpsa(d1v):setvec(1,{4, 6, 0, 0, 0,12}))
  assertTrue(t1  :axpbypc(t5  ,3,2,4) == tpsa(d1v):setvec(1,{4, 6, 0, 0, 0,12}))
  assertTrue(t12 :axpbypc(t12 ,2,3,4) == tpsa(d1v):setvec(1,{4,10,15, 0, 0, 0}))
  assertTrue(t15 :axpbypc(t12 ,2,3,4) == tpsa(d1v):setvec(1,{4,10,15, 8,10,12}))
  assertTrue(t12 :axpbypc(t15 ,3,2,4) == tpsa(d1v):setvec(1,{4,10,15, 8,10,12}))
  assertTrue(t24 :axpbypc(t12 ,2,3,4) == tpsa(d1v):setvec(1,{4, 6,15, 8,10, 0}))
  assertTrue(t12 :axpbypc(t24 ,3,2,4) == tpsa(d1v):setvec(1,{4, 6,15, 8,10, 0}))
  assertTrue(t24 :axpbypc(t12 ,2,3,4) == tpsa(d1v):setvec(1,{4, 6,15, 8,10, 0}))
  assertTrue(t12 :axpbypc(t24 ,3,2,4) == tpsa(d1v):setvec(1,{4, 6,15, 8,10, 0}))
  assertTrue(t45 :axpbypc(t12 ,2,3,4) == tpsa(d1v):setvec(1,{4, 6, 9, 0,10,12}))
  assertTrue(t12 :axpbypc(t45 ,3,2,4) == tpsa(d1v):setvec(1,{4, 6, 9, 0,10,12}))
  assertTrue(t5  :axpbypc(t12 ,2,3,4) == tpsa(d1v):setvec(1,{4, 6, 9, 0, 0,12}))
  assertTrue(t12 :axpbypc(t5  ,3,2,4) == tpsa(d1v):setvec(1,{4, 6, 9, 0, 0,12}))
  assertTrue(t15 :axpbypc(t15 ,2,3,4) == tpsa(d1v):setvec(1,{4,10,15,20,25,30}))
  assertTrue(t24 :axpbypc(t15 ,2,3,4) == tpsa(d1v):setvec(1,{4, 6,15,20,25,18}))
  assertTrue(t15 :axpbypc(t24 ,3,2,4) == tpsa(d1v):setvec(1,{4, 6,15,20,25,18}))
  assertTrue(t45 :axpbypc(t15 ,2,3,4) == tpsa(d1v):setvec(1,{4, 6, 9,12,25,30}))
  assertTrue(t15 :axpbypc(t45 ,3,2,4) == tpsa(d1v):setvec(1,{4, 6, 9,12,25,30}))
  assertTrue(t5  :axpbypc(t15 ,2,3,4) == tpsa(d1v):setvec(1,{4, 6, 9,12,15,30}))
  assertTrue(t15 :axpbypc(t5  ,3,2,4) == tpsa(d1v):setvec(1,{4, 6, 9,12,15,30}))
  assertTrue(t24 :axpbypc(t24 ,2,3,4) == tpsa(d1v):setvec(1,{4, 0,15,20,25, 0}))
  assertTrue(t45 :axpbypc(t24 ,2,3,4) == tpsa(d1v):setvec(1,{4, 0, 9,12,25,12}))
  assertTrue(t24 :axpbypc(t45 ,3,2,4) == tpsa(d1v):setvec(1,{4, 0, 9,12,25,12}))
  assertTrue(t5  :axpbypc(t24 ,2,3,4) == tpsa(d1v):setvec(1,{4, 0, 9,12,15,12}))
  assertTrue(t24 :axpbypc(t5  ,3,2,4) == tpsa(d1v):setvec(1,{4, 0, 9,12,15,12}))
  assertTrue(t45 :axpbypc(t45 ,2,3,4) == tpsa(d1v):setvec(1,{4, 0, 0, 0,25,30}))
  assertTrue(t5  :axpbypc(t45 ,2,3,4) == tpsa(d1v):setvec(1,{4, 0, 0, 0,15,30}))
  assertTrue(t45 :axpbypc(t5  ,3,2,4) == tpsa(d1v):setvec(1,{4, 0, 0, 0,15,30}))
  assertTrue(t5  :axpbypc(t5  ,2,3,4) == tpsa(d1v):setvec(1,{4, 0, 0, 0, 0,30}))
end