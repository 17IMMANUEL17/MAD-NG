--[=[
 o-----------------------------------------------------------------------------o
 |
 | GTPSA module unit tests - real tpsa
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: 
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide regression test suites for the tpsa module.

 o-----------------------------------------------------------------------------o
]=]

local vector, tpsa, ctpsa, gtpsad, tpsa_eqn, monomial            in MAD
local eps, abs, pi                                               in MAD.constant
local abs                                                        in MAD.gmath
local ident                                                      in MAD.gfunc
local assertTrue, assertEquals, assertAlmostEquals, 
      assrtIsFalse, assertErrorMsgContains, 
      assertError, assertNil, assertFalse                      in MAD.utest
local is_tpsa, is_ctpsa, is_gtpsad, is_number, is_complex        in MAD.typeid

-- locals ---------------------------------------------------------------------o

local dat = assert(loadfile('data/tpsa.dat'))()

local ord = {1,2,3,4,5,6,7,10,12,15}

-- regression test suites -----------------------------------------------------o

local Data = {}
Data.t1v = {}
Data.t2v = {}
Data.ct1v = {}
Data.ct2v = {}
local d1v = gtpsad(1,5)
local d2v = gtpsad(2,5)

TestTPSACtor   = {}
TestTPSA2Index = {}
TestTPSAGet    = {}
TestTPSASet    = {}


for nv=1,2 do
  for key, ord in pairs(ord) do
    local d = gtpsad(nv,ord)
    Data.t1v[#Data.t1v+1]   = tpsa( )
    Data.ct1v[#Data.ct1v+1] = ctpsa()
    Data.t2v[#Data.t1v+1]   = tpsa( )
    Data.ct2v[#Data.ct1v+1] = ctpsa()
  end
end


function TestTPSACtor:testCtor()
  for nv = 1, 2 do
    local d   = gtpsad(nv, 15)
    local t1  = tpsa  (      )
    local t2  = tpsa  (     d)
    local t3  = tpsa  (    t1)
    local ct1 = ctpsa (      )
    local ct2 = ctpsa (     d)
    local ct3 = ctpsa (   ct1)

    assertEquals(t1 :nv()  , nv)
    assertEquals(t1 :mord(), 15)
    assertEquals(t2 :nv()  , nv)
    assertEquals(t2 :mord(), 15)
    assertEquals(t3 :nv()  , nv)
    assertEquals(t3 :mord(), 15)
    assertEquals(ct1:nv()  , nv)
    assertEquals(ct1:mord(), 15)
    assertEquals(ct2:nv()  , nv)
    assertEquals(ct2:mord(), 15)
    assertEquals(ct3:nv()  , nv)
    assertEquals(ct3:mord(), 15)
  end
end


function TestTPSACtor:testCtorMo()
  for nv = 1, 2 do
    local d   = gtpsad(nv, 15)
    for o=0, d:maxord() + 1 do
      local t1  = tpsa (     o)
      local t2  = tpsa (d,   o)
      local t3  = tpsa (t1,  o)
      local ct1 = ctpsa(     o)
      local ct2 = ctpsa(d  , o)
      local ct3 = ctpsa(ct1, o)
      if o < 15 then
        assertEquals(t1 :nv(),   nv)
        assertEquals(t2 :nv(),   nv)
        assertEquals(t3 :nv(),   nv)
        assertEquals(ct1:nv(),   nv)
        assertEquals(ct2:nv(),   nv)
        assertEquals(ct3:nv(),   nv)
        assertEquals(t1 :mord(),  o)
        assertEquals(t2 :mord(),  o)
        assertEquals(t3 :mord(),  o)
        assertEquals(ct1:mord(),  o)
        assertEquals(ct2:mord(),  o)
        assertEquals(ct3:mord(),  o)
      else  --check that if we create a tpsa with ord > d.maxord() is not allowed
        assertEquals(t1 :mord(),  d:maxord())
        assertEquals(t2 :mord(),  d:maxord())
        assertEquals(t3 :mord(),  d:maxord())
        assertEquals(ct1:mord(),  d:maxord())
        assertEquals(ct2:mord(),  d:maxord())
        assertEquals(ct3:mord(),  d:maxord())
      end
    end
  end
end


function TestTPSA2Index:testTPSAMonoStr2IndexSingVar()
  local d = gtpsad(1,50)
  local t = tpsa()
  local ct = ctpsa()

  assertEquals(t :get_idx(monomial(1,  2)),  t:get_idx("2"))
  assertEquals(ct:get_idx(monomial(1,  2)), ct:get_idx("2"))
  assertEquals(t :get_idx(monomial(1, 21)),  t:get_idx("L"))
  assertEquals(ct:get_idx(monomial(1, 21)), ct:get_idx("L"))
  assertEquals(t :get_idx(monomial(1, 42)),  t:get_idx("g"))
  assertEquals(ct:get_idx(monomial(1, 42)), ct:get_idx("g"))
  assertEquals(t :get_idx(monomial({16} )),  t:get_idx("G"))
  assertEquals(ct:get_idx(monomial({16} )), ct:get_idx("G"))
  assertEquals(t :get_idx(monomial("a"  )),  t:get_idx("a"))
  assertEquals(ct:get_idx(monomial("a"  )), ct:get_idx("a"))
end


function TestTPSA2Index:testTPSAMonoStr2IndexMultVar()
  local d = gtpsad(2,50)
  local t = tpsa()
  local ct = ctpsa()

  assertEquals(t :get_idx(monomial(2,     2)),  t:get_idx("22"))
  assertEquals(ct:get_idx(monomial(2,     2)), ct:get_idx("22"))
  assertEquals(t :get_idx(monomial(2,    21)),  t:get_idx("LL"))
  assertEquals(ct:get_idx(monomial(2,    21)), ct:get_idx("LL"))
  assertEquals(t :get_idx(monomial(2,    25)),  t:get_idx("PP"))
  assertEquals(ct:get_idx(monomial(2,    25)), ct:get_idx("PP"))
  assertEquals(t :get_idx(monomial({16, 15})),  t:get_idx("GF"))
  assertEquals(ct:get_idx(monomial({16, 15})), ct:get_idx("GF"))
  assertEquals(t :get_idx(monomial("AB"    )),  t:get_idx("AB"))
  assertEquals(ct:get_idx(monomial("AB"    )), ct:get_idx("AB"))
end


function TestTPSA2Index:testTPSAMono2IndexSingVar()
  local t = tpsa(d1v)
  local ct = ctpsa(d1v)
  
  --check that non valid orders return index 0
  assertEquals(t :get_idx(monomial(1,d1v:maxord() + 1)), 0)
  assertEquals(ct:get_idx(monomial(1,              -1)), 0)
  for ord = 0, d1v:maxord() do
    assertEquals(t :get_idx(monomial(1,ord)), ord + 1)
    assertEquals(ct:get_idx(monomial(1,ord)), ord + 1)
  end
end


function TestTPSA2Index:testTPSAMono2IndexMultVar()
  local t = tpsa(d2v)
  local ct = ctpsa(d2v)
  local count = 0
  
  --check that non valid orders return index 0
  assertEquals(t :get_idx(monomial({1           ,  d1v:maxord()})), 0)
  assertEquals(t :get_idx(monomial({d1v:maxord(),             1})), 0)
  assertEquals(t :get_idx(monomial({-1          ,             0})), 0)
  assertEquals(t :get_idx(monomial({0           ,            -1})), 0)
  for ord = 0, d1v:maxord() do
    for idx = 0, ord  do  --scanning all the coeff of a given order
      assertEquals(t :get_idx(monomial({ord - idx, idx})), count + 1)
      count = count + 1
    end
  end
end


function TestTPSAGet:testGet0()
  for _,d in ipairs{d1v,d2v} do
    local t  =  tpsa(d,1):set0(   1)
    local ct = ctpsa(d,1):set0(1+1i)

    assertEquals(t :get0(),    1)
    assertEquals(ct:get0(), 1+1i)
  end
end


function TestTPSAGet:testGetIdx()
  for _,d in ipairs{d1v,d2v} do
    local n  = d:maxlen()
    local t  = tpsa (d):fill(1..n)
    local ct = ctpsa(d):fill(1..n)*1i
  
    for i=1,n do
      assertEquals(t :get(i),  i   )
      assertEquals(ct:get(i),  i*1i)
    end

    assertError(t .get,  t,  -1)
    assertError(ct.get, ct,  -1)
    assertError(t .get,  t, n+1)
    assertError(ct.get, ct, n+1)
  end
end


function TestTPSAGet:testGetIdxMo()
  for _,d in ipairs{d1v,d2v} do
    for o=0, d:maxord() + 1 do
      local n  =  tpsa(d,o):mlen()
      print(n)
      local t  =  tpsa (d,o):fill(1..n)
      local ct =  ctpsa(d,o):fill(1..n)*1i

      for i=1, n do
        assertEquals(t :get(i), i   )
        assertEquals(ct:get(i), i*1i)
      end

      if o < 5 then
        assertError (t .get,  t, -1)
        assertError (ct.get, ct, -1)
        assertEquals(t :get(    n+1),       0)
        assertEquals(ct:get(    n+1),  0 + 0i)
      else
        assertError (t .get,  t,   0)
        assertError (ct.get, ct,   0)
        assertError (t .get,  t, n+1)
        assertError (ct.get, ct, n+1)
      end
    end
  end
end


function TestTPSAGet:testGetVec()
  local d1 = gtpsad(1, 5)
  local d2 = gtpsad(3, 5)
  
  for _,d in ipairs{d1,d2} do
    local sz_t = d:maxlen(4)
    local sz_d = d:maxlen( )
    local t    = tpsa (d,4):fill(1..sz_t)
    local ct   = ctpsa(d,4):fill(1..sz_t)*1i

    if t:nv() == 0 then
      assertEquals(t :getvec(1,5), vector(5):fill(1..5)   )
      assertEquals(ct:getvec(1,5), vector(5):fill(1..5)*1i)
      assertEquals(t :getvec(2,4), vector(4):fill(2..5)   )
      assertEquals(ct:getvec(2,4), vector(4):fill(2..5)*1i)
      assertEquals(t :getvec(1,4), vector(4):fill(1..4)   )
      assertEquals(ct:getvec(1,4), vector(4):fill(1..4)*1i)
      assertEquals(t :getvec(2,3), vector(3):fill(2..4)   )
      assertEquals(ct:getvec(2,3), vector(3):fill(2..4)*1i)
      assertEquals(t :getvec(2,5), vector(5):fill({2,3,4,5,0})   )
      assertEquals(ct:getvec(2,5), vector(5):fill({2,3,4,5,0})*1i)
     end

    if t:nv() == 3 then
      assertEquals(t :getvec( 2, 3), vector( 3):fill(2 .. 4)   )
      assertEquals(ct:getvec( 2, 3), vector( 3):fill(2 .. 4)*1i)
      assertEquals(t :getvec( 3, 1), vector( 1):fill(3 .. 3)   )
      assertEquals(ct:getvec( 3, 1), vector( 1):fill(3 .. 3)*1i)
      assertEquals(t :getvec( 2, 4), vector( 4):fill(2 .. 5)   )
      assertEquals(ct:getvec( 2, 4), vector( 4):fill(2 .. 5)*1i)
      assertEquals(t :getvec( 2,30), vector(30):fill(2 ..31)   )
      assertEquals(ct:getvec( 2,30), vector(30):fill(2 ..31)*1i)
      assertEquals(t :getvec( 6, 6), vector( 6):fill(6 ..11)   )
      assertEquals(ct:getvec( 6, 6), vector( 6):fill(6 ..11)*1i)
      assertEquals(t :getvec(13,10), vector(10):fill(13..22)   )
      assertEquals(ct:getvec(13,10), vector(10):fill(13..22)*1i)
      assertEquals(t :getvec(21,10), vector(10):fill(21..30)   )
      assertEquals(ct:getvec(21,10), vector(10):fill(21..30)*1i)
      assertEquals(t :getvec(23, 8), vector( 8):fill(23..30)   )
      assertEquals(ct:getvec(23, 8), vector( 8):fill(23..30)*1i)
      assertEquals(t :getvec(21,15), vector(15):fill(21..35)   )
      assertEquals(ct:getvec(21,15), vector(15):fill(21..35)*1i)
      assertEquals(t :getvec(34, 4), vector(4):fill({34,35,0,0})   )
      assertEquals(ct:getvec(34, 4), vector(4):fill({34,35,0,0})*1i)
     end

    assertError(t .getvec,      0, 1)
    assertError(ct.getvec,      0, 1)
    assertError(t .getvec, sz_d+1, 1)
    assertError(ct.getvec, sz_d+1, 1)
  end
end


function TestTPSASet:testTPSASet0SingVar()
  for _,d in ipairs{d1v,d2v} do
    local t1  =  tpsa(d,1):set0(   1)
    local ct1 = ctpsa(d,1):set0(1+1i)
    local t2  =  tpsa(d,1):set0(   1):set0(   2,   3)
    local ct2 = ctpsa(d,1):set0(   1):set0(2+1i, 3+1i)


    assertEquals(t1 :get0(),    1)
    assertEquals(ct1:get0(), 1+1i)
    assertEquals(t2 :get0(),    5)
    assertEquals(ct2:get0(), 5+2i)
  end
end


function TestTPSASet:testSetStrSingVar()
    local t  = tpsa (d1v):set("0",1)
    local ct = ctpsa(d1v):set("0",1i)

    assertEquals(t :mlen(true), 1)
    assertEquals(ct:mlen(true), 1)
    assertEquals(t :set("1", 1):mlen(true), 2)
    
    assertEquals(ct:set("1",1i):mlen(true), 2)
    assertEquals(t :set("4", 1):mlen(true), 5)
    assertEquals(ct:set("4",1i):mlen(true), 5)
    assertEquals(t :get(1),    1)
    assertEquals(ct:get(1),   1i)
    assertEquals(t :get(2),    1)
    assertEquals(ct:get(2),   1i)
    assertEquals(t :get(3),    0)
    assertEquals(ct:get(3), 0+0i)
    assertEquals(t :get(4),    0)
    assertEquals(ct:get(4), 0+0i)
    assertEquals(t :get(5),    1)
    assertEquals(ct:get(5),   1i)
    assertEquals(t :get(6),    0)
    assertEquals(ct:get(6), 0+0i)
    assertError (t .set, t , "-1",1)
    assertError (ct.set, ct, "-1",1)
    assertError (t .set, t ,  "6",1)
    assertError (ct.set, ct,  "6",1)
  
end