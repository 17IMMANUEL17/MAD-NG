--[=[
 o-----------------------------------------------------------------------------o
 |
 | GTPSA module regression tests - real tpsa
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide regression test suites for the tpsa module.

 o-----------------------------------------------------------------------------o
]=]

local vector, tpsa, gtpsa_desc                                      in MAD
local eps, abs                                                      in MAD.gmath
local ident                                                         in MAD.gfunc
local assertTrue, assertEquals, assertAlmostEquals                  in MAD.utest

-- locals ---------------------------------------------------------------------o

local dat = require 'tpsa_dat'
local ord = {1,2,3,4,5,6,7,10,12,15}

-- regression test suites -----------------------------------------------------o

TestTPSAFun = {}

local trc = false

local function checkVal (msg, r, c, n)
  local tol = n and c.neps or c.eps or eps
  n = n or ident
  if trc then r:debug(msg) end
  assertTrue(r:is_valid())
  for i=1,#r do
    local v = n(c[i],i)
    if trc then io.write('i=',i,', v=',v,', r=',r:get(i),'\n') end
    if abs(v) > 2 then
      assertAlmostEquals(r:get(i) / v -1, 0, i*tol)
    else
      assertAlmostEquals(r:get(i)       , v, i*tol)
    end
  end
end

local function checkFun1 (fnam)
  gtpsa_desc(1,15)

  local t, r
  if trc then io.write('\n') end
  for _,c in ipairs(dat.fun[fnam]) do
  for _,o in ipairs(ord) do
    if trc then io.write('f=',fnam,'(',c[0],') @ ',o,'\n') end
    t = tpsa(o):set(1,c.x0):set(2,1)
    r = t[fnam](t)   ; checkVal('n', r, c)        -- no alias (r ~= t)
    r = t[fnam](t,t) ; checkVal('a', r, c)        -- aliased  (r == t)

    if c.neg and c[0] ~= 0 then
      if trc then io.write('f=',fnam,'(',-c[0],') @ ',o,'\n') end
      t = tpsa(o):set(1,-c.x0):set(2,1)
      r = t[fnam](t) ; checkVal('m', r, c, c.neg) -- negative
    end
  end end
end

TestTPSAFun.testInv   = \s -> checkFun1('inv')
TestTPSAFun.testISqrt = \s -> checkFun1('invsqrt')
TestTPSAFun.testSqrt  = \s -> checkFun1('sqrt')
TestTPSAFun.testExp   = \s -> checkFun1('exp')
TestTPSAFun.testLog   = \s -> checkFun1('log')
TestTPSAFun.testSin   = \s -> checkFun1('sin')
TestTPSAFun.testCos   = \s -> checkFun1('cos')
TestTPSAFun.testTan   = \s -> checkFun1('tan')
TestTPSAFun.testCot   = \s -> checkFun1('cot')
-- TestTPSAFun.testSinc  = \s -> checkFun1('sinc')
TestTPSAFun.testSinh  = \s -> checkFun1('sinh')
TestTPSAFun.testCosh  = \s -> checkFun1('cosh')
TestTPSAFun.testTanh  = \s -> checkFun1('tanh')
TestTPSAFun.testCoth  = \s -> checkFun1('coth')
TestTPSAFun.testAsin  = \s -> checkFun1('asin')
TestTPSAFun.testAcos  = \s -> checkFun1('acos')
TestTPSAFun.testAtan  = \s -> checkFun1('atan')
TestTPSAFun.testAcot  = \s -> checkFun1('acot')
TestTPSAFun.testAsinh = \s -> checkFun1('asinh')
TestTPSAFun.testAcosh = \s -> checkFun1('acosh')
TestTPSAFun.testAtanh = \s -> checkFun1('atanh')
TestTPSAFun.testAcoth = \s -> checkFun1('acoth')
TestTPSAFun.testErf   = \s -> checkFun1('erf')

-- end ------------------------------------------------------------------------o


