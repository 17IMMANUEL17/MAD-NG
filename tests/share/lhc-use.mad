MADX:load("lhc_as-built.seq", "lhc_as-built_gen.mad")
MADX:load("opt_inj.madx"    , "opt_inj_gen.mad"     )

require 'lhc_as-built_gen'
require 'opt_inj_gen'
--require 'opt_inj_colltunes_gen'
require 'undef_var'

--[[
require 'opt_inj'
-- require 'opt_inj_colltunes'

local MADX in _G
local lhcb1, lhcb2 in MADX

!value MCBXH.2R1->at;
!value mcbxh.2R1->slot_id;

print(lhcb1.mcbxh_2r1, lhcb1.mcbxh_2r1.at, lhcb1.mcbxh_2r1.from, lhcb1.mcbxh_2r1.parent)
print(lhcb2.mcbxh_2r1, lhcb2.mcbxh_2r1.at, lhcb2.mcbxh_2r1.from, lhcb2.mcbxh_2r1.parent)

--------------------------------------
-- example of expression manipulation
--------------------------------------

local print, ipairs, pcall, os = print, ipairs, pcall, os

MADX:open_env()

print(lhcb2.mqm_6r8_b2.k1) -- 0.0035505192480385

-- extend deferred expression

my_k1 = lhcb2.mqm_6r8_b2:get_raw 'k1' -- capture expr (avoid recursive calls)
lhcb2.mqm_6r8_b2.k1 =\ my_k1 * 2 + 1  -- new deferred expression
print(lhcb2.mqm_6r8_b2.k1)            -- 1.0071010384961

local t0, a = os.clock(), 0
for i=1,1e8 do
  a = a + lhcb2.mqm_6r8_b2.k1
end
print('time=', os.clock()-t0, 'value=', a) -- time=  0.128   value=  100710104.0025

-- extend expression with value

local k1 = lhcb2.mqm_6r8_b2.k1        -- capture value (avoid recursive calls)
lhcb2.mqm_6r8_b2.k1 =\ k1 * 2 + 1     -- new deferred expression
print(lhcb2.mqm_6r8_b2.k1)            -- 3.0142020769922

local t0, a = os.clock(), 0
for i=1,1e8 do
  a = a + lhcb2.mqm_6r8_b2.k1
end
print('time=', os.clock()-t0, 'value=', a) -- time=  0.127   value=  301420207.94652

-- sanity checks
local k = { 'angle', 'hkick', 'k0', 'k1', 'k1s', 'k2', 'k2s', 'k3', 'kick', 'kmax',
'knl', 'ks', 'ksl', 'vkick', 'volt' }

for i,e in ipairs(lhcb1) do
  for j,k in ipairs(k) do
    if e[k] ~= nil then
      local s = e[k] -- trig an error if expression used undefined variables
    end
  end
end
]]