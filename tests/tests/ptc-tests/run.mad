local track, sequence, beam, option, filesys, regex, matrix,     
      tpsa, logrange, mtable, monomial, tostring, damap          in MAD
local eps                                                        in MAD.constant
local is_number                                                  in MAD.typeid
local sbend, rbend, quadrupole, sextupole, octupole, decapole,   
      dodecapole, drift, rfcavity, kicker, solenoid, elseparator,
      multipole, rfmultipole, crabcavity                         in MAD.element
local fringe                                                     in MAD.element.flags
local printf, openfile                                           in MAD.utility
local pi, abs                                                    in math                            

local dbgmap = require "madl_dbgmap"
local create_dif =  dbgmap.cmpmdump

local doprnt = false
local dosave = true
local dodbg  = false
local dum = damap() -- get a dummy damap object

-- local X0s = {{x=0   , px=0    , y=0    , py=0   , t=0   , pt=0   }, -- zero
--              {x=3e-3, px=-2e-4, y=-2e-3, py=3e-4, t=0   , pt=0   }, -- 4D
--              {x=3e-3, px=-2e-4, y=-2e-3, py=3e-4, t=0   , pt=2e-5}, -- 5D
--              {x=3e-3, px=-2e-4, y=-2e-3, py=3e-4, t=1e-5, pt=2e-5}} -- 6D
-- local models = {DKD = 1, TKT = 2}
local ref_cfg = { 
    "model", "energy", "method", "nslice", "x0i", "order", "icase",
    model = 1..2,
    energy = {0.01, 1, 6500}, 
    method = 2..6..2,
    nslice = 1..3, 
    x0i = 1..4,
    order = {2},
    icase = {56},
}

local function gen_params(cfg) -- Generate string of parameters set to values from cfg
    local string = ""
    for k, v in pairs(cfg) do 
        string = string .. k .. "=" .. v .. "; "
    end
    return string
end 

local function tbl_cat(t1, t2) -- Concatenate two tables, index and keys
    local t1_len = #t1
    local t = table.new(t1_len + #t2, t1_len + #t2)
    for i, v in ipairs(t1) do
        t[i] = v
        t[v] = t1[v]
    end
    for i, v in ipairs(t2) do
        t[i+t1_len] = v
        t[v] = t2[v]
    end
    return t
end

local function gen_mtbl(tbl, element, order) -- Generate mtbl ready to be appended
    local mtbl = {}
    for i = 0, order do
        mtbl[i+1] = "max_err_"..i
    end
    for i, v in ipairs(tbl) do
        mtbl[order + 1 + i] = v
    end
    return mtable(element.name)(mtbl)
end

local function getlastmap(filename)
    local file = openfile(filename, "r", {".txt", ".dat", ".out"})
    local final_pos = 0
    for line in file:lines() do
      if line:sub(1, 2) == "@@" then
        final_pos = file:seek("cur")
      end
    end
    file:seek("set", final_pos)
    local dam = dum:read(file)
    file:close()
    return dam
  end

local script = [[
${params}
seq: sequence, l=2 ;
  elm: ${elm};
endsequence ;
]]

-- Get max difference in all monomials of all coordinates in the last map
local function get_diffs(map, order)
    local max_dif = {}
    for i = 0, order do max_dif[i] = 0 end
    for i=1,#map do
        local tbl = map[i]:totable()
        for i, mono in ipairs(tbl) do
            local ord = monomial(mono):ord() 
            if abs(tbl[mono]) > max_dif[ord] then max_dif[ord] = abs(tbl[mono]) end
        end
    end
    return max_dif
end

local function run_mad(cfg, elm)
    io.open("ref.mad", "w"):write([[
local X0s = {{x=0   , px=0    , y=0    , py=0   , t=0   , pt=0   }, -- zero
                {x=3e-3, px=-2e-4, y=-2e-3, py=3e-4, t=0   , pt=0   }, -- 4D
                {x=3e-3, px=-2e-4, y=-2e-3, py=3e-4, t=0   , pt=2e-5}, -- 5D
                {x=3e-3, px=-2e-4, y=-2e-3, py=3e-4, t=1e-5, pt=2e-5}} -- 6D
local models = {DKD = 1, TKT = 2}
local beam, sequence, track in MAD
MADX:load("element.seq", true)
local beam = beam { energy = MADX.energy }
local mtbl, mflw = track {
    sequence=MADX.seq, beam=beam, X0=X0s[MADX.x0i], mapdef=MADX.order, model=models[MADX.model],
    method=MADX.method, nslice=MADX.nslice, ptcmodel=true, debug=6
        }
        ]]):close()
    os.execute('../mad '.. "ref.mad" ..' >' .. elm.name .. "_n.txt")
    create_dif(elm.name)
end

local function run_dbg(cfg, exit, elm)
    run_mad(cfg, elm)
    exit["exit"] = true 
end

local function do_trck(cfg, exit, elm, elm_str, max_dif_tbl, tol, res_tbl)
    -- Run track and PTC
    cfg.n = cfg.n + 1 
    local mtbl_row = {}
    io.open("element.seq", "w"):write(
        script%{elm = elm_str, params=gen_params(cfg)}
    ):close()
    os.execute('../madx64 '.. "ref.madx" ..' >' .. elm.name .. "_p.txt")

    local beam = beam { energy = cfg.energy }
    MADX:load("element.seq", true)
    local mtbl, mflw = track {
        sequence=MADX.seq, beam=beam, X0=X0s[cfg.x0i], mapdef=cfg.order, model=models[cfg.model],
        method=cfg.method, nslice=cfg.nslice, ptcmodel=true
    }
    MADX.elm = nil -- Remove element so that next test can be run with new values
        
    --Get last map from ptc and compare with mflw
    local ptc_res = getlastmap(elm.name .. "_p.txt"):fromptc()    
    local dif_map = mflw[1]:dif(ptc_res)
    local max_dif = get_diffs(dif_map, cfg.order) -- To be replaced. Gets a list of max differences of e
    
    for i = 0, cfg.order do 
        if dosave then mtbl_row["max_err_"..i] = max_dif[i]/eps end 
        if max_dif[i]/eps > tol then 
            if dodbg  then run_dbg(cfg, exit, elm) end
            if doprnt then 
                for k, v in pairs(cfg) do
                    if not max_dif_tbl[i][k] then max_dif_tbl[i][k] = {} end
                    max_dif_tbl[i][k][v] = max_dif_tbl[i][k][v] and max_dif_tbl[i][k][v] + 1 or 1
                end
            end
        end
    end
        -- Print results
    if doprnt then 
        io.write(cfg.n, "\t") 
        for i = 0, cfg.order do 
            printf("%.2e %d\t", max_dif[i], max_dif[i]/eps) 
        end
        io.write("\n")
    end
    -- Save results
    if dosave then 
        for k, v in pairs(cfg) do mtbl_row[k] = v end
        res_tbl:addrow(mtbl_row)
    end
end

local function run_cfg(tbl, idx, cfg, exit, ...) --The recursive function
    if exit["exit"] then return end
    local k = tbl[idx]
    if not k then 
        return do_trck(cfg, exit, ...) -- Could be changed to any function
    end
    for i, v in ipairs(tbl[k]) do
        cfg[k] = v
        run_cfg(tbl, idx+1, cfg, exit, ...)
    end
end

local function print_result(max_dif_tbl, order) -- From max_dif_tbl, print the results
    for i = 0, order do 
        io.write("order ",i, ":\n")
        for k, v in pairs(max_dif_tbl[i]) do
            if not (is_number(k) or k == "n") then 
                io.write(k, "\t= ", tostring(v), "\n")
            end
        end
    end
end

local function run_test(elm, elm_str, cfg_tbl, tol)
    local max_dif_tbl = {}
    for i = 0, cfg_tbl.order[1] do max_dif_tbl[i] = {} end
    local res_tbl
    if dosave then res_tbl = gen_mtbl(cfg_tbl, elm, cfg_tbl.order[1]) end
    run_cfg(cfg_tbl, 1, {n = 0}, {},  -- For recursion, could place icase and order here instead?
                    elm, elm_str, max_dif_tbl, tol, res_tbl) -- For do_trck
    
    if doprnt then print_result(max_dif_tbl, cfg_tbl.order[1]) end
    if dosave then res_tbl:write(elm.name..".tfs") end
    
    if not dodbg then  -- Cleanup
        os.remove(elm.name .. "_p.txt")
        os.remove("element.seq")
    end 
end

local function testQUAD ()
    local elm_str = "QUADRUPOLE, at=0.75, l=1.5, k1=k1, k1s=k1s, tilt=tilt*pi/8, fringe=fringe"
    local quad_cfg = {
        "tilt", "fringe", "k1", "k1s",
        tilt   = 0  ..4,
        fringe = 0  ..3 ..3,
        k1     = -0.2..0.2..0.2,
        k1s    = -0.2..0.2..0.2,
    }
    run_test(quadrupole, elm_str, tbl_cat(ref_cfg, quad_cfg), 100) -- Only actually use elm.name
end


local function testDRIFT ()
    local elm_str = "DRIFT, at=0.75, l=1.5"
    
    run_test(drift, elm_str, ref_cfg, 0) -- Only actually use elm.name
end
testQUAD()
testDRIFT()