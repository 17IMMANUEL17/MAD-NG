local track, sequence, beam, option, filesys, regex, matrix,     
      tpsa, logrange, mtable, monomial, tostring, damap          in MAD
local eps                                                        in MAD.constant
local is_number, is_matrix                                       in MAD.typeid
local sbend, rbend, quadrupole, sextupole, octupole, decapole,   
      dodecapole, drift, rfcavity, kicker, solenoid, elseparator,
      multipole, rfmultipole, crabcavity                         in MAD.element
local fringe                                                     in MAD.element.flags
local printf, openfile, tblcpy, val2keys                         in MAD.utility
local pi, abs                                                    in math                            

local dbgmap = require "madl_dbgmap"
local create_dif =  dbgmap.cmpmdump

local doprnt = false
local dosave = false
local dodbg  = true
local dum = damap() -- get a dummy damap object

local X0s = {{x=0   , px=0    , y=0    , py=0   , t=0   , pt=0   }, -- zero
             {x=3e-3, px=-2e-4, y=-2e-3, py=3e-4, t=0   , pt=0   }, -- 4D
             {x=3e-3, px=-2e-4, y=-2e-3, py=3e-4, t=0   , pt=2e-5}, -- 5D
             {x=3e-3, px=-2e-4, y=-2e-3, py=3e-4, t=1e-5, pt=2e-5}} -- 6D
local models = {DKD = 1, TKT = 2}
local ref_cfg = { 
    "model", "energy", "method", "nslice", "x0i", "order", "icase",
    model = 1..2,
    energy = {1, 6500}, 
    method = 2..2..2,
    nslice = 1..3..2, 
    x0i = 1..4,
    order = {2},
    icase = {56},
}

local function tbl_cat(t1, t2) -- Concatenate two tables, index and keys
    local t1_len = #t1
    local t = table.new(t1_len + #t2, t1_len + #t2)
    for i, v in ipairs(t1) do
        t[i] = v
        t[v] = t1[v]
    end
    for i, v in ipairs(t2) do
        t[i+t1_len] = v
        t[v] = t2[v]
    end
    return t
end

local function gen_mtbl(tbl, element, order) -- Generate mtbl ready to be appended
    local mtbl = {{"n"}}
    for i = 0, order do
        mtbl[i+2] = "max_err_"..i
    end
    for i, v in ipairs(tbl) do
        mtbl[order + 2 + i] = v
    end
    return mtable(element.name)(mtbl)
end

local function getlastmap(filename)
    local file = openfile(filename, "r", {".txt", ".dat", ".out"})
    local final_pos = 0
    for line in file:lines() do
      if line:sub(1, 2) == "@@" then
        final_pos = file:seek("cur")
      end
    end
    file:seek("set", final_pos)
    local dam = dum:read(file)
    file:close()
    return dam
  end

local ctx =  "icase = ${icase}; model = ${model}; method = ${method}; nslice = ${nslice}; x0i = ${x0i}; order = ${order}; energy = ${energy};"
local madx_script = [[
${ctx}
seq: sequence, l=2 ;
  elm: ${elm};
endsequence ;
]]

-- Get max difference in all monomials of all coordinates in the last map
local function get_diffs(map, order)
    local max_dif = {}
    for i = 0, order do max_dif[i] = 0 end
    for i=1,#map do
        local tbl = map[i]:totable()
        for i, mono in ipairs(tbl) do
            local ord = monomial(mono):ord() 
            if abs(tbl[mono]) > max_dif[ord] then max_dif[ord] = abs(tbl[mono]) end
        end
    end
    return max_dif
end

local function get_mad_str(cfg, elm, elm_str, debug_)
    io.open("element.seq", "w"):write(
        madx_script%{elm = elm_str(cfg), ctx=ctx}%cfg
    ):close()
    return [[
local X0s = {{x=0   , px=0    , y=0    , py=0   , t=0   , pt=0   }, -- zero
             {x=3e-3, px=-2e-4, y=-2e-3, py=3e-4, t=0   , pt=0   }, -- 4D
             {x=3e-3, px=-2e-4, y=-2e-3, py=3e-4, t=0   , pt=2e-5}, -- 5D
             {x=3e-3, px=-2e-4, y=-2e-3, py=3e-4, t=1e-5, pt=2e-5}} -- 6D

local models = {DKD = 1, TKT = 2}
local beam, sequence, track in MAD
MADX:load("element.seq", true)
local beam = beam { energy = MADX.energy }
local mtbl, mflw = track {
    sequence=MADX.seq, beam=beam, X0=X0s[MADX.x0i], mapdef=MADX.order, model=models[MADX.model],
    method=MADX.method, nslice=MADX.nslice, ptcmodel=true, debug=${debug},
}
return mtbl, mflw
        ]] % {debug = debug_ and 6 or 0}
end

local function run_dbg(cfg, elm, elm_str)
    io.open("ref.mad", "w"):write(get_mad_str(cfg, elm, elm_str, true)):close()
    os.execute('../mad '.. "ref.mad" ..' >' .. elm.name .. "_n.txt")
    os.execute('../madx64 '.. "ref.madx" ..' >' .. elm.name .. "_p.txt")
    create_dif({nam=elm.name})
    cfg.exit = true 
end

local function do_trck(cfg, exit, elm, elm_str, tol, res_tbl)
    -- Run track and PTC
    cfg.n = cfg.n + 1 
    local mtbl_row = {}
    local _, mflw = assert(loadstring(get_mad_str(cfg, elm, elm_str)))() -- Run track
    os.execute('../madx64 '.. "ref.madx" ..' >' .. elm.name .. "_p.txt")
    MADX.elm = nil -- Remove element so that next test can be run with new values
        
    -- Get last map from ptc and compare with mflw
    local ptc_res = getlastmap(elm.name .. "_p.txt"):fromptc()    
    local dif_map = mflw[1]:dif(ptc_res)
    local max_dif = get_diffs(dif_map, cfg.order) -- To be replaced. Gets a list of max differences of e
    
    for i = 0, cfg.order do 
        if dosave then mtbl_row["max_err_"..i] = max_dif[i]/eps  end 
        if dodbg and max_dif[i]/eps > tol then run_dbg(cfg, elm, elm_str) end
    end
        -- Print results
    if doprnt then 
        io.write(cfg.n, "\t") 
        for i = 0, cfg.order do 
            printf("%.2e %d\t", max_dif[i], max_dif[i]/eps) 
        end
        io.write("\n")
    end
    -- Save results
    if dosave then 
        for k, v in pairs(cfg) do mtbl_row[k] = v end
        res_tbl:addrow(mtbl_row)
    end
end

local function run_cfg(tbl, idx, cfg, cnd_, ...) --The recursive function
    if cfg.exit then return end
    local k = tbl[idx]
    if not k then 
        return do_trck(cfg, ...) -- Could be changed to any function
    end
    for i, v in ipairs(tbl[k]) do
        cfg[k] = cnd_[k] and cnd_[k](v, cfg) or v -- If there is a condition, use it
        run_cfg(tbl, idx+1, cfg, cnd_, ...)
    end
end

local function print_result(max_dif_tbl, order) -- From max_dif_tbl, print the results
    for i = 0, order do 
        io.write("\norder ",i, ":\n")
        for k, v in pairs(max_dif_tbl[i]) do
            if not (is_number(k) or k == "n") then 
                io.write(k, "\t= ", tostring(v), "\n")
            end
        end
    end
end

local function read_mtbl(element, lower_bnds_, order_)
    local lower_bnds = {}
    local order = order_ or 4
    if is_number (lower_bnds_) then 
        for i = 0, order do lower_bnds[i] = lower_bnds_ end
    else
        lower_bnds = lower_bnds_
    end
    local ref = mtable:read(element.name..".tfs")
    local col_list = {}
    for i, v in ipairs(ref:colnames()) do 
        if not (v:find("max_err_") or v == "n") then col_list[#col_list+1] = v end
    end
    local col_tbl = {}; for i = 0, order do col_tbl[i] = {} end
    for i = 0, order do 
        local red_tbl = mtable(ref:colnames())
        ref:foreach(\r, ri => if r["max_err_"..i] > lower_bnds[i] then red_tbl = red_tbl + r end end)
        for _, col_name in ipairs(col_list) do
            local c = red_tbl:getcol(col_name)
            local _, klist = val2keys(is_matrix(c) and c:totable() or c)
            col_tbl[i][col_name] = klist
        end
    end
    print_result(col_tbl, order)
end

local function run_test(elm, elm_str, cfg_tbl, tol, cnd_)
    local res_tbl
    local mtbl = io.open(elm.name..".tfs", "r")
    if not mtbl then dosave = true end
    mtbl:close()
    if dosave then res_tbl = gen_mtbl(cfg_tbl, elm, cfg_tbl.order[1]) end
    run_cfg(cfg_tbl, 1, {n = 0}, {}, cnd_ or {},  -- For recursion, could place icase and order here instead?
                    elm, elm_str, tol, res_tbl) -- For do_trck
    
    if dosave then res_tbl:write(elm.name..".tfs") end
    if doprnt then read_mtbl(elm, tol, cfg_tbl.order[1]) end
    
    if not dodbg then  -- Cleanup
        os.remove(elm.name .. "_p.txt")
        os.remove("element.seq")
    end 
end

local function testQUAD ()
    local elm_str = \->" QUADRUPOLE, at=0.75, l=1.5, k1=${k1}, k1s=${k1s}, tilt=${tilt}*pi/8, fringe=${fringe}"
    local quad_cfg = {
        "tilt", "fringe", "k1", "k1s",
        tilt   = 0  ..4,
        fringe = 0  ..3 ..3,
        k1     = -0.2..0.2..0.2,
        k1s    = -0.2..0.2..0.2,
    }
    run_test(quadrupole, elm_str, tbl_cat(ref_cfg, quad_cfg), 100) -- Only actually use elm.name
end

local function testSEXT ()
    local elm_str = \->" SEXTUPOLE, at=0.75, l=1.5, k2=${k2}, k2s=${k2s}, tilt=${tilt}*pi/12, fringe=${fringe}"
    local sext_cfg = {
        "tilt", "fringe", "k2", "k2s",
        tilt   = 0  ..6,
        fringe = 0  ..3 ..3,
        k2     = -0.2..0.2..0.2,
        k2s    = -0.2..0.2..0.2,
    }
    run_test(sextupole, elm_str, tbl_cat(ref_cfg, sext_cfg), 100) -- Only actually use elm.name
end

local function testOCT ()
    local elm_str = \->" OCTUPOLE, at=0.75, l=1.5, k3=${k3}, k3s=${k3s}, tilt=${tilt}*pi/16, fringe=${fringe}"
    local oct_cfg = {
        "tilt", "fringe", "k3", "k3s",
        tilt   = 0  ..8..2,
        fringe = 0  ..3 ..3,
        k3     = -0.2..0.2..0.2,
        k3s    = -0.2..0.2..0.2,
    }
    run_test(octupole, elm_str, tbl_cat(ref_cfg, oct_cfg), 100) -- Only actually use elm.name
end


local function testDECA ()
    local elm_str = \->" DECAPOLE, at=0.75, l=1.5, k4=${k4}, k4s=${k4s}, tilt=${tilt}*pi/20, fringe=${fringe}"
    local deca_cfg = {
        "tilt", "fringe", "k4", "k4s",
        tilt   = 0  ..10..5,
        fringe = 0  ..3 ..3,
        k4     = -0.2..0.2..0.2,
        k4s    = -0.2..0.2..0.2,
    }
    local deca_ref = tblcpy(ref_cfg)
    deca_ref.order = {5}
    run_test(decapole, elm_str, tbl_cat(deca_ref, deca_cfg), 100) -- Only actually use elm.name
end

local function testDODECA ()
    local elm_str = \->" DODECAPOLE, at=0.75, l=1.5, k5=${k5}, k5s=${k5s}, tilt=${tilt}*pi/24, fringe=${fringe}"
    local deca_cfg = {
        "tilt", "fringe", "k5", "k5s",
        tilt   = 0  ..12..3,
        fringe = 0  ..3 ..3,
        k5     = -0.2..0.2..0.2,
        k5s    = -0.2..0.2..0.2,
    }
    local dodeca_ref = tblcpy(ref_cfg)
    dodeca_ref.order = {6}
    run_test(dodecapole, elm_str, tbl_cat(dodeca_ref, deca_cfg), 100) -- Only actually use elm.name
end

local function testDRIFT ()
    local elm_str = \->" DRIFT, at=0.75, l=1.5"
    local drift_cfg = tblcpy(ref_cfg)
    drift_cfg.nslice = {1}
    run_test(drift, elm_str, drift_cfg, 0) -- Only actually use elm.name
end

local function testCAV ()
    local elm_str = \cfg -> cfg.totalpath and "RFCAVITY, at=0.75, l=1.5, volt=${volt}, lag=${lag}, harmon=${harmon}, freq=${freq};"
                                             or "RFCAVITY, at=0.75, l=1.5, volt=${volt}, lag=${lag}, harmon=${harmon}, freq=${freq}, no_cavity_totalpath=true;"
    local cav_cfg = {
        "totalpath", "volt", "lag", "freq", "harmon",
        totalpath = {false, true},
        volt      = -8 ..8  ..8   ,
        lag       =  0 ..0.9..0.45,
        freq      =  0 ..150 ..75,
        harmon    =  {2},
    }
    local cnd = {harmon = \v, cfg -> cfg.freq == 0 and 2 or 0}
    local cav_ref = tblcpy(ref_cfg)
    cav_ref.icase = {6}
    run_test(rfcavity, elm_str, tbl_cat(cav_ref, cav_cfg), 10000, cnd)
end

local function testMULT ()
    local elm_str = \-> "MULTIPOLE, at=0.75, lrad=1.5, knl={${k0}, ${k1}, ${k2}, ${k3}}, ksl={${k0s}, ${k1s}, ${k2s}, ${k3s}};"
    local cav_cfg = {
        "k0", "k1", "k2", "k3", "k0s", "k1s", "k2s", "k3s", "knl", "ksl",
        k0        = -0.2..0.2..0.2,
        k1        = -0.2..0.2..0.2,
        k2        = -0.2..0.2..0.2,
        k3        = -0.2..0.2..0.2,
        k0s       = -0.2..0.2..0.2,
        k1s       = -0.2..0.2..0.2,
        k2s       = -0.2..0.2..0.2,
        k3s       = -0.2..0.2..0.2,
    }
    local cav_ref = tblcpy(ref_cfg)
    cav_ref.icase = {6}
    run_test(multipole, elm_str, tbl_cat(cav_ref, cav_cfg), 1, cnd)
end

local function testRFMULT ()
    local elm_str = \-> [[
        RFMULTIPOLE, at=0.75, lrad=1.5, volt=${volt}, lag=${lag}, harmon=${harmon}, freq=${freq}, 
        pnl={${k0}, ${k1}, ${k2}, ${k3}}, psl={${k0s}, ${k1s}, ${k2s}, ${k3s}};]]
    local cav_cfg = {
        "volt", "lag", "freq", "harmon", "k0", "k1", "k2", "k3", "k0s", "k1s", "k2s", "k3s", "pnl", "psl",
        -- totalpath = {false, true}, !illegal in MAD-X
        volt      = -8 ..8  ..8   ,
        lag       =  0 ..0.9..0.45,
        freq      =  0 ..150 ..75,
        harmon    =  {2},
        k0        = -0.2..0.2..0.2,
        k1        = -0.2..0.2..0.2,
        k2        = -0.2..0.2..0.2,
        k3        = -0.2..0.2..0.2,
        k0s       = -0.2..0.2..0.2,
        k1s       = -0.2..0.2..0.2,
        k2s       = -0.2..0.2..0.2,
        k3s       = -0.2..0.2..0.2,
    }
    local cnd = {
        harmon = \v, cfg -> cfg.freq == 0 and 2 or 0, 
        }
    local cav_ref = tblcpy(ref_cfg)
    cav_ref.icase = {6}
    run_test(rfmultipole, elm_str, tbl_cat(cav_ref, cav_cfg), 1000, cnd)
end
-- testCAV()
-- testRFMULT()
-- read_mtbl(rfcavity, 20) -- For reading the results
-- testQUAD()
testSEXT()
-- testOCT()
-- testDECA ()
-- testDODECA ()
-- testDRIFT()
-- read_mtbl(sextupole, 10, 2) -- For reading the results
