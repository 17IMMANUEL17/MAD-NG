local track, sequence, beam, option, filesys, regex, matrix,     
      tpsa, logrange, mtable, monomial, tostring, damap, vector  in MAD
local eps                                                        in MAD.constant
local is_number, is_matrix, is_function, is_string               in MAD.typeid
local sbend, rbend, quadrupole, sextupole, octupole, decapole,   
      dodecapole, drift, rfcavity, kicker, solenoid, elseparator,
      multipole, rfmultipole, crabcavity                         in MAD.element
local fringe                                                     in MAD.element.flags
local printf, openfile, tblcpy, val2keys, fileexists             in MAD.utility
local pi, abs                                                    in math                            

local create_dif = require "madl_dbgmap".cmpmdump

-- The Setup for the tests -----------------------------------------------------o
local doprnt = false -- false
local dorun  = false  -- true
local dosave = true  -- true
local dodbg  = false -- false

local dum = damap() -- get a dummy damap object
local coords = {"x", "px", "y", "py", "t", "pt"}                    -- Coordinates
local X0s = {{x=0   , px=0    , y=0    , py=0   , t=0   , pt=0   }, -- zero
             {x=3e-3, px=-2e-4, y=-2e-3, py=3e-4, t=0   , pt=0   }, -- 4D
             {x=3e-3, px=-2e-4, y=-2e-3, py=3e-4, t=0   , pt=2e-5}, -- 5D
             {x=3e-3, px=-2e-4, y=-2e-3, py=3e-4, t=1e-5, pt=2e-5}} -- 6D
local models = {DKD = 1, TKT = 2}

local ctx =  "icase = ${icase}; model = ${model}; method = ${method}; nslice = ${nslice}; x0i = ${x0i}; order = ${order}; energy = ${energy};"
local madx_script = [[
${ctx}
seq: sequence, l=2 ;
  elm: ${elm};
endsequence ;
]]
--------------------------------------------------------------------------------o

-- The configuration table -----------------------------------------------------o
local ref_cfg = { 
    "model", "energy", "method", "nslice", "x0i", "order", "icase",
    model = 1..2,
    energy = {1, 6500}, 
    method = 2..2..2,
    nslice = 1..3..1, 
    x0i = 1..4,
    order = {2},
    icase = {56},
}
--------------------------------------------------------------------------------o

-- Dealing with the cfg mtable -------------------------------------------------o
local function gen_cfg(tbl, idx, cfg, mtbl) --The recursive function
    local k = tbl[idx]
    if not k then 
        cfg.cfgid = cfg.cfgid + 1
        return mtbl:addrow(cfg) -- Could be changed to any function
    end
    for i, v in ipairs(tbl[k]) do
        cfg[k] = is_function(v) and v(cfg) or v -- If there is a condition, use it
        gen_cfg(tbl, idx+1, cfg, mtbl)
    end
end

local function gen_mtbls(tbl, element) -- Generate mtbls ready to be appended
    local cfg_mtbl, err_mtbl = {{"cfgid"}}, {{"cfgid"}}
    local order = tbl.order[1]                  -- Get the order
    
    for i = 0, order do err_mtbl[i+2] = "order"..i.."_eps" end
    for i, c in ipairs(coords) do err_mtbl[i+order+2] = c.."_eps" end
    err_mtbl = mtable(element.name.."_max_err")(err_mtbl)

    for i, v in ipairs(tbl) do
        cfg_mtbl[i+1] = v
    end
    cfg_mtbl = mtable(element.name)(cfg_mtbl)
    gen_cfg(tbl, 1, {cfgid = 0}, cfg_mtbl)         -- Generate the cfg
    return cfg_mtbl, err_mtbl
end
--------------------------------------------------------------------------------o

-- Grab the final map from the madx dump file ----------------------------------o
local function getlastmap(filename)
    local file = openfile(filename, "r", {".txt", ".dat", ".out"})
    local final_pos = 0
    for line in file:lines() do
      if line:sub(1, 2) == "@@" then
        final_pos = file:seek("cur")
      end
    end
    file:seek("set", final_pos)
    local dam = dum:read(file)
    file:close()
    return dam
  end
--------------------------------------------------------------------------------o

-- Get max difference in all monomials of all coordinates in the last map ------o
local function get_diffs(map, order)
    local max_dif = {}
    for i = 0, order do max_dif[i] = 0 end
    for i, c in ipairs(coords) do -- Loop over coordinates instead
        local _, max_idxs = map[c]:maxbyord()
        local max_vals = vector(#max_idxs)
        max_idxs:map(\x-> x~=0 and abs(map[c]:get(x))/eps or 0, max_vals)
        max_dif[c] = max_vals:max()
        for ord, val in ipairs(max_vals) do
            if val > max_dif[ord-1] then max_dif[ord-1] = val end
        end
    end
    return max_dif
end
--------------------------------------------------------------------------------o

-- Write MAD-X script to element.seq and generate a MAD-NG script and return it-o
local function get_mad_str(cfg, elm, elm_str, debug_) 
    io.open("element.seq", "w"):write(
        madx_script%{elm = elm_str(cfg), ctx=ctx}%cfg
    ):close()
    return [[
local X0s = {{x=0   , px=0    , y=0    , py=0   , t=0   , pt=0   }, -- zero
             {x=3e-3, px=-2e-4, y=-2e-3, py=3e-4, t=0   , pt=0   }, -- 4D
             {x=3e-3, px=-2e-4, y=-2e-3, py=3e-4, t=0   , pt=2e-5}, -- 5D
             {x=3e-3, px=-2e-4, y=-2e-3, py=3e-4, t=1e-5, pt=2e-5}} -- 6D

local models = {DKD = 1, TKT = 2}
local beam, sequence, track in MAD
MADX:load("element.seq", true)
local beam = beam { energy = MADX.energy }
local mtbl, mflw = track {
    sequence=MADX.seq, beam=beam, X0=X0s[MADX.x0i], mapdef=MADX.order, model=models[MADX.model],
    method=MADX.method, nslice=MADX.nslice, ptcmodel=true, debug=${debug},
}
return mtbl, mflw
        ]] % {debug = debug_ and 6 or 0}
end
-------------------------------------------------------------------------------o

-- Run MAD-NG (in debug mode) and MAD-X and compare the results ---------------o
local function run_dbg(cfg, elm, elm_str) 
    io.open("ref.mad", "w"):write(get_mad_str(cfg, elm, elm_str, true)):close()
    os.execute('../mad '.. "ref.mad" ..' >' .. elm.name .. "_n.txt")
    os.execute('../madx64 '.. "ref.madx" ..' >' .. elm.name .. "_p.txt")
    create_dif({nam=elm.name})
    return true 
end
-------------------------------------------------------------------------------o

-- Run track and PTC ----------------------------------------------------------o
local function do_trck(cfg, elm, elm_str, tol, res_mtbl)
    local mtbl_row = {cfgid = cfg.cfgid}
    local _, mflw = assert(loadstring(get_mad_str(cfg, elm, elm_str)))() -- Run track
    os.execute('../madx64 '.. "ref.madx" ..' >' .. elm.name .. "_p.txt")
    MADX.elm = nil -- Remove element so that next test can be run with new values
        
    
    local ptc_res = getlastmap(elm.name .. "_p.txt"):fromptc() -- Get last map from ptc 
    local max_dif = get_diffs(mflw[1]:dif(ptc_res), cfg.order) -- Gets a list of max differences of each order

    for i = 0, cfg.order do 
        mtbl_row["order"..i.."_eps"] = max_dif[i]
    end
    for i, c in ipairs(coords) do -- Loop over coordinates instead
        mtbl_row[c.."_eps"] = max_dif[c]
    end
    res_mtbl:addrow(mtbl_row) -- Save results to mtbl

    if doprnt then io.write(cfg.cfgid, "\t") end    
    for i = 0, cfg.order do 
        if doprnt then printf("%.2e %d\t", max_dif[i]*eps, max_dif[i]) end
        if dodbg and max_dif[i] > tol then return run_dbg(cfg, elm, elm_str) end
    end
    if doprnt then io.write("\n") end 
end
-------------------------------------------------------------------------------o

--  Output results of test ----------------------------------------------------o
local function print_result(max_dif_tbl, order) -- From max_dif_tbl, print the results
    for i = 0, order do 
        io.write("\norder ",i, ":\n")
        for k, v in pairs(max_dif_tbl[i]) do
            if not (is_number(k) or k == "cfgid") then 
                io.write(k, "\t= ", tostring(v), "\n")
            end
        end
    end
end

local function get_lower_bnds(cfg, lower_bnds)
    local final_bnds = {}
    if is_string(lower_bnds) then
        local bnds_file = mtable:read(lower_bnds)
        assert(#bnds_file == #cfg, "The tolerance file must have the same number of rows as the configuration file")
        for i = 0, #cfg do final_bnds[i] = \r->bnds_file[r]["order"..i.."_eps"] end
    elseif is_number(lower_bnds) then
        for i = 0, #cfg do final_bnds[i] = \->lower_bnds end
    else
        for i = 0, #cfg do final_bnds[i] = \->lower_bnds[i] end
    end
    return final_bnds
end

local function show_mtbl(cfg, res, lower_bnds, order) -- (Lower bounds not optional but can be a number or tbl)
    assert(dodbg or #cfg == #res, "The configuration and result mtables must have the same number of rows")
    local lower_bnds = get_lower_bnds(cfg, lower_bnds)
    local col_tbl = {}; for i = 0, order do col_tbl[i] = {} end
    for i = 0, order do 
        local red_tbl = mtable(cfg:colnames())
        cfg:foreach(\r, ri => if res[ri] and res[ri]["order"..i.."_eps"] > lower_bnds[i](ri) then red_tbl = red_tbl + r end end)
        for _, col_name in ipairs(cfg:colnames()) do
            local c = red_tbl:getcol(col_name) 
            local _, klist = val2keys(is_matrix(c) and c:totable() or c)
            col_tbl[i][col_name] = klist
        end
    end
    print_result(col_tbl, order)
end

local function read_mtbl(element, lower_bnds, order_) -- Read the stored mtbl and cfg for the element
    local order = order_ or 4
    local cfg = mtable:read(element.name..".tfs")
    local res = mtable:read(element.name.."_max_err.tfs")
    show_mtbl(cfg, res, lower_bnds, order) 
end
--------------------------------------------------------------------------------o

-- Run test -------------------------------------------------------------------o
local function run_test(elm, elm_str, cfg_tbl, tol_)
    local tol = tol_ or 1 -- Default tolerance is 1 eps
    if not dorun then return read_mtbl(elm, tol, cfg_tbl.order[1]) end
    local cfg_mtbl, res_mtbl = gen_mtbls(cfg_tbl, elm)
    local dosave = dosave or not
                  (fileexists(elm.name..".tfs") and fileexists(elm.name.."_max_err.tfs")) 
    if dosave then cfg_mtbl:write(cfg_mtbl.name..".tfs") end -- Save the cfg before results for debugging

    for i, row in cfg_mtbl:iter() do 
        if do_trck(row, elm, elm_str, tol, res_mtbl) then break end -- Run every cfg and break if debug is on and there is a failure
    end
    if dosave then res_mtbl:write(res_mtbl.name..".tfs") end -- Save the results
    if doprnt then show_mtbl(cfg_mtbl, res_mtbl, tol, cfg_tbl.order[1]) end -- Print the results
    
    if not dodbg then  -- Cleanup
        os.remove(elm.name .. "_p.txt")
        os.remove("element.seq")
        os.remove("internal_mag_pot.txt")
        os.remove("fort.18")
    end 
end
--------------------------------------------------------------------------------o

-- Concatenate two tables, index and keys --------------------------------------o
local function tbl_cat(t1, t2) 
    local t1_len = #t1
    local t = table.new(t1_len + #t2, t1_len + #t2)
    for i, v in ipairs(t1) do
        t[i] = v
        t[v] = t1[v]
    end
    for i, v in ipairs(t2) do
        t[i+t1_len] = v
        t[v] = t2[v]
    end
    return t
end
--------------------------------------------------------------------------------o


-- The actual test functions ---------------------------------------------------o
local function testQUAD(tol_)
    local elm_str = \->" QUADRUPOLE, at=0.75, l=1.5, k1=${k1}, k1s=${k1s}, tilt=${tilt}*pi/8, fringe=${fringe}"
    local quad_cfg = {
        "tilt", "fringe", "k1", "k1s",
        tilt   = 0  ..4,
        fringe = 0  ..3 ..3,
        k1     = -0.2..0.2..0.2,
        k1s    = -0.2..0.2..0.2,
    }
    run_test(quadrupole, elm_str, tbl_cat(ref_cfg, quad_cfg), tol_) -- Only actually use elm.name
end

local function testSEXT(tol_)
    local elm_str = \->" SEXTUPOLE, at=0.75, l=1.5, k2=${k2}, k2s=${k2s}, tilt=${tilt}*pi/12, fringe=${fringe}"
    local sext_cfg = {
        "tilt", "fringe", "k2", "k2s",
        tilt   = 0  ..6,
        fringe = 0  ..3 ..3,
        k2     = -0.2..0.2..0.2,
        k2s    = -0.2..0.2..0.2,
    }
    run_test(sextupole, elm_str, tbl_cat(ref_cfg, sext_cfg), tol_) -- Only actually use elm.name
end

local function testOCT(tol_)
    local elm_str = \->" OCTUPOLE, at=0.75, l=1.5, k3=${k3}, k3s=${k3s}, tilt=${tilt}*pi/16, fringe=${fringe}"
    local oct_cfg = {
        "tilt", "fringe", "k3", "k3s",
        tilt   = 0  ..8..2,
        fringe = 0  ..3 ..3,
        k3     = -0.2..0.2..0.2,
        k3s    = -0.2..0.2..0.2,
    }
    run_test(octupole, elm_str, tbl_cat(ref_cfg, oct_cfg), tol_) -- Only actually use elm.name
end


local function testDECA(tol_)
    local elm_str = \->" DECAPOLE, at=0.75, l=1.5, k4=${k4}, k4s=${k4s}, tilt=${tilt}*pi/20, fringe=${fringe}"
    local deca_cfg = {
        "tilt", "fringe", "k4", "k4s",
        tilt   = 0  ..10..5,
        fringe = 0  ..3 ..3,
        k4     = -0.2..0.2..0.2,
        k4s    = -0.2..0.2..0.2,
    }
    local deca_ref = tblcpy(ref_cfg)
    deca_ref.order = {5}
    run_test(decapole, elm_str, tbl_cat(deca_ref, deca_cfg), tol_) -- Only actually use elm.name
end

local function testDODECA(tol_)
    local elm_str = \->" DODECAPOLE, at=0.75, l=1.5, k5=${k5}, k5s=${k5s}, tilt=${tilt}*pi/24, fringe=${fringe}"
    local deca_cfg = {
        "tilt", "fringe", "k5", "k5s",
        tilt   = 0  ..12..3,
        fringe = 0  ..3 ..3,
        k5     = -0.2..0.2..0.2,
        k5s    = -0.2..0.2..0.2,
    }
    local dodeca_ref = tblcpy(ref_cfg)
    dodeca_ref.order = {6}
    run_test(dodecapole, elm_str, tbl_cat(dodeca_ref, deca_cfg), tol_) -- Only actually use elm.name
end

local function testDRIFT(tol_)
    local elm_str = \->" DRIFT, at=0.75, l=1.5"
    local drift_cfg = tblcpy(ref_cfg)
    drift_cfg.nslice = {1}
    run_test(drift, elm_str, drift_cfg, 0) -- Only actually use elm.name
end

local function testCAV(tol_)
    local elm_str = \cfg -> cfg.totalpath and "RFCAVITY, at=0.75, l=1.5, volt=${volt}, lag=${lag}, harmon=${harmon}, freq=${freq};"
                                           or "RFCAVITY, at=0.75, l=1.5, volt=${volt}, lag=${lag}, harmon=${harmon}, freq=${freq}, no_cavity_totalpath=true;"
    local cav_cfg = {
        "totalpath", "volt", "lag", "freq", "harmon",
        totalpath = {false, true},
        volt      = -8 ..8  ..8   ,
        lag       =  0 ..0.9..0.45,
        freq      =  0 ..150 ..75,
        harmon    =  {\cfg -> cfg.freq == 0 and 2 or 0},
    }
    local cav_ref = tblcpy(ref_cfg)
    cav_ref.icase = {6}
    run_test(rfcavity, elm_str, tbl_cat(cav_ref, cav_cfg), tol_)
end

local function testMULT(tol_)
    local elm_str = \-> "MULTIPOLE, at=0.75, lrad=1.5, knl={${k0}, ${k1}, ${k2}, ${k3}}, ksl={${k0s}, ${k1s}, ${k2s}, ${k3s}};"
    local cav_cfg = {
        "k0", "k1", "k2", "k3", "k0s", "k1s", "k2s", "k3s",
        k0        = -0.2..0.2..0.2,
        k1        = -0.2..0.2..0.2,
        k2        = -0.2..0.2..0.2,
        k3        = -0.2..0.2..0.2,
        k0s       = -0.2..0.2..0.2,
        k1s       = -0.2..0.2..0.2,
        k2s       = -0.2..0.2..0.2,
        k3s       = -0.2..0.2..0.2,
    }
    local cav_ref = tblcpy(ref_cfg)
    cav_ref.icase = {6}
    run_test(multipole, elm_str, tbl_cat(cav_ref, cav_cfg), tol_)
end

local function testRFMULT(tol_)
    local elm_str = \-> [[
        RFMULTIPOLE, at=0.75, lrad=1.5, volt=${volt}, lag=${lag}, harmon=${harmon}, freq=${freq}, 
        pnl={${k0}, ${k1}, ${k2}, ${k3}}, psl={${k0s}, ${k1s}, ${k2s}, ${k3s}};]]
    local cav_cfg = {
        "volt", "lag", "freq", "harmon", "k0", "k1", "k2", "k3", "k0s", "k1s", "k2s", "k3s",
        -- totalpath = {false, true}, !illegal in MAD-X
        volt      = -8 ..8  ..8   ,
        lag       =  0 ..0.9..0.45,
        freq      =  0 ..150 ..75,
        harmon    =  {\cfg -> cfg.freq == 0 and 2 or 0},
        k0        = -0.2..0.2..0.2,
        k1        = -0.2..0.2..0.2,
        k2        = -0.2..0.2..0.2,
        k3        = -0.2..0.2..0.2,
        k0s       = -0.2..0.2..0.2,
        k1s       = -0.2..0.2..0.2,
        k2s       = -0.2..0.2..0.2,
        k3s       = -0.2..0.2..0.2,
    }
    local cav_ref = tblcpy(ref_cfg)
    cav_ref.icase = {6}
    run_test(rfmultipole, elm_str, tbl_cat(cav_ref, cav_cfg), tol_)
end
--------------------------------------------------------------------------------o

-- Running the tests------------------------------------------------------------o
-- testCAV()
-- testRFMULT()
-- read_mtbl(rfcavity, 20) -- For reading the results
testQUAD(1000)
-- testSEXT()
-- testOCT()
-- testDECA ()
-- testDODECA ()
-- testDRIFT()
-- read_mtbl(quadrupole, 10, 2) -- For reading the results
-- read_mtbl(quadrupole, "quadrupole_max_err", 2) -- For reading the results
