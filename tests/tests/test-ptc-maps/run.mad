-- locals ---------------------------------------------------------------------o
local track, sequence, beam, option, filesys, regex, matrix,     
      tpsa, logrange, mtable, monomial, tostring, damap, vector  in MAD
local eps                                                        in MAD.constant
local is_number, is_matrix, is_function, is_string               in MAD.typeid
local sbend, rbend, quadrupole, sextupole, octupole, decapole,   
      dodecapole, drift, rfcavity, kicker, solenoid, elseparator,
      multipole, rfmultipole, crabcavity                         in MAD.element
local fringe                                                     in MAD.element.flags
local printf, openfile, tblcpy, val2keys, fileexists             in MAD.utility
local pi, abs                                                    in math                            

local create_dif = require "madl_dbgmap".cmpmdump

local dum = damap() -- get a dummy damap object
local coords = {"x", "px", "y", "py", "t", "pt"} -- Coordinates
local ctx =  "icase = ${icase}; model = ${model}; method = ${method}; nslice = ${nslice}; x0i = ${x0i}; order = ${order}; energy = ${energy};"
local madx_script = [[
${ctx}
seq: sequence, l=2 ;
  elm: ${elm};
endsequence ;
]]
--------------------------------------------------------------------------------o

-- The setup for the tests -----------------------------------------------------o
local doprnt = false -- false
local dorun  = true  -- true
local dosave = true  -- true
local dodbg  = false -- false

local ref_cfg = { 
    "model", "energy", "method", "nslice", "x0i", "order", "icase",
    model = 1..2,
    energy = {1, 6500}, 
    method = 2..2..2,
    nslice = 1..3..1, 
    x0i = 1..4,
    order = {2},
    icase = {56},
}
--------------------------------------------------------------------------------o

-- Dealing with the cfg mtable -------------------------------------------------o
local function gen_cfg(tbl, idx, cfg, mtbl) --The recursive function
    local k = tbl[idx]
    if not k then 
        cfg.cfgid = cfg.cfgid + 1
        return mtbl:addrow(cfg) -- Could be changed to any function
    end
    for i, v in ipairs(tbl[k]) do
        cfg[k] = is_function(v) and v(cfg) or v -- If there is a condition, use it
        gen_cfg(tbl, idx+1, cfg, mtbl)
    end
end

local function gen_mtbls(tbl, element, tol) -- Generate mtbls ready to be appended
    local cfg_mtbl, err_mtbl = {{"cfgid"}}, {{"cfgid"}}
    local order = tbl.order[1]                  -- Get the order
    
    for i = 0, order do err_mtbl[i+2] = "order"..i.."_eps" end
    for i, c in ipairs(coords) do err_mtbl[i+order+2] = c.."_eps" end
    err_mtbl = mtable(element.name.."_max_err")(err_mtbl)
    err_mtbl:inscol("Above Tolerance", 
    \ri, m =>
        for ci = 2, #coords + order + 1 do 
            if m[ri][ci] > tol then return true end 
        end 
        return 0
    end)

    for i, v in ipairs(tbl) do
        cfg_mtbl[i+1] = v
    end
    cfg_mtbl = mtable(element.name)(cfg_mtbl)
    gen_cfg(tbl, 1, {cfgid = 0}, cfg_mtbl)         -- Generate the cfg
    return cfg_mtbl, err_mtbl
end
--------------------------------------------------------------------------------o

-- Grab the final map from the madx dump file ----------------------------------o
local function getlastmap(filename)
    local file = openfile(filename, "r", {".txt", ".dat", ".out"})
    local final_pos = 0
    for line in file:lines() do
      if line:sub(1, 2) == "@@" then
        final_pos = file:seek("cur")
      end
    end
    file:seek("set", final_pos)
    local dam = dum:read(file)
    file:close()
    return dam
  end
--------------------------------------------------------------------------------o

-- Get max difference in all monomials of all coordinates in the last map ------o
local function get_diffs(map, order)
    local max_dif = {}
    for i = 0, order do max_dif[i] = 0 end
    for i, c in ipairs(coords) do -- Loop over coordinates instead
        local _, max_idxs = map[c]:maxbyord()
        local max_vals = vector(#max_idxs)
        max_idxs:map(\x-> x~=0 and abs(map[c]:get(x))/eps or 0, max_vals)
        max_dif[c] = max_vals:max()
        for ord, val in ipairs(max_vals) do
            if val > max_dif[ord-1] then max_dif[ord-1] = val end
        end
    end
    return max_dif
end
--------------------------------------------------------------------------------o

-- Write MAD-X script to element.seq and generate a MAD-NG script and return it-o
local function get_mad_str(cfg, elm, elm_str, debug_) 
    io.open("element.seq", "w"):write(
        madx_script%{elm = elm_str, ctx=ctx}%cfg
    ):close()
    return [[
local X0s = {{x=0   , px=0    , y=0    , py=0   , t=0   , pt=0   }, -- zero
             {x=3e-3, px=-2e-4, y=-2e-3, py=3e-4, t=0   , pt=0   }, -- 4D
             {x=3e-3, px=-2e-4, y=-2e-3, py=3e-4, t=0   , pt=2e-5}, -- 5D
             {x=3e-3, px=-2e-4, y=-2e-3, py=3e-4, t=1e-5, pt=2e-5}} -- 6D

local models = {DKD = 1, TKT = 2}
local beam, sequence, track in MAD
MADX:load("element.seq", true)
local beam = beam { energy = MADX.energy }
local mtbl, mflw = track {
    sequence=MADX.seq, beam=beam, X0=X0s[MADX.x0i], mapdef=MADX.order, model=models[MADX.model],
    method=MADX.method, nslice=MADX.nslice, ptcmodel=true, debug=${debug},
}
return mtbl, mflw
        ]] % {debug = debug_ and 6 or 0}
end
-------------------------------------------------------------------------------o

-- Run MAD-NG (in debug mode) and MAD-X and compare the results ---------------o
local function run_dbg(cfg, elm, elm_str) 
    io.open("ref.mad", "w"):write(get_mad_str(cfg, elm, elm_str, true)):close()
    os.execute('../mad '.. "ref.mad" ..' >' .. elm.name .. "_n.txt")
    os.execute('../madx64 '.. "ref.madx" ..' >' .. elm.name .. "_p.txt")
    create_dif({nam=elm.name})
    return true 
end
-------------------------------------------------------------------------------o

-- Run track and PTC ----------------------------------------------------------o
local function do_trck(cfg, elm, elm_str, tol, res_mtbl)
    local mtbl_row = {cfgid = cfg.cfgid}
    local _, mflw = assert(loadstring(get_mad_str(cfg, elm, elm_str)))() -- Run track
    os.execute('../madx64 '.. "ref.madx" ..' >' .. elm.name .. "_p.txt")
    MADX.elm = nil -- Remove element so that next test can be run with new values
        
    
    local ptc_res = getlastmap(elm.name .. "_p.txt"):fromptc() -- Get last map from ptc 
    local max_dif = get_diffs(mflw[1]:dif(ptc_res), cfg.order) -- Gets a list of max differences of each order

    for i = 0, cfg.order do 
        mtbl_row["order"..i.."_eps"] = max_dif[i]
    end
    for i, c in ipairs(coords) do -- Loop over coordinates instead
        mtbl_row[c.."_eps"] = max_dif[c]
    end
    res_mtbl:addrow(mtbl_row) -- Save results to mtbl

    if doprnt then io.write(cfg.cfgid, "\t") end    
    for i = 0, cfg.order do 
        if doprnt then printf("%.2e %d\t", max_dif[i]*eps, max_dif[i]) end
        if dodbg and max_dif[i] > tol then return run_dbg(cfg, elm, elm_str) end
    end
    if doprnt then io.write("\n") end 
end
-------------------------------------------------------------------------------o

--  Output results of test ----------------------------------------------------o
local function print_result(max_dif_tbl, order) -- From max_dif_tbl, print the results
    for i = 0, order do 
        io.write("\norder ",i, ":\n")
        for k, v in pairs(max_dif_tbl[i]) do
            if not (is_number(k) or k == "cfgid") then 
                io.write(k, "\t= ", tostring(v), "\n")
            end
        end
    end
end

local function get_lower_bnds(cfg, lower_bnds)
    local final_bnds = {}
    if is_string(lower_bnds) then
        local bnds_file = mtable:read(lower_bnds)
        assert(#bnds_file == #cfg, "The tolerance file must have the same number of rows as the configuration file")
        for i = 0, #cfg do final_bnds[i] = \ri->bnds_file[ri]["order"..i.."_eps"] end
    elseif is_number(lower_bnds) then
        for i = 0, #cfg do final_bnds[i] = \->lower_bnds end
    else
        for i = 0, #cfg do final_bnds[i] = \->lower_bnds[i] end
    end
    return final_bnds
end

local function show_mtbl(cfg, res, lower_bnds, order) -- (Lower bounds not optional but can be a number or tbl)
    assert(dodbg or #cfg == #res, "The configuration and result mtables must have the same number of rows")
    local lower_bnds = get_lower_bnds(cfg, lower_bnds)
    local col_tbl = {}; for i = 0, order do col_tbl[i] = {} end
    for i = 0, order do 
        local red_tbl = mtable(cfg:colnames())
        cfg:foreach(\r, ri => if res[ri] and res[ri]["order"..i.."_eps"] > lower_bnds[i](ri) then red_tbl = red_tbl + r end end)
        for _, col_name in ipairs(cfg:colnames()) do
            local c = red_tbl:getcol(col_name) 
            local _, klist = val2keys(is_matrix(c) and c:totable() or c)
            col_tbl[i][col_name] = klist
        end
    end
    print_result(col_tbl, order)
end

local function read_mtbl(element, lower_bnds, order_) -- Read the stored mtbl and cfg for the element
    local order = order_ or 4
    local cfg = mtable:read(element.name..".tfs")
    local res = mtable:read(element.name.."_max_err.tfs")
    show_mtbl(cfg, res, lower_bnds, order) 
end
--------------------------------------------------------------------------------o

-- Run test -------------------------------------------------------------------o
local function run_test(elm, elm_str, cfg_tbl, tol_)
    local tol = tol_ or 1 -- Default tolerance is 1 eps
    if not dorun then return read_mtbl(elm, tol, cfg_tbl.order[1]) end
    local cfg_mtbl, res_mtbl = gen_mtbls(cfg_tbl, elm, tol)
    local dosave = dosave or not
                  (fileexists(elm.name..".tfs") and fileexists(elm.name.."_max_err.tfs")) 
    if dosave then cfg_mtbl:write(cfg_mtbl.name..".tfs") end -- Save the cfg before results for debugging

    for i, row in cfg_mtbl:iter() do 
        if do_trck(row, elm, elm_str, tol, res_mtbl) then break end -- Run every cfg and break if debug is on and there is a failure
    end
    if dosave then res_mtbl:write(res_mtbl.name..".tfs") end -- Save the results
    if doprnt then show_mtbl(cfg_mtbl, res_mtbl, tol, cfg_tbl.order[1]) end -- Print the results
    
    if not dodbg then  -- Cleanup
        os.remove(elm.name .. "_p.txt")
        os.remove("element.seq")
        os.remove("internal_mag_pot.txt")
        os.remove("fort.18")
    end 
end
--------------------------------------------------------------------------------o

-- Concatenate two tables, index and keys --------------------------------------o
local function tbl_cat(t1, t2) 
    local t1_len = #t1
    local t = table.new(t1_len + #t2, t1_len + #t2)
    for i, v in ipairs(t1) do
        t[i] = v
        t[v] = t1[v]
    end
    for i, v in ipairs(t2) do
        t[i+t1_len] = v
        t[v] = t2[v]
    end
    return t
end
--------------------------------------------------------------------------------o


-- The actual test functions ---------------------------------------------------o
local function testQUAD(tol_)
    local elm_str = " QUADRUPOLE, at=0.75, l=1.5, k1=${k1}, k1s=${k1s}, tilt=${tilt}*pi/8, fringe=${fringe}"
    local quad_cfg = {
        "tilt", "fringe", "k1", "k1s",
        tilt   = 0  ..4,
        fringe = 0  ..3 ..3,
        k1     = -0.2..0.2..0.2,
        k1s    = -0.2..0.2..0.2,
    }
    run_test(quadrupole, elm_str, tbl_cat(ref_cfg, quad_cfg), tol_) -- Only actually use elm.name
end

local function testSEXT(tol_)
    local elm_str = " SEXTUPOLE, at=0.75, l=1.5, k2=${k2}, k2s=${k2s}, tilt=${tilt}*pi/12, fringe=${fringe}"
    local sext_cfg = {
        "tilt", "fringe", "k2", "k2s",
        tilt   = 0..6,
        fringe = 0..3..3,
        k2     = -0.2..0.2..0.2,
        k2s    = -0.2..0.2..0.2,
    }
    run_test(sextupole, elm_str, tbl_cat(ref_cfg, sext_cfg), tol_) -- Only actually use elm.name
end

local function testOCT(tol_)
    local elm_str = " OCTUPOLE, at=0.75, l=1.5, k3=${k3}, k3s=${k3s}, tilt=${tilt}*pi/16, fringe=${fringe}"
    local oct_cfg = {
        "tilt", "fringe", "k3", "k3s",
        tilt   = 0  ..8..2,
        fringe = 0  ..3 ..3,
        k3     = -0.2..0.2..0.2,
        k3s    = -0.2..0.2..0.2,
    }
    run_test(octupole, elm_str, tbl_cat(ref_cfg, oct_cfg), tol_) -- Only actually use elm.name
end


local function testDECA(tol_)
    local elm_str = " DECAPOLE, at=0.75, l=1.5, k4=${k4}, k4s=${k4s}, tilt=${tilt}*pi/20, fringe=${fringe}"
    local deca_cfg = {
        "tilt", "fringe", "k4", "k4s",
        tilt   = 0  ..10..5,
        fringe = 0  ..3 ..3,
        k4     = -0.2..0.2..0.2,
        k4s    = -0.2..0.2..0.2,
    }
    local deca_ref = tblcpy(ref_cfg)
    deca_ref.order = {5}
    run_test(decapole, elm_str, tbl_cat(deca_ref, deca_cfg), tol_) -- Only actually use elm.name
end

local function testDODECA(tol_)
    local elm_str = " DODECAPOLE, at=0.75, l=1.5, k5=${k5}, k5s=${k5s}, tilt=${tilt}*pi/24, fringe=${fringe}"
    local deca_cfg = {
        "tilt", "fringe", "k5", "k5s",
        tilt   = 0  ..12..3,
        fringe = 0  ..3 ..3,
        k5     = -0.2..0.2..0.2,
        k5s    = -0.2..0.2..0.2,
    }
    local dodeca_ref = tblcpy(ref_cfg)
    dodeca_ref.order = {6}
    run_test(dodecapole, elm_str, tbl_cat(dodeca_ref, deca_cfg), tol_) -- Only actually use elm.name
end

local function testDRIFT(tol_)
    local elm_str = " DRIFT, at=0.75, l=1.5"
    local drift_cfg = tblcpy(ref_cfg)
    drift_cfg.nslice = {1}
    run_test(drift, elm_str, drift_cfg, 0) -- Only actually use elm.name
end

local function testCAV(tol_)
    local elm_str =  "RFCAVITY, at=0.75, l=1.5, volt=${volt}, lag=${lag}, harmon=${harmon}, freq=${freq}, no_cavity_totalpath=${no_totalpath};"
    local cav_cfg = {
        "no_totalpath", "volt", "lag", "freq", "harmon",
        no_totalpath = {true, false},
        volt      = -8 ..8  ..8   ,
        lag       =  0 ..0.9..0.45,
        freq      =  0 ..150 ..75,
        harmon    =  {\cfg -> cfg.freq == 0 and 2 or 0},
    }
    local cav_ref = tblcpy(ref_cfg)
    cav_ref.icase = {6}
    run_test(rfcavity, elm_str, tbl_cat(cav_ref, cav_cfg), tol_)
end

local function testCCAV(tol_)
    local elm_str =  "CRABCAVITY, at=0.75, l=1.5, volt=${volt}, lag=${lag}, harmon=${harmon}, freq=${freq};"
    local ccav_cfg = {
        "volt", "lag", "freq", "harmon",
        -- no_totalpath = {true, false}, !Illegal in MAD-X
        volt      = -8 ..8  ..8   ,
        lag       =  0 ..0.9..0.45,
        freq      =  0 ..150 ..75,
        harmon    =  {\cfg -> cfg.freq == 0 and 2 or 0},
    }
    local cav_ref = tblcpy(ref_cfg)
    cav_ref.icase = {6}
    run_test(crabcavity, elm_str, tbl_cat(cav_ref, ccav_cfg), tol_)
end

local function testMULT(tol_)
    local elm_str =  "MULTIPOLE, at=0.75, lrad=1.5, knl={${k0}, ${k1}, ${k2}, ${k3}}, ksl={${k0s}, ${k1s}, ${k2s}, ${k3s}};"
    local mult_cfg = {
        "k0", "k1", "k2", "k3", "k0s", "k1s", "k2s", "k3s",
        k0        = -0.2..0.2..0.2,
        k1        = -0.2..0.2..0.2,
        k2        = -0.2..0.2..0.2,
        k3        = -0.2..0.2..0.2,
        k0s       = -0.2..0.2..0.2,
        k1s       = -0.2..0.2..0.2,
        k2s       = -0.2..0.2..0.2,
        k3s       = -0.2..0.2..0.2,
    }
    local cav_ref = tblcpy(ref_cfg)
    cav_ref.icase = {6}
    run_test(multipole, elm_str, tbl_cat(cav_ref, mult_cfg), tol_)
end

local function testSBEND(tol_)
    local elm_str =  "SBEND, at=0.75, l=1.5, k0=${k0}*2*pi/1e2/1.5, angle=${k0}*2*pi/1e2, kill_ent_fringe=${no_fringe}, kill_exi_fringe=${no_fringe};"
    local sbend_cfg = {
        "k0", "no_fringe", 
        k0        = -0.5..0.5..0.2,
        no_fringe = {true, false},
    }
    run_test(sbend, elm_str, tbl_cat(ref_cfg, sbend_cfg), tol_)
end

local function testRBEND(tol_)
    local elm_str =  "RBEND, at=0.75, l=1.5, k0=${k0}*2*pi/1e2/1.5, angle=${k0}*2*pi/1e2, kill_ent_fringe=${no_fringe}, kill_exi_fringe=${no_fringe}, ptcrbend=true, truerbend=true;"
    local rbend_cfg = {
        "k0", "no_fringe", 
        k0        = -0.5..0.5..0.2,
        no_fringe = {--[[ true, ]] false}, ! Impossible to turn off fringe in MAD-X
    }
    run_test(rbend, elm_str, tbl_cat(ref_cfg, rbend_cfg), tol_)
end

local function testSOL(tol_) ! Only TKT while MAD-NG does not support 0 length solenoids 
    local elm_str =  "SOLENOID, at=0.75, l=${l}, ks=${ks}, fringe=${fringe};"
    local sol_cfg = {
        "l", "ks", --[[ "ksi", ]] "fringe",
        l        = {1.5},
        ks       = -0.6..0.6..0.3,
        -- ksi      = {\cfg-> ((cfg.model==1) and (cfg.method < 4) and (cfg.nslice == 1) and cfg.ks*1.5 or 0)}, 
        fringe   = 0..1,
    }
    local sol_ref = tblcpy(ref_cfg)
    sol_ref.model = {2} ! TKT only
    run_test(solenoid, elm_str, tbl_cat(sol_ref, sol_cfg), tol_)
end

local function testELSEP(tol_)
    local elm_str =  "ELSEPARATOR, at=0.75, l=1.5, ex=${ex}, ey=${ey}, ex_l=${ex_l}, ey_l=${ey_l}, tilt=${tilt};" 
    local elsep_cfg = {
        "ex", "ey", "ex_l", "ey_l", "tilt",
        ex       = -4..4..4,
        ey       = -4..4..4,
        ex_l     = {0}, !-6..6..6,   ! Broken as the madx is ex_l and the madng is exl
        ey_l     = {0}, !-6..6..6,   ! Broken as the madx is ex_l and the madng is exl
        tilt     = {0}, !1..4, ! MAD-X does not tell PTC about tilt
    }
    run_test(elseparator, elm_str, tbl_cat(ref_cfg, elsep_cfg), tol_)
end

local function testKICK(tol_)
    local elm_str =  "KICKER, at=0.75, l=1.5, hkick=${hkick}, vkick=${vkick}, tilt=${tilt}*pi/16;"
    local kick_cfg = {
        "hkick", "vkick", "tilt",
        hkick    = -2e-3..2e-3..2e-3,
        vkick    = -2e-3..2e-3..2e-3,
        tilt     = 1..4,
    }
    run_test(kicker, elm_str, tbl_cat(ref_cfg, kick_cfg), tol_)
end

local function testRFMULT(tol_)
    local elm_str =  [[
        RFMULTIPOLE, at=0.75, lrad=1.5, volt=${volt}, lag=${lag}, harmon=${harmon}, freq=${freq}, 
        pnl={${k0}, ${k1}, ${k2}, ${k3}}, psl={${k0s}, ${k1s}, ${k2s}, ${k3s}};
        ]]
    local rfmult_cfg = {
        "volt", "lag", "freq", "harmon", "k0", "k1", "k2", "k3", "k0s", "k1s", "k2s", "k3s",
        -- totalpath = {false, true}, !illegal in MAD-X
        volt      = -8 ..8  ..8   ,
        lag       =  0 ..0.9..0.45,
        freq      =  0 ..150 ..75,
        harmon    =  {\cfg -> cfg.freq == 0 and 2 or 0},
        k0        = -0.2..0.2..0.2,
        k1        = -0.2..0.2..0.2,
        k2        = -0.2..0.2..0.2,
        k3        = -0.2..0.2..0.2,
        k0s       = -0.2..0.2..0.2,
        k1s       = -0.2..0.2..0.2,
        k2s       = -0.2..0.2..0.2,
        k3s       = -0.2..0.2..0.2,
    }
    local cav_ref = tblcpy(ref_cfg)
    cav_ref.icase = {6}
    run_test(rfmultipole, elm_str, tbl_cat(cav_ref, rfmult_cfg), tol_)
end
--------------------------------------------------------------------------------o

-- Running the tests------------------------------------------------------------o
-- testDRIFT()
-- testSBEND(1e6)
-- testRBEND(1e6)
-- testQUAD(1000)
-- testQUAD("quadrupole_max_err")! For testing with a file for the tolerance
-- testSEXT()
-- testOCT()
-- testDECA ()
-- testDODECA ()
-- testKICK(1e3)
-- testELSEP(1e3)
testMULT(100)
-- testSOL(1e3)
-- testCAV(1000)
-- testRFMULT()
-- testCCAV(1000) !Fails as MAD-X defines a k0 for the crab cavity based on volt
-- read_mtbl(quadrupole, 10, 2) -- For reading the results


--[[
    LIST OF ISSUES:
    
    MAD-NG:
        - MAD-NG does not support 0 length solenoids

    MAD-X:
        - MAD-X does not communicate tilt in ELSEPARATOR to PTC
        - MAD-X does not allow to turn off fringe in RBEND
        - MAD-X defines a k0 for the crab cavity based on volt
        - MAD-X does not support totalpath in RFMULTIPOLE
        - MAD-X does not support totalpath in CRABCAVITY
    
    Other:
        - MAD-NG does not support the same syntax for the rf cavity as MAD-X for totalpath
        - MAD-NG does not support the same syntax for the elseparator as MAD-X for exl and eyl
]]