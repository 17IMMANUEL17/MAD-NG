-- ../mad run.mad
-- assume ../madx64 to be present...


--[[
	Process:

		User input:
			- element string
			- additional parameters
			- tolerance (or set on function call)

        If dorun == false -> go to Postprocessing
        
		Preprocessing:
			- Create the mtable columns __cfg and __res (create_mtable)

        Running 
            gen_cfg
            - Create a cfg snapshot
            
            dotrck
            - Create the element sequence based on cfg
            - Run PTC and track (from loadfile) 
            - Get PTC last map and get diff with mflw[1]
            
            run_cfg
            - Store config in __cfg and results in __res
            - If print -> print results
            - If debug -> if res > tol -> run mad in file and go to Postprocessing

            Postprocessing     
            - If dosave == false -> if cfg or res file does not exist -> dosave = true
            - If dosave -> save cfg and res files             
            - if doprnt -> print linearised mtable by order and attribute
            
        Order of functions 
        run_test ->
                if not dorun -> read_mtbl ->
                                    show_mtbl ->
                                        get_lower_bnds

                else         -> create_mtbl ->
                                    gen_cfg ->
                                        run_cfg ->
                                            dotrck ->
                                                create_seq
                                                getlastmap
                                
                if prnt      -> show_mtbl ->
                                        get_lower_bnds

]]

-- locals ---------------------------------------------------------------------o
local track, sequence, beam, option, filesys, regex, matrix,     
      tpsa, logrange, mtable, monomial, tostring, damap, vector,
      object                                                     in MAD
local eps                                                        in MAD.constant
local is_number, is_matrix, is_function, is_string               in MAD.typeid
local sbend, rbend, quadrupole, sextupole, octupole, decapole,   
      dodecapole, drift, rfcavity, kicker, solenoid, elseparator,
      multipole, rfmultipole, crabcavity                         in MAD.element
local fringe                                                     in MAD.element.flags
local printf, openfile, tblcpy, val2keys, fileexists, tblcat, 
      tbl2lst                                                    in MAD.utility
local pi, abs, floor, log                                        in math                            

local create_dif = require "madl_dbgmap".cmpmdump

local dum = damap() -- get a dummy damap object for reading
local coord_tbl = {"x", "px", "y", "py", "t", "pt"} -- Coordinates
local X0s = {{x=0   , px=0    , y=0    , py=0   , t=0   , pt=0   }, -- zero
             {x=3e-3, px=-2e-4, y=-2e-3, py=3e-4, t=0   , pt=0   }, -- 4D
             {x=3e-3, px=-2e-4, y=-2e-3, py=3e-4, t=0   , pt=2e-5}, -- 5D
             {x=3e-3, px=-2e-4, y=-2e-3, py=3e-4, t=1e-5, pt=2e-5}} -- 6D

local ctx =  [[
model  = ${model};
method = ${method};
nslice = ${nslice};
energy = ${energy};
]]

local coord_str = [[
x0  = ${x};
px0 = ${px};
y0  = ${y};
py0 = ${py};
t0  = ${t};
pt0 = ${pt};
]]

local const_ctx = [[
order  = ${order};
icase  = ${icase};
debug  = ${debug};
]]

local madx_script = [[
${coords}
${ctx}
${const_ctx}
seq: sequence, l=2 ;
  elm: ${elm};
endsequence ;
]]

local in_dir  = \s -> 'input/' ..(s or '')
local madx_ref = in_dir("ref.madx")
local mad_ref  = in_dir("ref.mad")
local mad_file = loadfile(mad_ref)
local out_dir = \s -> 'output/'..(s or '')
local out_fileexists = \s -> fileexists(out_dir(s))
-- os.execute("mkdir -p "..out_dir())
--------------------------------------------------------------------------------o

-- The setup for the tests -----------------------------------------------------o
local doprnt = true      -- false
local dorun  = true      -- true
local dosave = true      -- true
local dodbg  = true     -- false

local ref_cfg = object "ref" {
  -- list of variables in the tests
  __attr = {"model", "energy", "method", "nslice", "x0i"},
  cfg  = {cfgid=0},

  -- list of values that are used in elmseq.seq but are not variables
  order  = 2,        -- 2/4
  icase  = 56,       -- 56/6
  debug  = 0,        -- 0/6

  -- list of values for each variables
  model  = 2..2,
  method = 2..2..2,    -- 2..6..2
  nslice = 1..3..2,
  energy = {1, 6500},  -- {1, 450, 6500}
  x0i    = 1..4..4,       -- 0, 4D, 5D, 6D (see get_mad_str)
}
--------------------------------------------------------------------------------o

-- Write MAD-X script to element.seq and generate a MAD-NG script and return it-o
local function create_seq(cfg, elm_str, cfg_obj)
    io.open(in_dir("elmseq.seq"), "w"):write(
        madx_script%{
            elm      = elm_str, -- Relies on cfg 
            ctx      = ctx,     -- Relies on cfg
            const_ctx= const_ctx % cfg_obj,
            coords   = coord_str % X0s[cfg.x0i],
        } % cfg
      ):close()
end
-------------------------------------------------------------------------------o

-- Grab the final map from the madx dump file ----------------------------------o
local function getlastmap(filename)
    local file = openfile(filename, "r", {".txt", ".dat", ".out"})
    local final_pos = 0
    for line in file:lines() do
      if line:sub(1, 2) == "@@" then
        final_pos = file:seek("cur")
      end
    end
    file:seek("set", final_pos)
    local dam = dum:read(file)
    file:close()
    return dam
  end
--------------------------------------------------------------------------------o

-- Run track and PTC ----------------------------------------------------------o
local function do_trck(cfg_obj, elm_str) -- Run cfg and create results
    local res = {}
    local cfg = tblcpy(cfg_obj.cfg)
	create_seq(cfg, elm_str, cfg_obj)
    local _, mflw = mad_file() -- Run track
    os.execute('../madx64 '..madx_ref ..' >' .. out_dir(cfg_obj.name .. "_p.txt"))
    MADX.elm = nil -- Remove element so that next test can be run with new values


    local ptc_res = getlastmap(out_dir(cfg_obj.name .. "_p.txt")):fromptc() -- Get last map from ptc
    local dif = mflw[1]:dif(ptc_res)
    
    local max_difs = matrix(#coord_tbl, cfg_obj.order+1)    -- Setup max matrix coords v order
    
    for i, c in ipairs(coord_tbl) do 
        local _, max_idxs = dif[c]:maxbyord()
        local max_vals = vector(#max_idxs)
        max_idxs:map(\x-> x~=0 and abs(dif[c]:get(x))/eps or 0, max_vals)
        max_difs:setrow(i, max_vals) -- Add row to matrix
        res[c.."_eps"] = max_vals:max()  -- Get coordinate max
    end
    for i = 1, max_difs.ncol do
        res["order"..i-1.."_eps"] = max_difs:getcol(i):max()
    end
    return cfg, res
end

local function run_cfg (cfg_obj, mtbl, elm_str, tol)
    local cfg, res = do_trck(cfg_obj, elm_str)
    mtbl:addrow({__cfg=cfg, __res=res})
    
    if doprnt then io.write(cfg_obj.cfg.cfgid, "\t") end
    for i = 1, cfg_obj.order+1 do
        local ord_max_dif = res["order"..i-1.."_eps"]
        if doprnt then                      -- Output the results per row
            io.write(
                ord_max_dif > tol and 
                ">e+" .. floor(log(ord_max_dif, 10)) or
                string.format("%d", ord_max_dif), "\t")
        end
        if dodbg and ord_max_dif > tol then  -- Debug the problem and exit
            cfg_obj.debug = 6
            create_seq(cfg, elm_str, cfg_obj)
            os.execute('../mad '.. mad_ref ..' >' .. out_dir(cfg_obj.name .. "_n.txt"))
            create_dif({nam=out_dir(cfg_obj.name)})
            cfg_obj.stop = true
        end
    end
    if doprnt then io.write("\n") end
end

-- Dealing with the cfg mtable -------------------------------------------------o
local function gen_cfg(cfg_obj, idx, gen_fun) --The recursive function
    if cfg_obj.stop then return end
    local k = cfg_obj.__attr[idx]
    if not k then
        cfg_obj.cfg.cfgid = cfg_obj.cfg.cfgid + 1
        return gen_fun() -- Could be changed to any function
    end
    for i, v in ipairs(cfg_obj[k]) do
        cfg_obj.cfg[k] = v -- If there is a condition, use it
        gen_cfg(cfg_obj, idx+1, gen_fun)
    end
end
local function create_mtbl(cfg_obj, elm_str, tol) -- Create empty mtable and fill function
    local mtbl_cols = {"__cfg", "__res"}
	local mtbl = mtable(cfg_obj.name)(mtbl_cols)
	gen_cfg(cfg_obj, 1, \-> run_cfg(cfg_obj, mtbl, elm_str, tol)) -- Fill the mtable
    
    local attr_cols = tbl2lst(mtbl.__cfg[1])
    local res_cols  = tbl2lst(mtbl.__res[1])
    for i, k in pairs(attr_cols) do
        mtbl:addcol(k, \ri, m -> m[ri].__cfg[k])
    end
    for i, k in pairs(res_cols) do
        mtbl:addcol(k, \ri, m -> m[ri].__res[k])
    end
    return mtbl, attr_cols, res_cols
end
-------------------------------------------------------------------------------o

--  Output results of test ----------------------------------------------------o
local function get_lower_bnds(res, lower_bnds)
    if is_string(lower_bnds) then
        local bnds_file = mtable:read(lower_bnds)
        assert(#bnds_file == #res, "The tolerance file must have the same number of rows as the configuration file")
        return \o, ri->bnds_file[ri]["order"..o.."_eps"]
    elseif is_number(lower_bnds) then
        return \->lower_bnds
    else 
        return \o->lower_bnds[o]
    end
end

local function show_mtbl(res, attr_cols, lower_bnds, order) -- (Lower bounds not optional but can be a number or tbl)
    local lower_bnds = get_lower_bnds(res, lower_bnds)
    local col_tbl = {}; for i = 0, order do col_tbl[i] = {} end
    local dum_tbl = mtable(tblcpy(attr_cols))
    dum_tbl.novector = true
    for o = 0, order do
        local err_tbl = dum_tbl:copy()
        res:foreach(\r, ri =>
            if res[ri]["order"..o.."_eps"] > lower_bnds(o, ri) then 
                for i, v in ipairs(attr_cols) do
                    err_tbl[v][ri] = r[v]
                end 
            end end)
        
        -- Prrinting
        io.write("\norder ",o, ":\n")
        for _, col_name in ipairs(attr_cols) do
            local _, key_cnt = val2keys(err_tbl:getcol(col_name))
            if not (col_name == "cfgid") then
                io.write(col_name, "\t= ", tostring(key_cnt), "\n")
            end
        end
    end
end

local function read_mtbl(test_name, lower_bnds, order_) -- Read the stored mtbl and cfg for the element
    local order = order_ or 4
    local cfg = mtable:read(out_dir(test_name.."_cfg.tfs"))
    local res = mtable:read(out_dir(test_name.."_res.tfs"))
    show_mtbl(res, res:colnames(), lower_bnds, order)
end
--------------------------------------------------------------------------------o

-- Run test -------------------------------------------------------------------o
local function run_test(elm_str, cfg_obj, tol_)
    local tol = tol_ or 1 -- Default tolerance is 1 eps
    if not dorun then return read_mtbl(cfg_obj.name, tol, cfg_obj.order) end
    local cfg_mtbl, attr_cols, res_cols = create_mtbl(cfg_obj, elm_str, tol)
    local dosave = dosave or not
                  (out_fileexists(cfg_obj.name.."_cfg.tfs") and out_fileexists(cfg_obj.name.."_res.tfs"))
    if dosave then 
        cfg_mtbl:write(out_dir(cfg_mtbl.name.."_cfg.tfs"), attr_cols) -- Save the cfg before results for debugging
        cfg_mtbl:write(out_dir(cfg_mtbl.name.."_res.tfs"), res_cols) 
    end -- Save the results
    if doprnt then show_mtbl(cfg_mtbl, attr_cols, tol, cfg_obj.order) end -- Print the results

    if not cfg_obj.stop then  -- Cleanup
        os.remove(cfg_obj.name .. "_p.txt")
        os.remove(in_dir("elmseq.seq"))
        os.remove("internal_mag_pot.txt")
        os.remove("fort.18")
    end
end
--------------------------------------------------------------------------------o

-- The actual test functions ---------------------------------------------------o
local function testQUAD(tol_)
    local elm_str = " QUADRUPOLE, at=0.75, l=1.5, k1=${k1}, k1s=${k1s}, tilt=${tilt}*pi/8, fringe=${fringe}"
    local elm_cfg = ref_cfg "quadrupole" {
        __attr = tblcat(ref_cfg.__attr, {"tilt", "fringe", "k1", "k1s"}),
        tilt   = 0  ..4,
        fringe = 0  ..3 ..3,
        k1     = -0.2..0.2..0.2,
        k1s    = -0.2..0.2..0.2,
    }
    run_test(elm_str, elm_cfg, tol_) 
end

local function testSEXT(tol_)
    local elm_str = " SEXTUPOLE, at=0.75, l=1.5, k2=${k2}, k2s=${k2s}, tilt=${tilt}*pi/12, fringe=${fringe}"
    local elm_cfg = ref_cfg "sextupole" {
        __attr = tblcat(ref_cfg.__attr, {"tilt", "fringe", "k2", "k2s",}),
        tilt   = 0..6,
        fringe = 0..3..3,
        k2     = -0.2..0.2..0.2,
        k2s    = -0.2..0.2..0.2,
    }
    run_test(elm_str, elm_cfg, tol_) 
end

local function testOCT(tol_)
    local elm_str = " OCTUPOLE, at=0.75, l=1.5, k3=${k3}, k3s=${k3s}, tilt=${tilt}*pi/16, fringe=${fringe}"
    local elm_cfg = ref_cfg "octupole" {
        __attr = tblcat(ref_cfg.__attr, {"tilt", "fringe", "k3", "k3s"}),
        tilt   = 0  ..8..2,
        fringe = 0  ..3 ..3,
        k3     = -0.2..0.2..0.2,
        k3s    = -0.2..0.2..0.2,
    }
    run_test(elm_str, elm_cfg, tol_) 
end


local function testDECA(tol_)
    local elm_str = "multipole, at=0.75, knl={0,0,0,0,${k4}*1.5}, ksl={0,0,0,0,${k4s}*1.5}, tilt=${tilt}*pi/20, fringe=${fringe}"
    local elm_cfg = ref_cfg "decapole" {
        __attr = tblcat(ref_cfg.__attr, {"tilt", "fringe", "k4", "k4s"}),
        tilt   = 0  ..10..5,
        fringe = 0  ..3 ..3,
        k4     = -0.2..0.2..0.2,
        k4s    = -0.2..0.2..0.2,
        order  = 5,
    }
    run_test(elm_str, elm_cfg, tol_) 
end

local function testDODECA(tol_)
    local elm_str = "multipole, at=0.75, knl={0,0,0,0,0,${k5}*1.5}, ksl={0,0,0,0,${k5s}*1.5}, tilt=${tilt}*pi/20, fringe=${fringe}"
    local elm_cfg = ref_cfg "dodecapole" {
        __attr = tblcat(ref_cfg.__attr, {"tilt", "fringe", "k5", "k5s"}),
        tilt   = 0  ..12..3,
        fringe = 0  ..3 ..3,
        k5     = -0.2..0.2..0.2,
        k5s    = -0.2..0.2..0.2,
        order = 6,
    }
    run_test(elm_str, elm_cfg, tol_) 
end

local function testDRIFT(tol_)
    local elm_str = " DRIFT, at=0.75, l=1.5"
    local elm_cfg = ref_cfg "drift" { }
    run_test(elm_str, elm_cfg, tol_) 
end

local function testCAV(tol_)
    local elm_str =  "RFCAVITY, at=0.75, l=1.5, volt=${volt}, lag=${lag}, harmon=${harmon}, freq=${freq}, no_cavity_totalpath=${no_totalpath};"
    local elm_cfg = ref_cfg "cavity" {
        __attr =  tblcat(ref_cfg.__attr, {"no_totalpath", "volt", "lag", "freq", "harmon"}),
        no_totalpath = {true, false},
        volt      = -8 ..8  ..8   ,
        lag       =  0 ..0.9..0.45,
        freq      =  0 ..150 ..75,
        icase     =  6,
    }
    elm_cfg = elm_cfg {harmon := {elm_cfg.cfg.freq == 0 and 2 or 0},}
    run_test(elm_str, elm_cfg, tol_)
end

local function testCCAV(tol_)
    local elm_str =  "CRABCAVITY, at=0.75, l=1.5, volt=${volt}, lag=${lag}, harmon=${harmon}, freq=${freq};"
    local elm_cfg = ref_cfg "cavity" {
        __attr = tblcat(ref_cfg.__attr, {"volt", "lag", "freq", "harmon"}),
        -- no_totalpath = {true, false}, !Illegal in MAD-X
        volt      = -8 ..8  ..8   ,
        lag       =  0 ..0.9..0.45,
        freq      =  0 ..150 ..75,
        icase     =  6,
    }
    elm_cfg = elm_cfg {harmon := {elm_cfg.cfg.freq == 0 and 2 or 0},}
    run_test(elm_str, elm_cfg, tol_)
end

local function testMULT(tol_)
    local elm_str =  "MULTIPOLE, at=0.75, lrad=1.5, knl={${k0}, ${k1}, ${k2}, ${k3}}, ksl={${k0s}, ${k1s}, ${k2s}, ${k3s}};"
    local elm_cfg = ref_cfg "multipole" {
        __attr = tblcat(ref_cfg.__attr, {"k0", "k1", "k2", "k3", "k0s", "k1s", "k2s", "k3s"}),
        k0        = -0.2..0.2..0.2,
        k1        = -0.2..0.2..0.2,
        k2        = -0.2..0.2..0.2,
        k3        = -0.2..0.2..0.2,
        k0s       = -0.2..0.2..0.2,
        k1s       = -0.2..0.2..0.2,
        k2s       = -0.2..0.2..0.2,
        k3s       = -0.2..0.2..0.2,
    }
    run_test(elm_str, elm_cfg, tol_)
end

local function testSBEND(tol_)
    local elm_str =  "SBEND, at=0.75, l=1.5, angle=${k0}*2*pi/1e2, kill_ent_fringe=${no_fringe}, kill_exi_fringe=${no_fringe};"
    local elm_cfg = ref_cfg "sbend" {
        __attr = tblcat(ref_cfg.__attr, {"k0", "no_fringe"}), 
        k0        = -0.5..0.5..0.2,
        no_fringe = {true, false},
    }
    run_test(elm_str, elm_cfg, tol_)
end

local function testRBEND(tol_)
    local elm_str =  "RBEND, at=0.75, l=1.5, angle=${k0}*2*pi/1e2, kill_ent_fringe=${no_fringe}, kill_exi_fringe=${no_fringe}, ptcrbend=true, truerbend=true;"
    local elm_cfg = ref_cfg "rbend"{
        __attr = tblcat(ref_cfg.__attr, {"k0", "no_fringe"}),
        k0        = -0.5..0.5..0.2,
        no_fringe = {--[[ true, ]] false}, ! Impossible to turn off fringe in MAD-X
    }
    run_test(elm_str, elm_cfg, tol_)
end

local function testSOL(tol_) ! Only TKT while MAD-NG does not support 0 length solenoids 
    local elm_str =  "SOLENOID, at=0.75, l=${l}, ks=${ks}, fringe=${fringe};"
    local elm_cfg = ref_cfg "solenoid" {
        __attr = tblcat(ref_cfg.__attr, {"l", "ks", --[[ "ksi", ]] "fringe"}),
        l        = {1.5},
        ks       = -0.6..0.6..0.3,
        -- ksi      = {\cfg-> ((cfg.model==1) and (cfg.method < 4) and (cfg.nslice == 1) and cfg.ks*1.5 or 0)}, 
        fringe   = 0..1,
        model    = {2},
    }
    run_test(elm_str, elm_cfg, tol_)
end

local function testELSEP(tol_)
    local elm_str =  "ELSEPARATOR, at=0.75, l=1.5, ex=${ex}, ey=${ey}, ex_l=${ex_l}, ey_l=${ey_l}, tilt=${tilt};" 
    local elm_cfg = ref_cfg "elseparator" {
        __attr = tblcat(ref_cfg.__attr, {"ex", "ey", "ex_l", "ey_l", "tilt"}),
        ex       = -4..4..4,
        ey       = -4..4..4,
        ex_l     = {0}, !-6..6..6,   ! Broken as the madx is ex_l and the madng is exl
        ey_l     = {0}, !-6..6..6,   ! Broken as the madx is ex_l and the madng is exl
        tilt     = {0}, !1..4, ! MAD-X does not tell PTC about tilt
    }
    run_test(elm_str, elm_cfg, tol_)
end

local function testKICK(tol_)
    local elm_str =  "KICKER, at=0.75, l=1.5, hkick=${hkick}, vkick=${vkick}, tilt=${tilt}*pi/16;"
    local elm_cfg = ref_cfg "kicker" {
        __attr = tblcat(ref_cfg.__attr, {"hkick", "vkick", "tilt"}), 
        hkick    = -2e-3..2e-3..2e-3,
        vkick    = -2e-3..2e-3..2e-3,
        tilt     = 1..4,
    }
    run_test(elm_str, elm_cfg, tol_)
end

local function testRFMULT(tol_)
    local elm_str =  [[
        RFMULTIPOLE, at=0.75, lrad=1.5, volt=${volt}, lag=${lag}, harmon=${harmon}, freq=${freq},
        pnl={${k0}, ${k1}, ${k2}, ${k3}}, psl={${k0s}, ${k1s}, ${k2s}, ${k3s}};
        ]]
    local elm_cfg = ref_cfg "rfmultipole" {
        __attr = tblcat(ref_cfg.__attr, {"volt", "lag", "freq", "harmon", "k0", "k1", "k2", "k3", "k0s", "k1s", "k2s", "k3s"}),
        -- totalpath = {false, true}, !illegal in MAD-X
        volt      = -8 ..8  ..8   ,
        lag       =  0 ..0.9..0.45,
        freq      =  0 ..150 ..75,
        k0        = -0.2..0.2..0.2,
        k1        = -0.2..0.2..0.2,
        k2        = -0.2..0.2..0.2,
        k3        = -0.2..0.2..0.2,
        k0s       = -0.2..0.2..0.2,
        k1s       = -0.2..0.2..0.2,
        k2s       = -0.2..0.2..0.2,
        k3s       = -0.2..0.2..0.2,
        icase     = 6,
    }
    elm_cfg = elm_cfg {harmon := {elm_cfg.cfg.freq == 0 and 2 or 0},}
    run_test(elm_str, elm_cfg, tol_)
end
-------------------------------------------------------------------------------o

-- Running the tests------------------------------------------------------------o
-- testDRIFT(20)
-- testSBEND(1e6)
-- testRBEND(1e6)
-- testQUAD(1000)
-- testQUAD("quadrupole_max_err")! For testing with a file for the tolerance
-- testSEXT(100)
-- testOCT(100)
-- testDECA (100) -- Only actually tests the multipole
-- testDODECA (100) -- Only actually tests the multipole
-- testKICK(1e3)
-- testELSEP(1e3)
-- testMULT(100)
-- testSOL(1e3)
-- testCAV(1000)
testRFMULT(10)
-- testCCAV(1000) !Fails as MAD-X defines a k0 for the crab cavity based on volt
-- read_mtbl(quadrupole, 10, 2) -- For reading the results


--[[
    LIST OF ISSUES:
    
    MAD-NG:
        - MAD-NG does not support 0 length solenoids

    MAD-X:
        - MAD-X does not communicate tilt in ELSEPARATOR to PTC
        - MAD-X does not allow to turn off fringe in RBEND
        - MAD-X defines a k0 for the crab cavity based on volt
        - MAD-X does not support totalpath in RFMULTIPOLE
        - MAD-X does not support totalpath in CRABCAVITY
    
    Other:
        - MAD-NG does not support the same syntax for the rf cavity as MAD-X for totalpath
        - MAD-NG does not support the same syntax for the elseparator as MAD-X for exl and eyl
]]