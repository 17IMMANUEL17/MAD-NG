-- ../mad run.mad
-- assume ../madx64 to be present...


--[[
	Process:

		User input:
			- element string
			- additional parameters
			- tolerance (or set on function call)

        If dorun == false -> go to Postprocessing
        
		Preprocessing:
			- Create the mtable columns __cfg and __res (create_mtable)

        Running 
            gen_cfg
            - Create a cfg snapshot
            
            dotrck
            - Create the element sequence based on cfg
            - Run PTC and track (from loadfile) 
            - Get PTC last map and get diff with mflw[1]
            
            run_cfg
            - Store config in __cfg and results in __res
            - If print -> print results
            - If debug -> if res > tol -> run mad in file and go to Postprocessing

            Postprocessing     
            - If dosave == false -> if cfg or res file does not exist -> dosave = true
            - If dosave -> save cfg and res files             
            - if doprnt -> print linearised mtable by order and attribute
            
        Order of functions 
        run_test ->
                if not dorun -> read_mtbl ->
                                    show_mtbl ->
                                        get_lower_bnds

                else         -> create_mtbl ->
                                    gen_cfg ->
                                        run_cfg ->
                                            dotrck ->
                                                create_seq
                                                getlastmap
                                
                if prnt      -> show_mtbl ->
                                        get_lower_bnds

]]

-- locals ---------------------------------------------------------------------o
local matrix, mtable, tostring, damap, vector, object            in MAD
local eps                                                        in MAD.constant
local is_number, is_matrix, is_function, is_string               in MAD.typeid
local sbend, rbend, quadrupole, sextupole, octupole, decapole,   
      dodecapole, drift, rfcavity, kicker, solenoid, elseparator,
      multipole, rfmultipole, crabcavity                         in MAD.element
local fringe                                                     in MAD.element.flags
local printf, openfile, tblcpy, val2keys, fileexists, tblcat, 
      tbl2lst                                                    in MAD.utility
local pi, abs, floor, log                                        in math                            

local create_dif = require "madl_dbgmap".cmpmdump

local dum = damap() -- get a dummy damap object for reading
local coord_tbl = {"x", "px", "y", "py", "t", "pt"} -- Coordinates
local X0s = {{x=0   , px=0    , y=0    , py=0   , t=0   , pt=0   }, -- zero
             {x=3e-3, px=-2e-4, y=-2e-3, py=3e-4, t=0   , pt=0   }, -- 4D
             {x=3e-3, px=-2e-4, y=-2e-3, py=3e-4, t=0   , pt=2e-5}, -- 5D
             {x=3e-3, px=-2e-4, y=-2e-3, py=3e-4, t=1e-5, pt=2e-5}} -- 6D

local ctx =  [[
model  = ${model};
method = ${method};
nslice = ${nslice};
energy = ${energy};
]]

local coord_str = [[
x0  = ${x};
px0 = ${px};
y0  = ${y};
py0 = ${py};
t0  = ${t};
pt0 = ${pt};
]]

local const_ctx = [[
order  = ${order};
icase  = ${icase};
debug  = ${debug};
]]

local madx_script = [[
${coords}
${ctx}
${const_ctx}
seq: sequence, l=2 ;
  elm: ${elm};
endsequence ;
]]

local in_dir  = \s -> 'input/' ..(s or '')
local madx_ref = in_dir("ref.madx")
local mad_ref  = in_dir("ref.mad")
local mad_file = loadfile(mad_ref)
local out_dir = \s -> 'output/'..(s or '')
local out_fileexists = \s -> fileexists(out_dir(s))
os.execute("mkdir -p "..out_dir())
--------------------------------------------------------------------------------o

-- Write MAD-X script to element.seq and generate a MAD-NG script and return it-o
local function create_seq(cfg, elm_str, cfg_obj)
    io.open(in_dir("elmseq.seq"), "w"):write(
        madx_script%{
            elm      = elm_str, -- Relies on cfg 
            ctx      = ctx,     -- Relies on cfg
            const_ctx= const_ctx % cfg_obj,
            coords   = coord_str % X0s[cfg.x0i],
        } % cfg
      ):close()
end
-------------------------------------------------------------------------------o

-- Grab the final map from the madx dump file ----------------------------------o
local function getlastmap(filename)
    local file = openfile(filename, "r", {".txt", ".dat", ".out"})
    local final_pos = 0
    for line in file:lines() do
      if line:sub(1, 2) == "@@" then
        final_pos = file:seek("cur")
      end
    end
    file:seek("set", final_pos)
    local dam = dum:read(file)
    file:close()
    return dam
  end
--------------------------------------------------------------------------------o

-- Run track and PTC ----------------------------------------------------------o
local function do_trck(cfg_obj, elm_str) -- Run cfg and create results
    local res = {}
    local cfg = tblcpy(cfg_obj.cfg)
	create_seq(cfg, elm_str, cfg_obj)
    local _, mflw = mad_file() -- Run track
    os.execute('../madx64 '..madx_ref ..' >' .. out_dir(cfg_obj.name .. "_p.txt"))
    MADX.elm = nil -- Remove element so that next test can be run with new values


    local ptc_res = getlastmap(out_dir(cfg_obj.name .. "_p.txt")):fromptc() -- Get last map from ptc
    local dif = mflw[1]:dif(ptc_res)
    
    local max_difs = matrix(#coord_tbl, cfg_obj.order+1)    -- Setup max matrix coords v order
    
    for i, c in ipairs(coord_tbl) do 
        local _, max_idxs = dif[c]:maxbyord()
        local max_vals = vector(#max_idxs)
        max_idxs:map(\x-> x~=0 and abs(dif[c]:get(x))/eps or 0, max_vals)
        max_difs:setrow(i, max_vals) -- Add row to matrix
        res[c.."_eps"] = max_vals:max()  -- Get coordinate max
    end
    for i = 1, max_difs.ncol do
        res["order"..i-1.."_eps"] = max_difs:getcol(i):max()
    end
    return cfg, res
end

local function run_cfg (cfg_obj, mtbl, elm_str, tol)
    local cfg, res = do_trck(cfg_obj, elm_str)
    mtbl:addrow({__cfg=cfg, __res=res})
    
    if cfg_obj.doprnt then io.write(cfg_obj.cfg.cfgid, "\t") end
    for i = 1, cfg_obj.order+1 do
        local ord_max_dif = res["order"..i-1.."_eps"]
        if cfg_obj.doprnt then                      -- Output the results per row
            io.write(
                ord_max_dif > tol and 
                ">e+" .. floor(log(ord_max_dif, 10)) or
                string.format("%d", ord_max_dif), "\t")
        end
        if cfg_obj.dodbg and ord_max_dif > tol then  -- Debug the problem and exit
            cfg_obj.debug = 6
            create_seq(cfg, elm_str, cfg_obj)
            os.execute('../mad '.. mad_ref ..' >' .. out_dir(cfg_obj.name .. "_n.txt"))
            create_dif({nam=out_dir(cfg_obj.name)})
            cfg_obj.stop = true
        end
    end
    if cfg_obj.doprnt then io.write("\n") end
end

-- Dealing with the cfg mtable -------------------------------------------------o
local function gen_cfg(cfg_obj, idx, gen_fun) --The recursive function
    if cfg_obj.stop then return end
    local k = cfg_obj.__attr[idx]
    if not k then
        cfg_obj.cfg.cfgid = cfg_obj.cfg.cfgid + 1
        return gen_fun() -- Could be changed to any function
    end
    for i, v in ipairs(cfg_obj[k]) do
        cfg_obj.cfg[k] = v -- If there is a condition, use it
        gen_cfg(cfg_obj, idx+1, gen_fun)
    end
end
local function create_mtbl(cfg_obj, elm_str, tol) -- Create empty mtable and fill function
    local mtbl_cols = {"__cfg", "__res"}
	local mtbl = mtable(cfg_obj.name)(mtbl_cols)
	gen_cfg(cfg_obj, 1, \-> run_cfg(cfg_obj, mtbl, elm_str, tol)) -- Fill the mtable
    
    local attr_cols = tbl2lst(mtbl.__cfg[1])
    local res_cols  = tbl2lst(mtbl.__res[1])
    for i, k in pairs(attr_cols) do
        mtbl:addcol(k, \ri, m -> m[ri].__cfg[k])
    end
    for i, k in pairs(res_cols) do
        mtbl:addcol(k, \ri, m -> m[ri].__res[k])
    end
    return mtbl, attr_cols, res_cols
end
-------------------------------------------------------------------------------o

--  Output results of test ----------------------------------------------------o
local function get_lower_bnds(res, lower_bnds)
    if is_string(lower_bnds) then
        local bnds_file = mtable:read(lower_bnds)
        assert(#bnds_file == #res, "The tolerance file must have the same number of rows as the configuration file")
        return \o, ri->bnds_file[ri]["order"..o.."_eps"]
    elseif is_number(lower_bnds) then
        return \->lower_bnds
    else 
        return \o->lower_bnds[o]
    end
end

local function show_mtbl(res, attr_cols, lower_bnds, order) -- (Lower bounds not optional but can be a number or tbl)
    local lower_bnds = get_lower_bnds(res, lower_bnds)
    local col_tbl = {}; for i = 0, order do col_tbl[i] = {} end
    local dum_tbl = mtable(tblcpy(attr_cols))
    dum_tbl.novector = true
    for o = 0, order do
        local err_tbl = dum_tbl:copy()
        res:foreach(\r, ri =>
            if res[ri]["order"..o.."_eps"] > lower_bnds(o, ri) then 
                for i, v in ipairs(attr_cols) do
                    err_tbl[v][ri] = r[v]
                end 
            end end)
        
        -- Prrinting
        io.write("\norder ",o, ":\n")
        for _, col_name in ipairs(attr_cols) do
            local _, key_cnt = val2keys(err_tbl:getcol(col_name))
            if not (col_name == "cfgid") then
                io.write(col_name, "\t= ", tostring(key_cnt), "\n")
            end
        end
    end
end

local function read_mtbl(test_name, lower_bnds, order_) -- Read the stored mtbl and cfg for the element
    local order = order_ or 4
    local cfg = mtable:read(out_dir(test_name.."_cfg.tfs"))
    local res = mtable:read(out_dir(test_name.."_res.tfs"))
    show_mtbl(res, res:colnames(), lower_bnds, order)
end
-------------------------------------------------------------------------------o

-- Run test -------------------------------------------------------------------o
local function run_test(elm_str, cfg_obj, tol_)
    local tol = tol_ or 1 -- Default tolerance is 1 eps
    if not cfg_obj.dorun then return read_mtbl(cfg_obj.name, tol, cfg_obj.order) end
    local cfg_mtbl, attr_cols, res_cols = create_mtbl(cfg_obj, elm_str, tol)
    cfg_obj.dosave = cfg_obj.dosave or not
                  (out_fileexists(cfg_obj.name.."_cfg.tfs") and out_fileexists(cfg_obj.name.."_res.tfs"))
    if cfg_obj.dosave then 
        cfg_mtbl:write(out_dir(cfg_mtbl.name.."_cfg.tfs"), attr_cols) -- Save the cfg before results for debugging
        cfg_mtbl:write(out_dir(cfg_mtbl.name.."_res.tfs"), res_cols) 
    end -- Save the results
    if cfg_obj.doprnt then show_mtbl(cfg_mtbl, attr_cols, tol, cfg_obj.order) end -- Print the results

    if not cfg_obj.stop then  -- Cleanup
        os.remove(cfg_obj.name .. "_p.txt")
        os.remove(in_dir("elmseq.seq"))
        os.remove("internal_mag_pot.txt")
        os.remove("fort.18")
    end
end
--------------------------------------------------------------------------------o
return {run_test = run_test}