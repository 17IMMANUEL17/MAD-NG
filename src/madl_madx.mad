--[=[
 o-----------------------------------------------------------------------------o
 |
 | MADX module
 |
 | Methodical Accelerator Design - Copyright CERN 2015+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide basic compatibility with MADX sequences and optics files

 o-----------------------------------------------------------------------------o
]=]

local M = { __help = {} }

-- help -----------------------------------------------------------------------o

M.__help.self = [=[
NAME
  madx for MAD-X compatibility

SYNOPSIS
  local MADX = require "madx"

DESCRIPTION
  This module provide the function loadmadx that read MADX sequence and optics
  files and load then in the MADX global variable. If it does not exist, it will
  create the globla MADX variable as an object and load all elements, constants,
  and math functions compatible with MADX.

RETURN VALUES
  The MADX global variable

EXAMPLES
  local MADX = require "madx"
  MADX:open_env()
  -- inline definition
  MADX:close_env()

SEE ALSO
  element, object
]=]

-- locals ---------------------------------------------------------------------o

local Object, is_nil, is_number, is_string in MAD

-- MADX environment -----------------------------------------------------------o

assert(is_nil(MADX), "MADX environment already defined")

MADX = Object {}  -- global
local MADX = MADX -- local

-- math functions, see mad_dict.c from MAD-X source
MADX:set_function {
  abs    = math.abs   ,
  sqrt   = math.sqrt  ,
  exp    = math.exp   ,
  log    = math.log   ,
  log10  = math.log10 ,
  sin    = math.sin   ,
  cos    = math.cos   ,
  tan    = math.tan   ,
  sinh   = math.sinh  ,
  cosh   = math.cosh  ,
  tanh   = math.tanh  ,
  asin   = math.asin  ,
  acos   = math.acos  ,
  atan   = math.atan  ,
  asinh  = MAD .asinh ,
  acosh  = MAD .acosh ,
  atanh  = MAD .atanh ,
  ranf   = MAD .ranf  ,
  gauss  = MAD .gauss ,
  tgauss = MAD .tgauss,
  floor  = math.floor ,
  ceil   = math.ceil  ,
  round  = MAD .round ,
  frac   = MAD .frac  ,
  erf    = MAD .erf   ,
  erfc   = MAD .erfc  ,
  sinc   = MAD .sinc  ,
}

-- constants
MADX:set_variable(MAD.constant)

-- elements
MADX:set_variable(MAD.element)

-- aliases (not in MAD)
MADX.tkicker     = MAD.element.kicker
MADX.rcollimator = MAD.element.collimator

-- load -----------------------------------------------------------------------o

local seq, env

local function incr (t,k)
  t[k] = (t[k] or 0) + 1
end

local cmt = { ['//'] = '--', ['/*'] = '--[[', ['*/'] = ']]', }

local function convert_comments (line)
  return string.gsub(line, '([/*][/*])', cmt)
end

local function convert_name (str)
  str = string.lower(string.gsub(str, '([.$])', '_'))
  -- incr(env.nam, str)
  return str
end

local function convert_names (str)
  return string.gsub(str, '([%a_][%w%._$]*)', convert_name)
end

local tok = { real='', const='', shared='', REAL='', CONST='', SHARED='' }

local function convert_tokens (line)
  line = string.gsub(line, '(%w+)', tok)
  line = string.gsub(line, '->', '.')
  line = string.gsub(line, '%%', '.')
  line = string.gsub(line, '&', ' ')
  return line
end
               --   [1]  [2]             [3]  [4]  [5]  [6]
local variable = "^(%s*)([%a_][%w%._$]*)(%s*)(:?=)(%s*)([^;]*);"

local function convert_variable (line, cap)
  cap[2] = convert_name(cap[2])
  if cap[4] == ':=' then cap[4] = '=\\ ' end
  cap[6] = convert_names(cap[6])
  if string.sub(cap[6],1,1) == '(' then
    cap[6] = '(' .. cap[6] .. ')'
  end
  -- incr(env.var, cap[2])
  return table.concat( cap )
end

              --   [1]  [2]                [3]  [4]
local command = "^(%s*)([%a_][%w%._$]*)%s*([,;])()"
local command_attr = "(%s*)([^;]*);"

local function convert_command (line, cap)
  local cmd = convert_name(cap[2])
  local spc
  if cmd == 'endsequence' then
    seq = nil
    return '}'
  end
  if cap[3] == ',' and env.elm[cmd] ~= nil then -- update
    assert(seq == nil, "invalid update inside sequence definition")
    spc, cap[3] = string.match(line, command_attr, cap[4]+1)
    assert(cap[3], "invalid empty update detected")
    cap[3] = convert_names(cap[3])
    return string.format("%s['%s'] :set %s{ %s }",  env.elm[cmd], cap[2], spc or '', cap[3])
  else -- command
    line = '-- ' .. line
  end
  return line
end
              --   [1]  [2]                    [3]                [4]  [5]
local element = "^(%s*)([%a_][%w%._$]*)%s*:%s*([%a_][%w%._$]*)%s*([,;=])()"
local element_attr = "(%s*)([^;]*);"
local element_line = "(%s*)(%b())%s*;"
local element_from = "from%s*=%s*([%a_][%w%._$]*)"

local function convert_from (str)
  return string.gsub(str, element_from, "from = '%1'")
end

local function convert_line (str)
  local cap = string.sub(str, 2, -2)
  if cap ~= '' then
    cap = '{ ' .. cap
  end
  return cap
end

local function convert_element (line, cap)
  local elm = convert_name(cap[2])
  local cls = convert_name(cap[3])
  local spc, clo, pfx
  if cls == 'sequence' then -- sequence
    assert(not seq, "invalid sequence definition inside sequence definition")
    seq, clo, pfx = elm, ',', elm .. ' = '
    env.seq[elm] = elm
    env.seq[#env.seq+1] = elm
  elseif not seq then       -- class
    clo, pfx = ' }', elm .. ' = '
    env.elm[elm] = cls
  else                      -- element
    clo, pfx = ' },', ''
    if env.elm[elm] then env.tie[env.elm[elm]] = seq end
    env.elm[elm] = seq
  end
  if cap[4] == ',' then     -- attribute
    spc, cap[4] = string.match(line, element_attr, cap[5]+1)
    cap[4] = convert_from (cap[4] or '')
    cap[4] = convert_names(cap[4])
  elseif cap[4] == '=' then -- line
    spc, cap[4] = string.match(line, element_line, cap[5]+1)
    cap[4] = convert_line (cap[4] or '')
    cap[4] = convert_names(cap[4])
  else
    cap[4] = ''
  end
  return string.format("%s%s%s '%s' %s{ %s%s", pfx, cap[1], cls, cap[2], spc or '', cap[4], clo)
end

local capf = \i,j,... -> {...}
local function convert_statements (line)
  local cap
  cap = capf( string.find(line, variable) )
  if #cap > 0 then return convert_variable(line, cap) end
  cap = capf( string.find(line, element) )
  if #cap > 0 then return convert_element (line, cap) end
  cap = capf( string.find(line, command) )
  if #cap > 0 then return convert_command (line, cap) end
  return line
end

local function load (_, file_in, file_out)
  assert(is_string(file_in)                     , "invalid input file name")
  assert(is_string(file_out) or is_nil(file_out), "invalid ouput file name")

  env = { seq={}, elm={}, tie={} } -- nam={}, var={} }

  -- load file
  local inf = assert( io.open(file_in) )
  local out = {}
  out[1] = "local MADX = MADX -- local"
  out[2] = "MADX:open_env()\n\n"

  for line in inf:lines() do
    line = convert_comments   (line)
    line = convert_tokens     (line)
    line = convert_statements (line)
    out[#out+1] = line
  end
  for k,v in pairs(env.tie) do
    out[#out+1] = string.format("%s:tie(%s)", k, v)
  end
  out[#out+1] = "\n\nMADX:close_env()"
  inf:close()

  env = nil

  if file_out then -- save file
    local outf = assert( io.open(file_out, "w") )
    for i,s in ipairs(out) do
      outf:write(s, '\n')
  --  outf.write(i, ": ", s, '\n')
    end
  else -- in memory TODO
  end

  collectgarbage()
end

MADX:set_function { load = load }

M.madxload = \inf,outf -> load(nil, inf, outf)

-- end ------------------------------------------------------------------------o
return MAD.utility.defhelp(M) -- todo: per function help -> 'madx'
