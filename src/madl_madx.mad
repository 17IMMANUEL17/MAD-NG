--[=[
 o-----------------------------------------------------------------------------o
 |
 | MADX module
 |
 | Methodical Accelerator Design - Copyright CERN 2015+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide basic compatibility with MADX sequence

 o-----------------------------------------------------------------------------o
]=]

local M = { __help = {} }

-- help -----------------------------------------------------------------------o

M.__help.self = [=[
NAME
  madx for MAD-X compatibility

SYNOPSIS
  local MADX = require "madx"

DESCRIPTION
  This module provide the function loadmadx that read MADX sequence and optics
  files and load then in the MADX global variable. If it does not exist, it will
  create the globla MADX variable as an object and load all elements, constants,
  and math functions compatible with MADX.

RETURN VALUES
  The MADX global variable

EXAMPLES
  local MADX = require "madx"
  MADX:open_env()
  -- inline definition
  MADX:close_env()

SEE ALSO
  element, object
]=]

-- locals ---------------------------------------------------------------------o

local Object, is_number in MAD





local file = arg[1]
assert(file ~= nil, "missing file name")

local function display_head ()
  io.write [[
local abs, sqrt, exp, log, log10, sin, cos, tan, asin, acos, atan,
      sinh, cosh, tanh, ranf, gauss, tgauss, floor, ceil, round,
      frac, erf, erfc, sinc in MAD
local pi, twopi, degrad, raddeg, amu0, emass, mumass, nmass, pmass, clight,
      qelect, hbar, erad, prad in MAD.constant
local sequence, sbend, rbend, quadrupole, sextupole, octupole, multipole,
      solenoid, hkicker, vkicker, kicker, rfcavity, marker, placeholder,
      instrument, monitor, collimator in MAD.element
local tkicker, rcollimator = kicker, collimator -- alias
local MADX = MADX -- local
MADX:open_env()
]]
end

local seq = nil
local env = { __nam={}, __var={}, __elm={}, __seq={} }

local function incr (t,k)
  t[k] = (t[k] or 0) + 1
end

local cmt = { ['//'] = '--', ['/*'] = '--[[', ['*/'] = ']]', }

local function convert_comments (line)
  return string.gsub(line, '([/*][/*])', cmt)
end

local function convert_name (str)
  str = string.lower(string.gsub(str, '([.$])', '_'))
  incr(env.__nam, str)
  return str
end

local function convert_names (str)
  return string.gsub(str, '([%a_][%w%._$]*)', convert_name)
end

local tok = { real='', const='', shared='', REAL='', CONST='', SHARED='' }

local function convert_tokens (line)
  line = string.gsub(line, '(%w+)', tok)
  line = string.gsub(line, '->', '.')
  line = string.gsub(line, '%%', '.')
  return line
end
               --   [1]  [2]             [3]  [4]  [5]  [6]
local variable = "^(%s*)([%a_][%w%._$]*)(%s*)(:?=)(%s*)([^;]*);"

local function convert_variable (line, cap)
  cap[2] = convert_name(cap[2])
  if cap[4] == ':=' then cap[4] = '=\\ ' end
  cap[6] = convert_names(cap[6])
  if string.sub(cap[6],1,1) == '(' then
    cap[6] = '(' .. cap[6] .. ')'
  end
  incr(env.__var, cap[2])
  return table.concat( cap )
end

              --   [1]  [2]                [3]  [4]
local command = "^(%s*)([%a_][%w%._$]*)%s*([,;])()"
local command_attr = "(%s*)([^;]*);"

local function convert_command (line, cap)
  local cmd = convert_name(cap[2])
  local spc
  if cmd == 'endsequence' then
    seq = nil
    return '}'
  end
  if cap[3] == ',' and env.__elm[cmd] ~= nil then -- update
    assert(seq == nil, "invalid update inside sequence definition")
    spc, cap[3] = string.match(line, command_attr, cap[4]+1)
    assert(cap[3], "invalid empty update detected")
    cap[3] = convert_names(cap[3])
    return string.format("%s['%s'] :set %s{ %s }",  env.__elm[cmd], cap[2], spc or '', cap[3])
  else -- command
    line = '-- ' .. line
  end
  return line
end
              --   [1]  [2]                    [3]                [4]  [5]
local element = "^(%s*)([%a_][%w%._$]*)%s*:%s*([%a_][%w%._$]*)%s*([,;])()"
local element_attr = "(%s*)([^;]*);"
local element_from = "from%s*=%s*([%a_][%w%._$]*)"

local function convert_from (str)
  return string.gsub(str, element_from, "from = '%1'")
end

local function convert_element (line, cap)
  local elm = convert_name(cap[2])
  local cls = convert_name(cap[3])
  local spc, clo, pfx
  if cls == 'sequence' then -- sequence
    assert(not seq, "invalid sequence definition inside sequence definition")
    seq, clo, pfx = elm, ',', elm .. ' = '
    env.__seq[elm] = elm
    env.__seq[#env.__seq+1] = elm
  elseif not seq then       -- class
    clo, pfx = ' }', elm .. ' = '
    env.__elm[elm] = cls
  else                      -- element
    clo, pfx = ' },', ''
    env.__elm[elm] = seq
  end
  if cap[4] == ',' then     -- attribute
    spc, cap[4] = string.match(line, element_attr, cap[5]+1)
    cap[4] = convert_from (cap[4] or '')
    cap[4] = convert_names(cap[4])
  else
    cap[4] = ''
  end
  return string.format("%s%s%s '%s' %s{ %s%s", pfx, cap[1], cls, cap[2], spc or '', cap[4], clo)
end

local capf = \i,j,... -> {...}
local function convert_statements (line)
  local cap
  cap = capf( string.find(line, variable) )
  if #cap > 0 then return convert_variable(line, cap) end
  cap = capf( string.find(line, element) )
  if #cap > 0 then return convert_element (line, cap) end
  cap = capf( string.find(line, command) )
  if #cap > 0 then return convert_command (line, cap) end
  return line
end

local ln = 0
display_head()
for line in io.lines(file) do
  ln = ln+1
  line = convert_comments   (line)
  line = convert_tokens     (line)
  line = convert_statements (line)
  io.write(line, '\n')
--  io.write(seq and "S" or "", ln, ": ", line, '\n')
end

if #env.__seq == 2 then
  io.write(string.format("%s:tie(%s)\n", env.__seq[1], env.__seq[2]))
end
io.write "MADX:close_env()\n"
