--[=[
 o-----------------------------------------------------------------------------o
 |
 | Sequence module
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide sequence object to define lattices

 o-----------------------------------------------------------------------------o
]=]

local M = {}

-- module ---------------------------------------------------------------------o

local __help = {}
__help.sequence = [=[
NAME
  sequence -- build sequences

SYNOPSIS
  seq = sequence 'name' { attribute-list, element-list... }

DESCRIPTION
  TODO

RETURN VALUE

EXAMPLE
  see LHC sequences

SEE ALSO
  element.
]=]

__help["sequence: seqedit"] = [=[
Sequence edition:
-----------------
  seqedit:    n/a
  flatten:    n/a
  reflect:    n/a
  endedit:    n/a

  selection: (foreach)
    range=range, flag=flag, pattern=string, class=element, select=predicate

  seq:remove  { selection }
  seq:replace { elements={elem1, elem2, ...}, selection } -- recycle elements
  seq:insert  { elements={elem1, elem2, ...}, selection } -- recycle elements

  seq:dump()  -- to be defined, i.e. should save values, not expressions.
]=]

__help["sequence: indexes, ranges and iterators"] = [=[
Indexes: (index_of)
--------
  return the index in the sequence or nil

  seq:index_of(spos|name|elem, [index|count])
  - spos (number: s-position)
    + spos < 0 means starts from end (i.e. seq.l+num)
    + return the closest index if spos is not found
  - mname (string: mangled name)
    + name                 (absolute and unique)
    + name[count]          (absolute with occurences count)
    + name{count} & index  (relative with occurences count if index is provided)
    + $start or #s or #S (index=1), $end or #e or #E (index=#seq)
  - element (object)
    + element.name         (absolute and unique)
    + element.name & count (absolute with occurences count)

  Inverse method: (name_of)
    seq:name_of(index) returns the mname at index.
    seq:name_of(seq:index_of('mq[10]')) == 'mq[10]'

Ranges: (range_of)
-------
  return the pair of indexes in the sequence or nil

  seq:range_of(arg)
  - start_spos .. stop_spos  (range object)
  - { spos|name|elem, spos|name|elem }
  - "spos|name / spos|name"
  - support for start > stop or missing stop (i.e. stop = start)

Iterators: (iter)
----------
  return an iterator usable by generic for loop

  seq:iter([range], [nturn])
  - iterate through the sequence.
  - if nturn is not specified, nturn=0.
  - if range is not specified
    + if seq.start_at exists, nturn+1 starting at seq.start_at.
    + otherwise from 1 to #seq.
]=]

-- locals ---------------------------------------------------------------------o

local second, bind1st, bind2nd, bind2st                        in MAD.gfunc
local sub, ltrue, lfalse                                       in MAD.operator
local is_iterable, is_callable                                 in MAD.concept
local sequence, marker, flags                                  in MAD.element
local minlen                                                   in MAD.constant
local strsplit, strsplitbra                                    in MAD.utility
local bsearch                                                  in MAD.algorithm
local is_nil, is_boolean, is_number, is_positive, is_string,
      is_table, is_rawtable, is_range, is_element, is_class,
      is_instanceOf                                            in MAD.typeid

local abs, min, max in math
local table_insert, table_remove = table.insert, table.remove

local sequence_mt = getmetatable(sequence)
local var_raw, var_val = sequence.var_raw, sequence.var_val
local get_var, set_var = sequence_mt.__index, sequence_mt.__newindex

-- root object ----------------------------------------------------------------o

-- hidden keys: elem array, (name,index) dict and positions.
local _elem, _eidx, _epos, _spos = {}, {}, {}, {}

-- defined in elements
sequence :set { direction=1, refer='centre', l=0,
                [_elem]={}, [_eidx]={}, [_epos]={}, [_spos]={} }

local function is_sequence(a)
  return is_table(a) and not is_nil(a[_eidx])
end

local function is_orig_sequence(a)
  return is_sequence(a) and not is_nil(a:raw_get(_eidx))
end

-- definitions ----------------------------------------------------------------o

-- forward declarations
local elem_pos

-- hidden key to store array length
local _len = {}

-- special numerical value for elements positions.
local uninitialized = -1e9
local ongoing_init  = -2e9
local maximum_dist  =  2e9 -- to find the closest

-- start and end markers
local mkstart = marker '$start' { at=0 } : set_readonly()
local mkend   = marker '$end'   {      } : set_readonly()

-- sanity checks --------------------------------------------------------------o

local function seq_error (msg, seq, idx, nam)
  error(msg .. " in sequence '"  .. (seq.name or '?')
            .. "' for element '" .. (nam      or '?')
            .. "' at index "     .. (idx      or '?'), 2)
end

local function seq_poserr (typ, seq, idx, pos)
  seq_error(string.format(
    "invalid %s position at s = %.6gm (negative drift %.6gm)",
    typ, seq[_spos][idx], seq[_spos][idx]-pos), seq, idx, seq[idx].name)
end

-- check sequence $start and $stop integrity
local function check_mark (seq)
  local n = #seq
      if seq[1].__id ~= mkstart.__id or seq[1].is_marker ~= true then
    error("invalid sequence first element ($start marker expected)", 2)
  elseif seq[n].__id ~= mkend  .__id or seq[n].is_marker ~= true then
    error("invalid sequence last element ($end marker expected)", 2)
  end
end

-- check sequence spos and elements overlapp
local function check_spos (seq)
--  print('check_spos=', seq.name, #seq, #seq[_elem], #seq[_spos], #seq[_epos])
  for i=1,#seq-1 do
    local ds = seq[_spos][i+1] - (seq[_spos][i]+seq[i].l)
    if ds < -minlen then
      seq_poserr("element", seq, i, seq[_spos][i]-ds)
    end
  end
end

-- check dictionnary of name -> idx
local function check_dict (seq)
  local elem, eidx = seq[_elem], seq[_eidx]
  eidx['#s'], eidx['#e'], eidx['#S'], eidx['#E'] = nil
  for en,ei in pairs(eidx) do        -- name -> index or table of indexes
    if is_number(ei) then
      assert(elem[ei].name == en     , "unexpected corrupted dictionnary")
    elseif is_table(ei) then
      assert(elem[ei[1]].name == en  , "unexpected corrupted dictionnary")
      for i=2,ei[_len] do
        assert(ei[i-1] < ei[i]       , "unexpected corrupted dictionnary")
        assert(elem[ei[i]].name == en, "unexpected corrupted dictionnary")
      end
    else
      error("unexpected corrupted dictionnary")
    end
  end
end

--[=[
local function dumpseq (seq)
  local fmt = MAD.option.format
  MAD.option.format = "%.5g"
  print()
  print('sequence:', seq.name, 'l=', seq.l)
  print('i', 'name', 'L', 'S (s)', 'S (e)')
  seq:foreach \e,i -> print(i, e.name, e.l, seq[_spos][i], seq[_epos][i])
  MAD.option.format = fmt
end
]=]

-- helper for mangled names and elements indexes (same as mtable) -------------o

-- get index from signed index (direct)
local function index_of_idx (seq, idx)
  assert(is_number(idx), "invalid argument #2 (index expected)")
  local n = #seq
  if idx < 0 then idx = n+idx+1 end -- reflect
  if idx < 1 or idx > n then return nil end
  return idx
end

-- get index from s-position (binary)
local function index_of_num (seq, num)
  assert(is_number(num), "invalid argument #2 (number expected)")
  if num < 0 then num = seq.l+num end -- reflect
  if num < 0 or num > seq.l then return nil end
  return bsearch(seq[_spos], num)
end

-- get index from name [with count] (direct)
local function index_of_cnam (seq, nam, cnt_)
  local ei = seq[_eidx][nam]
  if is_table(ei) then
    cnt_ = cnt_ or 1
    assert(is_number(cnt_), "invalid argument #3 (count expected)")
    if cnt_ < 0 then cnt_ = ei[_len]+cnt_+1 end -- reflect
    return ei[cnt_]
  end
  return ei
end

-- get index from name [with relative count] (linear)
local function index_of_rnam (seq, nam, cnt_, idx_)
  cnt_ = cnt_ or 1
  assert(is_number(cnt_), "invalid argument #3 (count expected)")
  local ei = seq[_eidx][nam]
  if is_nil(ei) then return nil end
  idx_ = index_of_idx(seq, idx_ or 1)
  if is_nil(idx_) then return nil end
  if is_number(ei) then
    return (cnt_ ==  1 and ei >= idx_ and ei) or
           (cnt_ == -1 and ei <= idx_ and ei) or nil
  end
  if cnt_ > 0 then
    for i=1,ei[_len] do
      if ei[i] >= idx_ then return ei[i+cnt_-1] end
    end
  elseif cnt_ < 0 then
    for i=1,ei[_len] do
      if ei[i] >  idx_ then return ei[i+cnt_  ] end
    end
  end
  return nil
end

-- get index from [mangled] name (direct or linear)
local function index_of_mnam (seq, nam, idx_)
  assert(is_string(nam), "invalid argument #2 (string expected)")
  local nam, cnt, bra = strsplitbra(nam)
  cnt = tonumber(cnt) or cnt
  if is_nil(idx_) or bra ~= '{' then
    return index_of_cnam(seq, nam, cnt      ), bra
  else
    return index_of_rnam(seq, nam, cnt, idx_), bra
  end
end

local function index_of_nam (seq, nam, idx_)
  return (index_of_mnam(seq, nam, idx_))
end

-- get index from element (linear)
local function index_of_elm (seq, elm, idx_)
  assert(is_element(elm), "invalid argument #2 (element expected)")
  local nam = elm.name
  local ei = seq[_eidx][nam]
  if is_nil(ei) then return nil end
  idx_ = idx_ and index_of_idx(seq, idx_) or 1
  local elem = seq[_elem]
  if is_number(ei) then
    return ei >= idx_ and elem[ei] == elm and ei or nil
  end
  for i=1,ei[_len] do
    local ii = ei[i]
    if ii >= idx_ and elem[ii] == elm then return ii end
  end
  return nil
end

-- get [mangled] name from element (linear)
local function name_of_elm (seq, elm, idx_)
  assert(is_element(elm), "invalid argument #2 (element expected)")
  local nam = elm.name
  local ei = seq[_eidx][nam]
  if is_nil(ei) then return nil end
  idx_ = index_of_idx(seq, idx_ or 1)
  local elem = seq[_elem]
  if is_number(ei) then
    return ei >= idx_ and elem[ei] == elm and nam or nil
  end
  for i=1,ei[_len] do
    local ii = ei[i]
    if ii >= idx_ and elem[ii] == elm then
      return string.format("%s[%d]", nam, i)
    end
  end
  return nil
end

-- get [mangled] name from index (linear)
local function name_of_idx (seq, idx)
  idx = index_of_idx(seq, idx)
  if is_nil(idx) then return nil end
  local nam = seq[_elem][idx].name
  local ei = seq[_eidx][nam]
  if is_number(ei) then
    assert(ei == idx, "unexpected corrupted dictionnary")
    return nam
  end
  for i=1,ei[_len] do
    if ei[i] == idx then
      return string.format("%s[%d]", nam, i)
    end
  end
  error("unexpected corrupted dictionnary")
end

-- position helpers -----------------------------------------------------------o

-- hidden keys for temporaries of 'from' lookup
local _lastfrom, _lastfrompos = {}, {}

-- return e-position of 'from', memoize result if count is not relative
local function from_epos (seq, from, idx)
  if rawget(seq, _lastfrom) ~= from then             -- memoized?
    local idx, bra = index_of_mnam(seq, from, idx)
    if is_nil(idx) then                              -- not found
      seq_error("invalid from of '" .. from .. "'", seq)
    end
    rawset(seq, _lastfrompos, second(elem_pos(seq, idx)))
    if bra ~= '{'
    then rawset(seq, _lastfrom, from)                -- not relative: memoize
    else rawset(seq, _lastfrom, nil )                -- relative: do not memoize
    end
  end
  return rawget(seq, _lastfrompos)                   -- epos
end

-- return e-position of 'refpos'
local function refpos_epos (seq)
  local rpos = seq.refpos
  if is_nil(rpos) then return 0 end
  return from_epos(seq, rpos)
end

-- forward index
-- return (#elm-1)+1 because seq[idx] == sseq[2] (see copy_sequ and sequ_pos).
local function fidx (elm)
  return is_sequence(elm) and #elm or 1
end

-- return s-position of 'from'
local function from_pos (seq, elm, idx)
  local pos  = elm.at or 0
  local from = elm.from or elm.at and 'start' or 'prev'

      if from == 'start'    then return pos
  elseif from == 'prev'     then return pos + elem_pos(seq,idx-1)+seq[_elem][idx-1].l
  elseif from == 'next'     then return pos + second(elem_pos(seq,idx+fidx(elm)))
  elseif from == 'end'      then return seq.l - pos
  elseif from == 'selected' then return pos + elem_pos(seq,idx)
  else                           return pos + from_epos(seq,from,idx)
  end
end

-- return s-position of 'refer'
local function refer_pos (seq, elm, idx)
  local refer
  if is_sequence(elm)
  then refer = elm.refpos and 'refpos' or seq.refer
  else refer = elm.refer or seq.refer
  end
      if refer == 'entry'  then return 0
  elseif refer == 'centre' then return elm.l/2
  elseif refer == 'exit'   then return elm.l
  elseif refer == 'refpos' then return refpos_epos(elm)
  else seq_error("invalid refer to '" .. refer .. "'", seq, idx, elm)
  end
end

-- build positions ------------------------------------------------------------o

-- set s-positions at index or return element s-positions
-- already declared for forward use, must not be local
function elem_pos (seq, idx, elm_)
  local spos = seq[_spos][idx]
  if is_nil(spos) then
    seq_error("invalid index or reference detected", seq, idx, elm_)
  elseif is_nil(elm_) then
    if spos >= 0 then
      return spos, seq[_epos][idx]
    elseif spos == ongoing_init then
      seq_error("cycling dependencies detected", seq, idx)
    elseif spos ~= uninitialized then
      seq_error("corrupted s-position detected", seq, idx)
    end
    seq[_spos][idx] = ongoing_init
  end

  local elm  = elm_ or seq[_elem][idx]
  local epos = from_pos (seq, elm, idx)
  local rpos = refer_pos(seq, elm, idx)
  spos = epos - rpos

  if is_nil(elm_) then
    seq[_spos][idx] = spos
    seq[_epos][idx] = epos
  end
  return spos, epos
end

-- set s-positions of elements from their sub sequence
local function sequ_pos (seq, sseq, idx, dir)
  check_mark(sseq)
  local elem, spos, epos = seq[_elem], seq[_spos], seq[_epos]
  local pos = elem_pos(seq, idx, sseq)    -- shift by subsequence refpos

  if seq.direction ~= sseq.direction then -- changedir patch
    spos[idx] = sseq[_spos][1] + pos
    epos[idx] = sseq[_epos][1] + pos
    idx = idx + 1
  end

  local n = #sseq
  if dir > 0 then
    for i=2,n-1 do
      spos[idx-2+i] = sseq[_spos][i] + pos
      epos[idx-2+i] = sseq[_epos][i] + pos
      assert(elem[idx-2+i] == sseq[i], "unexpected corrupted flat sequence")
    end
  else
    local l = sseq.l
    for i=2,n-1 do
      local sp, el = sseq[_spos][n+1-i], sseq[n+1-i].l
      spos[idx-2+i] = l - (sp + el                            ) + pos
      epos[idx-2+i] = l - (sp + el - (sseq[_epos][n+1-i] - sp)) + pos
      assert(elem[idx-2+i] == sseq[n+1-i], "unexpected corrupted flat sequence")
    end
  end

  if seq.direction ~= sseq.direction then -- changedir patch
    spos[idx+n] = sseq[_spos][n] + pos
    epos[idx+n] = sseq[_epos][n] + pos
  end
end

-- compute elements positions
local function build_pos (seq, sref)
  local elem, spos, epos = seq[_elem], seq[_spos], seq[_epos]
  local n, idx, pos = #elem, 1, 0
  sref = sref or {}
  for i=1,n do
    spos[i], epos[i] = uninitialized, uninitialized
  end
  while idx <= n do
    local sseq = sref[idx]
    if is_nil(sseq) then     -- element
      elem_pos(seq, idx)
      if pos-minlen > spos[idx] then
        seq_poserr('element', seq, idx, pos)
      end
      pos = spos[idx] + elem[idx].l
      idx = idx + 1
    else                     -- subsequence
      sequ_pos(seq, sseq, idx, sref.sdir[idx])
      if pos-minlen > spos[idx] then
        seq_poserr('subsequence', seq, idx, pos)
      end
      pos = spos[idx] - sseq[_spos][2] + sseq.l
      idx = idx + #sseq-2
    end
  end
  assert(n == idx-1, "unexpected corrupted flat sequence")

  -- adjust sequence length or end marker position
  local len = spos[n]
  if   seq.l < len
  then seq.l = len
  else spos[n], epos[n] = seq.l, seq.l
  end
end

-- flatten sequence -----------------------------------------------------------o

-- copy sub sequence
local function copy_sequ (seq, flat, sref, idx, dir)
  check_mark(seq)
  local n = #seq
  if n <= 2 then return idx end

  sref[idx], sref.sdir[idx] = seq, dir -- link subsequence

  if sref.dir ~= seq.direction then -- insert changedir patch
    idx, flat[idx] = idx+1, changedir(seq.name, {})
  end

  if dir > 0 then
    for i=2,n-1 do flat[idx-2+i] = seq[i] end
  else
    for i=2,n-1 do flat[idx-2+i] = seq[n+1-i] end
  end

  if sref.dir ~= seq.direction then
    idx, flat[idx-2+n] = idx+1, flat[idx-1]:select(shared) -- share patch
  end
  return idx-2+n
end

-- flatten lines and subsequence
local function flatten_line (line, flat, sref, idx, dir)
  local n, rep = #line, (line.__rep or 1) * dir
  if n == 0 then return idx end

  local start, stop, step
  if rep < 0
  then rep, start, stop, step = -rep, n, 1, -1
  else rep, start, stop, step =  rep, 1, n,  1
  end

  for i=1,rep do
  for j=start,stop,step do
    local elm = line[j]
    if not (is_element(elm) or is_rawtable(elm)) then
      seq_error("invalid element detected", line, j)
    elseif elm.is_bline == true or is_rawtable(elm) then
      idx = flatten_line(elm, flat, sref, idx, step)
    elseif not is_nil(sref) and is_sequence(elm) then
      idx = copy_sequ   (elm, flat, sref, idx, step)
    else -- other elements
      idx, flat[idx] = idx+1, elm
    end
  end end
  return idx
end

-- flatten sequence
local function flatten_sequ (seq, flat, sref)
  local n, idx = seq:raw_len(), 2
  flat[1] = mkstart {}
  for i=1,n do
    local elm = seq:raw_get(i)
    if not (is_element(elm) or is_rawtable(elm)) then
      seq_error("invalid element detected", seq, i)
    elseif elm.is_bline == true or is_rawtable(elm) then
      idx = flatten_line(elm, flat, sref, idx, 1)
    elseif is_sequence(elm) then
      idx = copy_sequ   (elm, flat, sref, idx, 1)
    else -- other elements
      idx, flat[idx] = idx+1, elm
    end
  end
  flat[idx] = mkend {}
  assert(n <= idx, "unexpected corrupted flat sequence")
end

-- build sequence -------------------------------------------------------------o

-- build dictionnary name -> idx
local function build_index (seq)    -- must be very fast
  local ei = seq[_eidx]
  table.clear(ei)                   -- reuse main storage
  for idx,elm in ipairs(seq[_elem]) do
    local nam = elm.name
    local val = ei[nam]
    if is_nil(val) then             -- none: name -> idx
      ei[nam] = idx
    elseif is_number(val) then      -- one : create array
      ei[nam] = {val, idx, [_len]=2 }
    else                            -- many: append
      local len = val[_len]+1
      val[len], val[_len] = idx, len
    end
  end
end

-- finalize sequence
local function finish_sequ (seq)
  -- clear memoization
  rawset(seq, _lastfrom   , nil)
  rawset(seq, _lastfrompos, nil)

  -- sanity checks
  if MAD.option.debug then
    check_mark(seq)
    check_spos(seq)
    check_dict(seq) -- remove $start/$end marker aliases
  end

  -- $start/$end markers aliases
  seq[_eidx]['#s'], seq[_eidx]['#S'] = 1, 1
  seq[_eidx]['#e'], seq[_eidx]['#E'] = #seq, #seq
end

-- sequence init (build)
local function sequence_init (seq)
  local n = seq:raw_len()
  if n == 0 then return seq end -- empty

  local flat, sref = table.new(n+2,0), { dir=seq.direction, sdir={} }
  flatten_sequ(seq, flat, sref)
  seq:clear_array()

  seq[_elem], seq[_eidx] = flat, table.new(#flat,0)
  build_index(seq, flat)

  seq[_epos], seq[_spos] = table.new(#seq,0), table.new(#seq,0)
  build_pos(seq, sref)

  finish_sequ(seq)
  return seq
end

-- copy -----------------------------------------------------------------------o

local function sequence_copy (seq, name_)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  local cpy = seq:copy(name_)
  if not is_orig_sequence(seq) then return cpy end

  local n, elem1, epos1, spos1 = #seq, seq[_elem], seq[_epos], seq[_spos]
  local elem2, epos2, spos2 = table.new(n,0), table.new(n,0), table.new(n,0)
  for i=1,n do
    elem2[i], epos2[i], spos2[i] = elem1[i], epos1[i], spos1[i]
  end
  cpy[_elem], cpy[_epos], cpy[_spos], cpy[_eidx] = elem2, epos2, spos2, table.new(0,n)
  build_index(cpy)
  finish_sequ(cpy)
  return cpy
end

-- sequence metamethods -------------------------------------------------------o

-- dict count proxy
local _dct = {}

local function dct_iter (s, i)
  i = i + 1
  local ei = s[_dct][i]
  if ei then return i, s[_elem][ei] end
end

local dct_mt = {
  __len       =\s   -> s[_dct][_len],
  __index     =\s,i -> s[_elem][s[_dct][i]],
  __pairs     =\s   -> dct_iter, s, 0,
  __ipairs    =\s   -> dct_iter, s, 0,
  __newindex := error("forbidden write access to counts", 2),
}

-- iterator over elements
local function ipairs_mm (seq)
  return ipairs(seq[_elem])
end

-- number of elements
local function len_mm (seq)
  return #seq[_elem]
end

-- read access precedence: element index, variable key, element name.
local function index_mm (seq, key)
  -- element index
  if is_number(key) then
    return seq[_elem][key]
  end
  -- variable
  local var = var_raw(seq, key)
  if var then
    return var_val(seq, key, var)
  end
  -- element name
  local idx = seq[_eidx][key]
  if is_table(idx) then
    return setmetatable({[_dct]=idx, [_elem]=seq[_elem]}, dct_mt) -- dict proxy
  end
  return seq[_elem][idx]                                          -- elem or nil
end

local function newindex_mm (seq, key, val)
  -- element index or name
  if is_number(key) or seq[_eidx][key] then
    error("invalid sequence write access (use replace method)")
  end
  -- variable
  set_var(seq, key, val)
end

-- methods (readonly) ---------------------------------------------------------o

local function name_of (seq, a, ref_)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
      if is_number (a) then return name_of_idx(seq, a)
  elseif is_element(a) then return name_of_elm(seq, a, ref_)
  end
  error("invalid argument #2 (number or element expected)")
end

local function index_of (seq, a, ref_)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
      if is_number (a) then return index_of_num(seq, a)
  elseif is_string (a) then return index_of_nam(seq, a, ref_)
  elseif is_element(a) then return index_of_elm(seq, a, ref_)
  end
  error("invalid argument #2 (number, string or element expected)")
end

local function range_of (seq, rng, ref_)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  local start, stop
  if is_number(rng) then
    start = index_of_idx(seq, rng)
    return start, start
  elseif is_string(rng) then
    local s1, s2 = strsplit(rng, "/")
    start, stop = tonumber(s1) or s1, tonumber(s2) or s2
  elseif is_table(rng) then
    start, stop = rng[1], rng[2]
  elseif is_range(rng) then
    start, stop = rng:bounds()
  else error("invalid argument #2 (index, string, range or table expected)")
  end
  start = index_of(seq, start, ref_)
  stop  = stop and index_of(seq, stop, ref_ or start) or start
  return start, stop
end

local function length_of (seq, rng_, ntrn_)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  local siz = rng_ and 1-sub(range_of(seq, rng_)) or 0
  return siz + #seq * ((ntrn_ or 0) + (siz <= 0 and 1 or 0))
end

-- functional methods ---------------------------------------------------------o

--[=[
programming model:
seq:foreach {
  action=function,
  range=range,
  flag=flag, pattern=string, class=element, select=predicate -- AND'ed selections
  default=nil/'none'
}
seq:foreach(action, range, select, not)
seq:select/deselect(flag, range, select, not)
seq:filter(range, select, default)
without any selection criterium:
  not ~= true and default ~= 'none' -> select all
  not == true or  default == 'none' -> select nothing
]=]

local pcls   = is_instanceOf
local psel   = marker.is_selected
local pnam   = \e,pat -> not is_nil(string.match(e.name, pat))
local pand   = \p,p2,e,i -> p(e,i) and p2(e,i)
local ptrue  = \p,_ ,e,i -> p(e,i) and true
local pfalse = \p,_ ,e,i -> p(e,i) or false

local function foreach (seq, act, rng_, sel_, not_) -- action, range, selection, default
  local f, p
  if is_nil(rng_) and is_rawtable(act) then
    f, rng_ = act.action, act     -- extract action + right shift
  else
    f = act
  end
  if is_nil(sel_) and is_rawtable(rng_) and is_nil(rng_[1]) then
    rng_, sel_ = rng_.range, rng_ -- extract range  + right shift
  end
  if is_nil(not_) and is_boolean(sel_) then
    not_, sel_ = sel_             --                  right shift
  end

  if is_rawtable(sel_) then       -- logically and'ed selections
    if is_nil(not_) and (sel._default == 'none' or sel._default == true) then
      not_ = true
    end
    local op = not_ ~= true and ptrue or pfalse
    if sel_.select then
      assert(is_callable(sel_.select), "invalid select (callable expected)")
      op, p = pand, bind2st(op, sel_.select, p)
    end
    if sel_.class then
      assert(is_element(sel_.class), "invalid class (element expected)")
      op, p = pand, bind2st(op, bind2nd(pcls, sel_.class), p)
    end
    if sel_.pattern then
      assert(is_string(sel_.pattern), "invalid pattern (string expected)")
      op, p = pand, bind2st(op, bind2nd(pnam, sel_.pattern), p)
    end
    if sel_.flag then
      assert(is_number(sel_.flag), "invalid flag (number expected)")
      op, p = pand, bind2st(op, bind2nd(psel, sel_.flag), p)
    end
  elseif not is_nil(sel_) then    -- build the selection
    p = is_number  (sel_) and bind2nd(psel, sel_) or
        is_string  (sel_) and bind2nd(pnam, sel_) or
        is_element (sel_) and bind2nd(pcls, sel_) or
        is_callable(sel_) and sel_                or nil
  end
  if is_nil(p) then p = not_ ~= true and ltrue or lfalse end

  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  assert(is_callable(f)  , "invalid argument #2 (callable expected)")
  assert(is_callable(p)  , "invalid argument #4 (callable expected)")

  if p ~= lfalse then
    for idx,elm in seq:iter(rng_) do
      if p(elm,idx) then f(elm,idx) end
    end
  end
  return seq
end

local do_select = marker.select

local function select (seq, flg_, rng_, sel_, not_)
  if is_rawtable(flg_) and is_nil(rng_) and is_nil(sel_) then
    rng_, flg_ = flg_ -- right shift
  end
  local f = bind2nd(do_select, flg_)
  return seq:foreach(f, rng_, sel_, not_)
end

local do_deselect = marker.deselect

local function deselect (seq, flg_, rng_, sel_, not_)
  if is_rawtable(flg_) and is_nil(rng_) and is_nil(sel_) then
    rng_, flg_ = flg_ -- right shift
  end
  local f = bind2nd(do_deselect, flg_)
  return seq:foreach(f, rng_, sel_, not_)
end

local do_filter = \elm,idx,e,i => local j = #elm+1 ; elm[j],idx[j] = e,i end

local function filter (seq, rng_, sel_, not_)
  local elm, idx = {}, {}
  local f = bind2st(do_filter, elm, idx)
  seq:foreach(f, rng_, sel_, not_)
  return elm, idx
end

-- methods (R/W, update dict) -------------------------------------------------o

local function remove (seq, rng_, sel_)
  assert(is_orig_sequence(seq), "invalid argument #1 (original sequence expected)")

  -- collect elements and indexes to remove
  local elm_r, idx_r = filter(seq, rng_, sel_, true)
  local nr = #idx_r
  if nr == 0 then return end
  assert(idx_r[nr]-idx_r[1] >= nr-1, "invalid range, indexes must be increasing")

  -- remove elements by decreasing indexes
  local elem, spos, epos = seq[_elem], seq[_spos], seq[_epos]
  for i=nr,1,-1 do
    local ii = idx_r[i]
    table_remove(elem, ii)
    table_remove(spos, ii)
    table_remove(epos, ii)
  end

  -- rebuild dict
  build_index(seq)
  finish_sequ(seq)
  return elm_r, idx_r
end

local function replace (seq, elm, rng_, sel_)
  assert(is_orig_sequence(seq), "invalid argument #1 (original sequence expected)")

  if is_rawtable(elm) and is_nil(rng_) and is_nil(sel_) then
    rng_, elm = elm, elm.elements -- extract elements + right shift
  end

  if is_element(elm) then elm = {elm} end
  assert(is_rawtable(elm), "invalid argument #2 (elements list expected)")
  local ne = #elm
  if ne == 0 then return end

  -- check elements
  for i=1,ne do
    if is_element(elm[i]) and not is_sequence(elm[i]) then
      error("invalid element '"..(elm[i].name or '?').."' replacement at index "..i)
    end
  end

  -- collect elements and indexes to replace
  local elm_r, idx_r = filter(seq, rng_, sel_, true)
  local nr = #idx_r
  if nr == 0 then return end
  assert(idx_r[nr]-idx_r[1] >= nr-1, "invalid range, indexes must be increasing")

  -- replace elements
  local elem, spos, epos = seq[_elem], seq[_spos], seq[_epos]
  for i=1,nr do
    local ii, ie = idx_r[i], (i-1)%ne+1   -- recycle list of elements
    elem[ii], spos[ii], epos[ii] = elm[ie], uninitialized, uninitialized
    elem_pos(seq, ii) -- recompute the positions
  end

  -- rebuild dict
  build_index(seq)
  finish_sequ(seq)
  return elm_r, idx_r
end

local function insert (seq, elm, rng_, sel_)
  assert(is_orig_sequence(seq), "invalid argument #1 (original sequence expected)")

  if is_rawtable(elm) and is_nil(rng_) and is_nil(sel_) then
    rng_, elm = elm, elm.elements -- extract elements + right shift
  end

  if is_element(elm) then elm = {elm} end
  assert(is_rawtable(elm), "invalid argument #2 (elements list expected)")
  local ne = #elm
  if ne == 0 then return end

  -- collect reference indexes where to insert
  local _, idx_r = filter(seq, rng_, sel_, true)
  local nr = #idx_r
  assert(idx_r[nr]-idx_r[1] >= nr-1, "invalid range, indexes must be increasing")

  -- collect elements and subsequences to insert
  local ins = table.new(ne,0) -- no sref -> keep subsequence as-is
  flatten_line(elm, ins, nil, 1, 1)
  elm, ne, ins = ins, #ins -- update

  -- precompute number of elements with from='selected'
  local ns = 0
  for i=1,ne do
    if is_element(elm[i]) and not is_sequence(elm[i]) then
      error("invalid element '"..(elm[i].name or '?').."' insertion at index "..i)
    end
    if elm[i].from == 'selected' then ns = ns + 1 end
  end

  -- precompute position of each element
  local i, ni = 1, ne-ns + ns*nr
  local spos, epos = table.new(ni,0), table.new(ni,0)
  for ie=1,ne do
    if elm[ie].from ~= 'selected' then
      elm[i], spos[i], epos[i] = elm[ie], elem_pos(seq, 1        , elm[ie])
      i = i + 1
    else for ir=1,nr do
      elm[i], spos[i], epos[i] = elm[ie], elem_pos(seq, idx_r[ir], elm[ie])
      i = i + 1
    end end
  end
  ne = i

  -- insert elements
  for ie=1,ne do
    local idx = bsearch(seq[_spos], spos[ie], 2, #seq[_spos]-1)
    if is_sequence(elm[ie]) then
      local sseq = elm[ie]
      for j=#sseq-1,2,-1 do -- see sequ_pos
        table_insert(seq[_elem], idx, sseq[j])
        table_insert(seq[_spos], idx, sseq:spos(j) + spos[ie])
        table_insert(seq[_epos], idx, sseq:epos(j) + spos[ie])
      end
    else
      table_insert(seq[_elem], idx, elm [ie])
      table_insert(seq[_spos], idx, spos[ie])
      table_insert(seq[_epos], idx, epos[ie])
    end
  end

  -- rebuild dict
  build_index(seq)
  finish_sequ(seq)
  return seq
end

-- flags ----------------------------------------------------------------------o

local function cycle (seq, elm)
  assert(is_sequence(seq)  , "invalid argument #1 (sequence expected)")
  assert(index_of(seq, elm), "invalid argument #2 (reference expected)")
  seq.start_at = elm
  return seq
end

local function share (seq1, seq2)
  assert(is_orig_sequence(seq1), "invalid argument #1 (original sequence expected)")
  assert(is_orig_sequence(seq2), "invalid argument #2 (original sequence expected)")
  check_mark(seq1) check_mark(seq2)
  local elem1, eidx1 = seq1[_elem], seq1[_eidx]
  local elem2, eidx2 = seq2[_elem], seq2[_eidx]
  for i=2,#elem1-1 do
    local nam = elem1[i].name   -- share by (unique) name
    if eidx2[nam] then          -- element name found in seq2
      local i1, i2 = eidx1[nam], eidx2[nam]
      -- ensure that elements are unique in both sequences
      assert(is_number(i1) and is_number(i2), "invalid shared element (must be unique)")
      local e1, e2 = elem1[i1], elem2[i2]
      assert(e1.name == nam and e2.name == nam, "unexpected corrupted dictionnary")
      -- make Y inheritance using e1 as reference and discard e2 (pos are unchanged)
      local c1 = e1 { at := e1.at, from := e1.from, refpos := e1.refpos }
      local c2 = e1 { at := e2.at, from := e2.from, refpos := e2.refpos }
      -- check compatibility of positions
      local s0, s1, s2 = seq2[_spos][i2], elem_pos(seq2,i2,c2), elem_pos(seq2,i2,e2)
      assert(s0 == s1 and s0 == s2, "incompatible shared elements (spos differs)")
      -- update arrays, add shared flag
      elem1[i1] = c1:set_flag(flags.shared)
      elem2[i2] = c2:set_flag(flags.shared)
    end
  end
  finish_sequ(seq1) finish_sequ(seq2)
  return seq1, seq2
end

local function unique (seq)
  assert(is_orig_sequence(seq), "invalid argument #1 (original sequence expected)")
  local elem, eidx = seq[_elem], seq[_eidx]
  local lst = table.new(0, #elem)
  for _,elm in ipairs(elem) do
    lst[elm] = (lst[elm] or 0) + 1
  end
  for elm,cnt in pairs(lst) do
    if cnt > 1 then
      local ei = eidx[elm.name]
      for i=1,cnt do
        local idx = index_of_elm(seq, elm)
        assert(elem[idx] == elm, "unexpected corrupted dictionnary")
        -- replace by a child
        elem[idx] = elm {} :set_flag(flags.shared)
      end
      assert(is_nil(index_of_elm(seq, elm)), "unexpected corrupted dictionnary")
    end
  end
  finish_sequ(seq)
  return seq
end

local function unique_name (seq, fmt_) -- to unify with unique
  assert(is_orig_sequence(seq), "invalid argument #1 (original sequence expected)")
  local fmt = fmt_ or "%s:%d"
  if is_string(fmt) then fmt = bind1st(string.format, fmt) end
  assert(is_callable(fmt), "invalid argument #2 (callable expected)")
  local elem, eidx, lst = seq[_elem], seq[_eidx], table.new(0,10)
  for en,ei in pairs(eidx) do
    if is_table(ei) then
      table.clear(lst)
      for i=1,ei[_len] do
        local elm, nam = elem[ei[i]], fmt(en,i)
        if not is_nil(lst[elm]) then
          error("cannot rename element '"..nam.."' (not unique)")
        end
        if not is_nil(eidx[nam]) then
          error("cannot rename element '"..nam.."' (mangled name exists)")
        end
        eidx[nam], elem[ei[1]].__id = ei[i], nam -- rename unique element
      end
      eidx[en] = nil
    end
  end
  finish_sequ(seq)
  return seq
end

-- flags ----------------------------------------------------------------------o

local _flgs = {} -- hidden key

local function save_flags (seq)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  local n = #seq
  local flgs = table.new(n,0)
  for i=1,n do flgs[i] = seq[i]:get_flags() end
  if is_nil(seq[_flgs]) then seq[_flgs] = {} end
  seq[_flgs][#seq[_flgs]+1] = flgs
end

local function drop_flags (seq)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  assert(not (is_nil(seq[_flgs]) or #seq[_flgs] == 0), "saved flags not found")
  seq[_flgs][#seq[_flgs]] = nil
end

local function restore_flags (seq)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  assert(not (is_nil(seq[_flgs]) or #seq[_flgs] == 0), "saved flags not found")
  local flgs = seq[_flgs][#seq[_flgs]]
  for i=1,#seq do seq[i]:set_flags(flgs[i]) end
  seq[_flgs][#seq[_flgs]] = nil
end

-- iterators ------------------------------------------------------------------o

local function seqfwditer (state, i)
  if i == state.stop then
    if state.turn == 0 then return nil end
    state.turn = state.turn-1
  end
  if i < state.n then
    i = i+1
  else
    i, state.soff = 1, state.soff+state.l
  end
  return i, state.elem[i], state.spos[i]+state.soff
end

local function mkfwditer (seq, start, stop, nturn)
  local elem, spos = seq[_elem], seq[_spos]
  if start == stop+1 then nturn = nturn+1 end
  return seqfwditer, { elem=elem, spos=spos, soff=-spos[start],
                       l=seq.l, n=#seq, stop=stop, turn=nturn }, start-1
end

local function seqbwditer (state, i)
  if i == state.stop then
    if state.turn == 0 then return nil end
    state.turn = state.turn-1
  end
  if i > 1 then
    i = i-1
  else
    i, state.soff = state.n, state.soff-state.l
  end
  return i, state.elem[i], state.spos[i]+state.elem[i].l-state.soff
end

local function mkbwditer (seq, start, stop, nturn)
  local elem, spos = seq[_elem], seq[_spos]
  if start == stop-1 then nturn = nturn+1 end
  return seqbwditer, { elem=elem, spos=spos, soff=spos[start]+elem[start].l,
                       l=seq.l, n=#seq, stop=stop, turn=nturn}, start+1
end

local function fwditer (seq, rng_, ntrn_)
  local nturn = ntrn_ or 0
  assert(is_sequence(seq)            , "invalid argument #1 (sequence expected)")
  assert(is_number(nturn) and nturn >= 0,"invalid argument #3 (number expected)")
  local start, stop
  if is_nil(rng_) then
    if is_nil(seq.start_at) then
      start, stop = 1, #seq
    else
      start = assert(index_of(seq, seq.start_at), "invalid cycle reference")
      stop  = start == 1 and #seq or start-1
    end
  else
    start, stop = seq:range_of(rng_)
    assert(is_number(start), "invalid range start")
    assert(is_number(stop ), "invalid range stop" )
  end
  return mkfwditer(seq, start, stop, nturn)
end

local function bwditer (seq, rng_, ntrn_)
  local nturn = ntrn_ or 0
  assert(is_sequence(seq)            , "invalid argument #1 (sequence expected)")
  assert(is_number(nturn) and nturn >= 0,"invalid argument #3 (number expected)")
  local start, stop
  if is_nil(rng_) then
    if is_nil(seq.start_at) then
      start, stop = #seq, 1
    else
      start = assert(index_of(seq, seq.start_at), "invalid cycle reference")
      stop  = start == #seq and 1 or start+1
    end
  else
    start, stop = seq:range_of(rng_)
    assert(is_number(start), "invalid range start")
    assert(is_number(stop ), "invalid range stop" )
  end
  return mkbwditer(seq, start, stop, nturn)
end

local function iter (seq, rng_, ntrn_, dir_)
  local dir = dir_ or 1
  assert(is_number(dir), "invalid argument #4 (number expected)")
  if dir ==  1 then return fwditer(seq, rng_, ntrn_) end
  if dir == -1 then return bwditer(seq, rng_, ntrn_) end
  error("invalid argument #4 (direction number expected)")
end

-- env ------------------------------------------------------------------------o

MAD.element.sequence            = sequence
MAD.typeid.is_sequence          = is_sequence
MAD.typeid.is_original_sequence = is_orig_sequence

-- members --------------------------------------------------------------------o

sequence :set_functions {
  elem          = \s,i -> s[_elem][i],
  spos          = \s,i -> s[_spos][i],
  epos          = \s,i -> s[_epos][i],

  name_of       = name_of,
  index_of      = index_of,
  range_of      = range_of,
  length_of     = length_of,

  foreach       = foreach,
  select        = select,
  deselect      = deselect,
  filter        = filter,

  remove        = remove,
  replace       = replace,
  insert        = insert,

  cycle         = cycle,
  share         = share,
  unique        = unique,

  iter          = iter,
  copy          = sequence_copy,

  save_flags    = save_flags,
  drop_flags    = drop_flags,
  restore_flags = restore_flags,

  -- disabled methods
  is_selected  := error("invalid sequence operation", 2),

} : set_metamethods ({
  __len      = len_mm,
  __index    = index_mm,
  __newindex = newindex_mm,
  __ipairs   = ipairs_mm,

  __copy     = sequence_copy,
  __init     = sequence_init,
}, true) :set_readonly()

-- end -------------------------------------------------------------------------
return {
  sequence = sequence,
  __help   = __help,
}

--[=[
SEQUENCE DISPLAY
local function show_fields(t, lst)
  local a, k, s
  lst = lst or sequence_fields
  for _,v in ipairs(lst) do
    if is_list(v) then k, s = v[1], v[2] else k, s = v, v end
    a = t[k]
    if a then io.write(', ', s, '= ', tostring(a)) end
  end
end

function M:show(disp)
  io.write("sequence '", self.name,"' { ")
  show_list(self, disp)
  io.write(' }\n')
  for _,v in ipairs(self) do v:show(disp) end
  io.write('endsequence\n')
end

function M:show_madx(disp)
  io.write("'", self.name, "': sequence, ")
  show_list(self, disp)
  io.write(';\n')
  for _,v in ipairs(self) do v:show_madx(disp) end
  io.write('endsequence;\n')
end
--]=]
