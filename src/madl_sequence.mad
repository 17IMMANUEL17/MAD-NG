--[=[
 o-----------------------------------------------------------------------------o
 |
 | Sequence module
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide sequence object to define lattices

 o-----------------------------------------------------------------------------o
]=]

local M = {}

-- module ---------------------------------------------------------------------o

local __help = {}
__help.sequence = [=[
NAME
  sequence -- build sequences

SYNOPSIS
  seq = sequence 'name' { attribute-list, element-list... }

DESCRIPTION
  TODO

RETURN VALUE

EXAMPLE
  see LHC sequences

SEE ALSO
  element.
]=]

__help["sequence: seqedit"] = [=[
Sequence edition:
-----------------
  seqedit:    n/a
  flatten:    n/a
  reflect:    n/a
  endedit:    n/a

  selection: (foreach)
    range=range, flag=flag, pattern=string, class=element, select=predicate

  seq:remove  { selection }
  seq:replace { elements={elem1, elem2, ...}, selection } -- recycle elements
  seq:insert  { elements={elem1, elem2, ...}, selection } -- recycle elements

  seq:dump()  -- to be defined, i.e. should save values, not expressions.
]=]

__help["sequence: indexes, ranges and iterators"] = [=[
Indexes: (index_of)
--------
  return the index in the sequence or nil

  seq:index_of(spos|name|elem, [index|count])
  - spos (number: s-position)
    + spos < 0 means starts from end (i.e. seq.l+num)
    + return the closest index if spos is not found
  - mname (string: mangled name)
    + name                 (absolute and unique)
    + name[count]          (absolute with occurences count)
    + name{count} & index  (relative with occurences count if index is provided)
    + $start or #s or #S (index=1), $end or #e or #E (index=#seq)
  - element (object)
    + element.name         (absolute and unique)
    + element.name & count (absolute with occurences count)

  Inverse method: (name_of)
    seq:name_of(index) returns the mname at index.
    seq:name_of(seq:index_of('mq[10]')) == 'mq[10]'

Ranges: (range_of)
-------
  return the pair of indexes in the sequence or nil

  seq:range_of(arg)
  - start_spos .. stop_spos  (range object)
  - { spos|name|elem, spos|name|elem }
  - "spos|name / spos|name"
  - support for start > stop or missing stop (i.e. stop = start)

Iterators: (iter)
----------
  return an iterator usable by generic for loop

  seq:iter([range], [nturn])
  - iterate through the sequence.
  - if nturn is not specified, nturn=0.
  - if range is not specified
    + if seq.start_at exists, nturn+1 starting at seq.start_at.
    + otherwise from 1 to #seq.
]=]

-- locals ---------------------------------------------------------------------o

local second, bind1st, bind2nd, bind2st                        in MAD.gfunc
local sub, ltrue, lfalse                                       in MAD.operator
local is_iterable, is_callable                                 in MAD.concept
local sequence, marker, flags                                  in MAD.element
local minlen                                                   in MAD.constant
local strtrim, strsplit, strbracket, bsearch                   in MAD.utility
local is_nil, is_boolean, is_number, is_string, is_table,
      is_rawtable, is_range, is_element, is_instanceOf         in MAD.typeid

local abs in math
local table_new, table_clear, table_insert, table_remove =
      table.new, table.clear, table.insert, table.remove

-- backup original methods and metamethods
local sequence_mt = getmetatable(sequence)
local var_raw, var_val = sequence.var_raw, sequence.var_val
local var_get, var_set = sequence_mt.__index, sequence_mt.__newindex
local raw_get, seq_cpy = sequence.raw_get, sequence.copy
local parent           = sequence.parent

-- root object ----------------------------------------------------------------o

-- hidden key.
local _data = {}

-- defined in elements
sequence :set { direction=1, refer='centre', l=0,
                [_data]={eidx={}, spos={}, epos={}, n=0} }

local function is_sequence (a)
  return is_table(a) and a[_data] ~= nil
end

local function is_orig_sequence (a)
  return is_sequence(a) and raw_get(a, _data) ~= nil
end

local function original (a)
  while raw_get(a, _data) == nil do a = parent(a) end
  assert(not rawequal(a,sequence), "no original sequence found")
  return a
end

-- definitions ----------------------------------------------------------------o

-- forward declarations
local elem_pos

-- special numerical value for elements positions.
local uninitialized = -1e9
local ongoing_init  = -2e9

-- start and end markers
local mkstart = marker '$start' { at=0 } : set_readonly()
local mkend   = marker '$end'   {      } : set_readonly()

-- sanity checks --------------------------------------------------------------o

local function seq_error (msg, seq, idx, nam)
  error(msg .. " in sequence '"  .. (seq.__id or '?')
            .. "' for element '" .. (nam      or '?')
            .. "' at index "     .. (idx      or '?'), 2)
end

local function seq_poserr (typ, data, idx, pos)
  local msg = string.format(
    "invalid %s position at s = %.6gm (negative drift %.6gm)",
    typ, data.spos[idx], data.spos[idx]-pos)
  seq_error(msg, data.seq, idx, data[idx].__id)
end

-- check sequence $start and $stop integrity
local function check_mark (data)
  local n = data.ne
      if data[1].__id ~= mkstart.__id or data[1].is_marker ~= true then
    error("invalid sequence first element ($start marker expected)", 2)
  elseif data[n].__id ~= mkend  .__id or data[n].is_marker ~= true then
    error("invalid sequence last element ($end marker expected)", 2)
  end
end

-- check sequence spos and elements overlapp
local function check_spos (data)
  for i=1,data.ne-1 do
    local ds = data.spos[i+1] - (data.spos[i]+data[i].l)
    if ds < -minlen then
      seq_poserr("element", data, i, data.spos[i]-ds)
    end
  end
end

-- check dictionnary of name -> idx
local function check_dict (data)
  local eidx = data.eidx
  eidx['#s'], eidx['#e'], eidx['#S'], eidx['#E'] = nil
  for en,ei in pairs(eidx) do   -- name -> index or table of indexes
    if is_number(ei) then
      assert(data[ei].__id == en     , "unexpected corrupted dictionnary")
    elseif is_table(ei) then
      assert(data[ei[1]].__id == en  , "unexpected corrupted dictionnary")
      for i=2,ei.n do
        assert(ei[i-1] < ei[i]       , "unexpected corrupted dictionnary")
        assert(data[ei[i]].__id == en, "unexpected corrupted dictionnary")
      end
    else
      error("unexpected corrupted dictionnary")
    end
  end
end

--[=[
local function dumpseq (seq)
  local fmt = MAD.option.format
  MAD.option.format = "%.5g"
  print()
  print('sequence:', seq.name, 'l=', seq.l)
  print('i', 'name', 'L', 'S (s)', 'S (e)')
  seq:foreach \e,i -> print(i, e.__id, e.l, seq[_spos][i], seq[_epos][i])
  MAD.option.format = fmt
end
]=]

-- helper for mangled names and elements indexes (same as mtable) -------------o

-- get index from signed index (direct)
local function index_of_idx (data, idx)
  assert(is_number(idx), "invalid argument #2 (index expected)")
  local n = data.ne
  if idx < 0 then idx = n+idx+1 end -- reflect
  if idx < 1 or idx > n then return nil end
  return idx
end

-- get index from s-position (binary)
local function index_of_num (data, num)
  assert(is_number(num), "invalid argument #2 (number expected)")
  local l = data.seq.l
  if num < 0 then num = l+num end -- reflect
  if num < 0 or num > l then return nil end
  return bsearch(data.spos, num)
end

-- get index from name [with count] (direct)
local function index_of_cnam (data, nam, cnt_)
  local ei = data.eidx[nam]
  if is_table(ei) then
    cnt_ = cnt_ or 1
    assert(is_number(cnt_), "invalid argument #3 (count expected)")
    if cnt_ < 0 then cnt_ = ei.n+cnt_+1 end -- reflect
    return ei[cnt_]
  end
  return ei
end

-- get index from name [with relative count] (linear)
local function index_of_rnam (data, nam, cnt_, idx_)
  cnt_ = cnt_ or 1
  assert(is_number(cnt_), "invalid argument #3 (count expected)")
  local ei = data.eidx[nam]
  if is_nil(ei) then return nil end
  idx_ = index_of_idx(data, idx_ or 1)
  if is_nil(idx_) then return nil end
  if is_number(ei) then
    return (cnt_ ==  1 and ei >= idx_ and ei) or
           (cnt_ == -1 and ei <= idx_ and ei) or nil
  end
  if cnt_ > 0 then
    for i=1,ei.n do
      if ei[i] >= idx_ then return ei[i+cnt_-1] end
    end
  elseif cnt_ < 0 then
    for i=1,ei.n do
      if ei[i] >  idx_ then return ei[i+cnt_  ] end
    end
  end
  return nil
end

-- get index from [mangled] name (direct or linear)
local function index_of_mnam (data, nam, idx_)
  assert(is_string(nam), "invalid argument #2 (string expected)")
  local nam, cnt, _, bra = strbracket(nam)
  cnt = tonumber(cnt) or cnt
  if is_nil(idx_) or bra ~= 2 then
    return index_of_cnam(data, nam, cnt      ), bra
  else
    return index_of_rnam(data, nam, cnt, idx_), bra
  end
end

local function index_of_nam (data, nam, idx_)
  return (index_of_mnam(data, nam, idx_))
end

-- get index from element (linear)
local function index_of_elm (data, elm, idx_)
  assert(is_element(elm), "invalid argument #2 (element expected)")
  local nam = elm.__id
  local ei = data.eidx[nam]
  if is_nil(ei) then return nil end
  idx_ = idx_ and index_of_idx(data, idx_) or 1
  if is_number(ei) then
    return ei >= idx_ and data[ei] == elm and ei or nil
  end
  for i=1,ei.n do
    local ii = ei[i]
    if ii >= idx_ and data[ii] == elm then return ii end
  end
  return nil
end

-- get [mangled] name from element (linear)
local function name_of_elm (data, elm, idx_)
  assert(is_element(elm), "invalid argument #2 (element expected)")
  local nam = elm.__id
  local ei = data.eidx[nam]
  if is_nil(ei) then return nil end
  idx_ = index_of_idx(data, idx_ or 1)
  if is_number(ei) then
    return ei >= idx_ and data[ei] == elm and nam or nil
  end
  for i=1,ei.n do
    local ii = ei[i]
    if ii >= idx_ and data[ii] == elm then
      return string.format("%s[%d]", nam, i)
    end
  end
  return nil
end

-- get [mangled] name from index (linear)
local function name_of_idx (data, idx)
  idx = index_of_idx(data, idx)
  if is_nil(idx) then return nil end
  local nam = data[idx].__id
  local ei = data.eidx[nam]
  if is_number(ei) then
    assert(ei == idx, "unexpected corrupted dictionnary")
    return nam
  end
  for i=1,ei.n do
    if ei[i] == idx then
      return string.format("%s[%d]", nam, i)
    end
  end
  error("unexpected corrupted dictionnary")
end

-- position helpers -----------------------------------------------------------o

-- return e-position of 'from', memoize result if count is not relative
local function from_epos (data, from, idx)
  if data.last_from ~= from then                     -- memoized?
    local idx, bra = index_of_mnam(data, from, idx)
    if is_nil(idx) then                              -- not found
      seq_error("invalid from of '" .. from .. "'", data.seq)
    end
    data.last_frompos = second(elem_pos(data, idx))
    data.last_from = bra ~= 2 and from or nil        -- memoize if not relative
  end
  return data.last_frompos                           -- epos
end

-- return e-position of 'refpos'
local function refpos_epos (sseq)
  local rpos = sseq.refpos
  if is_nil(rpos) then return 0 end
  return from_epos(var_raw(sseq,_data), rpos)
end

-- forward index
-- return (#elm-1)+1 because seq[idx] == sseq[2] (see copy_ssequ and sequ_pos).
local function fidx (elm)
  return is_sequence(elm) and #elm or 1
end

-- return s-position of 'from'
local function from_pos (data, elm, idx)
  local pos  = elm.at or 0
  local from = elm.from or elm.at and 'start' or 'prev'

      if from == 'start'    then return pos
  elseif from == 'prev'     then return pos + elem_pos(data,idx-1)+data[idx-1].l
  elseif from == 'next'     then return pos + second(elem_pos(data,idx+fidx(elm)))
  elseif from == 'end'      then return data.seq.l - pos
  elseif from == 'selected' then return pos + elem_pos(data,idx)
  else                           return pos + from_epos(data,from,idx)
  end
end

-- return s-position of 'refer'
local function refer_pos (data, elm, idx)
  local refer
  if is_sequence(elm)
  then refer = elm.refpos and 'refpos' or data.seq.refer
  else refer = elm.refer               or data.seq.refer
  end
      if refer == 'entry'  then return 0
  elseif refer == 'centre' then return elm.l/2
  elseif refer == 'exit'   then return elm.l
  elseif refer == 'refpos' then return refpos_epos(elm)
  else seq_error("invalid refer to '" .. refer .. "'", data.seq, idx, elm)
  end
end

-- build positions ------------------------------------------------------------o

-- set s-positions at index or return element s-positions
-- already declared for forward use, *must not be local*
function elem_pos (data, idx, elm_)
  local spos = data.spos[idx]
  if is_nil(spos) then
    seq_error("invalid index or reference detected", data.seq, idx, elm_)
  elseif is_nil(elm_) then
    if spos >= 0 then
      return spos, data.epos[idx]
    elseif spos == ongoing_init then
      seq_error("cycling dependencies detected", data.seq, idx)
    elseif spos ~= uninitialized then
      seq_error("corrupted s-position detected", data.seq, idx)
    end
    data.spos[idx] = ongoing_init
  end

  local elm  = elm_ or data[idx]
  local epos = from_pos (data, elm, idx)
  local rpos = refer_pos(data, elm, idx)
  spos = epos - rpos

  if is_nil(elm_) then
    data.spos[idx], data.epos[idx] = spos, epos
  end
  return spos, epos
end

-- set s-positions of elements from their sub sequence
local function sequ_pos (data, sseq, idx, dir)
  local pos = elem_pos(data, idx, sseq)    -- shift by subsequence refpos
  local sdata = var_raw(sseq,_data)
  check_mark(sdata)

  if data.seq.direction ~= sseq.direction then -- changedir patch
    data.spos[idx] = sdata.spos[1] + pos
    data.epos[idx] = sdata.epos[1] + pos
    idx = idx + 1
  end

  local n = sdata.ne
  if dir > 0 then
    for i=2,n-1 do
      data.spos[idx-2+i] = sdata.spos[i] + pos
      data.epos[idx-2+i] = sdata.epos[i] + pos
      assert(data[idx-2+i] == sdata[i], "unexpected corrupted flat sequence")
    end
  else
    local l = sseq.l
    for i=2,n-1 do
      local sp, el = sdata.spos[n+1-i], sdata[n+1-i].l
      data.spos[idx-2+i] = l - (sp + el                           ) + pos
      data.epos[idx-2+i] = l - (sp + el - (sdata.epos[n+1-i] - sp)) + pos
      assert(data[idx-2+i] == sdata[n+1-i], "unexpected corrupted flat sequence")
    end
  end

  if data.seq.direction ~= sseq.direction then -- changedir patch
    data.spos[idx+n] = sdata.spos[n] + pos
    data.epos[idx+n] = sdata.epos[n] + pos
  end
end

-- compute elements positions
local function build_pos (data, sref)
  local n, idx, pos = data.ne, 1, 0
  sref = sref or {}
  for i=1,n do
    data.spos[i], data.epos[i] = uninitialized, uninitialized
  end
  while idx <= n do
    local sseq = sref[idx]
    if is_nil(sseq) then     -- element
      elem_pos(data, idx)
      if pos-minlen > data.spos[idx] then
        seq_poserr('element', data, idx, pos)
      end
      pos = data.spos[idx] + data[idx].l
      idx = idx + 1
    else                     -- subsequence
      local sdata = var_raw(sseq,_data)
      sequ_pos(data, sdata, idx, sref.sdir[idx])
      if pos-minlen > data.spos[idx] then
        seq_poserr('subsequence', data, idx, pos)
      end
      pos = data.spos[idx] - sdata.spos[2] + sseq.l
      idx = idx + sdata.ne-2
    end
  end
  assert(n == idx-1, "unexpected corrupted flat sequence")

  -- adjust sequence length or end marker position
  local len, l = data.spos[n], data.seq.l
  if   l < len
  then l = len
  else data.spos[n], data.epos[n] = l, l
  end
end

-- flatten sequence -----------------------------------------------------------o

-- copy sub sequence
local function copy_ssequ (seq, flat, sref, idx, dir)
  local data = var_raw(seq,_data)
  check_mark(data)
  if data.ne <= 2 then return idx end

  sref[idx], sref.sdir[idx] = seq, dir -- link subsequence

  if sref.dir ~= seq.direction then -- insert changedir patch
    idx, flat[idx] = idx+1, changedir(seq.__id, {})
  end

  local n = data.ne
  if dir > 0 then
    for i=2,n-1 do flat[idx-2+i] = data[i] end
  else
    for i=2,n-1 do flat[idx-2+i] = data[n+1-i] end
  end

  if sref.dir ~= seq.direction then
    idx, flat[idx-2+n] = idx+1, flat[idx-1]:select(shared) -- share patch
  end
  return idx-2+n
end

-- flatten lines and subsequence
local function flatten_line (line, flat, sref, idx, dir)
  local n, rep = #line, (line.__rep or 1) * dir
  if n == 0 then return idx end

  local start, stop, step
  if rep < 0
  then rep, start, stop, step = -rep, n, 1, -1
  else rep, start, stop, step =  rep, 1, n,  1
  end

  for i=1,rep do
  for j=start,stop,step do
    local elm = line[j]
    if not (is_element(elm) or is_rawtable(elm)) then
      seq_error("invalid element detected", line, j)
    elseif elm.is_bline == true or is_rawtable(elm) then
      idx = flatten_line(elm, flat, sref, idx, step)
    elseif not is_nil(sref) and is_sequence(elm) then
      idx = copy_ssequ  (elm, flat, sref, idx, step)
    else -- other elements
      idx, flat[idx] = idx+1, elm
    end
  end end
  return idx
end

-- flatten sequence
local function flatten_sequ (seq, flat, sref)
  local n, idx = seq:raw_len(), 2
  flat[1] = mkstart {}
  for i=1,n do
    local elm = seq:raw_get(i)
    if not (is_element(elm) or is_rawtable(elm)) then
      seq_error("invalid element detected", seq, i)
    elseif elm.is_bline == true or is_rawtable(elm) then
      idx = flatten_line(elm, flat, sref, idx, 1)
    elseif is_sequence(elm) then
      idx = copy_ssequ  (elm, flat, sref, idx, 1)
    else -- other elements
      idx, flat[idx] = idx+1, elm
    end
  end
  flat[idx] = mkend {}
  assert(n <= idx, "unexpected corrupted flat sequence")
end

-- dict helper ----------------------------------------------------------------o

-- build dictionnary name -> idx
local function build_idx (data)     -- must be very fast
  local eidx = data.eidx
  table_clear(eidx)                 -- reuse main storage
  for idx,elm in ipairs(data) do
    local nam = elm.__id
    local val = eidx[nam]
    if is_nil(val) then             -- none: scalar
      eidx[nam] = idx
    elseif is_number(val) then      -- one : scalar to array
      eidx[nam] = {val, idx, n=2}
    else                            -- many: append
      local n = val.n+1
      val[n], val.n = idx, n
    end
  end
end

-- build sequence -------------------------------------------------------------o

-- finalize sequence
local function finish_seq (data)
  -- sanity checks
  if MAD.option.debug > 2 then
    check_mark(data)
    check_spos(data)
    check_dict(data) -- remove $start/$end marker aliases
  end

  -- clear memoization
  data.last_from    = nil
  data.last_frompos = nil

  -- $start/$end markers aliases
  local ei, ne = data.eidx, data.ne
  ei['#s'], ei['#S'] =  1,  1
  ei['#e'], ei['#E'] = ne, ne
end

-- sequence init (build)
local function sequ_init (seq)
  local n = seq:raw_len()
  if n == 0 then return seq end -- empty

  local sref = { dir=seq.direction, sdir={} }
  local data = table_new(n+2,8) -- elements (data)
  flatten_sequ(seq, data, sref)
  seq:clear_array()

  local ne  = #data
  data.eidx = table_new(0,ne)   -- name -> idx
  data.epos = table_new(ne,0)   -- elem   positions
  data.spos = table_new(ne,0)   -- elem s-positions
  data.ne   = ne                -- #elem
  data.seq  = seq               -- connect data to sequence

  seq[_data] = data
  build_idx (data)
  build_pos (data, sref)
  finish_seq(data)
  return seq
end

-- sequence metamethods -------------------------------------------------------o

-- count proxy
local _idx = {}

local function cnt_iter (s, i)
  i = i+1
  local ei = s[_idx][i]
  if ei then return i, s[_data][ei] end
end

local cnt_mt = {
  __len       =\s   -> s[_idx].n,
  __index     =\s,i -> s[_data][s[_idx][i]],
  __pairs     =\s   -> cnt_iter, s, 0,
  __ipairs    =\s   -> cnt_iter, s, 0,
  __tostring  =\s   -> string.format("<sequence count> %p", s),

  __newindex := error("forbidden write access to counts" , 2),
  __kpairs   := error("invalid access to sequence counts", 2),
}

-- iterator over elements
local function ipairs_mm (seq)
  return ipairs(var_raw(seq,_data))
end

-- number of elements
local function len_mm (seq)
  return var_raw(seq,_data).ne
end

-- read access precedence: element index, variable key, element name.
local function index_mm (seq, key)
  -- element index
  if is_number(key) then                              -- see index_of_idx
    local data = var_raw(seq,_data)
    if key < 0 then key = data.ne+key+1 end -- reflect
    return data[key]
  end
  -- variable
  local var = var_raw(seq, key)
  if var then return var_val(seq, key, var) end
  -- element name
  local data = var_raw(seq,_data)
  local idx = data.eidx[key]
  if is_number(idx) then
    return data[idx]
  elseif is_table(idx) then
    return setmetatable({[_idx]=idx, [_data]=data}, cnt_mt)
  end
end

local function newindex_mm (seq, key, val)
  -- element index or name
  if is_number(key) or var_raw(seq,_data).eidx[key] then
    error("invalid sequence write access (use replace method)")
  end
  -- variable
  var_set(seq, key, val)
end

-- methods (readonly) ---------------------------------------------------------o

local function name_of (seq, a, ref_)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
      if is_number (a) then return name_of_idx(seq, a)
  elseif is_element(a) then return name_of_elm(seq, a, ref_)
  end
  error("invalid argument #2 (number or element expected)")
end

local function index_of (seq, a, ref_)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
      if is_number (a) then return index_of_num(seq, a)
  elseif is_string (a) then return index_of_nam(seq, a, ref_)
  elseif is_element(a) then return index_of_elm(seq, a, ref_)
  end
  error("invalid argument #2 (number, string or element expected)")
end

local function range_of (seq, rng, ref_)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  local start, stop
  if is_number(rng) then
    start = index_of_idx(seq, rng)
    return start, start
  elseif is_string(rng) then
    local s1, i2 = strsplit(rng, "/" )
    local s2 = i2 > 0 and strtrim(rng, i2+1) or nil
    start, stop = tonumber(s1) or s1, tonumber(s2) or s2
  elseif is_table(rng) then
    start, stop = rng[1], rng[2]
  elseif is_range(rng) then
    start, stop = rng:bounds()
  else error("invalid argument #2 (index, string, range or table expected)")
  end
  start = index_of(seq, start, ref_)
  stop  = stop and index_of(seq, stop, ref_ or start) or start
  return start, stop
end

local function length_of (seq, rng_, ntrn_)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  local siz = rng_ and 1-sub(range_of(seq, rng_)) or 0
  return siz + #seq * ((ntrn_ or 0) + (siz <= 0 and 1 or 0))
end

-- functional methods ---------------------------------------------------------o

--[=[
programming model:
seq:foreach {
  action=function,
  range=range,
  flag=flag, pattern=string, class=element, select=predicate -- AND'ed selections
  default=nil/'none'
}
seq:foreach(action, range, select, not)
seq:select/deselect(flag, range, select, not)
seq:filter(range, select, default)
without any selection criterium:
  not ~= true and default ~= 'none' -> select all
  not == true or  default == 'none' -> select nothing
]=]

local pcls   = is_instanceOf
local psel   = marker.is_selected
local pnam   = \e,pat -> string.match(e.__id, pat) ~= nil
local pand   = \p,p2,e,i -> p(e,i) and p2(e,i)
local ptrue  = \p,_ ,e,i -> p(e,i) and true
local pfalse = \p,_ ,e,i -> p(e,i) or false

local function foreach (seq, act, rng_, sel_, not_) -- action, range, selection, default
  local f, p
  if is_nil(rng_) and is_rawtable(act) then
    f, rng_ = act.action, act     -- extract action + right shift
  else
    f = act
  end
  if is_nil(sel_) and is_rawtable(rng_) and is_nil(rng_[1]) then
    rng_, sel_ = rng_.range, rng_ -- extract range  + right shift
  end
  if is_nil(not_) and is_boolean(sel_) then
    not_, sel_ = sel_             --                  right shift
  end

  if is_rawtable(sel_) then       -- logically and'ed selections
    if is_nil(not_) and (sel._default == 'none' or sel._default == true) then
      not_ = true
    end
    local op = not_ ~= true and ptrue or pfalse
    if sel_.select then
      assert(is_callable(sel_.select), "invalid select (callable expected)")
      op, p = pand, bind2st(op, sel_.select, p)
    end
    if sel_.class then
      assert(is_element(sel_.class), "invalid class (element expected)")
      op, p = pand, bind2st(op, bind2nd(pcls, sel_.class), p)
    end
    if sel_.pattern then
      assert(is_string(sel_.pattern), "invalid pattern (string expected)")
      op, p = pand, bind2st(op, bind2nd(pnam, sel_.pattern), p)
    end
    if sel_.flag then
      assert(is_number(sel_.flag), "invalid flag (number expected)")
      op, p = pand, bind2st(op, bind2nd(psel, sel_.flag), p)
    end
  elseif not is_nil(sel_) then    -- build the selection
    p = is_number  (sel_) and bind2nd(psel, sel_) or
        is_string  (sel_) and bind2nd(pnam, sel_) or
        is_element (sel_) and bind2nd(pcls, sel_) or
        is_callable(sel_) and sel_                or nil
  end
  if is_nil(p) then p = not_ ~= true and ltrue or lfalse end

  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  assert(is_callable(f)  , "invalid argument #2 (callable expected)")
  assert(is_callable(p)  , "invalid argument #4 (callable expected)")

  if p ~= lfalse then
    for idx,elm in seq:iter(rng_) do
      if p(elm,idx) then f(elm,idx) end
    end
  end
  return seq
end

local do_select = marker.select

local function select (seq, flg_, rng_, sel_, not_)
  if is_rawtable(flg_) and is_nil(rng_) and is_nil(sel_) then
    rng_, flg_ = flg_ -- right shift
  end
  local f = bind2nd(do_select, flg_)
  return seq:foreach(f, rng_, sel_, not_)
end

local do_deselect = marker.deselect

local function deselect (seq, flg_, rng_, sel_, not_)
  if is_rawtable(flg_) and is_nil(rng_) and is_nil(sel_) then
    rng_, flg_ = flg_ -- right shift
  end
  local f = bind2nd(do_deselect, flg_)
  return seq:foreach(f, rng_, sel_, not_)
end

local do_filter = \idx,_,i => local n=idx.n+1 ; idx[n], idx.n = i, n end

local function filter (seq, rng_, sel_, not_)
  local idx = table_new(8,1)
  local f = bind1st(do_filter, idx)
  idx.n = 0
  seq:foreach(f, rng_, sel_, not_)
  return idx
end

-- methods (R/W, rebuild dict) ------------------------------------------------o

local function rebuild_index (seq)
  assert(is_orig_sequence(seq), "invalid argument #1 (original sequence expected)")
  local data = var_raw(seq,_data)
  build_idx (data)
  finish_seq(data)
  return seq
end

local function remove (seq, rng_, sel_)
  assert(is_orig_sequence(seq), "invalid argument #1 (original sequence expected)")

  -- collect indexes of elements to remove
  local idx_r = filter(seq, rng_, sel_, true)
  local nr = idx_r.n
  if nr == 0 then return end
  assert(idx_r[nr]-idx_r[1] >= nr-1, "invalid range, indexes must be increasing")

  -- remove elements by decreasing indexes -- to optimize to avoid slow removal
  local data, elm_r = raw_get(seq,_data), table_new(nr,0)
  for i=nr,1,-1 do
    local ii = idx_r[i]
    elm_r[i] = data[ii]    -- backup
    table_remove(data     , ii)
    table_remove(data.spos, ii)
    table_remove(data.epos, ii)
  end
  data.ne = data.ne-nr
  rebuild_index(seq)
  return elm_r, idx_r
end

local function replace (seq, elm, rng_, sel_)
  assert(is_orig_sequence(seq), "invalid argument #1 (original sequence expected)")

  if is_rawtable(elm) and is_nil(rng_) and is_nil(sel_) then
    rng_, elm = elm, elm.elements -- extract elements + right shift
  end

  if is_element(elm) then elm = {elm} end
  assert(is_rawtable(elm), "invalid argument #2 (elements list expected)")
  local ne = #elm
  if ne == 0 then return end

  -- check elements
  for i=1,ne do
    if is_element(elm[i]) and not is_sequence(elm[i]) then
      error("invalid element '"..(elm[i].__id or '?').."' replacement at index "..i)
    end
  end

  -- collect indexes of elements to replace
  local idx_r = filter(seq, rng_, sel_, true)
  local nr = idx_r.n
  if nr == 0 then return end
  assert(idx_r[nr]-idx_r[1] >= nr-1, "invalid range, indexes must be increasing")

  -- replace elements
  local data, elm_r = raw_get(seq,_data), table_new(nr,0)
  for i=1,nr do
    local ii, ie = idx_r[i], (i-1)%ne+1    -- recycle list of elements
    data[ii], elm_r[i] = elm[ie], data[ii] -- backup
    data.spos[ii], data.epos[ii] = uninitialized, uninitialized
    elem_pos(data, ii) -- recompute the positions
  end
  rebuild_index(seq)
  return elm_r, idx_r
end

local function insert (seq, elm, rng_, sel_)
  assert(is_orig_sequence(seq), "invalid argument #1 (original sequence expected)")

  if is_rawtable(elm) and is_nil(rng_) and is_nil(sel_) then
    rng_, elm = elm, elm.elements -- extract elements + right shift
  end

  if is_element(elm) then elm = {elm} end
  assert(is_rawtable(elm), "invalid argument #2 (elements list expected)")
  local ne = #elm
  if ne == 0 then return end

  -- collect indexes of reference where to insert
  local idx_r = filter(seq, rng_, sel_, true)
  local nr = idx_r.n
  assert(idx_r[nr]-idx_r[1] >= nr-1, "invalid range, indexes must be increasing")

  -- collect elements and subsequences to insert
  local ins = table_new(ne,0) -- no sref -> keep subsequence as-is
  flatten_line(elm, ins, nil, 1, 1)
  elm, ne, ins = ins, #ins -- update

  -- precompute number of elements with from='selected'
  local ns = 0
  for i=1,ne do
    if is_element(elm[i]) and not is_sequence(elm[i]) then
      error("invalid element '"..(elm[i].__id or '?').."' insertion at index "..i)
    end
    if elm[i].from == 'selected' then ns = ns+1 end
  end

  -- precompute position of each element
  local data = raw_get(seq,_data)
  local i, ni = 0, ne-ns + ns*nr
  local spos, epos = table_new(ni,0), table_new(ni,0)
  for ie=1,ne do
    if elm[ie].from ~= 'selected' then
      i = i + 1
      elm[i], spos[i], epos[i] = elm[ie], elem_pos(data, 1, elm[ie])
    else for ir=1,nr do
        i = i + 1
        elm[i], spos[i], epos[i] = elm[ie], elem_pos(data, idx_r[ir], elm[ie])
      end
    end
  end

  -- insert elements -- to optimize to avoid slow insertion
  for ie=1,i do
    local idx = bsearch(data.spos, spos[ie], 2, data.ne-1)
    if is_sequence(elm[ie]) then
      local sdata = var_raw(elm[ie],_data)
      for j=sdata.ne-1,2,-1 do -- see sequ_pos
        table_insert(data     , idx, sdata     [j])
        table_insert(data.spos, idx, sdata.spos[j] + spos[ie])
        table_insert(data.epos, idx, sdata.epos[j] + spos[ie])
      end
    else
      table_insert(data     , idx, elm [ie])
      table_insert(data.spos, idx, spos[ie])
      table_insert(data.epos, idx, epos[ie])
    end
  end
  data.ne = #data
  rebuild_index(seq)
  return seq
end

local function copy (seq, name_)
  assert(not rawequal(seq, sequence), "invalid argument #1 (cannot copy 'sequence')")
  assert(is_sequence(seq)           , "invalid argument #1 (sequence expected)")
  local cpy  = seq_cpy(seq,name_)
  local data = raw_get(seq,_data)
  if not data then return cpy end

  local ne   = data.ne
  local cdat = table_new(ne,8)  -- see sequ_init
  cdat.eidx  = table_new(0,ne)  -- name -> idx
  cdat.epos  = table_new(ne,0)  -- elem   positions
  cdat.spos  = table_new(ne,0)  -- elem s-positions
  cdat.ne    = ne               -- #elem
  cdat.seq   = cpy              -- connect data to sequence

  for i=1,ne do
    cdat[i] = data[i]:copy()
    cdat.spos[i], cdat.epos[i] = data.spos[i], data.epos[i]
  end

  cpy[_data] = data
  rebuild_index(cpy)
  return cpy
end

-- special --------------------------------------------------------------------o

local function cycle (seq, ref)
  assert(is_sequence(seq)  , "invalid argument #1 (sequence expected)")
  assert(index_of(seq, ref), "invalid argument #2 (reference expected)")
  seq.start_at = ref
  return seq
end

local function share (seq1, seq2)
  assert(is_orig_sequence(seq1), "invalid argument #1 (original sequence expected)")
  assert(is_orig_sequence(seq2), "invalid argument #2 (original sequence expected)")
  local data1 = raw_get(seq1,_data)
  local data2 = raw_get(seq2,_data)
  check_mark(data1) check_mark(data2)
  for i=2,data1.ne-1 do
    local nam = data1[i].__id -- share by (unique) name
    local i2 = data2.eidx[nam]
    if i2 then -- element name found in seq2
      local i1 = data1.eidx[nam]
      -- ensure that elements are unique in both sequences
      assert(is_number(i1) and is_number(i2), "invalid shared element (must be unique)")
      local e1, e2 = data1[i1], data2[i2]
      assert(e1.__id == nam and e2.__id == nam, "unexpected corrupted dictionnary")
      -- make Y inheritance using e1 as reference and discard e2 (pos are unchanged)
      local c1 = e1 { at := e1.at, from := e1.from, refpos := e1.refpos }
      local c2 = e1 { at := e2.at, from := e2.from, refpos := e2.refpos }
      -- check compatibility of positions
      local s0, s1, s2 = data2.spos[i2], elem_pos(data2,i2,c2), elem_pos(data2,i2,e2)
      assert(s0 == s1 and s0 == s2, "incompatible shared elements (spos differs)")
      -- update arrays, add shared flag
      data1[i1] = c1:set_flag(flags.shared)
      data2[i2] = c2:set_flag(flags.shared)
    end
  end
  finish_seq(data1) finish_seq(data2)
  return seq1, seq2
end

local function unique (seq, fmt_)
  assert(is_orig_sequence(seq), "invalid argument #1 (original sequence expected)")
  if is_string(fmt_) then fmt_ = bind1st(string.format, fmt_) end
  assert(is_callable(fmt_), "invalid argument #2 (callable expected)")
  local data, lst = raw_get(seq,_data), table_new(0,64)
  for en,ei in pairs(data.eidx) do
    if is_table(ei) then
      table_clear(lst)
      for i=1,ei.n do
        local elm = data[ei[i]]
        lst[elm] = (lst[elm] or 0)+1
      end
      for i=1,ei.n do
        local idx, nam = ei[i]
        local elm = data[idx]
        if fmt_ then
          nam = fmt_(elm.__id, i, idx)
          if data.eidx[nam] ~= nil then
            error("cannot rename uniquely element '"..nam.."' (already in use)")
          end
          data.eidx[nam] = idx
        end
        if lst[elm] > 1 then
          data[idx] = elm(nam,{})    -- replaced by unique child
        elseif fmt_ then
          elm:raw_set('__id', nam)   -- override with unique name
        end
      end
      if fmt_ then data.eidx[en] = nil end
    end
  end
  finish_seq(data)
  return seq
end

-- iterators ------------------------------------------------------------------o

local function fwditer (state, i)
  if i == state.stop then
    if state.turn == 0 then return nil end
    state.turn = state.turn-1
  end
  if i < state.ne then
    i = i+1
  else
    i, state.soff = 1, state.soff+state.l
  end
  return i, state.data[i], state.spos[i]+state.soff
end

local function bwditer (state, i)
  if i == state.stop then
    if state.turn == 0 then return nil end
    state.turn = state.turn-1
  end
  if i > 1 then
    i = i-1
  else
    i, state.soff = state.ne, state.soff-state.l
  end
  return i, state.data[i], state.spos[i]+state.data[i].l-state.soff
end

local function iter (seq, rng_, ntrn_, dir_)
  local nturn, dir = ntrn_ or 0, dir_ or 1
  assert(is_sequence(seq)                ,"invalid argument #1 (sequence expected)")
  assert(is_number(nturn) and nturn >= 0 ,"invalid argument #3 (number expected)")
  assert(is_number(dir) and abs(dir) == 1,"invalid argument #4 (direction expected)")

  local data, start, stop = var_raw(seq,_data)
  if is_nil(rng_) then
    local s0, sn = 1, data.ne
    if dir < 0 then s0, sn = sn, s0 end
    if is_nil(seq.start_at) then
      start, stop = s0, sn
    else
      start = assert(index_of(seq, seq.start_at), "invalid cycle reference")
      stop  = start == s0 and sn or start-dir
    end
  else
    start, stop = range_of(seq, rng_)
    assert(is_number(start), "invalid range start")
    assert(is_number(stop ), "invalid range stop" )
  end
  if start == stop+dir then nturn = nturn+1 end

  local soff = dir > 0 and -data.spos[start] or data.spos[start]+data[start].l
  return dir > 0 and fwditer or bwditer, {data=data, spos=data.spos, soff=soff,
         l=seq.l, ne=data.ne, stop=stop, turn=nturn}, start-dir
end

-- flags ----------------------------------------------------------------------o

local function save_flags (seq)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  local data = var_raw(seq,_data)
  local flgs = table_new(data.ne,0)
  for i=1,data.ne do flgs[i] = data[i]:get_flags() end
  if is_nil(data.flgs) then data.flgs = { n=0 } end
  local n = data.flgs.n+1
  data.flgs[n], data.flgs.n = flgs, n
end

local function drop_flags (seq)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  local data = var_raw(seq,_data)
  assert(not (is_nil(data.flgs) or data.flgs.n == 0), "saved flags not found")
  local n = data.flgs.n
  data.flgs[n], data.flgs.n = nil, n-1
end

local function restore_flags (seq)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  local data = var_raw(seq,_data)
  assert(not (is_nil(data.flgs) or data.flgs.n == 0), "saved flags not found")
  local n = data.flgs.n
  local flgs = data.flgs[n]
  for i=1,data.ne do data[i]:set_flags(flgs[i]) end
  data.flgs[n], data.flgs.n = nil, n-1
end

-- env ------------------------------------------------------------------------o

MAD.typeid.is_sequence          = is_sequence
MAD.typeid.is_original_sequence = is_orig_sequence

-- members --------------------------------------------------------------------o

sequence.original = original

sequence :set_methods {
  elem          = \s,i -> s[_data]     [i],
  spos          = \s,i -> s[_data].spos[i],
  epos          = \s,i -> s[_data].epos[i],

  name_of       = name_of,
  index_of      = index_of,
  range_of      = range_of,
  length_of     = length_of,

  foreach       = foreach,
  select        = select,
  deselect      = deselect,
  filter        = filter,

  remove        = remove,
  replace       = replace,
  insert        = insert,
  copy          = copy,

  cycle         = cycle,
  share         = share,
  unique        = unique,

  iter          = iter,

  -- flags
  save_flags    = save_flags,
  drop_flags    = drop_flags,
  restore_flags = restore_flags,

  -- read/write
  read         := error("NYI", 2), -- TODO (possible?)
  write        := error("NYI", 2), -- TODO

  -- debug
  rebuild_index = rebuild_index, -- debug

  -- disabled methods
  is_selected  := error("invalid sequence operation", 2),

} : set_metamethods ({
  __len         = len_mm,
  __index       = index_mm,
  __newindex    = newindex_mm,
-- __pairs      = pairs_mm, default
  __ipairs      = ipairs_mm,
-- __kpairs     = kpairs_mm, default

  __copy        = copy,
  __init        = sequ_init,

}, true) :set_readonly()

-- end -------------------------------------------------------------------------
return {
  sequence = sequence,
  __help   = __help,
}

--[=[
SEQUENCE DISPLAY
local function show_fields(t, lst)
  local a, k, s
  lst = lst or sequence_fields
  for _,v in ipairs(lst) do
    if is_list(v) then k, s = v[1], v[2] else k, s = v, v end
    a = t[k]
    if a then io.write(', ', s, '= ', tostring(a)) end
  end
end

function M:show(disp)
  io.write("sequence '", self.__id,"' { ")
  show_list(self, disp)
  io.write(' }\n')
  for _,v in ipairs(self) do v:show(disp) end
  io.write('endsequence\n')
end

function M:show_madx(disp)
  io.write("'", self.__id, "': sequence, ")
  show_list(self, disp)
  io.write(';\n')
  for _,v in ipairs(self) do v:show_madx(disp) end
  io.write('endsequence;\n')
end
--]=]
