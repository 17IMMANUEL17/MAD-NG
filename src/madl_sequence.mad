--[=[
 o-----------------------------------------------------------------------------o
 |
 | Sequence module
 |
 | Methodical Accelerator Design - Copyright CERN 2015+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide sequences to define lattices

 o-----------------------------------------------------------------------------o
]=]

local M = { __help = {} }

-- module ---------------------------------------------------------------------o

M.__help.self = [[
NAME
  sequence -- build sequences

SYNOPSIS
  seq = sequence 'name' { attribute-list, element-list... }

DESCRIPTION
  TODO

RETURN VALUE

EXAMPLE
  see LHC sequences

SEE ALSO
  bline, element, beam
]]

-- locals ---------------------------------------------------------------------o

local is_nil, is_number, is_string, is_rawtable, vector, sign in MAD
local is_iterable, is_callable in MAD.concept
local element in MAD.element

-- definition -----------------------------------------------------------------o

local _pos = {} -- hidden key

local sequence = element 'sequence' {
   kind='sequence', is_sequence=true, direction=1,
}

local init_sequence -- forward declaration

sequence:set_metamethod {
  __init = \s -> init_sequence(s),
}

local function seq_error (msg, sequ, elem, idx)
    error(msg .. " in sequence '"  .. sequ.name
              .. "' for element '" .. elem.name
              .. "' at index "     .. (idx or '?'))
end

-- implementation -------------------------------------------------------------o

-- identifier
local function ident (name)
  return string.gsub(string.lower(name), '[^%l%d_]', '_')
end

-- search
local function find_idx (sequ, elem, start_)
  if elem ~= nil then
    local start, stop, step = start_ or 1
    if start > 0
    then stop, step = #sequ, 1
    else stop, step, start = 1, -1, -start
    end
    for i=start,stop,step do  -- linear search
      if sequ[i] == elem then return i end
    end
  end
  return nil
end

local function find_idx_s (sequ, s, start_)
  local s_pos = sequ.s_pos
  local start = start_ or 1
  if start > 0 then
    for i=start,#s_pos do    -- linear search
      if s_pos[i] >= s then return i end
    end
  elseif start < 0 and -start <= #s_pos then
    for i=-start,1,-1 do     -- linear search
      if s_pos[i] <= s then return i end
    end
  end
  return nil
end

-- collect
local function add_mult_elem (to, elem)
  if is_nil(to)    then return  elem      end  -- no ref yet
  if to.is_element then return {to, elem} end  -- one ref
  to[#to+1] = elem      return  to             -- many refs
end

local function add_uniq_elem (to, elem)
  if is_nil(to) or to == elem then return elem end  -- no ref yet or equal ref
  if to.is_element then return {to, elem} end       -- one ref
  for i=1,#to do
    if to[i] == elem then return to end             -- many refs, already there
  end
  to[#to+1] = elem        return to                 -- many refs, not yet there
end

local uninitialized = -1e9
local ongoing_init  = -2e9

-- compute s positions of sequence elements
local function elem_spos(sequ, idx)
  local s_pos = sequ.s_pos[idx]
  if s_pos >= 0 then return s_pos end
  if s_pos == ongoing_init then
    seq_error("cycling dependencies detected", sequ, sequ[idx], idx)
  elseif s_pos ~= uninitialized then
    seq_error("corrupted s-position detected", sequ, sequ[idx], idx)
  end

  sequ.s_pos[idx] = ongoing_init

  local elem  = sequ[idx]
  local len   = elem.l     or 0
  local pos   = elem.at    or 0
  local from  = elem.from  or elem.at and 'start' or idx > 1 and 'prev' or 'start'
  local refer = elem.refer or sequ.refer or 'entry'

      if refer == 'entry'  then -- nothing
  elseif refer == 'centre' then pos = pos - len/2
  elseif refer == 'exit'   then pos = pos - len
  else seq_error("invalid refer to '" .. refer .. "'", sequ, elem, idx)
  end

      if from == 'start'   then ;
  elseif from == 'end'     then pos = sequ.l - pos
  elseif from == 'prev'    then pos = pos + (idx > 0 and sequ.s_pos[idx-1]+(sequ[idx-1].l or 0) or 0)
  elseif from == 'next'    then pos = pos + elem_spos(sequ, idx+1)
  elseif sequ[from]        then pos = pos + elem_spos(sequ, find_idx(sequ, sequ[from], -sign(elem.at)*idx))
  else seq_error("invalid from of '" .. from .. "'", sequ, elem, idx)
  end

  sequ.s_pos[idx] = pos
  return pos
end

local function copy_spos (sequ, sseq, idx)
  local spos, elem
  elem, sequ[idx] = sequ[idx], sseq -- find subsequence position
  spos, sequ[idx] = elem_spos(sequ, idx), elem
  -- TODO: refpos
  for i=1,#sseq do
    sequ.s_pos[idx+i-1] = spos + sseq.s_pos[i]
    assert(sequ[idx+i-1] == sseq[i], "unexpected corrupted flat sequence")
  end
end

local function copy_sequ (sequ, flat, sref, k)
  local k0 = k
  for _,elem in ipairs(sequ) do
    k, flat[k], sref[k] = k+1, elem, false
  end
   -- keep a link of the subsequence
  if k ~= k0 then sref[k0] = sequ end
  return k
end

local function flatten_line (line, flat, sref, k, rev)
  local n = (line._rep or 1) * rev
  local start, stop, step, elem

  if n < 0
  then n, start, stop, step = -n, #line,     1, -1
  else n, start, stop, step =  n, 1    , #line,  1
  end

  for i = 1,n do
    for idx = start,stop,step do
      elem = line[idx]
      if is_rawtable(elem) or elem.is_bline == true then
        k = flatten_line(elem, flat, sref, k, step)
      elseif elem.is_sequence == true then
        k = copy_sequ   (elem, flat, sref, k)
      elseif elem.is_element == true then
        k, flat[k], sref[k] = k+1, elem, false
      else
        seq_error("invalid element detected", line, elem, idx)
      end
    end
  end
  return k
end

local function flatten_sequ (sequ, flat, sref)
  local k = 1
  for idx,elem in ipairs(sequ) do
    if is_rawtable(elem) or elem.is_bline == true then
      k = flatten_line(elem, flat, sref, k, 1)
    elseif elem.is_sequence == true then
      k = copy_sequ   (elem, flat, sref, k)
    elseif elem.is_element == true then
      k, flat[k], sref[k] = k+1, elem, false
    else
      seq_error("invalid element detected", sequ, elem, idx)
    end
  end
  assert(#sequ+1 <= k and #flat == #sref, "unexpected corrupted flat sequence")
end

local function build_sequ (sequ, flat)
  for idx,elem in ipairs(flat) do
    local name = elem.name
    sequ[name] = add_mult_elem(sequ[name], elem)
    sequ[ident(name)] = sequ[name]
    sequ[idx] = elem
  end
  assert(#sequ == #flat, "unexpected corrupted flat sequence")
end

local function build_spos (sequ, sref)
  assert(#sequ == #sref,  "unexpected corrupted flat sequence")
  rawset(sequ, _pos, vector(#sref):ones(uninitialized))
  local idx, len = 1, #sref
  while idx <= len do
    if sref[idx] == false then
      elem_spos(sequ, idx)
      idx = idx + 1
    else -- subsequence
      local sseq = sref[idx]
      copy_spos(sequ, sseq, idx)
      idx = idx + #sseq
    end
  end
  assert(len+1 == idx, "unexpected corrupted flat sequence")
end

function init_sequence (sequ)
  local flat, sref = {}, {}
  flatten_sequ (sequ, flat, sref)
  build_sequ   (sequ, flat)
  build_spos   (sequ, sref)
  return sequ
end

-- functions ------------------------------------------------------------------o

M.__help["Indexes and ranges"] = [[
Indexes:
  - idx (number)
  - negative idx, as idx but starts from end (i.e. #seq-idx+1)
  - name (string)
  - name[count] (case of multiple occurences)
  - element (object)
  - #s or #S (idx=1), #e or #E (idx=#seq)
Ranges:
  - idx (i.e. {idx,idx})
  - "start_index/stop_index"
  - {start_index, stop_index}
  requires start_index <= stop_index
]]

local function index_of (seq, elem, start_)
  if is_number(elem) then
    local len = #seq
    if elem < 0 then elem = len+elem+1 end
    assert(elem >= 1 and elem <= len, "index out of bounds")
    return elem
  elseif is_string(elem) then
    if name == '#s' or name == '#S' then return 1 end
    if name == '#e' or name == '#E' then return #seq end
    local name, cnt = string.match(elem, "([^[/]+)%[(%d*)%]")
    if name ~= nil and cnt ~= nil then
      elem = seq[name][tonumber(cnt)]
    else
      elem = seq[string.match(elem, "([^[/]+)")]
    end
  end
  return find_idx(seq, elem, start_)
end

local function spos_of (seq, elem, start_)
  local idx = index_of(seq, elem, start_)
  assert(is_number(idx), "invalid argument #2 (valid key expected)")
  return seq[_pos][idx]
end

local function range_index (seq, rng)
  local len, start, stop = #seq
  if is_string(rng) then
    start, stop = string.match(rng, "([^/]+)/?(.*)")
    if string.match(start, "%d+") then start = tonumber(start) end
    if string.match(stop , "%d+") then stop  = tonumber(stop ) end
  else
    start = is_iterable(rng) and rng[1] or rng or 1
    stop  = is_iterable(rng) and rng[2] or rng or len
  end
  start = assert(index_of(seq, start)      , "invalid range start")
  stop  = assert(index_of(seq, stop, start), "invalid range stop" )
  assert(start <= stop, "invalid range, start > stop")
  return start, stop
end

local function foreach (seq, f, rng_)
  assert(is_callable(f), "invalid argument #2 (callable expected)")
  local start, stop = range_index(seq, rng_)
  for i=start,stop do f(seq[i],i) end
  return seq
end

local function filter (seq, p, rng_)
  assert(is_callable(p), "invalid argument #2 (callable expected)")
  local r, start, stop = {}, range_index(seq, rng_)
  for i=start,stop do
    if p(seq[i],i) == true then r[#r+1] = seq[i] end
  end
  return r
end

local function select (seq, p, rng_)
  assert(is_callable(p), "invalid argument #2 (callable expected)")
  local start, stop = range_index(seq, rng_)
  for i=start,stop do
    local elem = seq[i]
    local flag = p(elem,i)
        if flag == true  then elem:select()
    elseif flag == false then elem:deselect() end
  end
  return seq
end

local function tie (seq1, seq2)
  -- e.g. LHCB1:tie(LHCB2)
  assert(seq2.is_sequence == true, "invalid argument #2 (sequence expected)")
  local shrd1, shrd2 = {}, {}
  for i1,e1 in ipairs(seq1) do
    local name = e1.name
    local e2 = seq2[name]
    if e2 ~= nil then
      assert(e1.is_element == true, "invalid shared element (must be unique)")
      assert(e2.is_element == true, "invalid shared element (must be unique)")
      local i2 = find_idx(seq2, e2, i1) or find_idx(seq2, e2)
      local id = ident(name)
      seq1[name] = e1( {at = e1:get_raw 'at', from = e1:get_raw 'from'} )
      seq2[name] = e1( {at = e2:get_raw 'at', from = e2:get_raw 'from'} )
      seq1[id] = seq1[name]
      seq2[id] = seq2[name]
      seq1[i1] = seq1[name]
      seq2[i2] = seq2[name]
      shrd1[name] = e1
      shrd2[name] = e2
      e1.at, e1.from = nil, nil
      e2.at, e2.from = nil, nil
    end
  end
  return seq1, { [ident(seq1.name)] = shrd1, [ident(seq2.name)] = shrd2 }
end

-- attributes -----------------------------------------------------------------o

sequence:set_variable {
  s_pos = \s -> s[_pos]
}

-- methods --------------------------------------------------------------------o

sequence:set_function {
  range_index  = range_index,
  index_of     = index_of,
  spos_of      = spos_of,
  foreach      = foreach,
  filter       = filter,
  select       = select,
  is_selected := error("invalid sequence operation"),
  deselect    := error("invalid sequence operation"),
  tie          = tie,
}

MAD.utility.defhelp(M) -- todo: per function help -> 'sequence'

-- sequence and bline are elements
MAD.element.sequence = sequence
MAD.element.bline    = sequence

-- end -------------------------------------------------------------------------
return {
  sequence = sequence,
  bline    = sequence,

  __help   = M.__help,
}

--[=[
--------------------------------------------------------------------------------
-- TODO ------------------------------------------------------------------------
--------------------------------------------------------------------------------

--[[ SEQUENCE
local function adjust_length (seq)
  local last = seq[#seq]
  if not seq.length or seq.length < last.s_pos + last.length then
    seq.length = last.s_pos + last.length
  end
end

---  if elem:get_raw('sequence') ~= nil then
--    seq_error("already assigned element detected", seq, elem, idx)
--  end
--  elem.sequence = seq

-- concatenation
function M.__add(sequ, a)
  return sequ:add(a)
end

-- methods
function M:add(a, at, from, refer)
  if at or not a.at then add_item(self, a, at, from, refer)                 -- positional params
  elseif is_list(a) then add_item(self, a.item or a[1], a.at, a.from, a.refer)   -- named params
  else error("invalid set of parameters in incremental construction of sequence '"..self.name.."'")
  end
  return self
end

function M:set(a)
  self[1] = nil -- clear sequence
  copy_fields(self, a, sequence_fields)
  add_element(self, start_marker, 0)
  add_list   (self, a)
  return self:done()
end

function M:done()
  add_element   (self, end_marker, self.length)
  sequence_spos (self)
  adjust_length (self)
  clean_sequence(self)
  return self
end
]]

--[[ SEQUENCE DISPLAY
local function show_fields(t, lst)
  local a, k, s
  lst = lst or sequence_fields
  for _,v in ipairs(lst) do
    if is_list(v) then k, s = v[1], v[2] else k, s = v, v end
    a = t[k]
    if a then io.write(', ', s, '= ', tostring(a)) end
  end
end

function M:show(disp)
  io.write("sequence '", self.name,"' { ")
  show_list(self, disp)
  io.write(' }\n')
  for _,v in ipairs(self) do v:show(disp) end
  io.write('endsequence\n')
end

function M:show_madx(disp)
  io.write("'", self.name, "': sequence, ")
  show_list(self, disp)
  io.write(';\n')
  for _,v in ipairs(self) do v:show_madx(disp) end
  io.write('endsequence;\n')
end
]]

--[[
local function flatten(self, name)
  local t = { name=name or self.name }

  for i,v in ipairs(self) do
    if type(v) == 'function' then v = v() end
    if v.is_sequence then
      add_sequence(t, v)
    elseif v.is_element then
      add_element(t, v)
    elseif v.is_line then
      add_line(t, v)
    else
      error('invalid sequence element at slot '..i)
    end
  end

  return localise(t)
end
--]]

-- geometry -- TODO: at, from, refer
local function localise(self, start)
  local s_pos = start and v[start].s_pos or 0
  for i=start or 1,#self do
    self[i].s_pos = s_pos
    if self[i].length then s_pos = s_pos + self[i].length end
  end
  if not self.length then self.length = s_pos end
  return self
end

local function insert_element_key(self, elem)
  local name = elem.name              -- dict part
  local ref = self[name]
  if ref == nil then                  -- not yet registered
    self[name] = elem
  elseif ref.is_element then          -- already one element
    self[name] = ref.i_pos < elem.i_pos and {ref, elem} or {elem, ref}
  else                                -- already many elements
    table.insert(ref, find_index_by_idx(ref, elem.i_pos), elem)
  end
end

local function remove_element_key(self, elem)
  local name = elem.name              -- dict part
  local ref = self[name]
  if ref.is_element then              -- single element
    self[name] = nil
  else                                -- list of elements
    table.remove(ref, find_index_by_ref(ref, elem))
    if #ref == 1 then self[name] = ref[1] end -- was a pair
  end
end

-- edition -- TODO: check s_pos and length
local function insert_element(self, elem, before)
  test_membership(self, before)
  local i = before.i_pos
  table.insert(self, i, elem)
  update_index(self, i)
  insert_element_key(self, elem)
end

local function remove_element(self, elem)
  test_membership(self, elem)
  local i = elem.i_pos
  remove_element_key(self, elem)
  table.remove(self, i)
  update_index(self, i)
end

local function replace_element(self, old_elem, new_elem)
  test_membership(self, old_elem)
  local i = old_elem.i_pos
  self[i] = new_elem
  new_elem.i_pos = i
  remove_element_key(self, elem)
  insert_element_key(self, elem)
end

local function swap_elements(self, elem1, elem2, update_key)
  test_membership(self, elem1)
  test_membership(self, elem2)
  local i1, i2 = elem1.i_pos, elem2.i_pos
  self[i1], self[i2] = elem2, elem1
  elem1.i_pos, elem2.i_pos = i2, i1
  if update_key then
    remove_element_key(self, elem1)
    remove_element_key(self, elem2)
    insert_element_key(self, elem1)
    insert_element_key(self, elem2)
  end
end

function M:remove(a, count) -- TODO
  if type(a) == 'string' then
    a = self[a]
    if is_list(a) then a = a[count or 1] end
  end
  remove_element(self, a)
end

function M:insert(a, at, count) -- TODO
  if type(at) == 'string' then
    at = self[at]
    if is_list(at) then at = at[count or 1] end
  elseif type(at) == 'number' then
    at = self[find_index_by_pos(self, at)]
  end
  insert_element(self, a, at)
end
--]=]
