--[=[
 o-----------------------------------------------------------------------------o
 |
 | Sequence module
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide sequence object to define lattices

 o-----------------------------------------------------------------------------o
]=]

local M = {}

-- module ---------------------------------------------------------------------o

local __help = {}
__help.sequence = [=[
NAME
  sequence -- build sequences

SYNOPSIS
  seq = sequence 'name' { attribute-list, element-list... }

DESCRIPTION
  TODO

RETURN VALUE

EXAMPLE
  see LHC sequences

SEE ALSO
  element.
]=]

__help["sequence: seqedit"] = [=[
Sequence edition:
-----------------
  seqedit:    n/a
  flatten:    n/a
  cycle:      n/a
  endedit:    n/a

  seq:insert  { elem1, elem2, ..., deep=true }
  seq:remove  { name1, name2, ..., range=range|'selected' }
  seq:move    { name1, name2, ..., range=range|'selected', by=ds }
  seq:replace { name1=elem1, name2=elem2, ... }
  seq:extract { range=range|'selected' }    (return a table, not a sequence)

  seq:reflect()
  seq:save()
  seq:dump()

  remove from s1 to s2:
  - select elements with s1 <= s_pos <= s2
  - remove selected
]=]

__help["sequence: indexes and ranges"] = [=[
Indexes:
--------
  - element (object)
    + element.name & count
  - index (number)
    + number <0 means starts from end (i.e. #seq-idx+1)
  - name (string)
    + name                (exact)
    + name[count]         (exact with occurences count)
    + name{count} & index (closest with occurences count starting from index)
    + #s or #S (index=1), #e or #E (index=-1)

Ranges:
-------
  - index                 (single, equivalent to {index,index})
  - {start,stop}
  - "start/stop"
  - support start > stop
]=]

-- locals ---------------------------------------------------------------------o

local abs                                                  in math
local vector                                               in MAD
local is_nil, is_number, is_string, is_rawtable, is_object in MAD.typeid
local is_iterable, is_callable                             in MAD.concept
local Element                                              in MAD.element
local minlen                                               in MAD.constant

-- definitions ----------------------------------------------------------------o

-- hidden keys: elements indexes, elements positions, elements entry positions.
local _eidx, _epos, _spos = {}, {}, {}
local _lastfrom, _lastfrompos = {}, {}

-- special numerical value for elements positions.
local uninitialized = -1e9
local ongoing_init  = -2e9
local maximum_dist  =  2e9 -- to find the closest

-- default sequence
local sequence = Element 'sequence' {
  kind='sequence', is_sequence=true, direction=1, refer='centre', l=0,
}

local sequence_init, sequence_len, elem_pos -- forward declarations

sequence:set_metamethod({
  __init = \s -> sequence_init(s),
  __len  = \s -> sequence_len (s),
}, true)

local function seq_error (msg, sequ, idx, elem)
    error(msg .. " in sequence '"  .. sequ.name
              .. "' for element '" .. (elem and elem.name or sequ[idx].name)
              .. "' at index "     .. (idx or '?'))
end

-- helpers --------------------------------------------------------------------o

local function is_element(a)
  return is_object(a) and a.is_element == true
end

-- dictionnary { key=nil|val|{val1,...} }
local function add_to (to, a)
  if is_nil(to)          then return      a  end  -- none -> element
  if not is_rawtable(to) then return {to, a} end  -- one  -> table
  to[#to+1] = a               return  to          -- many -> append
end

local function repl_by (to, a, b)
  if not is_rawtable(to) then  return b  end      -- none or one
  for i=1,#to do
    if to[i] == a then to[i]=b return to end      -- many -> replace
  end
  to[#to+1] = b                return to          -- many -> append
end

-- get element index (linear)
local function efind_idx (seq, e, idx_, cnt_)
  if e ~= nil then
    local start, stop, step = idx_ or 1
    if start > 0
    then stop, step = #seq, 1
    else stop, step, start = 1, -1, -start
    end
    local cnt = cnt_ or 1
    for i=start,stop,step do  -- linear search
      if seq[i] == e then
        if cnt == 1 then return i end
        cnt = cnt - 1
      end
    end
  end
  return nil
end

-- get element index (direct)
local function find_idx (seq, e, cnt_)
  local idx = seq[_eidx][e]
  if is_rawtable(idx) then return idx[cnt_] end
  return idx
end

local function index_of_num (seq, n)
  local len = #seq
  if n < 0 then n = len+n+1 end -- reflect
  if n < 1 or n > len then return nil end
  return n
end

local function index_of_str (seq, s, idx_)
  local i, j, name, del = string.find(s, "([^[{/]+)([[{]?)")
  assert(name ~= nil and i == 1, "invalid format (name expected)")
  local elem = seq[name]                           -- get element
  if is_nil(elem) then return nil end              -- not found
  if del == '' then return find_idx(seq, elem) end -- index of "name"
  local rel, cnt
  if del == '['                                    -- get count
  then i, j, cnt = string.find(s, "[(%d+)]", j)
  else i, j, cnt = string.find(s, "{(%d+)}", j) ; rel = true
  end
  cnt = assert(tonumber(cnt), "invalid count format (bracketed integer expected)")
  if not rel
  then return  find_idx(seq, elem,       cnt)      -- index of "name[n]"
  else return efind_idx(seq, elem, idx_, cnt)      -- index of "name{n}"
  end
end

-- get index from signed index, strings or element
local function index_of (seq, a, idx_)
  if is_number(a) then
    return index_of_num(seq, a)
  end
  if is_string(a) then
    return index_of_str(seq, a, idx_)
  end
  assert(is_element(a), "invalid argument #2 (index, string or element expected)")
  return find_idx(seq, seq[a.name], idx_)
end

-- get closest index from s position (linear)
local function sindex_of (seq, s, idx_)
  local s_pos = seq.s_pos
  local start, stop, step = idx_ or 1
  if start > 0
  then stop, step = #seq, 1
  else stop, step, start = 1, -1, -start
  end
  local smin = maximum_dist
  for i=start,stop,step do
    local d = abs(s_pos[i]-s)
    if d > smin then return i-1 end
    smin = d
  end
  return nil
end

local function from_pos (seq, from, idx_)
  if seq[_lastfrom] ~= from then -- TODO: from should be unique?
    seq[_lastfrom   ] = from
    seq[_lastfrompos] = elem_pos(seq, index_of(seq, from, idx_))
  end
  return seq[_lastfrompos]
end

-- build helper ---------------------------------------------------------------o

-- refpos (sequence)
local function sequ_rpos (sequ)
  local rpos = sequ.refpos
  if rpos == nil then return 0 end
  local idx = sequ:index_of(rpos)
  return sequ.e_pos[idx]
end

-- compute s positions of sequence elements
function elem_pos (sequ, idx, elem_)
  local pos = sequ.e_pos[idx]
  if pos >= 0 and is_nil(elem_) then return pos end
  if pos == ongoing_init then
    seq_error("cycling dependencies detected", sequ, idx, elem_)
  elseif pos ~= uninitialized then
    seq_error("corrupted s-position detected", sequ, idx, elem_)
  end

  sequ.e_pos[idx] = ongoing_init
  local elem = elem_ or sequ[idx]
  pos = elem.at or 0

  local from = elem.from or elem.at and 'start' or 'prev'
  local fidx = elem.is_sequence ~= true and idx+1 or idx+#elem -- forward index

      if from == 'start' then -- nothing
  elseif from == 'end'   then pos = sequ.l - pos
  elseif from == 'prev'  then pos = pos + (idx  > 1     and elem_pos(sequ,idx-1)+sequ[idx-1].l or 0)
  elseif from == 'next'  then pos = pos + (fidx < #sequ and elem_pos(sequ,fidx) or sequ.l)
  elseif sequ[from]      then pos = pos + from_pos(sequ, from)
  else seq_error("invalid from of '" .. from .. "'", sequ, idx)
  end

  local refer, rpos
  if elem.is_sequence ~= true
  then refer = elem.refer or sequ.refer
  else refer = elem.refpos and 'refpos' or sequ.refer
  end
      if refer == 'entry'  then rpos = 0
  elseif refer == 'centre' then rpos = elem.l/2
  elseif refer == 'exit'   then rpos = elem.l
  elseif refer == 'refpos' then rpos = sequ_rpos(elem)
  else seq_error("invalid refer to '" .. refer .. "'", sequ, idx)
  end

  sequ.e_pos[idx] = pos
  sequ.s_pos[idx] = pos - rpos
  return pos, rpos
end

-- compute s positions of sub sequence elements
local function sequ_pos (sequ, sseq, idx)
  local elem, pos, rpos
  elem, sequ[idx] = sequ[idx], sseq -- find subsequence position
  sequ[idx], pos, rpos = elem, elem_pos(sequ, idx) -- TODO: cleaner approach
  pos = pos - rpos                  -- shift by subsequence refpos
  for i=1,#sseq do
    sequ.e_pos[i+idx-1] = sseq.e_pos[i] + pos
    sequ.s_pos[i+idx-1] = sseq.s_pos[i] + pos
    assert(sequ[i+idx-1] == sseq[i], "unexpected corrupted flat sequence")
  end
  return pos
end

-- copy sub sequence
local function copy_sequ (sequ, flat, sref, k)
  local k0 = k
  for i=1,#sequ do
    k, flat[k], sref[k] = k+1, sequ[i], false
  end
  if k ~= k0 then sref[k0] = sequ end -- keep a link of the subsequence
  return k
end

-- flatten lines and sub sequence
local function flatten_line (line, flat, sref, k, rev)
  local n = (line.__rep or 1) * rev
  local start, stop, step, elem

  if n < 0
  then n, start, stop, step = -n, #line,     1, -1
  else n, start, stop, step =  n, 1    , #line,  1
  end

  for i = 1,n do
    for idx = start,stop,step do
      elem = line[idx]
      if is_rawtable(elem) or elem.is_bline == true then
        k = flatten_line(elem, flat, sref, k, step)
      elseif elem.is_sequence == true then
        k = copy_sequ   (elem, flat, sref, k)
      elseif elem.is_element == true then
        k, flat[k], sref[k] = k+1, elem, false
      else
        seq_error("invalid element detected", line, idx)
      end
    end
  end
  return k
end

-- flatten sequence
local function flatten_sequ (sequ, flat, sref)
  local k, n = 1, #sequ
  for i=1,n do
    local elem = sequ[i]
    if is_rawtable(elem) or elem.is_bline == true then
      k = flatten_line(elem, flat, sref, k, 1)
    elseif elem.is_sequence == true then
      k = copy_sequ   (elem, flat, sref, k)
    elseif elem.is_element == true then
      k, flat[k], sref[k] = k+1, elem, false
    else
      seq_error("invalid element detected", sequ, idx)
    end
  end
  assert(n+1 <= k and #flat == #sref, "unexpected corrupted flat sequence")
end

-- build sequence and dictionnaries
local function build_sequ (sequ, flat)
  local eidx = {}
  for idx,elem in ipairs(flat) do
    local name = elem.name
    sequ[idx ] = elem                         -- array part
    sequ[name] = add_to(sequ[name], elem)     -- dict name->elem
    eidx[elem] = add_to(eidx[elem], idx )     -- dict elem->index
  end
  sequ[_eidx] = eidx
  assert(#sequ == #flat, "unexpected corrupted flat sequence")
end

-- compute elements positions
local function build_pos (sequ, sref)
  assert(#sequ == #sref,  "unexpected corrupted flat sequence")
  sequ[_epos] = vector(#sref):ones(uninitialized)
  sequ[_spos] = vector(#sref)
  local idx, len, pos = 1, #sref, 0
  while idx <= len do
    if sref[idx] == false then    -- element
      elem_pos(sequ, idx)
      if pos-minlen > sequ.s_pos[idx] then
        seq_error(string.format(
          "invalid element position at s = %.6gm (negative drift %.6gm)",
          sequ.s_pos[idx], sequ.s_pos[idx]-pos), sequ, idx)
      end
      pos = sequ.s_pos[idx] + sequ[idx].l
      idx = idx + 1
    else                          -- subsequence
      local sseq = sref[idx]
      sequ_pos(sequ, sseq, idx)
      if pos-minlen > sequ.s_pos[idx] then
        seq_error(string.format(
          "invalid subsequence position at s = %.6gm (negative drift %.6gm)",
          sequ.s_pos[idx], sequ.s_pos[idx]-pos), sequ, idx)
      end
      pos = sequ.s_pos[idx] - sseq.s_pos[1] + sseq.l
      idx = idx + #sseq
    end
  end
  assert(len+1 == idx, "unexpected corrupted flat sequence")
end

local function finish_sequ (sequ)
  local n = sequ:rawlen()

  -- aliases for 1st and last element
  sequ['#s'], sequ['#S'] = sequ[1], sequ[1]
  sequ['#e'], sequ['#E'] = sequ[n], sequ[n]

  -- adjust length
  local len = sequ.s_pos[n] + sequ[n].l
  if sequ.l < len then sequ.l = len end

  -- clear from cache
  sequ[_lastfrom], sequ[_lastfrompos] = nil, nil
end

-- forwarded meta-functions ---------------------------------------------------o

function sequence_len (sequ)
  local len = 0
  while sequ ~= sequence do
    len = sequ:rawlen()
    if len ~= 0 then return len end
    sequ = sequ.parent
  end
  return 0
end

-- sequence init (build)
function sequence_init (sequ)
  assert(#sequ > 0, "invalid argument #1 (non-empty sequence expected)")
  if sequ:rawlen() == 0 then return sequ end -- inheritance (already built)

  local flat, sref = {}, {}
  flatten_sequ (sequ, flat, sref)
  build_sequ   (sequ, flat)
  build_pos    (sequ, sref)
  finish_sequ  (sequ)
  return sequ:set_readonly()
end

-- methods --------------------------------------------------------------------o

local function range_index (seq, rng)
  local start, stop
  if is_string(rng) then
    start, stop = string.match(rng, "([^/]+)/?(.*)")
    if string.match(start, "%d+") then start = tonumber(start) end
    if string.match(stop , "%d+") then stop  = tonumber(stop ) end
  else
    start = is_iterable(rng) and rng[1] or rng or 1
    stop  = is_iterable(rng) and rng[2] or rng or #seq
  end
  start = assert(index_of(seq, start), "invalid range start")
  stop  = assert(index_of(seq, stop ), "invalid range stop" )
  assert(start <= stop, "invalid range, start > stop")
  return start, stop
end

local function pos_of (seq, elem, start_)
  local idx = index_of(seq, elem, start_)
  assert(is_number(idx), "invalid argument #2 (valid key expected)")
  return seq[_epos][idx]
end

local function spos_of (seq, elem, start_)
  local idx = index_of(seq, elem, start_)
  assert(is_number(idx), "invalid argument #2 (valid key expected)")
  return seq[_spos][idx]
end

local function foreach (seq, f, rng_)
  assert(is_callable(f), "invalid argument #2 (callable expected)")
  local start, stop = range_index(seq, rng_)
  for i=start,stop do f(seq[i],i) end
  return seq
end

local function filter (seq, p, rng_)
  assert(is_callable(p), "invalid argument #2 (callable expected)")
  local r, start, stop = {}, range_index(seq, rng_)
  for i=start,stop do
    if p(seq[i],i) == true then r[#r+1] = seq[i] end
  end
  return r
end

local function select (seq, p, rng_)
  assert(is_callable(p), "invalid argument #2 (callable expected)")
  local start, stop = range_index(seq, rng_)
  for i=start,stop do
    local elem = seq[i]
    local flag = p(elem,i)
        if flag == true  then elem:  select()
    elseif flag == false then elem:deselect() end
  end
  return seq
end

-- Note: functions below need to update dicts...

local function unique (seq)
  seq:set_readonly(false)
  for _,idx in pairs(seq[_eidx]) do -- search duplicates
    if is_rawtable(idx) then cnt[#cnt+1] = idx end
  end
  for e=1,#cnt do                   -- foreach duplicate
    local elem = seq[e[1]]
    local name = elem.name
    for i=1,#cnt[e] do              -- clone references
      assert(seq[i] == elem, "unexpected corrupted dictionnary")
      local c = elem {}             -- clone
      seq[i], seq[_eidx][c] = c, i
      seq[name] = repl_by(seq[name], elem, c)
    end
    seq[_eidx][elem] = nil
  end
  seq:set_readonly()
  return seq
end

local function tie (seq1, seq2) -- e.g. lhcb1:tie(lhcb2)
  assert(seq2.is_sequence == true, "invalid argument #2 (sequence expected)")
  seq1:set_readonly(false) seq2:set_readonly(false)
  local shrd1, shrd2 = {}, {}
  for i1=1,#seq1 do
    local e1 = seq1[i1]
    local name = e1.name
    local e2 = seq2[name]
    if e2 ~= nil then
      assert(e1.is_element == true, "invalid shared element (must be unique)")
      assert(e2.is_element == true, "invalid shared element (must be unique)")
      local i2 = find_idx(seq2, e2)
      local c1 = e1 { at=e1:rawget'at', from=e1:rawget'from' } -- clone
      local c2 = e1 { at=e2:rawget'at', from=e2:rawget'from' } -- clone
      -- update name->elem dict
      seq1[name], seq1[i1] = c1, c1
      seq2[name], seq2[i2] = c2, c2
      -- update elem->index dict
      seq1[_eidx][c1], seq1[_eidx][e1] = seq1[_eidx][e1], nil
      seq2[_eidx][c2], seq2[_eidx][e2] = seq2[_eidx][e2], nil
      -- save shared
      shrd1[name], shrd2[name] = e1, e2
      e1.at, e1.from = nil, nil
      e2.at, e2.from = nil, nil
    end
  end
  seq1:set_readonly() seq2:set_readonly()
  return seq1, { [seq1] = shrd1, [seq2] = shrd2 }
end

-- env ------------------------------------------------------------------------o

MAD.element.sequence = sequence

-- members --------------------------------------------------------------------o

local ffalse =\ false

sequence:set_variable {
  s_pos = \s -> s[_spos],
  e_pos = \s -> s[_epos],

} :set_function {
  pos_of       = pos_of,
  spos_of      = spos_of,
  index_of     = index_of,
  sindex_of    = sindex_of,
  range_index  = range_index,
  foreach      = foreach,
  filter       = filter,
  select       = select,
  deselect     = \s,r -> s:select(ffalse, r),
  is_selected := error("invalid sequence operation"),
--  identifier   = identifier,
  unique       = unique,
  tie          = tie,

} :set_readonly()

-- end -------------------------------------------------------------------------
return {
  sequence = sequence,
  __help   = __help,
}

--[=[
--------------------------------------------------------------------------------
-- TODO ------------------------------------------------------------------------
--------------------------------------------------------------------------------

--[[
local function show_fields(t, lst)
  local a, k, s
  lst = lst or sequence_fields
  for _,v in ipairs(lst) do
    if is_list(v) then k, s = v[1], v[2] else k, s = v, v end
    a = t[k]
    if a then io.write(', ', s, '= ', tostring(a)) end
  end
end

function M:show(disp)
  io.write("sequence '", self.name,"' { ")
  show_list(self, disp)
  io.write(' }\n')
  for _,v in ipairs(self) do v:show(disp) end
  io.write('endsequence\n')
end

function M:show_madx(disp)
  io.write("'", self.name, "': sequence, ")
  show_list(self, disp)
  io.write(';\n')
  for _,v in ipairs(self) do v:show_madx(disp) end
  io.write('endsequence;\n')
end

local function identifier (seq, cvt_)
  local cvt = cvt_ or \s -> string.gsub(string.lower(s), '[^%l%d_]', '_')
  for i=1,#seq do
    local name = seq[i].name
    local knam = cvt(name)
    if name ~= knam then sequ[knam] = sequ[name] end
  end
  return seq
end
]]

--[[ SEQUENCE DISPLAY
local function show_fields(t, lst)
  local a, k, s
  lst = lst or sequence_fields
  for _,v in ipairs(lst) do
    if is_list(v) then k, s = v[1], v[2] else k, s = v, v end
    a = t[k]
    if a then io.write(', ', s, '= ', tostring(a)) end
  end
end

function M:show(disp)
  io.write("sequence '", self.name,"' { ")
  show_list(self, disp)
  io.write(' }\n')
  for _,v in ipairs(self) do v:show(disp) end
  io.write('endsequence\n')
end

function M:show_madx(disp)
  io.write("'", self.name, "': sequence, ")
  show_list(self, disp)
  io.write(';\n')
  for _,v in ipairs(self) do v:show_madx(disp) end
  io.write('endsequence;\n')
end
]]

-- edition -- TODO: check s_pos and length
local function insert_element(self, elem, before)
  test_membership(self, before)
  local i = before.i_pos
  table.insert(self, i, elem)
  update_index(self, i)
  insert_element_key(self, elem)
end

local function remove_element(self, elem)
  test_membership(self, elem)
  local i = elem.i_pos
  remove_element_key(self, elem)
  table.remove(self, i)
  update_index(self, i)
end

local function replace_element(self, old_elem, new_elem)
  test_membership(self, old_elem)
  local i = old_elem.i_pos
  self[i] = new_elem
  new_elem.i_pos = i
  remove_element_key(self, elem)
  insert_element_key(self, elem)
end

local function swap_elements(self, elem1, elem2, update_key)
  test_membership(self, elem1)
  test_membership(self, elem2)
  local i1, i2 = elem1.i_pos, elem2.i_pos
  self[i1], self[i2] = elem2, elem1
  elem1.i_pos, elem2.i_pos = i2, i1
  if update_key then
    remove_element_key(self, elem1)
    remove_element_key(self, elem2)
    insert_element_key(self, elem1)
    insert_element_key(self, elem2)
  end
end
--]=]
