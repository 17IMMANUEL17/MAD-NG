--[=[
 o-----------------------------------------------------------------------------o
 |
 | Sequence module
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide sequence object to define lattices

 o-----------------------------------------------------------------------------o
]=]

local M = {}

-- locals ---------------------------------------------------------------------o

local second, bind1st, bind2nd, bind2st                          in MAD.gfunc
local sub, ltrue, lfalse                                         in MAD.operator
local sequence, marker, flags                                    in MAD.element
local minlen                                                     in MAD.constant
local strtrim, strsplit, strbracket, bsearch, errorf             in MAD.utility
local is_nil, is_boolean, is_number, is_integer, is_decimal,
      is_string, is_table, is_rawtable, is_iterable, is_callable,
      is_range, is_element, is_instanceOf, set_concept, concept  in MAD.typeid
local not_mappable, not_extendable, not_mutable                  in concept

local abs in math

-- backup original methods and metamethods
local sequence_mt = getmetatable(sequence)
local var_raw, var_val = sequence.var_raw, sequence.var_val
local var_get, var_set = sequence_mt.__index, sequence_mt.__newindex
local raw_get, seq_cpy = sequence.raw_get, sequence.copy
local parent           = sequence.parent

-- root object ----------------------------------------------------------------o

-- hidden key.
local _data = {}

-- defined in elements
sequence :set { direction=1, refer='centre', l=0,
                [_data]={eidx={}, spos={}, epos={}, n=0} }

local function is_sequence (a)
  return is_table(a) and a[_data] ~= nil
end

local function is_owner (a)
  return raw_get(a, _data) ~= nil
end

local function is_view (a)
  return raw_get(a, _data) == nil
end

-- definitions ----------------------------------------------------------------o

-- forward declarations
local elem_pos

-- special numerical value for elements positions.
local uninitialized = -1e9
local ongoing_init  = -2e9

-- start and end markers
local mkstart = marker '$start' { at=0 } : set_readonly()
local mkend   = marker '$end'   {      } : set_readonly()

-- sanity checks --------------------------------------------------------------o

local function seq_error (msg, seq, idx, nam)
  error(msg .. " in sequence '"  .. (seq.__id or '?')
            .. "' for element '" .. (nam      or '?')
            .. "' at index "     .. (idx      or '?'), 2)
end

local function seq_poserr (typ, seq, idx, pos)
  local elem = var_raw(seq,_data)
  local msg = string.format(
    "invalid %s position at s = %.6gm (negative drift %.6gm)",
    typ, elem.spos[idx], elem.spos[idx]-pos)
  seq_error(msg, seq, idx, elem[idx].__id)
end

-- check sequence $start and $stop integrity
local function check_mark (seq)
  local elem = var_raw(seq,_data)
  local n = elem.ne
      if elem[1].__id ~= mkstart.__id or elem[1].is_marker ~= true then
    error("invalid sequence first element ($start marker expected)", 2)
  elseif elem[n].__id ~= mkend  .__id or elem[n].is_marker ~= true then
    error("invalid sequence last element ($end marker expected)", 2)
  end
end

-- check sequence spos and elements overlapp
local function check_spos (seq)
  local elem = var_raw(seq,_data)
  for i=1,elem.ne-1 do
    local ds = elem.spos[i+1] - (elem.spos[i]+elem[i].l)
    if ds < -minlen then
      seq_poserr("element", seq, i, elem.spos[i]-ds)
    end
  end
end

-- check dictionnary of name -> idx
local function check_index (seq)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  local elem = var_raw(seq,_data)
  local eidx = elem.eidx
  local s, e, S, E = eidx['#s'], eidx['#e'], eidx['#S'], eidx['#E']
  assert(is_number(s) and is_number(e) and is_number(S) and is_number(E),
         "unexpected reuse of #s/#e or #S/#E start/stop markers names")

  eidx['#s'], eidx['#e'], eidx['#S'], eidx['#E'] = nil

  -- check dict vs elem: name -> index or table of indexes
  for en,ei in pairs(eidx) do
    if is_number(ei) then
      assert(elem[ei].__id == en     , "unexpected corrupted dictionnary")
    elseif is_table(ei) then
      assert(elem[ei[1]].__id == en  , "unexpected corrupted dictionnary")
      assert(ei.n             >= 2   , "unexpected corrupted dictionnary")
      for i=2,ei.n do
        assert(ei[i-1] < ei[i]       , "unexpected corrupted dictionnary")
        assert(elem[ei[i]].__id == en, "unexpected corrupted dictionnary")
      end
    else
      error("unexpected corrupted dictionnary")
    end
  end

  -- check elem vs dict: name -> index or table of indexes
  for i=1,elem.ne do
    local ei = eidx[elem[i].__id]
    if is_number(ei) then
      assert(ei == i                 , "unexpected corrupted dictionnary")
    elseif is_table(ei) then
      local ii
      for j=1,ei.n do
        if ei[j] >= i then ii = ei[j] ; break end
      end
      assert(ii == i                 , "unexpected corrupted dictionnary")
    else
      error("unexpected corrupted dictionnary")
    end
  end

  eidx['#s'], eidx['#e'], eidx['#S'], eidx['#E'] = s, e, S, E
end

--[=[
local function dumpseq (seq)
  local fmt = MAD.option.format
  MAD.option.format = "%.5g"
  print()
  print('sequence:', seq.name, 'l=', seq.l)
  print('i', 'name', 'L', 'S (s)', 'S (e)')
  seq:foreach \e,i -> print(i, e.__id, e.l, seq:spos(i), seq:epos(i))
  MAD.option.format = fmt
end
]=]

-- helper for mangled names and elements indexes (same as mtable) -------------o

-- reflect indexes
local function reflect (i, n)
  return i < 0 and n+i+1 or i
end

-- canonize index (direct)
local function index_of_idx (seq, idx)
  local n = var_raw(seq,_data).ne
  idx = reflect(idx, n)
  return idx >= 1 and idx <= n and idx or nil
end

-- get index from s-position (binary)
local function index_of_num (seq, num)
  local l = seq.l
  if num < 0 then num = l+num end -- reflect
  if num < 0 or num > l then return nil end
  return bsearch(var_raw(seq,_data).spos, num)
end

-- get index from name [with absolute count] (direct)
local function index_of_cnam (seq, nam, cnt)
  local ei = var_raw(seq,_data).eidx[nam]
  if is_table(ei) then
    return ei[ reflect(cnt, ei.n) ]
  elseif cnt == 1 or cnt == -1 then
    return ei
  end
  return nil
end

-- get index from name [with relative count] (linear)
local function index_of_rnam (seq, nam, cnt, ref)
  local ei = var_raw(seq,_data).eidx[nam]
  if is_nil(ei) then return nil end
  assert(is_integer(ref), "invalid reference index (integer expected)")
  local idx = assert(index_of_idx(seq, ref), "invalid reference index")
  if is_number(ei) then
    return (cnt ==  1 and ei >= idx and ei) or
           (cnt == -1 and ei <= idx and ei) or nil
  end
  if cnt > 0 then
    for i=1,ei.n do
      if ei[i] >= idx then return ei[i+cnt-1] end
    end
  elseif cnt_ < 0 then
    for i=ei.n,1,-1 do
      if ei[i] <= idx then return ei[i+cnt+1] end
    end
  end
  return nil
end

-- get index from [mangled] name or s-position (direct or linear)
local function index_of_str (seq, str, ref_)
  local num = tonumber(str)
  if num then return index_of_num(seq, num) end
  local nam, cnt, _, bra = strbracket(str)
  cnt = is_nil(cnt) and 1 or tonumber(cnt)
  assert(is_integer(cnt) and cnt ~= 0, "invalid argument #2 (non-zero count expected)")
  if is_nil(ref_) or bra == 1 then
    return index_of_cnam(seq, nam, cnt      )
  else
    return index_of_rnam(seq, nam, cnt, ref_)
  end
end

-- get index from 'from' [mangled] name (direct or linear)
local function index_of_fnam (seq, nam, ref_)
  assert(is_string(nam), "invalid argument #2 (string expected)")
  local nam, cnt, _, bra = strbracket(nam)
  cnt = is_nil(cnt) and 1 or tonumber(cnt)
  assert(is_integer(cnt) and cnt ~= 0, "invalid argument #2 (non-zero count expected)")
  if is_nil(ref_) or bra ~= 2 then -- need both for relative from
    return index_of_cnam(seq, nam, cnt      ), bra
  else
    return index_of_rnam(seq, nam, cnt, ref_), bra
  end
end

-- get index from element (linear)
local function index_of_elm (seq, elm, ref_)
  local nam, elem = elm.__id, var_raw(seq,_data)
  local ei = elem.eidx[nam]
  if is_nil(ei) then return nil end
  ref_ = ref_ or 1
  assert(is_integer(ref_), "invalid reference index (integer expected)")
  local idx = assert(index_of_idx(seq, ref_), "invalid reference index")
  if is_number(ei) then
    return ei >= idx and elem[ei] == elm and ei or nil
  end
  for i=1,ei.n do
    if ei[i] >= idx and elem[ei[i]] == elm then return ei[i] end
  end
  return nil
end

-- get [mangled] name from index (linear)
local function name_of_idx (seq, idx, ref_)
  local elem = var_raw(seq,_data)
  idx = index_of_idx(seq, idx)
  if is_nil(idx) then return nil end
  local nam = elem[idx].__id
  local ei = elem.eidx[nam]
  if is_number(ei) then
    assert(ei == idx, "unexpected corrupted dictionnary")
    return nam
  end

  local cnt, b1, b2 = 0
  if ref_ then
    assert(is_integer(ref_), "invalid reference index (integer expected)")
    local idx = assert(index_of_idx(seq, ref_), "invalid reference index")
    for i=1,ei.n do
      if ei[i] < idx then cnt = cnt+1 else break end
    end
    b1, b2 = "{", "}"
  else
    b1, b2 = "[", "]"
  end

  for i=1,ei.n do
    if ei[i] == idx then
      if cnt >= i then cnt = cnt+1 end
      return string.format("%s%s%d%s", nam, b1, i-cnt, b2)
    end
  end
  error("unexpected corrupted dictionnary")
end

-- position helpers -----------------------------------------------------------o

-- return e-position of 'from', memoize result if count is not relative
local function from_epos (seq, from, idx)
  local elem = var_raw(seq,_data)
  if elem.last_from ~= from then                     -- memoized?
    local idx, bra = index_of_fnam(seq, from, idx)
    if is_nil(idx) then                              -- not found
      seq_error("invalid from of '" .. from .. "'", seq)
    end
    elem.last_frompos = second(elem_pos(seq, idx))
    elem.last_from = bra ~= 2 and from or nil        -- memoize if not relative
  end
  return elem.last_frompos                           -- epos
end

-- return e-position of 'refpos'
local function refpos_epos (seq)
  local rpos = seq.refpos
  if is_nil(rpos) then return 0 end
  return from_epos(seq, rpos)
end

-- forward index
-- return (#elm-1)+1 because seq[idx] == sseq[2] (see copy_ssequ and sequ_pos).
local function fidx (elm)
  return is_sequence(elm) and #elm or 1
end

-- return s-position of 'from'
local function from_pos (seq, elm, idx)
  local pos  = elm.at or 0
  local from = elm.from or elm.at and 'start' or 'prev'

      if from == 'start'    then return pos
  elseif from == 'prev'     then return pos + elem_pos(seq,idx-1)+var_raw(seq,_data)[idx-1].l
  elseif from == 'next'     then return pos + second(elem_pos(seq,idx+fidx(elm)))
  elseif from == 'end'      then return seq.l - pos
  elseif from == 'selected' then return pos + elem_pos(seq,idx) -- BUG?
  else                           return pos + from_epos(seq,from,idx)
  end
end

-- return s-position of 'refer'
local function refer_pos (seq, elm, idx)
  local refer
  if is_sequence(elm)
  then refer = elm.refpos and 'refpos' or seq.refer
  else refer = elm.refer               or seq.refer
  end
      if refer == 'entry'  then return 0
  elseif refer == 'centre' then return elm.l/2
  elseif refer == 'exit'   then return elm.l
  elseif refer == 'refpos' then return refpos_epos(elm)
  else seq_error("invalid refer to '" .. refer .. "'", seq, idx, elm)
  end
end

-- build positions ------------------------------------------------------------o

-- set s-positions at index or return element s-positions
-- already declared for forward use, *must not be local*
function elem_pos (seq, idx, elm_)
  local elem = var_raw(seq,_data)
  local spos = elem.spos[idx]
  if is_nil(spos) then
    seq_error("invalid index or reference detected", seq, idx, elm_)
  elseif is_nil(elm_) then
    if spos >= 0 then
      return spos, elem.epos[idx]
    elseif spos == ongoing_init then
      seq_error("cycling dependencies detected", seq, idx)
    elseif spos ~= uninitialized then
      seq_error("corrupted s-position detected", seq, idx)
    end
    elem.spos[idx] = ongoing_init
  end

  local elm  = elm_ or elem[idx]
  local epos = from_pos (seq, elm, idx)
  local rpos = refer_pos(seq, elm, idx)
  spos = epos - rpos

  if is_nil(elm_) then
    elem.spos[idx], elem.epos[idx] = spos, epos
  end
  return spos, epos
end

-- set s-positions of elements from their sub sequence
local function sequ_pos (seq, sseq, idx, dir)
  check_mark(sseq)
  local pos = elem_pos(seq, idx, sseq)    -- shift by subsequence refpos
  local elem, selem = var_raw(seq,_data), var_raw(sseq,_data)

  if seq.direction ~= sseq.direction then -- changedir patch
    elem.spos[idx] = selem.spos[1] + pos
    elem.epos[idx] = selem.epos[1] + pos
    idx = idx + 1
  end

  local n = selem.ne
  if dir > 0 then
    for i=2,n-1 do
      elem.spos[idx-2+i] = selem.spos[i] + pos
      elem.epos[idx-2+i] = selem.epos[i] + pos
      assert(elem[idx-2+i] == selem[i], "unexpected corrupted flat sequence")
    end
  else
    local l = sseq.l
    for i=2,n-1 do
      local sp, el = selem.spos[n+1-i], selem[n+1-i].l
      elem.spos[idx-2+i] = l - (sp + el                           ) + pos
      elem.epos[idx-2+i] = l - (sp + el - (selem.epos[n+1-i] - sp)) + pos
      assert(elem[idx-2+i] == selem[n+1-i], "unexpected corrupted flat sequence")
    end
  end

  if seq.direction ~= sseq.direction then -- changedir patch
    elem.spos[idx+n] = selem.spos[n] + pos
    elem.epos[idx+n] = selem.epos[n] + pos
  end
end

-- compute elements positions
local function build_pos (seq, sref)
  local elem = var_raw(seq,_data)
  local n, idx, pos = elem.ne, 1, 0
  sref = sref or {}
  for i=1,n do
    elem.spos[i], elem.epos[i] = uninitialized, uninitialized
  end
  while idx <= n do
    local sseq = sref[idx]
    if is_nil(sseq) then     -- element
      elem_pos(seq, idx)
      if pos-minlen > elem.spos[idx] then
        seq_poserr('element', seq, idx, pos)
      end
      pos = elem.spos[idx] + elem[idx].l
      idx = idx + 1
    else                     -- subsequence
      sequ_pos(seq, sseq, idx, sref.sdir[idx])
      if pos-minlen > elem.spos[idx] then
        seq_poserr('subsequence', seq, idx, pos)
      end
      local selem = var_raw(sseq,_data)
      pos = elem.spos[idx] - selem.spos[2] + sseq.l
      idx = idx + selem.ne-2
    end
  end
  assert(n == idx-1, "unexpected corrupted flat sequence")

  -- adjust sequence length or end marker position
  local len = elem.spos[n]
  if   seq.l < len
  then seq.l = len
  else elem.spos[n], elem.epos[n] = seq.l, seq.l
  end
end

-- flatten sequence -----------------------------------------------------------o

-- copy sub sequence
local function copy_ssequ (seq, flat, sref, idx, dir)
  check_mark(seq)
  local elem = var_raw(seq,_data)
  if elem.ne <= 2 then return idx end

  sref[idx], sref.sdir[idx] = seq, dir -- link subsequence

  if sref.dir ~= seq.direction then -- insert changedir patch
    idx, flat[idx] = idx+1, changedir(seq.__id, {})
  end

  local n = elem.ne
  if dir > 0 then
    for i=2,n-1 do flat[idx-2+i] = elem[i] end
  else
    for i=2,n-1 do flat[idx-2+i] = elem[n+1-i] end
  end

  if sref.dir ~= seq.direction then
    idx, flat[idx-2+n] = idx+1, flat[idx-1]:select(shared) -- share patch
  end
  return idx-2+n
end

-- flatten lines and subsequence
local function flatten_line (line, flat, sref, idx, dir)
  local n, rep = #line, (line.__rep or 1) * dir
  if n == 0 then return idx end

  local start, stop, step
  if rep < 0
  then rep, start, stop, step = -rep, n, 1, -1
  else rep, start, stop, step =  rep, 1, n,  1
  end

  for i=1,rep do
  for j=start,stop,step do
    local elm = line[j]
    if not (is_element(elm) or is_rawtable(elm)) then
      seq_error("invalid element detected", line, j)
    elseif elm.is_bline == true or is_rawtable(elm) then
      idx = flatten_line(elm, flat, sref, idx, step)
    elseif not is_nil(sref) and is_sequence(elm) then
      idx = copy_ssequ  (elm, flat, sref, idx, step)
    else -- other elements
      idx, flat[idx] = idx+1, elm
    end
  end end
  return idx
end

-- flatten sequence
local function flatten_sequ (seq, flat, sref)
  local n, idx = seq:raw_len(), 2
  flat[1] = mkstart {}
  for i=1,n do
    local elm = seq:raw_get(i)
    if not (is_element(elm) or is_rawtable(elm)) then
      seq_error("invalid element detected", seq, i)
    elseif elm.is_bline == true or is_rawtable(elm) then
      idx = flatten_line(elm, flat, sref, idx, 1)
    elseif is_sequence(elm) then
      idx = copy_ssequ  (elm, flat, sref, idx, 1)
    else -- other elements
      idx, flat[idx] = idx+1, elm
    end
  end
  flat[idx] = mkend {}
  assert(n <= idx, "unexpected corrupted flat sequence")
end

-- dict helper ----------------------------------------------------------------o

-- build dictionnary name -> idx
local function build_idx (data)     -- must be very fast
  local eidx = data.eidx
  table.clear(eidx)                 -- reuse main storage
  for idx,elm in ipairs(data) do
    local nam = elm.__id
    local val = eidx[nam]
    if is_nil(val) then             -- none: scalar
      eidx[nam] = idx
    elseif is_number(val) then      -- one : scalar to array
      eidx[nam] = {val, idx, n=2}
    else                            -- many: append
      local n = val.n+1
      val[n], val.n = idx, n
    end
  end
end

-- build sequence -------------------------------------------------------------o

-- finalize sequence
local function finish_sequ (seq)
  local data = var_raw(seq,_data)

  -- clear memoization
  data.last_from    = nil
  data.last_frompos = nil

  -- $start/$end markers aliases
  local ei, ne = data.eidx, data.ne
  ei['#s'], ei['#S'] =  1,  1
  ei['#e'], ei['#E'] = ne, ne

  -- sanity checks
  if MAD.option.debug > 2 then
    check_mark (seq)
    check_spos (seq)
    check_index(seq) -- remove $start/$end marker aliases
  end
end

-- sequence init (build)
local function sequ_init (seq)
  local n = seq:raw_len()
  if n == 0 then return seq end -- empty

  local sref = { dir=seq.direction, sdir={} }
  local data = table.new(n+2,8)
  flatten_sequ(seq, data, sref)
  seq:clear_array()

  local ne = #data
  data.eidx = table.new(0,ne)
  data.epos = table.new(ne,0)
  data.spos = table.new(ne,0)
  seq[_data], data.ne = data, ne

  build_idx (data)
  build_pos  (seq, sref)
  finish_sequ(seq)
  return seq
end

-- sequence metamethods -------------------------------------------------------o

-- count proxy
local _idx = {}

local function cnt_iter (s, i)
  i = i+1
  local ei = s[_idx][i]
  if ei then return i, s[_data][ei] end
end

local cnt_mt = set_concept({
  __len       =\s   -> s[_idx].n,
  __index     =\s,i -> s[_data][s[_idx][i]],
  __ipairs    =\s   -> (cnt_iter, s, 0),
  __tostring  =\s   -> string.format("sequence count: %p", s),
}, not_mappable + not_extendable + not_mutable)

-- number of elements
local function len_mm (seq)
  return var_raw(seq,_data).ne
end

-- read access precedence: element index, variable key, element name.
local function index_mm (seq, key)
  -- element index
  if is_number(key) then                              -- see index_of_idx
    local elem = var_raw(seq,_data)
    return elem[ reflect(key, elem.ne) ]
  end
  -- variable
  local var = var_raw(seq, key)
  if not is_nil(var) then return var_val(seq, key, var) end
  -- element name
  local elem = var_raw(seq,_data)
  local idx = elem.eidx[key]
  if is_number(idx) then
    return elem[idx]
  elseif is_table(idx) then
    return setmetatable({[_idx]=idx, [_data]=elem}, cnt_mt)
  end
end

local function newindex_mm (seq, key, val)
  -- element index or name
  if is_number(key) or var_raw(seq,_data).eidx[key] then
    error("invalid sequence write access (use replace method)")
  end
  -- variable
  var_set(seq, key, val)
end

-- methods (readonly) ---------------------------------------------------------o

local function index (seq, idx)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  assert(is_integer (idx), "invalid argument #2 (integer expected)")
  return index_of_idx(seq, idx)
end

local function name_of (seq, idx, idx_)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  assert(is_integer (idx), "invalid argument #2 (integer expected)")
  return name_of_idx(seq, idx, idx_)
end

local function index_of (seq, a, idx_)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
      if is_number (a) then return index_of_num(seq, a)
  elseif is_string (a) then return index_of_str(seq, a, idx_)
  elseif is_element(a) then return index_of_elm(seq, a, idx_)
  end
  error("invalid argument #2 (number, string or element expected)")
end

local function range_of (seq, rng, idx_)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  local start, stop, istart, istop
  if is_integer(rng) then
    start, istart = rng, index_of_idx(seq, rng)
    stop , istop  = start, istart
  elseif is_string(rng) then
    local s1, i2 = strsplit(rng, "/")
    local s2 = i2 > 0 and strtrim(rng, i2+1) or nil
    start, stop = s1, s2
  elseif is_range(rng) then
    start, stop = rng:bounds()
  elseif is_table(rng) then
    start, stop, idx_ = rng[1], rng[2], idx_ or rng[3]
    if idx_ == 'idx' and is_integer(start) and is_integer(stop) then
      istart, istop = index_of_idx(seq, start), index_of_idx(seq, stop)
    end
  else error("invalid argument #2 (integer, string, table or range expected)")
  end
  istart = istart or index_of(seq, start, idx_)
  istop  = istop  or index_of(seq, stop , idx_)
  if not istart then errorf("invalid range start '%s'", tostring(start)) end
  if not istop  then errorf("invalid range stop '%s'" , tostring(stop )) end
  return istart, istop
end

local function length_of (seq, rng_, ntrn_) -- see iter
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  local siz = rng_ and 1-sub(range_of(seq, rng_)) or 0
  return siz + #seq * ((ntrn_ or 0) + (siz <= 0 and 1 or 0))
end

-- functional methods ---------------------------------------------------------o

local pcls   = is_instanceOf
local psel   = marker.is_selected
local pnam   = \pat, e,i -> string.match(e.__id, pat) ~= nil
local pand   = \p,p2,e,i -> p(e,i) and p2(e,i)
local ptrue  = \p,_ ,e,i -> p(e,i) and true
local pfalse = \p,_ ,e,i -> p(e,i) or false

local function foreach (seq, act, rng_, sel_, not_) -- action, range, selection, default
  local f, p

  -- foreach(sel) -> foreach(sel.action, sel)
  if is_nil(rng_) and is_rawtable(act) then
    f, rng_ = act.action, act     -- extract action + right shift
  else
    f = act
  end
  -- foreach(act,sel) -> foreach(act, sel.range, sel)
  if is_nil(sel_) and is_rawtable(rng_) and is_nil(rng_[1]) then
    rng_, sel_ = rng_.range, rng_ -- extract range  + right shift
  end

  if is_rawtable(sel_) then       -- logically and'ed selections
    if is_nil(not_) and (sel_.default == 'none' or sel_.default == true) then
      not_ = true
    end
    local op = not_ ~= true and ptrue or pfalse
    if sel_.select then
      assert(is_callable(sel_.select), "invalid select (callable expected)")
      op, p = pand, bind2st(op, sel_.select, p)
    end
    if sel_.class then
      assert(is_element(sel_.class), "invalid class (element expected)")
      op, p = pand, bind2st(op, bind2nd(pcls, sel_.class), p)
    end
    if sel_.pattern then
      assert(is_string(sel_.pattern), "invalid pattern (string expected)")
      op, p = pand, bind2st(op, bind1st(pnam, sel_.pattern), p)
    end
    if sel_.flag then
      assert(is_number(sel_.flag), "invalid flag (number expected)")
      op, p = pand, bind2st(op, bind2nd(psel, sel_.flag), p)
    end
  elseif not is_nil(sel_) then    -- build the selection
    p = is_number  (sel_) and bind2nd(psel, sel_) or
        is_string  (sel_) and bind1st(pnam, sel_) or
        is_element (sel_) and bind2nd(pcls, sel_) or
        is_callable(sel_) and sel_                or nil
  end
  if is_nil(p) then p = (not_ ~= true or rng_) and ltrue or lfalse end

  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  assert(is_callable(f)  , "invalid argument #2 (callable expected)")
  assert(is_callable(p)  , "invalid argument #4 (callable expected)")

  if p ~= lfalse then
    for idx,elm in seq:iter(rng_) do
      if p(elm,idx) then f(elm,idx) end
    end
  end
  return seq
end

local do_select = marker.select

local function select (seq, flg_, rng_, sel_, not_)
  if is_rawtable(flg_) and is_nil(rng_) and is_nil(sel_) then
    rng_, flg_ = flg_ -- right shift
  end
  local f = bind2nd(do_select, flg_)
  return seq:foreach(f, rng_, sel_, not_)
end

local do_deselect = marker.deselect

local function deselect (seq, flg_, rng_, sel_, not_)
  if is_rawtable(flg_) and is_nil(rng_) and is_nil(sel_) then
    rng_, flg_ = flg_ -- right shift
  end
  local f = bind2nd(do_deselect, flg_)
  return seq:foreach(f, rng_, sel_, not_)
end

local do_filter = \ei,_,i => local n=ei.n+1 ; ei[n], ei.n = i, n end

local function filter (seq, rng_, sel_, not_)
  local ei = table.new(8,1)
  local f = bind1st(do_filter, ei)
  ei.n = 0
  seq:foreach(f, rng_, sel_, not_)
  return ei
end

-- methods (R/W, rebuild dict) ------------------------------------------------o

local function build_index (seq)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  local data = var_raw(seq,_data)
  build_idx (data)
  finish_sequ(seq)
  return seq
end

local function remove (seq, rng_, sel_)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")

  -- collect indexes of elements to remove
  local idx_r = filter(seq, rng_, sel_, true)
  local nr = idx_r.n
  if nr == 0 then return end
  assert(idx_r[nr]-idx_r[1] >= nr-1, "invalid range, indexes must be increasing")

  -- remove elements by decreasing indexes -- to optimize to avoid O(N^2) removal
  local elem, elm_r = var_raw(seq,_data), table.new(nr,0)
  for i=nr,1,-1 do
    local ii = idx_r[i]
    elm_r[i] = elem[ii]    -- backup
    table.remove(elem     , ii)
    table.remove(elem.spos, ii)
    table.remove(elem.epos, ii)
  end
  elem.ne = #elem

  build_index(seq)
  return elm_r, idx_r
end

local function replace (seq, elm, rng_, sel_)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")

  if is_rawtable(elm) and is_nil(rng_) and is_nil(sel_) then
    rng_, elm = elm, elm.elements -- extract elements + right shift
  end

  if is_element(elm) then elm = {elm} end
  assert(is_rawtable(elm), "invalid argument #2 (elements list expected)")
  local ne = #elm
  if ne == 0 then return end

  -- check elements
  for i=1,ne do
    if is_element(elm[i]) and not is_sequence(elm[i]) then
      error("invalid element '"..(elm[i].__id or '?').."' replacement at index "..i)
    end
  end

  -- collect indexes of elements to replace
  local idx_r = filter(seq, rng_, sel_, true)
  local nr = idx_r.n
  if nr == 0 then return end
  assert(idx_r[nr]-idx_r[1] >= nr-1, "invalid range, indexes must be increasing")

  -- replace elements
  local elem, elm_r = var_raw(seq,_data), table.new(nr,0)
  for i=1,nr do
    local ii, ie = idx_r[i], (i-1)%ne+1    -- recycle list of elements
    elem[ii], elm_r[i] = elm[ie], elem[ii] -- backup
    elem.spos[ii], elem.epos[ii] = uninitialized, uninitialized
    elem_pos(seq, ii) -- recompute the positions
  end

  check_spos (seq)
  build_index(seq)
  return elm_r, idx_r
end

local function insert (seq, elm, rng_, sel_)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")

  if is_rawtable(elm) and is_nil(rng_) and is_nil(sel_) then
    rng_, elm = elm, elm.elements -- extract elements + right shift
  end

  if is_element(elm) then elm = {elm} end
  assert(is_rawtable(elm), "invalid argument #2 (elements list expected)")
  local ne = #elm
  if ne == 0 then return end

  -- collect indexes of reference where to insert
  local idx_r = filter(seq, rng_, sel_, true)
  local nr = idx_r.n
  assert(idx_r[nr]-idx_r[1] >= nr-1, "invalid range, indexes must be increasing")

  -- collect elements and subsequences to insert
  local ins = table.new(ne,0) -- no sref -> keep subsequence as-is
  flatten_line(elm, ins, nil, 1, 1)
  elm, ne, ins = ins, #ins -- update

  -- precompute number of elements with from='selected'
  local ns = 0
  for i=1,ne do
    if is_element(elm[i]) and not is_sequence(elm[i]) then
      error("invalid element '"..(elm[i].__id or '?').."' insertion at index "..i)
    end
    if elm[i].from == 'selected' then ns = ns+1 end
  end

  -- precompute position of each element
  local i, ni = 0, ne-ns + ns*nr
  local spos, epos = table.new(ni,0), table.new(ni,0)
  for ie=1,ne do
    if elm[ie].from ~= 'selected' then
      i = i + 1
      elm[i], spos[i], epos[i] = elm[ie], elem_pos(seq, 1        , elm[ie])
    else for ir=1,nr do
      i = i + 1
      elm[i], spos[i], epos[i] = elm[ie], elem_pos(seq, idx_r[ir], elm[ie])
    end end
  end

  -- insert elements -- to optimize to avoid O(N^2) insertion
  local elem = var_raw(seq,_data)
  for ie=1,i do
    local idx = bsearch(elem.spos, spos[ie], 2, elem.ne-1)
    if is_sequence(elm[ie]) and #elm[ie] > 2 then
      local selem = var_raw(elm[ie],_data)
      table.move(elem     , idx, elem.ne, idx+selem.ne-1)
      table.move(elem.spos, idx, elem.ne, idx+selem.ne-1)
      table.move(elem.epos, idx, elem.ne, idx+selem.ne-1)
      for j=2,selem.ne-1 do -- see sequ_pos
        elem     [idx+j-2] = selem     [j]
        elem.spos[idx+j-2] = selem.spos[j]+spos[ie]
        elem.epos[idx+j-2] = selem.epos[j]+spos[ie]
      end
    else
      table.insert(elem     , idx, elm [ie])
      table.insert(elem.spos, idx, spos[ie])
      table.insert(elem.epos, idx, epos[ie])
    end
  end
  elem.ne = #elem

  check_spos (seq)
  build_index(seq)
  return seq
end

local function copy (seq, name_, owner_)
  if is_nil(owner_) and is_boolean(name_) then
    owner_, name_ = name_
  end
  assert(not rawequal(seq, sequence), "invalid argument #1 (cannot copy 'sequence')")
  assert(is_sequence(seq)           , "invalid argument #1 (sequence expected)")
  local cpy = seq_cpy(seq,name_)
  if is_view(seq) and not owner_ then return cpy end

  local elem = var_raw(seq,_data)
  local ne = elem.ne
  local data = table.new(ne,5)  -- see sequ_init
  data.eidx  = table.new(0,ne)
  data.epos  = table.new(ne,0)
  data.spos  = table.new(ne,0)
  cpy[_data], data.ne = data, ne

  for i=1,ne do
    data[i] = elem[i]:copy()
    data.spos[i], data.epos[i] = elem.spos[i], elem.epos[i]
  end

  build_index(cpy)
  return cpy
end

-- special --------------------------------------------------------------------o

local function cycle (seq, a)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  assert(index_of(seq, a), "invalid argument #2 (reference expected)")
  seq.start_at = a
  return seq
end

local function share (seq1, seq2)
  assert(is_sequence(seq1), "invalid argument #1 (sequence expected)")
  assert(is_sequence(seq2), "invalid argument #2 (sequence expected)")
  check_mark(seq1) check_mark(seq2)
  local elem1 = var_raw(seq1,_data)
  local elem2 = var_raw(seq2,_data)
  for i=2,elem1.ne-1 do
    local nam = elem1[i].__id   -- share by (unique) name
    if elem2.eidx[nam] then     -- element name found in seq2
      local i1, i2 = elem1.eidx[nam], elem2.eidx[nam]
      -- ensure that elements are unique in both sequences
      assert(is_number(i1) and is_number(i2), "invalid shared element (must be unique)")
      local e1, e2 = elem1[i1], elem2[i2]
      assert(e1.__id == nam and e2.__id == nam, "unexpected corrupted dictionnary")
      -- make Y inheritance using e1 as reference and discard e2 (pos are unchanged)
      local c1 = e1 { at := e1.at, from := e1.from, refpos := e1.refpos }
      local c2 = e1 { at := e2.at, from := e2.from, refpos := e2.refpos }
      -- check compatibility of positions
      local s0, s1, s2 = elem2.spos[i2], elem_pos(seq2,i2,c2), elem_pos(seq2,i2,e2)
      assert(s0 == s1 and s0 == s2, "incompatible shared elements (spos differs)")
      -- update arrays, add shared flag
      elem1[i1] = c1:set_flag(flags.shared)
      elem2[i2] = c2:set_flag(flags.shared)
    end
  end
  finish_sequ(seq1) finish_sequ(seq2)
  return seq1, seq2
end

local function unique (seq, fmt_)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  if is_string(fmt_) then fmt_ = bind1st(string.format, fmt_) end
  assert(is_callable(fmt_), "invalid argument #2 (callable expected)")
  local elem, lst = var_raw(seq,_data), table.new(0,100)
  for en,ei in pairs(elem.eidx) do
    if is_table(ei) then
      table.clear(lst)
      for i=1,ei.n do
        local elm = elem[ei[i]]
        lst[elm] = (lst[elm] or 0)+1
      end
      for i=1,ei.n do
        local idx, nam = ei[i]
        local elm = elem[idx]
        if fmt_ then
          nam = fmt_(elm.__id, i, idx)
          if elem.eidx[nam] ~= nil then
            error("cannot rename uniquely element '"..nam.."' (already in use)")
          end
          elem.eidx[nam] = idx
        end
        if lst[elm] > 1 then
          elem[idx] = elm(nam,{})    -- replaced by unique child
        elseif fmt_ then
          elm:raw_set('__id', nam)   -- override with unique name
        end
      end
      if fmt_ then elem.eidx[en] = nil end
    end
  end
  finish_sequ(seq)
  return seq
end

-- iterators ------------------------------------------------------------------o

local function niliter (state, i)
  return nil
end

local function fwditer (state, i)
  if i == state.stop then
    if state.turn == 0 then return nil end
    state.turn = state.turn-1
  end
  if i < state.ne then
    i = i+1
  else
    i, state.soff = 1, state.soff+state.l
  end
  return i, state.elem[i], state.spos[i]+state.soff
end

local function bwditer (state, i)
  if i == state.stop then
    if state.turn == 0 then return nil end
    state.turn = state.turn-1
  end
  if i > 1 then
    i = i-1
  else
    i, state.soff = state.ne, state.soff-state.l
  end
  return i, state.elem[i], state.spos[i]+state.elem[i].l-state.soff
end

local function iter (seq, rng_, ntrn_, dir_)
  local nturn, dir = ntrn_ or 0, dir_ or 1
  assert(is_sequence(seq)                ,"invalid argument #1 (sequence expected)")
  assert(is_number(nturn) and nturn >= 0 ,"invalid argument #3 (number expected)")
  assert(is_number(dir) and abs(dir) == 1,"invalid argument #4 (direction expected)")

  if #seq == 0 then return niliter end

  local elem, start, stop = var_raw(seq,_data)
  if is_nil(rng_) then
    local s0, sn = 1, elem.ne
    if dir < 0 then s0, sn = sn, s0 end
    if is_nil(seq.start_at) then
      start, stop = s0, sn
    else
      start = assert(index_of(seq, seq.start_at), "invalid cycle reference")
      stop  = start == s0 and sn or start-dir
    end
  else
    start, stop = range_of(seq, rng_)
  end
  if start == stop+dir then nturn = nturn+1 end

  local soff = dir > 0 and -elem.spos[start] or elem.spos[start]+elem[start].l
  return dir > 0 and fwditer or bwditer, {elem=elem, spos=elem.spos, soff=soff,
         l=seq.l, ne=elem.ne, stop=stop, turn=nturn}, start-dir
end

-- flags ----------------------------------------------------------------------o

local function save_flags (seq)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  local elem = var_raw(seq,_data)
  local flgs = table.new(elem.ne,0)
  for i=1,elem.ne do flgs[i] = elem[i]:get_flags() end
  if is_nil(elem.flgs) then elem.flgs = { n=0 } end
  local n = elem.flgs.n+1
  elem.flgs[n], elem.flgs.n = flgs, n
end

local function drop_flags (seq)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  local elem = var_raw(seq,_data)
  assert(not (is_nil(elem.flgs) or elem.flgs.n == 0), "saved flags not found")
  local n = elem.flgs.n
  elem.flgs[n], elem.flgs.n = nil, n-1
end

local function restore_flags (seq)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  local elem = var_raw(seq,_data)
  assert(not (is_nil(elem.flgs) or elem.flgs.n == 0), "saved flags not found")
  local n = elem.flgs.n
  local flgs = elem.flgs[n]
  for i=1,elem.ne do elem[i]:set_flags(flgs[i]) end
  elem.flgs[n], elem.flgs.n = nil, n-1
end

-- members --------------------------------------------------------------------o

sequence.original = original

sequence :set_methods {
  -- elem, spos, epos, canonical index
  elem          = \s,i -> var_raw(s, _data)     [i],
  spos          = \s,i -> var_raw(s, _data).spos[i],
  epos          = \s,i -> var_raw(s, _data).epos[i],
  index         = index,

  -- elements manipulation
--  getelm       = get_elm,
--  addelm       = add_elm,
--  setelm       = set_elm,
--  remelm       = rem_elm,
--  inselm       = ins_elm,

  -- sequence-like methods
  name_of       = name_of,
  index_of      = index_of,
  range_of      = range_of,
  length_of     = length_of,

  foreach       = foreach,
  select        = select,
  deselect      = deselect,
  filter        = filter,

  remove        = remove,
  replace       = replace,
  insert        = insert,
  copy          = copy,

  cycle         = cycle,
  share         = share,
  unique        = unique,
  iter          = iter,

  -- flags
  save_flags    = save_flags,
  drop_flags    = drop_flags,
  restore_flags = restore_flags,

  -- read/write
  read         := error("NYI", 2), -- TODO (possible?)
  write        := error("NYI", 2), -- TODO (useful?)

  -- ownership
  is_owner      = is_owner,
  is_view       = is_view,

  -- index dict
  build_index   = build_index,
  check_index   = check_index,

  -- disabled methods
  is_selected  := error("invalid sequence operation", 2),

} : set_metamethods ({
  __len         = len_mm,
  __index       = index_mm,
  __newindex    = newindex_mm,
-- __pairs      = pairs_mm , default from object
-- __ipairs     = ipairs_mm, default from object

  __copy        = copy,
  __init        = sequ_init,

}, true): set_readonly()

-- env ------------------------------------------------------------------------o

MAD.typeid.is_sequence = is_sequence

-- end -------------------------------------------------------------------------
return {
  sequence = sequence,
  __help   = require 'madh_sequence',
}

--[=[ TODO?
SEQUENCE DISPLAY

local function show_fields(t, lst)
  local a, k, s
  lst = lst or sequence_fields
  for _,v in ipairs(lst) do
    if is_list(v) then k, s = v[1], v[2] else k, s = v, v end
    a = t[k]
    if a then io.write(', ', s, '= ', tostring(a)) end
  end
end

function M:show(disp)
  io.write("sequence '", self.__id,"' { ")
  show_list(self, disp)
  io.write(' }\n')
  for _,v in ipairs(self) do v:show(disp) end
  io.write('endsequence\n')
end

function M:show_madx(disp)
  io.write("'", self.__id, "': sequence, ")
  show_list(self, disp)
  io.write(';\n')
  for _,v in ipairs(self) do v:show_madx(disp) end
  io.write('endsequence;\n')
end
--]=]
