--[=[
 o-----------------------------------------------------------------------------o
 |
 | Sequence module (help)
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o
]=]

local __help = {}

-- help -----------------------------------------------------------------------o

__help.sequence = [=[
NAME
  sequence -- build sequences

SYNOPSIS
  seq = sequence 'name' { attribute-list, element-list... }

DESCRIPTION
  TODO

RETURN VALUE

EXAMPLE
  see LHC sequences

SEE ALSO
  element.
]=]

__help["sequence: seqedit"] = [=[
Sequence edition:
-----------------
  seqedit:    n/a
  flatten:    n/a
  reflect:    n/a
  endedit:    n/a

  selection: (foreach)
    range=range, flag=flag, pattern=string, class=element, select=predicate

  seq:remove  { selection }
  seq:replace { elements={elem1, elem2, ...}, selection } -- recycle elements
  seq:insert  { elements={elem1, elem2, ...}, selection } -- recycle elements

  seq:dump()  -- to be defined, i.e. should save values, not expressions.
]=]

__help["sequence: indexes, ranges and iterators"] = [=[
Indexes: (index_of)
--------
  return the index in the sequence or nil

  seq:index_of(spos|name|elem, [index|count])
  - spos (number: s-position)
    + spos < 0 means starts from end (i.e. seq.l+num)
    + return the closest index if spos is not found
  - mname (string: mangled name)
    + name                 (equivalent to name[1])
    + name        & index  (equivalent to name{1} & index)
    + name[count]          (absolute with occurences count)
    + name{count} & index  (relative with occurences count if index is provided)
    + name{count}          (equivalent to name[count])
    + name[count] & index  (equivalent to name[count], i.e. index is ignored)
    + $start or #s or #S (index=1), $end or #e or #E (index=#seq)
  - element (object)
    + element.name         (absolute and unique)
    + element.name & count (absolute with occurences count)

  Inverse method: (name_of)
    seq:name_of(index) returns the mname at index.
    seq:name_of(seq:index_of('mq[10]')) == 'mq[10]'

Ranges: (range_of)
-------
  return the pair of indexes in the sequence or nil

  seq:range_of(arg)
  - start_spos .. stop_spos  (range object)
  - { spos|name|elem, spos|name|elem }
  - "spos|name / spos|name"
  - support for start > stop or missing stop (i.e. stop = start)

Iterators: (iter)
----------
  return an iterator usable by generic for loop

  seq:iter([range], [nturn])
  - iterate through the sequence.
  - if nturn is not specified, nturn=0.
  - if range is not specified
    + if seq.start_at exists, nturn+1 starting at seq.start_at.
    + otherwise from 1 to #seq.
]=]

--[=[
programming model:
seq:foreach {
  action=function,
  range=range,
  flag=flag, pattern=string, class=element, select=predicate -- AND'ed selections
  default=nil/'none'
}
seq:foreach(action, range, select, not)
seq:select/deselect(flag, range, select, not)
seq:filter(range, select, default)
without any selection criterium:
  not ~= true and default ~= 'none' -> select all
  not == true or  default == 'none' -> select nothing
]=]

-- end -------------------------------------------------------------------------
return __help
