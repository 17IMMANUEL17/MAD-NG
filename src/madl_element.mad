--[=[
 o-----------------------------------------------------------------------------o
 |
 | Elements module
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide the hierarchy (taxonomy) of the lattice elements

 o-----------------------------------------------------------------------------o
]=]

local M = {}

-- locals ---------------------------------------------------------------------o

local object                                       in MAD
local is_nil, is_number, is_table, is_object       in MAD.typeid
local test_flag, set_flag, clear_flag              in object

local _nyi

-- root object ----------------------------------------------------------------o

local Element = object 'element' {
  kind='element', is_element=true,
  l=0, angle=0, tilt=0, -- number required!
  model=false, method=false, radius=false,
  k0 =false, k1 =false, k2 =false, k3 =false, k4 =false, k5 =false,
  k0s=false, k1s=false, k2s=false, k3s=false, k4s=false, k5s=false,
  knl=false, ksl=false, dknl=false, dksl=false, dknlr=false, dkslr=false,
  aperture={kind='bbox', 1, tilt=false, offset=false, tol=false},
}

-- identity -------------------------------------------------------------------o

local _id = {}

local function is_element (a)
  local mt = getmetatable(a)
  return mt ~= nil and mt.__elem == _id
end

-- flags ----------------------------------------------------------------------o

M.flags = {
  selected = Element.first_free_flag,
  implicit = Element.first_free_flag+1,               -- inherited from object
  observe  = Element.first_free_flag+2,
  layout   = Element.first_free_flag+3,
  layangle = Element.first_free_flag+4,
}

Element.first_free_flag = Element.first_free_flag+5   -- overridden in Element

-- members --------------------------------------------------------------------o

local implicit, observe, selected in M.flags

Element :set_methods {
  is_selected = \s,f ->  test_flag(s, f or selected),
  select      = \s,f ->   set_flag(s, f or selected),
  deselect    = \s,f -> clear_flag(s, f or selected),
  -- specializations
  is_implicit = \s   ->  test_flag(s, implicit),
  is_observed = \s   ->  test_flag(s, observe ),

} :set_metamethods ({
  -- identity
  __elem = _id,
  -- concatenation
  __add = \a,b -> M.bline { a, b },
  -- repetition
  __mul = \a,b => if is_number(b) then a,b = b,a end
                  return M.bline { __rep=a, b } end,
  -- reflection
  __unm = \a -> M.bline { __rep=-1, a },
  -- dump
  __tostring = \s -> string.format("%s: '%s' %p", s.kind, s.__id, s),

}, true) :set_readonly()

-- taxonomy -------------------------------------------------------------------o

-- element kinds

M. thin_element = Element  'thin_element' { is_thin    = true }
M.drift_element = Element 'drift_element' { is_drift   = true, is_thick = true }
M.thick_element = Element 'thick_element' { is_thick   = true }
M.patch_element = Element 'patch_element' { is_patch   = true }
M.specl_element = Element 'specl_element' { is_special = true }
M.extra_element = Element 'extra_element' { is_extra   = true }

-- assembler elements

M.sequence    = M.extra_element 'sequence'     { }
M.assembly    = M.extra_element 'assembly'     { }
M.bline       = M.extra_element 'bline'        { }

-- special elements

M.marker      = M.specl_element 'marker'       { }
M.slink       = M.specl_element 'slink'        { }

-- drift elements

M.drift       = M.drift_element 'drift'        { }
M.monitor     = M.drift_element 'monitor'      { }
M.collimator  = M.drift_element 'collimator'   { }
M.instrument  = M.drift_element 'instrument'   { }
M.placeholder = M.drift_element 'placeholder'  { }

-- thick elements

M.sbend       = M.thick_element 'sbend'        { } -- curved  , k0+k1
M.combined    = M.thick_element 'combined'     { } -- curved  , k1+k0
M.rbend       = M.thick_element 'rbend'        { } -- straight, k0+k1
M.quadrupole  = M.thick_element 'quadrupole'   { } -- straight, k1+k0
M.sextupole   = M.thick_element 'sextupole'    { }
M.octupole    = M.thick_element 'octupole'     { }
M.decapole    = M.thick_element 'decapole'     { }
M.dodecapole  = M.thick_element 'dodecapole'   { }
M.solenoid    = M.thick_element 'solenoid'     { ks=0, ksi=0 }
M.kicker      = M.thick_element 'kicker'       { hkick=0, vkick=0 }
M.tkicker     = M.thick_element 'tkicker'      { hkick=0, vkick=0 }
M.wiggler     = M.thick_element 'wiggler'      { _nyi }
M.elseparator = M.thick_element 'elseparator'  { ex=0, ey=0, exl=0, eyl=0 }
M.rfcavity    = M.thick_element 'rfcavity'     { volt=0, freq=0, lag=0 }

-- thin elements

M.beambeam    = M.thin_element  'beambeam'     { beam=false, xma=0, yma=0, dir=0 }
M.multipole   = M.thin_element  'multipole'    { lrad=0 }
M.rfmultipole = M.thin_element  'rfmultipole'  { }

-- patch elements

M.xrotation   = M.patch_element 'xrotation'    { }
M.yrotation   = M.patch_element 'yrotation'    { }
M.srotation   = M.patch_element 'srotation'    { }
M.translate   = M.patch_element 'translate'    { }
M.changeref   = M.patch_element 'changeref'    { }
M.changedir   = M.patch_element 'changedir'    { }
M.changenrj   = M.patch_element 'changenrj'    { }

-- specializations

M.twcavity    = M.rfcavity      'twcavity'     { _nyi }
M.crabcavity  = M.rfmultipole   'crabcavity'   { _nyi }

M.hmonitor    = M.monitor       'hmonitor'     { }
M.vmonitor    = M.monitor       'vmonitor'     { }

M.hkicker     = M.kicker        'hkicker'      { kick=0 }
M.vkicker     = M.kicker        'vkicker'      { kick=0 }

-- build kind and is_xxx keys of elements -------------------------------------o

for k,e in pairs(M) do
  if is_object(e) then
    assert(is_element(e), "non-element '"..e.__id.."'detected in Element")
    if k ~= string.lower(e.__id) then
      error("inconsistent element kind '"..k.."' detected in '".. e.__id .."'")
    end
-- warning: class protection set by alt. nolookup object model can be BYPASSED
--          because classes are modified before any use of 'kind' and 'is_xxx'
--          attributes by any children at the time of module loading...
    e:setv({ kind=k, ['is_'.. k]=true }, 'init')
  end
end

-- env ------------------------------------------------------------------------o

-- local is_implicit, is_observed, is_selected in Element

MAD.typeid.is_element  = is_element
-- MAD.typeid.is_implicit = is_implicit
-- MAD.typeid.is_observed = is_observed
-- MAD.typeid.is_selected = is_selected

-- end ------------------------------------------------------------------------o
return { element = M }

--[[ TODO?
ELEMENT DISPLAY

local function show_inheritance(self, depth, sep)
  show_list(self, element_fields, sep)
  if depth > 0 and not rawget(self:class(), 'kind') then
    show_inheritance(self:class(), depth-1)
  end
end

local function show_properties(self, disp, sep)
  local show = type(disp) == 'number' and show_inheritance or show_list
  show(self, disp, sep)
end

local printf in MAD.utility

function MT:show(disp)
  printf("   %-25s '%s' { at= %g, ", self:class().name ...)
  show_properties(self, disp)
  io.write(' },\n')
end

function MT:show_madx(disp)
  printf("  %-25s:%s, at= %g, ", self.name, self:class().name, self.spos)
  show_properties(self, disp, {'= ', ', '})
  io.write(';\n')
end
]]



