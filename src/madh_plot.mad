--[=[
 o-----------------------------------------------------------------------------o
 |
 | Plot module (help)
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 |          A. Bloch , aurelien.bloch at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o
]=]

local __help = {}

-- plot help ------------------------------------------------------------------o

__help.plot = [=[
NAME
  plot

SYNOPSIS
  my_plot = plot 'myplot' { parameters... }

DESCRIPTION
  This module prides an high level interface to 'gnuplot' a cross-platform
  command-line graphing utility (See http://www.gnuplot.info/). It requires
  gnuplot 5+ to be installed to work and this documentation will heavily lean on
  the gnuplot documentation (available at
  http://www.gnuplot.info/docs_5.0/gnuplot.pdf).

  It works by generating a gnuplot script and passing it to an instance of
  gnuplot using gplot to manage this resources (See gplot).

  This command offers two main functionalities:
    - A user-friendly way to dump data to gnuplot (to generate plots)
    - The generation of a gnuplot script to create a layout from a sequence.

  To see the complete list of available parameters, their default value, and the
  way to define them properly see "plot: options"

RETURN VALUE
  The plot command.

EXAMPLES
  -- Simple example that plot the "y1" column of tbl against the line indexes
  -- and show the layout of seq on top.
  -- See tests for more examples.
  plot {
    sequence = seq,
    table    = tbl,
    x1y1     = "y1",
  }
  -- For complete and working examples involving all kinds of parameters
  -- refer to the unit test of the plot command (in plot.mad)

SEE ALSO
  gplot, mtable, sequence.
]=]

__help['plot: options'] = [=[
DESCRIPTION
  This section present the list of all available plot options with their
  corresponding default values. On the right side, a comment on the value is
  written that describe the types of values that this particular parameters can
  accept and the correct syntax of it.

OPTIONS
  -- stream id
  sid         = 1,          -- 1 <= n <= 25

  -- user command
  prolog      = nil,        -- string
  epilog      = nil,        -- string

  -- windows setup
  term        = "wxt",
  wsizex      = 800,        -- x > 0
  wsizey      = 500,        -- y > 0

  -- output
  output      = 1,          -- ("filename") -> pdf | number -> wid
  scrdump     = nil,        -- ("filename")

  -- table or data input
  data        = nil,        -- { x=tbl.x, y=vec } (precedence over table)
  table       = nil,        -- mtable
  tablerange  = nil,        -- compatible table range

  -- sequence input
  sequence    = nil,        -- seq | { seq1, seq2, ... } | "keep"
  range       = nil,        -- compatible sequence range
  seqdisty    = 0,          -- y >= 0 | { y1, y2, ... }
  seqdistx    = 0,          -- x >= 0 | { x1, x2, ... }
  seqshift    = 0,          -- x >= 0
  nturn       = 0,          -- n >= 0
  X0          = {0, 0, 0},  -- {x, y, z} numbers
  A0          = {0, 0, 0},  -- {theta, phi, psi} numbers

  -- layout style
  laypos      = "top",      -- "top" | "bottom" | "middle" | "in" | 0 < y < 1
  laysize     = nil,        -- 0 < y < 1
  elemname    = true,       -- boolean
  elemwidth   = nil,        -- unsigned size of element before elemscale
  elemscale   = 1,          -- multiplier or default size
  elemminlen  = 0,          -- x > 0
  layangle    = true,       -- boolean
  kindselect  = nil,        -- { "quadrupole", "sbend" }
  kindcolor   = true,       -- {
                            --  quadrupole = "blue",
                            --  sbend = {fillcolor = "red", fillstyle = "solid"}
                            -- }
                            -- true -> use default

  -- axis selection (and names)
  x1y1        = nil,        -- x1y1 = { x1 = {"y1", "y2"}, x2 = {"y3", "y4"}}
  x1y2        = nil,        -- x1y1 = { x1 = {"y1", "y2"}, x2 = "y3"}
  x2y1        = nil,        -- x1y1 = { x2 = {"y1", "y2"}, "y3"},
  x2y2        = nil,        -- x1y1 = { x1 = {"y1", "y2"}},
                            -- x1y1 = { x2 = "y1", "y2"},
                            -- x1y1 = { x1 = "y1"},
                            -- x1y1 = {"y1", "y2"},
                            -- x1y1 = "y1",

  -- labels
  title       = "${name} MAD ${version}, ${date}, ${time}",
  legend      = nil,        -- { y = "distance" }
  xlabel      = nil,        -- strings
  x2label     = nil,        -- strings
  ylabel      = nil,        -- strings
  y2label     = nil,        -- strings

  -- axis ranges
  xrange      = nil,        -- { min, max }
  x2range     = nil,        -- { min, max }
  yrange      = nil,        -- { min, max }
  y2range     = nil,        -- { min, max }

  -- plot command configuration
  plotcfg     = nil,        -- string
  plotvar     = nil,        -- table
  plotcmd     = nil,        -- string

  -- plot style
  originx     = nil,        -- 0 < x < 1
  originy     = nil,        -- 0 < y < 1
  psizex      = nil,        -- 0 < x < 1
  psizey      = nil,        -- 0 < y < 1

  -- data style
  datastyles  = { },        -- { y = { style = "lines", color = "blue"} }
  styles      = "lines",    -- { y = "lines" }
  colors      = "red",      -- { y = "green" }
  dashtypes   = "solid",    -- { y = "..-- " }
  linewidths  = 1,          -- { y = 2.3     }
  pointtypes  = 1,          -- { y = 2       }
  pointsizes  = 1,          -- { y = 2.3     }

  -- decoration
  font        = "Times New Roman",
  fontsize    = 14,         -- n > 0
  titlefont   = nil,        -- string
  titlesize   = nil,        -- n > 0
  legendfont  = nil,        -- string
  legendsize  = nil,        -- n > 0
  legendpos   = "left top", -- string
  grid        = "",         -- string
  border      = 15,         -- 0 <= n <= 15

  -- object shift
  oshft       = 1000000,    -- n >= 0

  -- build the command (do not execute)
  exec        = exec,
]=]

__help['plot.sid'] = [=[
NAME
  sid

SYNOPSIS
  plot.sid

DESCRIPTION
  The sid is used by the plot command to configure the gplot object
  (See gplot.sid for more). You might want to use multiple gnuplot instances for
  many reasons but here are a few possibilities :
    - If you want to have multiple pdf open for creation, then  use one sid per
    pdf because changing the name of the ouptut pdf will close the previous one
    and once closed, it can not be extended anymore.
    - If you want to have multiple interactive windows at the same time, then
    you should use one sid per window because inside a same gnuplot instances
    only the last one will be interactive.

RETURN VALUE
  The command sid.

SEE ALSO
  gplot.sid, plot.output
]=]

__help['plot.prolog'] = [=[
NAME
  prolog, epilog

SYNOPSIS
  plot.prolog
  plot.epilog

DESCRIPTION
  Allows to insert any string at the beginning and end of the gnuplot script.

RETURN VALUES
  prolog, epilog as strings.

EXAMPLES
  -- example to activate and deactivate gnuplot multiplot mode at the end
  -- an the beginning of the script.
  plot {
    [...]
    prolog = "set multiplot",
    epilog = "unset multiplot",
  }

SEE ALSO
  None.
]=]
__help['plot.epilog'] = __help['plot.prolog']

__help['plot.term'] = [=[
NAME
  term, wsizex, wsizey
SYNOPSIS
  plot.term
  plot.wsizex
  plot.wsizey

DESCRIPTION
  term is the name of the gnuplot windows terminal used by the command. it's
  default value is "wxt". wsizex and wsizey are the width and hight of the
  graphical window in pixels.

RETURN VALUES
  term as a string
  wsizex, wsizey as number in pixels.

EXAMPLES
  -- example to use the qt terminal with a definition of 800x500 px.
  plot {
    [...]
    term   = "qt",
    wsizex = 800,
    wsizey = 500,
  }

SEE ALSO
  None.
]=]
__help['plot.wsizex'] = __help['plot.term']
__help['plot.wsizey'] = __help['plot.term']

__help['plot.output'] = [=[
NAME
  output, scrdump

SYNOPSIS
  plot.output
  plot.scrdump

DESCRIPTION
  output set the output mode.
    - A number value will use the windows terminal set by the "term" parameter
  and create a windows with this number as id. A single gnuplot instances can
  have multiple windows designated by the output number.
    - A string value will use the "pdfcairo" terminal and generate a pdf
  file with this string as name.

  scrdump is the name of the file where the gnuplot script will be saved.
  a nil value means that the scrdump is not saved (default)

RETURN VALUES
  the output mode as a number or a string.
  the scrdump filename as a string.

EXAMPLES
  -- example to create a "wxt" window with an id of 2 and not save the script.
  plot {
    [...]
    output  = 2,
    scrdump = nil,
  }
  -- example to generate a pdf named "plot.pdf"
  -- and save the script in the "plot.gp" file
  plot {
    output  = "plot.pdf",
    scrdump = "plot.gp",
  }

SEE ALSO
  None.
]=]
__help['plot.scrdump'] = __help['plot.output']

__help['plot.data'] = [=[
NAME
  data, table, tablerange

SYNOPSIS
  plot.data
  plot.table
  plot.tablerange

DESCRIPTION
  Both data and table contains columns of data to be plotted. Those columns can
  be themselves of type table or vector. Columns to be plotted are selected by
  name (i.e. see plot.x1y1). the columns are first searched in data then if not
  found, in table. Columns in data have to be provided with correct length,
  while a range can be provided in tablerange for columns in table.

RETURN VALUES
  data as a table of columns of data to be plotted.
  table as a mtable containing columns of data to be plotted.
  tablerange compatible with range of mtable.

EXAMPLES
  -- This example will plot "y1" against "x1" an "y2" against "x2".
  -- where "xÆ1 is a vector and "y2" a table will be found in data.
  -- and x2, y2 will be searched as columns in the mtable "mtbl" and only
  -- values in lines within range will be used.
  local vec = vector(n):fill{ [...] }
  local tbl = { [...] }
  plot {
    [...]
    data  = { x1 = vec , y2 = tbl  }
    table = mtbl,
    x1y1  = { x1 = "y1", x2 = "y2" }
    range = { 10, 110 }
  }

SEE ALSO
  mtable.range, plot.x1y1, plot.x1y2, plot.x2y1, plot.x2y2.
]=]
__help['plot.table'     ] = __help['plot.data']
__help['plot.tablerange'] = __help['plot.data']

__help['plot.sequence'] = [=[
NAME
  sequence, range, seqdisty, seqdistx, seqshift, nturn, X0, A0

SYNOPSIS
  plot.sequence
  plot.range
  plot.seqdisty
  plot.seqdistx
  plot.seqshift
  plot.nturn
  plot.X0
  plot.A0

DESCRIPTION
  sequence is the sequence or table of sequences from which the layout will be
  plotted. range is the range or table of range from which the layout will be
  plotted. seqdisty allows to position the different sequences along the y axis
  relatively to the first sequence of the list. If seqdisty is a number then all
  subsequent sequences will position at seqdisty to the first one. if seqdisty
  is a table then each i-th value correspond to the distance between the 1st
  and the (i+1)-th sequence. seqdistx is similar to seqdisty but along the x
  axis. seqshift shift all sequences along the x axis (needed to have correct
  spos for subsequence layout as layout always start at spos=0). nturn, x0, A0
  are compatible with survey and represent the number of turn of the sequence
  to be plotted and the initial position and rotation for the surveys.

RETURN VALUES
  sequence has a sequence or table of sequences.
  range compatible with sequence range.
  seqdisty, seqdistx as numbers or tables of numbers.
  seqshift, nturn as numbers.
  X0 and A0 as tables compatible with survey X0 and A0.

EXAMPLES
  -- plot the layout of the two lhc beam around IP5. seqdisty use the mechanical
  -- separation to ajust the distance between the two beam allong the y axis.
  -- seqshift shift the two beam to the correct spos (layout start at 0 by
  -- default).
  plot {
    [...]
    sequence = { lhcb1, lhcb2 },
    range    = { {"E.DS.L5.B1", "S.DS.R5.B1"}, {"E.DS.L5.B2", "S.DS.R5.B2"} },
    seqdisty = lhcb2["E.DS.L5.B2"].mech_sep,
    seqshift = lhcb1:spos(lhcb1:index_of("E.DS.L5.B1")),
  }
  -- plot the survey of lhcb1 from IP2 to IP4 with X0 and A0 as initial survey
  -- condition.
  plot {
    [...]
    sequence  = lhcb1,
    laypos    = "in",
    range     = { "IP2"   , "IP4"      },
    X0        = { -1231.18, 0, 2970.46 },
    A0        = { -pi/4   , 0, 0       },
  }

SEE ALSO
  sequence.range, sequence.nturn, survey.nturn, survey.A0, survey.X0.
]=]
__help['plot.range'   ] = __help['plot.sequence']
__help['plot.seqdisty'] = __help['plot.sequence']
__help['plot.seqdistx'] = __help['plot.sequence']
__help['plot.seqshift'] = __help['plot.sequence']
__help['plot.nturn'   ] = __help['plot.sequence']
__help['plot.X0'      ] = __help['plot.sequence']
__help['plot.A0'      ] = __help['plot.sequence']

__help['plot.laypos'] = [=[
NAME
  laypos, laysize, elemname, elemwidth, elemscale, elemminlen, layangle,
  kindselect, kindcolor

SYNOPSIS
  plot.laypos
  plot.laysize
  plot.elemname
  plot.elemwidth
  plot.elemscale
  plot.elemminlen
  plot.layangle
  plot.kindselect
  plot.kindcolor

DESCRIPTION
  laypos is the position of the layout. It can be a string : "top", "bottom",
  or middle to place it relatively to the plot. It can be a number (0 < y < 1)
  representing the position along the y axis, using screen coordinate (see
  gnuplot documentation). The string "in" will draw the layout inside the plot
  using survey. laysize is the total size taken by the layout along the y axis
  in screen coordinate. elemname is a boolean activating or not the labeling of
  elements (hover over the center of an element with you mouse to see its name
  and its kind). elemwidth, base width of layout element. elemscale, multiplier
  applied to elemwidth. elemminlen allows to filter element to be drawn by their
  length. layangle boolean that activate or not the use of the layangle flags of
  elements to take into account their angle in the layout. kindselect filters
  element to be drawn by their kind. kindcolor allows to choose the fillcolor
  and fillstyle (see gnuplot documentation) for each kind of element. Setting it
  to true will use default color and fillstyle.

RETURN VALUES
  laypos as a string or a number.
  elemname, layangle as a boolean.
  elemwidth, laysize, elemscale, elemminlen as numbers.
  kindselect as a table.
  kindcolor as a boolean, or table.

EXAMPLES
  -- This example will position the layout of lhcb1 bellow the plot, it will
  -- take 40% of the screen, name of element will be shown if hover over their
  -- center, their width will be proportionally set to 0.07*1.5 meters, all
  -- element smaller than 3 meters will not be drawn, the angle of flagged
  -- element will be used and finally only quadrupole in blue and sbend in solid
  -- red will be drawn.
  plot {
    [...]
    sequence   = lhcb1
    laypos     = "bottom",
    laysize    = 0.4,
    elemname   = true,
    elemwidth  = 0.07,
    elemscale  = 1.5,
    elemminlen = 3,
    layangle   = true
    kindselect = {"quadrupole", "sbend"}
    kindcolor  = {
      "quadrupole" = "blue",                 -- if not specified it is fillcolor
      "sbend"      = { fillcolor = "red", fillstyle = "solid" }
    }
  }

SEE ALSO
  survey, gnuplot : screen coordinate, fillstyle, fillcolor.
]=]
__help['plot.laysize'   ] = __help['plot.laypos']
__help['plot.elemname'  ] = __help['plot.laypos']
__help['plot.elemwidth' ] = __help['plot.laypos']
__help['plot.elemscale' ] = __help['plot.laypos']
__help['plot.elemminlen'] = __help['plot.laypos']
__help['plot.layangle'  ] = __help['plot.laypos']
__help['plot.kindselect'] = __help['plot.laypos']
__help['plot.kindcolor' ] = __help['plot.laypos']

__help['plot.x1y1'] = [=[
NAME
  x1y1, x1y2, x2y1, x2y2

SYNOPSIS
  plot.x1y1
  plot.x1y2
  plot.x2y1
  plot.x2y2

DESCRIPTION
  Those four parameters allows to select by name from data or table the columns
  to be plotted and along which gnuplot axis (See gnuplot Axes). if no abscissa
  columns is provided (i.e. x1y1 = "y1") then the line index are used as
  abscissa.

RETURN VALUES
  x1y1, x1y2, x2y1, x2y2 as strings, or tables.

EXAMPLES
  -- This example will plot : y1 and y2 against x1, y3 against x2,
  -- y4 against line indexes using gnuplot x1y1 axis and y5 against x3 using
  -- gnuplot x2y2 axis.
  plot {
    [...]
    x1y1 = { x1 = {"y1", "y2"}, x2 = "y3", "y4" }
    x2y2 = { x3 = "y5" }
  }

SEE ALSO
  plot.data, plot.table, gnuplot : Axes (x1y1, x1y2, x2y1, x2y2).
]=]
__help['plot.x1y2'] = __help['plot.x1y1']
__help['plot.x2y1'] = __help['plot.x1y1']
__help['plot.x2y2'] = __help['plot.x1y1']

__help['plot.title'] = [=[
NAME
  title, legend, xlabel, x2label, ylabel, y2label

SYNOPSIS
  plot.title
  plot.legend
  plot.xlabel
  plot.x2label
  plot.ylabel
  plot.y2label

DESCRIPTION
  title is the string used as plot title. legend is a table that match columns
  name use in axis selection (i.e see gplot.x1y1) to a string as legend.
  xlabel, x2label, ylabel, y2label are strings used as labels for the different
  gnuplot axes.

RETURN VALUES
  legend as a table.
  title, xlabel, x2label, ylabel, y2label as strings.

EXAMPLES
  -- This example will plot two line and set all labels, legend en title.
  plot {
    [...]
    title   = "My plot Title"
    x1y1    = { "y1", "y2" }
    legend  = { y1 = "My legend1", y2 = "My legend 2" }
    xlabel  = " X unit "
    x2label = " X2 unit "
    ylabel  = " Y unit "
    y2label = " Y2 unit "
  }

SEE ALSO
  gplot.x1y1, gplot.x1y2, gplot.x2y1, gplot.x2y2,
  gnuplot: title, legend, xlabel, x2label, ylabel, y2label.
]=]
__help['plot.legend' ] = __help['plot.title']
__help['plot.xlabel' ] = __help['plot.title']
__help['plot.x2label'] = __help['plot.title']
__help['plot.ylabel' ] = __help['plot.title']
__help['plot.y2label'] = __help['plot.title']

__help['plot.xrange'] = [=[
NAME
  xrange, x2range, yrange, y2range

SYNOPSIS
  plot.xrange
  plot.x2range
  plot.yrange
  plot.y2range

DESCRIPTION
  Those parameters set the gnuplot range by providing the minimal and maximal
  value for a given axis (see gnuplot documentation).

RETURN VALUES
  xrange, x2range, yrange, y2range as tables of two numbers.

EXAMPLES
  -- This example sets the range of the x1y1 axis to a square between -1e10
  -- and 1e10 and the x2y2 axis to a square between -0.5 and 0.5.
  plot {
    [...]
    xrange  = { -1e10, 1e10 }
    yrange  = { -1e10, 1e10 }
    x2range = { -0.5 , 0.5  }
    y2range = { -0.5 , 0.5  }
  }
SEE ALSO
  gnuplot :  xrange, x2range, yrange, y2range.
]=]
__help['plot.x2range'] = __help['plot.xrange']
__help['plot.yrange' ] = __help['plot.xrange']
__help['plot.y2range'] = __help['plot.xrange']

__help['plot.plotcfg'] = [=[
NAME
  plotcfg, plotvar, plotcmd

SYNOPSIS
  plot.plotcfg
  plot.plotvar
  plot.plotcmd

DESCRIPTION
  plotcfg is a string that will be dumped in the script (similar to prolog and
  epilog) just before the plot command. It can be used to set/unset some
  gnuplot variables before the plot cmd. plotcmd is a string that will replace
  the standard gnuplot plotting command generated by the plot command
  (see gnuplot documentation). It can contains variables that will be
  interpolated. plotvar is a table containing the user variables for
  interpolation. The command define some variables that plotcmd can use. To have
  more details and example of how to use it see "plot: interpolation"

RETURN VALUES
  plotcfg, plotcmd as strings.
  plotvar as a table.

EXAMPLES
  -- this example use the ${data1} automatically generated variable contains the
  -- name of the gnuplot datablock containing all columns data (here all the c*).
  plot {
    [...]
    x1y1    = { c1 = {"c2", "c3", "c4", "c5", "c6"} },
    plotcfg = "set pm3d map",
    plotcmd = "splot ${data1} matrix",
  }

SEE ALSO
  plot.prolog, plot.epilog, utility.strinterp,
  plot: interpolation, gnuplot : plot.
]=]
__help['plot.plotvar'] = __help['plot.plotcfg']
__help['plot.plotcmd'] = __help['plot.plotcfg']

__help['plot: interpolation'] = [=[
DESCRIPTION
  In this section we will see how the string interpolation of mad can be use
  to customize the gnuplot plotting command using plot.
  First let see how the default command is generated using string interpolation.
  Each line that have to be plotted has its on gnuplot plotting command that
  start from the fixed string bellow :

    "${cmd${id}}${data${id}}${index${id}}${using${id}}with ${style${id}}
     ${lines${id}}${points${id}}${color${id}}${title${id}}${axes${id}}"

  First we interpolate this string by replacing the ${id} by the index of the
  plotting command, for instance the first command will look has follow :

    "${cmd1}${data1}${index1}${using1}with ${style1}${lines1}${points1}${color1}
     ${title1}${axes1}"

  Then the plot command parse all its the parameters, especially the once that
  correspond to the style of the plot lines and create the following variables
  for each index:

    cmd, data, index, using, style, lines, points, color, title, axes

  The command is then once again interpolated with all those new variables. For
  example the first plot command of the examples section bellow would look like
  the following :

    plot '$MAD_DATA' index 0 using 1:2 with lines dashtype '..   ' linewidth 2.3
            linecolor 'red' title 'y1' axes x1y1 ,\
         ''          index 0 using 1:3 with points pointsize 2 pointtype 2
            linecolor 'blue' title 'y3' axes x1y1 ,\
         ''          index 0 using 1:4 with linespoints dashtype '--  '
            linewidth 3.2 pointsize 4.1 pointtype 3 linecolor 'pink' title 'y4'
            axes x1y1 ,\
  So this is how the default mechanism work. Let see now how the two ways that
  we can customize it. The first one is to use plotvar to override so default
  variables. For instance if in the previous example we define in the plotvar
  table a variable named data2 with '$MAD_DATA2' and manually define a
  $MAD_DATA2 datablock (see gnuplot datablocks) with data in gnuplot (using
  gplot to send data or directly using plotcfg), then the second plotting
  command will stay the same but will use another set of data for drawing its
  line. The second way to use this is to define our own plotting command via
  the plotcmd parameter, with inside some interpolated variables that will be
  defined by the plot command (see first example bellow).

EXAMPLES
  -- This example shows the use of both functionalities. We defined our own
  -- plotting command via a plotcmd string that contains interpolated variables.
  -- We also use plotvar to override the command generated color3 to change its
  -- contents.
  plot {
    [...]
    x1y1       = { x1 = {"y1", "y3", "y4" } },
    styles     = { y1 = "lines", y3 = "points", y4 = "linespoints" },
    colors     = { y1 = "red"  , y3 = "blue"  , y4 = "green"       },
    dashtypes  = { y1 = "..   ",                y4 = "--  "        },
    linewidths = { y1 = 2.3    ,                y4 = 3.2           },
    pointtypes = {               y3 = 2       , y4 = 3             },
    pointsizes = {               y3 = 2.0     , y4 = 4.1           },
    plotvar    = { color3 ="linecolor 'pink' " },
    plotcmd    = "\z
      ${cmd1}${data1}${index1}${using1}with ${style1}${lines1}${points1}${color1}${title1}${axes1},\\\n\z
      ${cmd2}${data2}${index2}${using2}with ${style2}${lines2}${points2}${color2}${title2}${axes2},\\\n\z
      ${cmd3}${data3}${index3}${using3}with ${style3}${lines3}${points3}${color3}${title3}${axes3},\\\n\z
    "
  }
  -- this example shows how to handle multiple level of interpolation on the
  -- user side, using a functionality of the object model, being the
  -- auto-evaluation of functions. To do the interpolation you can define the
  -- lamda T bellow and put it at the beginning of the string of all variables
  -- of plotvar need to be interpolated.
  local T = \s\ctx -> s % ctx
  plot {
    [...]
    plotvar = {
      title2  = T"title '${mytitle}' ",
      mytitle = T"title for command (${cmd1}) on axes (${axes2})",
    },
  }

SEE ALSO
  plot.plotcfg, plot.plotvar, plot.plotcmd, utility.strinterp,
  gnuplot : datablocks.
]=]

__help['plot.originx'] = [=[
NAME
  originx, originy, psizex, psizey

SYNOPSIS
  plot.originx
  plot.originy
  plot.psizex
  plot.psizey

DESCRIPTION
  originx, originy set the x and y position of the plot origin in screen
  coordinate (see gnuplot documentation). psizex, psizey define the size of the
  plot along the x and y axes in screen coordinate.

RETURN VALUES
  originx, originy, psizex, psizey as numbers.

EXAMPLES
  -- This example generate a plot that has its origin in the center of the
  -- drawing and take a quarter of its surface (in the top right corner).
  plot {
    [...]
    originx =  0.5,
    originy =  0.5,
    psizex  =  0.5,
    psizey  =  0.5,
  }

SEE ALSO
  gnuplot: screen coordinate, origin, size.
]=]
__help['plot.originy'] = __help['plot.originx']
__help['plot.psizex' ] = __help['plot.originx']
__help['plot.psizey' ] = __help['plot.originx']

__help['plot.datastyles'] = [=[
NAME
    datastyles, styles, colors, dashtypes, linewidths, pointtypes, pointsizes

SYNOPSIS
  plot.datastyles
  plot.styles
  plot.colors
  plot.dashtypes
  plot.linewidths
  plot.pointtypes
  plot.pointsizes

DESCRIPTION
  styles, colors, dashtypes, linewidths, pointtypes, pointsizes allows to set
  gnuplot line style for each selected columns to plot. Those parameters
  directly match what gnuplot is expecting (see gnuplot documentation).
  datastyles allows to do the same thing but specifies at once all styles for a
  signle columns (see example bellow).

RETURN VALUES
  datastyles, styles, colors, dashtypes, linewidths, pointtypes, pointsizes as
  tables.

EXAMPLES
  -- Those two example generate the exact same result and set all possible
  -- styles to display plot data for a single line "y1"
  plot {
    [...]
    x1y1       = "y1",
    datastyles = {
      y1 = {
        style     = "lines",
        color     = "green",
        dashtype  = "..-- ",
        linewidth = 2.3,
        pointtype = 2,
        pointsize = 2.3,
      }
    }
  }
  plot {
    [...]
    x1y1       = "y1",
    styles     = { y1 = "linespoints" },
    colors     = { y1 = "green" },
    dashtypes  = { y1 = "..-- " },
    linewidths = { y1 = 2.3     },
    pointtypes = { y1 = 2       },
    pointsizes = { y1 = 2.3     },
  }

SEE ALSO
  gnuplot : linecolor, linewidth, pointtype, pointsize, dashtype.
]=]
__help['plot.styles'    ] = __help['plot.datastyles']
__help['plot.colors'    ] = __help['plot.datastyles']
__help['plot.dashtypes' ] = __help['plot.datastyles']
__help['plot.linewidths'] = __help['plot.datastyles']
__help['plot.pointtypes'] = __help['plot.datastyles']
__help['plot.pointsizes'] = __help['plot.datastyles']

__help['plot.font'] = [=[
NAME
  font, fontsize, titlefont, titlesize, legendfont, legendsize, legendpos,
  grid, border

SYNOPSIS
  plot.font
  plot.fontsize
  plot.titlefont
  plot.titlesize
  plot.legendfont
  plot.legendsize
  plot.legendpos
  plot.grid
  plot.border

DESCRIPTION
  font, titlefont, legendfont are the name of the font respectively for global
  settings, title and legend. fontsize, titlesize and legendsize are the size in
  points for global settings, title and font. legendpos is the string describing
  the position of the legend (see gnuplot documentation). grid allows to
  set/unset the background grid. border allows to set the border only on the
  sides of interest by adding the code of each side (see gnuplot documentation)

RETURN VALUES
  font, titlefont, legendfont legendpos, grid as strings.
  fontsize, titlesize, legendsize, border as numbers.

EXAMPLES
  -- This example generates a plot that as "Arial Black" and "Aclonica" as
  -- respectively titlefont and legendfont with a size of 21 and 11 points.
  -- The legend will be in the bottom right corner of the plot. The gird will
  -- not be shown and only the bottom and the right border will be shown.
  plot {
    [...]
    titlefont  = "Arial Black",
    titlesize  = 21,
    legendfont = "Aclonica",
    legendsize = 11,
    legendpos  = "bottom right",
    grid       = false,
    border     = 3,
  }

SEE ALSO
  gnuplot : fonts, terminal, title, key, grid, border.
]=]
__help['plot.fontsize'  ] = __help['plot.font']
__help['plot.titlefont' ] = __help['plot.font']
__help['plot.titlesize' ] = __help['plot.font']
__help['plot.legendfont'] = __help['plot.font']
__help['plot.legendsize'] = __help['plot.font']
__help['plot.legendpos' ] = __help['plot.font']
__help['plot.grid'      ] = __help['plot.font']
__help['plot.border'    ] = __help['plot.font']

__help['plot.oshft'] = [=[
NAME
  oshft

SYNOPSIS
  plot.oshft

DESCRIPTION
  It is most likely that you won't neeed to set oshft. The plot command uses
  gnuplot objects to represent element of a layout. Internally gnuplot uses
  index to reference an object. The plot command will create objects with
  indexes starting at oshft. If you use by yourself more than 1000000 object
  then, the plot command might override some of them. To avoid that, you
  can increase the number in oshft.

RETURN VALUES
  oshft as a number.

EXAMPLES
  plot {
    [...]
    oshft = 1000000,
  }

SEE ALSO
  gnuplot : object.
]=]

-- gplot help -----------------------------------------------------------------o

__help.gplot = [=[
NAME
  gplot

SYNOPSIS
  my_gplot = gplot 'mygplot' {}

DESCRIPTION
  gplot is used to manages gnuplot instances by creating it, and writing to it.
  Its unique state is the stream id (sid) of the instance it currently handles.

RETURN VALUE
  An instance of the gplot object.

EXAMPLES
  gplot:set_sid(3)
  gplot:write("reset")
  gplot:printf("set xrange [%e:%e]", xmin, xmax)

SEE ALSO
  plot.
]=]

__help['gplot.sid'] = [=[
NAME
  sid

SYNOPSIS
  gplot.sid

DESCRIPTION
  The sid is the number of the gnuplot instance that the gplot object is
  currently managing.

RETURN VALUE
  The current sid.

EXAMPLES
  gplot.sid          -- 1
  gplot:set_sid(2)
  gplot.sid          -- 2

SEE ALSO
  plot.sid.
]=]

__help['gplot:write'] = [=[
NAME
  write, printf

SYNOPSIS
  gplot:write(str)
  gplot:printf(str, ...)

DESCRIPTION
  The write method writes the given string to the gnuplot instance managed by
  gplot (corresponding sid). The printf method does the same thing but format
  the string using the variadic arguments before writing it.

RETURN VALUE
  None.

EXAMPLES

SEE ALSO
  None.
]=]
__help['gplot:printf'] = __help['gplot:write']

__help['gplot:set_sid'] = [=[
NAME
  set_sid

SYNOPSIS
  gplot:set_sid(number)

DESCRIPTION
  The set_sid method change the sid number of the gnuplot instance managed by
  the gplot object.

RETURN VALUE
  None.

ERRORS
  set_sid triggers an error if the provided sid is not within the allowed range
  (currently 1 <= sid <= 25).

EXAMPLES
  gplot.sid          -- =1
  gplot:set_sid(2)
  gplot.sid          -- =2

SEE ALSO
  None.
]=]

__help['gplot:is_busy'] = [=[
NAME
  is_busy

SYNOPSIS
  gplot:is_busy()

DESCRIPTION
  The is_busy method tells if the corresponding gnuplot is still processing the
  script provided by a previous plot command. NB: it doesn't take into account
  the command sent through gplot directly. It can be use to test if the previous
  command is done before executing a new one (avoiding a blocking wait if the
  maximum number of tmp file is reached : see clean_tmpFile).

RETURN VALUE
  It returns a boolean indicating if the corresponding gnuplot is busy.

EXAMPLES
  gplot:is_busy()                       -- =false
  plot { prolog = "pause 5" }           -- pause during 5 seconds
  gplot:is_busy()                       -- =true

SEE ALSO
  None.
]=]

__help['gplot:clean_tmpfile'] = [=[
NAME
  clean_tmpfile

SYNOPSIS
  gplot:clean_tmpfile()

DESCRIPTION
  Remove all unused temporary files (tmp) from the tmp folder. Those file
  contains the gnuplot scripts not yet processed by gnuplot. This function can
  be used to remove all files that have not been properly removed
  (after a crash for example). The tmp files are used by the plot command and
  written in the "TMP_MAD_PLOT" folder created in the current working directory.
  This folder shouldn't be remove while MAD is running but can be manually
  removed afterward.

RETURN VALUE
  None.

SEE ALSO
  None.
]=]


-- end ------------------------------------------------------------------------o
return __help
