--[=[
 o-----------------------------------------------------------------------------o
 |
 | Table module
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide MAD table objects (TFS tables)
  - Many features have similar implementation to sequences

 o-----------------------------------------------------------------------------o
]=]

-- help -----------------------------------------------------------------------o

local __help = {}
__help.mtable = [=[
NAME
  mtable -- TFS table

SYNOPSIS
  my_tab = mtable 'mytab' { column_name_list... }

DESCRIPTION
  The module table creates TFS tables used by MAD. The columns and the rows can
  be accessed (in this order) by name or by index (rows only). If a name of the
  column name list is itself enclosed into a list (i.e. bracketed), then the
  name of the rows (i.e. strings) can be used to have direct access to the rows.
  Adding news rows or columns let the table grows automatically.

RETURN VALUE
  The TFS table.

ERRORS
  TODO

EXAMPLES
  local mtable in MAD
  tbl = mtable 'survey' { {'name'}, 'x', 'y', 'z', 'phi', 'theta', 'rho' }
  tbl:add_row { 'dft', 0.1, 0.2, 0.5, 0, 0, 0 }
  tbl:add_row { name='mq', x=0.2, y=0.4, z=1 }
  tbl = tbl + { name='mq', x=0.2, y=0.4, z=2 }
  print(tbl.x[2])     -- x of 'mq[1]' using col-then-row access
  print(tbl.mq[1].x)  -- x of 'mq[1]' using row-then-col access
  print(tbl.dft.x)    -- x of 'dft'   using row-then-col access
  tbl:write()         -- equivalent to tab:write "survey.tfs"

SEE ALSO
  sequence, element, beam
]=]

-- locals ---------------------------------------------------------------------o

local Object, vector, env                                        in MAD
local bind1st, bind2nd, bind2st                                  in MAD.gfunc
local sub, ltrue, lfalse                                         in MAD.operator
local is_iterable, is_callable                                   in MAD.concept
local strtrim, strsplit, strbracket, fprintf, kpairs             in MAD.utility
local is_nil, is_boolean, is_number, is_positive, is_string,
      is_table, is_rawtable, is_range, is_file, is_matrix        in MAD.typeid

local max, ceil in math
local strsub = string.sub
local table_new, table_clear, table_insert, table_remove =
      table.new, table.clear, table.insert, table.remove

-- root object ----------------------------------------------------------------o

-- hidden keys.
local _data = {}

local origin = string.format("MAD %s %s %s", env.version, env.os, env.arch)

local mtable = Object '' {
  type='', title='', origin=origin, kind='mtable',
  header = { 'name', 'type', 'title', 'origin', 'date', 'time' },
  column = {},
  reserve=8, novector=nil,
  [_data]={ridx={}, cidx={}, cref=nil, cvec=nil, [0]={nr=0},
           nr=0, nc=0, ng=0, rmax=0},
}

-- backup original methods and metamethods
local mtable_mt = getmetatable(mtable)
local var_raw, var_val = mtable.var_raw, mtable.var_val
local var_get, var_set = mtable_mt.__index, mtable_mt.__newindex
local raw_get, tbl_cpy = mtable.raw_get, mtable.copy
local parent, readonly = mtable.__par, mtable.set_readonly

local function is_mtable (a)
  return is_table(a) and a[_data] ~= nil
end

local function is_orig_mtable (a)
  return is_mtable(a) and raw_get(a, _data) ~= nil
end

local function original (a)
  while raw_get(a, _data) == nil do a = parent(a) end
  assert(not rawequal(a,mtable), "no original mtable found")
  return a
end

-- sanity checks --------------------------------------------------------------o

-- check dictionnary of name -> idx
local function check_dict (tbl)
  local data = var_raw(tbl,_data)
  if is_nil(data.cref) then return end
  local cref = data[data.cref]
  for rn,ri in pairs(data.ridx) do -- name -> index or table of indexes
    if is_number(ri) then
      assert(cref[ri] == rn     , "unexpected corrupted dictionnary")
    elseif is_table(ri) then
      assert(cref[ri[1]] == rn  , "unexpected corrupted dictionnary")
      for i=2,ri.n do
        assert(ri[i-1] < ri[i]  , "unexpected corrupted dictionnary")
        assert(cref[ri[i]] == rn, "unexpected corrupted dictionnary")
      end
    else
      error("unexpected corrupted dictionnary")
    end
  end
end

-- helper for mangled names and row indexes (same as sequence) ----------------o

-- get row index from signed index (direct)
local function index_of_idx (tbl, idx)
  assert(is_number(idx), "invalid argument #2 (index expected)")
  local n = var_raw(tbl,_data).nr
  if idx < 0 then idx = n+idx+1 end -- reflect
  if idx < 1 or idx > n then return nil end
  return idx
end

-- get index from name [with count] (direct)
local function index_of_cnam (tbl, nam, cnt_)
  local ri = var_raw(tbl,_data).ridx[nam]
  if is_table(ri) then
    cnt_ = cnt_ or 1
    assert(is_number(cnt_), "invalid argument #3 (count expected)")
    if cnt_ < 0 then cnt_ = ri.n+cnt_+1 end -- reflect
    return ri[cnt_]
  end
  return ri
end

-- get index from name [with relative count] (linear)
local function index_of_rnam (tbl, nam, cnt_, idx_)
  cnt_ = cnt_ or 1
  assert(is_number(cnt_), "invalid argument #3 (count expected)")
  local ri = var_raw(tbl,_data).ridx[nam]
  if is_nil(ri) then return nil end
  idx_ = index_of_idx(tbl, idx_ or 1)
  if is_nil(idx_) then return nil end
  if is_number(ri) then
    return (cnt_ ==  1 and ri >= idx_ and ri) or
           (cnt_ == -1 and ri <= idx_ and ri) or nil
  end
  if cnt_ > 0 then
    for i=1,ri.n do
      if ri[i] >= idx_ then return ri[i+cnt_-1] end
    end
  elseif cnt_ < 0 then
    for i=1,ri.n do
      if ri[i] >  idx_ then return ri[i+cnt_  ] end
    end
  end
  return nil
end

-- get index from [mangled] name (direct or linear)
local function index_of_nam (tbl, nam, idx_)
  assert(is_string(nam), "invalid argument #2 (string expected)")
  local nam, cnt, _, bra = strbracket(nam)
  cnt = tonumber(cnt) or cnt
  if is_nil(idx_) or bra ~= 2 then
    return index_of_cnam(tbl, nam, cnt      )
  else
    return index_of_rnam(tbl, nam, cnt, idx_)
  end
end

-- get [mangled] name from index (linear)
local function name_of_idx (tbl, idx)
  idx = index_of_idx(tbl, idx)
  if is_nil(idx) then return nil end
  local data = var_raw(tbl,_data)
  assert(data.cref, "no reference column found")
  local nam = data[data.cref][idx]
  local ri  = data.ridx[nam]
  if is_number(ri) then
    assert(ri == idx, "unexpected corrupted dictionnary")
    return nam
  end
  for i=1,ri.n do
    if ri[i] == idx then
      return string.format("%s[%d]", nam, i)
    end
  end
  error("unexpected corrupted dictionnary")
end

-- build mtable ---------------------------------------------------------------o

-- finalize mtable
local function finish_mtbl (tbl)
  -- sanity checks
  if MAD.option.debug > 2 then
    check_dict(tbl)
  end
end

-- mtable initialization
local function mtbl_init (tbl)
  local nc = tbl:raw_len()
  if nc == 0 then return tbl end -- empty

  local nr   = tbl.reserve          -- forseen rows
  local data = table_new(nc, 8)     -- columns (data)
  data.ridx  = table_new( 0,nr)     -- name -> idx
  data.cidx  = table_new(nc+1,nc+1) -- name -> idx and idx -> name
  data[0]    = table_new(nr, 1)     -- selected rows
  data.nr    = 0                    -- #rows
  data.nc    = nc                   -- #cols
  data.ng    = 0                    -- #gens
  data.rmax  = 1                    -- allocated rows (specialize after 1st row)

  for i=1,nc do
    local col = raw_get(tbl,i)      -- column key
    if is_table(col) then           -- ref: { key }
      assert(is_rawtable(col) and is_nil(col[2]), "invalid reference column")
      data.cref, col = i, col[1]
    end
    assert(is_string(col), "invalid column name (string expected)")
    data.cidx[col], data.cidx[i] = i, col
    data[i] = {nr=0}
  end
  data[0].nr, data.cidx.is_selected, data.cidx[0] = 0, 0, 'is_selected'
  tbl:clear_array() -- clear list of column names
  tbl.date, tbl.time = os.date'%d/%m/%y', os.date'%H:%M:%S'
  tbl[_data] = data
  finish_mtbl(tbl)
  return tbl
end

-- mtable metamethods ---------------------------------------------------------o

local _idx, _gen = {}, {}

-- generator proxy
local function gen_iter (s, i)
  i = i+1
  if i <= s[_data].nr then return i, s[_gen](i) end
end

local gen_mt = {
  __len       =\s   -> s[_data].nr,
  __index     =\s,i -> i >= 1 and i <= s[_data].nr and s[_gen](i) or nil,
  __pairs     =\s   -> (gen_iter, s, 0),
  __ipairs    =\s   -> (gen_iter, s, 0),
  __tostring  =\s   -> string.format("<mtable column generator> %p", s),

  __newindex := error("forbidden write access to column generator", 2),
  __kpairs   := error("invalid access to column generator"        , 2),
}

-- column proxy (RO)
local function col_iter (s, i)
  i = i+1
  if i <= s[_data].nr then return i, s[_data][i] end
end

local col_mt = {
  __len       =\s   -> s[_data].nr,
  __index     =\s,i -> i >= 1 and i <= s[_data].nr and s[_data][i] or nil,
  __pairs     =\s   -> (col_iter, s, 0),
  __ipairs    =\s   -> (col_iter, s, 0),
  __tostring  =\s   -> string.format("<mtable readonly column> %p", s),

  __newindex := error("forbidden write access to readonly column", 2),
  __kpairs   := error("invalid access to readonly column"        , 2),
}

-- row proxy
local function row_iter (s, i)
  i = i+1
  local col = s[_data][i]
  if col then return i, col[s[_idx]] end
end

local function row_kiter (s, k)
  local data = s[_data]
  local i = k and data.cidx[k]+1 or 1
  local col = data[i]
  if col then return data.cidx[i], col[s[_idx]] end
end

local row_mt = {
  __len       =\s   -> s[_data].nr,
  __index     =\s,i => local data = s[_data]
                       local col = is_number(i) and data[i] or data[data.cidx[i]]
                       if col then return col[s[_idx]] end
                       end,
  __newindex  =\s,i,v => local data = s[_data]
                       local col = is_number(i) and data[i] or data[data.cidx[i]]
                       assert(col, "invalid column (write access)")
                       col[s[_idx]] = v
                       end,
  __pairs     =\s   -> (row_iter , s, 0  ),
  __ipairs    =\s   -> (row_iter , s, 0  ),
  __kpairs    =\s   -> (row_kiter, s, nil),
  __tostring  =\s   -> string.format("<mtable row> %p", s),

}

-- count proxy
local function cnt_iter (s, i)
  i = i+1
  local ri = s[_idx][i]
  if ri then s[_data][_idx] = ri return i, s[_data] end
end

local cnt_mt = {
  __len       =\s   -> s[_idx].n,
  __index     =\s,i => local ri = s[_idx][i]
                       if ri then s[_data][_idx] = ri return s[_data] end
                       end,
  __pairs     =\s   -> (cnt_iter, s, 0),
  __ipairs    =\s   -> (cnt_iter, s, 0),
  __tostring  =\s   -> string.format("<mtable count> %p", s),

  __newindex := error("forbidden write access to counts", 2),
  __kpairs   := error("invalid access to mtable counts" , 2),
}

-- iterators over rows
local function rows_iter (row, i)
  i = i+1
  if i <= row[_data].nr then row[_idx] = i ; return i, row end
end

local function ipairs_mm (tbl)
  local row = setmetatable({[_idx]=0, [_data]=var_raw(tbl,_data)}, row_mt)
  return rows_iter, row, 0
end

-- number of rows
local function len_mm (tbl)
  return var_raw(tbl,_data).nr
end

-- read access precedence: row index, variable key, column key, row key.
local function index_mm (tbl, key)
  -- row index
  if is_number(key) then              -- see index_of_idx
    local data = var_raw(tbl,_data)
    local n = data.nr
    if key < 0 then key = n+key+1 end -- reflect
    if key < 1 or key > n then return nil end
    return setmetatable({[_idx]=key, [_data]=data}, row_mt)
  end
  -- variable
  local var = var_raw(tbl, key)
  if var then return var_val(tbl, key, var) end
  -- column name
  local data = var_raw(tbl,_data)
  local idx = data.cidx[key]
  if idx then return data[idx] end -- full column
  -- row name
  local idx = data.ridx[key]
  if is_number(idx) then
    return setmetatable({[_idx]=idx, [_data]=data}, row_mt)
  elseif is_table(idx) then
    return setmetatable({[_idx]=idx, [_data]=
           setmetatable({[_idx]=0  , [_data]=data}, row_mt)}, cnt_mt)
  end
end

local function newindex_mm (tbl, key, val)
  local data = var_raw(tbl,_data)
  -- row index or col/row name
  if is_number(key) or data.cidx[key] or data.ridx[key] then
    error("invalid mtable write access (use 'set' methods)")
  end
  -- variables
  var_set(tbl, key, val)
end

-- readonly protection --------------------------------------------------------o

local function set_readonly (tbl, set_)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  local data = raw_get(tbl,_data)
  if set_ ~= false and not tbl:is_readonly() then -- RW -> RO
    for i=1,data.nc-data.ng do
      data[i] = setmetatable({ [_data]=data[i] }, col_mt)
    end
  elseif set_ == false and tbl:is_readonly() then -- RO -> RW
    for i=1,data.nc-data.ng do
      data[i] = data[i][_data]
    end
  end
  return readonly(tbl, set_)
end

-- methods (readonly) ---------------------------------------------------------o

local function name_of (tbl, a)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  if is_number(a) then return name_of_idx(tbl, a) end
  error("invalid argument #2 (number expected)")
end

local function index_of (tbl, a, ref_)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
      if is_number(a) then return index_of_idx(tbl, a)
  elseif is_string(a) then return index_of_nam(tbl, a, ref_)
  end
  error("invalid argument #2 (number or string expected)")
end

local function range_of (tbl, rng, ref_)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  local start, stop
  if is_number(rng) then
    start = index_of_idx(tbl, rng)
    return start, start
  elseif is_string(rng) then
    local s1, i2 = strsplit(rng, "/" )
    local s2 = i2 > 0 and strtrim(rng, i2+1) or nil
    start, stop = tonumber(s1) or s1, tonumber(s2) or s2
  elseif is_table(rng) then
    start, stop = rng[1], rng[2]
  elseif is_range(rng) then
    start, stop = rng:bounds()
  else error "invalid argument #2 (index, string, range or table expected)"
  end
  start = index_of(tbl, start, ref_)
  stop  = stop and index_of(tbl, stop, ref_ or start) or start
  return start, stop
end

local function length_of (tbl, rng_, ntrn_)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  local siz = rng_ and 1-sub(range_of(tbl, rng_)) or 0
  return siz + #tbl * ((ntrn_ or 0) + (siz <= 0 and 1 or 0))
end

-- dict helpers ---------------------------------------------------------------o

-- insert to dictionnary name -> idx (warning: indexes are not shifted)
local function ins_idx (data, idx)
  if is_nil(data.cref) then return end
  local nam = data[data.cref][idx]
  local val = data.ridx[nam]
  if is_nil(val) then             -- none: scalar
    data.ridx[nam] = idx
  elseif is_number(val) then      -- one : scalar to array
    data.ridx[nam] = val > idx and {idx, val, n=2} or {val, idx, n=2}
  else                            -- many: insert
    local i, n = 1, val.n
    while i <= n and idx <= val[i] do i = i+1 end
    while i <= n do val[i], idx, i = idx, val[i], i+1 end
    val.n, val[i] = i, idx
  end
end

-- remove from dictionnary name -> idx (warning: indexes are not shifted)
local function rem_idx (data, idx)
  if is_nil(data.cref) then return end
  local nam = data[data.cref][idx]
  local val = data.ridx[nam]
  if is_number(val) then          -- one : delete
    data.ridx[nam] = nil
  elseif val.n == 2 then          -- two : array to scalar
    data.ridx[nam] = val[1] == idx and val[2] or val[1]
  else                            -- many: remove
    local i, n = 1, val.n
    while idx < val[i] do i = i+1 end
    assert(idx == val[i], "unexpected corrupted dictionnary")
    while i < n do val[i], i = val[i+1], i+1 end
    val.n, val[i] = i-1, nil
  end
end

-- add to dictionnary name -> idx (warning: indexes are not shifted)
local function add_idx (data, idx)
  if is_nil(data.cref) then return end
  local nam = data[data.cref][idx]
  local val = data.ridx[nam]
  if is_nil(val) then             -- none: scalar
    data.ridx[nam] = idx
  elseif is_number(val) then      -- one : scalar to array
    data.ridx[nam] = {val, idx, n=2}
  else                            -- many: append
    local n = val.n+1
    val[n], val.n = idx, n
  end
end

-- build dictionnary name -> idx
local function build_idx (tbl)         -- must be very fast (see add_idx)
  local data = var_raw(tbl,_data)
  if is_nil(data.cref) then return end -- no reference column
  table_clear(data.ridx)               -- reuse main storage
  for i=1,data.nr do add_idx(data, i) end
end

-- memory helpers -------------------------------------------------------------o

-- expand vectors, specialize on 1st row unless novector is set
local function expand (data, tbl, extra)
  local rmax = ceil(max(tbl.reserve, data.rmax*1.5, data.rmax+extra))
  assert(rmax <= 1e8, "too big mtable") -- should see 'out of memory' first
  if is_nil(data.cvec) then data.cvec = tbl.novector ~= true end
  local nr, nc = data.nr, data.nc-data.ng
  for i=1,nc do
    local val = data[i]
    if data.cvec and is_number(data[i][1]) then
      data[i] = vector(rmax)
      data[i].nr = nr
      if nr > 1 then data[i]:copy(val) else data[i][1] = val[1] end
    elseif data.rmax == 1 then -- expand only for 1st row
      data[i] = table_new(rmax,1)
      data[i][1], data[i].nr = val[1], nr
    end
  end
  data.rmax = data.cvec and rmax or 1e8
end

-- methods (R/W, update dict) -------------------------------------------------o

local function get_col (tbl, key)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  local data = var_raw(tbl,_data)
  local idx = is_number(key) and key or data.cidx[key]
  if is_nil(idx) then return nil end
  if idx < 0 then idx = data.nr+idx+1 end
  return data[idx] -- full column data, column generator or nil
end

local function add_col (tbl, key, val)
  assert(is_orig_mtable(tbl), "invalid argument #1 (original mtable expected)")
  assert(is_string(key)     , "invalid argument #2 (string expected)")
  local data = raw_get(tbl,_data)
  assert(is_nil(data.cidx[key]), "invalid argument #2 (column name already in use)")

  if is_callable(val) then     -- generator
    local idx = data.nc+1
    data[idx] = setmetatable({ [_data]=data, [_gen]=val }, gen_mt)
    data.cidx[key], data.cidx[idx], data.ng = idx, key, data.ng+1
  elseif is_iterable(val) then -- iterable
    assert(#val >= data.nr, "invalid argument #2 (longer iterable expected)")
    local idx = data.nc-data.ng+1
    if data.cvec and is_number(val[1]) then
      table_insert(data, idx, vector(data.rmax):fill(val))
    else
      table_insert(data, idx, table_new(data.rmax,1))
      for i=1,data.nr do data[idx][i] = val[i] end
    end
    data[idx].nr = nr
    for k,i in kpairs(data.cidx) do
      if i >= idx then data.cidx[k] = i+1 end
    end
    data.cidx[key] = idx
    table_insert(data.cidx, idx, key)
  end
  data.nc = data.nc+1
end

local function rem_col (tbl, key)
  assert(is_orig_mtable(tbl), "invalid argument #1 (original mtable expected)")
  assert(is_string(key)     , "invalid argument #2 (string expected)")
  local data = var_raw(tbl,_data)
  local idx  = data.cidx[key]
  assert(idx, "invalid argument #2 (valid column expected)")
  assert(idx > data.nc-data.ng, "invalid argument #2 (generator column expected)")
  table_remove(data, idx)
  table_remove(data.cidx, idx)
  data.nc, data.ng, data.cidx[key] = data.nc-1, data.ng-1
  for k,i in kpairs(data.cidx) do
    if i > idx then data.cidx[k] = i-1 end
  end
end

local function cpy_row (data, idx, val, i0, nr) -- not exposed
  if val[1] then             -- copy by idx-value
    for i=1,data.nc-data.ng do
      data[i].nr = nr
      data[i][idx] = val[i0+i]
    end
    data[0].nr = nr
    data[0][idx] = true
  else                       -- copy by key-value
    for k,v in pairs(val) do
      local col = data[data.cidx[k]]
      assert(col, "invalid argument #3 (valid column expected)")
      col.nr = nr
      col[idx] = v
    end
  end
end

local function get_row (tbl, key, ref_)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  local idx = index_of(tbl, key, ref_)
  if is_nil(idx) then return nil end
  return setmetatable({[_idx]=idx, [_data]=var_raw(tbl,_data)}, row_mt)
end

local function add_row (tbl, val, ini_)
  ini_ = ini_ or 1
  assert(is_mtable(tbl)  , "invalid argument #1 (mtable expected)")
  assert(is_iterable(val), "invalid argument #2 (iterable expected)")
  assert(is_number(ini_) , "invalid argument #3 (number expected)")
  local data = var_raw(tbl, _data)
  local idx  = data.nr+1
  if idx > data.rmax then expand(data, tbl, 1) end
  cpy_row(data, idx, val, ini_-1, idx)
  add_idx(data, idx)
  data.nr = idx
  return tbl
end

local function set_row (tbl, key, val, ini_)
  ini_ = ini_ or 1
  assert(is_mtable(tbl)  , "invalid argument #1 (mtable expected)")
  local idx = index_of(tbl, key)
  assert(is_number(idx)  , "invalid argument #2 (valid row expected)")
  assert(is_iterable(val), "invalid argument #3 (iterable expected)")
  assert(is_number(ini_) , "invalid argument #4 (number expected)")
  local data = var_raw(tbl, _data)
  rem_idx(data, idx)
  cpy_row(data, idx, val, ini_-1, data.nr)
  ins_idx(data, idx)
  return tbl
end

local function swp_row (tbl, key1, key2, ref_)
  assert(is_mtable(tbl) , "invalid argument #1 (mtable expected)")
  local idx1, idx2 = index_of(tbl, key1, ref_), index_of(tbl, key2, ref_)
  assert(is_number(idx1), "invalid argument #2 (valid row expected)")
  assert(is_number(idx2), "invalid argument #3 (valid row expected)")
  if idx1 == idx2 then return tbl end
  local data = var_raw(tbl, _data)
  rem_idx(data, idx1) ; rem_idx(data, idx2)
  for i=0,data.nc-data.ng do
    data[i][idx1], data[i][idx2] = data[i][idx2], data[i][idx1]
  end
  ins_idx(data, idx1) ; ins_idx(data, idx2)
  return tbl
end

-- functional methods ---------------------------------------------------------o -- TODO

--[=[
programming model:
tbl:foreach {
  action=function,
  range=range,
  selected=t/f/nil, pattern=string, kind=string, select=predicate -- AND'ed selections
  default=nil/'none'
}
tbl:foreach(action, range, select, not)
tbl:select/deselect(range, select, not)
tbl:filter(range, select, default)
without any selection criterium:
  not ~= true and default ~= 'none' -> select all
  not == true or  default == 'none' -> select nothing
]=]

local pknd   = \knd,k,  r,i -> knd[i] == k
local psel   = \sel,    r,i -> sel[i] == true
local pnam   = \ref,pat,r,i -> string.match(ref[i], pat) ~= nil
local pand   = \p,p2,   r,i -> p(r,i) and p2(r,i)
local ptrue  = \p,_ ,   r,i -> p(r,i) and true
local pfalse = \p,_ ,   r,i -> p(r,i) or false

local function foreach (tbl, act, rng_, sel_, not_) -- action, range, selection, default
  local f, p
  if is_nil(rng_) and is_rawtable(act) then
    f, rng_ = act.action, act     -- extract action + right shift
  else
    f = act
  end
  if is_nil(sel_) and is_rawtable(rng_) and is_nil(rng_[1]) then
    rng_, sel_ = rng_.range, rng_ -- extract range  + right shift
  end
  if is_nil(not_) and is_boolean(sel_) then
    not_, sel_ = sel_             --                  right shift
  end

  local data = var_raw(tbl, _data)
  if is_rawtable(sel_) then       -- logically and'ed selections
    if is_nil(not_) and (sel._default == 'none' or sel._default == true) then
      not_ = true
    end
    local op = not_ ~= true and ptrue or pfalse
    if sel_.select then
      assert(is_callable(sel_.select), "invalid select (callable expected)")
      op, p = pand, bind2st(op, sel_.select, p)
    end
    if sel_.pattern then
      assert(is_string(sel_.pattern), "invalid pattern (string expected)")
      assert(data.cref, "unexpected pattern selection (no reference column)")
      op, p = pand, bind2st(op, bind2st(pnam,data[data.cref], sel_.pattern), p)
    end
    if sel_.kind then
      assert(is_string(sel_.kind), "invalid kind (string expected)")
      assert(data.cidx.kind, "unexpected 'kind' selection (no 'kind' column)")
      op, p = pand, bind2st(op, bind2st(pknd,data[data.cidx.kind], sel_.kind),p)
    end
    if sel_.selected then
      op, p = pand, bind2st(op, bind1st(psel, data[0]), p)
    end
  elseif not is_nil(sel_) then    -- build the selection
    p = is_boolean (sel_) and bind1st(psel, data[0])               or
        is_string  (sel_) and assert(data.cref, "unexpected pattern selection (no reference column)")
                          and bind2st(pnam, data[data.cref], sel_) or
        is_callable(sel_) and sel_                                 or nil
  end
  if is_nil(p) then p = not_ ~= true and ltrue or lfalse end

  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  assert(is_callable(f), "invalid argument #2 (callable expected)")
  assert(is_callable(p), "invalid argument #4 (callable expected)")

  if p ~= lfalse then
    for idx,row in tbl:iter(rng_) do
      if p(row,idx) then f(row,idx) end
    end
  end
  return tbl
end

local do_select = \sel,_,i => sel[i] = true end

local function select (tbl, rng_, sel_, not_)
  local f = bind2nd(do_select, var_raw(tbl,_data)[0])
  return tbl:foreach(f, rng_, sel_, not_)
end

local do_deselect = \sel,_,i => sel[i] = false end

local function deselect (tbl, rng_, sel_, not_)
  local f = bind2nd(do_deselect, var_raw(tbl,_data)[0])
  return tbl:foreach(f, rng_, sel_, not_)
end

local do_filter = \idx,_,i => local n=idx.n+1 ; idx[n], idx.n = i, n end

local function filter (tbl, rng_, sel_, not_)
  local idx = table_new(8,1)
  local f = bind1st(do_filter, idx)
  idx.n = 0
  tbl:foreach(f, rng_, sel_, not_)
  return idx
end

-- methods (R/W, rebuild dict) ------------------------------------------------o -- TODO

local function rebuild_index (tbl, key_)
  assert(is_orig_mtable(tbl), "invalid argument #1 (original mtable expected)")
  if key_ then -- change reference column
    local data = var_raw(tbl, _data)
    local idx = is_number(key_) and key_ or data.cidx[key_]
    assert(idx, "invalid argument #2 (valid column expected)")
    data.cref = idx
  end
  build_idx  (tbl)
  finish_mtbl(tbl)
  return tbl
end

local function remove (tbl, rng_, sel_)
  assert(is_orig_mtable(tbl), "invalid argument #1 (original mtable expected)")

  -- collect indexes of elements to remove
  local idx_r = filter(tbl, rng_, sel_, true)
  local nr = idx_r.n
  if nr == 0 then return end
  assert(idx_r[nr]-idx_r[1] >= nr-1, "invalid range, indexes must be increasing")

  -- move rows by increasing indexes
  local data = raw_get(tbl,_data)
  local j, nc = 0, data.nc-data.ng
  for ii=idx_r[1],data.nr-nr do
    if ii == idx_r[j+1] then j = j+1 end
    for i=0,nc do data[i][ii] = data[i][ii+j] end
  end
  data.nr = data.nr - nr
  for i=0,nc do data[i].nr = data.nr end
  assert(j == nr, "unexpected corrupted move of rows (remove)")

  rebuild_index(tbl)
  return tbl
end

local function insert (tbl, rows, rng_, sel_)
  assert(is_orig_mtable(tbl), "invalid argument #1 (original mtable expected)")

  -- collect indexes of elements to remove
  local idx_r = filter(tbl, rng_, sel_, true)
  local nr = idx_r.n
  if nr == 0 then return end
  assert(idx_r[nr]-idx_r[1] >= nr-1, "invalid range, indexes must be increasing")

  -- expand if needed
  local data = raw_get(tbl,_data)
  if data.nr+nr > data.rmax then expand(data, tbl, nr) end

  -- move rows by decreasing indexes
  local j, nc = nr, data.nc-data.ng
  data.nr = data.nr + nr
  for i=0,nc do data[i].nr = data.nr end
  for ii=data.nr,idx_r[1],-1 do
    if ii == idx_r[j] then
      for i=0,nc do data[i][ii] = rows[j][i] end
      j = j-1
    else
      for i=0,nc do data[i][ii] = data[i][ii-j] end
    end
  end
  assert(j == 0, "unexpected corrupted move of rows (insert)")

  rebuild_index(tbl)
  return tbl
end

local function sort (tbl, cmp, rng_, sel_)
  assert(is_orig_mtable(tbl), "invalid argument #1 (original mtable expected)")
  assert(is_callable(cmp)   , "invalid argument #2 (callable expected)")

  -- collect indexes of elements to remove
  local idx_r = filter(tbl, rng_, sel_, true)
  local nr = idx_r.n
  if nr == 0 then return end
  assert(idx_r[nr]-idx_r[1] >= nr-1, "invalid range, indexes must be increasing")

  -- sort indexes (indirectly)
  local data  = raw_get(tbl,_data)
  local row1  = setmetatable({[_idx]=0, [_data]=data}, row_mt)
  local row2  = setmetatable({[_idx]=0, [_data]=data}, row_mt)
  local idx_s = table.copy(idx_r, table_new(nr,0))
  table.sort(idx_s, \i1,i2 => row1[_idx], row2[_idx] = idx_s[i1], idx_s[i2]
                              return cmp(row1,row2) end)

  -- build lookup table
  local idx_l = table_new(0,nr)
  for i=1,nr do idx_l[idx_s[i]] = idx_r[i] end

  -- sort rows
  local nc = data.nc-data.ng
  local tmp = table_new(nc,0)
  for ii=1,nr do
    local s, r = idx_s[ii], idx_l[idx_s[ii]]
    if s == r then -- identity (cleanup)
      idx_l[s] = nil
    elseif r then  -- not yet processed
      local ts = s
      for i=1,nc do tmp[i] = data[i][s] end
      while r ~= ts do
        for i=1,nc do data[i][s] = data[i][r] end
        s, r, idx_l[s] = r, idx_l[r]
      end
      for i=1,nc do data[i][s] = tmp[i] end
      idx_l[s] = nil
    end
  end
  assert(is_nil(next(idx_l)), "unexpected corrupted lookup indexes (sort)")

  rebuild_index(tbl)
  return tbl
end

local function copy (tbl, name_)
  assert(not rawequal(tbl, mtable), "invalid argument #1 (cannot copy 'mtable')")
  assert(is_mtable(tbl)           , "invalid argument #1 (mtable expected)")
  local cpy  = tbl_cpy(tbl,name_)
  local data = raw_get(tbl,_data)
  if not data then return cpy end -- tbl is not an original table

  local nr, nc, ng = data.nr, data.nc, data.ng
  local cdat = table_new(nc, 8) -- see mtbl_init
  cdat.ridx  = table_new( 0,nr)  -- name -> idx
  cdat.cidx  = table_new(nc,nc)  -- name -> idx and idx -> name
  cdat.nr    = nr                -- #rows
  cdat.nc    = nc                -- #cols
  cdat.ng    = ng                -- #gens
  cdat.rmax  = nr                -- allocated rows
  cdat.cref  = data.cref         -- reference column (if any)
  cdat.cvec  = data.cvec         -- use vectors for column

  table.copy(data.cidx, nil, cdat.cidx)

  for i=0,nc-ng do                              -- copy data columns
    cdat[i] = is_table(data[i]) and table_new(nr,1) or vector(nr)
    for j=1,nr do cdat[i][j] = data[i][j] end
    cdat[i].nr = nr
  end
  for i=nc-ng+1,nc do                           -- copy generators
    cdat[i] = setmetatable({ [_data]=cdat, [_gen]=data[i][_gen] }, gen_mt)
  end

  cpy[_data] = cdat
  rebuild_index(cpy)
  return cpy
end

-- special --------------------------------------------------------------------o

local function cycle (tbl, ref)
  assert(is_mtable(tbl)    , "invalid argument #1 (mtable expected)")
  assert(index_of(tbl, ref), "invalid argument #2 (reference expected)")
  tbl.start_at = ref
  return tbl
end

-- iterators ------------------------------------------------------------------o

local function fwditer (state, i)
  if i == state.stop then
    if state.turn == 0 then return nil end
    state.turn = state.turn-1
  end
  i = i < state.n and i+1 or 1
  state.row[_idx] = i
  return i, state.row
end

local function bwditer (state, i)
  if i == state.stop then
    if state.turn == 0 then return nil end
    state.turn = state.turn-1
  end
  i = i > 1 and i-1 or state.n
  state.row[_idx] = i
  return i, state.row
end

local function iter (tbl, rng_, ntrn_, dir_)
  local nturn, dir = ntrn_ or 0, dir_ or 1
  assert(is_mtable(tbl)                  ,"invalid argument #1 (mtable expected)")
  assert(is_number(nturn) and nturn >= 0 ,"invalid argument #3 (number expected)")
  assert(is_number(dir) and abs(dir) == 1,"invalid argument #4 (direction expected)")

  local start, stop
  if is_nil(rng_) then
    local s0, sn = 1, #tbl
    if dir < 0 then s0, sn = sn, s0 end
    if is_nil(tbl.start_at) then
      start, stop = s0, sn
    else
      start = assert(index_of(seq, tbl.start_at), "invalid cycle reference")
      stop  = start == s0 and sn or start-dir
    end
  else
    start, stop = range_of(tbl, rng_)
    assert(is_number(start), "invalid range start")
    assert(is_number(stop ), "invalid range stop" )
  end
  if start == stop+dir then nturn = nturn+1 end

  local row = setmetatable({[_idx]=0, [_data]=var_raw(tbl,_data)}, row_mt)
  return dir > 0 and fwditer or bwditer,
         { row=row, n=#tbl, stop=stop, turn=nturn }, start-dir
end

-- I/O methods ----------------------------------------------------------------o

local function write(tbl, filnam_, colnam_, hdrnam_)
  if is_table(filnam_) and is_nil(hdrnam_) then
    filnam_, colnam_, hdrnam_ = nil, filnam_, colnam_ -- right shift
  end
  local cnam = colnam_ or tbl.column
  local hnam = hdrnam_ or tbl.header
  local data = var_raw(tbl,_data)
  local nrow = data.nr
  local ncol = #cnam
  local cols = table_new(ncol, 0)

  -- collect column
  for i=1,ncol do
    local idx = is_number(cnam[i]) and cnam[i] or data.cidx[cnam[i]]
    cols[i] = assert(data[idx], "invalid column name or index")
  end

  -- open file
  local file
  if is_file(filnam_) then
    file = filnam_
    assert(io.type(file) == 'file', "invalid argument #2 (open file expected)")
  elseif rawequal(filnam_,'-') then
    file = io.stdout
  else
    local fname = filnam_ or tbl.name or 'tmptable'
    assert(is_string(fname), "invalid argument #2 (string expected)")
    if strsub(fname,-4) ~= '.tfs' then fname = fname .. '.tfs' end
    local handle, err = io.open(fname, 'w')
    if not handle then
      error("unable to open file '" .. fname .. "' for writing: " .. err)
    end
    file = handle
  end

  -- dump header
  for i=1,#hnam do
    local k, v = hnam[i], tbl[hnam[i]]
    if is_string(v) then
      fprintf(file, '@ %-18s %%%02ds %q\n', k, #v, v)
    elseif is_number(v) then
      fprintf(file, '@ %-18s %%le %s\n', k, tostring(v))
    elseif is_boolean(v) then
      fprintf(file, '@ %-18s %%b %s\n', k, tostring(v))
    else
      fprintf(file, '@ %-18s %%? %s\n', k, tostring(v))
    end
  end

  -- dump col names
  file:write('*')
  for i=1,ncol do
    fprintf(file, ' %-17s ', cnam[i])
  end
  file:write('\n')

  -- dump col types
  file:write('$')
  for i=1,ncol do
    local v = cols[i][1]
    local fmt = is_string (v) and '%s'
             or is_number (v) and '%le' or '%?'
    fprintf(file, ' %-17s ', fmt)
  end
  file:write('\n')

  -- dump rows
  for j=1,nrow do
    if cols[0] then -- is_selected
      file:write(' ')
      for i=1,ncol do
        local v = cols[i][j]
        if is_string(v)
        then fprintf(file, '%-18s ', '"'..v..'"')
        else fprintf(file, '%-18s ', tostring(v))
        end
      end
      file:write('\n')
    end
  end

  -- close file
  if not rawequal(filnam_,'-') then
    file:close()
  end

  return tbl
end

-- env ------------------------------------------------------------------------o

MAD.typeid.is_mtable          = is_mtable
MAD.typeid.is_original_mtable = is_orig_mtable

-- members --------------------------------------------------------------------o

mtable.original = original

mtable: set_methods {
  -- columns manipulation
  getcol        = get_col,
  addcol        = add_col,
  remcol        = rem_col,

  -- rows manipulation
  getrow        = get_row,
  addrow        = add_row,
  setrow        = set_row,
  swprow        = swp_row,

  -- sequence-like methods
  name_of       = name_of,
  index_of      = index_of,
  range_of      = range_of,
  length_of     = length_of,

  foreach       = foreach,
  select        = select,
  deselect      = deselect,
  filter        = filter,

  remove        = remove,
  insert        = insert,
  sort          = sort,
  copy          = copy,

  cycle         = cycle,

  iter          = iter,

  -- read/write
  read         := error("NYI", 2), -- TODO (using splitall or LPEG)
  write         = write,

  -- readonly
  set_readonly  = set_readonly,

  -- debug
  rebuild_index = rebuild_index, -- debug

  -- disabled methods
  is_selected  := error("invalid mtable operation", 2),

} : set_metamethods ({
  __add         = add_row,
  __len         = len_mm,
  __index       = index_mm,
  __newindex    = newindex_mm,
-- __pairs      = pairs_mm, default
  __ipairs      = ipairs_mm,
-- __kpairs     = kpairs_mm, default

  __copy        = copy,
  __init        = mtbl_init,

}, true): set_readonly()

-- end ------------------------------------------------------------------------o
return {
  mtable = mtable,
  __help = __help,
}


--[[ 'High level table access is very slow!
code A:
t0=os.clock()
do
  local a, t = 0, MAD.mtable 'mytable' { {'name'}, 'x', 'y', 'z' }
  t=t+{'A', 1.1,1.2,1.3}+{'B', 2.1,2.2,2.3}+{'A', 3.1,3.2,3.3}
  for i=1,1e7 do a=a+t.B.x end
  print('a=',a)
end
print('time=',os.clock()-t0)
time= 1.14

code B:
t0=os.clock()
do
  local a, t = 0, MAD.mtable 'mytable' { {'name'}, 'x', 'y', 'z' }
  t=t+{'A', 1.1,1.2,1.3}+{'B', 2.1,2.2,2.3}+{'A', 3.1,3.2,3.3}
  for i=1,1e7 do a=a+t.x[2] end
  print('a=',a)
end
print('time=',os.clock()-t0)
time= 1.14

Output code A:
building dict:  1
a=  21000000.000896
time= 1.14
changing t.B.x by t[2].x
time= 1.14
changing t.B.x by t.x[2]
time= 0.012
]]
