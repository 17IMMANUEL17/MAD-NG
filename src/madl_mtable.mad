--[=[
 o-----------------------------------------------------------------------------o
 |
 | Table module
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide MAD table objects (TFS tables)
  - Many features have similar implementation to sequences

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local Object, vector, env                                        in MAD
local bind1st, bind2nd, bind2st                                  in MAD.gfunc
local sub, ltrue, lfalse                                         in MAD.operator
local strtrim, strsplit, strbracket, fprintf, kpairs, bsearch,
      toboolean                                                  in MAD.utility
local is_nil, is_boolean, is_number, is_integer, is_decimal,
      is_positive, is_string, is_table, is_rawtable, is_range,
      is_file, is_matrix, is_iterable, is_callable, set_concept,
      concept                                                    in MAD.typeid
local not_keyrable, not_extendable, not_mutable                  in concept

local abs, max, ceil in math
local strsub = string.sub
local table_new, table_clear, table_insert, table_remove =
      table.new, table.clear, table.insert, table.remove

-- root object ----------------------------------------------------------------o

-- hidden keys.
local _data = {}

local origin = string.format("MAD %s %s %s", env.version, env.os, env.arch)

local mtable = Object 'mtable' {
  title='', type='', origin=origin, kind='mtable',
  header = { 'title', 'type', 'origin', 'date', 'time', 'refcol' },
  column = nil, --{},
  reserve=8, novector=nil, owner=nil,
  [_data]={ridx={}, cidx={}, nvec={}, [0]={nr=0},
           cref=nil, nr=0, nc=0, ng=0, rmax=0},
}

-- backup original methods and metamethods
local mtable_mt = getmetatable(mtable)
local var_raw, var_val = mtable.var_raw, mtable.var_val
local var_get, var_set = mtable_mt.__index, mtable_mt.__newindex
local raw_get, tbl_cpy = mtable.raw_get, mtable.copy
local parent, readonly = mtable.__par, mtable.set_readonly

local function is_mtable (a)
  return is_table(a) and a[_data] ~= nil
end

local function is_owner (a)
  return raw_get(a, _data) ~= nil
end

local function is_view (a)
  return raw_get(a, _data) == nil
end

-- sanity checks --------------------------------------------------------------o

-- check dictionnary of name -> idx
local function check_index (tbl)
  local data = raw_get(tbl,_data)
  if is_nil(data.cref) then return end
  local cref = data[data.cref]
  for rn,ri in pairs(data.ridx) do -- name -> index or table of indexes
    if is_number(ri) then
      assert(cref[ri] == rn     , "unexpected corrupted dictionnary")
    elseif is_table(ri) then
      assert(cref[ri[1]] == rn  , "unexpected corrupted dictionnary")
      for i=2,ri.n do
        assert(ri[i-1] < ri[i]  , "unexpected corrupted dictionnary")
        assert(cref[ri[i]] == rn, "unexpected corrupted dictionnary")
      end
    else
      error("unexpected corrupted dictionnary")
    end
  end
end

-- helper for mangled names and row indexes (same as sequence) ----------------o

local index_of -- forward declaration

-- reflect indexes
local function reflect (i, n)
  return i < 0 and n+i+1 or i
end

-- get index from s-position (binary)
local function index_of_num (tbl, num)
  local data = var_raw(tbl,_data)
  local s = data[data.cidx.s]
  assert(s, "missing column 's', cannot find s-position")
  local l = s[data.nr]
  if num < 0 then num = l+num end -- reflect
  if num < 0 or num > l then return nil end
  return bsearch(s, num)
end

-- get row index from signed index or s-position (direct)
function index_of_idx (tbl, idx, typ)
  if typ == 'spos' then return index_of_num(tbl, idx, typ) end
  local n = var_raw(tbl,_data).nr
  idx = reflect(idx, n)
  if idx < 1 or idx > n then return nil end
  return idx
end

-- get index from name [with absolute count] (direct)
local function index_of_cnam (tbl, nam, cnt)
  local ri = var_raw(tbl,_data).ridx[nam]
  if is_table(ri) then
    return ri[ reflect(cnt, ri.n) ]
  end
  return ri
end

-- get index from name [with relative count] (linear)
local function index_of_rnam (tbl, nam, cnt, ref)
  local ri, idx = var_raw(tbl,_data).ridx[nam]
  if is_nil(ri) then return nil end
  if ref then idx = index_of(tbl, ref) end
  if is_nil(idx) then return nil end
  if is_number(ri) then
    return (cnt ==  1 and ri >= idx and ri) or
           (cnt == -1 and ri <= idx and ri) or nil
  end
  if cnt > 0 then
    for i=1,ri.n do
      if ri[i] >= idx then return ri[i+cnt-1] end
    end
  elseif cnt < 0 then
    for i=1,ri.n do
      if ri[i] >  idx then return ri[i+cnt  ] end
    end
  end
  return nil
end

-- get index from [mangled] name or s-position (direct or linear)
local function index_of_str (tbl, str, ref_)
  local num = tonumber(str)
  if num then return index_of_num(tbl, num, ref_) end
  local data = var_raw(tbl,_data)
  assert(data.cref, "no reference column found")
  local nam, cnt, _, bra = strbracket(str)
  cnt = is_nil(cnt) and 1 or tonumber(cnt)
  assert(is_number(cnt), "invalid count (number expected)")
  if is_nil(ref_) or bra == 1 then
    return index_of_cnam(tbl, nam, cnt      )
  else
    return index_of_rnam(tbl, nam, cnt, ref_)
  end
end

-- get [mangled] name from index (linear)
local function name_of_idx (tbl, idx, ref_)
  idx = index_of_idx(tbl, idx)
  if is_nil(idx) then return nil end
  local data = var_raw(tbl,_data)
  assert(data.cref, "no reference column found")
  local nam = data[data.cref][idx]
  local ri  = data.ridx[nam]
  if is_number(ri) then
    assert(ri == idx, "unexpected corrupted dictionnary")
    return nam
  end

  local cnt, b1, b2 = 0
  if ref_ then
    ref_ = assert(index_of(tbl, ref_), "invalid reference index")
    for i=1,ri.n do
      if ri[i] < ref_ then cnt = cnt+1 else break end
    end
    b1, b2 = "{", "}"
  else
    b1, b2 = "[", "]"
  end

  for i=1,ri.n do
    if ri[i] == idx then
      if cnt >= i then cnt = cnt+1 end
      return string.format("%s%s%d%s", nam, b1, i-cnt, b2)
    end
  end
  error("unexpected corrupted dictionnary")
end

local function name_of_num (tbl, num, ref_)
  local idx = index_of_num(tbl, num, ref_)
  if is_nil(idx) then return nil end
  return name_of_idx (tbl, idx, ref_)
end

local function name_of_str (tbl, str, ref_)
  local idx = index_of_str(tbl, str, ref_)
  if is_nil(idx) then return nil end
  return name_of_idx (tbl, idx, ref_)
end

-- build mtable ---------------------------------------------------------------o

-- finalize mtable
local function finish_mtbl (tbl)
  -- sanity checks
  if MAD.option.debug > 2 then
    check_index(tbl)
  end
end

-- mtable initialization
local function mtbl_init (tbl)
  local nc, owner = tbl:raw_len(), tbl:raw_get 'owner'
  if nc == 0 and not owner then return tbl end -- empty, pure inheritance

  local pdat = var_raw(tbl.parent, _data)
  local pnc  = pdat.nc-pdat.ng
  nc = nc + pnc
  local nr   = tbl.reserve           -- forseen rows
  local data = table_new(nc, 8)      -- columns (data)
  data.ridx  = table_new( 0,nr)      -- name -> idx
  data.cidx  = table_new(nc+1,nc+1)  -- name -> idx and idx -> name
  data[0]    = table_new(nr, 1)      -- selected rows
  data.nvec  = {}                    -- columns that should not be specialized
  data.cref  = pdat.cref             -- refence column for fast row indexing
  data.nr    = 0                     -- #rows
  data.nc    = nc                    -- #cols
  data.ng    = 0                     -- #gens
  data.rmax  = 1                     -- allocated rows (specialize after 1st row)

  -- copy parent data columns, clear generated columns
  table.cpy(pdat.cidx, data.cidx)
  for i=pnc+1,pdat.nc do
    data.cidx[data.cidx[i]], data.cidx[i] = nil, nil
  end

  -- process new columns
  for i=pnc+1,nc do
    local col = raw_get(tbl,i-pnc)     -- column key
    if is_table(col) then              -- cref: { key }
      assert(is_rawtable(col) and is_nil(col[2]), "invalid reference column")
      data.cref, col = i, col[1]
    end
    assert(is_string(col), "invalid column name (string expected)")
    assert(is_nil(data.cidx[col]), "invalid column name (name already in use)")
    data.cidx[col], data.cidx[i] = i, col
    data[i] = {nr=0}
  end
  if data.cref then tbl.refcol = data.cidx[data.cref] end

  -- prepare non-specilized columns
  if is_table(tbl.novector) then
    data.nvec = table.cpy(pdat.nvec)
    for _,k in ipairs(tbl.novector) do
      assert(data.cidx[k], "invalid column name for non-specialization")
      data.nvec[k], data.nvec[data.cidx[k]] = data.cidx[k], k
    end
    tbl.novector = table.cat(data.nvec,{})
  elseif tbl.novector == true then
    data.nvec = data.cidx
  end

  -- clear list of column names
  tbl:clear_array()
  -- set current date and time
  tbl.date, tbl.time = os.date'%d/%m/%y', os.date'%H:%M:%S'
  -- column 0 named is_selected
  data[0].nr, data.cidx.is_selected, data.cidx[0] = 0, 0, 'is_selected'

  -- concat header names and column names to parent ones for I/O
  local hdrnam, colnam = raw_get(tbl, 'header'), raw_get(tbl, 'column')
  if is_table(hdrnam) and #hdrnam > 0 then
    tbl.header = table.cat(hdrnam, tbl.parent.header or {})
  end
  if is_table(colnam) and #colnam > 0 then
    tbl.column = table.cat(colnam, tbl.parent.column or {})
  end

  -- finalized
  tbl[_data] = data
  finish_mtbl(tbl)
  return tbl
end

-- mtable metamethods ---------------------------------------------------------o

local _idx, _gen = {}, {}

-- column generator
local function gen_iter (s, i)
  i = i+1
  if i <= s[_data].nr then return i, s[_gen](i) end
end

local gen_mt = set_concept({
  __len      = \s   -> s[_data].nr,
  __index    = \s,i -> i >= 1 and i <= s[_data].nr and s[_gen](i) or nil,
  __pairs    = \s   -> (gen_iter, s, 0),
  __ipairs   = \s   -> (gen_iter, s, 0),
  __tostring = \s   -> string.format("mtable column generator: %p", s),
}, not_keyrable + not_extendable + not_mutable)

-- column proxy (RO)
local function col_iter (s, i)
  i = i+1
  if i <= s[_data].nr then return i, s[_data][i] end
end

local col_mt = set_concept({
  __len      = \s   -> s[_data].nr,
  __index    = \s,i -> i >= 1 and i <= s[_data].nr and s[_data][i] or nil,
  __pairs    = \s   -> (col_iter, s, 0),
  __ipairs   = \s   -> (col_iter, s, 0),
  __tostring = \s   -> string.format("mtable readonly column: %p", s),
}, not_keyrable + not_extendable + not_mutable)

-- row proxy
local function row_iter (s, i)
  i = i+1
  local col = s[_data][i]
  if col then return i, col[s[_idx]] end
end

local function row_kiter (s, k)
  local data = s[_data]
  local i = k and data.cidx[k]+1 or 1
  local col = data[i]
  if col then return data.cidx[i], col[s[_idx]] end
end

local row_mt = set_concept({
  __len      = \s   -> s[_data].nr,
  __index    = \s,i => local data = s[_data]
                       local col = is_number(i) and data[i] or data[data.cidx[i]]
                       if col then return col[s[_idx]] end
                       end,
  __newindex = \s,i,v => local data = s[_data]
                       local col = is_number(i) and data[i] or data[data.cidx[i]]
                       assert(col, "invalid column (write access)")
                       col[s[_idx]] = v
                       end,
  __pairs    = \s   -> (row_kiter, s, nil),
  __kpairs   = \s   -> (row_kiter, s, nil),
  __ipairs   = \s   -> (row_iter , s, 0  ),
  __tostring = \s   -> string.format("mtable row: %p", s),
}, not_mutable)

-- count proxy
local function cnt_iter (s, i)
  i = i+1
  local ri = s[_idx][i]
  if ri then s[_data][_idx] = ri return i, s[_data] end
end

local cnt_mt = set_concept({
  __len      = \s   -> s[_idx].n,
  __index    = \s,i => local ri = s[_idx][i]
                       if ri then s[_data][_idx] = ri return s[_data] end
                       end,
  __pairs    = \s   -> (cnt_iter, s, 0),
  __ipairs   = \s   -> (cnt_iter, s, 0),
  __tostring = \s   -> string.format("mtable count: %p", s),
}, not_keyrable + not_extendable + not_mutable)

-- iterators over rows
local function rows_iter (row, i)
  i = i+1
  if i <= row[_data].nr then row[_idx] = i ; return i, row end
end

local function ipairs_mm (tbl)
  local row = setmetatable({[_idx]=0, [_data]=var_raw(tbl,_data)}, row_mt)
  return rows_iter, row, 0
end

-- number of rows
local function len_mm (tbl)
  return var_raw(tbl,_data).nr
end

-- read access precedence: row index, variable key, column key, row key.
local function index_mm (tbl, key)
  -- row index
  if is_number(key) then              -- see index_of_idx
    local data = var_raw(tbl,_data)
    key = reflect(key, data.nr)
    if key < 1 or key > data.nr then return nil end
    return setmetatable({[_idx]=key, [_data]=data}, row_mt)
  end
  -- variable
  local var = var_raw(tbl, key)
  if var then return var_val(tbl, key, var) end
  -- column name
  local data = var_raw(tbl,_data)
  local idx = data.cidx[key]
  if idx then return data[idx] end -- full column
  -- row name
  local idx = data.ridx[key]
  if is_number(idx) then
    return setmetatable({[_idx]=idx, [_data]=data}, row_mt)
  elseif is_table(idx) then
    return setmetatable({[_idx]=idx, [_data]=
           setmetatable({[_idx]=0  , [_data]=data}, row_mt)}, cnt_mt)
  end
end

local function newindex_mm (tbl, key, val)
  local data = var_raw(tbl,_data)
  -- row index or col/row name
  if is_number(key) or data.cidx[key] or data.ridx[key] then
    error("invalid mtable write access (use 'set' methods)")
  end
  -- variables
  var_set(tbl, key, val)
end

-- readonly protection --------------------------------------------------------o

local function set_readonly (tbl, set_)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  local data = raw_get(tbl,_data)
  if set_ ~= false and not tbl:is_readonly() then -- RW -> RO
    for i=1,data.nc-data.ng do
      data[i] = setmetatable({ [_data]=data[i] }, col_mt)
    end
  elseif set_ == false and tbl:is_readonly() then -- RO -> RW
    for i=1,data.nc-data.ng do
      data[i] = data[i][_data]
    end
  end
  return readonly(tbl, set_)
end

-- methods (readonly) ---------------------------------------------------------o

local function name_of (tbl, a, ref_)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
      if is_integer(a) then return name_of_idx(tbl, a, ref_)
  elseif is_number (a) then return name_of_num(tbl, a, ref_)
  elseif is_string (a) then return name_of_str(tbl, a, ref_)
  end
  error("invalid argument #2 (number or string expected)")
end

function index_of (tbl, a, ref_)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
      if is_integer(a) then return index_of_idx(tbl, a, ref_)
  elseif is_number (a) then return index_of_num(tbl, a, ref_)
  elseif is_string (a) then return index_of_str(tbl, a, ref_)
  end
  error("invalid argument #2 (number or string expected)")
end

local function range_of (tbl, rng, ref_)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  local start, stop
  if is_number(rng) then
    start = index_of(tbl, rng, ref_)
    return start, start
  elseif is_string(rng) then
    local s1, i2 = strsplit(rng, "/" )
    local s2 = i2 > 0 and strtrim(rng, i2+1) or nil
    start, stop = tonumber(s1) or s1, tonumber(s2) or s2
  elseif is_table(rng) then
    start, stop, ref_ = rng[1], rng[2], ref_ or rng[3]
  elseif is_range(rng) then
    start, stop = rng:bounds()
  else error "invalid argument #2 (index, string, table or range expected)"
  end
  local ref1, ref2
  if is_nil(ref_) then
    ref1 = is_number(start) and (is_decimal(start) or is_decimal(stop)) and 'spos' or nil
    ref2 = is_number(stop ) and (is_decimal(start) or is_decimal(stop)) and 'spos' or nil
  end
  start =          index_of(tbl, start, ref1 or ref_)
  stop  = stop and index_of(tbl, stop , ref2 or ref_) or start
  return start, stop
end

local function length_of (tbl, rng_, ntrn_) -- see iter
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  local siz = rng_ and 1-sub(range_of(tbl, rng_)) or 0
  return siz + #tbl * ((ntrn_ or 0) + (siz <= 0 and 1 or 0))
end

-- dict helpers ---------------------------------------------------------------o

-- shift indexes >= idx by n
local function shf_idx (data, idx, n)
  if is_nil(data.cref) then return end
  local ridx = data.ridx
  for nam,ei in pairs(ridx) do
    if is_number(ei) then       -- scalar
      if ei >= idx then ridx[nam] = ei+n end
    else for i=1,ei.n do        -- table
      if ei[i] >= idx then ei[i] = ei[i]+n end
    end end
  end
end

-- insert to dictionnary name -> idx (warning: indexes are not shifted)
local function ins_idx (data, idx)
  if is_nil(data.cref) then return end
  local nam = data[data.cref][idx]
  local val = data.ridx[nam]
  if is_nil(val) then             -- none: scalar
    data.ridx[nam] = idx
  elseif is_number(val) then      -- one : scalar to array
    data.ridx[nam] = val > idx and {idx, val, n=2} or {val, idx, n=2}
  else                            -- many: insert
    local ii = 1
    for i=val.n,1,-1 do
      if val[i] >= idx then val[i+1] = val[i] else ii = i+1 ; break end
    end
    val[ii], val.n = idx, val.n+1
  end
end

-- remove from dictionnary name -> idx (warning: indexes are not shifted)
local function rem_idx (data, idx)
  if is_nil(data.cref) then return end
  local nam = data[data.cref][idx]
  local val = data.ridx[nam]
  if is_number(val) then          -- one : delete
    data.ridx[nam] = nil
  elseif val.n == 2 then          -- two : array to scalar
    data.ridx[nam] = val[1] == idx and val[2] or val[1]
  else                            -- many: remove
    for i=1,val.n do
      if val[i] >= idx then val[i] = val[i+1] end
    end
    val.n = val.n-1
  end
end

-- add to dictionnary name -> idx (warning: indexes are not shifted)
local function add_idx (data, idx)
  if is_nil(data.cref) then return end
  local nam = data[data.cref][idx]
  local val = data.ridx[nam]
  if is_nil(val) then             -- none: scalar
    data.ridx[nam] = idx
  elseif is_number(val) then      -- one : scalar to array
    data.ridx[nam] = {val, idx, n=2}
  else                            -- many: append
    val[val.n+1], val.n = idx, val.n+1
  end
end

-- build dictionnary name -> idx
local function build_idx (data)        -- must be very fast (see add_idx)
  if is_nil(data.cref) then return end -- no reference column
  table_clear(data.ridx)               -- reuse main storage
  for i=1,data.nr do add_idx(data, i) end
end

-- memory helpers -------------------------------------------------------------o

-- expand vectors, specialize on 1st row unless nvec[col] is set
local function expand (data, tbl, extra)
  local rmax = ceil(max(tbl.reserve, data.rmax*1.5, data.rmax+extra))
  assert(rmax <= 1e8, "too big mtable") -- should see 'out of memory' first
  local nr, nc, cvec = data.nr, data.nc-data.ng, nil
  for i=1,nc do
    local val = data[i]
    if is_number(data[i][1]) and not data.nvec[i] then
      data[i] = vector(rmax)
      data[i].nr, cvec = nr, true
      if nr > 1 then data[i]:copy(val) else data[i][1] = val[1] end
    elseif data.rmax == 1 then -- expand only for 1st row
      data[i] = table_new(rmax,1)
      data[i][1], data[i].nr = val[1], nr
    end
  end
  data.rmax = cvec and rmax or 1e8
end

-- methods (R/W, update dict) -------------------------------------------------o

local function get (tbl, row, col, cnt_)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  local data, ridx, cidx = var_raw(tbl,_data)

  if is_number(col)
  then cidx = reflect(col, data.nc)
  else cidx = data.cidx[col]
  end
  if is_nil(data[cidx]) then return nil end

  if is_number(row)
  then ridx = reflect(row, data.nr)
  else ridx = data.ridx[row]
    if is_table(ridx) then
      local cnt = cnt_ or 1
      assert(is_number(cnt), "invalid argument #4 (number expected)")
      ridx = ridx[ reflect(cnt, ridx.n) ]
    end
  end

  return data[cidx][ridx]
end

local function set (tbl, row, col, val, cnt_)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  local data, cidx, ridx = var_raw(tbl,_data)

  if is_number(col)
  then cidx = reflect(col, data.nc)
  else cidx = data.cidx[col]
  end
  assert(data[cidx], "invalid argument #3 (valid column expected)")

  if is_number(row) then
    ridx = reflect(row, data.nr)
    assert(ridx >= 1 and ridx <= data.nr, "row index out of bounds")
  else
    ridx = assert(data.ridx[row], "invalid argument #2 (valid row expected)")
    if is_table(ridx) then
      local cnt = cnt_ or 1
      assert(is_number(cnt), "invalid argument #4 (number expected)")
      ridx = assert(ridx[ reflect(cnt, ridx.n) ],
                             "invalid argument #2 (valid row[cnt] expected)")
    end
  end

--  if cidx ~= data.cref then
    data[cidx][ridx] = val
--  else
--    rem_idx(data, ridx)
--    data[cidx][ridx] = val
--    ins_idx(data, ridx)
--  end
end

--- columns -------------------------------o

local function get_col (tbl, key)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  local data = var_raw(tbl,_data)
  local idx = is_number(key) and key or data.cidx[key]
  if is_nil(idx) then return nil end
  return data[ reflect(idx, data.nc) ] -- full column data, column generator or nil
end

local function add_col (tbl, key, val, nvec_)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  assert(is_string(key), "invalid argument #2 (string expected)")
  local data = raw_get(tbl,_data)
  assert(is_nil(data.cidx[key]), "invalid argument #2 (column name already in use)")
  assert(not tbl:is_readonly(), "invalid modification of readonly mtable")

  if is_callable(val) then     -- generator
    local idx = data.nc+1
    data[idx] = setmetatable({ [_data]=data, [_gen]=val }, gen_mt)
    data.cidx[key], data.cidx[idx], data.ng = idx, key, data.ng+1
  elseif is_iterable(val) then -- iterable
    local idx = data.nc-data.ng+1
    if is_number(val[1]) and not nvec_ and data.nvec ~= data.cidx then
      table_insert(data, idx, vector(data.rmax):reshape(data.nr):fill(val))
    else
      table_insert(data, idx, table_new(data.nr,1))
      for i=1,data.nr do data[idx][i] = val[i] end
    end
    data[idx].nr = data.nr
    for k,i in kpairs(data.cidx, data.nc) do
      if i >= idx then data.cidx[k] = i+1 end
    end
    data.cidx[key] = idx
    table_insert(data.cidx, idx, key)
    if nvec_ and data.nvec ~= data.cidx then
      data.nvec[key] = idx
      table_insert(data.nvec, idx, key)
    end
  end
  data.nc = data.nc+1
end

local function rem_col (tbl, key)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  local data = raw_get(tbl,_data)
  local idx  = is_number(key) and reflect(key, data.nr) or
           assert(data.cidx[key], "invalid argument #2 (valid column expected")
  assert(data.nc-data.ng < idx and idx <= data.nc,
                             "invalid argument #2 (generator column expected)")
  assert(not tbl:is_readonly(), "invalid modification of readonly mtable")
  data.nc, data.ng, data.cidx[data.cidx[idx]] = data.nc-1, data.ng-1, nil
  table_remove(data, idx)
  table_remove(data.cidx, idx)
  for k,i in kpairs(data.cidx, data.nc) do
    if i > idx then data.cidx[k] = i-1 end
  end
end

--- rows ----------------------------------o

local function clr_row_ (data, idx) -- not exposed
  for i=1,data.nc-data.ng do
    data[i][idx] = not is_table(data[i]) and 0 or nil
  end
end

local function cpy_row_ (data, idx, val, ini, nr) -- not exposed
  if ini or val[1] then      -- copy by idx-value
    local i0 = (ini or 1) - 1
    for i=1,data.nc-data.ng do
      data[i].nr   = nr
      data[i][idx] = val[i0+i]
    end
  else                       -- copy by key-value
    for k,v in pairs(val) do
      local col = is_number(k) and data[k] or data[data.cidx[k]]
      assert(col, "invalid argument #3 (valid column expected)")
      col.nr   = nr
      col[idx] = v
    end
  end
  data[0].nr   = nr
  data[0][idx] = true
end

local function get_row (tbl, key, ref_)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  local idx = index_of(tbl, key, ref_)
  if is_nil(idx) then return nil end
  return setmetatable({[_idx]=idx, [_data]=var_raw(tbl,_data)}, row_mt)
end

local function add_row (tbl, val, ini_)
  assert(is_mtable(tbl)  , "invalid argument #1 (mtable expected)")
  assert(is_iterable(val), "invalid argument #2 (iterable expected)")
  assert(not tbl:is_readonly(), "invalid modification of readonly mtable")
  local data = var_raw(tbl, _data)
  local idx  = data.nr+1
  if idx > data.rmax then expand(data, tbl, 1) end
  cpy_row_(data, idx, val, ini_, idx)
  add_idx (data, idx)
  data.nr = idx
  return tbl
end

local function set_row (tbl, key, val, ini_, ref_)
  assert(is_mtable(tbl)  , "invalid argument #1 (mtable expected)")
  local idx = index_of(tbl, key, ref_)
  assert(is_number(idx)  , "invalid argument #2 (valid row expected)")
  assert(is_iterable(val), "invalid argument #3 (iterable expected)")
  assert(not tbl:is_readonly(), "invalid modification of readonly mtable")
  local data = var_raw(tbl, _data)
  rem_idx (data, idx)
  cpy_row_(data, idx, val, ini_, data.nr)
  ins_idx (data, idx)
  return tbl
end

local function rem_row (tbl, key, ref_)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  local idx = index_of(tbl, key, ref_)
  assert(is_number(idx), "invalid argument #2 (valid row expected)")
  assert(not tbl:is_readonly(), "invalid modification of readonly mtable")
  local data = var_raw(tbl, _data)
  local nr, nc = data.nr, data.nc-data.ng
  rem_idx(data, idx)
  shf_idx(data, idx, -1)
  for i=0,nc do
    for j=idx,nr-1 do data[i][j] = data[i][j+1] end
  end
  clr_row_(data, data.nr)
  for i=0,nc do data[i].nr = data[i].nr-1 end
  data.nr = data.nr-1
  return tbl
end

local function ins_row (tbl, key, val, ini_, ref_)
  assert(is_mtable(tbl)  , "invalid argument #1 (mtable expected)")
  if key == #tbl+1 then return add_row(tbl, val, ini_) end
  local idx = index_of(tbl, key, ref_)
  assert(is_number(idx)  , "invalid argument #2 (valid row expected)")
  assert(is_iterable(val), "invalid argument #3 (iterable expected)")
  assert(not tbl:is_readonly(), "invalid modification of readonly mtable")
  local data = var_raw(tbl, _data)
  local nr, nc = data.nr, data.nc-data.ng
  if nr+1 > data.rmax then expand(data, tbl, 1) end
  for i=0,nc do
    data[i].nr = data[i].nr+1
    for j=nr,idx,-1 do data[i][j+1] = data[i][j] end
  end
  data.nr = data.nr+1
  clr_row_(data, idx)
  cpy_row_(data, idx, val, ini_, data.nr)
  shf_idx (data, idx, 1)
  ins_idx (data, idx)
  return tbl
end

local function swp_row (tbl, key1, key2, ref_)
  assert(is_mtable(tbl) , "invalid argument #1 (mtable expected)")
  local idx1, idx2 = index_of(tbl, key1, ref_), index_of(tbl, key2, ref_)
  assert(is_number(idx1), "invalid argument #2 (valid row expected)")
  assert(is_number(idx2), "invalid argument #3 (valid row expected)")
  assert(not tbl:is_readonly(), "invalid modification of readonly mtable")
  if idx1 == idx2 then return tbl end
  local data = var_raw(tbl, _data)
  rem_idx(data, idx1) ; rem_idx(data, idx2)
  for i=0,data.nc-data.ng do
    data[i][idx1], data[i][idx2] = data[i][idx2], data[i][idx1]
  end
  ins_idx(data, idx1) ; ins_idx(data, idx2)
  return tbl
end

local function clr_row (tbl, key, ref_)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  local idx = index_of(tbl, key, ref_)
  assert(is_number(idx), "invalid argument #2 (valid row expected)")
  assert(not tbl:is_readonly(), "invalid modification of readonly mtable")
  local data = var_raw(tbl, _data)
  clr_row_(data, idx)
  return tbl
end

-- functional methods ---------------------------------------------------------o

local pknd   = \knd,k,  r,i -> knd[i] == k
local psel   = \sel,    r,i -> sel[i] == true
local pnam   = \ref,pat,r,i -> string.match(ref[i], pat) ~= nil
local pand   = \p,p2,   r,i -> p(r,i) and p2(r,i)
local ptrue  = \p,_ ,   r,i -> p(r,i) and true
local pfalse = \p,_ ,   r,i -> p(r,i) or false

local function foreach (tbl, act, rng_, sel_, not_) -- action, range, selection, default
  local f, p
  if is_nil(rng_) and is_rawtable(act) then
    f, rng_ = act.action, act     -- extract action + right shift
  else
    f = act
  end
  if is_nil(sel_) and is_rawtable(rng_) and is_nil(rng_[1]) then
    rng_, sel_ = rng_.range, rng_ -- extract range  + right shift
  end
  if is_nil(not_) and is_boolean(sel_) then
    not_, sel_ = sel_             --                  right shift
  end

  local data = var_raw(tbl, _data)
  if is_rawtable(sel_) then       -- logically and'ed selections
    if is_nil(not_) and (sel_.default == 'none' or sel_.default == true) then
      not_ = true
    end
    local op = not_ ~= true and ptrue or pfalse
    if sel_.select then
      assert(is_callable(sel_.select), "invalid select (callable expected)")
      op, p = pand, bind2st(op, sel_.select, p)
    end
    if sel_.pattern then
      assert(is_string(sel_.pattern), "invalid pattern (string expected)")
      assert(data.cref, "unexpected pattern selection (no reference column)")
      op, p = pand, bind2st(op, bind2st(pnam,data[data.cref], sel_.pattern), p)
    end
    if sel_.kind then
      assert(is_string(sel_.kind), "invalid kind (string expected)")
      assert(data.cidx.kind, "unexpected 'kind' selection (no 'kind' column)")
      op, p = pand, bind2st(op, bind2st(pknd,data[data.cidx.kind], sel_.kind),p)
    end
    if sel_.selected then
      op, p = pand, bind2st(op, bind1st(psel, data[0]), p)
    end
  elseif not is_nil(sel_) then    -- build the selection
    p = is_boolean (sel_) and bind1st(psel, data[0])               or
        is_string  (sel_) and assert(data.cref, "unexpected pattern selection (no reference column)")
                          and bind2st(pnam, data[data.cref], sel_) or
        is_callable(sel_) and sel_                                 or nil
  end
  if is_nil(p) then p = not_ ~= true and ltrue or lfalse end

  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  assert(is_callable(f), "invalid argument #2 (callable expected)")
  assert(is_callable(p), "invalid argument #4 (callable expected)")

  if p ~= lfalse then
    for idx,row in tbl:iter(rng_) do
      if p(row,idx) then f(row,idx) end
    end
  end
  return tbl
end

local do_select = \sel,_,i => sel[i] = true end

local function select (tbl, rng_, sel_, not_)
  local f = bind1st(do_select, var_raw(tbl,_data)[0])
  return tbl:foreach(f, rng_, sel_, not_)
end

local do_deselect = \sel,_,i => sel[i] = false end

local function deselect (tbl, rng_, sel_, not_)
  local f = bind1st(do_deselect, var_raw(tbl,_data)[0])
  return tbl:foreach(f, rng_, sel_, not_)
end

local do_filter = \idx,_,i => local n=idx.n+1 ; idx[n], idx.n = i, n end

local function filter (tbl, rng_, sel_, not_)
  local idx = table_new(8,1)
  local f = bind1st(do_filter, idx)
  idx.n = 0
  tbl:foreach(f, rng_, sel_, not_)
  return idx
end

-- methods (R/W, rebuild dict) ------------------------------------------------o

local function build_index (tbl, key_)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  assert(not tbl:is_readonly(), "invalid modification of readonly mtable")

  local data = raw_get(tbl,_data)
  if key_ == 'none' then -- 'none' disable index
    tbl.refcol, data.cref = nil, nil
  elseif key_ then       -- change reference column
    local idx = is_number(key_) and reflect(key_, data.nc) or data.cidx[key_]
    assert(data[idx], "invalid argument #2 (valid column expected)")
    tbl.refcol, data.cref = data.cidx[idx], idx
  end

  build_idx (data)
  finish_mtbl(tbl)
  return tbl
end

local function remove (tbl, rng_, sel_)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  assert(not tbl:is_readonly(), "invalid modification of readonly mtable")

  -- collect indexes of elements to remove
  local idx_r = filter(tbl, rng_, sel_, true)
  local nr = idx_r.n
  if nr == 0 then return end
  assert(idx_r[nr]-idx_r[1] >= nr-1, "invalid range, indexes must be increasing")

  -- move rows by increasing indexes
  local data = raw_get(tbl,_data)
  local ni, nc = data.nr-nr, data.nc-data.ng
  local i, j, r = idx_r[1], idx_r[1]+1, 2
  while i <= ni do
    if j == idx_r[r] then
      j, r = j+1, r+1
    else
      for ic=0,nc do data[ic][i] = data[ic][j] end
      i, j = i+1, j+1
    end
  end
  for i=ni+1,data.nr do clr_row_(data, i) end
  for i=0,nc do data[i].nr = data.nr end
  data.nr = data.nr - nr

  build_index(tbl)
  return tbl
end

local function insert (tbl, rows, rng_, sel_)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  assert(not tbl:is_readonly(), "invalid modification of readonly mtable")

  -- collect indexes of elements to remove
  local idx_r = filter(tbl, rng_, sel_, true)
  local nr = idx_r.n
  if nr == 0 then return end
  assert(idx_r[nr]-idx_r[1] >= nr-1, "invalid range, indexes must be increasing")

  -- expand if needed
  local data = raw_get(tbl,_data)
  if data.nr+nr > data.rmax then expand(data, tbl, nr) end

  -- move rows by decreasing indexes
  local j, nc = nr, data.nc-data.ng
  data.nr = data.nr + nr
  for i=0,nc do data[i].nr = data.nr end
  for ii=data.nr,idx_r[1],-1 do
    if ii == idx_r[j] then
      for i=0,nc do data[i][ii] = rows[j][i] end
      j = j-1
    else
      for i=0,nc do data[i][ii] = data[i][ii-j] end
    end
  end
  assert(j == 0, "unexpected corrupted move of rows (insert)")

  build_index(tbl)
  return tbl
end

local function sort (tbl, cmp, rng_, sel_)
  assert(is_mtable(tbl)  , "invalid argument #1 (mtable expected)")
  assert(is_callable(cmp), "invalid argument #2 (callable expected)")
  assert(not tbl:is_readonly(), "invalid modification of readonly mtable")

  -- collect indexes of elements to remove
  local idx_r = filter(tbl, rng_, sel_)
  local nr = idx_r.n
  if nr == 0 then return end
  assert(idx_r[nr]-idx_r[1] >= nr-1, "invalid range, indexes must be increasing")

  -- sort indexes (indirectly)
  local data  = raw_get(tbl,_data)
  local row1  = setmetatable({[_idx]=0, [_data]=data}, row_mt)
  local row2  = setmetatable({[_idx]=0, [_data]=data}, row_mt)
  local idx_s = table.cpy(idx_r, table_new(nr,0))
  table.sort(idx_s, \i1,i2 => row1[_idx], row2[_idx] = i1, i2
                              return cmp(row1,row2) end)

  -- build lookup table
  local idx_l = table_new(0,nr)
  for i=1,nr do idx_l[idx_r[i]] = idx_s[i] end

  -- sort rows
  local nc = data.nc-data.ng
  local tmp = table_new(nc+1,0)
  for ii=1,nr do
    local s, r = idx_s[ii], idx_l[idx_s[ii]]
    if s == r then -- identity (cleanup)
      idx_l[s] = nil
    elseif r then  -- not yet processed
      local ts = s
      for i=0,nc do tmp[i] = data[i][s] end
      while r ~= ts do
        for i=0,nc do data[i][s] = data[i][r] end
        s, r, idx_l[s] = r, idx_l[r]
      end
      for i=0,nc do data[i][s] = tmp[i] end
      idx_l[s] = nil
    end
  end
  assert(is_nil(next(idx_l)), "unexpected corrupted lookup indexes (sort)")

  build_index(tbl)
  return tbl
end

local function copy (tbl, name_, owner_)
  if is_nil(owner_) and is_boolean(name_) then
    owner_, name_ = name_
  end
  assert(not rawequal(tbl, mtable), "invalid argument #1 (cannot copy 'mtable')")
  assert(is_mtable(tbl)           , "invalid argument #1 (mtable expected)")
  local cpy = tbl_cpy(tbl,name_)
  if is_view(tbl) and not owner_ then return cpy end -- tbl is not an original table

  local data = var_raw(tbl,_data)
  local nr, nc = data.nr, data.nc-data.ng
  local cdat = table_new(nc, 8)      -- see mtbl_init
  cdat.ridx  = table_new( 0,nr)      -- name -> idx
  cdat.cidx  = table_new(nc+1,nc+1)  -- name -> idx and idx -> name
  cdat.nvec  = {}                    -- columns that should not be specialized
  cdat.cref  = data.cref             -- reference column (if any)
  cdat.nr    = nr                    -- #rows
  cdat.nc    = nc                    -- #cols
  cdat.ng    = 0                     -- #gens
  cdat.rmax  = data.rmax             -- allocated rows

  -- copy data columns, not generated columns
  table.cpy(data.cidx, cdat.cidx)
  for i=nc+1,data.nc do
    cdat.cidx[cdat.cidx[i]], cdat.cidx[i] = nil, nil
  end

  if  data.nvec == data.cidx
  then cdat.nvec = cdat.cidx
  else cdat.nvec = table.cpy(data.nvec)
  end

  for i=0,nc do                      -- copy data columns
    cdat[i] = is_table(data[i]) and table_new(nr,1) or vector(nr)
    for j=1,nr do cdat[i][j] = data[i][j] end
    cdat[i].nr = nr
  end

  cpy[_data] = cdat
  build_index(cpy)
  return cpy
end

-- special --------------------------------------------------------------------o

local function cycle (tbl, a)
  assert(is_mtable(tbl)  , "invalid argument #1 (mtable expected)")
  assert(index_of(tbl, a), "invalid argument #2 (reference expected)")
  tbl.start_at = a
  return tbl
end

-- iterators ------------------------------------------------------------------o

local function niliter (state, i)
  return nil
end

local function fwditer (state, i)
  if i == state.stop then
    if state.turn == 0 then return nil end
    state.turn = state.turn-1
  end
  i = i < state.n and i+1 or 1
  state.row[_idx] = i
  return i, state.row
end

local function bwditer (state, i)
  if i == state.stop then
    if state.turn == 0 then return nil end
    state.turn = state.turn-1
  end
  i = i > 1 and i-1 or state.n
  state.row[_idx] = i
  return i, state.row
end

local function iter (tbl, rng_, ntrn_, dir_)
  local nturn, dir = ntrn_ or 0, dir_ or 1
  assert(is_mtable(tbl)                  ,"invalid argument #1 (mtable expected)")
  assert(is_number(nturn) and nturn >= 0 ,"invalid argument #3 (number expected)")
  assert(is_number(dir) and abs(dir) == 1,"invalid argument #4 (direction expected)")

  if #tbl == 0 then return niliter end

  local start, stop
  if is_nil(rng_) then
    local s0, sn = 1, #tbl
    if dir < 0 then s0, sn = sn, s0 end
    if is_nil(tbl.start_at) then
      start, stop = s0, sn
    else
      start = assert(index_of(tbl, tbl.start_at), "invalid cycle reference")
      stop  = start == s0 and sn or start-dir
    end
  else
    start, stop = range_of(tbl, rng_)
    assert(is_number(start), "invalid range start")
    assert(is_number(stop ), "invalid range stop" )
  end
  if start == stop+dir then nturn = nturn+1 end

  local row = setmetatable({[_idx]=0, [_data]=var_raw(tbl,_data)}, row_mt)
  return dir > 0 and fwditer or bwditer,
         { row=row, n=#tbl, stop=stop, turn=nturn }, start-dir
end

-- I/O methods ----------------------------------------------------------------o

local function write (tbl, filnam_, colnam_, hdrnam_)
  if is_table(filnam_) and is_nil(hdrnam_) then
    filnam_, colnam_, hdrnam_ = nil, filnam_, colnam_ -- right shift
  end
  local data = var_raw(tbl,_data)
  local fnam = filnam_ or io.stdout
  local cnam = colnam_ or tbl.column or data.cidx
  local hnam = hdrnam_ or tbl.header
  local nrow = data.nr
  local ncol = #cnam
  local cols = table_new(ncol, 0)

  -- collect column
  for i=1,ncol do
    local idx = is_number(cnam[i]) and cnam[i] or data.cidx[cnam[i]]
    cols[i] = assert(data[idx], "invalid column name or index")
    cnam[i] = data.cidx[idx]
  end

  -- open file
  local file = fnam
  if is_string(fnam) then
    if strsub(fnam,-4) ~= '.tfs' then fnam = fnam .. '.tfs' end
    file = assert(io.open(fnam, 'w'))
  end
  assert(io.type(file) == 'file', "invalid argument #2 (open file expected)")

  -- dump header
  for i=1,#hnam do
    local k, v = hnam[hnam[i]] or hnam[i], tbl[hnam[i]]
    if is_number(v) then
      fprintf(file, '@ %-18s %%le  %s\n', k, tostring(v))
    elseif is_string(v) then
      if k == 'type' and v == '' then v = tbl.kind end -- to review
      fprintf(file, '@ %-18s %%%02ds  %q\n', k, #v, v)
    elseif is_table(v) then
      fprintf(file, '@ %-18s %%%02dt  %q\n', k, #v, table.concat(v,', '))
    elseif is_boolean(v) then
      fprintf(file, '@ %-18s %%b  %s\n', k, tostring(v))
    else
      fprintf(file, '@ %-18s %%?  %s\n', k, tostring(v))
    end
  end

  if ncol > 0 then
    local fmt, v
    -- dump col names
    file:write('*')
    fmt = ' %-17s '
    for i=1,ncol do
      if i == ncol then fmt = ' %s\n' end
      fprintf(file, fmt, cnam[i])
    end

    -- dump col types
    file:write('$')
    fmt = ' %-17s '
    for i=1,ncol do
      local v = cols[i][1]
      local s = is_string(v) and '%s' or is_number(v) and '%le' or '%?'
      if i == ncol then fmt = ' %s\n' end
      fprintf(file, fmt, s)
    end

    -- dump rows
    for j=1,nrow do
      if data[0][j] then -- is_selected
        file:write(' ')
        for i=1,ncol-1 do
          local v = cols[i][j]
          if is_string(v) then v = string.format("%q", v) end
          fprintf(file, '%-18s ', tostring(v))
        end
        local v = cols[ncol][j]
        if is_string(v) then v = string.format("%q", v) end
        file:write(tostring(v), '\n')
      end
    end
  end

  file:close()
  return tbl
end

local function read (tbl, filnam_)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  local quote, splitall in string
  local fnam = filnam_ or io.stdin
  local hnam = table.new(8,8)
  local cnam = nil
  local ncol = 0
  local row  = {n=0}
  local ln   = 0

  -- open file
  local file = fnam
  if is_string(fnam) then
    if strsub(fnam,-4) ~= '.tfs' then fnam = fnam .. '.tfs' end
    file = assert(io.open(fnam, 'r'))
  end
  assert(io.type(file) == 'file', "invalid argument #2 (open file expected)")

  -- read header
  for line in file:lines() do
    ln = ln+1
    row, ncol = splitall(line, " \t", nil, row)
    if row[1] == '@' then
      if ncol ~= 4 then
        error("invalid header format (4 columns expected at line "..ln..")")
      end
      local typ = string.sub(row[3],-1)
      hnam[#hnam+1] = row[2]
      if typ == 'e' then
        hnam[row[2]] = tonumber(row[4])
      elseif typ == 'b' then
        hnam[row[2]] = toboolean(row[4])
      elseif typ == 's' then
        hnam[row[2]] = quote(row[4])
      elseif typ == 't' then
        local res, n = splitall(row[4], ",")
        assert(n == tonumber(string.sub(row[3],2,-2)), "unmatched table length")
        for i=1,n do res[i] = tonumber(res[i]) or quote(res[i]) end
        hnam[row[2]] = res
      elseif typ == '?' then
        hnam[row[2]] = row[4]
      else
        error("invalid header field type: '"..typ.."'")
      end
    elseif row[1] == '*' then -- col names
      cnam, row.n = table.new(ncol-1,0), ncol-1
      for i=1,ncol-1 do cnam[i] = row[i+1] end
    elseif row[1] == '$' then -- col types (discarded)
      break
    end
  end

  assert(hnam.type == tbl.type or tbl.type == '' and hnam.type == tbl.kind,
         "invalid parent table (kinds differ)") -- to review

  -- create table from header
  for i,v in ipairs(hnam) do
    cnam[v], hnam[v] = hnam[v], nil
  end
  tbl = tbl(hnam.name, cnam) -- inherit from tbl
  tbl.header = hnam

  -- read and add rows
  for line in file:lines() do
    ln = ln+1
    row, ncol = splitall(line, " \t", nil, row)
    if row.n ~= ncol then
      error("invalid row format (".. (row.n-ncol) ..
            " missing columns at line ".. ln ..")")
    end
    for i=1,ncol do -- convert to numbers or remove quotes (if any)
      row[i] = row[i] ~= 'nil' and (tonumber(row[i]) or quote(row[i])) or nil
    end
    tbl:addrow(row)
  end

  -- build index with column 'name' (if any)
  local cref = tbl:raw_get('refcol')
  if cref then tbl:build_index(cref) end

  file:close()
  return tbl
end

-- members --------------------------------------------------------------------o

mtable: set_methods {
  -- cells manipulation
  get          = get,
  set          = set,

  -- columns manipulation
  getcol       = get_col,
  addcol       = add_col,
--setcol       = set_col,
  remcol       = rem_col, -- rem data column?
--inscol       = ins_col,

  -- rows manipulation
  getrow       = get_row,
  addrow       = add_row,
  setrow       = set_row,
  remrow       = rem_row,
  insrow       = ins_row,
  swprow       = swp_row,
  clrrow       = clr_row,

  -- sequence-like methods
  name_of      = name_of,
  index_of     = index_of,
  range_of     = range_of,
  length_of    = length_of,

  foreach      = foreach,
  select       = select,
  deselect     = deselect,
  filter       = filter,

  remove       = remove,
  insert       = insert,
  sort         = sort,
  copy         = copy,

  cycle        = cycle,

  iter         = iter,

  -- read/write
  read         = read,
  write        = write,

  -- readonly
  set_readonly = set_readonly,

  -- ownership
  is_owner     = is_owner,
  is_view      = is_view,

  -- index dict
  build_index  = build_index,
  check_index  = check_index,

  -- disabled methods
  is_selected := error("invalid mtable operation", 2),

}: set_metamethods ({
  __add        = add_row,
  __len        = len_mm,
  __index      = index_mm,
  __newindex   = newindex_mm,
-- __pairs     = pairs_mm, default from Object
  __ipairs     = ipairs_mm,
-- __kpairs    = kpairs_mm, default from Object

  __copy       = copy,
  __init       = mtbl_init,

}, true): set_readonly()

-- env ------------------------------------------------------------------------o

MAD.typeid.is_mtable = is_mtable

-- end ------------------------------------------------------------------------o
return {
  mtable = mtable,
  __help = require 'madh_mtable',
}

--[[ 'High level table access is very slow!
code A:
t0=os.clock()
do
  local a, t = 0, MAD.mtable 'mytable' { {'name'}, 'x', 'y', 'z' }
  t=t+{'A', 1.1,1.2,1.3}+{'B', 2.1,2.2,2.3}+{'A', 3.1,3.2,3.3}
  for i=1,1e7 do a=a+t:get('A','x',2) end
  print('a=',a)
end
print('time=',os.clock()-t0)
time= 1.14

code B:
t0=os.clock()
do
  local a, t = 0, MAD.mtable 'mytable' { {'name'}, 'x', 'y', 'z' }
  t=t+{'A', 1.1,1.2,1.3}+{'B', 2.1,2.2,2.3}+{'A', 3.1,3.2,3.3}
  for i=1,1e7 do a=a+t.x[2] end
  print('a=',a)
end
print('time=',os.clock()-t0)
time= 1.14

Output code A:
building dict:  1
a=  21000000.000896
time= 1.14
changing t.B.x by t[2].x
time= 1.14
changing t.B.x by t.x[2]
time= 0.012
]]
