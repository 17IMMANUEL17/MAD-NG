--[=[
 o-----------------------------------------------------------------------------o
 |
 | Table module
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide MAD table objects (TFS tables)

 o-----------------------------------------------------------------------------o
]=]

-- help -----------------------------------------------------------------------o

local __help = {}
__help.mtable = [=[
NAME
  mtable -- TFS table

SYNOPSIS
  my_tab = mtable 'mytab' { column_name_list... }

DESCRIPTION
  The module table creates TFS tables used by MAD. The rows and the columns can
  be accessed (in this order) by name or by index. If a name of the column name
  list is itself enclosed into a list, then the name of the elements can be used
  to access the row. Adding news rows or columns let the table grows
  automatically.

RETURN VALUE
  The TFS table.

ERRORS
  TODO

EXAMPLES
  local mtable in MAD
  tbl = mtable 'survey' { {'name'}, 'x', 'y', 'z', 'phi', 'theta', 'rho' }
  tbl:add{ 'dft', 0.1, 0.2, 0.5, 0, 0, 0 }
  tbl:add{ name='mq', x=0.2, y=0.4, z=1 }
  tbl = tbl + { name='mq', x=0.2, y=0.4, z=2 }
  print(tbl.x[2])     -- x of 'mq[1]' using col-then-row access
  print(tbl.mq[1].x)  -- x of 'mq[1]' using row-then-col access
  print(tbl.dft.x)    -- x of 'dft'   using row-then-col access
  tbl:write()         -- equivalent to tab:write "survey.tfs"

SEE ALSO
  sequence, element, beam
]=]

-- locals ---------------------------------------------------------------------o

local Object, vector, env                                        in MAD
local fprintf                                                    in MAD.utility
local is_nil, is_number, is_positive, is_string, is_table,
      is_function, is_file, is_matrix, is_cmatrix, isa_matrix    in MAD.typeid

local min, max, ceil in math
local table_insert, table_remove = table.insert, table.remove

-- root object ----------------------------------------------------------------o

-- hidden keys: internals, row dictionnary, columns array, selected rows.
local _var, _row, _col = {}, {}, {}

local mtable = Object 'mtable' {
  kind='mtable', type='', title='', origin=origin
}

local function is_mtable(a)
  return is_table(a) and not is_nil(a[_var])
end

local origin = string.format("MAD %s %s %s", env.version, env.os, env.arch)
local mtable_mt = getmetatable(mtable) -- backup original (see metamethods)

-- header keys (I/O) ----------------------------------------------------------o

-- remove keys from the list of keys to display in the header
local function rem_keys (tbl, keys)
  if is_string(keys) then keys = {keys} end
  assert(is_table(keys), "invalid argument #2 ([list of] strings expected)")
  local list = tbl[_var].hrdnam
  for i=1,#keys do
  for j=1,#list do -- cubic, should be fast enough for most cases.
    if list[j] == keys[i] then
      table_remove(list, j) ; break
    end
  end end
  return tbl
end

-- add keys to the list of keys to display in the header
local function ins_keys (tbl, keys)
  assert(is_table(keys),
    "invalid argument #2 (set of new_key_to_ins[=where_to_ins_key] expected)")
  local list = tbl[_var].hrdnam
  for nk,k in pairs(keys) do
    if is_number(nk) then
      assert(is_string(k), "invalid header key (string expected)")
      table_insert(list, k)
    else -- quadratic, should be fast enough for most cases.
      assert(is_string(nk), "invalid header key (string expected)")
      for j=1,#list do -- search for position to insert
        if list[j] == k then
          table_insert(list, j, nk) ; break
        end
      end
    end
  end
  return tbl
end

-- rows bookkeeping -----------------------------------------------------------o

-- set the amount of rows allocated on first expand.
local function reserve (tbl, nrow)
  assert(is_number(nrow), "invalid argument #2 (number expects)")
  tbl[_var].reserve = ceil(min(nrow, max(nrow,1), 1e5))
  return tbl
end

-- allocated more memory for rows (i.e. vectors).
local function expand (tbl, idx)
  local var, col = tbl[_var], tbl[_col]
  local len = ceil(max(idx, var.reserve, var.maxrow*1.5))
  for i=1,var.lastvec do
    col[i] = vector(len):copy(col[i])
  end
  var.maxrow = len
end

-- ensure that enough rows are available (i.e. vectors).
local function resize (tbl, idx)
  local var = tbl[_var]
  local vec = var.colvec
  if idx > var.maxrow then expand(tbl, idx) end
  for i=1,var.lastvec do
    vec[i]:_reshape(idx)
  end
end

-- ensure that enough rows are available for insertion (i.e. vectors).
local function insert (tbl, idx)
  local var = tbl[_var]
  local vec = var.colvec
  local len = var.lastrow+1
  if len > var.maxrow then expand(tbl, len) end
  for i=1,var.lastvec do
    vec[i]:_reshape(idx)
    vec[i]:shift()
  end
end

-- convert columns with numbers into vectors plus some bookkeeping.
local function specialize (tbl)
  local var, row, col = tbl[_var], tbl[_row], tbl[_col]
  local len = max(var.reserve, var.maxrow)
  local j, colvec = 0, {}
  for i=1,var.lastcol do
    local v = col[i][1]
    if is_number(v) then
      col[i], j = vector(len):seti(1, v), j+1
      colvec[j] = col[i]
    else
      col[i]    = table.new(len,0)
      col[i][1] = v
    end
  end
  tbl[_sel] = table.new(len,0)
  if j > 0 then
    var.lastvec = j
    var.colvec  = colvec
    var.maxrow  = len
  else
    var.maxrow  = 2^31
  end
  if var.refcol then
    row[_col] = col[tbl[_var].refcol]
    assert(is_table(row[_col]), "invalid reference column (table expected)")
  end
end

-- build dictionnary ----------------------------------------------------------o

local function build_dict (tbl)
  local row, col = tbl[_row], tbl[_row][_col]
  table.clear(row)                    -- clear content
  row[_col] = col                     -- restore link to refcol
  for idx,key in ipairs(col) do
    if is_nil(row[key]) then          -- none -> key, index
      row[key] = idx
    elseif is_number(row[key]) then   -- one  -> create array
      row[key] = {row[key], idx}
    else                              -- many -> append
      table_insert(row[key], idx)
    end
  end
end

-- manipulate rows ------------------------------------------------------------o

local function index_of (tbl, idx)
  if is_number(idx) then        -- mirror negative row index
    return idx >= 0 and idx or idx+tbl[_var].lastrow+1
  elseif is_string(idx) then    -- string to index (or array of index)
    return tbl[_row][idx]
  end
end

local function swp_row (tbl, idx1, idx2)
  local col = tbl[_col]
  for i=1,tbl[_var].lastcol do
    col[i][idx1], col[i][idx2] = col[i][idx2], col[i][idx1]
  end
  tbl[_sel][idx1], tbl[_sel][idx2] = tbl[_sel][idx2], tbl[_sel][idx1]
end

local function cpy_row (tbl, idx, val)
  local col = tbl[_col]
  local len = min(#val, tbl[_var].lastcol)
  if len > 0 then                                    -- index-value copy
    for i=1,len do
      col[i][idx] = val[i]
    end
  else                                               -- key-value copy
    for k,v in pairs(val) do
      local i = col[k]
      assert(i, "invalid argument #3 (invalid column name)")
      col[i][idx], len = v, len+1
    end
  end
  tbl[_sel][idx] = true -- select row
  return len
end

local function sht_row (tbl, idx, dir)
  local col = tbl[_col]
  if dir > 0 then
    for i=1,tbl[_var].lastcol do
      if is_table(col[i]) then
        table_insert(col[i], idx, 0)
      else
        col[i]:shiftv(idx, 1)
      end
    end
    table_insert(tbl[_sel], idx, true)
  elseif dir < 0 then
    for i=1,tbl[_var].lastcol do
      if is_table(col[i]) then
        table_remove(col[i], idx)
      else
        col[i]:shiftv(idx, -1)
      end
    end
    table_remove(tbl[_sel], idx)
  end
end

local function add_row (tbl, val) -- exposed
  assert(is_mtable(tbl)  , "invalid argument #1 (mtable expected)")
  assert(is_iterable(val), "invalid argument #2 (iterable expected)")
  local var = tbl[_var]
  local rsz = var.lastrow+1
  if var.lastvec then resize(tbl, rsz) end
  local len = cpy_row(tbl, rsz, val)
  if len ~= var.lastcol then
    error(string.format(
      "invalid argument #2 (missing %d columns in row add)", var.lastcol-len))
  end
  if rsz == 1 then specialize(tbl) end
  var.lastrow = rsz
  var.valid = nil -- invalidate the dict
  return tbl
end

local function ins_row (tbl, idx, val) -- exposed
  idx = index_of(tbl, idx)
  assert(is_mtable(tbl)  , "invalid argument #1 (mtable expected)")
  assert(is_number(idx)  , "invalid argument #2 (row index expected)")
  assert(is_iterable(val), "invalid argument #3 (iterable expected)")
  local var = tbl[_var]
  local rsz = var.lastrow+1
  if idx == rsz then return add_row(tbl, val) end
  assert(idx >= 1 and idx < rsz, "invalid argument #2 (row index out of bounds)")
  if var.lastvec then resize(tbl, rsz) end
  sht_row(tbl, idx, 1) -- shift row from idx by one row down
  local len = cpy_row(tbl, idx, val)
  if len ~= var.lastcol then
    error(string.format(
      "invalid argument #3 (missing %d columns in row insert)", var.lastcol-len))
  end
  var.lastrow = rsz
  var.valid = nil -- invalidate the dict
  return tbl
end

local function rem_row (tbl, idx) -- exposed
  idx = index_of(tbl, idx)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  assert(is_number(idx), "invalid argument #2 (row index expected)")
  local var = tbl[_var]
  local rsz = var.lastrow
  assert(idx >= 1 and idx <= rsz, "invalid argument #2 (row index out of bounds)")
  if rsz >= 1 then
    rsz = rsz - 1
    sht_row(tbl, idx, -1) -- shift row from idx by one row up
    if var.lastvec then resize(tbl, rsz) end
    var.lastrow = rsz
    var.valid = nil -- invalidate the dict
  end
  return tbl
end

local function set_row (tbl, idx, val) -- exposed
  idx = index_of(tbl, idx)
  assert(is_mtable(tbl)  , "invalid argument #1 (mtable expected)")
  assert(is_number(idx)  , "invalid argument #2 (row index expected)")
  assert(is_iterable(val), "invalid argument #3 (iterable expected)")
  assert(idx >= 1 and idx <= tbl[_var].lastrow, "invalid argument #2 (row index out of bounds)")
  cpy_row(tbl, idx, val)
  var.valid = nil -- invalidate the dict
  return tbl
end

local function swp_rows (tbl, idx1, idx2) -- exposed
  idx1, idx2 = index_of(tbl, idx1), index_of(tbl, idx2)
  assert(is_mtable(tbl) , "invalid argument #1 (mtable expected)")
  assert(is_number(idx1), "invalid argument #2 (row index expected)")
  assert(is_number(idx2), "invalid argument #3 (row index expected)")
  assert(idx1 >= 1 and idx1 <= tbl[_var].lastrow, "invalid argument #2 (row index out of bounds)")
  assert(idx2 >= 1 and idx2 <= tbl[_var].lastrow, "invalid argument #3 (row index out of bounds)")
  swp_row(tbl, idx1, idx2)
  var.valid = nil -- invalidate the dict
  return tbl
end

-- manipulate columns ---------------------------------------------------------o

local function set_col (self, key, val)
  error('NYI')
end

local function ins_col (self, key, val)
  error('NYI')
end

local function add_col (self, key, val)
  error('NYI')
end

-- row proxy metamethods ------------------------------------------------------o

local function get_row_mt(self)
  local var_, col_ = self[_var], self[_col]

  local function idxiter (row, i)
    i = i+1
    if i <= var_.maxcol then return i, col_[i][row[_row]] end
  end

  local function keyiter (row, key)
    local i = row[_col]+1
    if i <= var_.maxcol then
      rawset(row, _col, i)
      return var_.colnam[i], col_[i][row[_row]]
    end
  end

  return {
    __len = function(row)
      local idx = row[_row]
      assert(is_number(idx), "invalid argument #2 (row count expected)")
      return idx >= 1 and idx <= var_.lastrow and var_.maxcol or 0
    end,

    __index = function(row, col)
      local idx = row[_row]
      if is_number(idx) then                                        -- row index
        if is_string(col) then col = col_[col] end           -- col key to index
        return col_[col] and col_[col][idx]
      elseif is_table(idx) then                                     -- row array
        assert(is_number(col), "invalid argument #2 (row count expected)")
        row[_row] = idx[col]                               -- row count to index
        return row
      end
      return nil
    end,

    __newindex = function(row, col, val)
      local idx = row[_row]
      if is_number(idx) then                                        -- row index
        assert(is_string(col) and col_[col], "invalid argument #2 (column key expected)")
        col_[col_[col]][idx] = val                           -- col key to index
      elseif is_table(idx) then                                     -- row array
        assert(is_number(col) and idx[col], "invalid argument #2 (row count expected)")
        set_row(self, idx[col], val)                       -- row count to index
      else
        error("invalid argument #2 (row count or column key expected)")
      end
    end,

    __ipairs = function (row)
      local idx = row[_row]
      assert(is_number(idx)                  , "invalid argument #1 (missing row count)")
      if idx < 0 then idx = var_.lastrow+idx end
      assert(idx >= 1 and idx <= var_.lastrow, "invalid argument #2 (row index out of bounds)")
      rawset(row, _row, idx)
      return idxiter, row, 0
    end,

    __pairs = function (row)
      local idx = row[_row]
      assert(is_number(idx)                  , "invalid argument #1 (missing row count)")
      if idx < 0 then idx = var_.lastrow+idx end
      assert(idx >= 1 and idx <= var_.lastrow, "invalid argument #2 (row index out of bounds)")
      rawset(row, _row, idx)
      rawset(row, _col, 0)
      return keyiter, row, nil
    end,

    metatable = false,
  }
end

-- mtable I/O -----------------------------------------------------------------o

local function write(self, filename_, colnames_, hdrnames_)
  if is_table(filename_) and is_nil(hdrnames_) then
    filename_, colnames_, hdrnames_ = nil, filename_, colnames_
  end
  local var, col = self[_var], self[_col]
  local hname = hdrnames_ or var.hdrnam
  local cname = colnames_ or var.colnam
  local cols = table.new(#cname, 0)

  -- check and collect columns
  for i=1,#cname do
    assert(col[cname[i]], "invalid column name")
    cols[i] = col[col[cname[i]]]
  end

  -- open file
  local file
  if is_file(filename_) then
    file = filename_
    assert(io.type(file) == 'file', "invalid argument #2 (open file expected)")
  else
    local fname = filename_ or self:get_key'name' or 'tmptable'
    assert(is_string(fname), "invalid argument #2 (string expected)")
    if string.sub(fname,-4) ~= '.tfs' then fname = fname .. '.tfs' end
    local handle, err = io.open(fname, 'w')
    file = handle
    if not handle then
      error("unable to open file '" .. fname .. "' for writing: " .. err)
    end
  end

  -- dump header
  for i=1,#hname do
    local k, v = hname[i], self:get_key(hname[i])
    if is_string(v) then
      fprintf(file, '@ %-18s %%%02ds %q\n', k, #v, v)
    elseif is_number(v) then
      fprintf(file, '@ %-18s %%le %s\n', k, tostring(v))
    else
      fprintf(file, '@ %-18s %%? %s\n', k, tostring(v))
    end
  end

  -- dump col names
  file:write('*')
  for i=1,#cols do
    fprintf(file, ' %-17s ', cname[i])
  end
  file:write('\n')

  -- dump col types
  file:write('$')
  for i=1,#cols do
    local v = cols[i][1]
    local fmt = is_string (v) and '%s'
             or is_number (v) and '%le' or '%?'
    fprintf(file, ' %-17s ', fmt)
  end
  file:write('\n')

  -- dump rows
  for j=1,var.lastrow do
    file:write(' ')
    for i=1,#cols do
      local v = cols[i][j]
      if is_string(v)
      then fprintf(file, '%-18s ', '"'..v..'"')
      else fprintf(file, '%-18s ', tostring(v))
      end
    end
    file:write('\n')
  end

  -- close file
  file:close()
  return self
end

-- table metamethods ----------------------------------------------------------o

--[=[
  Notes about mtable data structure:
  - Mtables are Objects
    + list of column names before init, cleared by init (empty).
    + dict of user variables (as any object)
      mtable provides name, type, title, origin, date and time by inheritance.

  - Hidden _var key: tbl[_var]
    + lastrow, lastcol: last valid row/column.
    + maxrow>=lastrow: vectors memory capacity (i.e. maxrow-lastrow=#free_row).
    + maxcol-lastcol>=0: extra column generators added by user (e.g. functors).
    + reserve: next maxrow allocation for vectors if reserve > maxrow.
    + resize: true if table contains at least one vector.
    + refcol: index of the reference column used as dict for direct row access.
    + hdrnam: list of ordered header key names for I/O (i.e. variable names).
    + colnam: list of ordered column names for I/O.
    + row_mt: metatable for row proxies, captures mtable and hidden keys.

  - Hidden _col key: tbl[_col]
    + list of the columns data ordered like in colnam.
    + dict of the columns key-col_index.
    + after the first row is stored, colunms are specialized by element types
      numbers are stored in vectors, others in lists.
    + supported formats are (numerics are formated by MAD.option.format):
      - string:  %s, %q (double quotes)
      - number:  %f, %d (e.g. 1.0, 1, -1) (+MAD-X %le)
      - logical: %l (true, false)

  - Hidden _row key: tbl[_row]
    + list of selected rows for I/O.
    + dict of refcol key-row_index or key-row_index_list (i.e. repeated key)
      i.e. pxy = tbl[_row][key][cnt_] -- row proxy for key (with cnt_)
           rci = tbl[_var].refcol     -- reference column index
      then pxy[rci] == key
    + direct access to reference column (if any, i.e. tbl[_row][_col])

  Notes about mtable row proxy:
  - Proxies are tables that store a mtable row reference
    + provides pairs and ipairs row iterators and row length
    + the mtable (i.e. self and hidden keys) is captured in the proxy metatable.

  - Hidden _row key: pxy[_row]
    + row_index or row_index_list
    + for row_index_list, the proxy expects a count to convert the list into a
      row_index and update pxy[_row] before use.
]=]

local function init_mm (tbl, nocheck)
  local row, col, var = {}, {}, {
    lastcol=0, lastrow=0, maxcol=0, maxrow=1, refcol=nil, row_mt=nil,
    reserve=8, resize=nil,
    hdrnam = { 'name', 'type', 'title', 'origin', 'date', 'time' },
    colnam = {},
  }
  -- top level variables to avoid lookup recursion
  rawset(tbl, _var, var)
  rawset(tbl, _row, row)
  rawset(tbl, _col, col)

  assert(nocheck or tbl.parent == mtable,
         "invalid mtable instance (inheritance not allowed)")

  for i,v in mtable_mt.__ipairs(tbl) do
    if is_table(v) then var.refcol, v = i, v[1] end   -- col is the dict
    assert(is_string(v), "invalid column name (string expected)")
    col[i], col[v], var.colnam[i] = {}, i, v          -- data, key2idx, idx2key
  end
  tbl:clear_array()

  if var.refcol then row[_col] = col[var.refcol] end -- direct access to ref col
  var.lastcol, var.maxcol = #col, #col               -- current #col
  var.row_mt = get_row_mt(tbl)                      -- row proxy metatable

  -- other keys are inherited from table
  tbl:set_variables { date = os.date'%d/%m/%y', time = os.date'%H:%M:%S' }
  return tbl
end

local function len_mm (tbl)
  return tbl[_var].lastrow
end

local function index_mm (tbl, key)                 -- access: tbl.row or tbl.col
  local idx = is_number(key) and key or tbl[_row][key]    -- row index or key
  if is_nil(idx) then                                     -- col key
    idx = tbl[_col][key]                                  -- col key to index
    if is_nil(idx) then                                   -- not col key
      return mtable_mt.__index(tbl, key)                  -- forward
    else
      return tbl[_col][idx]                               -- get full col
    end
  else
    return setmetatable({[_row]=idx}, tbl[_var].row_mt)   -- get full row (pxy)
  end
end

local function newindex_mm (self, key, val)  -- access: tbl.row or tbl.col = val
  local idx = is_number(key) and key or self[_row][key]    -- row index or key
  if is_nil(idx) then                                      -- col key
    idx = self[_col][key]                                  -- col key to index
    if is_nil(idx) then                                    -- not col key
      mtable_mt.__newindex(self, key, val)                 -- forward
    else
      set_col(self, idx, val)                              -- set full col
    end
  else
    set_row(self, idx, val)                                -- set full row
  end
end

local function iter (row, i)
  i = i+1
  if i <= row[_var].lastrow then
    rawset(row, _row, i)
    return i, row
  end
end

local function ipairs_mm (self)
  local row = setmetatable({[_row]=0, [_var]=self[_var]}, self[_var].row_mt)
  return iter, row, 0
end

init_mm(mtable, 'nocheck')
  : set_variables {
  header_names = \s -> s[_var].hdrnam,
  column_names = \s -> s[_var].colnam,
} : set_functions {
  add_keys = add_keys,
  get_key  = \s,k   -> mtable_mt.__index(s,k),
  set_key  = \s,k,v => mtable_mt.__newindex(s,k,v) return s end,
  reserve  = reserve,
  write    = write,
} : set_metamethods ({
  __add      = add_row,
  __len      = len_mm,
  __init     = init_mm,
  __index    = index_mm,
  __newindex = newindex_mm,
  __ipairs   = ipairs_mm,
}, true)
  : set_readonly()

-- end ------------------------------------------------------------------------o
return {
  mtable = mtable,
  __help = __help,
}
