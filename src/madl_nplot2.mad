local dat = require 'madl_plotdat2'
local is_nil, is_number, is_table, is_string, is_sequence     in MAD.typeid
local Command                                                 in MAD
local strinterp                                               in MAD.utility
local sign                                                    in MAD.gmath
-- global default -------------------------------------------------------------o

local _dflt = {
  color     = 'red',
  style     = 'linespoints',
  dashtype  = 'solid',
  linewidth = 1,
  pointsize = 1,
  pointtype = 1,
  filename  = "plot",
  lmargin   = 0.1,
  rmargin   = 0.9,
  tmargin   = 0.1,
  bmargin   = 0.9,
}

-- used to position the layout (e.g. top, bottom, etc...)
local layout_pos = {
  top    = { bmargin = 0.75, origin = 0.85  },
  middle = {                 origin = 0.425 },
  bottom = { tmargin = 0.2,  origin = 0     },
}

-- gplot ----------------------------------------------------------------------o

local _gpd = {}

local function has_plotter(gp, id)
  return not not gp[_gpd][id]
end

local function gp_create(gp, id)
  local gnuplot = assert(io.popen('gnuplot', 'w'))
  gp[_gpd][id] = gnuplot
  return gnuplot
end

local function gp_get (gp, id)
  local dat = gp[_gpd]
  if is_nil( dat[id] ) then gp_create( gp, id ) end
  if id ~= '__cur_id'  then dat.__cur_id = id end
  return dat[id]
end

local gplot = setmetatable({ [_gpd] = {__cur_id=1} },  {
  __index = gp_get,
  __call  = \gp,... -> gp[gp[_gpd].__cur_id]:write(...)
})

-- layout ---------------------------------------------------------------------o

local function xycpy(xfrom, yfrom, ysym, xto_, yto_)
  local size = #xfrom
  local xnew = xto_ or table.new(size, 0)
  local ynew = yto_ or table.new(size, 0)
  for i = 1,size do
    local xi, yi = xfrom[i], yfrom[i]
    local sxi, syi = #xi, #yi
    local xn, yn = table.new(sxi, 0), table.new(syi, 0)
    for j=1,sxi do
      table.insert(xn, xi[j])
    end
    for j=1,syi do
      table.insert(yn, yi[j]*ysym)
    end
    table.insert(xnew, xn)
    table.insert(ynew, yn)
  end
  return xnew, ynew
end

local xadjust = \x,l,s -> x*l + s
local yadjust = \y,s -> 0.05*y + (s or 0.9)

-- return the shape of an element in x and y
local function eShap(elem)
  local shape = dat[elem.kind]
  local el    = shape.ellipse
  local dash  = shape.dashtype

  local sh = shape.shape
  sh = sh and elem.l == 0 and elem.kind ~= "marker" and dat.default.shape or sh

  if not is_table(sh) then return el, dash end

  local x_sh, y_sh = sh.x, sh.y
  local x_sh2, y_sh2 = {}, {}
  local ysym = shape.ysym
  if is_number(ysym) then
    x_sh2, y_sh2 = xycpy(x_sh, y_sh, 1)
    x_sh2, y_sh2 = xycpy(x_sh, y_sh,-1, x_sh2, y_sh2)
  else
    ysym = sign(elem[ysym] or 1)
    x_sh2, y_sh2 = xycpy(x_sh, y_sh, ysym)
  end

  return el, dash, x_sh2, y_sh2
end

-- stream layout data
local function layout_data(param)
  local fpwrite, sequence, range, oshft in param
  local o = oshft
  for i,elem in sequence:iter(range) do
    local s, l = sequence:spos(i), elem.l
    param.min, param.max = param.min or s, s
    local el, dash, x_sh, y_sh = eShap(elem)
    if not is_nil(el) and l ~= 0 then
      -- TODO 0.5 -> 0 when centered
      local cx, cy = xadjust(0.5, l, s), yadjust(0   )
      local sx, sy = xadjust(1  , l, 0), yadjust(1, 0)
      local dashtype = dash or ""
      fpwrite("set object %d ellipse at %g, screen %g \\\n\z
        size %g, screen %g front fc rgb 'white' fs solid 1.0 border rgb 'black' %s \n",
        o, cx, cy, sx, sy, dashtype)
      o = o + 1
    end
    if not is_nil(x_sh) then
      for j=1,#x_sh do
        local xj, yj = x_sh[j], y_sh[j]
        local dashtype = dash and "dashtype '" .. dash .. "'" or ""
        fpwrite("set object %d polygon front fc rgb 'white' fs solid 1.0 border rgb 'black' %s \\\n", o, dashtype)
        local cmd = "from"
        for k=1,#xj do
          local xk = xadjust(xj[k], l, s)
          local yk = yadjust(yj[k])
          local next = k == #xj and "" or "\\"
          fpwrite("  %s %g, screen %g %s\n", cmd, xk, yk, next)
          cmd = "to"
        end
        o = o + 1
      end
      fpwrite("\n")
    end
  end
  fpwrite("set object %d rectangle behind noclip dashtype solid \\\n\z
    from first %g, screen 0.8999 to first %g, screen 0.901\n", o + 1, param.min, param.max)
end

-- main layout function
local function layout(param)
  layout_data(param)
end

-- plot -----------------------------------------------------------------------o

local margins = [[
set lmargin at screen $lmargin
set rmargin at screen $rmargin
set bmargin at screen $bmargin
set tmargin at screen $tmargin
]]

-- get vector from label
local function getv(data, tbl, label)
  if label then
    return data and data[label] or tbl[label],"tbl"  or error("invalid label")
  end
end

-- parse input axis and apply func to each label
local function parse_axis(param, func)
  local _axis = {'x1y1', 'x1y2', 'x2y1', 'x2y2'}
  for _,axis_name in ipairs(_axis) do
    local axis = param[axis_name]
    if is_string(axis) then                  -- e.g. x1y1 = 'y1'
      func(param, nil, axis, axis_name)
    elseif is_table(axis) and axis[1] then   -- e.g. x1y1 = {'y1', 'y2'}
      for i,y in ipairs(axis) do
        func(param, nil, y, axis_name)
      end
    elseif is_table(axis) then
      for x,y in pairs(axis) do
        if is_string(y) then                 -- e.g. x1y1 = { x1 = 'y1' }
          func(param, x, y, axis_name)
        elseif is_table(y) then              -- e.g. x1y1 = { x1 = {'y1', 'y2'}}
          for _,yi in pairs(y) do
            func(param, x, yi, axis_name)
          end
        end
      end
    end
  end
end

-- stream one plot data (used in parse_axis)
local function plot_data(param, xlbl, ylbl)
  local pwrite, tablerange, data, table in param
  local x      = getv(data, table, xlbl)
  local y,tbl  = getv(data, table, ylbl)
  local min    = tbl and tablerange and tablerange[1] or 1
  local max    = tbl and tablerange and tablerange[2] or #y
  for i=min,max do
    local x = x and x[i] or i -- use index if x is nil
    pwrite(x, " ", y[i], "\n")
  end
  pwrite("e\n")
end

-- parse dashtypes and add '' if it is a pattern : e.g.: ".-- "
local function parse_dash(dashtypes, y)
  local dash = is_table(dashtypes) and
    (dashtypes[y] or _dflt.dashtype) or dashtypes
  if string.match(dash, "[.%-_ ]+") then return "'" .. dash .. "'" end
  return dash
end

-- stream the gnuplot 'plot' command (used in parse_axis)
local function plot_cmd(param, _, y, axis)
  local pwrite, colors, styles, dashtypes, pointsizes,
    pointtypes, linewidths, legendnames in param
  local values = {
    color     = is_table(colors) and (colors[y] or _dflt.color) or colors,
    style     = is_table(styles) and (styles[y] or _dflt.style) or styles,
    dashtype  = parse_dash(dashtypes, y),
    pointsize = is_table(pointsizes)  and (pointsizes[y] or _dflt.pointsize) or pointsizes,
    pointtype = is_table(pointtypes)  and (pointtypes[y] or _dflt.pointtype) or pointtypes,
    linewidth = is_table(linewidths)  and (linewidths[y] or _dflt.linewidth) or linewidths,
    title     = is_table(legendnames) and legendnames[y] or y,
    axis      = axis,
  }
  local cmd = "$cmd using 1:2 with $style "
  if string.match(values.style, "lines") then
    cmd = cmd .. "dashtype $dashtype linewidth $linewidth "
  end
  if string.match(values.style, "points") then
    cmd = cmd .. "pointsize $pointsize pointtype $pointtype "
  end
  cmd = cmd .. "linecolor '$color' title '$title' axes $axis,\\\n"
  cmd = strinterp(cmd, values, false) % param
  param.cmd = "     '' "               -- only the first command need "plot '-'"
  pwrite(cmd)
end

-- set the range command for all axis
local function set_ranges(param)
  local fpwrite in param
  local names = {'x2range', 'yrange', 'y2range'}
  for _,rname in ipairs(names) do
    local range = param[rname]
    if range then fpwrite("set %s [%f:%f]\n", rname, range[1], range[2]) end
  end
  if not param.range and param.xrange then
    local xrange in param
    fpwrite("set xrange [%f:%f]\n", xrange[1], xrange[2])
  end
end

-- set label command for each axis
local function set_label(param)
  local fpwrite in param
  local names = {'xlabel', 'x2label', 'ylabel', 'y2label'}
  for _,lname in ipairs(names) do
    local label = param[lname]
    if label then fpwrite("set %s '%s'\n", lname, label) end
  end
end

-- set tics for each used axis
local function set_tics(param)
  local cmd = ""
  if param.x1y1 or param.x1y2 then cmd = cmd .. "set xtics nomirror \n"  end
  if param.x2y1 or param.x2y2 then cmd = cmd .. "set x2tics nomirror \n" end
  if param.x1y1 or param.x2y1 then cmd = cmd .. "set ytics nomirror \n"  end
  if param.x1y2 or param.x2y2 then cmd = cmd .. "set y2tics nomirror \n" end
  param.pwrite(cmd)
end

-- set remaining parameters (miscellaneous)
local function set_misc(param)
  local grid, border, title, legendpos, plotter in param
  local wrt = \s,... => plotter:write(string.format(s,...) % param) end
  if grid      then wrt("set %s\n", grid)          end
  if border    then wrt("set border %s\n", border) end
  if title     then
    local font = param.titlefont or ""
    local size = param.titlesize or ""
    wrt("set title '%s' font '%s,%s'\n", title, font, size)
  end
  if legendpos     then
    local font = param.legendfont or ""
    local size = param.legendsize or ""
    local cmd = "set key %s font '%s,%s'\n"
    wrt(cmd, legendpos, font, size)
  end
end

-- main plot function
local function plot(param)
  set_ranges(param)
  set_label(param)
  set_tics(param)
  set_misc(param)
  param.cmd = "plot '-'" -- first plot command initialization
  parse_axis(param, plot_cmd)
  param.pwrite("\n")
  parse_axis(param, plot_data)
end

-- command --------------------------------------------------------------------o

-- create a graph with both the layout and the plot part
local function multiplot(param)
  local fpwrite, pwrite, multiplot, sequence, range, seqpos in param
  -- select default margins or specific ones for layout position
  local margins = margins
  if is_string(seqpos) then
    margins = strinterp(margins, layout_pos[seqpos], false)
  end
  pwrite(margins % _dflt)
  layout(param)
  local min, max in param
  fpwrite("set xrange [%s:%s]\n", min, max)
  pwrite("set origin 0,0.0\n")
  pwrite("set size 1,0.85\n")
  plot(param)
  -- change origin to place the layout on the plot (top, bottom etc...)
end

-- setup the stream between the three possibilities : pdffile, windows, scrdump
local function set_stream(self)
  local filename, scrdump, windows in self
  if has_plotter(gplot, self.sid) and filename or not windows then
    return gplot[self.sid]
  end
  local plotter = gplot[self.sid]
  if filename then
    filename = is_string(filename) and filename or _dflt.filename
    plotter:write("set term pdfcairo\n")
    plotter:write("set out '" .. filename .. ".pdf'\n")
  elseif windows then
    plotter:write("set term $term $wid size $wsizex,$wsizey \z
      enhanced font \'$font,$fontsize\'\n" % self)
  end

  if scrdump then
    scrdump = is_string(scrdump) and scrdump or _dflt.filename
    local script = io.open(scrdump .. ".gp", "w")
    local p = {
      write = \s,... => plotter:write(...); script:write(...) end,
      flush = \s,... => plotter:flush(...); script:flush(...) end,
      close = \s,... => plotter:close(...); script:close(...) end,
    }
    return p
  end
  return plotter
end

local function exec(self)

  local plotter = set_stream(self, plotter)
  local param = {
    version = tostring(MAD.env.version),
    name    = self.name or is_table(self.table) and self.table.title or "",
    date    = self.date or is_table(self.table) and self.table.date  or "",
    time    = self.time or is_table(self.table) and self.table.time  or "",
    plotter = plotter,
    fpwrite = \... -> plotter:write(string.format(...)),
    pwrite = \... -> plotter:write(...)
  }

  setmetatable(param, {__index=self})

  if self.sequence and (self.table or self.data) then
    multiplot(param)
  else
    param.plotter:write(margins % param)
    if is_sequence(self.sequence) then
      layout(param)
    end
    if self.table or self.data then
      plot(param)
    end
  end
  param.plotter:flush()
  -- param.plotter:close()
  return self
end

local plot = Command 'plot' {

  sid         = 1,       -- stream id

  multiplot   = false,   -- user sent multiplot cmd himself

  -- windows setup
  windows     = true,
  wid         = 1,
  term        = 'wxt',
  wsizex      = 800,
  wsizey      = 500,

  -- table or data input
  data        = false,   -- { x=tbl.x, y=vec } (precedence over table)
  table       = false,
  tablerange  = false,   -- { min, max }

  -- sequence input
  sequence    = false,
  range       = {1,-1},  -- {13240, 13250}
  seqpos      = "top",   -- top|bottom|middle|0<x<1

  -- decoration
  font        = "Times New Roman",
  fontsize    = 14,
  title       = "$name MAD $version, $date, $time",
  titlefont   = false,
  titlesize   = false,
  legendnames = false,   -- { y = 'distance' }
  legendfont  = false,
  legendsize  = false,
  legendpos   = "left top",
  grid        = 'grid',
  border      = 15,

  -- files
  filename    = false,   -- pdf name or true (filename.pdf or plot.pdf)
  scrdump     = false,   -- script name or true (scrdump.gp or plot.gp)

  -- axis selection (and names)
  x1y1        = false,   -- e.g. x1y1 = { x1 = {'y1', 'y2'}, x2 = {'y3', 'y4'}}
  x1y2        = false,   -- e.g. x1y1 = { x1 = {'y1', 'y2'}}
  x2y1        = false,   -- e.g. x1y1 = { x1 = 'y1'}
  x2y2        = false,   -- e.g. x1y1 = {'y1', 'y2'}
                         -- e.g. x1y1 = 'y1'
  -- axis labels
  xlabel      = false,   -- strings
  x2label     = false,
  ylabel      = false,
  y2label     = false,

  -- axis ranges
  xrange      = false,   -- { min, max }
  x2range     = false,
  yrange      = false,
  y2range     = false,

  -- plot style
  styles      = 'lines', -- { y = 'lines' }
  colors      = 'red',   -- { y = 'green' }
  dashtypes   = 'solid', -- { y = '..-- ' }
  linewidths  = 1,       -- { y = 2.3     }
  pointtypes  = 1,       -- { y = 2       }
  pointsizes  = 1,       -- { y = 2.3     }

  -- margins
  lmargin     = 0.1,
  rmargin     = 0.9,
  tmargin     = 0.1,
  bmargin     = 0.9,

  -- object shift
  oshft = 1000000,

  -- build the command (do not execute)
  exec = exec,
} :set_readonly()

-- end ------------------------------------------------------------------------o

return {
  nplot2 = plot,
  ngplot2 = gplot
}