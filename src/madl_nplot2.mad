local dat = require 'madl_plotdat2'
local is_nil, is_number, is_table, is_mtable, is_string,
  is_sequence, is_rawtable                                    in MAD.typeid
local Command, fun, vector, survey                            in MAD
local strinterp, fileexists                                   in MAD.utility
local sign, tan, min, max, abs, sqrt, inf                     in MAD.gmath
-- Utility --------------------------------------------------------------------o

local ffi = require("ffi")

ffi.cdef[[
void Sleep(int ms);
int poll(struct pollfd *fds, unsigned long nfds, int timeout);
]]

local sleep
if ffi.os == "Windows" then sleep = \s -> ffi.C.Sleep(s)
else                        sleep = \s -> ffi.C.poll(nil, 0, s)
end

local function lock_file (fname, time, timeout)
  local waited = 0
  local lock   = fname .. ".lock"
  while fileexists(lock) do
    sleep(time)
    waited = waited + time
    if waited > timeout then
      os.remove(lock)
      error("lock file \"" .. lock .. "\" prevent us from proceeding")
    end
  end
  io.open(lock, "w"):close()
end

local unlock_file = \fname -> os.remove(fname .. ".lock")

MAD.utility.sleep       = sleep
MAD.utility.lock_file   = lock_file
MAD.utility.unlock_file = unlock_file

-- global default -------------------------------------------------------------o

local _dflt = {
  color        = 'red',
  style        = 'linespoints',
  dashtype     = 'solid',
  linewidth    = 1,
  pointsize    = 1,
  pointtype    = 1,
  filename     = "plot.pdf",
  scrdump      = "plot.gp",
  originx      = 0,
  originy      = 0,
  psizex       = 1,
  psizey       = 1,
  laysize      = 0.15,
  multisize    = 0.05,
  elemwidth    = 0.07,
  elemwidth_in = 1,
  padding      = 0.025,
  middle       = 0.5,
  layonly      = 1,
}

-- GC -------------------------------------------------------------------------o

local gcf = {}

local plotgc = ffi.gc(ffi.new("int*"), \ =>
    for i=1,#gcf do
      os.remove(gcf[i])
    end
  end
)

local function gc_file(fname, lock)
  table.insert(gcf, fname)
  if lock then table.insert(gcf, fname .. ".lock") end
  return fname
end

-- gplot ----------------------------------------------------------------------o

local _gpd, _tmpf = {}, {}

local function gp_create (gplot, id)
  local gnuplot = assert(io.popen('gnuplot', 'w'))
  gplot[_gpd ][id] = gnuplot
  gplot[_tmpf][id] = gc_file(os.tmpname(), true)
  return gnuplot
end

local function gp_isBusy (gplot, id)
  return fileexists(gplot[_tmpf][id] .. ".lock")
end

local function gp_get (gplot, id, curr)
  local dat = gplot[_gpd]
  if is_nil( dat[id] )             then gp_create( gplot, id ) end
  if id ~= '__cur_id' and not curr then dat.__cur_id = id      end
  return dat[id]
end

local function gp_getlock (gplot, id)
  local gnuplot = gp_get(gplot, id, true)
  local file    = gplot[_tmpf][id]
  return gnuplot, file
end

local function gp_call (gplot, id, ...)
  local gnuplot
  if is_number(id) then
    gnuplot = gp_get(gplot, id)
    gnuplot:write(...)
  else
    gnuplot = gp_get(gplot, gplot.__cur_id)
    gnuplot:write(id, ...)
  end
  gnuplot:flush()
end

local gplot = {
  is_busy = gp_isBusy,
  [{}]    = plotgc,
  [_tmpf] = { },
  [_gpd]  = { __cur_id = 1 },
}

setmetatable(gplot, {
  __index = gp_get,
  __call  = gp_call,
})

-- initialization -------------------------------------------------------------o

local init_cmd = [[
#== initialization =============================================================
if (!(exist("MAD_MIN") && exist("MAD_MAX"))) {
  MAD_MIN = $oshft;
  MAD_MAX = -1;
}
MAD_RESET_OBJECT = "unset for [i=MAD_MIN:MAD_MAX] object i"
MAD_RESET_LABEL  = "unset for [i=MAD_MIN:MAD_MAX] label i"
if (!(exist("MAD_OLD_TERM") && exist("MAD_NEW_TERM"))) {
  MAD_OLD_TERM = "";
  MAD_NEW_TERM = "";
}
MAD_SET_TERM = "if (!(MAD_OLD_TERM eq MAD_NEW_TERM)) { \
  @MAD_NEW_TERM; \
  MAD_OLD_TERM = MAD_NEW_TERM; \
}"
#===============================================================================

]]

-- open files and gnuplot and set terminal when necessary
local function setup_cmd (self)
  local output, scrdump in self
  local gp, streamf = gp_getlock(gplot,self.sid)
  local file, fname

  if scrdump then
    fname = is_string(scrdump) and scrdump or _dflt.scrdump
    gc_file(fname .. ".lock")
  else
    fname = streamf
  end
  lock_file(streamf, 100, 4000)
  file = io.open(fname, "w")

  file:write(init_cmd % self)

  if is_number(output) then
    file:write("MAD_NEW_TERM = \"set term $term $output size $wsizex,$wsizey \z
      enhanced font '$font,$fontsize'\"\n" % self)
  elseif output then
    local filename = is_string(output) and output or _dflt.filename
    file:write("MAD_NEW_TERM = \"set term pdfcairo; set out '"
      .. filename .. "'\"\n")
  end

  file:write("@MAD_SET_TERM\n")

  return gp, file, streamf, fname
end

local function gnuplot_rm(gp, fname)
  if jit.os == "Windows" then gp:write("system 'del "  ..fname.." >nul 2>&1'\n")
  else                        gp:write("system '\\rm -f "..fname.."'\n")
  end
end

local function teardown_cmd (self, gp, file, streamf, fname)
  file:close()
  gp:write("load('" .. fname .. "')\n")
  if not self.scrdump then gnuplot_rm(gp, streamf) end
  gnuplot_rm(gp, streamf .. ".lock")
  gp:flush()
end

-- layout ---------------------------------------------------------------------o

-- flag for multi_layout
local flg = MAD.element.flags.sel_angle

--  adjust "out of plot" layout coordinate
local xadjust    = \xs,ys,base,l -> xs*l + base
local yadjust    = \size  -> \xs,ys,base -> size*ys + base
--  adjust "in plot" layout coordinate
local xadjust_in = \size  -> \xs,ys,base -> xs*base[1] + size*ys*base[2] + base[3]
local yadjust_in = \size  -> \xs,ys,base -> xs*base[1] + size*ys*base[2] + base[3]

-- return the shape of an element in x and y
local function eShap (elem, dir)
  local shape = dat[elem.kind]
  local el, dash, sh = shape.ellipse, shape.dashtype, shape.shape

  sh = sh and elem.l == 0 and elem.kind ~= "marker" and dat.default.shape or sh
  -- if only a ellipse
  if not is_table(sh) then return el, dash end

  local ysym, yscl, func = shape.ysym, (shape.yscl or 1), nil
  local yshft = shape.yshft and sign(elem[shape.yshft]) or 0
  if is_number(ysym) then -- for symmetric shapes
    func = {
      \y -> ((   y + yshft)*yscl),
      \y -> ((-1*y + yshft)*yscl),
    }
  else
    local fv = sign(elem[ysym] or 1)
    ysym = (ysym == "angle") and fv*dir or fv
    func = {\y -> ((ysym*y + yshft)*yscl) }
  end
  return el, dash, sh.x, sh.y, func
end

-- stream polygon data
local function layout_poly (param, len, xorig, yorig, x_sh, y_sh, dash, func)
  local fpwrite, xadjust, yadjust, ref in param
  for i=1,#func do
    for j=1,#x_sh do
      local xj, yj = x_sh[j], y_sh[j]
      local dashtype = dash and "dashtype '" .. dash .. "'" or ""
      fpwrite("set object %d polygon front fc rgb 'white' fs solid 1.0 \z
        border rgb 'black' %s \\\n", param.oid, dashtype)
      local cmd = "from"

      for k=1,#xj do
        local xk, yk = xj[k], func[i](yj[k])
        xk, yk = xadjust(xk, yk, xorig, len), yadjust(xk, yk, yorig)
        local next = (k == #xj) and "" or "\\"
        fpwrite("  %s %f, %s %f %s\n", cmd, xk, ref, yk, next)
        cmd = "to"
      end
      param.oid = param.oid + 1
    end
  end
  fpwrite("\n")
end

-- stream ellipse data
local function layout_ellipse (param, len, el, xorig, yorig, dash, size)
  local fpwrite, xadjust, yadjust, ref in param
  local cx, cy = xadjust(0, 0, xorig, len), yadjust(0, 0, yorig)
  local sx, sy = len, el*size
  local dashtype = dash or ""
  fpwrite("set object %d ellipse front at %f, %s %f \\\n\z
    size %f, %s %f front fc rgb 'white' fs solid 1.0 border rgb 'black' %s \n",
    param.oid, cx, ref, cy, sx, ref, sy, dashtype)
  param.oid = param.oid + 1
end

-- stream element label data
local function layout_label(param, name, kind, xorig, yorig)
  local fpwrite, oid, ref, xadjust, yadjust in param
  local x, y = xadjust(0, 0, xorig, 1), yadjust(0, 0, yorig)
  label = name .. " [" .. kind .. "]"
  fpwrite("set label %d back at %f, %s %f '%s' hypertext \z
    point pt 4 ps 1 lc 'white'\n", oid, x, ref, y, label)
end

-- stream beam line data
local function layout_bline (param, bline)
  local fpwrite, ref in param
  local prevX, prevY = bline.x[1], bline.y[1]
  for i=2,#bline.y do
    local xi, yi = bline.x[i], bline.y[i]
    fpwrite("set object %d polygon front dashtype solid \\\n\z
      from first %f, %s %f to first %f, %s %f to first %f, %s %f\n",
      param.oid, prevX, ref, prevY, xi, ref, yi, prevX, ref, prevY)
    param.oid = param.oid + 1
    prevX, prevY = xi, yi
  end
end

-- process data for "out of plot" layout
local function layout_process(param, pseq)
  local seqshift in param
  local range, seq, disty, distx  in pseq
  local seqsize = seq:length_of(range)
  local xs, ys  = table.new(seqsize, 0), table.new(seqsize, 0)
  local bline   = { x = { }, y={ } }
  local deltaY  = disty

  local prevs_sh, angle, j, dir, sinit = 0, 0, 1, seq.direction
  for i, elem in seq:iter(range) do
    local s, len = seq:spos(i), elem.l
    local s_sh   = s + len/2
    sinit        = sinit or s
    deltaY       = deltaY - tan(dir*angle)*(s_sh-prevs_sh)
    xs[j], ys[j] = s_sh + distx + seqshift - sinit, deltaY
    prevs_sh     = s_sh
    pseq.xmin, pseq.xmax = min(pseq.xmin, xs[j]), max(pseq.xmax, xs[j])
    pseq.ymin, pseq.ymax = min(pseq.ymin, ys[j]), max(pseq.ymax, ys[j])
    if elem:is_selected(flg) then
      angle = angle + elem.angle
      table.insert(bline.x, xs[j]); table.insert(bline.y, ys[j])
    end
    j = j + 1
  end
  table.insert(bline.x, xs[#xs]); table.insert(bline.x, 1, xs[1])
  table.insert(bline.y, ys[#ys]); table.insert(bline.y, 1, ys[1])
  pseq.xs, pseq.ys, pseq.bline = xs, ys, bline
end

-- process data "in plot" layout
local function layout_process_in(param, pseq)
  local range, seq  in pseq
  local seqsize = seq:length_of(range)
  local xs, ys  = table.new(seqsize, 0), table.new(seqsize, 0)
  local bline   = { x = { }, y={ } }
  local srv     = survey { sequence = seq, range = range }
  local idx, j  = 0, 1

  for i, elem in seq:iter(range) do
    local line_idx = srv:index_of(elem.name, idx)
    if is_table(line_idx) then line_idx = line_idx[1] end
    idx = line_idx
    local line     = srv:get_row(line_idx)
    local prevLine, x1, y1, xas, yas, xbs, ybs

    repeat
      prevLine = (line_idx~=1) and srv:get_row(line_idx - 1) or { x=0, z=0 }
      x1, y1   = prevLine.x, prevLine.z
      x2, y2   = line.x, line.z
      xas, yas = 0.5*(x2 - x1), 0.5*(y2 - y1)
      line_idx = line_idx - 1
    until xas ~= 0 or yas ~= 0 or line_idx <= 1

    if xas == 0 and yas == 0 then
      xbs, ybs   = 0, 1
    else
      local xx, yy = (x1 - x2), (y2 - y1)
      local sqrt_  = 1 / sqrt( yy^2 + xx^2 )
      xbs, ybs = yy*sqrt_, xx*sqrt_
    end

    if elem.l == 0 then xshft, yshft = x2, y2
    else                xshft, yshft = x1 + xas, y1 + yas
    end

    xs[j], ys[j]         = {xas, xbs, xshft}, {yas, ybs, yshft}
    pseq.xmin, pseq.xmax = min(pseq.xmin, xshft), max(pseq.xmax, xshft)
    pseq.ymin, pseq.ymax = min(pseq.ymin, yshft), max(pseq.ymax, yshft)
    table.insert(bline.x, xshft); table.insert(bline.y, yshft)
    j = j + 1
  end
  pseq.xs, pseq.ys, pseq.bline = xs, ys, bline
end

-- stream a signle layout
local function layout (param, pseq)
  local elemminlen, elemkind, elemwidth, elemname in param
  local seq, range, xs, ys, bline                in pseq
  local dir, j  = seq.direction, 1

  layout_bline(param, bline)
  for i, elem in seq:iter(range) do
    local s, len, kind = seq:spos(i), elem.l, elem.kind
    local xorig, yorig = xs[j], ys[j]

    if len >= elemminlen and (not elemkind or elemkind[kind]) then
      local sh_l = len / 2
      local el, dash, x_sh, y_sh, func  = eShap(elem, dir)

      if elemname  then layout_label(param, elem.name, kind, xorig, yorig) end

      if not is_nil(el) and len ~= 0 then
        layout_ellipse(param, len, el, xorig, yorig, dash, elemwidth)
      end

      if not is_nil(x_sh) then
        layout_poly(param, sh_l, xorig, yorig, x_sh, y_sh, dash, func)
      end
    end
    j = j + 1
  end
end

-- compute bounding box and scale data accordingly
-- post processing for "out of plot" layout
local function layout_post(param, pseqs, ymin, ymax)
  local sequence, laypos, layonly, elemwidth in param
  param.laysize  = param.laysize
    or (layonly and _dflt.layonly)
    or (not is_sequence(sequence) and _dflt.laysize + _dflt.multisize*#sequence)
    or _dflt.laysize
  elemwidth     = (elemwidth or _dflt.elemwidth) * elemscale
  local pad     = _dflt.padding
  local ybbox   = abs(ymax - ymin) + 2*elemwidth + 2*pad
  local yfactor = param.laysize / ybbox
  elemwidth     = elemwidth * yfactor
  if laypos == "top"    then laypos =1-(ymax*yfactor + elemwidth + pad) end
  if laypos == "bottom" then laypos =  -ymin*yfactor + elemwidth + pad  end
  if laypos == "middle" then laypos = _dflt.middle end
  param.elemwidth = elemwidth

  for i=1,#pseqs do
    local pseq = pseqs[i]
    local ys, bline in pseq
    pseq.ys      = fun.map(\y -> y*yfactor + laypos, ys):totable()
    pseq.bline.y = fun.map(\y -> y*yfactor + laypos, bline.y):totable()
  end
end

-- post processing for "in plot" layout
local function layout_post_in(param, ymin, ymax)
  local elemwidth, elemscale in param
  elemwidth       = elemwidth or (abs(ymax - ymin) * _dflt.elemwidth_in / 100)
  param.elemwidth = elemwidth * elemscale
end

-- main layout function
local function multi_layout (param)
  local sequence, fpwrite, range, seqdistx, seqdisty,
    elemwidth, elemscale, laypos, xrange                  in param
  local is_in = (laypos == "in")
  param.ref = is_in and "" or "screen"
  local xmin, xmax, ymin, ymax = inf, -inf, inf, -inf
  local pseqs = { }
  local seqs = is_sequence(sequence) and {sequence} or sequence

  for i=1,#seqs do
    local distx = (i~=1) and (is_table(seqdistx) and seqdistx[i-1] or seqdistx) or 0
    local disty = (i~=1) and (is_table(seqdisty) and seqdisty[i-1] or seqdisty) or 0
    local rg    = (#seqs > 1) and is_table(range) and range[i] or range or nil
    local pseq  = {
      xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax,
      seq = seqs[i], distx = distx, disty = disty, range=rg
    }
    if is_in then layout_process_in(param, pseq)
    else          layout_process(param, pseq)
    end
    xmin, xmax = min(xmin, pseq.xmin), max(xmax, pseq.xmax)
    ymin, ymax = min(ymin, pseq.ymin), max(ymax, pseq.ymax)
    pseqs[i]   = pseq
  end

  if is_in then layout_post_in(param, ymin, ymax)
  else          layout_post(param, pseqs, ymin, ymax)
  end
  param.xadjust = is_in and xadjust_in(param.elemwidth) or xadjust
  param.yadjust = is_in and yadjust_in(param.elemwidth) or yadjust(param.elemwidth)

  for i=1,#pseqs do
    local pseq = pseqs[i]
    layout(param, pseq)
  end

  fpwrite("MAD_MAX = %f\n", param.oid)
  xmin, xmax = xmin - param.elemwidth, xmax + param.elemwidth
  ymin, ymax = ymin - param.elemwidth, ymax + param.elemwidth
  if not xrange           then fpwrite("set xrange [%s:%s]\n", xmin, xmax) end
  if not yrange and is_in then fpwrite("set yrange [%s:%s]\n", ymin, ymax) end
end

-- plot -----------------------------------------------------------------------o

-- get vector from label
local function getv (data, tbl, label)
  if label then
    return data and data[label] or tbl[label],"tbl"  or error("invalid label")
  end
end

-- parse input axis and apply func to each label
local function parse_axis (param, func)
  local _axis = {'x1y1', 'x1y2', 'x2y1', 'x2y2'}
  for _,axis_name in ipairs(_axis) do
    local axis = param[axis_name]
    if is_string(axis) then                  -- e.g. x1y1 = 'y1'
      func(param, nil, axis, axis_name)
    elseif is_table(axis) and axis[1] then   -- e.g. x1y1 = {'y1', 'y2'}
      for i,y in ipairs(axis) do
        func(param, nil, y, axis_name)
      end
    elseif is_table(axis) then
      for x,y in pairs(axis) do
        if is_string(y) then                 -- e.g. x1y1 = { x1 = 'y1' }
          func(param, x, y, axis_name)
        elseif is_table(y) then              -- e.g. x1y1 = { x1 = {'y1', 'y2'}}
          for _,yi in pairs(y) do
            func(param, x, yi, axis_name)
          end
        end
      end
    end
  end
end

-- stream one plot data (used in parse_axis)
local function plot_data (param, xlbl, ylbl)
  local pwrite, tablerange, data, table in param
  local x      = getv(data, table, xlbl)
  local y,tbl  = getv(data, table, ylbl)
  local min    = tbl and tablerange and tablerange[1] or 1
  local max    = tbl and tablerange and tablerange[2] or #y
  for i=min,max do
    local x = x and x[i] or i -- use index if x is nil
    pwrite(x, " ", y[i], "\n")
  end
  pwrite("e\n")
end

-- parse dashtypes and add '' if it is a pattern : e.g.: ".-- "
local function parse_dash (dashtypes, y)
  local dash = is_table(dashtypes) and
    (dashtypes[y] or _dflt.dashtype) or dashtypes
  if string.match(dash, "[.%-_ ]+") then return "'" .. dash .. "'" end
  return dash
end

-- stream the gnuplot 'plot' command (used in parse_axis)
local function plot_cmd (param, _, y, axis)
  local pwrite, colors, styles, dashtypes, pointsizes,
    pointtypes, linewidths, legendnames in param
  local values = {
    color     = is_table(colors) and (colors[y] or _dflt.color) or colors,
    style     = is_table(styles) and (styles[y] or _dflt.style) or styles,
    dashtype  = parse_dash(dashtypes, y),
    pointsize = is_table(pointsizes)  and (pointsizes[y] or _dflt.pointsize) or pointsizes,
    pointtype = is_table(pointtypes)  and (pointtypes[y] or _dflt.pointtype) or pointtypes,
    linewidth = is_table(linewidths)  and (linewidths[y] or _dflt.linewidth) or linewidths,
    title     = is_table(legendnames) and legendnames[y] or y,
    axis      = axis,
  }
  local cmd = "$cmd using 1:2 with $style "
  if string.match(values.style, "lines") then
    cmd = cmd .. "dashtype $dashtype linewidth $linewidth "
  end
  if string.match(values.style, "points") then
    cmd = cmd .. "pointsize $pointsize pointtype $pointtype "
  end
  cmd = cmd .. "linecolor '$color' title '$title' axes $axis,\\\n"
  cmd = strinterp(cmd, values, false) % param
  param.cmd = "     '' "               -- only the first command need "plot '-'"
  pwrite(cmd)
end

-- set the range command for all axis
local function set_ranges (param)
  local fpwrite in param
  local names = {'xrange', 'x2range', 'yrange', 'y2range'}
  for _,rname in ipairs(names) do
    local range = param[rname]
    if range then fpwrite("set %s [%f:%f]\n", rname, range[1], range[2]) end
  end
end

-- set label command for each axis
local function set_label (param)
  local fpwrite in param
  local names = {'xlabel', 'x2label', 'ylabel', 'y2label'}
  for _,lname in ipairs(names) do
    local label = param[lname]
    if label then fpwrite("set %s '%s'\n", lname, label) end
  end
end

-- set tics for each used axis
local function set_tics (param)
  local cmd = ""
  if param.x1y1 or param.x1y2 then cmd = cmd .. "set xtics nomirror \n"  end
  if param.x2y1 or param.x2y2 then cmd = cmd .. "set x2tics nomirror \n" end
  if param.x1y1 or param.x2y1 then cmd = cmd .. "set ytics nomirror \n"  end
  if param.x1y2 or param.x2y2 then cmd = cmd .. "set y2tics nomirror \n" end
  param.pwrite(cmd)
end

-- set remaining parameters (miscellaneous)
local function set_misc (param)
  local psizex, psizey, originx, originy, grid, border,
    title, legendpos, plotter                             in param
  local wrt = \s,... => plotter:write(string.format(s,...) % param) end
  if grid      then wrt("set %s\n", grid)          end
  if border    then wrt("set border %s\n", border) end
  if title     then
    local font = param.titlefont or ""
    local size = param.titlesize or ""
    wrt("set title '%s' font '%s,%s'\n", title, font, size)
  end
  if legendpos     then
    local font = param.legendfont or ""
    local size = param.legendsize or ""
    local cmd  = "set key %s font '%s,%s'\n"
    wrt(cmd, legendpos, font, size)
  end
  if psizey or psizex  then
    psizex, psizey = psizex or _dflt.psizex, psizey or _dflt.psizey
    wrt("set size %f, %f\n", psizex, psizey)
  end
  if originy or originx then
    originx, originy = originx or _dflt.originx, originy or _dflt.originy
    wrt("set origin %f, %f\n", originx, originy)
  end
end

-- main plot function
local function plot (param)
  set_ranges(param)
  set_label(param)
  set_tics(param)
  set_misc(param)
  param.cmd = "plot '-'" -- first plot command initialization
  parse_axis(param, plot_cmd)
  param.pwrite("\n")
  parse_axis(param, plot_data)
end

-- command --------------------------------------------------------------------o

-- create a graph with both the layout and the plot part
local function composed_plot (param)
  local laypos, psizey, originy in param

  multi_layout(param)

  local laysize in param
  if laypos == "top" or laypos == "bottom" then
    param.psizey = psizey or _dflt.psizey - laysize
  end
  param.originy = originy or laypos == "bottom" and laysize
                          or _dflt.originy
  plot(param)
end

-- initialize the table of parameters
local function init_param(self, file)
  local param = {
    version = tostring(MAD.env.version),
    name    = self.name or is_table(self.table) and self.table.title or "",
    date    = self.date or is_table(self.table) and self.table.date  or "",
    time    = self.time or is_table(self.table) and self.table.time  or "",
    plotter = file,
    oid     = self.oshft,
    fpwrite = \... -> file:write(string.format(...)),
    pwrite  = \... -> file:write(...)
  }
  if self.elemkind then -- build dictionary
    param.elemkind = {}
    fun.foreach(\e => param.elemkind[e] = true end, self.elemkind)
  end

  setmetatable(param, {__index=self})
  return param
end

local layout_only = [[
unset key
unset tics
unset border
plot x lc 'white'
]]

local function exec (self)
  local gp, file, streamf, fname = setup_cmd(self)

  if self.sequence ~= "keep" then
    file:write("@MAD_RESET_OBJECT\n")
    file:write("@MAD_RESET_LABEL\n")
  elseif self.range then
    print("MAD Plot Warning : sequence=\"keep\" and range is \z
      provided - range is ignored")
  end

  if self.prolog then file:write(self.prolog) end
  local param = init_param(self, file)

  local has_plot   = is_mtable(self.table) or is_table(self.data)
  local has_layout = is_rawtable(self.sequence) or is_sequence(self.sequence)
  if has_plot and has_layout then
    composed_plot(param)
  elseif has_plot then
    plot(param)
  elseif has_layout then
    param.layonly = true
    multi_layout(param)
    param.fpwrite(layout_only)
  end

  if self.epilog then file:write(self.epilog) end
  teardown_cmd(self, gp, file, streamf, fname)
  return self
end

local plot = Command 'plot' {

  -- stream id
  sid         = 1,

  -- user command
  prolog      = false,   -- string
  epilog      = false,   -- string

  -- windows setup
  term        = 'wxt',
  wsizex      = 800,
  wsizey      = 500,

  -- output
  output      = 1,       -- ("filename"|true) -> pdf | number -> wid
  scrdump     = false,   -- ("filename"|true)

  -- table or data input
  data        = false,   -- { x=tbl.x, y=vec } (precedence over table)
  table       = false,
  tablerange  = false,   -- { min, max }

  -- sequence input
  sequence    = false,
  range       = false,   -- {'E.DS.L5.B1','S.DS.R5.B1'} or {122.2, 543} etc...
  seqdisty    = 0,     -- x >= 0 or { x1, x2, ... }
  seqdistx    = 0,     -- x >= 0 or { x1, x2, ... }
  seqshift    = 0,     -- x > =0

  -- layout style
  laypos      = "top",   -- top | bottom | middle | in | 0 < x < 1
  laysize     = false,   -- 0 < x < 1
  elemname    = true,
  elemwidth   = false,   -- unsigned size of element before elemscale
  elemscale   = 1,       -- multiplier or default size
  elemkind    = false,   -- { "quadrupole", "sbend" }
  elemminlen  = 0,       -- x > 0

  -- axis selection (and names)
  x1y1        = false,   -- e.g. x1y1 = { x1 = {'y1', 'y2'}, x2 = {'y3', 'y4'}}
  x1y2        = false,   -- e.g. x1y1 = { x1 = {'y1', 'y2'}}
  x2y1        = false,   -- e.g. x1y1 = { x1 = 'y1'}
  x2y2        = false,   -- e.g. x1y1 = {'y1', 'y2'}
                         -- e.g. x1y1 = 'y1'
  -- axis labels
  xlabel      = false,   -- strings
  x2label     = false,
  ylabel      = false,
  y2label     = false,

  -- axis ranges
  xrange      = false,   -- { min, max }
  x2range     = false,
  yrange      = false,
  y2range     = false,

  -- plot style
  originx     = false,   -- 0 < x < 1
  originy     = false,   -- 0 < x < 1
  psizex      = false,   -- 0 < x < 1
  psizey      = false,   -- 0 < x < 1
  styles      = 'lines', -- { y = 'lines' }
  colors      = 'red',   -- { y = 'green' }
  dashtypes   = 'solid', -- { y = '..-- ' }
  linewidths  = 1,       -- { y = 2.3     }
  pointtypes  = 1,       -- { y = 2       }
  pointsizes  = 1,       -- { y = 2.3     }

  -- decoration
  font        = "Times New Roman",
  fontsize    = 14,
  title       = "$name MAD $version, $date, $time",
  titlefont   = false,
  titlesize   = false,
  legendnames = false,   -- { y = 'distance' }
  legendfont  = false,
  legendsize  = false,
  legendpos   = "left top",
  grid        = 'grid',
  border      = 15,

  -- object shift
  oshft       = 1000000,

  -- build the command (do not execute)
  exec        = exec,
} :set_readonly()

-- end ------------------------------------------------------------------------o

return {
  nplot2 = plot,
  ngplot2 = gplot
}