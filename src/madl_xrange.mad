--[=[
 o-----------------------------------------------------------------------------o
 |
 | Range module
 |
 | Methodical Accelerator Design - Copyright CERN 2015+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provides full set of functions and operations on ranges (xranges) and
    logrange.

 o-----------------------------------------------------------------------------o
]=]

local M    = { __help = {} }
local Mlog = { __help = {} }

-- help -----------------------------------------------------------------------o

M.__help.self = [=[
NAME
  range

SYNOPSIS
  local r1 = range(start [,stop [,step]])
  local r2 = start..stop[..step]
  print(r1.start, r1.stop, r1.step)

DESCRIPTION
  Ranges are defined by their start, stop (included) and step fields. Zero step
  or steps with opposite sign to stop-start lead to an empty range. Ranges can
  be used as stateless iterators in for loops (i.e. ipairs), and provide better
  numerical stability for 'true' floating point numbers.
    Some methods like get, index (i.e. []) and iterator (i.e. ipairs) return nil
  outside the boundaries, and some others like value don't check for boundaries.
  The range module implements the functions:
    range (constructor), get, value, size, index, first, last, minmax, bounds,
    ovelap, equal, tostring, totable, tovector, scale, translate, revert.

RETURN VALUE
  The constructor of ranges

ERROR

EXAMPLES

SEE ALSO
  None.
]=]

Mlog.__help.self = M.__help.self

-- locals ---------------------------------------------------------------------o

local new, cdef, typeof, metatype in require 'ffi'
local is_number, is_range         in require 'madl_utils'
local max, floor                  in math

cdef [[
  typedef struct logxrange { const double start, stop, step; } logxrange;
]]

local range    = typeof 'xrange'
local logrange = typeof 'logxrange'

-- implementation -------------------------------------------------------------o

local function size (start, stop, step)
  if step > 1 then
    return max(0, floor( (stop-start+1)/step +0.5) )
  elseif step < -1 then
    return max(0, floor( (stop-start-1)/step +0.5) )
  elseif step ~= 0 then
    return max(0, floor( (stop-start  )/step +1.5) )
  else
    return 0
  end
end

local function sizelog (start, stop, step)
  -- TODO
  if step > 1 then
    return max(0, floor( (stop-start+1)/step +0.5) )
  elseif step < -1 then
    return max(0, floor( (stop-start-1)/step +0.5) )
  elseif step ~= 0 then
    return max(0, floor( (stop-start  )/step +1.5) )
  else
    return 0
  end
end

local function value (r, x)
  return r.start + (x-1)*r.step
end

local function valuelog (r, x)
  return r.start * r.step^(x-1)
end

local function iterincr(r, i)
  local v = value(r, i)
  if v <= r.stop then return i+1, v end
end

local function iterincrlog(r, i)
  local v = valuelog(r, i)
  if v <= r.stop then return i+1, v end
end

local function iterdecr(r, i)
  local v = value(r, i)
  if v >= r.stop then return i+1, v end
end

local function iterdecrlog(r, i)
  local v = valuelog(r, i)
  if v >= r.stop then return i+1, v end
end

local function get (r, x)
  local v = value(r, x)
  if x >= 1 and ((r.step > 0 and v <= r.stop)  or
                 (r.step < 0 and v >= r.stop)) then
    return v
  end
end

local function getlog (r, x)
  local v = valuelog(r, x)
  local s = abs(r.step)
  if x >= 1 and
    ((s > 1 and r.start > 0 or s < 1 and r.start < 0) and v <= r.stop) or
    ((s > 1 and r.start < 0 or s < 1 and r.start > 0) and v >= r.stop)
  then return v
  end
end

function M.__new (ct, start, stop, step)
  assert(is_number(start), "invalid argument #1 (expect number)")
  if stop == nil then stop = start end -- default
  if step == nil then step = 1 end     -- default
  return new(ct, start, stop, step)
end

function Mlog.__new (ct, start, stop, step)
  assert(is_number(start), "invalid argument #1 (expect number)")
  if stop == nil then stop = start end -- default
  if step == nil then step = 2 end     -- default
  return new(ct, start, stop, step)
end

function M.log (a)
  return logrange(a.start, a.stop, a.step)
end

function M.__index (r, a)
  if is_number(a) then return get(r, a) else return M[a] end
end

function Mlog.__index (r, a)
  if is_number(a) then return getlog(r, a) else return M[a] end
end

function M.__ipairs (r)
  if r.step > 0 then
    return iterincr, r, 0
  elseif r.step < 0 then
    return iterdecr, r, 0
  end
end

function Mlog.__ipairs (r)
  local s = abs(r.step)
  if s > 1 and r.start > 0 or s < 1 and r.start < 0 then
    return iterincrlog, r, 1
  elseif s > 1 and r.start < 0 or s < 1 and r.start > 0 then
    return iterdecrlog, r, 1
  end
end

function M.range (r)
  return r.start, r.stop, r.step
end

function Mlog.range (r)
  return r.start, r.stop, r.step
end

function M.size (r)
  return size(r:range())
end

function Mlog.size (r)
  return sizelog(r:range())
end

M.get      = get
M.value    = value
M.len      = size

Mlog.get   = getlog
Mlog.value = valuelog
Mlog.len   = sizelog

-- methods
--[=[

function M.index (r, x)
  local i = size(r.start, x, r.step)
  return i >= 1 and i <= r:size() and i or nil
end

function M.first(r)
  return r.start
end

function M.last (r)
  if r:size() == 0 then
    return r.start
  else
    return r:value(r:size()) end
end

function M.minmax (r)
  if r.step < 0 then
    return r:last(), r:first()
  else
    return r:first(), r:last()
  end
end

function M.bounds (r)
  if r.step < 0 then
    return r.stop, r.start
  else
    return r.start, r.stop
  end
end

function M.overlap (r, s)
  if r:size() == 0 or s:size() == 0 then
    return false
  end

  local rl, rh = r:bounds()
  local sl, sh = s:bounds()
  return not (rl < sl and rh < sl or rl > sh)
end

function M.equal (r1, r2)
  if r1:size() == 0 and r2:size() == 0 then
    return true
  else
    return r1.start == r2.start and r1.step == r2.step and r1.stop == r2.stop
  end
end

-- mutator

--[[
function M.scale (r, a)
  r._stop, r._step = r._stop*a, r._step*a
  r._size = size(r._start, r._stop, r._step)
  return r
end

function M.translate (r, a)
  r._start, r._stop = r._start+a, r._stop+a
  r._size = size(r._start, r._stop, r._step)
  return r
end

function M.reverse (r)
  r.start, r.stop, r.step = r.stop, r.start, -r.step
  return r
end]]

-- convertion

local function convert (r, ctor)
  local size = r:size()
  local t = ctor(size,0)
  for i=1,size do
    t[i] = r.start+(i-1)*r.step
  end
  return t
end

function M.totable (r)
  return convert(r, tnew)
end

function M.tostring (r)
  if r.step == 1 then
    return string.format("%g:%g", r.start, r.stop)
  else
    return string.format("%g:%g:%g", r.start, r.stop, r.step)
  end
end

--function M.tovector (r)
--  return convert(r, vector)
--end
]=]

-- metamethods
-- M.__eq      = M.equal

--[[

--[[
M.__len      = M.size
M.__tostring = M.tostring

local function iter(r, i)
  if i < r._size then
    return i+1, r._start+i*r._step
  end
end

function M.__ipairs (r) -- iterator: for n in ipairs(r)
  return iter, r, 0
end
]]

metatype('xrange'   , M   )
metatype('logxrange', Mlog)

-------------------------------------------------------------------------------o
return {
  range    = range,
  logrange = logrange,
}
