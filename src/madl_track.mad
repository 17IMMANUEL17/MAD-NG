--[=[
 o-----------------------------------------------------------------------------o
 |
 | Track module
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - TODO

 o-----------------------------------------------------------------------------o
]=]

--[=[
Notes about directions and quantities:
  element direction   edir: affects curvatures (edir = seq.dir).
  track direction (s) sdir: affects lengths    (sdir = cmd.dir).
  time direction  (t) tdir: affects angles     (tdir = edir x sdir).
  beam direction      bdir: affects strengths  (bdir = edir x sdir x chg).
]=]

-- locals ---------------------------------------------------------------------o

local command, element, mtable, damap, aperture, option, trace  in MAD

local is_nil, is_beam, is_sequence, is_boolean, is_number,
      is_integer, is_true, is_table, is_callable, is_iterable,
      is_mappable, is_tpsa, is_damap                            in MAD.typeid
local fnone, ffalse, ftrue, functor, chain, achain              in MAD.gfunc
local fact, arc2len                                             in MAD.gmath
local betablk, dp2pt                                            in MAD.gphys
local action, atbegin                                           in MAD.symint
local tblcat, errorf, assertf, printf                           in MAD.utility
local apercheck                                                 in MAD.aperture
local minlen, minang, minstr, clight, sqrt2, pi                 in MAD.constant
local is_implicit                                               in element.drift

local abs, min, max, sqrt, sin, cos, atan2 in math
local strsub = string.sub

-- constants
local minvolt = 1e-6

-- integrator schemes ---------------------------------------------------------o

local thinonly, thickonly, driftonly, DKD, MKM                  in MAD.symint

-- dynamic maps ---------------------------------------------------------------o

-- special elements (multipole, kickers)
local mult_kick, kicker_kick                                    in MAD.dynmap

-- straight and curved elements
local strex_drift, strex_kick, strex_fringe,
      curex_drift, curex_kick, curex_fringe                     in MAD.dynmap

-- bends (sbend and rbend)
local rbend_thick, rbend_kick,
      sbend_thick, sbend_kick, dipeg_fringe                     in MAD.dynmap

-- quadrupole
local quad_thick,  quad_kick,
      quad_sthick, quad_skick,
      quad_hthick, quad_hkick                                   in MAD.dynmap

-- solenoid
local solen_thick, solen_fringe                                 in MAD.dynmap

-- rfcavity
local rfcav_kick, rfcav_kickn, rfcav_fringe                     in MAD.dynmap

-- patches
local xrotation, yrotation, srotation, translate,
      changeref, changedir, changenrj, misalign                 in MAD.dynmap

-- sabac: TODO
local sabac_quad_drift, sabac_quad_kick, sabac_quad_corr        in MAD.dynmap

-- debug ----------------------------------------------------------------------o

local shtfmt = "% -.6e % -.6e % -.6e % -.6e % -.6e % -.6e "
local lngfmt = "% -.16e % -.16e % -.16e % -.16e % -.16e % -.16e "
local mapfmt = lngfmt -- shtfmt

local nodump = {marker=true}

local function mdump (mflw, elm, str_)
  if str_ and mflw.ndump <= 1 then return end

  if is_number(elm) then
    printf("@@ %-15s %-15s % -.16e\n", 'number', str_, elm) return
  end
  if nodump[elm.kind] then return end

  printf("@@ %-15s %-15s ", elm.name, str_ or 'exit')
  if mflw.npar == 0 then printf("no particle found\n") return end

  local X, R = mflw[1]

  if is_damap(X) then
    X, R = X:get0(), X:get1()
    printf(mapfmt, X[1], X[2], X[3], X[4], X[5], X[6])
  else
    printf(mapfmt, X.x, X.px, X.y, X.py, X.t, X.pt)
  end

  if R then
    for i=1,R.nrow do
      printf(mapfmt, R:get(i,1), R:get(i,2), R:get(i,3),
                     R:get(i,4), R:get(i,5), R:get(i,6))
    end
  end
  printf('\n')
end

local function xdump (mflw, elm, str, X)
  printf("@@ %-15s %-15s ", elm.name, str)

  if is_tpsa(X) then
    printf(mapfmt == lngfmt and "% -.16e " or "% -.6e ", X:get(1))
    printf(mapfmt, X:get(2), X:get(3), X:get(4), X:get(5), X:get(6), X:get(7))
  elseif is_number(X) then
    printf(mapfmt == lngfmt and "% -.16e " or "% -.6e ", X)
  end
  printf('\n')
end

-- strengths and phases -------------------------------------------------------o

local function get_mult (elm, m, n)
  local knl, dknl = elm.knl or {}, elm.dknl or {}
  local ksl, dksl = elm.ksl or {}, elm.dksl or {}

  m.nmul = max(#knl, #ksl, #dknl, #dksl)

  for i=1,max(m.nmul,n or 0) do
    m.knl[i] = ((knl[i] or 0) + (dknl[i] or 0)) / fact(i-1)
    m.ksl[i] = ((ksl[i] or 0) + (dksl[i] or 0)) / fact(i-1)
  end
end

local function get_phas (elm, m, n)
  local pnl, dpnl = elm.pnl or {}, elm.dpnl or {}
  local psl, dpsl = elm.psl or {}, elm.dpsl or {}

  m.npha = max(#pnl, #psl, #dpnl, #dpsl)

  for i=1,max(m.npha,n or 0) do
    m.pnl[i] = (pnl[i] or 0) + (dpnl[i] or 0)
    m.psl[i] = (psl[i] or 0) + (dpsl[i] or 0)
  end
end

-- element tracking -----------------------------------------------------------o

local function trackelm (elm, m, track, thick, thin, fringe)
  local sdir, tlt in m
  local mis = m.misalign and misalign or fnone
  local rot = abs(tlt) >= minang and srotation or fnone

  mis   (elm, m,  sdir)
  rot   (tlt, m,  sdir)
  fringe(elm, m,  sdir)
  track (elm, m,    1 , thick, thin)
  fringe(elm, m, -sdir)
  rot   (tlt, m, -sdir)
  mis   (elm, m, -sdir)
end

local function tracksub (elm, m, track, thick, thin, fringe)
  local sdir, tlt in m
  local mis  = m.misalign and misalign or fnone
  local rot = abs(tlt) >= minang and srotation or fnone

  mis   (elm, m, sdir)
  rot   (tlt, m, sdir)
  fringe(elm, m, sdir)

  if sdir > 0 then
    local at, lw = 0
    for i=1,#elm do
      at, lw = elm[i].at, elm[i].at - at
      if abs(lw) >= minlen then
        track(elm, m, lw, thick, thin)
      end
      elm[i]:track(m.__sdat)
    end
    lw = 1 - at
    if abs(lw) >= minlen then
      track(elm, m, lw, thick, thin)
    end

  else -- backtrack
    local at, lw = 1
    for i=#elm,1,-1 do
      at, lw = elm[i].at, at - elm[i].at
      if abs(lw) >= minlen then
        track(elm, m, lw, thick, thin)
      end
      elm[i]:track(m.__sdat)
    end
    lw = at
    if abs(lw) >= minlen then
      track(elm, m, lw, thick, thin)
    end
  end

  fringe(elm, m, -sdir)
  rot   (tlt, m, -sdir)
  mis   (elm, m, -sdir)
end

-- kinds ----------------------------------------------------------------------o

local function track_marker (elm, m)
  m.el, m.tlt = 0, 0
  thinonly(elm, m, 1, nil, fnone)
end

local function track_drift (elm, m)
  local ds, tdir in m
  m.el, m.tlt = ds, 0

  if is_implicit(elm) then
    local track = m.implicit and thickonly or driftonly
    track(elm, m, 1, strex_drift)
  else
    m.tlt = elm.tilt*tdir
    local track = #elm == 0 and trackelm or tracksub
    local thick = abs(ds) >= minlen and thickonly or driftonly
    track(elm, m, thick, strex_drift, nil, fnone)
  end
end

local function track_multipole (elm, m)
  get_mult(elm, m)
  if m.nmul == 0 then return track_marker(elm, m) end

  local angle, tilt in elm
  local sdir, tdir in m
  m.el, m.tlt = 0, tilt*tdir

  local kick
  if abs(angle) < minang then
    kick = strex_kick
  else
    kick = mult_kick
    m.el, m.ang = elm.lrad*sdir, angle*tdir
  end

  trackelm(elm, m, thinonly, nil, kick, fnone)
end

local function track_sbend (elm, m, e1_, e2_)
  get_mult(elm, m, 3)
  local ds, tdir, nmul, knl, ksl in m
  local angle, tilt, k0, k0s, k1, k1s, k2, k2s, e1, e2 in elm
  local l = abs(ds)

  assert(l          >= minlen, "invalid sbend length (>0 expected)")
  assert(abs(angle) >= minang, "invalid sbend angle (~=0 expected)")

  if not k0 then k0 = angle/l end -- MAD-X backward compatibility

  knl[1], ksl[1] = knl[1]+(k0 or 0)*l  , ksl[1]+(k0s or 0)*l
  knl[2], ksl[2] = knl[2]+(k1 or 0)*l  , ksl[2]+(k1s or 0)*l
  knl[3], ksl[3] = knl[3]+(k2 or 0)*l/2, ksl[3]+(k2s or 0)*l/2
  m.el, m.ang, m.rho, m.tlt = ds, angle*tdir, ds/angle*tdir, tilt*tdir
  m.e1, m.e2 = (e1_ or e1)*tdir, (e2_ or e2)*tdir
  m.k0, m.k1 = knl[1]/l, knl[2]/l

  if nmul < 3 then
    m.nmul = max((k2 or k2s) and 3 or (k1 or k1s) and 2 or (k0 or k0s) and 1 or 0, nmul)
  end

  local model  = elm.model  or m.model
  local method = elm.method or m.method
  local thick, kick

  if model == 'DKD' then
    thick, kick = curex_drift, curex_kick
  else
    thick, kick = sbend_thick, sbend_kick
  end

  local track = #elm == 0 and trackelm or tracksub
  track(elm, m, DKD[method], thick, kick, curex_fringe)
end

local track_combined =\ error("NYI") -- TODO: for now...

local function track_rbend (elm, m)                                             -- unchecked
  local angle, true_rbend in elm

  if not true_rbend then
    return track_sbend(elm, m, elm.e1+angle/2, elm.e2+angle/2)
  end

  get_mult(elm, m, 3)
  local ds, tdir, nmul, knl, ksl in m
  local tilt, k0, k0s, k1, k1s, k2, k2s, e1, e2 in elm
  local l = abs(ds)

  assert(l          >= minlen, "invalid rbend length (>0 expected)")
  assert(abs(angle) >= minang, "invalid rbend angle (~=0 expected)")

  knl[1], ksl[1] = knl[1]+(k0 or 0)*l  , ksl[1]+(k0s or 0)*l
  knl[2], ksl[2] = knl[2]+(k1 or 0)*l  , ksl[2]+(k1s or 0)*l
  knl[3], ksl[3] = knl[3]+(k2 or 0)*l/2, ksl[3]+(k2s or 0)*l/2
  m.eld, m.ang, m.rho, m.tlt = ds, angle*tdir, ds/angle*tdir, tilt*tdir
  m.e1, m.e2 = e1*tdir, e2*tdir
  m.k0, m.k1 = knl[1]/l, knl[2]/l
  m.el = arc2len(ds, angle)

  if nmul < 3 then
    m.nmul = max((k2 or k2s) and 3 or (k1 or k1s) and 2 or (k0 or k0s) and 1 or 0, nmul)
  end

  local model  = elm.model  or m.model
  local method = elm.method or m.method
  local thick, kick

  if model == 'DKD' then
    thick, kick = strex_drift, strex_kick
  else
    thick, kick = rbend_thick, rbend_kick
  end

  local track = #elm == 0 and trackelm or tracksub
  track(elm, m, DKD[method], thick, kick, strex_fringe)

   m.eld = nil
end

local function track_quadrupole (elm, m)
  get_mult(elm, m, 3)
  local ds, tdir, nmul, knl, ksl in m
  local angle, tilt, k0, k0s, k1, k1s, k2, k2s in elm
  local l = abs(ds)

  assert(l >= minlen, "invalid quadrupole length (>0 expected)")

  knl[1], ksl[1] = knl[1]+(k0 or 0)*l  , ksl[1]+(k0s or 0)*l
  knl[2], ksl[2] = knl[2]+(k1 or 0)*l  , ksl[2]+(k1s or 0)*l
  knl[3], ksl[3] = knl[3]+(k2 or 0)*l/2, ksl[3]+(k2s or 0)*l/2
  m.el, m.tlt = ds, tilt*tdir

  if nmul < 3 then
    m.nmul = max((k2 or k2s) and 3 or (k1 or k1s) and 2 or (k0 or k0s) and 1 or 0, nmul)
  end

  local model  = elm.model  or m.model
  local method = elm.method or m.method
  local no_ang = abs(angle)  < minang
  local no_k1s = abs(ksl[2]) < minstr
  local inter, thick, kick

  -- Note: MKM integrators used uniform length for the thick map
  --       hence all cos, sin, cosh, sinh should be computed here...
  if model ~= 'TKT' or no_k1s and no_ang and abs(knl[2]) < minstr then
    inter, thick, kick = DKD[method], strex_drift, strex_kick
  elseif no_k1s and no_ang then                 -- normal thick
    inter, thick, kick = MKM[method], quad_thick, quad_kick
    m.k1 = knl[2]/l
  elseif no_ang then                            -- skew thick
    inter, thick, kick = MKM[method], quad_sthick, quad_skick
    local a = -0.5*atan2(ksl[2], knl[2])*tdir
    m.ca, m.sa, m.k1 = cos(a), sin(a), sqrt(knl[2]^2 + ksl[2]^2)/l*tdir
  else                                          -- curved thick
    inter, thick, kick = MKM[method], quad_hthick, quad_hkick
    m.rho, m.k0, m.k1 = ds/angle*tdir, knl[1]/l, knl[2]/l
  end

  local track = #elm == 0 and trackelm or tracksub
  track(elm, m, inter, thick, kick, strex_fringe)
end

local function track_sextupole (elm, m)
  get_mult(elm, m, 3)
  local ds, tdir, nmul, knl, ksl in m
  local tilt, k2, k2s in elm
  local l = abs(ds)

  knl[3] = knl[3]+(k2  or 0)*l/2
  ksl[3] = ksl[3]+(k2s or 0)*l/2
  m.el, m.tlt = ds, tilt*tdir

  if nmul < 3 then
    m.nmul = max((k2 or k2s) and 3 or 0, nmul)
  end

  local method = elm.method or m.method
  local inter = l < minlen and thinonly or DKD[method]
  local track = #elm == 0 and trackelm or tracksub
  track(elm, m, inter, strex_drift, strex_kick, strex_fringe)
end

local function track_octupole (elm, m)
  get_mult(elm, m, 4)
  local ds, tdir, nmul, knl, ksl in m
  local tilt, k3, k3s in elm
  local l = abs(ds)

  knl[4] = knl[4]+(k3  or 0)*l/6
  ksl[4] = ksl[4]+(k3s or 0)*l/6
  m.el, m.tlt = ds, tilt*tdir

  if nmul < 4 then
    m.nmul = max((k3 or k3s) and 4 or 0, nmul)
  end

  local method = elm.method or m.method
  local inter = l < minlen and thinonly or DKD[method]
  local track = #elm == 0 and trackelm or tracksub
  track(elm, m, inter, strex_drift, strex_kick, strex_fringe)
end

local function track_decapole (elm, m)
  get_mult(elm, m, 5)
  local ds, tdir, nmul, knl, ksl in m
  local tilt, k4, k4s in elm
  local l = abs(ds)

  knl[5] = knl[5]+(k4  or 0)*l/24
  ksl[5] = ksl[5]+(k4s or 0)*l/24
  m.el, m.tlt = ds, tilt*tdir

  if nmul < 5 then
    m.nmul = max((k4 or k4s) and 5 or 0, nmul)
  end

  local method = elm.method or m.method
  local inter = l < minlen and thinonly or DKD[method]
  local track = #elm == 0 and trackelm or tracksub
  track(elm, m, inter, strex_drift, strex_kick, strex_fringe)
end

local function track_dodecapole (elm, m)
  get_mult(elm, m, 6)
  local ds, tdir, nmul, knl, ksl in m
  local tilt, k5, k5s in elm
  local l = abs(ds)

  knl[6] = knl[6]+(k5  or 0)*l/120
  ksl[6] = ksl[6]+(k5s or 0)*l/120
  m.el, m.tlt = ds, tilt*tdir

  if nmul < 6 then
    m.nmul = max((k5 or k5s) and 6 or 0, nmul)
  end

  local method = elm.method or m.method
  local inter = l < minlen and thinonly or DKD[method]
  local track = #elm == 0 and trackelm or tracksub
  track(elm, m, inter, strex_drift, strex_kick, strex_fringe)
end

local function track_solenoid (elm, m)
  get_mult(elm, m)

  local ds, tdir, edir in m
  local tilt, ks, ksi in elm
  local l = abs(ds)

  assert(l >= minlen, "invalid solenoid length (>0 expected)")

  m.el, m.tlt = ds, tilt*tdir

  local ksi = ksi + ks*l
  local thick

  if abs(ksi) < minstr then
    thick = strex_drift
  else
    m.ks = ksi/l*edir
    thick = solen_thick
  end

  local method = elm.method or m.method
  local track  = #elm == 0 and trackelm or tracksub
  track(elm, m, DKD[method], thick, strex_kick, solen_fringe)
end

local function track_rfcavity (elm, m)
  get_mult(elm, m)

  local ds, tdir, model in m
  local tilt, volt in elm
  local l = abs(ds)

  m.el, m.tlt = ds, tilt*tdir

  local kick, fringe

  if abs(volt) < minvolt then
    kick, fringe = strex_kick, fnone
  else
    m.volt, m.freq, m.lag, m.nbsl = volt, elm.freq, elm.lag, elm.n_bessel or 0
    if m.freq == 0 then
      m.freq = 1e-6 * elm.harmon * clight * m.beam.beta / m.sequ.l
    else
      m.freq = m.freq * 1e-6
    end
    print('freq=', m.freq)
    assert(m.freq > 0, "invalid rfcavity setup, positive freq or harmon expected")
    m.lag = m.lag + m.freq*pi*l/(clight * m.beam.beta) -- shift lag: t=0 => accel=0
    kick, fringe = m.nmul+m.nbsl == 0 and rfcav_kick or rfcav_kickn, rfcav_fringe
  end

  local method = elm.method or m.method
  local inter = l < minlen and thinonly or DKD[method]
  local track = #elm == 0 and trackelm or tracksub
  track(elm, m, inter, strex_drift, kick, fringe)
end

local function track_tkicker (elm, m)
  local ds, tdir in m

  m.hk, m.vk = elm.hkick, elm.vkick
  m.el, m.tlt = ds, elm.tilt*tdir

  local method = elm.method or m.method
  local inter = abs(ds) < minlen and thinonly or DKD[method]
  local track = #elm == 0 and trackelm or tracksub
  track(elm, m, inter, strex_drift, kicker_kick, fnone)
end

local function track_kicker (elm, m)
  local ds, tdir in m

  m.hk, m.vk = elm.hkick + (elm.chkick or 0), elm.vkick + (elm.cvkick or 0)
  m.el, m.tlt = ds, elm.tilt*tdir

  local method = elm.method or m.method
  local inter = abs(ds) < minlen and thinonly or DKD[method]
  local track = #elm == 0 and trackelm or tracksub
  track(elm, m, inter, strex_drift, kicker_kick, fnone)
end

local function track_hkicker (elm, m)
  local ds, tdir in m

  m.hk, m.vk = elm.kick + (elm.chkick or 0), 0
  m.el, m.tlt = ds, elm.tilt*tdir

  local method = elm.method or m.method
  local inter = abs(ds) < minlen and thinonly or DKD[method]
  local track = #elm == 0 and trackelm or tracksub
  track(elm, m, inter, strex_drift, kicker_kick, fnone)
end

local function track_vkicker (elm, m)
  local ds, tdir in m

  m.hk, m.vk = 0, elm.kick + (elm.cvkick or 0)
  m.el, m.tlt = ds, elm.tilt*tdir

  local method = elm.method or m.method
  local inter = abs(ds) < minlen and thinonly or DKD[method]
  local track = #elm == 0 and trackelm or tracksub
  track(elm, m, inter, strex_drift, kicker_kick, fnone)
end

-- load maps into elements ----------------------------------------------------o

local invalid = \e ->
  errorf("invalid track element %s of kind %s with length %s",
          e.name, e.kind, e.l)

local notyetdone = \e ->
  errorf("tracking element %s of kind %s with length %s not yet implemented",
          e.name, e.kind, e.l)

local E = element

-- warning: class protection set by alt. 'nolookup' object model can be BYPASSED
--          because classes are modified before any use of 'track' attribute
--          by any children at the time of module loading...

-- kind maps

E. thin_element:setv({ track = functor( invalid      ) }, 'init') -- avoid missing definition
E.drift_element:setv({ track = functor( track_drift  ) }, 'init')
E.thick_element:setv({ track = functor( invalid      ) }, 'init') -- avoid missing definition
E.specl_element:setv({ track = functor( track_marker ) }, 'init')
E.patch_element:setv({ track = functor( invalid      ) }, 'init') -- avoid missing definition
E.extra_element:setv({ track = functor( invalid      ) }, 'init') -- forbidden in track

-- specialized maps (invalid == NYI)

E.sbend      :setv({ track = functor( track_sbend      ) }, 'init') -- curved  , k0, (k0s, k1, k1s)
E.combined   :setv({ track = functor( notyetdone       ) }, 'init') -- curved  , k0, k1, (k0s, k1s)
E.rbend      :setv({ track = functor( track_rbend      ) }, 'init') -- straight, k0, (k0s, k1, k1s)
E.quadrupole :setv({ track = functor( track_quadrupole ) }, 'init') -- straight, k0, k1, (k0s, k1s)
E.sextupole  :setv({ track = functor( track_sextupole  ) }, 'init') -- straight, (k2, k2s)
E.octupole   :setv({ track = functor( track_octupole   ) }, 'init') -- straight, (k3, k3s)
E.decapole   :setv({ track = functor( track_decapole   ) }, 'init') -- straight, (k4, k4s)
E.dodecapole :setv({ track = functor( track_dodecapole ) }, 'init') -- straight, (k5, k5s)
E.solenoid   :setv({ track = functor( track_solenoid   ) }, 'init') -- straight, ksi, (ks)
E.rfcavity   :setv({ track = functor( track_rfcavity   ) }, 'init') -- straight, (volt, freq, lag)
E.twcavity   :setv({ track = functor( notyetdone       ) }, 'init') -- straight, (volt, freq, lag)

E.wiggler    :setv({ track = functor( notyetdone       ) }, 'init') -- straight
E.elseparator:setv({ track = functor( notyetdone       ) }, 'init') -- straight

E.kicker     :setv({ track = functor( track_kicker     ) }, 'init') -- straight, (hkick, vkick)
E.hkicker    :setv({ track = functor( track_hkicker    ) }, 'init') -- straight, ( kick, hkick)
E.vkicker    :setv({ track = functor( track_vkicker    ) }, 'init') -- straight, ( kick, vkick)
E.tkicker    :setv({ track = functor( track_tkicker    ) }, 'init') -- straight, (hkick, vkick)

E.beambeam   :setv({ track = functor( notyetdone       ) }, 'init') -- thin
E.multipole  :setv({ track = functor( track_multipole  ) }, 'init') -- thin
E.rfmultipole:setv({ track = functor( notyetdone       ) }, 'init') -- thin

-- patches

E.xrotation  :setv({ track = functor( xrotation        ) }, 'init') -- patch
E.yrotation  :setv({ track = functor( yrotation        ) }, 'init') -- patch
E.srotation  :setv({ track = functor( srotation        ) }, 'init') -- patch
E.translate  :setv({ track = functor( translate        ) }, 'init') -- patch
E.changeref  :setv({ track = functor( changeref        ) }, 'init') -- patch
E.changedir  :setv({ track = functor( changedir        ) }, 'init') -- patch
E.changenrj  :setv({ track = functor( changenrj        ) }, 'init') -- patch

-- track mtable ---------------------------------------------------------------o

local function save_dat (elm, mflw, lw, islc)
  if mflw.savesel(elm, mflw, lw, islc) == false then
    return false
  end

  local name, kind in elm
  local ds, eidx, sdir, tdir, spos, turn, mtbl, relative, mapsave in mflw

  local lw = relative and lw*islc or islc<0 and -1-islc or lw*islc
  local dsw = ds*lw

  eidx = is_implicit(elm) and eidx+0.5*sdir or eidx

  for i=1,mflw.npar do
    local id, x, px, y, py, t, pt in mflw[i]
    local M
    if is_tpsa(x) then
      x,px,y,py,t,pt = x:get0(),px:get0(),y:get0(),py:get0(),t:get0(),pt:get0()
      M = mapsave and (mapsave == 1 and mflw[i]:get1() or mflw[i]:copy())
    end

    -- keep order!
    mtbl = mtbl + { name, kind, spos+dsw, dsw, id,
                    x, px, y, py, t, pt, islc, turn, tdir, eidx, M }
  end
  return true
end

local function save_obs (elm, mflw, lw, islc)
  if elm:is_observed() and mflw.turn % mflw.observe == 0 then
    return save_dat(elm, mflw, lw, islc)
  end
  return false
end

local header = {
  'direction', 'observe', 'implicit', 'relative', 'misalign',
}

local function make_mtable (self, obs, ndp)
  local title, range, nturn, dir, implicit, relative, misalign, deltap, mapsave in self
  local sequ, nrow = self.sequence

  if obs > 0 then
    nrow = (nturn-1)*ndp
  else
    nrow = sequ:length_of(range, nturn)*(implicit and 2 or 1)*ndp
  end

  -- keep order!
  return mtable 'track' {
    title=title or sequ.name, type='track', header=header, reserve=nrow,
    direction=dir, observe=obs, implicit=implicit, relative=relative,
    misalign=misalign, deltap=deltap,
    {'name'}, 'kind', 's', 'l', 'id', 'x', 'px', 'y', 'py', 't', 'pt',
    'slc', 'turn', 'tdir',      -- t-direction of the tracking: sdir * seq.dir
    'idx',                      -- index of element in the sequence
    mapsave and 'M' or nil,     -- optional column to save the (da)map
  }
end

-- trace track internal actions -----------------------------------------------o

local act2str = {
  [fnone   ] = 'fnone'   , [ftrue   ] = 'ftrue'   , [ffalse] = 'ffalse',
  [save_dat] = 'save_all', [save_obs] = 'save_obs',
}

local function trace_action (mflw)
  local atentry, atslice, atexit, ataper, atsave in mflw

  local estr = act2str[atentry] or 'usrdef'
  local sstr = act2str[atslice] or 'usrdef'
  local xstr = act2str[atexit ] or 'usrdef'
  local astr = act2str[ataper ] or 'usrdef'
  local ostr = act2str[atsave ] or 'usrdef'

  trace(2, "track actions: atentry=%s, atslice=%s, atexit=%s, ataper=%s, atsave=%s",
           estr, sstr, xstr, astr, ostr)
end

-- track mflow ----------------------------------------------------------------o

local modint = {DKD=true, TKT=true}

local function make_mflow (self)
  -- check sequence
  local sequ = assert(self.sequence, "missing sequence")
  assert(is_sequence(sequ), "invalid sequence")

  -- check beam
  local beam = assert(self.beam or sequ.beam, "missing beam")
  assert(is_beam(beam), "invalid beam")

  -- build iterator (track direction)
  local range, dir, nturn in self
  local iter, state, init = sequ:siter(range, nturn, dir)

  -- saving data, build mtable
  local save, observe, implicit, relative, radiate in self
  if is_boolean(observe) then observe = observe and 1 or 0 end
  assert(is_boolean(save)    , "invalid save (boolean expected)")
  assert(is_boolean(implicit), "invalid implicit (boolean expected)")
  assert(is_boolean(relative), "invalid relative (boolean expected)")
  assert(is_integer(observe) and observe >= 0
                             , "invalid observe (positive integer expected)")

  local savesel = self:var_raw'savesel'
  assert(is_callable(savesel), "invalid savesel (callable expected)")

  -- sequence and time direction
  local edir = sequ.dir
  local tdir = dir*edir
  assert(tdir == 1 or tdir == -1, "invalid time direction (1 or -1 expected)")

  -- setup default sclicing
  local nslice in self
  local nslc = is_number(nslice) and nslice or is_iterable(nslice) and #nslice
  assert(is_integer(nslc) and nslc > 0,
         "invalid nslice (positive integer or iterable of slice weights expected)")

  -- setup default misalign
  local misalign in self
  assert(is_boolean(misalign), "invalid misalign (boolean expected)")

  -- setup deltap (number, table, vector or range)
  local deltap in self
  if is_number(deltap) then deltap = {deltap} end
  assert(is_iterable(deltap), "invalid deltap (number or iterable expected)")
  local ndp = #deltap

  -- retrieve default actions (avoid evaluation in case of functions)
  local atentry = self:var_raw 'atentry'
  local atslice = self:var_raw 'atslice'
  local atexit  = self:var_raw 'atexit'
  local ataper  = self:var_raw 'ataper'
  local atsave  = self:var_raw 'atsave'

  assert(is_callable(atentry), "invalid atentry (callable expected)")
  assert(is_callable(atslice), "invalid atslice (callable expected)")
  assert(is_callable(atexit ), "invalid atexit (callable expected)")
  assert(is_callable(ataper ), "invalid ataper (callable expected)")
  assert(is_callable(atsave ), "invalid atsave (callable expected)")

  local atslice0 = atslice

  -- chain ataper and atslice for aperture check (if not disabled)
  if ataper ~= ffalse then
    ataper = (ataper == fnone or ataper == ftrue) and
              apercheck or achain(apercheck, ataper)
    atslice = (atslice == fnone or atslice == ftrue) and achain(atbegin,ataper)
            or atslice ~= ffalse and chain(atslice, action('ataper')) or atslice
  end

  -- chain atsave, atentry, atslice and atexit to fill table (if not disabled)
  local mtbl, fill
  if save then
    mtbl = make_mtable(self, observe, ndp)

    if atsave ~= ffalse then
      fill = observe > 0 and save_obs or save_dat

      atsave = (atsave == fnone or atsave == ftrue) and
                fill or achain(fill, atsave)
      atexit = (atexit == fnone or atexit == ftrue) and atsave or
                atexit ~= ffalse and chain(atexit, atsave) or atexit
      if atentry  == ftrue then atentry = atsave end
      if atslice0 == ftrue then atslice = chain(atslice, action('atsave')) end
    end
  end

  -- totalpath
  local totalpath in self
  assert(is_boolean(totalpath), "invalid totalpath (boolean expected)")
  local T = totalpath and 1 or 0

  -- model, method
  local model, method in self
  assertf(modint[model],
          "invalid integration model %s (DKD or TKT expected)", model)
  assertf(DKD[method], "invalid integration method '%s'", method)

  -- retrieve initial conditions
  local s0, X0, R0, beta0, npart, mapdef, mapsave in self
  assert(is_number  (s0)    , "invalid s0 (number expected)")
  assert(is_mappable(X0)    , "invalid X0 (mappable expected)")
  assert(is_boolean(mapdef) or is_mappable(mapdef)
                            , "invalid mapdef (boolean or mappable expected)")
  assert(is_boolean(mapsave) or mapsave == 1
                            , "invalid mapsave (boolean or 1 expected)")
  if not is_mappable(X0[1]) then
    X0, R0, beta0 = {X0}, {R0}, {beta0}
  elseif is_nil(R0) and is_nil(beta0) then
    R0, beta0 = {}, {}
  end

  -- precedence of initial conditions
  local npar = min(npart or 1e9, #X0)
  local mflw = table.new(npar*ndp,50)

  for idp,dp in ipairs(deltap) do
    local dpt = dp2pt(dp, beam.beta)

    for i=1,npar do
      local X0i = X0[i]
      local dpt = X0i.beam and dp2pt(dp, X0i.beam.beta) or dpt
      local ii = (idp-1)*npar + i

      if is_damap(X0i) then -- copy: damap are mappable (i.e. must be first)
        mflw[ii] = X0i:copy()
        mflw[ii].id = ii
        mflw[ii].status = 'Mset'
        if dpt ~= 0 then mflw[ii]:translate{0,0,0,0,0,dpt} end
      elseif is_mappable(X0i) then -- access by indexes first for vectors
        local x  =  X0i[1] or X0i.x  or 0
        local px =  X0i[2] or X0i.px or 0
        local y  =  X0i[3] or X0i.y  or 0
        local py =  X0i[4] or X0i.py or 0
        local t  =  X0i[5] or X0i.t  or 0
        local pt = (X0i[6] or X0i.pt or 0) + dpt
        if mapdef then -- create: damap required from coordinates (and R matrix)
          mflw[ii] = damap(is_true(mapdef) and {} or mapdef[i] or mapdef)
          mflw[ii].id = ii
          mflw[ii].status = 'Rset'
          mflw[ii]:setv{x, px, y, py, t, pt}
          if        R0[i] then mflw[ii]:set1(R0[i])
          elseif beta0[i] then mflw[ii]:set1((betablk(beta0[i]))) end
          if dpt ~= 0 then mflw[ii]:translate{0,0,0,0,0,dpt} end
        else -- copy: need a table for key access (e.g. vs. vector)
          mflw[ii] = {id=ii, x=x, px=px, y=y, py=py, t=t, pt=pt+dpt, status='Xset'}
        end
      else
        errorf("invalid type of item at id=%d (coordinates or damap expected)", i)
      end
    end
  end

  -- complete mflow
  mflw.beam=beam             -- current beam
  mflw.sequ=sequ             -- current sequence
  mflw.mtbl=mtbl             -- current mtable (nil if no save)
  mflw.sdir=dir              -- s-direction of tracking
  mflw.tdir=tdir             -- t-direction of tracking
  mflw.edir=edir             -- current element direction
  mflw.eidx=init             -- current element index
  mflw.turn=1                -- current turn index

  mflw.s0=s0                 -- initial s-position (i.e. offset)
  mflw.ds=0                  -- s-length of results (signed)
  mflw.spos=0                -- s-position of results (signed)
  mflw.ndp=ndp               -- number of deltap
  mflw.npar=npar*ndp         -- number of tracked particles or damaps
  mflw.tpar=npar*ndp         -- total number of particles or damaps (i.e. #mflw)
  mflw.nslc=nslc             -- number of slices for each element (number)
  mflw.nslice=nslice         -- slices for each element (number or iterable)
  mflw.implicit=implicit     -- slice also implicit elements
  mflw.misalign=misalign     -- 0 none, 1 main, 2 +error

  mflw.save=save             -- save data
  mflw.savesel=savesel       -- save selector
  mflw.observe=observe       -- save observed elements every n turns
  mflw.relative=relative     -- save length of slices

  mflw.atentry=atentry       -- action when entering an element
  mflw.atslice=atslice       -- action after each element slices
  mflw.atexit=atexit         -- action when exiting an element
  mflw.ataper=ataper         -- action after checking for aperture
  mflw.atsave=atsave         -- action after saving in mtable

  mflw.usrdef=self.usrdef    -- user defined data

  mflw.model=model           -- default integration model
  mflw.method=method         -- default integration method
  mflw.totalpath=totalpath   -- t is the totalpath
  mflw.radiate=radiate       -- radiate at slices
  mflw.T=T                   -- cancel compensation for time of flight

  mflw.mapdef=mapdef         -- save damap definitions (for info)
  mflw.mapsave=mapsave       -- save damaps
  mflw.deltap=deltap         -- save deltaps (for info)

  mflw.ndump=0               -- dump level of damaps
  mflw.dump=fnone            -- dump damaps

  -- internal vars for track (varying states) --

  -- for processing elements
  mflw.__edat = setmetatable({
    el=0,                    -- current element length
    rho=0,                   -- current element radius
    ang=0,                   -- current element angle
    e1=0,                    -- current element pole face angle
    e2=0,                    -- current element pole face angle
    k0=0,                    -- current element strength k0
    k0s=0,                   -- current element strength k0s
    k1=0,                    -- current element strength k1
    k1s=0,                   -- current element strength k1s
    ks=0,                    -- current element strength ks
    tlt=0,                   -- current element tilt angle
    nsl=0,                   -- current element number of slices
    nmul=0,                  -- current element number of multipoles
    knl=table.new(15,0),     -- current element multipoles
    ksl=table.new(15,0),     -- current element multipoles skew
    npha=0,                  -- current element number of multiplole phases
    pnl=table.new(15,0),     -- current element multipoles phases
    psl=table.new(15,0),     -- current element multipoles shew phases
  }, {__index=mflw})

  -- for processing (thin) subelements
  mflw.__sdat = setmetatable({
    tlt=0,                   -- current subelement tilt angle
    nmul=0,                  -- current subelement number of multipoles
    knl=table.new(15,0),     -- current subelement multipoles
    ksl=table.new(15,0),     -- current subelement multipoles skew
    npha=0,                  -- current subelement number of multiplole phases
    pnl=table.new(15,0),     -- current subelement multipoles phases
    psl=table.new(15,0),     -- current subelement multipoles shew phases
  }, {__index=mflw})

  -- for processing sequence elements by nstep
  mflw.__sitr={iter=iter, state=state} -- sequence iterator state

  return mflw
end

-- track command --------------------------------------------------------------o

local _id = {} -- identity

local function exec (self)
  local mflw, mtbl

  -- retrieve or build mflw (and mtbl)
  if self.mflow then
    assert(self.mflow.__trck == _id, "invalid mflow (track mflow expected)")
    mflw = self.mflow
  else
    mflw = make_mflow(self)
    mflw.__trck = _id
  end
  mtbl = mflw.mtbl

  -- check number of element to track
  local nstep in self
  if nstep == 0 then return mtbl, mflw end

  -- retrieve information
  local s0, eidx, sequ, atentry, atexit in mflw
  local iter, state in mflw.__sitr
  local ne = #sequ

  -- debug actions setup
  if option.debug >= 2 then trace_action(mflw) end

  -- debug maps
  local mapdump in self
  if mapdump then
    mflw.ndump = mapdump == true and 1 or mapdump
    mflw.dump  = mflw.ndump > 0 and mdump or fnone
    mflw.dump1 = mflw.ndump > 1 and xdump or fnone
  end

  -- dynamic tracking
  for ei,elm,spos,ds in iter, state, eidx do
    mflw.eidx = ei ; mflw.spos = s0+spos ; mflw.ds = ds
    atentry  (elm, mflw.__edat, 0, -1)
    elm:track(     mflw.__edat       )
    atexit   (elm, mflw.__edat, 0, -2)
    mflw:dump(elm)

    -- check for particles
    if mflw.npar == 0 then break end
    -- check for end of turn
    if ei == ne then mflw.turn = mflw.turn + 1 end
    -- check remaining number of element to track
    nstep = nstep-1
    if nstep == 0 then return mtbl, mflw, ei end
  end

  return mtbl, mflw
end

local track = command 'track' {
  beam=nil,         -- beam (required or sequence.beam)                   (mflw)
  sequence=nil,     -- sequence (required)                                (mflw)
  range=nil,        -- range of tracking                                  (iter)
  dir=1,            -- s-direction of tracking (1 or -1)                  (mflw)

  s0=0,             -- initial s                                          (mflw)
  X0={0,0,0,0,0,0}, -- initial X coordinates (or damap, or list of)       (mflw)
  R0=nil,           -- initial R matrix (compagnion of X0 for damap)      (mflw)
  beta0=nil,        -- initial beta0 block to build uncoupled R0          (mflw)
  deltap=0,         -- initial deltap(s)                                  (mflw)

  mapdef=false,     -- setup for damap (true => {})                       (mflw)
  mapsave=false,    -- save damap in the mtable                           (mflw)
  mapdump=false,    -- dump X and R after each element                    (mflw)

  nturn=1,          -- number of turns                                    (iter)
  nstep=-1,         -- number of elements to track                        (iter)
  npart=nil,        -- number of particles/damaps (or #X0)                (mflw)
  nslice=1,         -- number of slice for each element                   (mflw)
  implicit=false,   -- slice implicit elements too                        (mflw)
  model='TKT',      -- model for integration ('DKD' or 'TKT')             (mflw)
  method='simple',  -- method or order for integration (1 to 8)           (mflw)
  totalpath=false,  -- 't' is the totalpath                               (mflw)
  radiate=false,    -- radiate at slices (NYI)                            (mflw)
  misalign=true,    -- consider misalignment errors                       (mflw)

  save=true,        -- create mtable and save results                     (mtbl)
  title=nil,        -- title of mtable (default seq.name)                 (mtbl)
  savesel=fnone,    -- save selector (predicate)                          (mtbl)
  relative=false,   -- save length of slices instead from element start   (mtbl)
  observe=1,        -- save only in observed elements (every n turns)     (mtbl)

  usrdef=nil,       -- user defined data attached to the mflow            (mflw)

  atentry=fnone,    -- action called when entering an element             (mflw)
  atslice=fnone,    -- action called after each element slices            (mflw)
  atexit=fnone,     -- action called when exiting an element              (mflw)
  ataper=fnone,     -- action called after checking for aperture          (mflw)
  atsave=fnone,     -- action called after saving in mtable               (mflw)

  mflow=nil,        -- mflow, exclusive with other attributes except nstep
  exec=exec,        -- command to execute upon children creation

  __attr = {        -- list of all setup attributes
    'beam', 'sequence', 'range', 'dir', 's0', 'X0', 'R0', 'beta0', 'deltap',
    'mapdef', 'mapsave', 'mapdump', 'nturn', 'nstep', 'npart', 'nslice',
    'implicit', 'model', 'method', 'totalpath', 'radiate', 'misalign', 'save',
    'title', 'relative', 'observe', 'usrdef',
    noeval = {'atentry', 'atslice', 'atexit', 'ataper', 'atsave', 'savesel'},
  }
} :set_readonly()   -- reference track command is readonly

-- end ------------------------------------------------------------------------o
return { track = track }
