--[=[
 o-----------------------------------------------------------------------------o
 |
 | Track module
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - TODO

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local element, mtable, command, damap, symint, trace            in MAD

local is_beam, is_sequence, is_boolean, is_number, is_integer, is_true,
      is_table, is_callable, is_mappable, is_tpsa, is_damap     in MAD.typeid
local fnone, ffalse, ftrue, functor, bind2st                    in MAD.gfunc
local tblcat, errorf, assertf                                   in MAD.utility

local min, max in math

-- integrator schemes ---------------------------------------------------------o

local thickonly                                                 in MAD.symint

-- dynamic maps ---------------------------------------------------------------o

local drift, rbend_drift, quad_drift, solenoid_drift,
      polar_drift, sbend_drift, combi_drift                     in MAD.dynmap

local kick, rbend_kick, quad_kick, rfcavity_kick,
      polar_kick, sbend_kick, combi_kick                        in MAD.dynmap

local fringe, polar_fringe, solenoid_fringe                     in MAD.dynmap

local xrotation, yrotation, srotation, translate,
      changeref, changedir, changenrj                           in MAD.dynmap

-- strengths and phases -------------------------------------------------------o

local function get_mult (elm, m)
  local knl, dknl = elm.knl or {}, elm.dknl or {}
  local ksl, dksl = elm.ksl or {}, elm.dksl or {}
  local nmul = max(#knl, #ksl, #dknl, #dksl)

  if nmul >= 1 then
    for i=1,nmul do
      m.knl[i] = (knl[i] or 0) + (dknl[i] or 0)
      m.ksl[i] = (ksl[i] or 0) + (dksl[i] or 0)
    end
  else
    m.knl[1], m.ksl[1], m.knl[2] = 0, 0, 0
  end
  m.nmul = nmul
end

local function get_phas (elm, m)
  local pnl, dpnl = elm.pnl or {}, elm.dpnl or {}
  local psl, dpsl = elm.psl or {}, elm.dpsl or {}
  local npha = max(#pnl, #psl, #dpnl, #dpsl)

  for i=1,npha do
    m.pnl[i] = (pnl[i] or 0) + (dpnl[i] or 0)
    m.psl[i] = (psl[i] or 0) + (dpsl[i] or 0)
  end
  m.npha = npha
end

-- sub element tracking -------------------------------------------------------o

local function subtrack_drift (elm, mflw)
  error("NYI")
end

local function subtrack_thick (elm, mflw)
  error("NYI")
end

-- kinds ----------------------------------------------------------------------o

local function track_thin (elm, mflw)
  get_mult (elm, mflw)
  if mflw.nmul == 0 then return end

  local sdir in mflw

  changeref(elm, mflw,  sdir)
       kick(elm, mflw,   1  )
  changeref(elm, mflw, -sdir)
end

local function track_drift (elm, mflw)
  if #elm ~= 0 then subtrack_drift(elm, mflw) end

  local sdir in mflw

  changeref(elm, mflw,  sdir)
  thickonly(elm, mflw,   1  , drift, nil)
  changeref(elm, mflw, -sdir)
end

-- local drift_sabac, quad_kick_sabac, quad_corr_sabac in MAD.dynmap

local function track_thick (elm, mflw)
  if #elm ~= 0 then subtrack_thick(elm, mflw) end

  get_mult(elm, mflw)
--  if mflw.nmul == 0 then return end

  local sdir   in mflw
  -- TODO
  changeref(elm, mflw,  sdir)
  thickonly(elm, mflw,   1  , drift, nil)
  changeref(elm, mflw, -sdir)
end

local function track_sbend (elm, mflw)
  -- sbend_drift, polar_kick, sbend_fringe
end

local function track_combined (elm, mflw)
  -- combined_drift, combined_kick, sbend_fringe
end

local function track_rbend (elm, mflw)
  -- rbend_drift, rfcavity_kick, straight_fringe
end

local function track_quadrupole (elm, mflw)
  -- quad_drift, quad_kick, straight_fringe

--  changeref(elm, mflw,  sdir)
--   fringe(elm, mflw,  sdir)
     integr(elm, mflw,   1  , drift, kick) -- , quad_corr_sabac)
--   fringe(elm, mflw, -sdir)
--  changeref(elm, mflw, -sdir)
end

local function track_solenoid (elm, mflw)
  -- solenoid_drift, rfcavity_kick, solenoid_fringe
end

local function track_rfcavity (elm, mflw)
  -- solenoid_drift, rfcavity_kick, rfcavity_fringe
end

local function track_twcavity (elm, mflw)
  -- twcavity_drift, twcavity_kick, twcavity_fringe
end

-- load maps into elements ----------------------------------------------------o

local invalid = \e ->
  errorf("invalid track element %s of kind %s with length %s",
          e.name, e.kind, e.l)

local E = element

-- warning: class protection set by alt. nolookup object model can be BYPASSED
--          because classes are modified before any use of 'track' attribute
--          by any children at the time of module loading...

-- kind maps

E. thin_element.track = functor( track_thin  )
E.drift_element.track = functor( track_drift )
E.thick_element.track = functor( track_thick )
E.specl_element.track = functor( invalid     ) -- avoid missing definition
E.patch_element.track = functor( invalid     ) -- avoid missing definition
E.extra_element.track = functor( invalid     ) -- forbidden in track

-- specialized maps

-- E.sbend     .track = functor( track_sbend      ) -- polar   , k0
-- E.combined  .track = functor( track_combined   ) -- polar   , k0+k1
-- E.rbend     .track = functor( track_rbend      ) -- straight, k0
-- E.quadrupole.track = functor( track_quadrupole ) -- straight, k0+k1
-- E.solenoid  .track = functor( track_solenoid   ) -- straight, ks+ksi
-- E.rfcavity  .track = functor( track_rfcavity   )
-- E.twcavity  .track = functor( track_twcavity   )

-- special maps

E.marker   .track = functor( fnone     )
E.xrotation.track = functor( xrotation )
E.yrotation.track = functor( yrotation )
E.srotation.track = functor( srotation )
E.translate.track = functor( translate )
E.changeref.track = functor( changeref )
E.changedir.track = functor( changedir )
E.changenrj.track = functor( changenrj )

-- track mtable ---------------------------------------------------------------o

local function save_dat (elm, mflw, lw, slc)
  local name, kind in elm
  local npar, ds, tdir, spos, turn, mtbl, atsave, relative, mapsave in mflw

  lw = relative and lw*max(0,min(1,slc)) or slc<0 and 1 or lw*slc
  local dsw = ds*lw

  for i=1,npar do
    local id, x, px, y, py, t, pt in mflw[i]
    local damap
    if is_tpsa(x) then
      x,px,y,py,t,pt = x:get0(),px:get0(),y:get0(),py:get0(),t:get0(),pt:get0()
      damap = mapsave and mflw[i]:copy()
    end

    -- keep order!
    mtbl = mtbl + { name, kind, spos+dsw, dsw, id,
                    x, px, y, py, t, pt, slc, turn, tdir, damap }
  end
  -- user action
  atsave(elm, mflw, lw, slc)
end

local function save_imp (elm, mflw, lw, slc)
  if not elm:is_implicit() then
    save_dat(elm, mflw, lw, slc)
  end
end

local function save_obs (elm, mflw, lw, slc)
  if elm:is_observed() and mflw.turn % mflw.observe == 0 then
    save_dat(elm, mflw, lw, slc)
  end
end

local function save_act (uact, save, elm, mflw, lw, slc)
  if uact(elm, mflw, lw, slc) then
     save(elm, mflw, lw, slc)
  end
end

local act2str = {
  [fnone   ] = 'fnone'   , [ftrue   ] = 'ftrue'   , [ffalse  ] = 'ffalse',
  [save_dat] = 'save_all', [save_imp] = 'save_imp', [save_obs] = 'save_obs',
  [save_act] = 'save_act',
}

local function debug_action(atentry, atslice, atexit)
  local estr = act2str[atentry] or 'user defined'
  local sstr = act2str[atslice] or 'user defined'
  local xstr = act2str[atexit ] or 'user defined'
  trace(2, "track actions: atentry=%s, atslice=%s, atexit=%s", estr, sstr, xstr)
end

local header = {
  'direction', 'observe', 'implicit', 'relative',
}

local function make_mtable (self, obs)
  local title, range, nturn, dir, implicit, relative, mapsave in self
  local sequ, nrow = self.sequence

  if obs > 0 then
    nrow = nturn-1
  else
    nrow = sequ:length_of(range, nturn)*(implicit and 2 or 1)
  end

  -- keep order!
  return mtable 'track' {
    title=title or sequ.name, type='track', header=header, reserve=nrow,
    direction=dir, observe=obs, implicit=implicit, relative=relative,
    {'name'}, 'kind', 's', 'l', 'id', 'x', 'px', 'y', 'py', 't', 'pt',
    'slc', 'turn', 'tdir',     -- t-direction of the tracking: sdir * seq.dir
    mapsave and 'damap' or nil -- optional column to save the damap
  }
end

-- track mflow ----------------------------------------------------------------o

local function make_mflow (self)
  -- check beam
  local beam = assert(self.beam, "missing beam")
  assert(is_beam(beam), "invalid beam")

  -- check sequence
  local sequ = assert(self.sequence, "missing sequence")
  assert(is_sequence(sequ), "invalid sequence")

  -- build iterator
  local range, dir, nturn in self
  local iter, state, init = sequ:siter(range, nturn, dir)

  -- saving data, build mtable
  local save, observe, implicit, relative in self
  local fill, mtbl = fnone
  if is_boolean(observe) then observe = observe and 1 or 0 end
  assert(is_boolean(save)    , "invalid save (boolean expected)")
  assert(is_boolean(implicit), "invalid implicit (boolean expected)")
  assert(is_boolean(relative), "invalid relative (boolean expected)")
  assert(is_integer(observe) and observe >= 0
                             , "invalid observe (positive integer expected)")
  if save then
    mtbl = make_mtable(self, observe)
    fill = observe  >  0    and save_obs or
           implicit ~= true and save_imp or save_dat
  end

  -- time direction
  local tdir = dir*sequ.dir
  assert(tdir == 1 or tdir == -1, "invalid time direction (1 or -1 expected)")

  -- setup default sclicing
  local nslice in self
  assert(is_integer(nslice) and nslice > 0,
                                "invalid nslice (positive integer expected)")

  -- retrieve default actions (avoid evaluation in case of functions)
  local atentry = self:var_raw 'atentry'
  local atslice = self:var_raw 'atslice'
  local atexit  = self:var_raw 'atexit'
  local atsave  = self:var_raw 'atsave'

  assert(is_callable(atentry), "invalid atentry (callable expected)")
  assert(is_callable(atslice), "invalid atslice (callable expected)")
  assert(is_callable(atexit ), "invalid atexit (callable expected)")
  assert(is_callable(atsave ), "invalid atsave (callable expected)")

  -- wrap atentry, atslice and atexit to fill table (if needed)
  if save then
    if atentry ~= fnone and atentry ~= ffalse then
      atentry = atentry == ftrue and fill or bind2st(save_act, atentry, fill)
    end
    if atslice ~= fnone and atslice ~= ffalse then
      atslice = atslice == ftrue and fill or bind2st(save_act, atslice, fill)
    end
    if atexit  ~= fnone and atexit  ~= ffalse then
      atexit  = atexit  == ftrue and fill or bind2st(save_act, atexit , fill)
    end
  end

  -- totalpath
  local totalpath in self
  assert(is_boolean(totalpath), "invalid totalpath (boolean expected)")
  local T = totalpath and 1 or 0

  -- method
  local method in self
  local integr = symint[method]
  assertf(is_callable(integr), "invalid integration method '%s'", method)

  -- retrieve initial conditions
  local s0, X0, R0, mapdef, mapsave in self
  assert(is_number  (s0)    , "invalid s0 (number expected)")
  assert(is_mappable(X0)    , "invalid X0 (mappable expected)")
  assert(is_boolean(mapdef) or is_mappable(mapdef)
                            , "invalid mapdef (boolean or mappable expected)")
  assert(is_boolean(mapsave), "invalid mapsave (boolean expected)")
  if not is_mappable(X0[1]) then X0, R0 = {X0}, {R0} end

  -- precedence of initial conditions
  local npar = #X0
  local mflw = table.new(npar,50)

  for i=1,npar do
    mflw[i] = X0[i] -- default is to reuse!

    if is_damap(X0[i]) then -- damap are mappable (i.e. must be first)
      mflw[i].id = X0[i].id or i
    elseif is_mappable(X0[i]) then -- access by indexes first for vectors
      local id =             X0[i].id or i
      local x  = X0[i][1] or X0[i].x  or 0
      local px = X0[i][2] or X0[i].px or 0
      local y  = X0[i][3] or X0[i].y  or 0
      local py = X0[i][4] or X0[i].py or 0
      local t  = X0[i][5] or X0[i].t  or 0
      local pt = X0[i][6] or X0[i].pt or 0
      if mapdef then -- replace: damap required from coordinates (and R matrix)
        mflw[i] = damap(is_true(mapdef) and {} or mapdef[i] or mapdef)
        mflw[i].id = id
        mflw[i]:set0{x, px, y, py, t, pt}
        if R0[i] then mflw[i]:set1(R0[i]) end
      elseif is_table(mflw[i]) then -- reuse: fill table
        mflw[i].id,
        mflw[i].x, mflw[i].px,
        mflw[i].y, mflw[i].py,
        mflw[i].t, mflw[i].pt = id, x, px, y, py, t, pt
      else -- replace: need a table for key access (e.g. vector)
        mflw[i] = {id=id, x=x, px=px, y=y, py=py, t=t, pt=pt}
      end
    else
      errorf("invalid type of item at id=%d (coordinates or damap expected)", i)
    end
  end

  -- complete mflow
  mflw.beam=beam             -- current beam
  mflw.sequ=sequ             -- current sequence
  mflw.mtbl=mtbl             -- current mtable (nil if no save)
  mflw.sdir=dir              -- s-direction of tracking
  mflw.tdir=tdir             -- t-direction of tracking
  mflw.eidx=init             -- current element index
  mflw.turn=1                -- current turn index

  mflw.s0=s0                 -- initial s-position (i.e. offset)
  mflw.ds=nil                -- s-length of results (signed)
  mflw.spos=nil              -- s-position of results (signed)
  mflw.npos=nil              -- position in slices 'first', nil, 'last'
  mflw.npar=npar             -- number of particles or damaps (i.e. #mflw)
  mflw.nslc=nslice           -- number of slice for each element

  mflw.save=save             -- save data
  mflw.observe=observe       -- save observed elements every n turns
  mflw.implicit=implicit     -- save also implicit elements
  mflw.relative=relative     -- save length of slices

  mflw.atentry=atentry       -- action when entering an element
  mflw.atslice=atslice       -- action after each element slices
  mflw.atexit =atexit        -- action when exiting an element
  mflw.atsave =atsave        -- action when saving a row in mtable

  mflw.integr=integr         -- default integrator
  mflw.totalpath=totalpath   -- t is the totalpath
  mflw.T=T                   -- cancel compensation for time of flight

  mflw.mapdef=mapdef         -- save damap definitions (for info)
  mflw.mapsave=mapsave       -- save damaps

  -- for processing elements
  mflw.nmul=0                -- current element number of multipoles
  mflw.knl=table.new(15,0)   -- current element multipoles
  mflw.ksl=table.new(15,0)   -- current element multipoles skew
  mflw.npha=0                -- current element number of multiplole phases
  mflw.pnl=table.new(15,0)   -- current element multipoles phases
  mflw.psl=table.new(15,0)   -- current element multipoles shew phases

  -- for processing subelements
  mflw.selm=table.new(4,0)   -- subelement pre-allocated stack (TODO)

  -- internal vars for track
  mflw.__trckitr={iter=iter, state=state} -- iterator and iteraror state

  return mflw
end

-- track command --------------------------------------------------------------o

local _id = {} -- identity

local function exec (self)
  local mflw, mtbl

  -- retrieve or build mflw (and mtbl)
  if self.mflow then
    assert(self.mflow.__trck == _id, "invalid mflow (track mflow expected)")
    mflw = self.mflow
  else
    mflw = make_mflow(self)
    mflw.__trck = _id
  end
  mtbl = mflw.mtbl

  -- check number of element to track
  local nstep in self
  if nstep == 0 then return mtbl, mflw end

  -- retrieve information
  local s0, eidx, sequ, atentry, atexit in mflw
  local iter, state in mflw.__trckitr
  local ne = #sequ

  -- debug actions setup
  if MAD.option.debug >= 2 then
    debug_action(atentry, mflw.atslice, atexit)
  end

  -- dynamic tracking
  for ei,elm,spos,ds in iter, state, eidx do
    mflw.eidx = ei ; mflw.spos = s0+spos ; mflw.ds = ds
    atentry  (elm, mflw, 0,  0)
    elm:track(     mflw       )
    atexit   (elm, mflw, 0, -1)

    -- check for end of turn
    if ei == ne then mflw.turn = mflw.turn + 1 end
    -- check remaining number of element to track
    nstep = nstep-1
    if nstep == 0 then return mtbl, mflw, ei end
  end

  return mtbl, mflw
end

local _na -- not applicable (see survey)

local track = command 'track' {
  beam=nil,         -- beam (required)                                    (mflw)
  sequence=nil,     -- sequence (required)                                (mflw)
  range=nil,        -- range of tracking                                  (iter)
  dir=1,            -- s-direction of tracking (1 or -1)                  (mflw)

  s0=0,             -- initial s                                          (mflw)
  X0={0,0,0,0,0,0}, -- initial X coordinates (or damap, or list of)       (mflw)

  mapdef=false,     -- setup for damap (true => {})                       (mflw)
  mapsave=false,    -- save damap in the mtable                           (mflw)
  R0=nil,           -- initial R matrix (compagnion of X0 for damap)      (mflw)

  nturn=1,          -- number of turns                                    (iter)
  nstep=-1,         -- number of elements to track                        (iter)
  nslice=1,         -- number of slice for each element                   (mflw)
  method='simple',  -- method for integration                             (mflw)
  totalpath=false,  -- 't' is the totalpath                               (mflw)

  save=true,        -- create mtable and save results                     (mtbl)
  title=nil,        -- title of mtable (default seq.name)                 (mtbl)
  implicit=true,    -- save also in implicit elements                     (mtbl)
  relative=false,   -- save length of slices instead from element start   (mtbl)
  observe=1,        -- save only in observed elements (every n turns)     (mtbl)

  atentry=fnone,    -- action called when entering an element             (mflw)
  atslice=fnone,    -- action called after each element slices            (mflw)
  atexit =ftrue,    -- action called when exiting an element              (mflw)
  atsave =fnone,    -- action called when saving a row in mtable          (mflw)

  mflow=nil,        -- mflow, exclusive with other attributes except nstep

  exec=exec,        -- command to execute upon children creation
} :set_readonly()   -- reference track command is readonly

-- end ------------------------------------------------------------------------o
return { track = track }
