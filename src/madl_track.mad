--[=[
 o-----------------------------------------------------------------------------o
 |
 | Track module
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - TODO

 o-----------------------------------------------------------------------------o
]=]

--[=[
Notes about directions and quantities:
  edir: element direction affects curvatures (edir = seq.dir).
  sdir: track direction s affects lengths    (sdir = cmd.dir).
  tdir: time direction t  affects angles     (tdir = edir x sdir).
  bdir: beam direction    affects strengths  (bdir = edir x sdir x chg).
--]=]

-- locals ---------------------------------------------------------------------o

local command, element, mtable, damap, aperture, option         in MAD

local is_nil, is_beam, is_sequence, is_boolean, is_number,
      is_integer, is_true, is_table, is_callable, is_iterable,
      is_mappable, is_tpsa, is_damap                            in MAD.typeid
local fnone, ffalse, ftrue, functor, chain, achain              in MAD.gfunc
local invfact, arc2len, sqrt, sin, cos, atan2                   in MAD.gmath
local betablk, dp2pt                                            in MAD.gphys
local atins                                                     in MAD.symint
local tblcat, errorf, assertf, printf                           in MAD.utility
local tobit                                                     in MAD.operator
local apercheck                                                 in MAD.aperture
local minlen, minang, minstr, clight, sqrt2, twopi              in MAD.constant
local is_implicit                                               in element.drift

local abs, min, max in math
local strsub = string.sub

-- constants
local minvolt = 1e-6

-- integrator schemes ---------------------------------------------------------o

local thinonly, thickonly, driftonly, DKD, MKM                     in MAD.symint

-- dynamic maps ---------------------------------------------------------------o

-- straight elements (DKD)
local strex_drift, strex_kick, strex_kickh, strex_fringe           in MAD.dynmap

-- curved elements (DKD)
local curex_drift, curex_kick             , curex_fringe           in MAD.dynmap

-- sbend (TKT)
local sbend_thick,  sbend_kick,
      sbend_thickf, sbend_kickf           , dipeg_fringe           in MAD.dynmap

-- rbend (TKT)
local rbend_thick,  rbend_kick                                     in MAD.dynmap

-- quadrupole (TKT)
local quad_thick,  quad_kick,
      quad_thicks, quad_kicks,
      quad_thickh, quad_kickh                                      in MAD.dynmap

-- solenoid (always TKT)
local solen_thick                                                  in MAD.dynmap

-- rfcavity
local rfcav_kick, rfcav_kickn             , rfcav_fringe           in MAD.dynmap

-- patches
local xrotation, yrotation, srotation, translate,
      changeref, changedir, changenrj, misalign                    in MAD.dynmap

-- debug ----------------------------------------------------------------------o

local shtfmt = "% -.6e  % -.6e  % -.6e  % -.6e  % -.6e  % -.6e "
local lngfmt = "% -.16e  % -.16e  % -.16e  % -.16e  % -.16e  % -.16e "
local mapfmt = lngfmt -- shtfmt

local nodump = {marker=true}

--[[ Unix command to retrieve madump=2 values in a matrix
./mad script_dump.mad | \
  awk 'BEGIN{printf("MAD.matrix{")} END{printf("}")}
  /@@/{printf("{");for(i=4;i<=NF;i++)printf("%s, ",$i);printf("},\n")}'
--]]

local function mdump (mflw, elm, str_)
  if str_ and mflw.ndump <= 1 then return end

  if is_number(elm) then
    printf("@@ %-15s %-15s ", '  "', str_ or '')
  else
    if nodump[elm.kind] then return end
    printf("@@ %-15s %-15s ", elm.name, str_ or 'exit')
  end

  if mflw.npar == 0 then io.write("no particle found\n") return end

  local X, R = mflw[1]

  if is_damap(X) then
    X, R = X:get0(), X:get1()
    printf(mapfmt, X[1], X[2], X[3], X[4], X[5], X[6])
  else
    printf(mapfmt, X.x, X.px, X.y, X.py, X.t, X.pt)
  end

  if R then
    for i=1,R.nrow do
      io.write(' ')
      printf(mapfmt, R:get(i,1), R:get(i,2), R:get(i,3),
                     R:get(i,4), R:get(i,5), R:get(i,6))
    end
  end
  io.write('\n')
end

local function xdump (mflw, elm, str, X)
  printf("@@ %-15s %-15s ", elm.name, str)

  if is_tpsa(X) then
    printf(mapfmt == lngfmt and "% -.16e " or "% -.6e ", X:get(1))
    printf(mapfmt, X:get(2), X:get(3), X:get(4), X:get(5), X:get(6), X:get(7))
  elseif is_number(X) then
    printf(mapfmt == lngfmt and "% -.16e " or "% -.6e ", X)
  end
  io.write('\n')
end

local function mshow (mflw)
  local show in MAD
  show(mflw)
  for i=1,#mflw do
    local m = mflw[i]
    printf("** [%d]=\n", i)
    show(m)
    if is_damap(m) then
      m:get0():print(nil,'line')
      if option.debug > 2 then m:get1():print(nil,'line') end
     end
  end
end

-- strengths and phases -------------------------------------------------------o

local function get_mult (elm, m, n)
  local knl, ksl, dknl, dksl in elm

  m.nmul = max(#knl, #ksl, #dknl, #dksl)

  for i=1,max(m.nmul,n or 0) do
    m.knl[i] = ((knl[i] or 0) + (dknl[i] or 0)) * invfact(i-1)
    m.ksl[i] = ((ksl[i] or 0) + (dksl[i] or 0)) * invfact(i-1)
  end
end

local function get_phas (elm, m, n)
  local pnl, psl, dpnl, dpsl in elm

  m.npha = max(#pnl, #psl, #dpnl, #dpsl)

  for i=1,max(m.npha,n or 0) do
    m.pnl[i] = (pnl[i] or 0) + (dpnl[i] or 0)
    m.psl[i] = (psl[i] or 0) + (dpsl[i] or 0)
  end
end

-- element tracking -----------------------------------------------------------o

local function trackelm (elm, m, track, thick, thin, fringe)
  local sdir, tlt in m
  local mis = m.misalign and misalign or fnone
  local rot = abs(tlt) >= minang and srotation or fnone

  mis   (elm, m,  sdir)
  rot   (tlt, m,  sdir)
  fringe(elm, m,  sdir)
  track (elm, m,    1 , thick, thin)
  fringe(elm, m, -sdir)
  rot   (tlt, m, -sdir)
  mis   (elm, m, -sdir)
end

local function tracksub (elm, m, track, thick, thin, fringe)
  local sdir, tlt, __sdat in m
  local mis = m.misalign and misalign or fnone
  local rot = abs(tlt) >= minang and srotation or fnone

  mis   (elm, m, sdir)
  rot   (tlt, m, sdir)
  fringe(elm, m, sdir)

  if sdir > 0 then
    local at, lw = 0
    for i=1,#elm do
      at, lw = elm[i].at, elm[i].at - at
      if abs(lw) >= minlen then -- drift
        track(elm, m, lw, thick, thin)
      end
      __sdat.clw = at
      elm[i]:track(__sdat)
    end
    lw = 1 - at
    if abs(lw) >= minlen then  -- last drift
      track(elm, m, lw, thick, thin)
    end

  else -- backtrack
    local at, lw = 1
    for i=#elm,1,-1 do
      at, lw = elm[i].at, at - elm[i].at
      if abs(lw) >= minlen then -- drift
        track(elm, m, lw, thick, thin)
      end
      __sdat.clw = at
      elm[i]:track(__sdat)
    end
    lw = at
    if abs(lw) >= minlen then -- first drift
      track(elm, m, lw, thick, thin)
    end
  end

  fringe(elm, m, -sdir)
  rot   (tlt, m, -sdir)
  mis   (elm, m, -sdir)
end

-- kinds ----------------------------------------------------------------------o

local function track_marker (elm, m)
  m.el, m.eh, m.tlt = 0, 0, 0
  thinonly(elm, m, 1, nil, fnone)
end

local function track_drift (elm, m)
  m.el, m.eh, m.tlt = m.ds, 0, 0

  if is_implicit(elm) then
    local track = m.implicit and thickonly or driftonly
    track(elm, m, 1, strex_drift)
  else
    m.tlt = elm.tilt*m.tdir
    local track = #elm == 0 and trackelm or tracksub
    local thick = abs(m.ds) >= minlen and thickonly or driftonly
    track(elm, m, thick, strex_drift, nil, fnone)
  end
end

local function track_multipole (elm, m)                                         -- to review with frs
  get_mult(elm, m)

  if m.nmul == 0 then
    return track_marker(elm, m)
  end

  local angle, tilt in elm
  local sdir, tdir in m
  m.el, m.eh, m.tlt = 0, 0, tilt*tdir

  local kick

  if not (m.ptcmodel and abs(angle) >= minang) then
    kick = strex_kick
  else
    local lrad in elm
    m.el = lrad*sdir
    kick = strex_kickh
  end

  trackelm(elm, m, thinonly, nil, kick, fnone)
end

local function track_sbend (elm, m, e1_, e2_)
  get_mult(elm, m, 3)

  local ds, tdir, nmul, knl, ksl in m
  local angle, tilt, k0, k0s, k1, k1s, k2, k2s, e1, e2 in elm
  local l = abs(ds)

  assert(l          >= minlen, "invalid sbend length (>0 expected)")
  assert(abs(angle) >= minang, "invalid sbend angle (~=0 expected)")

!  if not k0 then k0 = angle/l end -- MAD-X compatibility

  knl[1], ksl[1] = knl[1]+(k0 or 0)*l  , ksl[1]+(k0s or 0)*l
  knl[2], ksl[2] = knl[2]+(k1 or 0)*l  , ksl[2]+(k1s or 0)*l
  knl[3], ksl[3] = knl[3]+(k2 or 0)*l/2, ksl[3]+(k2s or 0)*l/2
  m.el, m.eh, m.tlt = ds, angle/ds*tdir, tilt*tdir
  m.e1, m.e2 = (e1_ or e1)*tdir, (e2_ or e2)*tdir

  if nmul < 3 then
    m.nmul = max((k2 or k2s) and 3 or (k1 or k1s) and 2 or (k0 or k0s) and 1 or 0, nmul)
  end

  local model  = elm.model  or m.model
  local method = elm.method or m.method
  local inter, thick, kick

  if model == 'DKD' then                        -- curved thin
    inter, thick, kick = DKD[method], curex_drift , curex_kick
  else -- if abs(knl[2]) < minstr then              -- curved thick
    inter, thick, kick = DKD[method], sbend_thick , sbend_kick
--  else                                          -- curved thick with focusing
--    inter, thick, kick = MKM[method], sbend_thickf, sbend_kickf
  end

  local track = #elm == 0 and trackelm or tracksub
  track(elm, m, inter, thick, kick, curex_fringe)
end

local function track_rbend (elm, m)                                             -- unchecked
  local angle, e1, e2, true_rbend in elm

  if not true_rbend then
    return track_sbend(elm, m, e1+angle/2, e2+angle/2)                          -- checked
  end
  --[[
    True RBEND:
    angle, e1 -> e2 = angle-e1
    angle, e2 -> e1 = angle-e2
    e1, e2    -> angle = e1+e2
  --]]

  get_mult(elm, m, 3)

  local ds, tdir, nmul, knl, ksl in m
  local tilt, k0, k0s, k1, k1s, k2, k2s in elm
  local l = abs(ds)

  assert(l          >= minlen, "invalid rbend length (>0 expected)")
  assert(abs(angle) >= minang, "invalid rbend angle (~=0 expected)")

  knl[1], ksl[1] = knl[1]+(k0 or 0)*l  , ksl[1]+(k0s or 0)*l
  knl[2], ksl[2] = knl[2]+(k1 or 0)*l  , ksl[2]+(k1s or 0)*l
  knl[3], ksl[3] = knl[3]+(k2 or 0)*l/2, ksl[3]+(k2s or 0)*l/2
  m.eld, m.eh, m.tlt = ds, angle/ds*tdir, tilt*tdir
  m.el, m.e1, m.e2 = arc2len(ds, angle), e1*tdir, e2*tdir

  if nmul < 3 then
    m.nmul = max((k2 or k2s) and 3 or (k1 or k1s) and 2 or (k0 or k0s) and 1 or 0, nmul)
  end

  local model  = elm.model  or m.model
  local method = elm.method or m.method
  local thick, kick

  if model == 'DKD' then
    thick, kick = strex_drift, strex_kick
  else
    thick, kick = rbend_thick, rbend_kick
  end

  local track = #elm == 0 and trackelm or tracksub
  track(elm, m, DKD[method], thick, kick, strex_fringe)
   m.eld = nil
end

local function track_quadrupole (elm, m)
  get_mult(elm, m, 2)

  local ds, edir, tdir, nmul, knl, ksl in m
  local angle, tilt, k0, k0s, k1, k1s in elm
  local l = abs(ds)

  assert(l >= minlen, "invalid quadrupole length (>0 expected)")

  knl[1], ksl[1] = knl[1]+(k0 or 0)*l, ksl[1]+(k0s or 0)*l
  knl[2], ksl[2] = knl[2]+(k1 or 0)*l, ksl[2]+(k1s or 0)*l
  m.el, m.eh, m.tlt = ds, angle/ds*tdir, tilt*tdir

  if nmul < 2 then
    m.nmul = max((k1 or k1s) and 2 or (k0 or k0s) and 1 or 0, nmul)
  end

  local model  = elm.model  or m.model
  local method = elm.method or m.method
  local no_k0a = abs(knl[1])+abs(angle) < minstr
  local no_k1  = abs(knl[2]) < minstr
  local no_k1s = abs(ksl[2]) < minstr
  local inter, thick, kick

  -- Note: MKM integrators used uniform length for the thick map
  --       hence all cos, sin, cosh, sinh could be computed here...
  if not m.ptcmodel or model ~= 'TKT' or no_k1 and no_k1s and no_k0a then
    inter, thick, kick = DKD[method], strex_drift, strex_kick
  elseif no_k1s and no_k0a then                 -- normal thick
    m.k1, m.ca, m.sa = knl[2]/ds*edir, 1, 0
    inter, thick, kick = MKM[method], quad_thick , quad_kick
  elseif no_k0a then                            -- skew thick
    local a = -0.5*atan2(ksl[2], knl[2])*tdir
    m.k1, m.ca, m.sa = sqrt(knl[2]^2 + ksl[2]^2)/ds*edir, cos(a), sin(a)
    inter, thick, kick = MKM[method], quad_thicks, quad_kicks
  else                                          -- curved thick (unchecked)
    m.k1, m.ca, m.sa = no_k1s and knl[2]/ds*edir or nil, 1, 0
    inter, thick, kick = MKM[method], quad_thickh, quad_kickh
  end

  local track = #elm == 0 and trackelm or tracksub
  track(elm, m, inter, thick, kick, strex_fringe)
  m.k1 = nil
end

local function track_strexgen (elm, m, l)
  local model  = elm.model  or m.model
  local method = elm.method or m.method
  local inter, thick, kick

  if not (m.ptcmodel and model == 'TKT' and l >= minlen) then
    inter = l < minlen and thinonly or DKD[method]
    thick, kick = strex_drift, strex_kick
  else
    inter, thick, kick = MKM[method], quad_thick, quad_kick
  end

  local track = #elm == 0 and trackelm or tracksub
  track(elm, m, inter, thick, kick, strex_fringe)
end

local function track_sextupole (elm, m)
  get_mult(elm, m, 3)

  local ds, tdir, nmul, knl, ksl in m
  local tilt, k2, k2s in elm
  local l = abs(ds)

  knl[3] = knl[3]+(k2  or 0)*l/2
  ksl[3] = ksl[3]+(k2s or 0)*l/2
  m.el, m.eh, m.tlt = ds, 0, tilt*tdir

  if nmul < 3 then
    m.nmul = max((k2 or k2s) and 3 or 0, nmul)
  end

  track_strexgen (elm, m, l)
end

local function track_octupole (elm, m)
  get_mult(elm, m, 4)

  local ds, tdir, nmul, knl, ksl in m
  local tilt, k3, k3s in elm
  local l = abs(ds)

  knl[4] = knl[4]+(k3  or 0)*l/6
  ksl[4] = ksl[4]+(k3s or 0)*l/6
  m.el, m.eh, m.tlt = ds, 0, tilt*tdir

  if nmul < 4 then
    m.nmul = max((k3 or k3s) and 4 or 0, nmul)
  end

  track_strexgen (elm, m, l)
end

local function track_decapole (elm, m)
  get_mult(elm, m, 5)

  local ds, tdir, nmul, knl, ksl in m
  local tilt, k4, k4s in elm
  local l = abs(ds)

  knl[5] = knl[5]+(k4  or 0)*l/24
  ksl[5] = ksl[5]+(k4s or 0)*l/24
  m.el, m.eh, m.tlt = ds, 0, tilt*tdir

  if nmul < 5 then
    m.nmul = max((k4 or k4s) and 5 or 0, nmul)
  end

  track_strexgen (elm, m, l)
end

local function track_dodecapole (elm, m)
  get_mult(elm, m, 6)

  local ds, tdir, nmul, knl, ksl in m
  local tilt, k5, k5s in elm
  local l = abs(ds)

  knl[6] = knl[6]+(k5  or 0)*l/120
  ksl[6] = ksl[6]+(k5s or 0)*l/120
  m.el, m.eh, m.tlt = ds, 0, tilt*tdir

  if nmul < 6 then
    m.nmul = max((k5 or k5s) and 6 or 0, nmul)
  end

  track_strexgen (elm, m, l)
end

local function track_kickgen (elm, m, hk, vk)
  get_mult(elm, m, 2)

  local ds, tdir, nmul, knl, ksl in m

  knl[1] = knl[1] - hk
  ksl[1] = ksl[1] + vk
  m.el, m.eh, m.tlt = ds, 0, elm.tilt*tdir

  if nmul == 0 and abs(knl[1])+abs(ksl[1]) >= minstr then
    m.nmul = 1
  end

  track_strexgen (elm, m, abs(ds))
end

local function track_tkicker (elm, m, hk_, vk_)
  track_kickgen(elm, m, elm.hkick, elm.vkick)
end

local function track_kicker (elm, m)
  track_kickgen(elm, m, elm.hkick+elm.chkick, elm.vkick+elm.cvkick)
end

local function track_hkicker (elm, m)
  track_kickgen(elm, m, elm.hkick+elm.chkick, 0)
end

local function track_vkicker (elm, m)
  track_kickgen(elm, m, 0, elm.vkick+elm.cvkick)
end

local function track_solenoid (elm, m)
  get_mult(elm, m)

  local ds, tdir, edir in m
  local tilt, ks, ksi in elm
  local l = abs(ds)

  assert(l >= minlen, "invalid solenoid length (>0 expected)")

  m.el, m.tlt = ds, tilt*tdir

  local ksi = ksi + ks*l
  local thick

  if abs(ksi) < minstr then
    thick = strex_drift
  else
    m.ks  = ksi/l*edir
    thick = solen_thick
  end

  local method = elm.method or m.method
  local track  = #elm == 0 and trackelm or tracksub
  track(elm, m, DKD[method], thick, strex_kick, strex_fringe)
end

local function track_rfcavity (elm, m)
  get_mult(elm, m)

  local ds, tdir in m
  local tilt, volt in elm

  m.el, m.eh, m.tlt = ds, 0, tilt*tdir

  local method = elm.method or m.method
  local inter, kick

  if not m.ptcmodel and abs(volt) < minvolt and m.nmul == 0 then
    inter, kick = abs(ds) < minlen and thinonly or thickonly, fnone
  else
    m.volt, m.freq = volt*1e-3, elm.freq*1e6
    m.lag , m.nbsl = elm.lag*twopi, elm.n_bessel
    if m.freq == 0 then
      m.freq = elm.harmon*clight*m.beam.beta/m.sequ.l
    end
    assert(m.freq > 0, "invalid rfcavity setup, (positive freq or harmon expected)")
    inter = abs(ds) < minlen and thinonly or DKD[method]
    kick = m.nmul+m.nbsl == 0 and rfcav_kick or rfcav_kickn
  end

  local track = #elm == 0 and trackelm or tracksub
  track(elm, m, inter, strex_drift, kick, rfcav_fringe)
end

-- load maps into elements ----------------------------------------------------o

local invalid = \e ->
  errorf("invalid track element %s of kind %s with length %s",
          e.name, e.kind, e.l)

local notyetdone = \e ->
  errorf("tracking element %s of kind %s with length %s not yet implemented",
          e.name, e.kind, e.l)

local E = element

-- warning: class protection set by alt. 'nolookup' object model can be BYPASSED
--          because classes are modified before any use of 'track' attribute
--          by any children at the time of module loading...

-- kind maps

E. thin_element:setvar({ track = functor( invalid      ) }, 'init') -- avoid missing definition
E.drift_element:setvar({ track = functor( track_drift  ) }, 'init')
E.thick_element:setvar({ track = functor( invalid      ) }, 'init') -- avoid missing definition
E.specl_element:setvar({ track = functor( track_marker ) }, 'init')
E.patch_element:setvar({ track = functor( invalid      ) }, 'init') -- avoid missing definition
E.extra_element:setvar({ track = functor( invalid      ) }, 'init') -- forbidden in track

-- specialized maps (invalid == NYI)

E.sbend      :setvar({ track = functor( track_sbend      ) }, 'init') -- curved  , k0, (k0s, k1, k1s, k2, k2s)
E.rbend      :setvar({ track = functor( track_rbend      ) }, 'init') -- straight, k0, (k0s, k1, k1s, k2, k2s)
E.quadrupole :setvar({ track = functor( track_quadrupole ) }, 'init') -- straight, k0, k1, (k0s, k1s, k2, k2s)
E.sextupole  :setvar({ track = functor( track_sextupole  ) }, 'init') -- straight, (k2, k2s)
E.octupole   :setvar({ track = functor( track_octupole   ) }, 'init') -- straight, (k3, k3s)
E.decapole   :setvar({ track = functor( track_decapole   ) }, 'init') -- straight, (k4, k4s)
E.dodecapole :setvar({ track = functor( track_dodecapole ) }, 'init') -- straight, (k5, k5s)
E.solenoid   :setvar({ track = functor( track_solenoid   ) }, 'init') -- straight, ksi, (ks)
E.rfcavity   :setvar({ track = functor( track_rfcavity   ) }, 'init') -- straight, volt, (freq, lag, harmon)
E.twcavity   :setvar({ track = functor( notyetdone       ) }, 'init') -- straight, volt, (freq, lag, harmon)

E.wiggler    :setvar({ track = functor( notyetdone       ) }, 'init') -- straight
E.elseparator:setvar({ track = functor( notyetdone       ) }, 'init') -- straight

E.kicker     :setvar({ track = functor( track_kicker     ) }, 'init') -- straight, (hkick, vkick)
E.hkicker    :setvar({ track = functor( track_hkicker    ) }, 'init') -- straight, ( kick, hkick)
E.vkicker    :setvar({ track = functor( track_vkicker    ) }, 'init') -- straight, ( kick, vkick)
E.tkicker    :setvar({ track = functor( track_tkicker    ) }, 'init') -- straight, (hkick, vkick)

E.beambeam   :setvar({ track = functor( notyetdone       ) }, 'init') -- thin
E.multipole  :setvar({ track = functor( track_multipole  ) }, 'init') -- thin
E.rfmultipole:setvar({ track = functor( notyetdone       ) }, 'init') -- thin

-- patches

E.xrotation  :setvar({ track = functor( xrotation        ) }, 'init') -- patch
E.yrotation  :setvar({ track = functor( yrotation        ) }, 'init') -- patch
E.srotation  :setvar({ track = functor( srotation        ) }, 'init') -- patch
E.translate  :setvar({ track = functor( translate        ) }, 'init') -- patch
E.changeref  :setvar({ track = functor( changeref        ) }, 'init') -- patch
E.changedir  :setvar({ track = functor( changedir        ) }, 'init') -- patch
E.changenrj  :setvar({ track = functor( changenrj        ) }, 'init') -- patch

-- track mtable ---------------------------------------------------------------o

local function save_dat (elm, mflw, lw, islc)
  if mflw.savesel(elm, mflw, lw, islc) == false then
    return false
  end

  local name, kind in elm
  local ds, eidx, clw, sdir, tdir, spos, turn, mtbl, mapsave in mflw

  local lw = islc<0 and -1-islc or clw
  local dsw = ds*lw

  eidx = is_implicit(elm) and eidx+0.5*sdir or eidx

  for i=1,mflw.npar do
    if mflw[i].nosave then goto continue end

    local m, M = mflw[i]
    local id, x, px, y, py, t, pt in m
    if is_damap(m) then
      x,px,y,py,t,pt = x:get0(),px:get0(),y:get0(),py:get0(),t:get0(),pt:get0()
      M = mapsave and (mapsave == 1 and m:get1() or m:copy())
    end

    -- keep order!
    mtbl = mtbl + { name, kind, spos+dsw, dsw, id,
                    x, px, y, py, t, pt, islc, turn, tdir, eidx, M }

    ::continue::
  end
  return true
end

local function save_obs (elm, mflw, lw, islc)
  if elm:is_observed() and mflw.turn % mflw.observe == 0 then
    return save_dat(elm, mflw, lw, islc)
  end
  return false
end

local header = {
  'direction', 'observe', 'implicit', 'misalign',
}

local function make_mtable (self, obs, ndp)
  local title, range, nturn, dir, implicit, misalign, deltap, mapsave in self
  local sequ, nrow = self.sequence

  if obs > 0 then
    nrow = (nturn-1)*ndp
  else
    nrow = sequ:length_of(range, nturn)*(implicit and 2 or 1)*ndp
  end

  -- keep order!
  return mtable(self.__id, {
    name=self.name, title=title or sequ.name, type='track', header=header,
    direction=dir, observe=obs, implicit=implicit, misalign=misalign,
    deltap=deltap, reserve=nrow,
    {'name'}, 'kind', 's', 'l', 'id', 'x', 'px', 'y', 'py', 't', 'pt',
    'slc', 'turn', 'tdir',      -- t-direction of the tracking: sdir * seq.dir
    'idx',                      -- index of element in the sequence
    mapsave and 'M' or nil,     -- optional column to save the (da)map
  })
end

-- reset mflow iterator (e.g. track again) ------------------------------------o

local function ireset (mflw)
  local sequ, sdir, __sitr in mflw
  local s0, range, nturn in __sitr
  local iter, state, init = sequ:siter(range, nturn, sdir)

  __sitr.iter=iter
  __sitr.state=state

  mflw.s0, mflw.ds, mflw.spos, mflw.eidx, mflw.turn = s0, 0, 0, init, 1

  return mflw
end

-- track mflow ----------------------------------------------------------------o

local modint = {DKD=true, TKT=true}

local function make_mflow (self)
  -- check sequence
  local sequ = assert(self.sequence, "missing sequence")
  assert(is_sequence(sequ), "invalid sequence")

  -- check beam
  local beam = assert(self.beam or sequ.beam, "missing beam")
  assert(is_beam(beam), "invalid beam")

  -- build iterator (track direction)
  local range, dir, nturn in self
  local iter, state, init = sequ:siter(range, nturn, dir)

  -- saving data, build mtable
  local save, observe, implicit, fringe, radiate in self
  if is_boolean(fringe ) then fringe  = fringe  and 1 or 0 end
  if is_boolean(radiate) then radiate = radiate and 1 or 0 end
  if is_boolean(observe) then observe = observe and 1 or 0 end
  assert(is_boolean(save)    , "invalid save (boolean expected)")
  assert(is_boolean(implicit), "invalid implicit (boolean expected)")
  assert(is_integer(fringe) and fringe >= 0
                             , "invalid fringe (positive integer expected)")
  assert(is_integer(radiate) and radiate >= 0
                             , "invalid radiate (positive integer expected)")
  assert(is_integer(observe) and observe >= 0
                             , "invalid observe (positive integer expected)")

  local savesel = self:var_raw 'savesel'
  assert(is_callable(savesel), "invalid savesel (callable expected)")

  -- sequence and time direction
  local edir = sequ.dir
  local tdir = dir*edir
  assert(tdir == 1 or tdir == -1, "invalid time direction (1 or -1 expected)")

  -- setup default sclicing
  local nslice = self:var_raw 'nslice'
  local nslc = is_number(nslice) and nslice or is_callable(nslice) and 1
                                            or is_iterable(nslice) and #nslice
  assert(is_integer(nslc) and nslc > 0,
         "invalid nslice (integer>0 or iterable of or generator of slice weights expected)")

  -- setup default misalign
  local misalign in self
  assert(is_boolean(misalign), "invalid misalign (boolean expected)")

  -- setup deltap (number, table, vector or range)
  local deltap in self
  if is_number(deltap) then deltap = {deltap} end
  assert(is_iterable(deltap), "invalid deltap (number or iterable expected)")
  local ndp = #deltap

  -- retrieve default actions (avoid evaluation in case of functions)
  local atentry = self:var_raw 'atentry'
  local atslice = self:var_raw 'atslice'
  local atexit  = self:var_raw 'atexit'
  local ataper  = self:var_raw 'ataper'
  local atsave  = self:var_raw 'atsave'

  assert(is_callable(atentry), "invalid atentry (callable expected)")
  assert(is_callable(atslice), "invalid atslice (callable expected)")
  assert(is_callable(atexit ), "invalid atexit (callable expected)")
  assert(is_callable(ataper ), "invalid ataper (callable expected)")
  assert(is_callable(atsave ), "invalid atsave (callable expected)")

  local mtbl
  if save then
    mtbl = make_mtable(self, observe, ndp)
  else
    atsave = ffalse
  end

  if ataper ~= ffalse then -- prepare ataper
    ataper = ataper == ftrue and apercheck or achain(apercheck, ataper)
  end

  if atsave ~= ffalse then -- prepare atsave
    local fill = observe > 0 and save_obs or save_dat
    atsave = atsave == ftrue and fill or achain(fill, atsave)
  end

  if atentry ~= ffalse then -- chain ataper to atentry
    atentry = atentry == ftrue and ataper or chain(atentry, ataper)
  end

  if atexit ~= ffalse then -- chain atsave to atexit
    atexit = atexit == ftrue and atsave or chain(atexit, atsave)
  end

  if atslice == ftrue then -- exec atsave inside body
    atslice = achain(atins, atsave)
  end

  -- totalpath
  local totalpath in self
  assert(is_boolean(totalpath), "invalid totalpath (boolean expected)")
  local T = totalpath and 0 or 1

  -- model, method
  local method, model, ptcmodel in self
  assertf(DKD[method], "invalid integration method '%s'", method)
  assertf(modint[model],
          "invalid integration model %s (DKD or TKT expected)", model)
  assert(is_boolean(ptcmodel), "invalid ptcmodel (boolean expected)")

  -- retrieve initial conditions
  local s0, X0, O0, R0, beta0, npart, mapdef, mapsave in self
  if X0 == 0 then X0 = {0,0,0,0,0,0} end
  if O0 == 0 then O0 = {0,0,0,0,0,0} end
  assert(is_number  (s0)    , "invalid s0 (number expected)")
  assert(is_mappable(X0)    , "invalid X0 (mappable expected)")
  assert(is_mappable(O0)    , "invalid O0 (mappable expected)")
  assert(is_boolean(mapdef) or is_mappable(mapdef)
                            , "invalid mapdef (boolean or mappable expected)")
  assert(is_boolean(mapsave) or mapsave == 1 -- 1 means to save only the matrix
                            , "invalid mapsave (boolean or 1 expected)")
  if not is_mappable(X0[1]) then
    X0, R0, beta0 = {X0}, {R0}, {beta0}
  elseif is_nil(R0) and is_nil(beta0) then
    R0, beta0 = {}, {}
  end

  -- create mflw
  local npar = min(npart or 1e9, #X0)
  local mflw = table.new(npar*ndp,50)
  local mdef = is_true(mapdef) and {} or mapdef

  -- reference orbit
  local x0, px0 = O0[1] or O0.x or 0, O0[2] or O0.px or 0
  local y0, py0 = O0[3] or O0.y or 0, O0[4] or O0.py or 0
  local t0, pt0 = O0[5] or O0.t or 0, O0[6] or O0.pt or 0
  local ro0 = abs(x0)+abs(px0)+abs(y0)+abs(py0)+abs(t0)+abs(pt0)

  -- precedence of initial conditions
  local ii = 0
  for j,dp in ipairs(deltap) do
    local dpt = dp2pt(dp, beam.beta)

    for i=1,npar do
      if X0[i].notrack then goto skip end -- skip this particle
      local X0i, beam = X0[i], X0[i].beam
      local dpt = beam and dp2pt(dp, beam.beta) or dpt
      ii = ii+1

      if is_damap(X0i) then -- copy: damap are mappable (i.e. must be first)
        mflw[ii] = X0i.nocopy and X0i or X0i:copy()
        if R0[i] or beta0[i] then
          mflw[ii]:setvar(X0i:get0()) -- reuse: erase orders > 0
          mflw[ii]:set1(R0[i] or betablk(beta0[i]))
        end
        if ro0 ~= 0 or dpt ~= 0 then
          mflw[ii]:translate({x0,px0,y0,py0,t0,pt0+dpt},'in')
        end
        mflw[ii].status = 'Mset'
      elseif is_mappable(X0i) then -- access by indexes first for vectors
        local x, px = X0i[1] or X0i.x or 0, X0i[2] or X0i.px or 0
        local y, py = X0i[3] or X0i.y or 0, X0i[4] or X0i.py or 0
        local t, pt = X0i[5] or X0i.t or 0, X0i[6] or X0i.pt or 0
        if mdef then -- create: damap required from coordinates (+1st order)
          mflw[ii] = damap(mdef[i] or mdef)
          mflw[ii]:setvar{x,px,y,py,t,pt}
          if R0[i] or beta0[i] then
            mflw[ii]:set1(R0[i] or betablk(beta0[i]))
          end
          if ro0 ~= 0 or dpt ~= 0 then
            mflw[ii]:translate({x0,px0,y0,py0,t0,pt0+dpt},'in')
          end
          mflw[ii].status = 'Rset'
        else -- copy: need a table for key access (e.g. vs. vector)
          mflw[ii] = {x=x0+x, px=px0+px, y=y0+y, py=py0+py, t=t0+t, pt=pt0+dpt+pt}
          mflw[ii].status = 'Xset'
        end
      else
        errorf("invalid type of item at id=%d (particle or damap expected)", i)
      end
      -- save extra information
      mflw[ii].id, mflw[ii].id0, mflw[ii].beam, mflw[ii].nocopy, mflw[ii].nosave =
               ii, ii ~= i and i or nil,  beam,      X0i.nocopy,      X0i.nosave
::skip::
    end
  end

  assert(ii == #mflw, "unexpected corrupted mflow (wrong #particles/damaps)")

  -- complete mflow
  mflw.beam=beam             -- current beam
  mflw.sequ=sequ             -- current sequence
  mflw.mtbl=mtbl             -- current mtable (nil if no save)
  mflw.sdir=dir              -- s-direction of tracking
  mflw.tdir=tdir             -- t-direction of tracking
  mflw.edir=edir             -- current element direction

  mflw.s0=s0                 -- initial s-position (i.e. offset)
  mflw.ds=0                  -- current element s-length (signed)
  mflw.spos=0                -- current element s-position (signed)
  mflw.eidx=init             -- current element index
  mflw.turn=1                -- current turn index
  mflw.nstep=-1              -- current number of remaining steps

  mflw.npar=ii               -- number of tracked particles or damaps
  mflw.tpar=ii               -- total number of particles or damaps (i.e. #mflw)
  mflw.nslc=nslc             -- minimum number of slices for all elements
  mflw.nslice=nslice         -- slices for each element (num, fun or iterable)
  mflw.deltap=deltap         -- delta p
  mflw.implicit=implicit     -- slice also implicit elements (e.g. plots)
  mflw.fringe=tobit(fringe)  -- compute fringe fields (0..7)
  mflw.radiate=radiate       -- radiate at slices
  mflw.misalign=misalign     -- 0 none, 1 main, 2 +error

  mflw.save=save             -- save data
  mflw.observe=observe       -- save observed elements every n turns
  mflw.savesel=savesel       -- save selector

  mflw.atentry=atentry       -- action called when entering an element (ataper)
  mflw.atslice=atslice       -- action called after each element slices
  mflw.atexit=atexit         -- action called when exiting an element (atsave)
  mflw.ataper=ataper         -- action called when checking aperture
  mflw.atsave=atsave         -- action called when saving in mtable

  mflw.method=method         -- default integration method
  mflw.model=model           -- default integration model
  mflw.ptcmodel=ptcmodel     -- use PTC integration model
  mflw.T=T                   -- cancel compensation for time of flight

  mflw.mapdef=mapdef         -- save damap definitions (for info)
  mflw.mapsave=mapsave       -- save damaps

  mflw.usrdef=self.usrdef    -- user defined data

  -- for debugging
  mflw.ndump=0               -- dump level of damaps
  mflw.mdump=fnone           -- dump damaps after each integration step
  mflw.xdump=fnone           -- dump damaps after each integration step
  mflw.show=mshow            -- show the mflow

  -- for processing sequence elements by nstep
  mflw.__sitr={iter=iter, state=state,          -- sequence iterator state
               s0=s0, range=range, nturn=nturn} -- sequence iterator reset
  mflw.ireset=ireset

  -- for processing elements (pre-alloc to avoid rehash)
  mflw.__edat = setmetatable({
    el=0, eh=0,               -- current element length and curvature
    e1=0, e2=0,               -- current element pole face angles
    ks=0,                     -- solenoid strength
    volt=0, freq=0, lag=0,    -- rfcavity parameters
    nsl=0,                    -- current element number of slices
    clw=0,                    -- current element cumulated length weights
    tlt=0,                    -- current element tilt angle
    nmul=0,                   -- current element number of multipoles
    knl={[0]=0},              -- current element multipoles
    ksl={[0]=0},              -- current element multipoles skew
    npha=0,                   -- current element number of multiplole phases
    pnl={[0]=0},              -- current element multipoles phases
    psl={[0]=0},              -- current element multipoles shew phases
  }, {__index=mflw})

  -- for processing (thin) subelements (pre-alloc to avoid rehash)
  mflw.__sdat = setmetatable({
    clw=0,                    -- current subelement cumulated length weights
    tlt=0,                    -- current subelement tilt angle
    nmul=0,                   -- current subelement number of multipoles
    knl={[0]=0},              -- current subelement multipoles
    ksl={[0]=0},              -- current subelement multipoles skew
    npha=0,                   -- current subelement number of multiplole phases
    pnl={[0]=0},              -- current subelement multipoles phases
    psl={[0]=0},              -- current subelement multipoles shew phases
  }, {__index=mflw})

  return mflw
end

-- track command --------------------------------------------------------------o

local _id = {} -- identity (unique)

local function exec (self)
  local mflw, mtbl

  -- retrieve or build mflw (and mtbl)
  if self.mflow then
    assert(self.mflow.__trck == _id, "invalid mflow (track mflow expected)")
    mflw = self.mflow
  else
    mflw = make_mflow(self)
    mflw.__trck = _id
  end
  mtbl = mflw.mtbl

  -- check number of elements to track
  local nstep in self
  if nstep == 0 then return mtbl, mflw end
  mflw.nstep = nstep

  -- debug maps
  local mapdump in self
  if mapdump then
    mflw.ndump = mapdump == true and 1 or mapdump
    mflw.mdump = mflw.ndump > 0 and mdump or fnone
    mflw.xdump = mflw.ndump > 1 and xdump or fnone
  end

  -- retrieve information
  local s0, eidx, sequ, atentry, atexit, __sitr, __edat in mflw
  local iter, state in __sitr
  local ne = #sequ

  -- dynamic tracking
  for ei,elm,spos,ds in iter, state, eidx do
    mflw.eidx, mflw.spos, mflw.ds, __edat.clw = ei, s0+spos, ds, 0
    atentry   (elm, __edat, 0, -1)
    elm:track (     __edat       )
    atexit    (elm, __edat, 0, -2)
    mflw.nstep = mflw.nstep-1

    -- check remaining number of elements and particles/damaps to track
    if mflw.nstep == 0 or mflw.npar == 0 then return mtbl, mflw, ei end
    -- check for end of turn
    if ei == ne then mflw.turn = mflw.turn+1 end
  end

  return mtbl, mflw
end

local track = command 'track' {
  beam=nil,         -- beam (required or sequence.beam)                   (mflw)
  sequence=nil,     -- sequence (required)                                (mflw)
  range=nil,        -- range of tracking                                  (iter)
  dir=1,            -- s-direction of tracking (1 or -1)                  (mflw)

  s0=0,             -- initial s (offset)                                 (mflw)
  X0=0,             -- initial X coordinates (or damap, or list of)       (mflw)
  O0=0,             -- initial orbit translation to apply to all X0       (mflw)
  R0=nil,           -- initial R matrix (companion of X0 for damap)       (mflw)
  beta0=nil,        -- initial beta0 block to build R0                    (mflw)
  deltap=0,         -- initial deltap(s)                                  (mflw)

  mapdef=false,     -- setup for damap (true => {})                       (mflw)
  mapsave=false,    -- save damap in the mtable                           (mflw)
  mapdump=false,    -- dump X and R after each element                    (mflw)

  nturn=1,          -- number of turns                                    (iter)
  nstep=-1,         -- number of elements to track                        (iter)
  npart=nil,        -- number of particles/damaps (or #X0)                (mflw)
  nslice=1,         -- number of slices (or weights) for each element     (mflw)
  method=2,         -- method or order for integration (1 to 8)           (mflw)
  model='TKT',      -- model for integration ('DKD' or 'TKT')             (mflw)
  ptcmodel=false,   -- use strict PTC integration models                  (mflw)
  implicit=false,   -- slice implicit elements too (e.g. plots)           (mflw)
  fringe=false,     -- activate fringe fields (0..7)                      (mflw)
  radiate=false,    -- radiate at slices (NYI)                            (mflw)
  misalign=true,    -- consider misalignment                              (mflw)
  totalpath=false,  -- 't' is the totalpath                               (mflw)

  save=true,        -- create mtable and save results                     (mtbl)
  title=nil,        -- title of mtable (default seq.name)                 (mtbl)
  observe=1,        -- save only in observed elements (every n turns)     (mtbl)
  savesel=fnone,    -- save selector (predicate)                          (mtbl)

  atentry=ftrue,    -- action called when entering an element  (ataper)   (mflw)
  atslice=fnone,    -- action called after each element slices (atsave)   (mflw)
  atexit=ftrue,     -- action called when exiting an element   (atsave)   (mflw)
  ataper=ftrue,     -- action called when checking for aperture           (mflw)
  atsave=ftrue,     -- action called when saving in mtable                (mflw)

  usrdef=nil,       -- user defined data attached to the mflow            (mflw)

  mflow=nil,        -- mflow, exclusive with other attributes except nstep
  exec=exec,        -- command to execute upon children creation

  __attr = {        -- list of all setup attributes
    'beam', 'sequence', 'range', 'dir', 's0', 'X0', 'O0', 'R0', 'beta0',
    'deltap', 'mapdef', 'mapsave', 'mapdump', 'nturn', 'nstep', 'npart',
    'method', 'model', 'ptcmodel', 'implicit', 'fringe', 'radiate', 'misalign',
    'totalpath', 'save', 'title', 'observe', 'usrdef',
    noeval = {'atentry', 'atslice', 'atexit', 'ataper', 'atsave', 'nslice',
              'savesel'},
  }
} :set_readonly()   -- reference track command is readonly

-- end ------------------------------------------------------------------------o
return { track = track }
