--[=[
 o-----------------------------------------------------------------------------o
 |
 | Track module
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - TODO

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local element, mtable, command, damap, symint, aperture, trace   in MAD

local is_beam, is_sequence, is_boolean, is_number, is_integer, is_true,
      is_table, is_callable, is_mappable, is_tpsa, is_damap      in MAD.typeid
local fnone, ffalse, ftrue, functor, chain, achain               in MAD.gfunc
local fact, sinc                                                 in MAD.gmath
local tblcat, errorf, assertf                                    in MAD.utility
local apercheck                                                  in MAD.aperture
local minlen, minang                                             in MAD.constant

local abs, min, max in math
local strsub = string.sub

-- integrator schemes ---------------------------------------------------------o

local thickonly, atend                                          in MAD.symint

-- dynamic maps ---------------------------------------------------------------o

local strex_drift, rbend_drift, quad_drift, quad_hdrift,
      polar_drift, sbend_drift, comb_drift, solenoid_drift      in MAD.dynmap

local strex_kick, rbend_kick, quad_kick, quad_hkick,
      polar_kick, sbend_kick, comb_kick, rfcavity_kick          in MAD.dynmap

local strex_fringe, polar_fringe, solenoid_fringe               in MAD.dynmap

-- sabac: TODO
local sabac_corr                                                in MAD.dynmap

-- patches
local xrotation, yrotation, srotation, translate,
      changeref, changedir, changenrj                           in MAD.dynmap

-- debug ----------------------------------------------------------------------o

local nodump = true

local function mdump(str, ...)
  if nodump then return end
  print(str, ...)
end

-- strengths and phases -------------------------------------------------------o

local function get_mult (elm, m)
  local knl, dknl = elm.knl or {}, elm.dknl or {}
  local ksl, dksl = elm.ksl or {}, elm.dksl or {}
  local nmul = max(#knl, #ksl, #dknl, #dksl)

  if nmul >= 1 then
    for i=1,nmul do
      m.knl[i] = ((knl[i] or 0) + (dknl[i] or 0)) / fact(i-1)
      m.ksl[i] = ((ksl[i] or 0) + (dksl[i] or 0)) / fact(i-1)
    end
  else
    m.knl[1], m.knl[2] = 0, 0
    m.ksl[1], m.ksl[2] = 0, 0
  end
  m.nmul = nmul
end

local function get_phas (elm, m)
  local pnl, dpnl = elm.pnl or {}, elm.dpnl or {}
  local psl, dpsl = elm.psl or {}, elm.dpsl or {}
  local npha = max(#pnl, #psl, #dpnl, #dpsl)

  for i=1,npha do
    m.pnl[i] = (pnl[i] or 0) + (dpnl[i] or 0)
    m.psl[i] = (psl[i] or 0) + (dpsl[i] or 0)
  end
  m.npha = npha
end

-- sub element tracking -------------------------------------------------------o

local function subtrack_drift (elm, mflw)
  error("NYI")
end

local function subtrack_thick (elm, mflw)
  error("NYI")
end

-- kinds ----------------------------------------------------------------------o

local function track_thin (elm, mflw)
  mdump('\ntrack_thin', elm.name, 'l=', elm.l, 'sdir=', mflw.sdir, 'tdir=', mflw.tdir, 'beta0=', mflw.beam.beta)
  get_mult(elm, mflw)
  if mflw.nmul == 0 then return end

  local l    in elm
  local sdir in mflw
  mflw.el, mflw.eld = l, l

  changeref (elm, mflw,  sdir)
  strex_kick(elm, mflw,   1  )
  changeref (elm, mflw, -sdir)
end

local function track_drift (elm, mflw)
  mdump('\ntrack_drift', elm.name, 'l=', elm.l, 'sdir=', mflw.sdir, 'tdir=', mflw.tdir, 'beta0=', mflw.beam.beta)
  local l    in elm
  local sdir in mflw
  mflw.el, mflw.eld = l, l

  changeref(elm, mflw,  sdir)
  thickonly(elm, mflw,   1  , strex_drift, nil)
  changeref(elm, mflw, -sdir)
end

local function track_sbend (elm, mflw)
  -- sbend_drift, polar_kick, sbend_fringe
  error("NYI")
end

local function track_combined (elm, mflw)
  -- combined_drift, combined_kick, sbend_fringe
  error("NYI")
end

local function track_rbend (elm, mflw)
  mdump('\ntrack_rbend', elm.name, 'mth=', mflw.method, 'l=', elm.l, 'sdir=', mflw.sdir, 'tdir=', mflw.tdir, 'beta0=', mflw.beam.beta)

  get_mult(elm, mflw)

  local sdir, nmul, knl, ksl in mflw
  local l, k0, k1, k0s, k1s in elm
  knl[1], knl[2] = knl[1]+k0 *l, knl[2]+k1 *l
  ksl[1], ksl[2] = ksl[1]+k0s*l, ksl[2]+k1s*l
  mflw.nmul = max(2,nmul) ; mflw.el, mflw.eld = l, l
  mflw.k0 = l ~= 0 and knl[1]/l or k0

  mdump('ntrack_rbend', 'el=', mflw.el, 'eld=', mflw.eld, 'k0=', mflw.k0)

  local model  = elm.model  or mflw.model
  local method = elm.method or mflw.method
  local drift, kick, corr

  if model == 'DKD' then
    drift, kick, corr = strex_drift, strex_kick, sabac_corr
  else      -- TKT
    drift, kick       = rbend_drift, rbend_kick
  end

--changeref      (elm, mflw,  sdir)
--straight_fringe(elm, mflw,  sdir)
  symint[method] (elm, mflw,   1  , drift, kick, corr)
--straight_fringe(elm, mflw, -sdir)
--changeref      (elm, mflw, -sdir)
end

local function track_quadrupole (elm, mflw)
  mdump('\ntrack_quadrupole', elm.name, 'mth=', mflw.method, 'l=', elm.l, 'sdir=', mflw.sdir, 'tdir=', mflw.tdir, 'beta0=', mflw.beam.beta)

  get_mult(elm, mflw)

  local sdir, nmul, knl, ksl in mflw
  local l, k0, k1, k0s, k1s in elm
  knl[1], knl[2] = knl[1]+k0 *l, knl[2]+k1 *l
  ksl[1], ksl[2] = ksl[1]+k0s*l, ksl[2]+k1s*l
  mflw.nmul = max(2,nmul) ; mflw.el, mflw.eld = l, l
  mflw.k1 = l ~= 0 and knl[2]/l or k1

  mdump('track_quadrupole', 'el=', mflw.el, 'eld=', mflw.eld, 'k1=', mflw.k1)

  local model  = elm.model  or mflw.model
  local method = elm.method or mflw.method
  local drift, kick, corr

  if model == 'DKD' then
    drift, kick, corr = strex_drift, strex_kick, sabac_corr
  else      -- TKT
    drift, kick = quad_drift, quad_kick
  end
-- else -- k0 ~= 0  -- TODO: ?
--   mflw.eld = l/sinc(elm.angle)
--   mflw.eh  = angle/mflw.eld
--   mflw.k0  = l ~= 0 and knl[1]/l or k0
--   drift, kick = quad_hdrift, quad_hkick
-- end

--changeref      (elm, mflw,  sdir)
--straight_fringe(elm, mflw,  sdir)
  symint[method] (elm, mflw,   1  , drift, kick, corr)
--straight_fringe(elm, mflw, -sdir)
--changeref      (elm, mflw, -sdir)
end

local function track_solenoid (elm, mflw)
  -- solenoid_drift, rfcavity_kick, solenoid_fringe
  error("NYI")
end

local function track_rfcavity (elm, mflw)
  -- solenoid_drift, rfcavity_kick, rfcavity_fringe
  error("NYI")
end

local function track_twcavity (elm, mflw)
  -- twcavity_drift, twcavity_kick, twcavity_fringe
  error("NYI")
end

-- load maps into elements ----------------------------------------------------o

local invalid = \e ->
  errorf("invalid track element %s of kind %s with length %s",
          e.name, e.kind, e.l)

local E = element

-- warning: class protection set by alt. 'nolookup' object model can be BYPASSED
--          because classes are modified before any use of 'track' attribute
--          by any children at the time of module loading...

-- kind maps

E. thin_element:setv({ track = functor( track_thin  ) }, 'init')
E.drift_element:setv({ track = functor( track_drift ) }, 'init')
E.thick_element:setv({ track = functor( invalid     ) }, 'init') -- avoid missing definition
E.specl_element:setv({ track = functor( invalid     ) }, 'init') -- avoid missing definition
E.patch_element:setv({ track = functor( invalid     ) }, 'init') -- avoid missing definition
E.extra_element:setv({ track = functor( invalid     ) }, 'init') -- forbidden in track

-- specialized maps

E.sbend     :setv({ track = functor( track_sbend      ) }, 'init') -- polar   , k0
E.combined  :setv({ track = functor( track_combined   ) }, 'init') -- polar   , k0+k1
E.rbend     :setv({ track = functor( track_rbend      ) }, 'init') -- straight, k0
E.quadrupole:setv({ track = functor( track_quadrupole ) }, 'init') -- straight, k0+k1
E.solenoid  :setv({ track = functor( track_solenoid   ) }, 'init') -- straight, ks+ksi
E.rfcavity  :setv({ track = functor( track_rfcavity   ) }, 'init')
E.twcavity  :setv({ track = functor( track_twcavity   ) }, 'init')

-- special maps

E.marker   :setv({ track = functor( fnone     ) }, 'init')
E.xrotation:setv({ track = functor( xrotation ) }, 'init')
E.yrotation:setv({ track = functor( yrotation ) }, 'init')
E.srotation:setv({ track = functor( srotation ) }, 'init')
E.translate:setv({ track = functor( translate ) }, 'init')
E.changeref:setv({ track = functor( changeref ) }, 'init')
E.changedir:setv({ track = functor( changedir ) }, 'init')
E.changenrj:setv({ track = functor( changenrj ) }, 'init')

-- track mtable ---------------------------------------------------------------o

local function save_dat (elm, mflw, lw, slc)
  local name, kind in elm
  local npar, ds, tdir, spos, turn, mtbl, atsave, relative, mapsave in mflw

  lw = relative and lw*max(0,min(1,slc)) or slc<0 and 1 or lw*slc
  local dsw = ds*lw

  for i=1,npar do
    local id, x, px, y, py, t, pt in mflw[i]
    local damap
    if is_tpsa(x) then
      x,px,y,py,t,pt = x:get0(),px:get0(),y:get0(),py:get0(),t:get0(),pt:get0()
      damap = mapsave and mflw[i]:copy()
    end

    -- keep order!
    mtbl = mtbl + { name, kind, spos+dsw, dsw, id,
                    x, px, y, py, t, pt, slc, turn, tdir, damap }
  end
  -- user action
  atsave(elm, mflw, lw, slc)
end

local function save_imp (elm, mflw, lw, slc)
  if not elm:is_implicit() then
    save_dat(elm, mflw, lw, slc)
  end
end

local function save_obs (elm, mflw, lw, slc)
  if elm:is_observed() and mflw.turn % mflw.observe == 0 then
    save_dat(elm, mflw, lw, slc)
  end
end

local header = {
  'direction', 'observe', 'implicit', 'relative',
}

local function make_mtable (self, obs)
  local title, range, nturn, dir, implicit, relative, mapsave in self
  local sequ, nrow = self.sequence

  if obs > 0 then
    nrow = nturn-1
  else
    nrow = sequ:length_of(range, nturn)*(implicit and 2 or 1)
  end

  -- keep order!
  return mtable 'track' {
    title=title or sequ.name, type='track', header=header, reserve=nrow,
    direction=dir, observe=obs, implicit=implicit, relative=relative,
    {'name'}, 'kind', 's', 'l', 'id', 'x', 'px', 'y', 'py', 't', 'pt',
    'slc', 'turn', 'tdir',     -- t-direction of the tracking: sdir * seq.dir
    mapsave and 'damap' or nil -- optional column to save the damap
  }
end

-- trace track internal actions -----------------------------------------------o

local act2str = {
  [fnone   ] = 'fnone'   , [ftrue   ] = 'ftrue'   , [ffalse  ] = 'ffalse',
  [save_dat] = 'save_all', [save_imp] = 'save_imp', [save_obs] = 'save_obs',
}

local function trace_action (mflw)
  local atentry, atslice, atexit, ataper, atsave in mflw

  local estr = act2str[atentry] or 'usrdef'
  local sstr = act2str[atslice] or 'usrdef'
  local xstr = act2str[atexit ] or 'usrdef'
  local astr = act2str[ataper ] or 'usrdef'
  local ostr = act2str[atsave ] or 'usrdef'

  trace(2, "track actions: atentry=%s, atslice=%s, atexit=%s, ataper=%s, atsave=%s",
           estr, sstr, xstr, astr, ostr)
end

-- track mflow ----------------------------------------------------------------o

local modint = {DKD=true, TKT=true}

local function make_mflow (self)
  -- check sequence
  local sequ = assert(self.sequence, "missing sequence")
  assert(is_sequence(sequ), "invalid sequence")

  -- check beam
  local beam = assert(self.beam or sequ.beam, "missing beam")
  assert(is_beam(beam), "invalid beam")

  -- build iterator
  local range, dir, nturn in self
  local iter, state, init = sequ:siter(range, nturn, dir)

  -- saving data, build mtable
  local save, observe, implicit, relative in self
  local fill, mtbl = fnone
  if is_boolean(observe) then observe = observe and 1 or 0 end
  assert(is_boolean(save)    , "invalid save (boolean expected)")
  assert(is_boolean(implicit), "invalid implicit (boolean expected)")
  assert(is_boolean(relative), "invalid relative (boolean expected)")
  assert(is_integer(observe) and observe >= 0
                             , "invalid observe (positive integer expected)")
  if save then
    mtbl = make_mtable(self, observe)
    fill = observe  >  0    and save_obs or
           implicit ~= true and save_imp or save_dat
  end

  -- time direction
  local tdir = dir*sequ.dir
  assert(tdir == 1 or tdir == -1, "invalid time direction (1 or -1 expected)")

  -- setup default sclicing
  local nslice in self
  assert(is_integer(nslice) and nslice > 0,
                                "invalid nslice (positive integer expected)")

  -- retrieve default actions (avoid evaluation in case of functions)
  local atentry = self:var_raw 'atentry'
  local atslice = self:var_raw 'atslice'
  local atexit  = self:var_raw 'atexit'
  local ataper  = self:var_raw 'ataper'
  local atsave  = self:var_raw 'atsave'

  assert(is_callable(atentry), "invalid atentry (callable expected)")
  assert(is_callable(atslice), "invalid atslice (callable expected)")
  assert(is_callable(atexit ), "invalid atexit (callable expected)")
  assert(is_callable(ataper ), "invalid ataper (callable expected)")
  assert(is_callable(atsave ), "invalid atsave (callable expected)")

  -- chain atentry, atslice and atexit to fill table (if needed)
  if save then
    if atentry ~= fnone and atentry ~= ffalse then
      atentry = atentry == ftrue and fill or achain(atentry, fill)
    end
    if atslice ~= fnone and atslice ~= ffalse then
      atslice = atslice == ftrue and fill or achain(atslice, fill)
    end
    if atexit  ~= fnone and atexit  ~= ffalse then
      atexit  = atexit  == ftrue and fill or achain(atexit , fill)
    end
  end

  -- chain ataper with atslice for aperture check (if not disabled)
  if ataper ~= fnone and ataper ~= ffalse then
    ataper  = ataper  == ftrue and apercheck or achain(ataper, apercheck)
    atslice = (atslice == fnone or atslice == ftrue) and ataper
                                             or  chain(ataper, atslice  )
  end

  -- totalpath
  local totalpath in self
  assert(is_boolean(totalpath), "invalid totalpath (boolean expected)")
  local T = totalpath and 1 or 0

  -- model, method
  local model, method in self
  assert(modint[model], "invalid integration model (DKD or TKT expected)")
  assertf(is_callable(symint[method]), "invalid integration method '%s'", method)

  -- retrieve initial conditions
  local s0, X0, R0, mapdef, mapsave in self
  assert(is_number  (s0)    , "invalid s0 (number expected)")
  assert(is_mappable(X0)    , "invalid X0 (mappable expected)")
  assert(is_boolean(mapdef) or is_mappable(mapdef)
                            , "invalid mapdef (boolean or mappable expected)")
  assert(is_boolean(mapsave), "invalid mapsave (boolean expected)")
  if not is_mappable(X0[1]) then X0, R0 = {X0}, {R0} end

  -- precedence of initial conditions
  local npar = #X0
  local mflw = table.new(npar,50)

  for i=1,npar do
    local X0i = X0[i]
    mflw[i] = X0i -- default is to reuse!

    if is_damap(X0i) then -- damap are mappable (i.e. must be first)
      mflw[i].id = X0i.id or i
    elseif is_mappable(X0i) then -- access by indexes first for vectors
      local id =           X0i.id or i
      local x  = X0i[1] or X0i.x  or 0
      local px = X0i[2] or X0i.px or 0
      local y  = X0i[3] or X0i.y  or 0
      local py = X0i[4] or X0i.py or 0
      local t  = X0i[5] or X0i.t  or 0
      local pt = X0i[6] or X0i.pt or 0
      if mapdef then -- replace: damap required from coordinates (and R matrix)
        mflw[i] = damap(is_true(mapdef) and {} or mapdef[i] or mapdef)
        mflw[i].id = id
        mflw[i]:set0{x, px, y, py, t, pt}
        if R0[i] then mflw[i]:set1(R0[i]) end
      elseif is_table(mflw[i]) then -- reuse: fill table
        mflw[i].id,
        mflw[i].x, mflw[i].px,
        mflw[i].y, mflw[i].py,
        mflw[i].t, mflw[i].pt = id, x, px, y, py, t, pt
      else -- replace: need a table for key access (e.g. vector)
        mflw[i] = {id=id, x=x, px=px, y=y, py=py, t=t, pt=pt}
      end
    else
      errorf("invalid type of item at id=%d (coordinates or damap expected)", i)
    end
  end

  -- complete mflow
  mflw.beam=beam             -- current beam
  mflw.sequ=sequ             -- current sequence
  mflw.mtbl=mtbl             -- current mtable (nil if no save)
  mflw.sdir=dir              -- s-direction of tracking
  mflw.tdir=tdir             -- t-direction of tracking
  mflw.eidx=init             -- current element index
  mflw.turn=1                -- current turn index

  mflw.s0=s0                 -- initial s-position (i.e. offset)
  mflw.ds=nil                -- s-length of results (signed)
  mflw.spos=nil              -- s-position of results (signed)
  mflw.npar=npar             -- number of tracked particles or damaps
  mflw.tpar=npar             -- total number of particles or damaps (i.e. #mflw)
  mflw.nslice=nslice         -- number of slice for each element

  mflw.save=save             -- save data
  mflw.observe=observe       -- save observed elements every n turns
  mflw.implicit=implicit     -- save also implicit elements
  mflw.relative=relative     -- save length of slices

  mflw.atentry=atentry       -- action when entering an element
  mflw.atslice=atslice       -- action after each element slices
  mflw.atexit=atexit         -- action when exiting an element
  mflw.atsave=atsave         -- action when saving a row in mtable
  mflw.ataper=ataper         -- action when checking for aperture

  mflw.usrdef=self.usrdef    -- user defined data

  mflw.model=model           -- default integration model
  mflw.method=method         -- default integration method
  mflw.totalpath=totalpath   -- t is the totalpath
  mflw.T=T                   -- cancel compensation for time of flight

  mflw.mapdef=mapdef         -- save damap definitions (for info)
  mflw.mapsave=mapsave       -- save damaps

  -- for processing elements
  mflw.el=0                  -- current element length
  mflw.eld=0                 -- current element D-shaped length (arc length)
  mflw.k0=0                  -- current element strength k0
  mflw.k1=0                  -- current element strength k1
  mflw.nmul=0                -- current element number of multipoles
  mflw.knl=table.new(15,0)   -- current element multipoles
  mflw.ksl=table.new(15,0)   -- current element multipoles skew
  mflw.npha=0                -- current element number of multiplole phases
  mflw.pnl=table.new(15,0)   -- current element multipoles phases
  mflw.psl=table.new(15,0)   -- current element multipoles shew phases

  -- for processing subelements
  mflw.selm=table.new(4,0)   -- subelement pre-allocated stack (TODO)

  -- internal vars for track
  mflw.__trckitr={iter=iter, state=state} -- iterator and iteraror state

  return mflw
end

-- track command --------------------------------------------------------------o

local _id = {} -- identity

local function exec (self)
  local mflw, mtbl

  -- retrieve or build mflw (and mtbl)
  if self.mflow then
    assert(self.mflow.__trck == _id, "invalid mflow (track mflow expected)")
    mflw = self.mflow
  else
    mflw = make_mflow(self)
    mflw.__trck = _id
  end
  mtbl = mflw.mtbl

  -- check number of element to track
  local nstep in self
  if nstep == 0 then return mtbl, mflw end

  -- retrieve information
  local s0, eidx, sequ, atentry, atexit in mflw
  local iter, state in mflw.__trckitr
  local ne = #sequ

  -- debug actions setup
  if MAD.option.debug >= 2 then trace_action(mflw) end

  -- dynamic tracking
  for ei,elm,spos,ds in iter, state, eidx do
    mflw.eidx = ei ; mflw.spos = s0+spos ; mflw.ds = ds
    atentry  (elm, mflw, 0,  0)
    elm:track(     mflw       )
    atexit   (elm, mflw, 0, -1)

    -- check for end of turn
    if ei == ne then mflw.turn = mflw.turn + 1 end
    -- check remaining number of element to track
    nstep = nstep-1
    if nstep == 0 then return mtbl, mflw, ei end
  end

  return mtbl, mflw
end

local _na -- not applicable (see survey)

local track = command 'track' {
  beam=nil,         -- beam (required or sequence.beam)                   (mflw)
  sequence=nil,     -- sequence (required)                                (mflw)
  range=nil,        -- range of tracking                                  (iter)
  dir=1,            -- s-direction of tracking (1 or -1)                  (mflw)

  s0=0,             -- initial s                                          (mflw)
  X0={0,0,0,0,0,0}, -- initial X coordinates (or damap, or list of)       (mflw)

  mapdef=false,     -- setup for damap (true => {})                       (mflw)
  mapsave=false,    -- save damap in the mtable                           (mflw)
  R0=nil,           -- initial R matrix (compagnion of X0 for damap)      (mflw)

  nturn=1,          -- number of turns                                    (iter)
  nstep=-1,         -- number of elements to track                        (iter)
  nslice=1,         -- number of slice for each element                   (mflw)
  model='TKT',      -- model for integration ('DKD' or 'TKT')             (mflw)
  method='simple',  -- method for integration                             (mflw)
  totalpath=false,  -- 't' is the totalpath                               (mflw)

  save=true,        -- create mtable and save results                     (mtbl)
  title=nil,        -- title of mtable (default seq.name)                 (mtbl)
  implicit=true,    -- save also in implicit elements                     (mtbl)
  relative=false,   -- save length of slices instead from element start   (mtbl)
  observe=1,        -- save only in observed elements (every n turns)     (mtbl)

  atentry=fnone,    -- action called when entering an element             (mflw)
  atslice=fnone,    -- action called after each element slices            (mflw)
  atexit=ftrue,     -- action called when exiting an element              (mflw)
  ataper=atend,     -- action called when checking for aperture           (mflw)
  atsave=fnone,     -- action called when saving a row in mtable          (mflw)

  usrdef=nil,       -- user defined data attached to the mflow            (mflw)

  mflow=nil,        -- mflow, exclusive with other attributes except nstep

  exec=exec,        -- command to execute upon children creation
} :set_readonly()   -- reference track command is readonly

-- end ------------------------------------------------------------------------o
return { track = track }
