--[=[
 o-----------------------------------------------------------------------------o
 |
 | Track module
 |
 | Methodical Accelerator Design - Copyright CERN 2015+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
            I. Shreyber, irina.tecker at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - TODO

 o-----------------------------------------------------------------------------o
]=]

local M = { __help = {} }

-- help -----------------------------------------------------------------------o

M.__help.self = [=[
NAME
  track -- track

SYNOPSIS
  TODO

DESCRIPTION
  The module track provides...

RETURN VALUES
  The track command

SEE ALSO
  element, sequence, survey
]=]

M.__help['References Track'] = [=[
[1] A. Wolski, "Beam Dynamics in High Energy Particle Accelerators".
[2] E. Forest, "Beam Dynamics, A New Attitude and Framework".
[3] E. Forest, "Introduction to Polymorphic Tracking Code", KEK report 2002-3.
]=]

-- locals ---------------------------------------------------------------------o

local Command, element, sequence, table                                in MAD
local is_nil, is_number, vector, matrix, is_matrix                     in MAD
local abs, sin, cos, sqrt, max, tan, atan, arcsin, arccos              in MAD

local minlen, minang = 1e-14, 1e-14

--[[ beta corresponds to beam particle=proton, energy=450
proton: m0c^2=0.938GeV
gamma = E_beam/E_rest= E_beam/m0c^2
beta  = sqrt(1 - (1/gamma)^2)
gamma = 1/sqrt(1 - beta^2)
]]
local beta    = 0.99999782628282619
local betai   = 1/beta
local gamma   = 1/(sqrt(1 - beta^2))
local bg2     = beta^2*gamma^2

--[[ METHOD:
2 - 2nd order, 1 kick per integration step
4 - Ruth-Neri-Yoshida 4th order, 3 kicks per step
6 - Yoshida 6th order, 7kicks per step
]]
local method = 2

--[[MODEL: 1 drift-kick-drift, 2 - matrix-kick-matrix)
]]
local model      = 1

local nst        = 1
local direction  = 1
local charge     = 1
local total_path = 0

--[[TODO:
-Add charge, direction, mass(?)

-Deltap (recalculation of pt)

- KICKEX: how to read properly strength of thick element (i.e. convert
k1,k1s, k2 etc to knl,ksl)

-????KICKEX: add a check for thick element that there is only one strength,
i.e. quad only has k1 and not k0, k2 or???
]]
-- add patch, rotation + translation

-- implementation -------------------------------------------------------------o

local function factorial(n)
  if n < 1 then return 1 end
  for i=2,n-1 do n = n*i end
  return n
end

local function invalid_track (elem, m)
  error(string.format("invalid element %s of kind %s with length %s",
                      elem.name, elem.kind, l and tostring(l) or 0))
end

M.__help['Track drift'] = [[
  [1] Drift Space, ch. 3.1, p.86 eq.(3.13-3.18)
  [2] p.353, ch. 12.1.3
  [3] PTC, Function DRIFTR in file Sh_def_kind.f90, same formula as [1]
]]

local function drift_track (m, l) -- TODO: check numerical stability
  if l >= minlen then
    local x, px, y, py, t, pt in m
    local l_pz = l/sqrt(1 + 2*betai*pt + pt^2 - px^2 - py^2)
    print("V before a drift = ", m.x, m.px, m.y, m.py, m.t, m.pt)
    m.x = x + px * l_pz
    m.y = y + py * l_pz
    m.t = t + (betai + pt)*l_pz - l*betai*(1-total_path)
  end
  print("V after a drift = ", m.x, m.px, m.y, m.py, m.t, m.pt)
end

M.__help['Track mutlipole'] = [[
  [2] p.354, ch. 12.1.3 
  [3] PTC, Function KICKEXR in file Sh_def_kind.f90)
]]

local function kick_mult(elem, m, l)
	-- KICKTR 
  local knl, ksl = elem.knl or {}, elem.ksl or {}
  local nmul = max(#knl, #ksl)

  io.write('tracking kick for ', elem.name, ' (l=', l, ', nmul=', nmul, ')\n')

 if nmul == 0 then return end

  local x, px, y, py, t, pt in m -- t, pt not used
  local by = knl[nmul] or 0
  local bx = ksl[nmul] or 0
  local byt

  for j=nmul-1,1,-1 do
    byt = x * by - y * bx + (knl[j] or 0)
    bx  = y * by + x * bx + (ksl[j] or 0)
    by  = byt
  end
  m.px = px - by + (knl[1] or 0)
  m.py = py + bx

  -- LD: missing t adjustment? (see slides)
  if knl[1] ~= 0 or ksl[1] ~= 0 then
	local pz = sqrt(1 + 2*betai*m.pt + m.pt^2)
    m.t = t + ((knl[1] or 0) * x - (ksl[1] or 0) * y) * (betai + pt) / pz
  end

end

M.__help['Track kick'] = [[
  [2] p. 72, Section K.4.2, 
  [3] PTC, Function KICKEXR in file Sh_def_kind.f90)
]]

local function kick_track(elem, m, l)
  local knl, ksl = elem.knl or {}, elem.ksl or {}
  local dkn, dks = elem.dkn or {}, elem.dks or {}
  local kn = { elem.k0 , elem.k1 , elem.k2 , elem.k3  }
  local ks = { elem.k0s, elem.k1s, elem.k2s, elem.k3s }
  local nmul = max(#knl, #ksl, #dkn, #dks, #kn, #ks)

  io.write('tracking kick for ', elem.name, ' (l=', l, ', nmul=', nmul, ')\n')

 if nmul == 0 then return end

  for i=1,nmul do
    kn[i] = (kn[i] or 0) + (knl[i] or 0) + (dkn[i] or 0)
    ks[i] = (ks[i] or 0) + (ksl[i] or 0) + (dks[i] or 0)
  end

  local x, px, y, py, t, pt in m -- t, pt not used
  local fact = 1/factorial(nmul-1)
  local by = (kn[nmul]*fact) or 0
  local bx = (ks[nmul]*fact) or 0
  local byt

  for j=nmul-1,1,-1 do
    byt = x * by - y * bx + (kn[j] or 0)
    bx  = y * by + x * bx + (ks[j] or 0)
    by  = byt
  end

  m.px = px - by*l + (kn[1] or 0)
  m.py = py + bx*l
 

  -- LD: missing t adjustment? (see slides)
  if kn[1] ~= 0 or ks[1] ~= 0 then
	local pz = sqrt(1 + 2*betai*m.pt + m.pt^2)
    m.t = t + ((kn[1] or 0) * l * x - (ksl[1] or 0) * l * y) * (betai + pt) / pz
  end

end

M.__help['Track curved drift-kick'] = [[
  [2] p.358, ch. 12.2.2 Drift-Kick Split, drift in polar coordinates
  [3] p. 76, PTC, Function SPROTR in file Sh_def_kind.f90)
]]


local function sprot(elem, m, l) -- check numerical statibility
  local l, k0 in elem

  -- bizarre: angle ~= 0 and k0 == 0 is not a drift...
  if is_nil(k0) or k0 == 0 then -- to check...
    drift_track(m, l) return
  end

  local x, px, y, py, t, pt in m
  local a, r, pz, ptt
  local xt, pxt, yt, tt = 0, 0, 0, 0

  a   = l * k0  -- incorrect in MAD-NG, angle ~= l/k0
  r   = 1 / k0  -- rho, curvature of what 1/angle or 1/(k0*l) ?
  pz  = sqrt(1 + 2 * betai*pt + pt^2 - px^2 - py^2)
  ptt = 1 - px * tan(a) / pz

  xt  = (x + r * (2 *  sin(a/2)^2 + px * sin(a)/pz)) / cos(a) / ptt
  pxt = px * cos(a) + sin(a) * pz
  yt  = y + py * (x + r) * tan(a) / pz/ ptt
  tt  = t + (x + r) * tan(a) * (betai + pt) / pz / ptt - l * betai

  m.x  = xt
  m.px = pxt
  m.y  = yt
  m.t  = tt
end

M.__help['Track curved kick '] = [[
  [2] p.358, ch. 12.2.2 Drift-Kick Split, kick in polar coordinates
  [3] p. 76, PTC, Function SKICK in file Sh_def_kind.f90)

]]

local function skick(elem, m, l)
  local l, k0, k0s in elem
  k0, k0s = k0 or 0, k0s or 0

  local x, px, y, py, t, pt in m -- y, t not used
  local b1 = -k0  * (1 + k0 *x)
  local b2 =  k0s * (1 + k0s*x)
  local dir = direction * charge -- from map

--TO ADD    call GETELECTRIC(EL,E,phi,B,VM,X,kick=my_true)

  m.px = px + l * dir * b1
  m.py = py + l * dir * b2
end

M.__help['Track curved bend-kick'] = [[
  [2] p.360, ch. 12.2.3 Matrix(Bend)-Kick Split
  [3] p. 76, PTC, Function SPAR in file Sh_def_kind.f90)
]]

local function spar(elem, m, l)

--[[
model = 2 (matrix-kick-matrix)
local l_n = l/nstp
YL = DH = l/2/nstp
DL = DD = l/2/nstp
D = l
?????to check if DD and DH is the same!!!

    SPAR(elem, m, l_n/2)
    KICKEX (elem, m, l_n/2)
   SPAR(elem, m, l_n/2)
  --- SPARr(EL,YL,DL,X,k)
    local dir=direction*charge
      pz = sqrt(1 + 2 * pt*betai + pt^2-px^2 - py^2)

       XN(2)=px - l_N/2*DIR*bn1 --(EL%BN(1))
       ???BN(1) ---

       ptt = sqrt(1 + 2.0 * pt*betai+pt^2-py^2)

       pzs = sqrt(1 + 2 * pt*betai + pt^2 - XN(2)^2 - py^2)

       XN(1) = x + (pzs - pz) / dir / bn1

      ????  XN(3)=(arcsin(px) / ptt - arcsin(XN(2)) / ptt) / dir / b1

       XN(6)= t + XN(3) * (betai + pt ) -  l_n*betai

       XN(3)= y + px * XN(3)

       X(1)=XN(1)
       X(2)=XN(2)
       X(3)=XN(3)
       X(6)=XN(6)
]]
end
M.__help['Track matrix-kick'] = [[
  [2] p.354, ch. 12.1.4 Matrix-Kick Split
  [3] p. 75, Section K.4.7, PTC, Function INTEP_TKTF in file Sh_def_kind.f90)
]]

--[[local function TKTF()
PUSHTKT7(l/2) (matrix in  GETMAT7)
KICKPATH(l/2)
KICKTKT(L)
KICKPATH(l/2)
PUSHTKT7(l/2)

end
]]

local function thin_track (elem, m)
  local l in elem -- l is zero in a thin lens...
  drift_track(      m, l/2)
    kick_mult(elem, m, l  )
  drift_track(      m, l/2)
  return l
end

M.__help['Track straight'] = [[
  [2] p.352, ch. 12.1
      DKD: ch 12.1.3, p. 353  
      MKM: ch 12.1.4, p.354
  [3] DKD: p. 72, Section K.4.2,
           PTC, Function INTER_STREX in file Sh_def_kind.f90)
      MKM: p. 75, Section K.4.7,
           PTC, Function INTER_TKTF  in file Sh_def_kind.f90)
]]

local function strait_track (elem, m)
  local l in elem

  io.write('STRAIT_TRACK: for ', elem.name, ' (l=', elem.l,', nstep=', nst, ')\n')

  local l_n = l/nst

  if (method == 2) then
    for i = 1, nst do
      print("slice =", i)
      drift_track(      m, l_n/2)
       kick_track(elem, m, l_n  )
      drift_track(      m, l_n/2)
    end
  end

  if (method == 4) then
    --[[FD1, FD2, FK1, and FK2 are constants related to
the fourth order Ruth-Yoshida integrator.
FD1 = FD4 =  1/2*(2-2^(1/3)              = 0.67560359597982889
FD2 = FD3 =  (1-2^(1/3))/(2*(2-2^(1/3))) = -0.17560359597982886
FK1 = FK3 =  1/(2-2^(1/3))               = 1.3512071919596578
FK2 =     =  -2^(1/3)/(2-2^(1/3))         = -1.7024143839193155

]]

    local fd1, fd2 = 0.67560359597982889, -0.17560359597982886
    local fk1, fk2 = 1.3512071919596578 , -1.7024143839193155
    for i = 1 , nst do
      print("slice =", i)
      drift_track(      m, l_n * fd1)
       kick_track(elem, m, l_n * fk1)
      drift_track(      m, l_n * fd2)
       kick_track(elem, m, l_n * fk2)
      drift_track(      m, l_n * fd2)
       kick_track(elem, m, l_n * fk1)
      drift_track(      m, l_n * fd1)
    end
  end

  return l
end

M.__help['Track curved'] = [[
  [2] p.357, ch. 12.2
  [3] PTC, p. 76, Section K.4.9,Function INTER_TEAPOT in file Sh_def_kind.f90)
]]

local function curved_track (elem, m)
  local l in elem

  if l < minlen then
    error('invalid thick element length: ' .. elem.name)
  end

  io.write('CURVED_TRACK: for ', elem.name, ' (l=', elem.l,', nstep=', nst, ')\n')

  local l_n = l/nst

  for i=1,nst do
    print("slice =", i)
    sprot(elem, m, l_n/2)
    skick(elem, m, l_n  )
    sprot(elem, m, l_n/2)
  end
  return l
end

-- load track maps into elements

element.element       :set_function { track = invalid_track }
element.thin_element  :set_function { track =    thin_track }
element.strait_element:set_function { track =  strait_track }
element.curved_element:set_function { track =  curved_track }

-- track command helpers

local function fill_table (tbl, name, kind, m, s, l)
  -- order!
  tbl = tbl + { name, kind, s, l, m.x, m.px, m.y, m.py, m.t, m.pt }
end

local function make_map (self)
  local X0 in self
  local x  = X0.x  or X0[1] or 0
  local px = X0.px or X0[2] or 0
  local y  = X0.y  or X0[3] or 0
  local py = X0.py or X0[4] or 0
  local t  = X0.t  or X0[5] or 0
  local pt = X0.pt or X0[6] or 0
  return { x=x, px=px, y=y, py=py, t=t, pt=pt }
end

local function make_table (self)
  local sequence, drift in self
  local n = (drift == true and 2 or 1) * #sequence
  return table 'track' {
    type='track', title=sequence.name, direction=sequence.direction,
    {'name'}, 'kind', 's', 'length', 'x', 'px', 'y', 'py', 't', 'pt',
  } : reserve(n)
end

-- track command exec
-- track { sequence=seq, X0={x,px,y,py,t,pt},
--         drift=logical, range={start,stop}, refer='exit' }
--> table

local function __exec (self)
  local seq = assert(self.sequence, "missing sequence")
  assert(seq.kind == 'sequence' and seq.is_sequence == true, "invalid sequence")

  local map = make_map(self)
  local tbl = make_table(self)
  local drift in self
  local s_pos in seq

  -- affine tracking
  local n, end_pos = -1, 0
  for i=1,#seq do
    local elem, s = seq[i], s_pos[i]
    local ds = s - end_pos

    -- implicit drift
    if ds < 0 then
      error(string.format("negative implicit drift %s in %s['%s'] at %s",
            tostring(ds), seq:get_key('name'), elem.name, tostring(s)))
    elseif ds >= minlen then
      drift_track(map, ds)
      end_pos, n = s, n+1
      if drift then fill_table(tbl, 'DRIFT_'..n, 'drift', map, end_pos, ds) end
    end

    -- sequence element
    ds = elem:track(map)
    end_pos = end_pos + ds
    fill_table(tbl, elem.name, elem.kind, map, end_pos, ds)
  end

  return tbl
end

-- track command template

local track = Command 'track' {
  -- default options
  X0={0,0,0,0,0,0}, drift=true, range={1,-1},
  noexec=true,                        -- make template only
} : set_metamethod({ __exec = __exec }, true) : set_readonly()

-- end ------------------------------------------------------------------------o
return {
  track = track,

  __help = M.__help,
}
