--[=[
 o-----------------------------------------------------------------------------o
 |
 | Track module
 |
 | Methodical Accelerator Design - Copyright CERN 2015+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: I. Shreyber, irina.tecker at cern.ch
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - TODO

 o-----------------------------------------------------------------------------o
]=]

local M = { __help = {} }

-- help -----------------------------------------------------------------------o

M.__help.self = [=[
NAME
  track -- track

SYNOPSIS
  TODO

DESCRIPTION
  The module track provides...

RETURN VALUES
  The track command

SEE ALSO
  element, sequence, survey
]=]

M.__help['References Track'] = [=[
[Wolski14]  A. Wolski,  "Beam Dynamics in High Energy Particle Accelerators".
[Forest98]  E. Forest,  "Beam Dynamics, A New Attitude and Framework".
[Forest02]  E. Forest,  "Introduction to Polymorphic Tracking Code",
            KEK report 2002-3.
[Yoshida90] H. Yoshida, "Construction of higher order symplectic integrators",
            Phys.Let A, Volume 150, number 5,6,7.
]=]

M.__help['Track drift'] = [[
  [1] Drift Space, ch. 3.1, p.86 eq.(3.13-3.18)
  [2] p.353, ch. 12.1.3
  [3] PTC, Function DRIFTR in file Sh_def_kind.f90, same formula as [1]
]]

M.__help['Track straight'] = [[
  [2] p.352, ch. 12.1
      DKD: ch 12.1.3, p. 353
      MKM: ch 12.1.4, p.354
  [3] DKD: p. 72, Section K.4.2,
           PTC, Function INTER_STREX in file Sh_def_kind.f90)
      MKM: p. 75, Section K.4.7,
           PTC, Function INTER_TKTF  in file Sh_def_kind.f90)
]]

M.__help['Track curved'] = [[
  [2] p.357, ch. 12.2
  [3] PTC, p. 76, Section K.4.9,Function INTER_TEAPOT in file Sh_def_kind.f90)
]]

M.__help['Track pushtkt'] = [[
[2] MKM: p. 75, Section K.4.7,
[3] PTC, Function INTER_TKTF  in file Sh_def_kind.f90)
]]

M.__help['Track straight matrix-kick'] = [[
  [2] p.358, ch. 12.2.2 Drift-Kick Split, drift in polar coordinates
  [3] p. 76, PTC, Function SPROTR in file Sh_def_kind.f90)
]]

M.__help['Track curved drift-kick'] = [[
  [2] p.358, ch. 12.2.2 Drift-Kick Split, drift in polar coordinates
  [3] p. 76, PTC, Function SPROTR in file Sh_def_kind.f90)
]]

M.__help['Track curved kick '] = [[
  [2] p.358, ch. 12.2.2 Drift-Kick Split, kick in polar coordinates
  [3] p. 76, PTC, Function SKICK in file Sh_def_kind.f90)

]]

M.__help['Track kick'] = [[
  [2] p.354, ch. 12.1.3
  [2] p. 72, Section K.4.2,
  [3] PTC, Function KICKEXR in file Sh_def_kind.f90)
  [3] PTC, Function KICKR in file Sh_def_kind.f90)
]]

--[[TODO:
-Add charge, direction, mass(?)
-Deltap (recalculation of pt)
- KICKEX: how to read properly strength of thick element (i.e. convert
k1,k1s, k2 etc to knl,ksl)
-????KICKEX: add a check for thick element that there is only one strength,
i.e. quad only has k1 and not k0, k2 or???
]]
-- add patch, rotation + translation

--[[ METHOD:
2 - 2nd order, 1 kick per integration step
4 - Ruth-Neri-Yoshida 4th order, 3 kicks per step
6 - Yoshida 6th order, 7kicks per step
]]

--[[
  frame of integration:

 angle == 0 and k0 ~= 0 rbend on (??? rbend with the straight ref. frame ??)
 STRAIGHT REF. FRAME FOR RBEND : STREX

 angle == 0 and k0 == 0 rbend off (i.e. drift)
 DRIFT-TRACK

 angle ~= 0 and k0 ~= 0 sbend on
 SBEND, default RBEND:  TEAPOT

 angle ~= 0 and k0 == 0 sbend off( useless, what kind of element is this? broken sbend?)
       <=> rbend with l = l_arc and k0 = angle, what about errors?

 angle == 0 abd k0 == 0 but k[n] ~= 0: straight magnet
 DKD (model = 1 ): STREX ; MKM (model = 2): TKTF
]]

-- locals ---------------------------------------------------------------------o

local Command, element, sequence, table, load                      in MAD
local is_nil, is_number, vector, matrix, is_matrix                 in MAD
local abs, sqrt, max, sin, cos, tan, asin, acos, atan, sinc        in MAD

local minlen, minang = 1e-14, 1e-14

-- From beam:
-- local energy  = 450 -- GeV
-- local beta    = 0.99999782628282619
-- local betai   = 1/beta
-- local gamma   = 1/(sqrt(1 - beta^2))
-- local bg2     = beta^2*gamma^2 = gamma^2-1 (better)
-- local charge  = 1

-- from map or element
-- local method     = 2 -- index/key of integrate table
-- local nst        = 1
-- local total_path = 0
-- local direction  = 1 -- copied from sequence

-- helpers --------------------------------------------------------------------o

-- todo: move to gmath? do binomial?
local fact = { [0]=1, 1 }
(function() for i=2,25 do fact[i] = fact[i-1]*i end end)()

-- implementation -------------------------------------------------------------o

local function invalid_track (elem, m)
  error(string.format("invalid element %s of kind %s with length %s",
                      elem.name, elem.kind, l and tostring(l) or 0))
end

-- Drift general exact strait

local function drift_track (_, m, l) -- DRIFT
--  io.write('tracking drift for l=', l, '\n')
  local beta_inv = 1/m.beam.beta
  local x, px, y, py, t, pt, T in m
  m.pz = sqrt(1 + 2*beta_inv*pt + pt^2 - px^2 - py^2)
  m.x = x + px * l/m.pz
  m.y = y + py * l/m.pz
  m.t = t + (beta_inv + pt)*l/m.pz - (1-T)*l*beta_inv
end

-- Kick general exact strait

local function kick_track(elem, m, l) -- KICKR (TODO: ks)
--  io.write('tracking kick for ', elem.name, ' (l=', l, ')\n')
  local beta, charge in m.beam
  local dir in m
  local beta_inv = 1/beta
  local knl , ksl  = elem.knl  or {}, elem.ksl  or {}
  local dknl, dksl = elem.dknl or {}, elem.dksl or {}
  local kn = { elem.k0  or 0, elem.k1  or 0, elem.k2  or 0, elem.k3  }
  local ks = { elem.k0s or 0, elem.k1s or 0, elem.k2s or 0, elem.k3s }
  local nmul = max(#knl, #ksl, #dknl, #dksl, #kn, #ks)

  for i=1,nmul do
    m.knl[i] = (kn[i] or 0)*l + (knl[i] or 0) + (dknl[i] or 0)
    m.ksl[i] = (ks[i] or 0)*l + (ksl[i] or 0) + (dksl[i] or 0)
  end

  local x, px, y, py, t, pt in m
  m.by = m.knl[nmul] -- * fact[nmul-1]
  m.bx = m.ksl[nmul] -- * fact[nmul-1]

  local byt
  for i=nmul-1,1,-1 do
      byt = x * m.by - y * m.bx + m.knl[i]
    m.bx  = y * m.by + x * m.bx + m.ksl[i]
    m.by  = byt
  end

  local kn0l = (elem.k0  or 0)*l + (m.knl[1] or 0)
  local ks0l = (elem.k0s or 0)*l + (m.ksl[1] or 0)

  m.px = px - m.by + kn0l
  m.py = py + m.bx

--  io.write('m.bx=', m.bx, ', m.by=', m.by, '\n')

  if kn0l ~= 0 or ks0l ~= 0 then
    m.pz = sqrt(1 + 2*beta_inv*pt + pt^2)
    m.t  = m.t + (kn0l*x - ks0l*y) * (beta_inv+pt)/m.pz
  end
end

-- Drift general exact curved

local function sdrift_track (elem, m, l)
--  io.write('tracking sdrift for l=', l, '\n')
  local l, angle, k0 in elem

  if is_nil(k0) or k0 == 0 then -- to check...
    return drift_track(nil, m, l)
  end

  local beta_inv = 1/m.beam.beta
  local x, px, y, py, t, pt, T in m

  local rho = l/angle
  local sa, ca, ta, sa_2 = sin(angle), cos(angle), tan(angle), sin(angle/2)

  m.pz  = sqrt(1 + 2*beta_inv*pt + pt^2 - px^2 - py^2)
  m.ptt = 1 - ta*px / m.pz
  m.xr  = x+rho

  m.xt  = (x + 4*rho*sa_2^2 + px*sa/m.pz) / (ca*m.ptt)
  m.pxt = ca*px + sa*m.pz
  m.yt  = y + ta*py*m.xr / (m.pz*m.ptt)
  m.tt  = t + ta*m.xr * (beta_inv+pt) / (m.pz*m.ptt) - (1-T)*l*beta_inv

  m.x  = m.xt
  m.px = m.pxt
  m.y  = m.yt
  m.t  = m.tt
end

-- Kick general exact curved (TODO)

local function skick_track (elem, m, l) -- TODO
--  io.write('tracking skick for ', elem.name, ' (l=', l, ')\n')
  local l, k0, k0s in elem
  k0, k0s = k0 or 0, k0s or 0

--  io.write("charge=", m.beam.charge, ", dir=", m.dir, '\n')

  local x, px, y, py, t, pt, dir in m -- y, t not used
  local charge in m.beam
  local b1 = -k0  * (1 + k0 *x)
  local b2 =  k0s * (1 + k0s*x)
  local bv = dir * charge -- from map

--TO ADD    call GETELECTRIC(EL,E,phi,B,VM,X,kick=my_true)

  m.px = px + l * bv * b1
  m.py = py + l * bv * b2
end

-- integrator schemes ---------------------------------------------------------o

local integrate = require 'madl_sympint'

-- frame kinds ----------------------------------------------------------------o

local function thin_track (elem, m)
--  io.write('THIN_TRACK: for ', elem.name, ' (l=', elem.l, ')\n')
  local l in elem

  if l >= minlen then
    error("invalid thin element length (too long): " .. elem.name)
  end

  -- TODO: k0?
  kick_track(elem, m, l) -- kick_mult(elem, m, _) optimized for l=0?
  return l
end

local function strait_track (elem, m) -- e.g. rbend
--  io.write('STRAIT_TRACK: for ', elem.name, ' (l=', elem.l,')\n')
  local l, angle, k0, method in elem

  if abs(angle) >= minang then
    error("invalid strait element angle (too curved): " .. elem.name)
--  elseif l < minlen then
--    error("invalid strait element length (too short): " .. elem.name)
  end

  -- TODO: boundary elements

  local l_field = l
  if k0 and k0 ~= 0 then
    l_field = l/sinc(k0*l/2) -- TO BE CHECKED
  end

  integrate[method or m.method](elem, m, l_field, drift_track, kick_track)
  return l
end

local function curved_track (elem, m) -- e.g. sbend
--  io.write('CURVED_TRACK: for ', elem.name, ' (l=', elem.l,')\n')
  local l, angle, k0, method in elem

  if abs(angle) < minang then
    error("invalid curved element angle (too strait): " .. elem.name)
  elseif l < minlen then
    error("invalid curved element length (too short): " .. elem.name)
  end

  -- TODO: boundary elements?

  local l_field = l
  if k0 and k0 ~= 0 then
    l_field = l/sinc((k0*l-angle)/2)  -- TO BE CHECKED
  end

  integrate[method or m.method](elem, m, l_field, sdrift_track, skick_track)
  return l
end

-- load track maps into elements

element.element       :set_function { track = invalid_track }
element.thin_element  :set_function { track =    thin_track }
element.strait_element:set_function { track =  strait_track }
element.curved_element:set_function { track =  curved_track }

-- track command --------------------------------------------------------------o

local _trck = {}

local function make_table (self, length)
  local sequence, drift, save in self
  if save == 'none' then return nil end
  local name, direction in sequence
  local nrow = (drift == true and 2 or 1) * length

  return table 'track' {
    type='track', title=name, direction=direction,
    {'name'}, 'kind', 's', 'l',
    'x', 'px', 'y', 'py', 't', 'pt',
    [_trck]=_trck,
  } : reserve(nrow)
end

local function fill_table (tbl, name, kind, m, s, l)
  -- keep order!
  tbl = tbl + { name, kind, s, l, m.x, m.px, m.y, m.py, m.t, m.pt }
end

local function make_map (self, start)
  local x, px, y, py, t, pt, X0, sequence in self

  x  = x  or X0.x  or X0[1]
  px = px or X0.px or X0[2]
  y  = y  or X0.y  or X0[3]
  py = py or X0.py or X0[4]
  t  = t  or X0.t  or X0[5]
  pt = pt or X0.pt or X0[6]

  local s_pos, direction in sequence
  local nst, method, total_path in self
  local T = total_path == true and 1 or 0

  return { x=x, px=px, y=y, py=py, t=t, pt=pt,
           knl={}, ksl={},
           dir=direction, nst=nst, method=method, T=T,
           s_ini=s_pos[start], s_end=s_pos[start], ndrift=-1, [_trck]=_trck }
end

-- track command exec
-- track { sequence=seq, X0={x,px,y,py,t,pt},
--         range={start,stop}, save='exit'|'none',
--         drift=logical, method='teapot', total_path=logical,
--         table=tbl, map=map  }
-- return the table and the map
-- alternate initial conditions (higher precedence):
-- x=x, px=px, y=y, py=py, t=t, pt=pt
-- X0={x=x, px=px, y=y, py=py, t=t, pt=pt}

local function exec (self)
  local seq = assert(self.sequence, "missing sequence")
  assert(seq.kind == 'sequence' and seq.is_sequence == true, "invalid sequence")
  local beam = assert(self.beam or seq.beam, "missing beam")
  assert(beam.kind == 'beam', "invalid beam")

  local start, stop = seq:range_index (self.range)
  local tbl = self.table or make_table(self, stop-start+1)
  local map = self.map   or make_map  (self, start)
  assert(map[_trck] == _trck, "invalid track map"  )
  assert(is_nil(tbl) or tbl[_trck] == _trck, "invalid track table")

  local s_ini, s_end, ndrift in map
  local drift, save in self
  local s_pos in seq

  drift = drift == true and save or 'none'
  map.beam = beam

  -- dynamic tracking
  for i=start,stop do
    local elem, s = seq[i], s_pos[i]
    local name, kind, angle, tilt, nstep in elem
    local ds = s - s_end

    -- implicit drift
    if ds >= minlen then
      drift_track(nil, map, ds)
      s_end, ndrift = s, ndrift+1

      if drift == 'exit' and elem:is_selected() then
        fill_table(tbl, 'DRIFT_'..ndrift, 'drift', map, s_end-s_ini, ds)
      end
    elseif ds < 0 then
      error(string.format("negative implicit drift %s in %s['%s'] at %s",
            tostring(ds), seq.name, name, tostring(s)))
    end

    -- sequence element
    ds = elem:track(map)
    s_end = s + ds

    if save == 'exit' and elem:is_selected() then
      fill_table(tbl, name, kind, map, s_end-s_ini, ds)
    end
  end
  map.s_end, map.ndrift = s_end, ndrift

  return tbl, map
end

-- track command template

local track = Command 'track' {
  -- default options
  X0={0,0,0,0,0,0}, range={1,-1},
  drift=true, save='exit', nst=1, method='teapot', total_path=false,
  exec=exec,
} :set_readonly()

MAD.utility.defhelp(M) -- todo: per function help -> 'track'

-- end ------------------------------------------------------------------------o
return {
  track = track,

  __help = M.__help,
}
