--[=[
 o-----------------------------------------------------------------------------o
 |
 | Track module
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: I. Shreyber, irina.tecker at cern.ch
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - TODO

 o-----------------------------------------------------------------------------o
]=]

-- help -----------------------------------------------------------------------o

local __help = {}
__help.track = [=[
NAME
  track -- track

SYNOPSIS
  TODO

DESCRIPTION
  The module track provides...

RETURN VALUES
  The track command

SEE ALSO
  element, sequence, survey
]=]

__help['track: references'] = [=[
[Wolski14]    A. Wolski, "Beam Dynamics in High Energy Particle Accelerators".
[Forest98]    E. Forest, "Beam Dynamics, A New Attitude and Framework".
[Forest02]    E. Forest, "Introduction to Polymorphic Tracking Code",
              KEK report 2002-3.
[Forest06]    E. Forest, "Geometric Integration for Particle Accelerators",
              J.Phys. A, Math.Gen. 39 (2006) 5321-5377.
[Ripken95]    K. Heinemann, G. Ripken, and F. Schmidt. "Construction of
              Nonlinear Symplectic Six-dimensional Thin-lens Maps by
              Exponentiation", Technical Report 95-189, DESY, 1995.
[SixTrack]    R. De. Maria et al., "SixTrack Physics Manual", CERN,
              http://cern.ch/SixTrack/doc/physics_manual/sixphys.pdf, Sep. 2016.
[Yoshida90]   H. Yoshida, "Construction of higher order symplectic integrators",
              Phys.Let. A, Volume 150, number 5,6,7.
[Burkhardt13] H. Burkhardt et al., "Improved Teapot Method and Tracking with
              Thick Quadrupoles for the LHC and its Upgrade", IPAC 2013.
[MADX-PTC]    MAD-X PTC Code, rev. 6099
]=]

__help['track: straight maps'] = [[
  [2] p.352, ch. 12.1
      DKD: ch 12.1.3, p. 353
      MKM: ch 12.1.4, p.354
  [3] DKD: p. 72, Section K.4.2,
           PTC, Function INTER_STREX in file Sh_def_kind.f90)
      MKM: p. 75, Section K.4.7,
           PTC, Function INTER_TKTF  in file Sh_def_kind.f90)
]]

__help['track: curved maps'] = [[
  [2] p.357, ch. 12.2
  [3] PTC, p. 76, Section K.4.9,Function INTER_TEAPOT in file Sh_def_kind.f90)
]]

__help['track: pushtkt'] = [[
[2] MKM: p. 75, Section K.4.7,
[3] PTC, Function INTER_TKTF  in file Sh_def_kind.f90)
]]

__help['track: straight matrix-kick'] = [[
  [2] p.358, ch. 12.2.2 Drift-Kick Split, drift in polar coordinates
  [3] p. 76, PTC, Function SPROTR in file Sh_def_kind.f90)
]]

--[[TODO:
-Add charge, direction, mass(?)
-Deltap (recalculation of pt)
- KICKEX: how to read properly strength of thick element (i.e. convert
k1,k1s, k2 etc to knl,ksl)
-????KICKEX: add a check for thick element that there is only one strength,
i.e. quad only has k1 and not k0, k2 or???
]]
-- add patch, rotation + translation

--[[ METHOD:
2 - 2nd order, 1 kick per integration step
4 - Ruth-Neri-Yoshida 4th order, 3 kicks per step
6 - Yoshida 6th order, 7kicks per step
]]

--[[
  frame of integration:

 angle == 0 and k0 ~= 0 rbend on (??? rbend with the straight ref. frame ??)
 STRAIGHT REF. FRAME FOR RBEND : STREX

 angle == 0 and k0 == 0 rbend off (i.e. drift)
 DRIFT-TRACK

 angle ~= 0 and k0 ~= 0 sbend on
 SBEND, default RBEND:  TEAPOT

 angle ~= 0 and k0 == 0 sbend off( useless, what kind of element is this? broken sbend?)
       <=> rbend with l = l_arc and k0 = angle, what about errors?

 angle == 0 abd k0 == 0 but k[n] ~= 0: straight magnet
 DKD (model = 1 ): STREX ; MKM (model = 2): TKTF
]]

--[[
  Documentation....

  List of top level frame_track methods:
  --------------------------------------

  - patch_frame
  - drift_frame
    + l = 0 -> sub element only
  - thin_frame ignore l and angle but not patch and tilt
    + nmul == 0 and #elm > 0 -> drift_frame
  - thick_frames (all-in-one)
    + l = 0 -> thin_frame
    + nmul = 0 -> drift_frame
    + l > 0 and nmul > 0 and angle == 0 -> strait_frame
    + l > 0 and nmul > 0 and angle ~= 0 -> curved_frame

  - do we need curved and strait differenciation?
  - decompose entry and exit in more steps?
  - do we perform radiation and aperture check after each nst?
    + what about thin lens?

  - no more guards about lengths in thin, allow to store non-zero length
  - no more guards about lengths in thick, allow to be compatible with madx
  - check for angle and length to switch between integration schemes
]]

__help['track: classification of drift-kick models versus thick elements'] = [=[
              drift kind        kick kind        fringe kind
- angle=0
  rbend:      rbend_drift       cavity_kick      straight_fringe
  quad:       quad_drift        quad_kick        straight_fringe
  solenoid:   solenoid_drift    cavity_kick      solenoid_fringe
  rfcav:      solenoid_drift    cavity_kick      cavity_fringe
  twcav:      twcav_drift       twcav_kick       twcavity_fringe
- angle~=0
  sbend:      sbend_drift       polar_kick       sbend_fringe       sbend
  combined:   combined_drift    combined_kick    sbend_fringe       KTK, TKTF

- precedences (ordered):
  if ks ~=0   solenoid_drift    cavity_kick      solenoid_fringe
  if ang~=0   sbend_drift       polar_kick       sbend_fringe
  if k0 ~=0   rbend_drift       cavity_kick      straight_fringe
  if v  ~=0   rbend_drift       cavity_kick      cavity_fringe
  if k1 ~=0   quad_drift        quad_kick        straight_fringe
  default     straight_drift    straight_kick    straight_fringe

- fallbacks:
  straight_drift(l=0)      => (none)
  rbend_drift(k0=0)        => straight_drift
  solenoid_drift(ks=0)     => rbend_drift
  quad_drift(k1=0)         => rbend_drift

  polar_drift(ang=0)       => rbend_drift (*)
  sbend_drift(k0=ang)      => polar_drift
  combined_drift(k1=0)     => sbend_drift

  straight_kick(nmul=0)    => (none)
  cavity_kick(v=0)         => straight_kick
  quad_kick(k1=0)          => cavity_kick (*)

  polar_kick(ang=0)        => straight_kick (*)
  combined_kick(k1=0)      => polar_kick

  straight_fringe(nmul=0)  => (none)
  solenoid_fringe(ks=0)    => straight_fringe (*)
  cavity_fringe(v=0)       => straight_fringe (*)
  sbend_fringe(ang=0)      => straight_fringe (*)

  (*) fallbacks that should never occur according to precedences

- remarks:
  + fringe kind should be driven by element kind and not by precedence
    is cavity_fringe(v=0) equivalent to straight_fringe?
  + quad_drift  = quad matrix (linear!)
    quad_kick   = ?? (straight + k1*(nonlinear - linear))
  + no solution for combined ang and/or k0 and ks ??
]=]

__help['track: drift-kick models and references'] = [=[
                   PTC KIND                         References
straight_drift:    DRIFT{R/P}
rbend_drift:       SPAR{R/P}
solenoid_drift:    KICK_SOL{R/P}
polar_drift:       SPROT{R/P}
sbend_drift:       SSEC{R/P}
quad_drift:        PUSHTKT7{R/P}
combined_drift:    PUSHTKT7{R/P} ?                  KTK, TKTF

straight_kick:     KICKEX{R/P}
cavity_kick:       KICK_CAV{R/P}
polar_kick:        SKICK{R/P} (GETELECTRIC)
quad_kick:         KICKPATH{R/P}+KICKTKT7{R/P}
combined_kick:     KICKPATH{R/P}+KICKTKT7{R/P}

twcavity(drift+kick): CAVE{R/P}_TRAV => RK{2,4,6}_CAV{R/P}+...

straight_fringe:   FRINGE_STRAIGHT{R/P}
sbend_fringe:      FRINGE_TEAPOT{R/P}
solenoid_fringe:   FRINGE_SOL{R/P}
cavity_fringe:     FRINGECAV{R/P}
twcavity_fringe:   FRINGE_CAV_TRAV{R/P}
]=]

-- locals ---------------------------------------------------------------------o

local vector, matrix, element, mtable, Command                  in MAD
local is_nil, is_number, is_sequence, is_beam                   in MAD.typeid
local minlen, minang                                            in MAD.constant
local observe, ismoved                                          in element.flags

local abs, sqrt, max, sin, cos, tan, asin, acos, atan, atan2,
      sinh, cosh, sinc, fact                                    in MAD.gmath

local minvolt = 1e-6

local ptc_compat  = true

-- special --------------------------------------------------------------------o

local function empty_track () end

local function invalid_track (elm)
  error(string.format("invalid element %s of kind %s with length %s",
                      elm.name, elm.kind, elm.l))
end

element.  extra_element :set_functions { track = invalid_track } -- not valid
element.special_element :set_functions { track =   empty_track } -- default

-- strengths and phases retrieval ---------------------------------------------o

-- Load element phases in mflow

local function get_phas (elm, m, nmul) -- l=0 (or ignored)
  local pnl, dpnl = elm.pnl or {}, elm.dpnl or {}
  local psl, dpsl = elm.psl or {}, elm.dpsl or {}
  for i=1,nmul do
    m.pnl[i] = (pnl[i] or 0) + (dpnl[i] or 0)
    m.psl[i] = (psl[i] or 0) + (dpsl[i] or 0)
  end
end

-- Load element multipoles and volts in mflow

local function get_mult (elm, m) -- l=0 (or ignored)
  local knl, dknl = elm.knl or {}, elm.dknl or {}
  local ksl, dksl = elm.ksl or {}, elm.dksl or {}
  local nmul = max(#knl, #ksl, #dknl, #dksl)

  m.ksi = (elm.ksi or 0) + (elm.dksi or 0) -- solenoid
  m.krf = (elm.krf or 0) + (elm.dkrf or 0) -- rf cavity (krf*z = omega_rf*t)
  m.v   = (elm.v   or 0) + (elm.dv   or 0) -- rf volts

  if nmul >= 1 then
    for i=1,nmul do
      m.knl[i] = (knl[i] or 0) + (dknl[i] or 0)
      m.ksl[i] = (ksl[i] or 0) + (dksl[i] or 0)
    end
    if abs(m.krf) >= minang then
      get_phas(elm, m, nmul)
    end
    m.nmul = nmul
  else
    m.nmul, m.knl[1], m.ksl[1] = 0, 0, 0
  end

end

-- Load element strengths, multipoles and volts in mflow

local function get_kmult (elm, m, l) -- l~=0
  if abs(l) < minlen then return get_mult(elm, m) end

  local k0 , k1 , k2 , k3  in elm
  local k0s, k1s, k2s, k3s in elm
  local nkn = k3  and 4 or k2  and 3 or k1  and 2 or k0  and 1 or 0
  local nks = k3s and 4 or k2s and 3 or k1s and 2 or k0s and 1 or 0
  local knl, dknl = elm.knl or {}, elm.dknl or {}
  local ksl, dksl = elm.ksl or {}, elm.dksl or {}
  local nmul = max(#knl, #ksl, #dknl, #dksl, nkn, nks)

  m.ksi = (elm.ks or 0)*l + (elm.ksi or 0) + (elm.dksi or 0)
  m.krf =                   (elm.krf or 0) + (elm.dkrf or 0)
  m.v   =                   (elm.v   or 0) + (elm.dv   or 0)

  if nmul >= 1 then
    local kn = { k0 , k1 , k2 , k3  }
    local ks = { k0s, k1s, k2s, k3s }
    for i=1,nmul do
      m.knl[i] = (kn[i] or 0)*l + (knl[i] or 0) + (dknl[i] or 0)
      m.ksl[i] = (ks[i] or 0)*l + (ksl[i] or 0) + (dksl[i] or 0)
    end
    if abs(m.krf) >= minang then
      get_phas(elm, m, nmul)
    end
    m.nmul = nmul
  else
    m.nmul, m.knl[1], m.ksl[1] = 0, 0, 0
  end
end

-- drifts ---------------------------------------------------------------------o

__help['track: exact straight drift'] = [=[
  [Wolski14] p.86, ch. 3.1, eq. 3.13-3.18
  [Forest98] p.306, ch. 10.4.3.1, eq. 10.23a-10.23c
  [MADX-PTC] Function DRIFTR in file Sh_def_kind.f90
]=]

local function straight_drift (_, m, l) -- exact, l~=0
  if abs(l) < minlen then return end

  local x, px, y, py, t, pt, T in m
  local _beta = 1/m.beam.beta
  local l_pz = l/sqrt(1 + 2*_beta*pt + pt^2 - px^2 - py^2) -- TODO: stability

  m.x = x + px*l_pz
  m.y = y + py*l_pz
  m.t = t - (_beta+pt)*l_pz + (1-T)*l*_beta
end

__help['track: exact rbend drift'] = [=[
  [Forest98] p.367, ch. 12.3.1, eq. 12.39a,12.39c, 12.39f
  [MADX-PTC] Function SPARR in file Sh_def_kind.f90
]=]

local function rbend_drift (elm, m, l)
  local knl in m
  if abs(knl[1]) < minang then
    return straight_drift(nil,m,l)
  end

  local x, px, y, py, t, pt, dirchg, T in m
  local _beta = 1/m.beam.beta
  local lw = l/elm.l
  local k0 = dirch*lw*knl[1]

  local pz = sqrt(1 + 2*_beta*pt + pt^2 - px^2 - py^2) -- TODO: stability
  local pt = sqrt(1 + 2*_beta*pt + pt^2 - py^2)
  local xp = px - k0
  local ps = sqrt(1 + 2*_beta*pt + pt^2 - xp^2 - py^2)
  local xs = (asin(px/pt) - asin(xp/pt))/k0

  m.x  = x + (ps-pz)/k0
  m.px = xp
  m.y  = y + py*xs
  m.t  = t - (_beta+pt)*xs + (1-T)*l*_beta
end

__help['track: exact solenoid drift'] = [=[
  [Forest98] p.377, ch. 12.5.2, eq. 12.50 and solution
  [MADX-PTC] Function KICK_SOL in file Sh_def_kind.f90
]=]

local function solenoid_drift (elm, m, l) -- exact, l~=0          TO BE REVIEWED
  local ksi in m
  if abs(ksi) < minang then
    return rbend_drift(elm,m,l)
  end

  local x, px, y, py, t, pt, T, dirchg in m      -- USE KSI not KS.
  local _beta = 1/m.beam.beta
  local lw = l/elm.l

--  local bsol = ksi*lw*dirchg/2
  local bsol = ks/elm.l*dirchg/2 -- to discuss
  local xp = px + bsol*y  -- ?? was not depending on l before, how is it possible?
  local yp = py - bsol*x  -- ?? was not depending on l before, how is it possible?

  local l_pz  = l/sqrt(1 + 2*_beta*pt + pt^2 - xp^2 - yp^2) -- TODO: stability
  local angle = l_pz*bsol

  local ca, sa, sc = cos(angle), sin(angle), sinc(angle)

  local xt  = ca*x  + l_pz*sc*px
  local pxt = ca*px - l_pz*sc*x *bsol^2
  local yt  = ca*y  + l_pz*sc*py
  local pyt = ca*py - l_pz*sc*y *bsol^2

  m.x  = ca*xt  + sa*yt
  m.px = ca*pxt + sa*pyt
  m.y  = ca*yt  - sa*xt
  m.py = ca*pyt - sa*pxt

  m.t  = t - (_beta+pt)*l_pz + (1-T)*l*_beta
end

__help['track: pseudo-exact quad drift'] = [=[
  [MADX-PTC] Function PUSHTKT7 in file Sh_def_kind.f90
]=]

local function quad_drift (elm, m, l) -- better for fast tunes convergence
  local knl in m
  if abs(knl[2]) < minang then
    return rbend_drift(elm,m,l)
  end

  local x, px, y, py, t, pt, dirchg, T in m -- TODO check dirchg
  local _beta = 1/m.beam.beta
  local l_bet2_gam2 = l/(m.beam.gamma^2-1)
  local _el = 1/elm.l

  local lw = l*_el
  local h  = lw*angle
  local hbar = h*_beta

  local k0, k1 = knl[1]*_el, knl[2]*_el
  local hk0pk1 = h*k0+k1
  local wx2, wy2 = abs(hk0pk1), abs(k1)
  local wx , wy  = sqrt(wx2), sqrt(wy2)

  local cx, sx, cy, sy
  if hk0pk1 < 0 -- check wx == 0 ?
  then cx, sx = cosh(wx*l), sinh(wx*l)/wx
  else cx, sx = cos (wx*l), sin (wx*l)/wx
  end
  if k1 < 0
  then cy, sy = cosh(wy*l), sinh(wy*l)/wy
  else cy, sy = cos (wy*l), sin (wy*l)/wy
  end

  local m16, m56 = (1-cx)/wx2, hbar^2*(l-sx)/wx2

  m.x  =      cx*x + sx*px + hbar*m16*pt + (h-k0)*m16
  m.px = -wx2*sx*x + cx*px + hbar*sx*pt  + (h-k0)*sx
  m.y  =      cy*y + sy*py
  m.py =  wy2*sy*y + cy*py
  m.t  = t - hbar*(sx*x+m16*px) + (l_bet2_gam2-m56)*pt + (1-T)*l*_beta
end

__help['track: exact polar drift'] = [=[
  [Forest02] p.76, ch. K.4.9, (general explaination)
  [Forest06] p.5365, eq. 127, exact drift -- WRONG: ref is an yrotation
  [MADX-PTC] Function SPROTR in file Sh_def_kind.f90
]=]

local function polar_drift (elm, m, l) -- exact, l~=0, k0=angle
  local angle in elm
  if abs(angle) < minang then -- should never occur due to precedences
    return rbend_drift(elm,m,l)
  end

  local rho = elm.l/(angle*m.dir)
  local ang = l/rho
  local sa, ca, ta, sa2 = sin(ang), cos(ang), tan(ang), sin(ang/2)

  local x, px, y, py, t, pt, T in m
  local _beta = 1/m.beam.beta
  local pz  = sqrt(1 + 2*_beta*pt + pt^2 - px^2 - py^2) -- TODO: stability
  local _pz = 1/pz
  local ptt = 1 - ta*px*_pz
  local xr  = (x+rho)*ta*_pz

  m.x  = (x + rho*(2*sa2^2 + sa*px*_pz))/(ca*ptt)
  m.px = ca*px + sa*pz
  m.y  = y + xr*py/ptt
  m.t  = t - xr*(_beta+pt)/ptt + (1-T)*l*_beta
end

__help['track: exact sbend drift'] = [=[
  [Forest06] p.5365, eq. 126, exact drift
]=]

local function sbend_drift (elm, m, l) -- exact, l~=0, k0~=angle
  local angle in elm
  local knl in m
  if abs(angle - knl[1]) < minang then
    return polar_drift(elm,m,l)
  end
  error("NYI")
end

__help['track: pseudo-exact combined drift'] = [=[
  [MADX-PTC] Function PUSHTKT7 in file Sh_def_kind.f90
]=]

local function combined_drift (elm, m, l) -- angle, k0, k1 (tunes)
  local knl in m
  if abs(knl[2]) < minang then
    return sbend_drift(elm,m,l)
  end
  error("NYI")
end

-- kicks ----------------------------------------------------------------------o

__help['track: generic thin kick'] = [[
  [MADX-PTC] Function KICKTR in file Sh_def_kind.f90
]]

-- Special case TO BE REVIEWED !!!
local function thin_kick (elm, m) -- l=0 (ignored)
--  local knlt, kslt = elm.knl or {}, elm.ksl or {} -- BUG: not retrieved by getmul
--  local knl1, ksl1 = (knlt[1] or 0), (kslt[1] or 0)

  local x, px, y, py, dirchg, nmul, knl, ksl in m -- BUG: nmul set by last getmul
  local byt
  local by = knl[nmul] / fact(nmul-1)
  local bx = ksl[nmul] / fact(nmul-1)
  for i=nmul-1,1,-1 do
    byt = x*by - y*bx + knl[i] / fact(i-1)
    bx  = y*by + x*bx + ksl[i] / fact(i-1)
    by  = byt
  end

  m.px = px - dirchg*by + dirchg*knl1
  m.py = py + dirchg*bx - dirchg*ksl1

  if knl1 ~= 0 or ksl1 ~= 0 then
    local t, pt in m
    local _beta = 1/m.beam.beta
    local pz = sqrt(1 + 2*_beta*pt + pt^2)

    local l = elm.lrad or 0
    if l ~= 0 then -- dipole focusing and deltap
      m.px = m.px - knl1^2*x/l + dirchg*knl1*(pz-1)
      m.py = m.py - ksl1^2*y/l + dirchg*ksl1*(pz-1)
    end
--    m.t = t + dirchg*(knl1*x - ksl1*y) * (_beta+pt)/pz
    m.t = t - dirchg*(knl1*x - ksl1*y) * (_beta+pt)/pz
  end
end

__help['track: straight kick'] = [[
  [Forest98] p.354, ch. 12.1.3, eq. 12.6
  [MADX-PTC] Function KICKEXR in file Sh_def_kind.f90
  [SixTrack] p.12, ch. 3.5 (thin multipole), eq. 91-94
  [Ripken95] p.26, ch. 4.6.2, eq. 4.23 (and solution)
]]

local function straight_kick (elm, m, l) -- l~=0
  local nmul in m
  if nmul == 0 then return end

  local x, px, y, py, knl, ksl, dirchg in m
  local lw, byt = abs(elm.l)>minlen and l/elm.l or 1
  local by = lw*knl[nmul] / fact(nmul-1)
  local bx = lw*ksl[nmul] / fact(nmul-1)

  for i=nmul-1,1,-1 do
    byt = x*by - y*bx + lw*knl[i] / fact(i-1)
    bx  = y*by + x*bx + lw*ksl[i] / fact(i-1)
    by  = byt
  end

  m.px = px - dirchg*by
  m.py = py + dirchg*bx
end

__help['track: exact cavity kick'] = [=[
[MADX-PTC] Function KICCAVR in file Sh_def_kind.f90
]=]

-- local foward_names (remove local in definition)

local function cavity_kick (elm, m, l)--RF CAV, CRAB, RFMULT with l>0 kick (kickcavr)
  local v in m
  if abs(v) < minvolt then
    return straight_kick(elm,m,l)
  end

  local x, px, y, py, t, pt, nmul, dirchg in m
  local tt, phase, phase0 = elm.tt or 0, elm.phase or 0, elm.phase0 or 0
  local ff, ph = elm.f or {}, elm.ph or {}
  local a , r  = elm.a or  0, elm.r or 0

  local pc     = beam.pc
  local volt_c = 1.0e-3
  local freq, harm = elm.freq or 0, elm.harm or 0
  local volt, lag  = elm.volt or 0, elm.lag or 0
  local nbessel    = elm.nbessel or  0

  if freq == 0 and harm == 0 then
    error("either frequency or harmonic number has to be defined for RF Cavity " .. elm.name)
  end

  local omega = twopi*freq / clight
  local vl    = m.dirchg*l*volt*volt_c/pc
  local df, f, r2 = 0, 1, 1

  do i=1,nbessel
    r2  = -r2*(ko*omega)^2/(4*(i+1)^2)
    dr2 =  r2*i
    df  =  df + 2*dr2
    r2  =  r2*(x^2+y^2)
    f   =  f + r2
  end

  if nbessel > 0 then
    m.px = px-x*ff[ko]* df * vl * cos(arg)/(ko*omega)
    m.py = py-y*ff[ko]* df * vl * cos(arg)/(ko*omega)
  end

  local arg = ko*omega*(t + tt) + phas + ph[ko] + phase0
  m.pt = m.pt -ff[ko]*f*vl*sin(arg)

  local lw, byt = elm.l>0 and l/elm.l or 1
  local by = lw*knl[nmul] / fact(nmul-1)
  local bx = lw*ksl[nmul] / fact(nmul-1)

  for i=nmul-1,1,-1 do
    byt = x*by - y*bx + lw*knl[i] / fact(i-1)
    bx  = y*by + x*bx + lw*ksl[i] / fact(i-1)
    by  = byt
  end

  m.px = m.px - ff[ko]*dirchg*by/pc*(a + r*cos(arg))
  m.py = m.py + ff[ko]*dirchg*bx/pc*(a + r*cos(arg))

  by = -lw*knl[nmul] / fact(nmul-1) / nmul
  bx = -lw*ksl[nmul] / fact(nmul-1) / nmul

  for i=nmul,2,-1 do
    byt = x*by - y*bx - lw*knl[i-i] / fact(i-2) / (i-1)
    bx  = y*by + x*bx - lw*ksl[i-i] / fact(i-2) / (i-1)
    by  = byt
  end

  byt = x*by - y*bx
  bx  = y*by + x*bx
  by  = byt

  m.pt = m.pt + ff[ko]*(ko*omega)*dirchg*by/pc * r *sin(arg)
end

__help['track: pseudo-exact quad kick'] = [=[
  [Forest98] p.354, ch. 12.1.3, eq. 12.6
  [MADX-PTC] Function KICKPATHR+KICKTKT7R in file Sh_def_kind.f90

]=]
local function quad_kickpath (elm, m, l)
  local x, px, y, py, t, pt, dirchg, T in m
  local _beta = 1/m.beam.beta

  local pz = sqrt(1 + 2*_beta*pt + pt^2 - px^2 - py^2) -- TODO: stability
  m.x  = x + l*px*(1/pz-1)
  m.y  = y + l*py*(1/pz-1)
  m.t  = t - l*(_beta+pt)/pz + (1-T)*l*_beta

end

local function quad_kick (elm, m, l)
  local knl in m
  if abs(knl[2]) < minang then -- should never occur due to precedences
    return cavity_kick(elm,m,l)
  end

-- kickpath (c exact)
    quad_kickpath (elm, m, l/2)
-- kicktkt7r
  local x, px, y, py, t, pt, dirchg, T in m
  local _beta = 1/m.beam.beta

  local pz = sqrt(1 + 2*_beta*pt + pt^2) - 1 -- TODO: stability

  m.px = px + lw*knl[1]*(pz - pt)*_beta
  m.t  = t  - lw*knl[1]*((pt + _beta)/(1 + pz) - _beta)*x

  local lw, byt = abs(elm.l)>minlen and l/elm.l or 1
  local by = lw*knl[nmul] / fact(nmul-1)
  local bx = lw*ksl[nmul] / fact(nmul-1)


  for i=nmul-1,1,-1 do
    byt = x*by - y*bx + lw*knl[i] / fact(i-1)
    bx  = y*by + x*bx + lw*ksl[i] / fact(i-1)
    by  = byt
  end

   m.px = m.px - dirch*(by- lw*knl[1] - lw*knl[2]*x)
   m.py = p.py + dirch*(bx-lw*knl[2]*y)
end

__help['track: polar kick'] = [[
  [Forest98] p. 358-361, ch. 12.2.2, eq. 12.18a-12.18f
  [Forest02] p. 76
  [MADX-PTC] Function SKICKR in file Sh_def_kind.f90
  [Ripken95] p. 22, ch. 4.3 (bending magnet) eq. 4.12 (and solution)
  [SixTrack] Thin Dipole, ch. 3.2.2, eq. 48-50
]]

local function polar_kick (elm, m, l) -- [PTC] SKICK, TODO: GETELECTRIC
  local angle in elm
  if abs(angle) < minang then -- should never occur due to precedences
    return straight_kick(elm,m,l)
  end

  local x, px, y, py, nmul, knl, ksl, dirchg in m
  local lw, byt = l/elm.l
  local by = lw*knl[nmul] / fact(nmul-1)
  local bx = lw*ksl[nmul] / fact(nmul-1)

  for i=nmul-1,1,-1 do
    byt = x*by - y*bx + lw*knl[i] / fact(i-1)
    bx  = y*by + x*bx + lw*ksl[i] / fact(i-1)
    by  = byt
  end

  -- TODO: modified, should be rechecked
  local h = lw*angle
  m.px = px - dirchg*by*(1 + h*x) -- was k0...
  m.py = py + dirchg*bx*(1 + h*x)
end

__help['track: pseudo-exact combined kick'] = [=[
Ref??
]=]

local function combined_kick (elm, m, l) -- angle, k0, k1 (tunes)
  local knl in m
  if abs(knl[2]) < minang then
    return polar_kick(elm,m,l)
  end
  -- error("NYI") -- TODO
end

-- fringes --------------------------------------------------------------------o

__help['track: straight fringe'] = [=[
  [Forest98] p. 389, ch. 13.2.3, eq. 13.33a-13.33f
]=]

local function straight_fringe (elm, m, l)
  local nmul in m
  if nmul == 0 then return end
  -- error("NYI") -- TODO
end

__help['track: solenoid fringe'] = [=[

]=]

local function solenoid_fringe (elm, m, l)
  local ksi in m
  if abs(ksi) < minang then -- should never occur due to precedences
    return straight_fringe(elm,m,l)
  end
  -- error("NYI") -- TODO
end

__help['track: rfcavity fringe'] = [=[
Ref??
]=]

local rfcavity_fringe_ptc

local function rfcavity_fringe (elm, m, l)
  local v in m
  if abs(v) < minvolt then -- should never occur due to precedences
    return straight_fringe(elm,m,l)
  end
  -- rfcavity_fringe_ptc(elm, m, l) -- TODO
end

__help['track: sbend fringe'] = [=[
Ref??
]=]

local sbend_fringe_ptc

local function sbend_fringe (elm, m, l)
  local angle in elm
  if abs(angle) < minang then -- should never occur due to precedences
    return straight_fringe(elm,m,l)
  end
  -- sbend_fringe_ptc(elm, m, l) -- TODO
end

-- patches --------------------------------------------------------------------o

-- S-rotation (roll, tilt)

local function srotation (_, m, angle)   -- XYrot <-> Rz(-angle)?
  if abs(angle) < minang then return end

  local x, px, y, py, dir in m
  local sa, ca = sin(angle*dir), cos(angle*dir)

  m.x  = ca*x  + sa*y
  m.y  = ca*y  - sa*x
  m.px = ca*px + sa*py
  m.py = ca*py - sa*px
end

-- Y-rotation (yaw)

local function yrotation (_, m, angle)   -- XZrot (Dragt's PROT) <-> Ry(angle)
  if abs(angle) < minang then return end

  local x, px, y, py, t, pt, dir in m
  local sa, ca, ta = sin(angle*dir), cos(angle*dir), tan(angle*dir)
  local _beta = 1/m.beam.beta
  local pz = sqrt(1 + 2*_beta*pt + pt^2 - px^2 - py^2) -- TODO: stability
  local _pz = 1/pz
  local ptt = 1 - ta*px*_pz

  m.x  = x/(ca*ptt)
  m.px = ca*px + sa*pz
  m.y  = y + ta*x*py*_pz/ptt
  m.t  = t - ta*x*_pz*(_beta+pt)/ptt
end

-- X-rotation (pitch)

local function xrotation (_, m, angle)   -- YZrot <-> Rx(angle)
  if abs(angle) < minang then return end -- XZrot with x,px <-> y,py)

  local x, px, y, py, t, pt, dir in m
  local sa, ca, ta = sin(angle*dir), cos(angle*dir), tan(angle*dir)
  local _beta = 1/m.beam.beta
  local pz = sqrt(1 + 2*_beta*pt + pt^2 - px^2 - py^2) -- TODO: stability
  local _pz = 1/pz
  local ptt = 1 - ta*py*_pz

  m.y  = y/(ca*ptt)
  m.py = ca*py + sa*pz
  m.x  = x + ta*y*px*_pz/ptt
  m.t  = t - ta*y*_pz*(_beta+pt)/ptt
end

-- Translation (dz treated as drift length)

local function translate (_, m, dx, dy, dz)
  local dir in m

  straight_drift(_, m, dz)
  m.x = m.x - dx*dir
  m.y = m.y - dy*dir
end

-- Changeref/Forward/Backward patches

local function changeref (elm, m)
  local x, y, z, theta, phi, psi in elm
  xrotation(nil, m, phi   or 0)                    -- phi  : Elevation angle.
  yrotation(nil, m, theta or 0)                    -- theta: Azimuthal angle.
  srotation(nil, m, psi   or 0)                    -- psi  : Roll      angle.
  translate(nil, m, x or 0, y or 0, z or 0)
end

local function forward_patch (elm, m)
  local x, y, z, theta, phi, psi, dx, dy, dz, dtheta, dphi, dpsi in elm
  xrotation(nil, m, (phi   or 0)+(dphi   or 0))    -- phi  : Elevation angle.
  yrotation(nil, m, (theta or 0)+(dtheta or 0))    -- theta: Azimuthal angle.
  srotation(nil, m, (psi   or 0)+(dpsi   or 0))    -- psi  : Roll      angle.
  translate(nil, m, (x or 0)+(dx or 0),
                    (y or 0)+(dy or 0),
                    (z or 0)+(dz or 0) )
end

local function backward_patch (elm, m)
  local x, y, z, theta, phi, psi, dx, dy, dz, dtheta, dphi, dpsi in elm
  translate(nil, m, (x or 0)+(dx or 0),
                    (y or 0)+(dy or 0),
                    (z or 0)+(dz or 0) )
  srotation(nil, m, (psi   or 0)+(dpsi   or 0))    -- psi  : Roll      angle.
  yrotation(nil, m, (theta or 0)+(dtheta or 0))    -- theta: Azimuthal angle.
  xrotation(nil, m, (phi   or 0)+(dphi   or 0))    -- phi  : Elevation angle.
end

local function patch_track (elm, m, pos)
  if pos == 'entry'
  then forward_patch (elm, m)
  else backward_patch(elm, m) -- not correct, need local survey patch
  end
end

-- sbend ----------------------------------------------------------------------o

__help['track: exact sbend'] = [[
  [Forest98] p.360, ch. 12.2.3
  [Forest02] p.76 (general explaination)
  [Forest06] p.5365, eq. 126, exact drift
  [MADX-PTC] Function SPROTR in file Sh_def_kind.f90
]]

local function sbend_face (elm, m, h)
  local x, px, y, py, t, pt, dir in m
  local k0 = elm.k0 or 0
  local _beta = 1/m.beam.beta

  if dir == 1 then -- to insure reversal symmetry ; horizontal wedge (only dir)
    px = px +(dir*k0*h/2)*x^2
  end

  local ptt =     sqrt(1 + 2*pt*_beta + pt^2 - px^2)
  local xi  = dir*sqrt(1 + 2*pt*_beta + pt^2)*k0*h/ptt^2
  local dxi_px   =  2*px*xi/ptt^2
  local dxi_ddel = -2*xi*(1 + pt)/ptt^2

  x  = x / (1-dxi_px*y^2)
  px = px - xi*y^2
  py = py - 2*xi*x*y
  t  = t  - dxi_ddel*x*y^2

  if(dir == -1) then -- to insure reversal symmetry; horizontal wedge (only dir)
    px = px +(dir*k0*h/2)*x^2
  end

  m.x  = x
  m.px = px
  m.py = py
  m.t  = t
end

local function sbend_wedge (elm, m, e)
  local x, px, y, py, t, pt, T, dir in m
  local k0 = elm.k0 or 0
  local _beta = 1/m.beam.beta
  local b1 = dir*k0
  local sa, ca, sa2 = sin(e), cos(e), sin(2*e)

  if b1 == 0 then
    yrot_track (elm, m, e) return
  end

  local pz  = sqrt(1 + 2*_beta*pt + pt^2 - px^2 - py^2) -- TODO: stability
  local ptt = sqrt(1 + 2*_beta*pt + pt^2        - py^2) -- TODO: stability
  local pxt = px*ca + (pz - b1*x)*sa
  local pzs = sqrt(1 + 2*_beta*pt + pt^2 - py^2 - pxt^2) -- TODO: stability
  local yt  = (e + asin(px/ptt) - asin(pxt/ptt)) / b1

  m.x  = x*ca + (x*px*sa2 + sa^2*(2*x*pz-b1*x^2)) / (pzs+pz*ca-px*sa)
  m.px = pxt
  m.y  = y + py * yt
  m.t  = t - yt*(_beta + pt)
end

local function sbend_fringe_field (elm, m, pos)
-- Lee-Whiting formula, E. Forest ch 13.2.3, eq 13.33
--  TODO: FINT and FINTX to have different FINT at entrance /exit
  local x, px, y, py, t, pt, T, dir in m
  local k0   = elm.k0 or 0
  local _beta = 1/m.beam.beta
-- soft edge
  local fint = elm.fint or 0  -- fringe field integral at entrance and exit of the bend
  local hgap = elm.hgap or 0  -- half gap of the magnet
  local fsad = 0

  if fint*hgap ~= 0.0 then  -- soft edge
      fsad = 1/(fint*hgap*2)/36
  end

  local b = m.beam.charge*k0
  if pos == 'exit' then
     b = -b
  end

  local pz = sqrt(1 + 2*_beta*pt + pt^2 - px^2 - py^2) -- TODO: stability
  local time_fac = _beta + pt
  local rel_p    = sqrt(1 + 2*_beta*pt + pt^2)

  local c3=b^2*fsad/rel_p

  local xp, yp = px/pz or 0, py/pz or 0
  local d  = matrix {
    { (1+xp^2) / pz, xp*yp    / pz, -time_fac*xp /pz^2 },
    {  xp*yp   / pz, (1+yp^2) / pz, -time_fac*yp /pz^2 },
    { -xp          ,   -yp        ,  time_fac    /pz   },
  }

  local fi0 = atan((xp/(1 + yp^2)))-2*b*fint*hgap*(1 + xp^2*(2 + yp^2))*pz
  local co2 = b/cos(fi0)^2
  local co1 = co2/(1 + (xp/(1 + yp^2))^2)

  local fi = {0, 0, 0}
  fi[1] =    co1 /       (1 + yp^2) - 2*co2*b*fint*hgap* (2*xp*(2 + yp^2)*pz)
  fi[2] =-2*co1*xp*yp/(1 + yp^2)^2  - 2*co2*b*fint*hgap* (2*xp^2*yp)*pz
  fi[3] =                           - 2*co2*b*fint*hgap* (1 + xp^2*(2 + yp^2))

  fi0=b*tan(fi0)

  b=0
  for i=1,3 do -- y column
    b=fi[i]*d:get(i,2) + b
  end
  m.y  = 2*m.y/(1 + sqrt(1 - 2*b*m.y))
  m.py = py - fi0*m.y

  b=0
  for i=1,3 do -- x column
    b=fi[i]*d:get(i,1) + b
  end
  m.x = m.x+0.5*b*m.y^2

  b=0
  for i=1,3 do -- z column
    b=fi[i]*d:get(i,3) + b
  end
  m.t = t + 0.5*b*m.y^2

  -- soft edge
  m.py = m.py - 4*c3*m.y^3
  m.t  = m.t  +   c3*m.y^4/rel_p^2*time_fac
end

local function sbend_fringe_ptc (elm, m, pos)
  if elm.kill_fringe then return end

  if pos == 'entry' and not elm.kill_ent_fringe then
    local e, h = elm.e1 or 0, elm.h1 or 0
    if abs(e) < minang then
      sbend_face         (elm, m,  h)
      sbend_fringe_field (elm, m,  'entry')
    else
      yrotation          (elm, m,  e)
      sbend_face         (elm, m,  h)
      sbend_fringe_field (elm, m,  'entry')
      sbend_wedge        (elm, m, -e)
    end
    return
  end

  if pos == 'exit' and not elm.kill_exi_fringe then
    local e, h = elm.e2 or 0, elm.h2 or 0
    if abs(e) < minang then
      sbend_fringe_field (elm, m, 'exit')
      sbend_face         (elm, m,  h)
    else
      sbend_wedge        (elm, m, -e)
      sbend_fringe_field (elm, m, 'exit')
      sbend_face         (elm, m,  h)
      yrotation          (elm, m,  e)
    end
    return
  end
end

element.sbend:set_functions {   kick_track = rfcavity_kick,
                              fringe_track = sbend_fringe }

-- cavities -------------------------------------------------------------------o

local function rfcavity_kick (elm, m, l) -- RF CAV, CRAB, RFMULT with l>0 kick (kickcavr)
  local x, px, y, py, t, pt, nmul, dirchg in m
  local tt, phase, phase0 = elm.tt or 0, elm.phase or 0, elm.phase0 or 0
  local ff, ph = elm.f or {}, elm.ph or {}
  local a, r = elm.a or  0, elm.r or 0

  -- nocavity.and.(.not.always_on)  return
  if 'nocavity' and (not 'always_on') then return end -- non-sense!!!

  local pc = beam.pc
  local volt_c = 1.0e-3
  local freq, harm, volt, lag = elm.freq or 0, elm.harm or 0, elm.volt or 0, elm.lag or 0
  local nbessel, nf = elm.nbessel or  0, elm.nf or 1
  if freq == 0 and harm == 0 then
    error("either frequency or harmonic number has to be defined for RF Cavity " .. elm.name)
  end

  local omega = twopi*freq / clight
  local vl    = m.dirchg*l*volt*volt_c/pc
  local df, f, r2 = 0, 1, 1

  for ko=1,nf do -- over modes
    for i=1,nbessel do
      r2  = -r2*(ko*omega)^2/(4*(i+1)^2)
      dr2 =  r2*i
      df  =  df + 2*dr2
      r2  =  r2*(x^2+y^2)
      f   =  f + r2
    end

    if nbessel > 0 then
      m.px = px-x*ff[ko]* df * vl * cos(arg)/(ko*omega)
      m.py = py-y*ff[ko]* df * vl * cos(arg)/(ko*omega)
    end

    local arg = ko*omega*(t + tt) + phas + ph[ko] + phase0
    m.pt = m.pt -ff[ko]*f*vl*sin(arg)

    local lw, byt = elm.l>0 and l/elm.l or 1
    local by = lw*knl[nmul] / fact(nmul-1)
    local bx = lw*ksl[nmul] / fact(nmul-1)

    for i=nmul-1,1,-1 do
      byt = x*by - y*bx + lw*knl[i] / fact(i-1)
      bx  = y*by + x*bx + lw*ksl[i] / fact(i-1)
      by  = byt
    end

    m.px = m.px - ff[ko]*dirchg*by/pc*(a + r*cos(arg))
    m.py = m.py + ff[ko]*dirchg*bx/pc*(a + r*cos(arg))

    by = -lw*knl[nmul] / fact(nmul-1) / nmul
    bx = -lw*ksl[nmul] / fact(nmul-1) / nmul

    for i=nmul-1,1,-1 do
      byt = x*by - y*bx - lw*knl[i] / fact(i-1) / i
      bx  = y*by + x*bx - lw*ksl[i] / fact(i-1) / i
      by  = byt
    end

    byt = x*by - y*bx
    bx  = y*by + x*bx
    by  = byt

    m.pt = m.pt + ff[ko]*(ko*omega)*dirchg*by/pc * r *sin(arg)
  end --over modes
end

local function rfcavity_thin_kick (elm, m, l) -- for tracking thin rf mult
  local x, px, y, py, t, pt, nmul, dirchg in m
  local tt, phase, phase0 = elm.tt or 0, elm.phase or 0, elm.phase0 or 0
  local ff, ph = elm.f or {}, elm.ph or {}
  local a, r = elm.a or  0, elm.r or 0
  -- nocavity.and.(.not.always_on)  return
  if 'nocavity' and (not 'always_on') then return end -- non-sense!!!

  local pc = beam.pc
  local volt =elm.volt
  local volt_c = 1.0e-3
  local omega = twopi*freq / clight

  for ko=1,nf do -- over modes
    local arg = ko*omega*(t + tt) + phas + ph[ko] + phase0
    m.pt = m.pt - dirchg*volt_c*ff[ko]*volt*sin(arg)/pc

    -- BUG: knl, ksl never retrieved
    local lw, byt = elm.l>0 and l/elm.l or 1
    local by = lw*knl[nmul] / fact(nmul-1)
    local bx = lw*ksl[nmul] / fact(nmul-1)

    for i=nmul-1,1,-1 do
      byt = x*by - y*bx + lw*knl[i] / fact(i-1)
      bx  = y*by + x*bx + lw*ksl[i] / fact(i-1)
      by  = byt
    end

    m.px = m.px - ff[ko]*dirchg*by/pc*(a + r*cos(arg))
    m.py = m.py + ff[ko]*dirchg*bx/pc*(a + r*cos(arg))

    by = -lw*knl[nmul] / fact(nmul-1) / nmul
    bx = -lw*ksl[nmul] / fact(nmul-1) / nmul

    for i=nmul,2,-1 do
      byt = x*by - y*bx - lw*knl[i-i] / fact(i-2) / (i-1)
      bx  = y*by + x*bx - lw*ksl[i-i] / fact(i-2) / (i-1)
      by  = byt
    end

    byt = x*by - y*bx
    bx  = y*by + x*bx
    by  = byt

    m.t = t - ff[ko]*(ko*omega)*dirchg*by/pc * r *sin(arg)
  end --over modes
end

local function adjust_time_cav(elm, m, pos)
  local x, px, y, py, t, pt, T, dir in m
  local _beta = 1/m.beam.beta

  local delta_e = elm.delta_e or 0
  if pos == 'entry' then
    delta_e = pt
    if 'nocavity' and (not 'always_on') then return end -- non-sense!!!

    if elm.l < minlen then
      rfcavity_thin_kick(elm, m)
      delta_e=(m.pt - delta_e)*m.beam.pc -- side effects?
    end
  else
    if elm.l < minlen then return end
    t = t - elm.l*_beta -- TO CHECK      -- side effects?
    delta_e = (pt - delta_e)*m.beam.pc   -- side effects?
  end
end

local function rfcavity_fringe_ptc (elm, m, pos)
  local x, px, y, py, t, pt, T, dir in m

  if ('nocavity' and (not 'always_on')) then return end -- non-sense!!!

  if elm.kill_fringe     == 1                     or
     elm.kill_ent_fringe == 1 and pos ==  'entry' or
     elm.kill_ext_fringe == 1 and pos ==  'exit' then return end

  adjust_time_cav(elm, m, 'entry')

  if not ('fringe' or elm.nbessel == -1) then return end
  if elm.l < minlen then return end

  local kbmad = 0
  if elm.nbessel == -1 then kbmad = 1 end

  local z = 0
  if pos == 'entry' then z = elm.l end
  local freq, volt = elm.freg or 0, elm.volt or 0
  local volt_c = 1.0e-3
  local pc = m.beam.pc
  local omega = twopi*freq / clight
  local vl = m.dirchg*volt*volt_c/pc
  if pos == 'exit' then vl = -vl end

  local tt, phase, phase0 = elm.tt or 0, elm.phase or 0, elm.phase0 or 0
  local ph = elm.f or {}, elm.ph or {}
  local nf = elm.nf or 1

  for ko=1,nf do   -- over modes
   s1 = cos(kbmad*ko*omega*z)*sin(ko*omega*(t+tt) + phas + phase0 + ph[ko])
   c1 = cos(kbmad*ko*omega*z)*cos(ko*omega*(t+tt) + phas + phase0 + ph[ko])
   m.px = m.px + 0.5*vl*s1*m.x
   m.py = m.py + 0.5*vl*s1*m.y
   m.pt = m.pt - 0.25*(m.x^2 + m.y^2)*vl*c1*omega*ko
  end

  adjust_time_cav(elm, m, 'exit')
end

-- integrator schemes ---------------------------------------------------------o

local integrators = require 'madl_sympint'

-- sub element kind tracking --------------------------------------------------o

local function subdft_track (elm, m, l)
  local s, ds, at = 0

  for i=1,#elm do   -- sub-elements
    local selm = elm[i]
    at = assert(selm.at, "invalid sub-element position (at expected)")

    -- implicit drift
    ds = at - s
    assert(ds >= 0, "invalid sub-element position (negative drift)")
    if ds >= minlen then
      straight_drift(nil, m, ds)
    end
    s = s + ds

    -- subelement
    selm:track(m)
    s = s + selm.l
  end

  -- implicit drift
  ds = l-s
  assert(ds >= 0, "invalid sub-element position (negative drift)")
  if ds >= minlen then
    straight_drift(nil, m, ds)
  end
end

local function subelm_track (elm, m, l)
  local integrator = integrators[elm.method or m.method]
  local drift_track, kick_track in elm
  local s, ds, at = 0

  table.insert(m.selm, selm)

  for i=1,#elm do   -- sub-elements
    local selm = elm[i]
    at = assert(selm.at, "invalid sub-element position (at expected)")

    -- implicit drift
    ds = at - s
    assert(ds >= 0, "invalid sub-element position (negative drift)")
    if ds >= minlen then
      integrator(elm, m, ds, drift_track, kick_track)
    end
    s = s + ds

    -- subelement
    selm:track(m)
    s = s + selm.l
  end

  -- implicit drift
  ds = l-s
  assert(ds >= 0, "invalid sub-element position (negative drift)")
  if ds >= minlen then
    integrator(elm, m, ds, drift_track, kick_track)
  end

  table.remove(m.selm)
end

-- element kind tracking ------------------------------------------------------o

local function thin_track (elm, m) -- e.g. multipole
  get_mult (elm, m) -- load strengths in map

  local tilt in elm
  patch_track (elm, m, 'entry')
  srotation   (elm, m,  tilt  )
  thin_kick   (elm, m         )
  srotation   (elm, m, -tilt  )
  patch_track (elm, m, 'exit' )
end

local function drift_track (elm, m) -- e.g. monitor
  local l in elm

  if #elm == 0 and #m.selm == 0 then -- no sub-elements, no surrounding elements
    return straight_drift(nil, m, l)
  end

  local tilt in elm
  patch_track (elm, m, 'entry')
  srotation   (elm, m,  tilt  )
  if #m.selm == 0 -- any surrounding elements?
  then subdft_track(elm, m, l)
  else subelm_track(elm, m, l)
  end
  srotation   (elm, m, -tilt  )
  patch_track (elm, m, 'exit' )
end

local function thick_track (elm, m) -- e.g. sbend, rbend, quadrupole, ...
  local l, tilt in elm

  if #m.selm == 0 then -- any surrounding elements?
    get_kmult(elm, m, l) -- load strengths in map
  else
    -- TODO
  end

  patch_track(elm, m, 'entry')
  srotation  (elm, m,  tilt  )
  elm:fringe_track(m, 'entry')

  if #elm == 0 then -- any sub-elements ?
    local integrator = integrators[elm.method or m.method]
    local drift_track, kick_track in elm
    integrator  (elm, m, l, drift_track, kick_track)
  else
    subelm_track(elm, m, l)
  end

  elm:fringe_track(m, 'exit')
  srotation  (elm, m, -tilt )
  patch_track(elm, m, 'exit')
end

-- load maps into elements ----------------------------------------------------o

local patch_element, thin_element, drift_element, thick_element,
      sbend, combined, rbend, quadrupole, solenoid, rfcavity, twcavity,
      xrotation, yrotation, srotation, translation, changeref in element

 thin_element :set_functions {    track =  thin_track }
drift_element :set_functions {    track = drift_track }
patch_element :set_functions {    track = patch_track }
thick_element :set_functions {    track = thick_track,
                            drift_track = straight_drift,
                             kick_track = straight_kick,
                           fringe_track = straight_fringe }

sbend :set_functions {      drift_track = sbend_drift,
                             kick_track = polar_kick,
                           fringe_track = sbend_fringe }

combined :set_functions {   drift_track = combined_drift,
                             kick_track = combined_kick,
                           fringe_track = sbend_fringe }

rbend :set_functions {      drift_track = rbend_drift,
                             kick_track = rfcavity_kick,
                           fringe_track = straight_fringe }

quadrupole :set_functions { drift_track = quad_drift,
                             kick_track = quad_kick,
                           fringe_track = straight_fringe }

solenoid :set_functions {   drift_track = solenoid_drift,
                             kick_track = rfcavity_kick,
                           fringe_track = solenoid_fringe }

rfcavity :set_functions {   drift_track = solenoid_drift,
                             kick_track = rfcavity_kick,
                           fringe_track = rfcavity_fringe }

twcavity :set_functions {   drift_track = twcavity_drift,
                             kick_track = twcavity_kick,
                           fringe_track = twcavity_fringe }

srotation   :set_functions { track = \_,m -> srotation(nil, m, e.angle) }
yrotation   :set_functions { track = \_,m -> yrotation(nil, m, e.angle) }
xrotation   :set_functions { track = \_,m -> xrotation(nil, m, e.angle) }
translation :set_functions { track = \_,m -> translate(nil, m, e.dx or 0,
                                                    e.dy or 0, e.dz or 0) }

-- track command --------------------------------------------------------------o

local _trk = {}

local function make_mtable (self)
  if self.mtable then return self.mtable end -- already built
  if not self.save then return nil end       -- nothing to build

  local sequence, drift, range, nturn in self
  local name, direction in sequence
  local nrow = sequence:length_of(range, nturn) * (drift and 2 or 1)

  return mtable 'track' {
    type='track', title=name, direction=direction,
    {'name'}, 'kind', 's', 'l',
    'x', 'px', 'y', 'py', 't', 'pt',
    [_trk]=_trk,
  } : reserve(math.min(nrow, 1e5))
end

local function fill_mtable (tbl, name, kind, m, l)
  -- keep order!
  tbl = tbl + { name, kind, m.s+l, l, m.x, m.px, m.y, m.py, m.t, m.pt }
end

local function make_mflow (self)
  local sequence, beam, mflow in self

  if not is_nil(mflow) then
    if sequence ~= mflow.seq then -- new sequence -> update
      local len, dir = #sequence, sequence.direction
      mflow.ds, mflow.iturn, mflow.dir, mflow.nlen = 0, 0, dir, len
      mflow.seq = sequence
    end
    if beam ~= mflow.beam then -- new beam -> update
      mflow.beam, mflow.dirchg = beam, mflow.dir*beam.charge
    end
    return mflow
  end

  local x, px, y, py, t, pt, X0 in self
  x  = x  or X0.x  or X0[1] or 0
  px = px or X0.px or X0[2] or 0
  y  = y  or X0.y  or X0[3] or 0
  py = py or X0.py or X0[4] or 0
  t  = t  or X0.t  or X0[5] or 0
  pt = pt or X0.pt or X0[6] or 0

  local save, drift, nstep, nslice, method, total_path in self
  local len, dir = #sequence, sequence.direction
  local T = total_path == true and 0 or 1

  return { x=x, px=px, y=y, py=py, t=t, pt=pt, T=T,         -- initial vars
           nmul=0, knl={}, ksl={}, pnl={}, psl={},          -- internal vars
           s=0, ds=0, iturn=0, dir=dir, nlen=len, ndft=0,   -- internal status
           selm={},                                         -- subelement stack
           nst=nstep, nsl=nslice, method=method,            -- user setup
           seq=sequence, save=save, drift=save and drift,   -- user status
           beam=beam, dirchg = dir*beam.charge,             -- user beam
           [_trk]=_trk }
end

local function exec (self)
  assert(self[_trk], "invalid argument #1 (survey expected)")
  local seq  = assert(self.sequence, "missing sequence")
  local beam = assert(self.beam    , "missing beam")
  assert(is_sequence(seq), "invalid sequence")
  assert(is_beam(beam)   , "invalid beam")

  -- build or update mflow and mtable
  local map = make_mflow (self)
  local tbl = make_mtable(self)

  assert(is_nil(tbl) or tbl[_trk] == _trk, "invalid track table")
  assert(               map[_trk] == _trk, "invalid track map"  )

  -- retrieve information
  local nlen, ndft, save, drift in map
  local range, nturn in self

  -- dynamic tracking
  for i,elm in seq:iter(range, nturn) do

    -- implicit drift
    local ds in map
    if ds >= minlen then
      straight_drift(nil, map, ds)
      if drift and elm:is_selected(observe) then
        ndft = ndft+1
        fill_mtable(tbl, 'DRIFT_'..ndft, 'drift', map, ds)
      end
      map.s, map.ds = map.s+ds, 0
    elseif ds <= -minlen then
      error(string.format("negative implicit drift %s in %s['%s'] at %s",
            ds, seq.name, elm.name, map.s))
    end

    -- sequence element
    local l in elm
    local tbl2, map2 = elm:track(map, tbl)
    if tbl2 then return tbl2, map2 end -- stop (e.g. slink)
    if save and elm:is_selected(observe) then
      fill_mtable(tbl, elm.name, elm.kind, map, l)
    end

    -- update map s, ds, iturn
    if i < nlen then
      map.ds = seq:spos(i+1) - (seq:spos(i)+l) -- patch z+dz?
    else
      map.ds, map.iturn = 0, map.iturn+1
    end
    map.s = map.s+l
  end

  map.ndft = ndft
  return tbl, map
end

-- track command template

local track = Command 'track' {
  X0={0,0,0,0,0,0}, nturn=0, drift=true, save=true,
  nstep=1, nslice=2, method='simple', total_path=false,
  exec=exec, [_trk]=true,
} :set_readonly()

-- end ------------------------------------------------------------------------o
return {
  track  = track,
  __help = __help,
}
