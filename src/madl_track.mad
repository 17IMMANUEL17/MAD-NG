--[=[
 o-----------------------------------------------------------------------------o
 |
 | Track module
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: I. Shreyber, irina.tecker at cern.ch
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - TODO

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local element, mtable, command                                  in MAD
local fnone                                                     in MAD.gfunc
local is_nil, is_number, is_sequence, is_beam                   in MAD.typeid
local errorf                                                    in MAD.utility
local minlen                                                    in MAD.constant
local observe                                                   in element.flags

-- dynamic maps ---------------------------------------------------------------o

local dynmap = require 'madl_dynmap'

-- integrator schemes ---------------------------------------------------------o

local symint = require 'madl_symint'

-- sub element tracking -------------------------------------------------------o

local function track_subelm (elm, m, symint)
  local track_drift, track_kick in elm
  local selm, selm_s in m

  -- save current sub-element and sub-position
  local nselm = #selm
  selm[nselm], selm_s[nselm] = elm, 0

  -- sub-tracking
  local n = #elm
  for i=1,n do
    -- implicit drift
    local dl = elm:spos(i) - selm_s[nselm]
    if dl >= minlen then
      symint(elm, m, dl, track_drift, track_kick)
      selm_s[nelm] = selm_s[nelm] + dl
    elseif dl <= -minlen then
      errorf("invalid sub-element %s['%s'] relative position at %sm",
             m.sequence.name, elm[i].name, dl)
    end

    -- sub-element
    elm[i]:track(m)
    selm_s[nelm] = selm_s[nelm] + elm[i].l
  end

  -- last implicit drift (if any)
  local dl = elm.l - elm:spos(n)
  if dl >= minlen then
    symint(elm, m, dl, track_drift, track_kick)
  elseif dl <= -minlen then
    errorf("invalid sub-element %s['%s'] relative position at %sm",
           m.sequence.name, elm[n].name, dl)
  end

  -- remove current sub-element
  selm[nselm] = nil
end

-- sub element for backtracking -----------------------------------------------o

local function trackback_subelm (elm, m, symint)
  local track_drift, track_kick in elm
  local selm, selm_s in m

  -- save current sub-element and sub-position
  local nselm = #selm
  selm[nselm], selm_s[nselm] = elm, 0

  -- sub-tracking
  local n = #elm
  for i=n,1,-1 do
    -- implicit drift
    local dl = selm_s[nselm] - (elm:spos(i) + elm[i].l)
    if dl <= -minlen then
      symint(elm, m, dl, track_drift, track_kick)
      selm_s[nelm] = selm_s[nelm] + dl
    elseif dl >= minlen then
      errorf("invalid sub-element %s['%s'] relative position at %sm",
             m.sequence.name, elm[i].name, dl)
    end

    -- sub-element
    elm[i]:trackback(m)
    selm_s[nelm] = selm_s[nelm] - elm[i].l
  end

  -- last implicit drift (if any)
  local dl = -elm:spos(1)
  if dl <= -minlen then
    symint(elm, m, dl, track_drift, track_kick)
  elseif dl <= -minlen then
    errorf("invalid sub-element %s['%s'] relative position at %sm",
           m.sequence.name, elm[n].name, dl)
  end

  -- remove current sub-element
  selm[nselm] = nil
end

-- element tracking -----------------------------------------------------------o

local function track_patch (elm, m, pos)
  if pos == 'entry'
  then entry_patch(elm, m)
  else  exit_patch(elm, m)
  end
end

local function track_thin (elm, m) -- e.g. multipole
  get_mult(elm, m) -- load strengths in map

  if m.has_k == false then return end

  track_patch(elm, m, 'entry')
  thin_kick  (elm, m)
  track_patch(elm, m, 'exit' )
end

local function track_drift (elm, m) -- e.g. monitor
  local no_selm = #m.selm == 0

  track_patch(elm, m, 'entry')

  if no_selm and #elm == 0 then -- any surrounding or sub-elements?
    symint.thick(elm, m, m.el, straight_drift)
  elseif no_selm then
    track_subelm(elm, m, straight_drift)
  else
    track_subelm(elm, m, symint[elm.method or m.mth])
  end

  track_patch(elm, m, 'exit')
end

local function track_thick (elm, m) -- e.g. sbend, rbend, quadrupole, ...
  get_kmult(elm, m)   -- load strengths in map

  if m.has_k == false then -- no strengths in elm
    return track_drift(elm, m)
  end

  track_patch(elm, m, 'entry')
  elm:track_fringe(m, 'entry')

  local symint = symint[elm.method or m.mth]
  if #elm == 0 then   -- any sub-elements?
    symint  (elm, m, m.el, elm.track_drift, elm.track_kick)
  else
    track_subelm(elm, m, symint)
  end

  elm:track_fringe(m, 'exit')
  track_patch(elm, m, 'exit')
end

-- element for tracking back --------------------------------------------------o

local trackback_patch = track_patch

local function trackback_thin (elm, m) -- e.g. multipole
  get_mult(elm, m) -- load strengths in map

  if m.has_k == false then return end

  trackback_patch(elm, m, 'exit' )
  thin_kick      (elm, m)
  trackback_patch(elm, m, 'entry')
end

local function trackback_drift (elm, m) -- e.g. monitor
  local no_selm = #m.selm == 0

  trackback_patch(elm, m, 'exit')

  if no_selm and #elm == 0 then -- any surrounding or sub-elements?
    symint.thick(elm, m, m.el, straight_drift)
  elseif no_selm then
    trackback_subelm(elm, m, straight_drift)
  else
    trackback_subelm(elm, m, symint[elm.method or m.mth])
  end

  trackback_patch (elm, m, 'entry')
end


local function trackback_thick (elm, m) -- e.g. sbend, rbend, quadrupole, ...
  get_kmult(elm, m)   -- load strengths in map

  if m.has_k == false then -- no strengths in elm
    return trackback_drift(elm, m)
  end

  trackback_patch(elm, m, 'exit')
  elm:track_fringe    (m, 'exit')

  local symint = symint[elm.method or m.mth]
  if #elm == 0 then   -- any sub-elements ?
    symint      (elm, m, m.el, elm.track_drift, elm.track_kick)
  else
    trackback_subelm(elm, m, symint)
  end

  elm:track_fringe    (m, 'entry')
  trackback_patch(elm, m, 'entry')
end

-- sequence tracking ----------------------------------------------------------o

local dft = element.drift {}

local function sequ_track (seq, map, rng_, ntrn_)
  local tbl = map.mtable

  -- retrieve information
  local save, drift, nlen in map

  -- dynamic tracking
  for i,elm in seq:iter(rng_, ntrn_, 1) do

    -- implicit drift
    local dl in map
    if dl >= minlen then
      straight_drift(nil, map, dl)
      if drift and elm:is_selected(observe) then
        map.ndft = map.ndft+1
        dft.name = 'DRIFT_'..map.ndft
        tbl:fill(dft, map, dl)
      end
      map.s, map.dl = map.s+dl, 0 -- update s
    elseif dl <= -minlen then
      errorf("negative implicit drift of %sm in %s['%s'] at %sm",
            dl, seq.name, elm.name, map.s)
    end

    -- sequence element
    map.el = elm.l
    local stop = elm:track(map)
    if stop then return tbl, map end -- stop (e.g. slink)

    local el in map
    if save and elm:is_selected(observe) then
      tbl:fill(elm, map, el)
    end
    map.s = map.s + el -- update s

    -- update dl
    if i == nlen
    then map.dl = 0
    else map.dl = seq:spos(i+1) - (seq:spos(i) + el) -- patch and dl?
    end
  end

  return tbl, map
end

-- sequence backtracking ------------------------------------------------------o

local function sequ_trackback (seq, map, rng_, ntrn_)
  local tbl = map.mtable

  -- retrieve information
  local save, drift, nlen in map

  -- dynamic tracking
  for i,elm in seq:iter(rng_, ntrn_, -1) do

    -- implicit drift
    local dl in map
    if dl <= -minlen then
      straight_drift(nil, map, dl)
      if drift and elm:is_selected(observe) then
        map.ndft = map.ndft+1
        dft.name = 'DRIFT_'..map.ndft
        tbl:fill(dft, map, dl)
      end
      map.s, map.dl = map.s + dl, 0 -- update s
    elseif dl >= minlen then
      errorf("negative implicit drift of %sm in %s['%s'] at %sm",
             dl, seq.name, elm.name, map.s)
    end

    -- sequence element
    map.el = -elm.l
    local stop = elm:trackback(map)
    if stop then return tbl, map end -- stop (e.g. slink)

    local el in map
    if save and elm:is_selected(observe) then
      tbl:fill(elm, map, el)
    end
    map.s = map.s + el -- update s

    -- update dl
    if i == 1
    then map.dl = 0
    else map.dl = seq:spos(i-1) + seq[i-1].l - seq:spos(i) -- patch and dl?
    end
  end

  return tbl, map
end

-- special --------------------------------------------------------------------o

local special_track = fnone

local invalid_track = \e ->
  errorf("invalid element %s of kind %s with length %s", e.name, e.kind, e.l)

-- load maps into elements ----------------------------------------------------o

local E = element

E.sequence :set_readonly(false)

E.  extra_element :set_methods { track     = invalid_track,
                                 trackback = invalid_track }
E. thin_element   :set_methods { track     = track_thin,
                                 trackback = track_thinback }

E.drift_element   :set_methods { track     = track_drift,
                                 trackback = track_driftback }

E.thick_element   :set_methods { track     = track_thick,
                                 trackback = track_thickback }

E.sequence        :set_methods { track     = sequ_track,
                                 trackback = sequ_trackback }

E.special         :set_methods { track     = special_track,
                                 trackback = special_track }

E.patch           :set_methods { track     = track_patch,
                                 trackback = track_patchback }

-- specialized maps

E.thick_element :set_methods { track_drift  = straight_drift,
                               track_kick   = straight_kick,
                               track_fringe = straight_fringe }

E.sbend         :set_methods { track_drift  = sbend_drift,
                               track_kick   = polar_kick,
                               track_fringe = sbend_fringe }

E.combined      :set_methods { track_drift  = combined_drift,
                               track_kick   = combined_kick,
                               track_fringe = sbend_fringe }

E.rbend         :set_methods { track_drift  = rbend_drift,
                               track_kick   = rfcavity_kick,
                               track_fringe = straight_fringe }

E.quadrupole    :set_methods { track_drift  = quadrupole_drift,
                               track_kick   = quadrupole_kick,
                               track_fringe = straight_fringe }

E.solenoid      :set_methods { track_drift  = solenoid_drift,
                               track_kick   = rfcavity_kick,
                               track_fringe = solenoid_fringe }

E.rfcavity      :set_methods { track_drift  = solenoid_drift,
                               track_kick   = rfcavity_kick,
                               track_fringe = rfcavity_fringe }

E.twcavity      :set_methods { track_drift  = twcavity_drift,
                               track_kick   = twcavity_kick,
                               track_fringe = twcavity_fringe }

-- TODO: patches
E.srotation   :set_methods { track = \e,m -> srotation(nil, m, e.angle) }
E.yrotation   :set_methods { track = \e,m -> yrotation(nil, m, e.angle) }
E.xrotation   :set_methods { track = \e,m -> xrotation(nil, m, e.angle) }
E.translate   :set_methods { track = \e,m -> translate(nil, m, e.dx or 0,
                                                       e.dy or 0, e.dz or 0) }
E.changeref   :set_methods { track = \_,m -> changeref(nil, m) }
E.changedir   :set_methods { track = \_,m -> changedir(nil, m) }
E.changenrj   :set_methods { track = \_,m -> changenrj(nil, m) }

E.sequence :set_readonly()

-- track helper ---------------------------------------------------------------o

local _trk = {}

local function fill_mtable (self, elm, m, l)
  -- keep order!
  self = self+{ elm.name, elm.kind, m.s+l, l, m.x, m.px, m.y, m.py, m.t, m.pt }
end

local function make_mtable (self)
  if self.mtable then
    assert(self.mtable[_trk] == _trk, "corrupted tracked mtable")
    return self.mtable
  end

  local sequence, drift, range, nturn, sdir in self
  local nrow = sequence:length_of(range, nturn) * (drift and 2 or 1)

  return mtable 'track' {
    type='track', title=sequence.name, sdir=sdir, reserve=nrow,
    {'name'}, 'kind', 's', 'l', 'x', 'px', 'y', 'py', 't', 'pt',
    [_trk]=_trk,
  } : set_methods { fill=fill_mtable }
end

local function update_mflow (self)
  local sequence, beam, sdir, mflow in self

  -- sanity checks
  assert(mflow[_trk] == _trk, "corrupted tracked mflow" )
  if mflow.save then
    assert(mflow.mtable[_trk] == _trk, "corrupted tracked mtable")
  end
  assert(is_beam    (mflow.beam    ), "corrupted tracked beam"    )
  assert(is_sequence(mflow.sequence), "corrupted tracked sequence")

  -- update with proper precedence
  if sequence and sequence ~= mflow.sequence then -- new sequence -> update
    assert(is_sequence(sequence), "invalid sequence")
    local len, seqdir = #sequence, sequence.dir
     mflow.sequ, mflow.dl, mflow.seqdir, mflow.nlen = sequence, 0, seqdir, len
  end
  if seqdir and seqdir ~= mflow.mdir then -- new direction -> update
    mflow.dl, mflow.mdir = 0, direction
  end
  if beam and beam ~= mflow.beam then -- new beam -> update
    assert(is_beam(beam), "invalid beam")
    mflow.beam, mflow.bdir = beam, mflow.sdir*mflow.mdir*beam.charge
  end

  return mflow
end

local function make_mflow (self)
  if self.mflow then
    return update_mflow(self)
  end

  local beam, sequence in self -- mandatory
  assert(is_beam(beam)        , "invalid beam")
  assert(is_sequence(sequence), "invalid sequence")

  local s, x, px, y, py, t, pt, X0 in self
  s  = s  or X0.s  or          0
  x  = x  or X0.x  or X0[1] or 0
  px = px or X0.px or X0[2] or 0
  y  = y  or X0.y  or X0[3] or 0
  py = py or X0.py or X0[4] or 0
  t  = t  or X0.t  or X0[5] or 0
  pt = pt or X0.pt or X0[6] or 0

  local save, drift, nstep, nslice, naction, method, total_path in self
  local nlen, sdir, mdir = #sequence, sequence.direction, self.direction
  local T = total_path == true and 1 or 0

  local mtable = save and make_mtable(self)

  return { x=x, px=px, y=y, py=py, t=t, pt=pt, T=T,          -- initial vars
           nmul=0, knl={}, ksl={}, pnl={}, psl={},           -- internal vars
           s=s, dl=0, el=0, nlen=nlen, ndft=0,               -- internal states
           selm={}, selm_s={},                               -- subelement stack
           nst=nstep, nsl=nslice, nact=naction, mth=method,  -- user setup
           save=save, drift=save and drift,                  -- user status
           sdir=sdir, mdir=mdir, bdir=sdir*mdir*beam.charge, -- directions
           sequence=sequence, beam=beam, mtable=mtable,      -- attached objects
           [_trk]=_trk }                                     -- tag
end

-- track command --------------------------------------------------------------o

local function exec (self)
  assert(self[_trk], "invalid argument #1 (track expected)")
  local map = make_mflow(self)                          -- build mflow
  local range, nturn in self                            -- range of tracking

  if map.mdir == 1
  then return map.sequence:    track(map, range, nturn) --     track sequence
  else return map.sequence:trackback(map, range, nturn) -- trackback sequence
  end
end

-- track command template

local track = command 'Track' {
  nturn=0, direction=1, total_path=false, drift=true, save=true, onestep=false,
  nstep=1, nslice=2, method='simple',
  exec=exec, [_trk]=true,
} :set_methods { naction=fnone } :set_readonly()

-- end ------------------------------------------------------------------------o
return { track = track }
