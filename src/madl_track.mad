--[=[
 o-----------------------------------------------------------------------------o
 |
 | Track module
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: I. Shreyber, irina.tecker at cern.ch
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - TODO

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local element, mtable, command                                  in MAD
local is_nil, is_number, is_sequence, is_beam                   in MAD.typeid
local minlen                                                    in MAD.constant
local observe                                                   in element.flags

-- dynamic maps ---------------------------------------------------------------o

local dynmap = require 'madl_dynmap'

-- integrator schemes ---------------------------------------------------------o

local symint = require 'madl_symint'

-- sub element tracking -------------------------------------------------------o

local function subelm_track (elm, m, symint)
  local drift_track, kick_track in elm
  local selm, selm_s in m

  -- save current sub-element and sub-position
  local nselm = #selm
  selm[nselm], selm_s[nselm] = elm, 0

  -- sub-tracking
  local n = #elm
  for i=1,n do
    -- implicit drift
    local dl = elm:spos(i) - selm_s[nselm]
    if dl >= minlen then
      symint(elm, m, dl, drift_track, kick_track)
      selm_s[nelm] = selm_s[nelm] + dl
    elseif dl <= -minlen then
      error(string.format("invalid sub-element %s['%s'] relative position at %sm",
            m.sequence.name, elm[i].name, dl))
    end

    -- sub-element
    elm[i]:track(m)
    selm_s[nelm] = selm_s[nelm] + elm[i].l
  end

  -- last implicit drift (if any)
  local dl = elm.l - elm:spos(n)
  if dl >= minlen then
    symint(elm, m, dl, drift_track, kick_track)
  elseif dl <= -minlen then
    error(string.format("invalid sub-element %s['%s'] relative position at %sm",
          m.sequence.name, elm[n].name, dl))
  end

  -- remove current sub-element
  selm[nselm] = nil
end

-- sub element for backtracking ---------------------------------------------------o

local function subelm_trackback (elm, m, symint)
  local drift_track, kick_track in elm
  local selm, selm_s in m

  -- save current sub-element and sub-position
  local nselm = #selm
  selm[nselm], selm_s[nselm] = elm, 0

  -- sub-tracking
  local n = #elm
  for i=n,1,-1 do
    -- implicit drift
    local dl = selm_s[nselm] - (elm:spos(i) + elm[i].l)
    if dl <= -minlen then
      symint(elm, m, dl, drift_track, kick_track)
      selm_s[nelm] = selm_s[nelm] + dl
    elseif dl >= minlen then
      error(string.format("invalid sub-element %s['%s'] relative position at %sm",
            m.sequence.name, elm[i].name, dl))
    end

    -- sub-element
    elm[i]:trackback(m)
    selm_s[nelm] = selm_s[nelm] - elm[i].l
  end

  -- last implicit drift (if any)
  local dl = -elm:spos(1)
  if dl <= -minlen then
    symint(elm, m, dl, drift_track, kick_track)
  elseif dl <= -minlen then
    error(string.format("invalid sub-element %s['%s'] relative position at %sm",
          m.sequence.name, elm[n].name, dl))
  end

  -- remove current sub-element
  selm[nselm] = nil
end

-- element tracking -----------------------------------------------------------o

-- TODO:
local function patch_track (elm, m, pos)
  if pos == 'entry'
  then entry_patch(elm, m)
  else  exit_patch(elm, m)
  end
end

local function thin_track (elm, m) -- e.g. multipole
  get_mult(elm, m) -- load strengths in map

  if m.has_k == false then return end

  patch_track(elm, m, 'entry')
  thin_kick  (elm, m)
  patch_track(elm, m, 'exit' )
end

local function drift_track (elm, m) -- e.g. monitor
  local no_selm = #m.selm == 0

  patch_track(elm, m, 'entry')

  if no_selm and #elm == 0 then -- any surrounding or sub-elements?
    symint.thick(elm, m, m.el, straight_drift)
  elseif no_selm then
    subelm_track(elm, m, straight_drift)
  else
    subelm_track(elm, m, symint[elm.method or m.mth])
  end

  patch_track(elm, m, 'exit')
end

local function thick_track (elm, m) -- e.g. sbend, rbend, quadrupole, ...
  get_kmult(elm, m)   -- load strengths in map

  if m.has_k == false then -- no strengths in elm
    return drift_track(elm, m)
  end

  patch_track(elm, m, 'entry')
  elm:fringe_track(m, 'entry')

  local symint = symint[elm.method or m.mth]
  if #elm == 0 then   -- any sub-elements?
    symint  (elm, m, m.el, elm.drift_track, elm.kick_track)
  else
    subelm_track(elm, m, symint)
  end

  elm:fringe_track(m, 'exit')
  patch_track(elm, m, 'exit')
end

-- element for tracking back --------------------------------------------------o

local patch_trackback = patch_track

local function thin_trackback (elm, m) -- e.g. multipole
  get_mult(elm, m) -- load strengths in map

  if m.has_k == false then return end

  patch_trackback(elm, m, 'exit' )
  thin_kick      (elm, m)
  patch_trackback(elm, m, 'entry')
end

local function drift_trackback (elm, m) -- e.g. monitor
  local no_selm = #m.selm == 0

  patch_trackback(elm, m, 'exit')

  if no_selm and #elm == 0 then -- any surrounding or sub-elements?
    symint.thick(elm, m, m.el, straight_drift)
  elseif no_selm then
    subelm_trackback(elm, m, straight_drift)
  else
    subelm_trackback(elm, m, symint[elm.method or m.mth])
  end

  patch_trackback (elm, m, 'entry')
end


local function thick_trackback (elm, m) -- e.g. sbend, rbend, quadrupole, ...
  get_kmult(elm, m)   -- load strengths in map

  if m.has_k == false then -- no strengths in elm
    return drift_trackback(elm, m)
  end

  patch_trackback(elm, m, 'exit')
  elm:fringe_track    (m, 'exit')

  local symint = symint[elm.method or m.mth]
  if #elm == 0 then   -- any sub-elements ?
    symint      (elm, m, m.el, elm.drift_track, elm.kick_track)
  else
    subelm_trackback(elm, m, symint)
  end

  elm:fringe_track    (m, 'entry')
  patch_trackback(elm, m, 'entry')
end

-- sequence tracking ----------------------------------------------------------o

local dft = element.drift {}

local function sequ_trackback (seq, map, rng_, ntrn_)
  local tbl = map.mtable

  -- retrieve information
  local save, drift, nlen in map

  -- dynamic tracking
  for i,elm in seq:iter(rng_, ntrn_, 1) do

    -- implicit drift
    local dl in map
    if dl >= minlen then
      straight_drift(nil, map, dl)
      if drift and elm:is_selected(observe) then
        map.ndft = map.ndft+1
        dft.name = 'DRIFT_'..map.ndft
        tbl:fill(dft, map, dl)
      end
      map.s, map.dl = map.s + dl, 0 -- update s
    elseif dl <= -minlen then
      error(string.format("invalid implicit drift of %sm in %s['%s'] at %sm",
            dl, seq.name, elm.name, map.s))
    end

    -- sequence element
    map.el = elm.l
    local stop = elm:track(map)
    if stop then return tbl, map end -- stop (e.g. slink)

    local el in map
    if save and elm:is_selected(observe) then
      tbl:fill(elm, map, el)
    end
    map.s = map.s + el -- update s

    -- update dl
    if i == nlen
    then map.dl = 0
    else map.dl = seq:spos(i+1) - (seq:spos(i) + el) -- patch and dl?
    end
  end

  return tbl, map
end

-- sequence backtracking ------------------------------------------------------o

local function sequ_trackback (seq, map, rng_, ntrn_)
  local tbl = map.mtable

  -- retrieve information
  local save, drift, nlen in map

  -- dynamic tracking
  for i,elm in seq:iter(rng_, ntrn_, -1) do

    -- implicit drift
    local dl in map
    if dl <= -minlen then
      straight_drift(nil, map, dl)
      if drift and elm:is_selected(observe) then
        map.ndft = map.ndft+1
        dft.name = 'DRIFT_'..map.ndft
        tbl:fill(dft, map, dl)
      end
      map.s, map.dl = map.s + dl, 0 -- update s
    elseif dl >= minlen then
      error(string.format("invalid implicit drift of %sm in %s['%s'] at %sm",
            dl, seq.name, elm.name, map.s))
    end

    -- sequence element
    map.el = -elm.l
    local stop = elm:trackback(map)
    if stop then return tbl, map end -- stop (e.g. slink)

    local el in map
    if save and elm:is_selected(observe) then
      tbl:fill(elm, map, el)
    end
    map.s = map.s + el -- update s

    -- update dl
    if i == 1
    then map.dl = 0
    else map.dl = seq:spos(i-1) + seq[i-1].l - seq:spos(i) -- patch and dl?
    end
  end

  return tbl, map
end

-- special --------------------------------------------------------------------o

local special_track = \ -> ()

local invalid_track = \e ->
  errorf("invalid element %s of kind %s with length %s", e.name, e.kind, e.l)

-- load maps into elements ----------------------------------------------------o

local E = element

E.  extra_element :set_methods { track     = invalid_track,
                                 trackback = invalid_track }
E.special_element :set_methods { track     = special_track,
                                 trackback = special_track }

E.patch_element :set_methods {    track = patch_track,
                              trackback = patch_trackback }

E. thin_element :set_methods {    track = thin_track,
                              trackback = thin_trackback }

E.drift_element :set_methods {    track = drift_track,
                              trackback = drift_trackback }

E.thick_element :set_methods {    track = thick_track,
                              trackback = thick_trackback }

E.sequence :set_readonly(false)
                :set_methods {    track = sequ_track,
                              trackback = sequ_trackback } :set_readonly()

-- specialized maps

E.thick_element :set_methods { drift_track = straight_drift,
                                kick_track = straight_kick,
                              fringe_track = straight_fringe }

E.sbend         :set_methods { drift_track = sbend_drift,
                                kick_track = polar_kick,
                              fringe_track = sbend_fringe }

E.combined      :set_methods { drift_track = combined_drift,
                                kick_track = combined_kick,
                              fringe_track = sbend_fringe }

E.rbend         :set_methods { drift_track = rbend_drift,
                                kick_track = rfcavity_kick,
                              fringe_track = straight_fringe }

E.quadrupole    :set_methods { drift_track = quadrupole_drift,
                                kick_track = quadrupole_kick,
                              fringe_track = straight_fringe }

E.solenoid      :set_methods { drift_track = solenoid_drift,
                                kick_track = rfcavity_kick,
                              fringe_track = solenoid_fringe }

E.rfcavity      :set_methods { drift_track = solenoid_drift,
                                kick_track = rfcavity_kick,
                              fringe_track = rfcavity_fringe }

E.twcavity      :set_methods { drift_track = twcavity_drift,
                                kick_track = twcavity_kick,
                              fringe_track = twcavity_fringe }

-- TODO
E.changedir   :set_methods { track = \_,m -> changedir(nil, m) }
E.srotation   :set_methods { track = \e,m -> srotation(nil, m, e.angle) }
E.yrotation   :set_methods { track = \e,m -> yrotation(nil, m, e.angle) }
E.xrotation   :set_methods { track = \e,m -> xrotation(nil, m, e.angle) }
E.translate   :set_methods { track = \e,m -> translate(nil, m, e.dx or 0,
                                                       e.dy or 0, e.dz or 0) }

-- track helper ---------------------------------------------------------------o

local _trk = {}

local function fill_mtable (self, elm, m, l)
  -- keep order!
  self = self+{ elm.name, elm.kind, m.s+l, l, m.x, m.px, m.y, m.py, m.t, m.pt }
end

local function make_mtable (self)
  if self.mtable then
    assert(self.mtable[_trk] == _trk, "corrupted tracked mtable")
    return self.mtable
  end

  local sequence, drift, range, nturn, direction in self
  local nrow = sequence:length_of(range, nturn) * (drift and 2 or 1)

  return mtable 'track' {
    type='track', title=sequence.name, direction=direction, reserve=nrow,
    {'name'}, 'kind', 's', 'l', 'x', 'px', 'y', 'py', 't', 'pt',
    [_trk]=_trk,
  } : set_methods { fill=fill_mtable }
end

local function update_mflow (self)
  local sequence, beam, direction, mflow in self

  -- sanity checks
  assert(mflow[_trk] == _trk, "corrupted tracked mflow" )
  if mflow.save then
    assert(mflow.mtable[_trk] == _trk, "corrupted tracked mtable")
  end
  assert(is_beam    (mflow.beam    ), "corrupted tracked beam"    )
  assert(is_sequence(mflow.sequence), "corrupted tracked sequence")

  -- update with proper precedence
  if sequence and sequence ~= mflow.sequence then -- new sequence -> update
    assert(is_sequence(sequence), "invalid sequence")
    local len, sdir = #sequence, sequence.direction
    mflow.dl, mflow.sdir, mflow.nlen = 0, sdir, len
    mflow.sequence, mflow.bdir = sequence, sdir*mflow.beam.charge
  end
  if direction and direction ~= mflow.mdir then -- new direction -> update
    mflow.dl, mflow.mdir = 0, direction
  end
  if beam and beam ~= mflow.beam then -- new beam -> update
    assert(is_beam(beam), "invalid beam")
    mflow.beam, mflow.bdir = beam, mflow.sdir*mflow.mdir*beam.charge
  end

  return mflow
end

local function make_mflow (self)
  if self.mflow then
    return update_mflow(self)
  end

  local beam, sequence in self -- mandatory
  assert(is_beam(beam)        , "invalid beam")
  assert(is_sequence(sequence), "invalid sequence")

  local s, x, px, y, py, t, pt, X0 in self
  s  = s  or X0.s  or          0
  x  = x  or X0.x  or X0[1] or 0
  px = px or X0.px or X0[2] or 0
  y  = y  or X0.y  or X0[3] or 0
  py = py or X0.py or X0[4] or 0
  t  = t  or X0.t  or X0[5] or 0
  pt = pt or X0.pt or X0[6] or 0

  local save, drift, nstep, nslice, naction, method, total_path in self
  local nlen, sdir, mdir = #sequence, sequence.direction, self.direction
  local T = total_path == true and 1 or 0

  local mtable = save and make_mtable(self)

  return { x=x, px=px, y=y, py=py, t=t, pt=pt, T=T,          -- initial vars
           nmul=0, knl={}, ksl={}, pnl={}, psl={},           -- internal vars
           s=s, dl=0, el=0, nlen=nlen, ndft=0,               -- internal states
           selm={}, selm_s={},                               -- subelement stack
           nst=nstep, nsl=nslice, nact=naction, mth=method,  -- user setup
           save=save, drift=save and drift,                  -- user status
           sdir=sdir, mdir=mdir, bdir=sdir*mdir*beam.charge, -- directions
           sequence=sequence, beam=beam, mtable=mtable,      -- attached objects
           [_trk]=_trk }                                     -- tag
end

-- track command --------------------------------------------------------------o

local function exec (self)
  assert(self[_trk], "invalid argument #1 (track expected)")
  local map = make_mflow(self)                          -- build mflow
  local range, nturn in self                            -- range of tracking

  if map.mdir == 1
  then return map.sequence:    track(map, range, nturn) --     track sequence
  else return map.sequence:trackback(map, range, nturn) -- trackback sequence
  end
end

-- track command template

local track = command 'Track' {
  nturn=0, direction=1, total_path=false, drift=true, save=true,
  nstep=1, nslice=2, method='simple',
  exec=exec, [_trk]=true,
} :set_methods { naction=empty_track }
  :set_readonly()

-- end ------------------------------------------------------------------------o
return { track = track }
