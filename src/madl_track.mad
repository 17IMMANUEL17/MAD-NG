--[=[
 o-----------------------------------------------------------------------------o
 |
 | Track module
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: I. Shreyber, irina.tecker at cern.ch
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - TODO

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local element, mtable, command                                  in MAD
local is_sequence, is_beam, is_boolean, is_number, is_integer,
      is_table, is_implicit, is_callable, is_mappable           in MAD.typeid
local fnone                                                     in MAD.gfunc
local errorf, assertf                                           in MAD.utility
local minlen                                                    in MAD.constant
local observe                                                   in element.flags

-- dynamic maps ---------------------------------------------------------------o

local dynmap = require 'madl_dynmap'

-- integrator schemes ---------------------------------------------------------o

local symint = require 'madl_symint'

-- sub element tracking -------------------------------------------------------o

local function track_subelm (elm, m, symint)
  local track_drift, track_kick in elm
  local selm, selm_s in m

  -- save current sub-element and sub-position
  local nselm = #selm
  selm[nselm], selm_s[nselm] = elm, 0

  -- sub-tracking
  local n = #elm
  for i=1,n do
    -- implicit drift
    local dl = elm:spos(i) - selm_s[nselm]
    if dl >= minlen then
      symint(elm, m, dl, track_drift, track_kick)
      selm_s[nelm] = selm_s[nelm] + dl
    elseif dl <= -minlen then
      errorf("invalid sub-element %s['%s'] relative position at %sm",
             m.sequence.name, elm[i].name, dl)
    end

    -- sub-element
    elm[i]:track(m)
    selm_s[nelm] = selm_s[nelm] + elm[i].l
  end

  -- last implicit drift (if any)
  local dl = elm.l - elm:spos(n)
  if dl >= minlen then
    symint(elm, m, dl, track_drift, track_kick)
  elseif dl <= -minlen then
    errorf("invalid sub-element %s['%s'] relative position at %sm",
           m.sequence.name, elm[n].name, dl)
  end

  -- remove current sub-element
  selm[nselm] = nil
end

-- sub element for backtracking -----------------------------------------------o

local function trackback_subelm (elm, m, symint)
  local track_drift, track_kick in elm
  local selm, selm_s in m

  -- save current sub-element and sub-position
  local nselm = #selm
  selm[nselm], selm_s[nselm] = elm, 0

  -- sub-tracking
  local n = #elm
  for i=n,1,-1 do
    -- implicit drift
    local dl = selm_s[nselm] - (elm:spos(i) + elm[i].l)
    if dl <= -minlen then
      symint(elm, m, dl, track_drift, track_kick)
      selm_s[nelm] = selm_s[nelm] + dl
    elseif dl >= minlen then
      errorf("invalid sub-element %s['%s'] relative position at %sm",
             m.sequence.name, elm[i].name, dl)
    end

    -- sub-element
    elm[i]:trackback(m)
    selm_s[nelm] = selm_s[nelm] - elm[i].l
  end

  -- last implicit drift (if any)
  local dl = -elm:spos(1)
  if dl <= -minlen then
    symint(elm, m, dl, track_drift, track_kick)
  elseif dl <= -minlen then
    errorf("invalid sub-element %s['%s'] relative position at %sm",
           m.sequence.name, elm[n].name, dl)
  end

  -- remove current sub-element
  selm[nselm] = nil
end

-- element tracking -----------------------------------------------------------o

local function track_patch (elm, m, pos)
  if pos == 'entry'
  then entry_patch(elm, m)
  else  exit_patch(elm, m)
  end
end

local function track_thin (elm, m) -- e.g. multipole
  get_mult(elm, m) -- load strengths in map

  if m.has_k == false then return end

  track_patch(elm, m, 'entry')
  thin_kick  (elm, m)
  track_patch(elm, m, 'exit' )
end

local function track_drift (elm, m) -- e.g. monitor
  local no_selm = #m.selm == 0

  track_patch(elm, m, 'entry')

  if no_selm and #elm == 0 then -- any surrounding or sub-elements?
    symint.thick(elm, m, m.el, straight_drift)
  elseif no_selm then
    track_subelm(elm, m, straight_drift)
  else
    track_subelm(elm, m, symint[elm.method or m.mth])
  end

  track_patch(elm, m, 'exit')
end

local function track_thick (elm, m) -- e.g. sbend, rbend, quadrupole, ...
  get_kmult(elm, m)   -- load strengths in map

  if m.has_k == false then -- no strengths in elm
    return track_drift(elm, m)
  end

  track_patch(elm, m, 'entry')
  elm:track_fringe(m, 'entry')

  local symint = symint[elm.method or m.mth]
  if #elm == 0 then   -- any sub-elements?
    symint  (elm, m, m.el, elm.track_drift, elm.track_kick)
  else
    track_subelm(elm, m, symint)
  end

  elm:track_fringe(m, 'exit')
  track_patch(elm, m, 'exit')
end

-- element for tracking back --------------------------------------------------o

local trackback_patch = track_patch

local function trackback_thin (elm, m) -- e.g. multipole
  get_mult(elm, m) -- load strengths in map

  if m.has_k == false then return end

  trackback_patch(elm, m, 'exit' )
  thin_kick      (elm, m)
  trackback_patch(elm, m, 'entry')
end

local function trackback_drift (elm, m) -- e.g. monitor
  local no_selm = #m.selm == 0

  trackback_patch(elm, m, 'exit')

  if no_selm and #elm == 0 then -- any surrounding or sub-elements?
    symint.thick(elm, m, m.el, straight_drift)
  elseif no_selm then
    trackback_subelm(elm, m, straight_drift)
  else
    trackback_subelm(elm, m, symint[elm.method or m.mth])
  end

  trackback_patch (elm, m, 'entry')
end


local function trackback_thick (elm, m) -- e.g. sbend, rbend, quadrupole, ...
  get_kmult(elm, m)   -- load strengths in map

  if m.has_k == false then -- no strengths in elm
    return trackback_drift(elm, m)
  end

  trackback_patch(elm, m, 'exit')
  elm:track_fringe    (m, 'exit')

  local symint = symint[elm.method or m.mth]
  if #elm == 0 then   -- any sub-elements ?
    symint      (elm, m, m.el, elm.track_drift, elm.track_kick)
  else
    trackback_subelm(elm, m, symint)
  end

  elm:track_fringe    (m, 'entry')
  trackback_patch(elm, m, 'entry')
end

-- sequence tracking ----------------------------------------------------------o

local dft = element.drift {}

local function sequ_track (seq, map, rng_, ntrn_)
  local tbl = map.mtable

  -- retrieve information
  local save, drift, nlen in map

  -- dynamic tracking
  for i,elm in seq:iter(rng_, ntrn_, 1) do

    -- implicit drift
    local dl in map
    if dl >= minlen then
      straight_drift(nil, map, dl)
      if drift and elm:is_selected(observe) then
        map.ndft = map.ndft+1
        dft.name = 'DRIFT_'..map.ndft
        tbl:fill(dft, map, dl)
      end
      map.s, map.dl = map.s+dl, 0 -- update s
    elseif dl <= -minlen then
      errorf("negative implicit drift of %sm in %s['%s'] at %sm",
            dl, seq.name, elm.name, map.s)
    end

    -- sequence element
    map.el = elm.l
    local stop = elm:track(map)
    if stop then return tbl, map end -- stop (e.g. slink)

    local el in map
    if save and elm:is_selected(observe) then
      tbl:fill(elm, map, el)
    end
    map.s = map.s + el -- update s

    -- update dl
    if i == nlen
    then map.dl = 0
    else map.dl = seq:spos(i+1) - (seq:spos(i) + el) -- patch and dl?
    end
  end

  return tbl, map
end

-- sequence backtracking ------------------------------------------------------o

local function sequ_trackback (seq, map, rng_, ntrn_)
  local tbl = map.mtable

  -- retrieve information
  local save, drift, nlen in map

  -- dynamic tracking
  for i,elm in seq:iter(rng_, ntrn_, -1) do

    -- implicit drift
    local dl in map
    if dl <= -minlen then
      straight_drift(nil, map, dl)
      if drift and elm:is_selected(observe) then
        map.ndft = map.ndft+1
        dft.name = 'DRIFT_'..map.ndft
        tbl:fill(dft, map, dl)
      end
      map.s, map.dl = map.s + dl, 0 -- update s
    elseif dl >= minlen then
      errorf("negative implicit drift of %sm in %s['%s'] at %sm",
             dl, seq.name, elm.name, map.s)
    end

    -- sequence element
    map.el = -elm.l
    local stop = elm:trackback(map)
    if stop then return tbl, map end -- stop (e.g. slink)

    local el in map
    if save and elm:is_selected(observe) then
      tbl:fill(elm, map, el)
    end
    map.s = map.s + el -- update s

    -- update dl
    if i == 1
    then map.dl = 0
    else map.dl = seq:spos(i-1) + seq[i-1].l - seq:spos(i) -- patch and dl?
    end
  end

  return tbl, map
end

-- special --------------------------------------------------------------------o

local special_track = fnone

local invalid_track = \e ->
  errorf("invalid element %s of kind %s with length %s", e.name, e.kind, e.l)

-- load maps into elements ----------------------------------------------------o

local E = element

E.sequence :set_readonly(false)

E.  extra_element :set_methods { track     = invalid_track,
                                 trackback = invalid_track }
E. thin_element   :set_methods { track     = track_thin,
                                 trackback = track_thinback }

E.drift_element   :set_methods { track     = track_drift,
                                 trackback = track_driftback }

E.thick_element   :set_methods { track     = track_thick,
                                 trackback = track_thickback }

E.sequence        :set_methods { track     = sequ_track,
                                 trackback = sequ_trackback }

E.special         :set_methods { track     = special_track,
                                 trackback = special_track }

E.patch           :set_methods { track     = track_patch,
                                 trackback = track_patchback }

-- specialized maps

E.thick_element :set_methods { track_drift  = straight_drift,
                               track_kick   = straight_kick,
                               track_fringe = straight_fringe }

E.sbend         :set_methods { track_drift  = sbend_drift,
                               track_kick   = polar_kick,
                               track_fringe = sbend_fringe }

E.combined      :set_methods { track_drift  = combined_drift,
                               track_kick   = combined_kick,
                               track_fringe = sbend_fringe }

E.rbend         :set_methods { track_drift  = rbend_drift,
                               track_kick   = rfcavity_kick,
                               track_fringe = straight_fringe }

E.quadrupole    :set_methods { track_drift  = quadrupole_drift,
                               track_kick   = quadrupole_kick,
                               track_fringe = straight_fringe }

E.solenoid      :set_methods { track_drift  = solenoid_drift,
                               track_kick   = rfcavity_kick,
                               track_fringe = solenoid_fringe }

E.rfcavity      :set_methods { track_drift  = solenoid_drift,
                               track_kick   = rfcavity_kick,
                               track_fringe = rfcavity_fringe }

E.twcavity      :set_methods { track_drift  = twcavity_drift,
                               track_kick   = twcavity_kick,
                               track_fringe = twcavity_fringe }

-- TODO: patches
E.srotation   :set_methods { track = \e,m -> srotation(nil, m, e.angle) }
E.yrotation   :set_methods { track = \e,m -> yrotation(nil, m, e.angle) }
E.xrotation   :set_methods { track = \e,m -> xrotation(nil, m, e.angle) }
E.translate   :set_methods { track = \e,m -> translate(nil, m, e.dx or 0,
                                                       e.dy or 0, e.dz or 0) }
E.changeref   :set_methods { track = \_,m -> changeref(nil, m) }
E.changedir   :set_methods { track = \_,m -> changedir(nil, m) }
E.changenrj   :set_methods { track = \_,m -> changenrj(nil, m) }

E.sequence :set_readonly()

-- track mtable ---------------------------------------------------------------o

local _var = {}

local function save_all (elm, mflw, lw)
  if not elm:is_selected(observe) then return end

  local name, kind, l in elm
  local x, px, y, py, t, pt, sdir, tdir, spos, mtbl in mflw

  -- keep order!
  mtbl = mtbl + { name, kind, spos, l*lw*sdir, x, px, y, py, t, pt, tdir, 1 }
end

local function save_elm (elm, mflw, lw)
  if not is_implicit(elm) then save_all(elm, mflw, lw) end
end

local function make_mtable (self)
  local range, nturn, implicit in self
  local sequ = self.sequence
  local sdir = self.sdir -- s-direction of the tracking
  local nrow = sequ:length_of(range, nturn)*(implicit and 2 or 1)

  return mtable 'track' {
    type='track', title=sequ.name, sdir=sdir, reserve=nrow,
    {'name'}, 'kind', 's', 'l', 'x', 'px', 'y', 'py', 't', 'pt',
    'tdir',   -- t-direction of the tracking: sdir * seqdir
    'id',     -- particle or mapflow id
  }
end

-- track mflow ----------------------------------------------------------------o

local function make_mflow (self)
  if self.mflow then
    assert(is_table(self.mflow[_var]), "invalid mflow (track mflow expected)")
    return self.mflow
  end

  -- check sequence
  local sequ = assert(self.sequence, "missing sequence")
  assert(is_sequence(sequ), "invalid sequence")

  -- check beam
  local beam = assert(self.beam, "missing beam")
  assert(is_beam(beam), "invalid beam")

  -- retrieve initial conditions
  local s0, X0 in self
  assert(is_number  (s0), "invalid s0 (number expected)")
  assert(is_mappable(X0), "invalid X0 (mappable expected)")

  -- precedence of initial conditions
  local x, px, y, py, t, pt in self
  x  = x  or X0.x  or X0[1] or 0
  px = px or X0.px or X0[2] or 0
  y  = y  or X0.y  or X0[3] or 0
  py = py or X0.py or X0[4] or 0
  t  = t  or X0.t  or X0[5] or 0
  pt = pt or X0.pt or X0[6] or 0

  -- TODO: handle N mapflows or N particles
  -- X0={0,0,0,0,0,0}        -- initial coordinates
  -- X0={{0,0,0,0,0,0},....} -- initial list of coordinates
  -- X0=mapflow              -- initial mapflow
  -- X0={mapflow, ...}       -- initial list of mapflow
  -- mapdef=nil,             -- mapflow setup (X0 are their initial coordinates)

  --npar=npar,               -- number of particles or mapflows, #mflw
  --ipar=1,                  -- current particle or mapflow
  --part=table.new(npar,0),  -- list of particles or mapflows

  -- build iterator
  local range, sdir, nturn in self
  local iter, state, init = sequ:siter(range, nturn, sdir)

  -- build mtable
  local save, nofill, implicit in self
  assert(is_boolean(save) or is_callable(save),
                               "invalid save (boolean or callable expected)")
  assert(is_boolean(nofill)  , "invalid nofill (boolean expected)")
  assert(is_boolean(implicit), "invalid implicit (boolean expected)")

  -- saving data
  local mtbl, fill
  if save then
    mtbl = make_mtable(self)
    fill = is_callable(save) and save or implicit and save_all or save_elm
  else
    fill = fnone
  end

  -- time direction
  local tdir = sdir*sequ.dir
  assert(tdir == 1 or tdir == -1, "invalid time direction (1 or -1 expected)")

  -- totalpath
  local totalpath in self
  assert(is_boolean(totalpath), "invalid totalpath (boolean expected)")

  -- method
  local method in self
  local integr = symint[method]
  assertf(is_callable(integr), "invalid integration method '%s'", method)

  -- setup default sclicing
  local nslice in self
  assert(is_integer(nslice) and nslice > 0, "invalid nslice (positive integer expected)")

  -- retrieve default actions (avoid evaluation in case of functions)
  local atentry = self:var_raw('atentry') or fnone
  local atslice = self:var_raw('atslice') or fnone
  local atexit  = self:var_raw('atexit' ) or fnone
  assert(is_callable(atentry), "invalid atentry (callable expected)")
  assert(is_callable(atslice), "invalid atslice (callable expected)")
  assert(is_callable(atexit ), "invalid atexit (callable expected)")

  -- build mflow
  local mflw = {
    sequ=sequ,                         -- current sequence
    beam=beam,                         -- current beam
    mtbl=mtbl,                         -- current mtable (nil if no save)
    sdir=sdir,                         -- s-direction of tracking
    tdir=tdir,                         -- t-direction of tracking
--  bdir=tdir*beam.charge,             -- beam direction of tracking

    integr=integr,                     -- default integrator
    totalpath=false,                   -- t is the totalpath

    fill=fill,                         -- fill/add one row to mtable (if any)
    nofill=nofill,                     -- disable filling at the end of an element
    nslice=nslice,                     -- number of slice for each element

    s0=s0,                             -- initial s-position
    idx=init,                          -- index of the current element
    spos=s0,                           -- s-position of the current element entry
    npos=nil,                          -- integrator step: nil, 'first', 'last'

    atentry=atentry,                   -- action when entering an element
    atslice=atslice,                   -- action after each element slices
    atexit =atexit,                    -- action when exiting an element

    -- for processing elements
    nmul=0,                            -- current element number of multipoles
    knl=table.new(15,0),               -- current element multipoles
    ksl=table.new(15,0),               -- current element multipoles skew
    pnl=table.new(15,0),               -- current element multipoles phases
    psl=table.new(15,0),               -- current element multipoles shew phases

    -- for processing subelements
    selm=table.new(3,0),               -- subelement stack

    -- internal vars for track
    [_var]={iter=iter, state=state},   -- iterator and iteraror state
  }

  return mflw
end

-- track command --------------------------------------------------------------o

local function exec (self)
  -- build mflow
  local mflw = make_mflow(self)

  -- check number of element to track
  local nstep in self
  if nstep == 0 then return mflw.mtbl, mflw end

  -- retrieve information
  local s0, sdir, idx, mtbl, fill, nofill, atentry, atexit in mflw
  local iter, state in mflw[_var]

  -- disable fill locally
  if nofill ~= false then fill = fnone end

  -- geometric tracking
  for i,elm,spos in iter, state, idx do
    mflw.idx, mflw.spos = i, s0+spos

        atentry(elm, mflw)
    elm:track  (     mflw, 1)
        atexit (elm, mflw)

    mflw.spos = s0+spos+elm.l*sdir
        fill   (elm, mflw, 1)

    -- check remaining number of element to track
    nstep = nstep-1
    if nstep == 0 then return mtbl, mflw, elm end
  end

  return mtbl, mflw
end

local track = command 'Track' {
  sequence=nil,     -- sequence (required)                                (mflw)
  beam=nil,         -- beam (required)                                    (mflw)
  range=nil,        -- range of tracking                                  (iter)
  sdir=1,           -- s-direction of tracking (1 or -1)                  (mflw)

  s0=0,             -- initial s                                          (mflw)
  X0={0,0,0,0,0,0}, -- initial coordinates (or mapflow, or list of)       (mflw)

  mapdef=nil,       -- setup for mapflow                                  (mflw)
  method='simple',  -- default integrator                                 (mflw)
  totalpath=false,  -- t is the totalpath                                 (mflw)

  nturn=1,          -- number of turns                                    (iter)
  nstep=-1,         -- number of elements to track                        (iter)
  nslice=1,         -- number of slice for each element                   (mflw)

  save=true,        -- create mtable and set fill to save data            (mtbl)
  nofill=false,     -- disable filling at the end of an element           (mflw)
  implicit=true,    -- save also implicit elements                        (mtbl)

  atentry=nil,      -- action to call when entering an element            (mflw)
  atslice=nil,      -- action to call after each element slices           (mflw)
  atexit=nil,       -- action to call when exiting an element             (mflw)

  mflow=nil,      -- current mflow, exclusive with other attributes except nstep

  exec=exec,      -- command to execute upon children creation
} :set_readonly() -- reference survey command is readonly

-- end ------------------------------------------------------------------------o
return { track = track }
