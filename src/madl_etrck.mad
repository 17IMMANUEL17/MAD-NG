--[=[
 o-----------------------------------------------------------------------------o
 |
 | Track element methods (loaded by track)
 |
 | Methodical Accelerator Design - Copyright (c) 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - TODO

 o-----------------------------------------------------------------------------o
]=]

--[=[
Notes about directions and quantities:
  edir: element direction affects curvatures (edir = seq.dir).
  sdir: track direction s affects lengths    (sdir = cmd.dir).
  tdir: time direction t  affects angles     (tdir = edir x sdir).
  bdir: beam direction    affects strengths  (bdir = edir x sdir x chg).
--]=]

-- locals ---------------------------------------------------------------------o

local element, damap, symint, option, warn, _C                  in MAD

local fnil, bind3rd                                             in MAD.gfunc
local fact, arc2cord, sqrt, sin, cos, atan2                     in MAD.gmath
local errorf                                                    in MAD.utility
local minlen, minang, minstr, clight, twopi, pi_2               in MAD.constant
local is_implicit                                               in element.drift

local type = type

local abs, max in math -- ensure that abs will not work on GTPSA.

-- redefine abs for this module (only!)
local abs = \a -> type(a) == "number" and abs(a) or abs(a:get0())

-- constants
local minvolt = 1e-6

local getanbnr in require("madl_curvmul")

-- integrator schemes ---------------------------------------------------------o

local thinonly, thickonly, driftonly, DKD, TKT, KMK                in MAD.symint

-- dynamic maps ---------------------------------------------------------------o

-- straight elements (DKD)
local strex_drift, strex_kick             , strex_fringe           in MAD.dynmap
local              strex_kickhs                                    in MAD.dynmap

-- curved elements (DKD)
local curex_drift, curex_kick             , curex_fringe           in MAD.dynmap

-- sbend (TKT)
local sbend_thick,  sbend_kick            , dipeg_fringe           in MAD.dynmap

-- rbend (TKT)
local rbend_thick,  rbend_kick                                     in MAD.dynmap

-- quadrupole (TKT)
local quad_thick , quad_kick , quad_kick_ ,
      quad_thicks, quad_kicks, quad_kicks_,
      quad_thickh, quad_kickh, quad_kickh_                         in MAD.dynmap

-- solenoid (TKT)
local solen_thick                         , solen_fringe           in MAD.dynmap

-- electrostatic separator
local esept_thick                                                  in MAD.dynmap

-- non-linear elliptical lens
local nllens_kick                                                  in MAD.dynmap

-- rfcavity
local rfcav_kick, rfcav_kickn             , rfcav_fringe           in MAD.dynmap

-- beambeam
local bbeam_kick, bbeam_kick6D                                     in MAD.dynmap

-- generic damap
local genm_thick                                                   in MAD.dynmap

-- patches
local xrotation, yrotation, srotation, translate,
      changeref, changedir, changenrj, misalign                    in MAD.dynmap

-- dynamic maps in C ----------------------------------------------------------o

local ffi = require 'ffi'

ffi.cdef [[
typedef  num_t  par6_t[6];
typedef tpsa_t *map6_t[6];

enum { nmul_max=22, snm_max=(nmul_max+1)*(nmul_max+2)/2 };

struct mflw_ { // must be identical to def in mad_dynmap.cpp !!
  // element data
  num_t el, eld, lrad;
  num_t eh, ang, mang;

  // beam
  num_t pc, beta, betgam;
  int charge;

  // directions
  int edir, sdir, tdir, T;

  // quad, solenoid, multipole, esptum, rfcav
  num_t k1, ks, ksi, volt, freq, lag, nbsl;

  // angles
  num_t ca, sa, tlt;

  // multipoles
  int   nmul;
  num_t knl[nmul_max];
  num_t ksl[nmul_max];

  // multipoles phases
  int   npha;
  num_t pnl[nmul_max];
  num_t psl[nmul_max];

  // curved multipoles
  int   snm;
  num_t bfx[snm_max];
  num_t bfy[snm_max];

  // particles/damaps
  int    npar;
  par6_t *par;
  map6_t *map;

  // patches
  num_t dx,   dy,   ds;
  num_t dthe, dphi, dpsi;

  // misalign
  struct {
    bool  rot, trn;
    num_t dx,   dy,   ds;
    num_t dthe, dphi, dpsi;
  } algn;
};
]]

local map = {
  r = {
    strex_drift  = _C.mad_trk_strex_drift_r ,
    strex_kick   = _C.mad_trk_strex_kick_r  ,
    strex_kickhs = _C.mad_trk_strex_kickhs_r,
    strex_fringe =            strex_fringe  ,
    curex_drift  = _C.mad_trk_curex_drift_r ,
    curex_kick   = _C.mad_trk_curex_kick_r  ,
    curex_fringe =            curex_fringe  ,
    sbend_thick  = _C.mad_trk_sbend_thick_r ,
    sbend_kick   = _C.mad_trk_sbend_kick_r  ,
    dipeg_fringe =            dipeg_fringe  ,
    rbend_thick  = _C.mad_trk_rbend_thick_r ,
    rbend_kick   = _C.mad_trk_rbend_kick_r  ,
    quad_thick   = _C.mad_trk_quad_thick_r  ,
    quad_thicks  = _C.mad_trk_quad_thicks_r ,
    quad_thickh  = _C.mad_trk_quad_thickh_r ,
    quad_kick    = _C.mad_trk_quad_kick_r   ,
    quad_kicks   = _C.mad_trk_quad_kicks_r  ,
    quad_kickh   = _C.mad_trk_quad_kickh_r  ,
    solen_thick  = _C.mad_trk_solen_thick_r ,
    solen_fringe =            solen_fringe  ,
    rfcav_kick   = _C.mad_trk_rfcav_kick_r  ,
    rfcav_kickn  = _C.mad_trk_rfcav_kickn_r ,
    rfcav_fringe =            rfcav_fringe  ,
    esept_thick  = _C.mad_trk_esept_thick_r ,
    nllens_kick  =            nllens_kick   ,
    bbeam_kick   =            bbeam_kick    ,
    bbeam_kick6D =            bbeam_kick6D  ,
    genm_thick   =            genm_thick    ,
    xrotation    = _C.mad_trk_xrotation_r   ,
    yrotation    = _C.mad_trk_yrotation_r   ,
    srotation    = _C.mad_trk_srotation_r   ,
    translate    = _C.mad_trk_translate_r   ,
    changeref    = _C.mad_trk_changeref_r   ,
    changedir    =            changedir     ,
    changenrj    =            changenrj     ,
    misalign     = _C.mad_trk_misalign_r    ,
  },
  t = {
    strex_drift  = _C.mad_trk_strex_drift_t ,
    strex_kick   = _C.mad_trk_strex_kick_t  ,
    strex_kickhs = _C.mad_trk_strex_kickhs_t,
    strex_fringe =            strex_fringe  ,
    curex_drift  = _C.mad_trk_curex_drift_t ,
    curex_kick   = _C.mad_trk_curex_kick_t  ,
    curex_fringe =            curex_fringe  ,
    sbend_thick  = _C.mad_trk_sbend_thick_t ,
    sbend_kick   = _C.mad_trk_sbend_kick_t  ,
    dipeg_fringe =            dipeg_fringe  ,
    rbend_thick  = _C.mad_trk_rbend_thick_t ,
    rbend_kick   = _C.mad_trk_rbend_kick_t  ,
    quad_thick   = _C.mad_trk_quad_thick_t  ,
    quad_thicks  = _C.mad_trk_quad_thicks_t ,
    quad_thickh  = _C.mad_trk_quad_thickh_t ,
    quad_kick    = _C.mad_trk_quad_kick_t   ,
    quad_kicks   = _C.mad_trk_quad_kicks_t  ,
    quad_kickh   = _C.mad_trk_quad_kickh_t  ,
    solen_thick  = _C.mad_trk_solen_thick_t ,
    solen_fringe =            solen_fringe  ,
    rfcav_kick   = _C.mad_trk_rfcav_kick_t  ,
    rfcav_kickn  = _C.mad_trk_rfcav_kickn_t ,
    rfcav_fringe =            rfcav_fringe  ,
    esept_thick  = _C.mad_trk_esept_thick_t ,
    nllens_kick  =            nllens_kick   ,
    bbeam_kick   =            bbeam_kick    ,
    bbeam_kick6D =            bbeam_kick6D  ,
    genm_thick   =            genm_thick    ,
    xrotation    = _C.mad_trk_xrotation_t   ,
    yrotation    = _C.mad_trk_yrotation_t   ,
    srotation    = _C.mad_trk_srotation_t   ,
    translate    = _C.mad_trk_translate_t   ,
    changeref    = _C.mad_trk_changeref_t   ,
    changedir    =            changedir     ,
    changenrj    =            changenrj     ,
    misalign     = _C.mad_trk_misalign_t    ,
  }
}

-- strengths and phases -------------------------------------------------------o

local function cpy_mult (m)
  local cflw in m
  cflw.nmul = m.nmul or 0
  cflw.npha = m.npha or 0
  cflw.snm  = m.snm  or 0

  for i=1,cflw.nmul do
    cflw.knl[i-1] = m.knl[i]
    cflw.ksl[i-1] = m.ksl[i]
  end

  for i=1,cflw.npha do
    cflw.pnl[i-1] = m.pnl[i]
    cflw.psl[i-1] = m.psl[i]
  end

  for i=1,cflw.snm do
    cflw.bfx[i-1] = m.bfx[i]
    cflw.bfy[i-1] = m.bfy[i]
  end
end

local function adj_mult (m)
  local knl, ksl in m

  for i=m.nmul,1,-1 do
    if abs(knl[i]) + abs(ksl[i]) ~= 0 then
      m.nmul = i ; return
    end
  end
  m.nmul = 0
end

local function get_mult (elm, m, n)
  local knl, ksl, dknl, dksl in elm

  m.nmul = max(#knl, #ksl, #dknl, #dksl, n or 0)

  for i=1,m.nmul do
    m.knl[i] = ((knl[i] or 0) + (dknl[i] or 0)) / fact(i-1)
    m.ksl[i] = ((ksl[i] or 0) + (dksl[i] or 0)) / fact(i-1)
  end
end

local function get_multphas (elm, m, n)
  local knl, ksl, dknl, dksl in elm
  local pnl, psl, dpnl, dpsl in elm

  m.nmul = max(#knl, #ksl, #dknl, #dksl, n or 0)
  m.npha = m.nmul

  for i=1,m.nmul do
    m.knl[i] = ((knl[i] or 0) + (dknl[i] or 0)) / fact(i-1)
    m.ksl[i] = ((ksl[i] or 0) + (dksl[i] or 0)) / fact(i-1)
    m.pnl[i] =  (pnl[i] or 0) + (dpnl[i] or 0)
    m.psl[i] =  (psl[i] or 0) + (dpsl[i] or 0)
  end
end

-- misalignments --------------------------------------------------------------o

local function get_algn (e, m)
  local al = e.misalign or  m.sequ:align (m.eidx)
  local el = m.misalign and m.sequ:ealign(m.eidx) or nil

  if not (al or el) then return nil end

  local dx, dy, ds, dthe, dphi, dpsi = 0, 0, 0, 0, 0, 0

  if al then -- element abolute/permanent misalignments
    dx, dthe = dx+(al.dx or 0), dthe+(al.dtheta or 0) -- horizontal/azimutal
    dy, dphi = dy+(al.dy or 0), dphi+(al.dphi   or 0) -- vertical/elevation
    ds, dpsi = ds+(al.ds or 0), dpsi+(al.dpsi   or 0) -- longitudinal/roll
  end

  if el then -- element relative/error misalignments
    dx, dthe = dx+(el.dx or 0), dthe+(el.dtheta or 0) -- horizontal/azimutal
    dy, dphi = dy+(el.dy or 0), dphi+(el.dphi   or 0) -- vertical/elevation
    ds, dpsi = ds+(el.ds or 0), dpsi+(el.dpsi   or 0) -- longitudinal/roll
  end

  local trn = abs(dx  )+abs(dy  )+abs(ds  ) >= minlen
  local rot = abs(dthe)+abs(dphi)+abs(dpsi) >= minang

  if not (trn or rot) then return nil end

  if m.cmap then
    local cmap = m.cflw
    cmap.tlt       = m.tlt
    cmap.algn.trn  = trn
    cmap.algn.rot  = rot
    cmap.algn.dx   = dx
    cmap.algn.dy   = dy
    cmap.algn.ds   = ds
    cmap.algn.dthe = dthe
    cmap.algn.dphi = dphi
    cmap.algn.dpsi = dpsi
  else
    return {trn=trn, rot=rot, dx=dx, dy=dy, ds=ds, dthe=dthe, dphi=dphi, dpsi=dpsi}
  end
end

-- helpers --------------------------------------------------------------------o

local function cmisalign (elm, m, dir)
  if m.cmap then
    map[m.cmap][misalign](m.cflw, dir)
  else
    misalign(elm, m, dir)
  end
end

local function crot (tlt, m, dir)
  if m.cmap then
    map[m.cmap][srotation](m.cflw, dir, tlt)
  else
    srotation(tlt, m, dir)
  end
end

-- element tracking -----------------------------------------------------------o

local function trackone (elm, m, inter, thick, thin, fringe_)
  local sdir, atentry, atexit in m

  if m.cmap then
    local cmap = map[m.cmap]
    thick, thin = cmap[thick], cmap[thin]
  end

  atentry(elm, m,  sdir, -1)
  inter  (elm, m,    1 , thick, thin)
  atexit (elm, m, -sdir, -2)
end

local function trackelm (elm, m, inter, thick, thin, fringe)
  local sdir, atentry, atexit in m
  local tlt  = elm.tilt*m.tdir  ; m.tlt  = tlt
  local algn = get_algn(elm, m) ; m.algn = algn
  local mis  = algn and cmisalign or fnil
  local rot  = abs(tlt) >= minang and crot or fnil
  local fng  = fringe or fnil

  if m.cmap then
    local cmap = map[m.cmap]
    thick, thin, fringe = cmap[thick], cmap[thin], cmap[fringe]
  end

  atentry(elm, m,  sdir, -1)
  mis    (elm, m,  sdir)
  rot    (tlt, m,  sdir)
  atentry(elm, m,  sdir, -3)
  fng    (elm, m,  sdir)
  inter  (elm, m,    1 , thick, thin)
  fng    (elm, m, -sdir)
  atexit (elm, m, -sdir, -4)
  rot    (tlt, m, -sdir)
  mis    (elm, m, -sdir)
  atexit (elm, m, -sdir, -2)

  m.tlt, m.algn = nil, nil
end

local function tracksub (elm, m, inter, thick, thin, fringe)
  local eidx, sdir, atentry, atexit, __sdat in m
  local tlt  = elm.tilt*m.tdir  ; m.tlt  = tlt
  local algn = get_algn(elm, m) ; m.algn = algn
  local mis  = algn and cmisalign or fnil
  local rot  = abs(tlt) >= minang and crot or fnil
  local fng  = fringe or fnil
  m.eidx = nil

  if not eidx then
    errorf("invalid subelement track %s (contain subelements)", elm.name)
  end

  if m.cmap then
    local cmap = map[m.cmap]
    thick, thin, fringe = cmap[thick], cmap[thin], cmap[fringe]
  end

  atentry(elm, m, sdir, -1)
  mis    (elm, m, sdir)
  rot    (tlt, m, sdir)
  atentry(elm, m, sdir, -3)
  fng    (elm, m, sdir)

  if sdir > 0 then
    local at, lw = 0
    for i=1,#elm do
      at, lw = elm[i].sat, elm[i].sat - at
      if abs(lw) >= minlen then -- body step
        inter(elm, m, lw, thick, thin)
      end
      __sdat.clw = at
      elm[i]:track(__sdat)
      at = at + elm[i].l/m.el
    end
    lw = 1 - at
    if abs(lw) >= minlen then  -- last body step
      inter(elm, m, lw, thick, thin)
    end

  else -- backtrack
    local at, lw = 1
    for i=#elm,1,-1 do
      local sat = elm[i].sat - elm[i].l/m.el                                  -- Thick element, therefore at is the exit point (el is weighted by sdir)
      at, lw = sat, at - sat
      if abs(lw) >= minlen then -- body step
        inter(elm, m, lw, thick, thin)
      end
      __sdat.clw = at
      elm[i]:track(__sdat)
      at = at + elm[i].l/m.el
    end
    lw = at
    if abs(lw) >= minlen then -- first body step
      inter(elm, m, lw, thick, thin)
    end
  end

  fng   (elm, m, -sdir)
  atexit(elm, m, -sdir, -4)
  rot   (tlt, m, -sdir)
  mis   (elm, m, -sdir)
  atexit(elm, m, -sdir, -2)

  m.tlt, m.algn, m.eidx = nil, nil, eidx
end

-- kinds ----------------------------------------------------------------------o

local function track_slink (elm, m)
  m.el, m.eh, m.nmul = 0, 0, 0

  local update = elm:var_get'update'
  if update then update(elm, m) end -- update damap

  if elm.sequence then
    m:change_si(elm.sequence, elm.range, elm.nturn, elm.dir)
    return "restart_si"
  end
end

local function track_marker (elm, m)
  m.el, m.eh, m.nmul = 0, 0, 0
  trackone(elm, m, thinonly, fnil, fnil)
end

local function track_drift (elm, m)
  m.el, m.eh, m.nmul = m.ds, 0, 0

  if m.cmap then
    m.cflw.el = m.el
  end

  if is_implicit(elm) then
    local inter = m.implicit and thickonly or driftonly
    trackone(elm, m, inter, strex_drift)
  else
    local track = #elm == 0 and trackelm or tracksub
    local inter = abs(m.ds) >= minlen and thickonly or driftonly
    track(elm, m, inter, strex_drift, fnil)
  end
end

local function track_multipole (elm, m)
  get_mult(elm, m, 1) ; adj_mult(m)

  if m.nmul == 0 and abs(elm.ksi) < minstr then return track_marker(elm, m) end

  local ksi, lrad in elm
  local knl, ksl, sdir in m

  m.lrad, m.ksi = sdir*lrad, ksi or 0

  local kick = strex_kick
  if abs(knl[1]) + abs(ksl[1]) + abs(m.ksi) >= minstr then
    kick = strex_kickhs
  end

  if m.cmap then
    m.cflw.lrad = m.lrad
    m.cflw.ksi  = m.ksi
    cpy_mult(m)
  end

  trackelm(elm, m, thinonly, fnil, kick)
  m.ksi, m.lrad = nil, nil
end

local function track_bbeam (elm, m)
  if not elm.enabled  then return track_marker(elm, m) end

  m.el, m.eh, m.nmul = 0, 0, 0

  local kick = elm.bb6D and bbeam_kick6D or bbeam_kick
  trackelm(elm, m, thinonly, fnil, kick)
end

local function track_nllens (elm, m)
  if not elm.enabled  then return track_marker(elm, m) end

  m.el, m.eh, m.nmul = 0, 0, 0

  trackelm(elm, m, thinonly, fnil, nllens_kick)
end

local function track_sbend (elm, m, e1_, e2_)
  get_mult(elm, m, 3)

  local ds, tdir, nmul, knl, ksl, bfx, bfy in m
  local angle, k0, k0s, k1, k1s, k2, k2s in elm
  local l = abs(ds)

  if l < minlen then
    errorf("invalid sbend '%s' length=%.4e [m] (>0 expected)", elm.name, l)
  end
  if abs(angle) < minang then
    errorf("invalid sbend '%s' angle=%.4e [rad] (~=0 expected)", elm.name, angle)
  end

  knl[1], ksl[1] = knl[1]+k0*l  , ksl[1]+k0s*l
  knl[2], ksl[2] = knl[2]+k1*l  , ksl[2]+k1s*l
  knl[3], ksl[3] = knl[3]+k2*l/2, ksl[3]+k2s*l/2
  m.el, m.eh = ds, angle*tdir/ds
  m.e1, m.e2 = (e1_ or elm.e1), (e2_ or elm.e2)
  m.ang      = angle*tdir

  local model  = elm.model   or m.model
  local method = elm.method  or m.method
  local snmul  = elm.secnmul or m.secnmul or -1
  local inter, thick, kick

  m.snm = snmul

  adj_mult(m) ; getanbnr(m)

  if model == 'DKD' then                          -- curved thin
    inter, thick, kick = DKD[method], curex_drift , curex_kick
  elseif m.nmul == 1 and ksl[1] == 0 and not m.ptcmodel then -- curved thick only
    inter, thick, kick = thickonly  , sbend_thick , fnil
  else -- if abs(knl[2]) < minstr then            -- curved thick
    inter, thick, kick = TKT[method], sbend_thick , sbend_kick
  end

  if m.cmap then
    m.cflw.eh   = m.eh
    m.cflw.el   = m.el
    m.cflw.ang  = m.ang
    m.cflw.mang = m.mang
    cpy_mult(m, true)
  end

  local track = #elm == 0 and trackelm or tracksub
  track(elm, m, inter, thick, kick, curex_fringe)
  m.snm, m.e1, m.e2, m.ang = nil, nil, nil, nil
end

local function track_rbend (elm, m)
  local angle, e1, e2, true_rbend in elm

  m.mang = 0
  if not true_rbend then                                                      -- checked
    return track_sbend(elm, m, e1+angle/2, e2+angle/2)
  end

  get_mult(elm, m, 3)                                                         -- checked

  local ds, tdir, nmul, knl, ksl, ptcmodel in m
  local k0, k0s, k1, k1s, k2, k2s in elm

  if abs(ds) < minlen then
    errorf("invalid rbend '%s' length=%.4e [m] (>0 expected)", elm.name, ds)
  end

  if is_number(e1) and abs(e1) > twopi then e1 = false end
  if is_number(e2) and abs(e2) > twopi then e2 = false end

  m.eld = ds
  m.elc = arc2cord(ds, angle)

  if e1 and e2 then                                                           -- Straight
    m.e1, m.e2 = e1+angle/2, e2+angle/2
    m.el = m.elc
  elseif e1 then                                                              -- True parallel with exit patch
    m.e1, m.e2, m.etp_dir = e1, angle - e1, -1
    m.el = m.elc * cos(angle/2 - e1)
  elseif e2 then                                                              -- True parallel with entry patch
    m.e1, m.e2, m.etp_dir = angle - e2, e2,  1
    m.el = m.elc * cos(angle/2 - e2)
  else errorf("True parallel rbend '%s' must set e1 or e2", elm.name)
  end

  local l = abs(m.el)
  m.eh = angle/ds*tdir

  knl[1], ksl[1] = knl[1]+k0*l  , ksl[1]+k0s*l
  knl[2], ksl[2] = knl[2]+k1*l  , ksl[2]+k1s*l
  knl[3], ksl[3] = knl[3]+k2*l/2, ksl[3]+k2s*l/2

  adj_mult(m)

  local model  = elm.model  or m.model
  local method = elm.method or m.method
  local inter, thick, kick

  if model == 'DKD' then
    inter, thick, kick = DKD[method], strex_drift, strex_kick
  elseif m.nmul == 1 and ksl[1] == 0 and not ptcmodel then
    inter, thick, kick = thickonly  , rbend_thick , fnil
  else
    inter, thick, kick = TKT[method], rbend_thick, rbend_kick
  end

  if m.cmap then
    m.cflw.eh   = m.eh
    m.cflw.el   = m.el
    m.cflw.eld  = m.eld
    m.cflw.ang  = m.ang
    m.cflw.mang = m.mang
    cpy_mult(m)
  end

  local track = #elm == 0 and trackelm or tracksub
  track(elm, m, inter, thick, kick, strex_fringe)
  m.e1, m.e2, m.ang, m.eld, m.elc, m.etp_dir = nil, nil, nil, nil, nil, nil
end

local function track_quadrupole (elm, m)
  get_mult(elm, m, 2)

  local ds, edir, tdir, nmul, knl, ksl, ptcmodel in m
  local angle, k0, k0s, k1, k1s in elm
  local l = abs(ds)

  if l == 0 and abs(k1)+abs(k1s)+abs(k0)+abs(k0s) > 0 then
    warn("quadrupole '%s' defines strength with zero length", elm.name)
  end

  knl[1], ksl[1] = knl[1]+k0*l, ksl[1]+k0s*l
  knl[2], ksl[2] = knl[2]+k1*l, ksl[2]+k1s*l
  m.el, m.eh = ds, 0

  adj_mult(m)

  local model  = elm.model  or m.model
  local method = elm.method or m.method
  local no_k1  = abs(knl[2]) < minstr
  local no_k1s = abs(ksl[2]) < minstr 
  local no_ang = abs(angle)  < minang
  local no_tlt = ptcmodel and not no_k1s and (abs(knl[1]) > minstr or nmul > 2 or elm.fringe > 0)
  local inter  = ptcmodel and KMK[method] or TKT[method]
  local thick, kick

  if model == 'DKD' or no_k1 and no_k1s and no_ang then
    inter, thick, kick = DKD[method], strex_drift, strex_kick
  elseif no_k1s and no_ang or no_tlt then       -- normal thick
    m.k1 = knl[2]/ds*edir
    thick, kick = quad_thick, ptcmodel and quad_kick_ or quad_kick
  elseif no_ang then                            -- skew thick
    local a = -0.5*atan2(ksl[2], knl[2])
    m.k1, m.ca, m.sa = sqrt(knl[2]^2 + ksl[2]^2)/ds*edir, cos(a), sin(a)
    thick, kick = quad_thicks, ptcmodel and quad_kicks_ or quad_kicks
  else                                          -- combined thick            -- unchecked
    m.eh = angle/ds*tdir
    thick, kick = quad_thickh, ptcmodel and quad_kickh_ or quad_kickh
  end

  if m.cmap then
    m.cflw.el = m.el
    m.cflw.eh = m.eh
    m.cflw.k1 = m.k1 or 0
    m.cflw.ca = m.ca or 0
    m.cflw.sa = m.sa or 0
    cpy_mult(m)
  end

  local track = #elm == 0 and trackelm or tracksub
  track(elm, m, inter, thick, kick, strex_fringe)
end

-- straigth magnets (-rbend -quad -solenoid)

local function track_strexgen (elm, m, ptc_, mth_)
  m.el, m.eh = m.ds, 0

  adj_mult(m)

  local model  = elm.model  or m.model
  local method = elm.method or mth_ or m.method
  local inter, thick, kick, fringe

  if abs(m.ds) < minlen then
    inter, thick, kick, fringe = thinonly, fnil, strex_kick, fnil
  elseif model == 'DKD' or not ptc_ then
    inter, thick, kick, fringe = DKD[method], strex_drift, strex_kick, strex_fringe
  else
    m.k1 = m.knl[2]/m.ds*m.edir
    inter, thick, kick, fringe = KMK[method], quad_thick, quad_kick_, strex_fringe
  end

  if m.cmap then
    m.cflw.eh = m.eh
    m.cflw.el = m.el
    m.cflw.k1 = m.k1
    cpy_mult(m)
  end

  local track = #elm == 0 and trackelm or tracksub
  track(elm, m, inter, thick, kick, fringe)
end

local function track_sextupole (elm, m)
  get_mult(elm, m, 3)

  local nmul, knl, ksl in m
  local k2, k2s in elm
  local l = abs(m.ds)

  if l == 0 and abs(k2)+abs(k2s) > 0 then
    warn("sextupole '%s' defines strength with zero length", elm.name)
  end

  knl[3] = knl[3]+k2 *l/2
  ksl[3] = ksl[3]+k2s*l/2

  track_strexgen (elm, m, m.ptcmodel)
end

local function track_octupole (elm, m)
  get_mult(elm, m, 4)

  local nmul, knl, ksl in m
  local k3, k3s in elm
  local l = abs(m.ds)

  if l == 0 and abs(k3)+abs(k3s) > 0 then
    warn("octupole '%s' defines strength with zero length", elm.name)
  end

  knl[4] = knl[4]+k3 *l/6
  ksl[4] = ksl[4]+k3s*l/6

  track_strexgen (elm, m, m.ptcmodel)
end

local function track_decapole (elm, m)
  get_mult(elm, m, 5)

  local nmul, knl, ksl in m
  local k4, k4s in elm
  local l = abs(m.ds)

  if l == 0 and abs(k4)+abs(k4s) > 0 then
    warn("decapole '%s' defines strength with zero length", elm.name)
  end

  knl[5] = knl[5]+k4 *l/24
  ksl[5] = ksl[5]+k4s*l/24

  track_strexgen (elm, m)
end

local function track_dodecapole (elm, m)
  get_mult(elm, m, 6)

  local nmul, knl, ksl in m
  local k5, k5s in elm
  local l = abs(m.ds)

  if l == 0 and abs(k5)+abs(k5s) > 0 then
    warn("dodecapole '%s' defines strength with zero length", elm.name)
  end

  knl[6] = knl[6]+k5 *l/120
  ksl[6] = ksl[6]+k5s*l/120

  track_strexgen (elm, m)
end

-- kickers (straigth magnets)

local function track_kickgen (elm, m, hk, vk)
  get_mult(elm, m, 2)

  local nmul, knl, ksl, ptcmodel in m
  local method = not ptcmodel and 2 or nil

  knl[1] = knl[1] - hk
  ksl[1] = ksl[1] + vk

  track_strexgen (elm, m, ptcmodel, method)
end

local function track_tkicker (elm, m, hk_, vk_)
  track_kickgen(elm, m, elm.hkick, elm.vkick)
end

local function track_kicker (elm, m)
  track_kickgen(elm, m, elm.hkick+elm.chkick, elm.vkick+elm.cvkick)
end

local function track_hkicker (elm, m)
  track_kickgen(elm, m, elm.kick+elm.chkick, 0)
end

local function track_vkicker (elm, m)
  track_kickgen(elm, m, 0, elm.kick+elm.cvkick)
end

-- solenoid

local function track_solenoid (elm, m)
  get_mult(elm, m) ; adj_mult(m)

  local ds, tdir, edir in m
  local ks, ksi, lrad in elm
  local l = abs(ds)
  local model  = elm.model or m.model

  if l == 0 and abs(ks) > 0 then
    warn("solenoid '%s' defines strength with zero length", elm.name)
  end

  if l < minlen then
    if model == "DKD" and lrad > minlen then
      return track_multipole(elm, m)
    end
    errorf("invalid solenoid '%s' length=%.4e [m] (>0 expected)", elm.name, l)
  end

  m.el, m.eh = ds, 0

  local ksi = ksi + ks*l
  local no_ksi = abs(ksi) < minstr
  local method = elm.method or m.method
  local thick, kick, fringe

  if model == 'DKD' and no_ksi then
    thick, kick, fringe = strex_drift, strex_kick , strex_fringe
--  elseif model == 'DKD' then -- invalid use of drift in solenoid
--    m.ksi, m.lrad = ksi, lrad
--    thick, kick, fringe = strex_drift, strex_kickhs, strex_fringe
  else
    m.ks = ksi/l*edir
    thick, kick, fringe = solen_thick, strex_kick, elm.new_fringe and solen_fringe or strex_fringe
  end

  if m.cmap then
    m.cflw.el   = m.el
    m.cflw.eh   = m.eh
    m.cflw.ks   = m.ks or 0
    cpy_mult(m)
  end

  local track  = #elm == 0 and trackelm or tracksub
  track(elm, m, DKD[method], thick, kick, fringe)
  m.ks, m.ksi, m.lrad = nil, nil, nil
end

-- eseptum

local function track_eseptum (elm, m)
  get_mult(elm, m) ; adj_mult(m)

  local ds, edir, tdir in m
  local ex, ey, exl, eyl in elm
  local l = abs(ds)

  if l == 0 and abs(ex)+abs(ey) > 0 then
    warn("eseptum '%s' defines strength with zero length", elm.name)
  end

  m.el, m.eh = ds, 0

  local exl = exl + ex*l
  local eyl = eyl + ey*l
  local volt = sqrt(exl^2 + eyl^2)/ds*edir
  local thick

  if abs(volt) < minvolt then
    thick = strex_drift
  else
    local a = -atan2(eyl, exl)
    m.volt, m.ca, m.sa = volt*1e-3, cos(a), sin(a)
    thick = esept_thick
  end

  if m.cmap then
    m.cflw.el   = m.el
    m.cflw.eh   = m.eh
    m.cflw.volt = m.volt or 0
    m.cflw.ca   = m.ca   or 0
    m.cflw.sa   = m.sa   or 0
    cpy_mult(m)
  end

  local inter = m.nmul == 0 and thickonly or KMK[elm.method or m.method]
  local track = #elm == 0 and trackelm or tracksub
  track(elm, m, inter, thick, strex_kick, strex_fringe)
end

-- rf cavities

local function track_rfcavgen (elm, m, crab)
  local ds in m
  local volt in elm
  local l = abs(ds)

  m.el, m.eh = ds, 0

  adj_mult(m)

  m.volt, m.lag = crab and 0 or volt*1e-3, elm.lag*twopi - (crab and pi_2 or 0)
  m.freq, m.nbsl= elm.freq*1e6, elm.n_bessel
  if m.freq == 0 then
    m.freq = elm.harmon*clight*m.beam.beta/m.sequ.l
  end
  if m.freq <= 0 and abs(m.volt) ~= 0 then
    errorf("invalid rfcavity '%s' frequency =%.4e [MHz] (>0 or harmon expected)",
            elm.name, m.freq)
  end

  local inter  = l < minlen and thinonly or DKD[elm.method or m.method]
  local kick   = m.nmul+m.nbsl == 0 and rfcav_kick or rfcav_kickn
  local fringe = l < minlen and fnil     or rfcav_fringe

  if m.cmap then
    m.cflw.el   = m.el
    m.cflw.eh   = m.eh
    m.cflw.volt = m.volt
    m.cflw.freq = m.freq
    m.cflw.lag  = m.lag
    m.cflw.nbsl = m.nbsl
    cpy_mult(m)
  end

  local track = #elm == 0 and trackelm or tracksub
  track(elm, m, inter, strex_drift, kick, fringe)
  m.volt, m.lag = nil, nil
end

local function track_rfcavity (elm, m)
  get_mult      (elm, m)
  track_rfcavgen(elm, m)
end

local function track_rfmcavity (elm, m)
  get_multphas  (elm, m)
  track_rfcavgen(elm, m)
  m.npha = nil
end

local function track_crabcavity (elm, m)
  get_multphas  (elm, m, 1)
  m.knl[1] = m.knl[1] + elm.volt*1e-3*abs(m.ds)
  track_rfcavgen(elm, m, true)
  m.npha = nil
end

-- genmap element

local function track_genmap (elm, m)
  get_mult(elm, m) ; adj_mult(m)

  local ds, tdir in m
  local angle in elm
  local l = abs(ds)

  m.el, m.eh = ds, angle/ds*tdir

  local method = elm.method or m.method
  local inter  = l < minlen  and thinonly or m.nmul == 0 and thickonly or DKD[method]
  local kick   = m.nmul == 0 and fnil or abs(angle) < minang and strex_kick   or curex_kick
  local fringe = l < minlen  and fnil or abs(angle) < minang and strex_fringe or curex_fringe

  local track  = #elm == 0 and trackelm or tracksub
  track(elm, m, inter, genm_thick, kick, fringe)
end

-- load maps into elements ----------------------------------------------------o

local _nyi = \e ->
  errorf("tracking element %s of kind %s with length %s not yet implemented",
          e.name, e.kind, e.l)

local E = element

-- warning: set_methods overides must be consistent with survey and element.

-- element kinds
E.drift_element :set_methods {track = track_drift}

-- special elements
E.marker     :set_methods {track = track_marker}     -- cloned in sequence
E.slink      :set_methods {track = track_slink }

-- thick elements
E.sbend      :set_methods {track = track_sbend     } -- curved  , k0!, k0s, k1, k1s, k2, k2s
E.rbend      :set_methods {track = track_rbend     } -- straight, k0!, k0s, k1, k1s, k2, k2s
E.quadrupole :set_methods {track = track_quadrupole} -- straight, k0, k1!, k0s, k1s, k2, k2s
E.sextupole  :set_methods {track = track_sextupole } -- straight, k2, k2s
E.octupole   :set_methods {track = track_octupole  } -- straight, k3, k3s
E.decapole   :set_methods {track = track_decapole  } -- straight, k4, k4s
E.dodecapole :set_methods {track = track_dodecapole} -- straight, k5, k5s
E.solenoid   :set_methods {track = track_solenoid  } -- straight, ks, ksi
E.rfcavity   :set_methods {track = track_rfcavity  } -- straight, volt, freq!, lag, harmon
E.rfmultipole:set_methods {track = track_rfmcavity } -- straight, volt, freq!, lag, harmon, mult, phas
E.crabcavity :set_methods {track = track_crabcavity} -- straight, volt, freq!, lag, harmon, mult, phas

E.wiggler    :set_methods {track = _nyi         }    -- straight
E.elseparator:set_methods {track = track_eseptum}    -- straight

E.tkicker    :set_methods {track = track_tkicker}    -- straight, hkick, vkick
E.kicker     :set_methods {track = track_kicker }    -- straight, hkick, vkick
E.hkicker    :set_methods {track = track_hkicker}    -- straight,  kick
E.vkicker    :set_methods {track = track_vkicker}    -- straight,  kick

-- thin elements
E.multipole  :set_methods {track = track_multipole}  -- thin
E.beambeam   :set_methods {track = track_bbeam    }  -- thin
E.nllens     :set_methods {track = track_nllens   }  -- thin
E.genmap     :set_methods {track = track_genmap   }  -- straight or curved, damap, update

-- patches
E.xrotation  :set_methods {track = bind3rd(trackone, xrotation)}
E.yrotation  :set_methods {track = bind3rd(trackone, yrotation)}
E.srotation  :set_methods {track = bind3rd(trackone, srotation)}
E.translate  :set_methods {track = bind3rd(trackone, translate)}
E.changeref  :set_methods {track = bind3rd(trackone, changeref)}
E.changedir  :set_methods {track = bind3rd(trackone, changedir)}
E.changenrj  :set_methods {track = bind3rd(trackone, changenrj)}

-- end ------------------------------------------------------------------------o
