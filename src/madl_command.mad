--[=[
 o-----------------------------------------------------------------------------o
 |
 | command module
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide root object for commands

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local object                                   in MAD
local is_nil, is_string, is_table, is_callable in MAD.typeid
local assertf                                  in MAD.utility

-- root object ----------------------------------------------------------------o

local _cmd = {}

local command = object 'command' { kind='command', [_cmd]=true }

local function is_command (a)
  return is_table(a) and not is_nil(a[_cmd])
end

-- implementation -------------------------------------------------------------o

local function exec (a)
  local exec = a:raw_get'exec'
  if exec == false then
    a.exec = nil
    return a
  elseif is_callable(exec) then
    a:set_metamethods({ __exec = exec }, true)
    a.exec = nil
    return a
  end
  return rawget(getmetatable(a), '__exec')(a)
end

-- local function add_specialization (cmd, def, tbl_)
--   if is_string(def) and is_table(tbl_) then
--     def, tbl_ = {def=tbl_}, nil        -- left shift
--   end
--   assert(is_command(cmd), "invalid argument #1 (command expected)")
--   assert(is_table(def)  , "invalid argument #2 (command specialization expected")
--
--   local status = cmd:is_readonly()
--   cmd:set_readonly(false)
--   for k,v in pairs(def) do
--     assertf(is_nil(cmd[k]), "invalid key for specialization ('%s' already in use)", k)
--     assert (is_nil(v.exec), "invalid specialization ('exec' already in use)")
--     v.exec = false
--     cmd[k] = cmd(k, v) -- attach specialized child
--   end
--   cmd:set_readonly(status)
--   return cmd
-- end
--
-- command :set_methods {
--   add_specialization = add_specialization,
-- }

command :set_metamethods {
  __init  = \s -> exec(s),
  __exec := error("invalid command (missing exec or __exec definition)", 2),
} :set_readonly()

-- env ------------------------------------------------------------------------o

MAD.typeid.is_command = is_command

-- end ------------------------------------------------------------------------o
return { command = command }
