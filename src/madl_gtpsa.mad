--[=[
 o-----------------------------------------------------------------------------o
 |
 | Generalised Truncated Power Series Algebra module
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provides full set of functions and operations on real and complex TPSA.
  - Support monomials with knobs and inhomogeneous orders.

 o-----------------------------------------------------------------------------o
]=]

local MR, MC = {}, {}

-- locals ---------------------------------------------------------------------o

local ffi = require 'ffi'
local istype   in ffi
local min, max in math

local _C, tostring, complex, vector, cvector, monomial in MAD
local max, log, exp in MAD.gmath
local openfile in MAD.utility

-- To review
local is_nil, is_number, is_integer, is_complex, is_scalar, is_string,
      is_table, is_lengthable, is_iterable, is_mappable, has_method,
      is_matrix, is_cmatrix, is_vector, is_cvector, is_monomial    in MAD.typeid

-- tmp for returned values
local cres = ffi.new 'complex[1]'

-- constants
local dbl_sz = ffi.sizeof 'double'
local cpx_sz = ffi.sizeof 'complex'

-- array of indexes
local int_arr = ffi.typeof 'int [?]'

-- types ----------------------------------------------------------------------o

ffi.cdef [[
typedef unsigned int bit_t; // mad_bit.h

struct desc { // warning: must be kept identical to C definition
  const int   id, nth;    // index in list of registered descriptors, max #threads or 1
  const int   nmv, nv;    // number of mvars, number of all vars
  const ord_t mo, ko, to; // max order for mvars, knobs, trunc (mo=max(mvar_ords),to<=mo)
  const ord_t
       *const mvar_ords,  // mvars orders[nmv] (for each TPSA in map)
       *const  var_ords;  //  vars orders[nv ] (max order for each monomial variable)
};            // end of compatibility with Lua FFI (rest is not visible)

struct tpsa { // warning: must be kept identical to C definition
  const desc_t *const d;  // ptr to descriptor
  const ord_t lo, hi, mo; // lowest/highest used ord, trunc ord
  const bit_t nz;         // non-zero homogeneous polynomials
  const num_t coef[?];
};

struct ctpsa { // warning: must be kept identical to C definition
  const desc_t *const d;  // ptr to descriptor
  const ord_t lo, hi, mo; // lowest/highest used ord, trunc ord
  const bit_t nz;         // non-zero homogeneous polynomials
  const cnum_t coef[?];
};
]]

local gtpsad_ctor = ffi.typeof 'struct  desc'
local   tpsa_ctor = ffi.typeof 'struct  tpsa'
local  ctpsa_ctor = ffi.typeof 'struct ctpsa'

local  tpsa_cref  = ffi.typeof 'struct  tpsa&'
local ctpsa_cref  = ffi.typeof 'struct ctpsa&'

local  tpsa_size  = ffi.offsetof( tpsa_ctor, 'coef')
local ctpsa_size  = ffi.offsetof(ctpsa_ctor, 'coef')

local is_gtpsad = \x -> istype(gtpsad_ctor, x)
local is_tpsa   = \x -> istype( tpsa_ctor , x)
local is_ctpsa  = \x -> istype(ctpsa_ctor , x)
local isa_tpsa  = \x -> is_tpsa(x) or is_ctpsa(x)

-- descriptors ----------------------------------------------------------------o

--[=[
  variables = map variables + knob variables

  nv: number of mvars  (ignored and replaced by #mo if mo is an array or a string)
  mo: mvars orders     (value, string or array)
  nk: number of knobs  (ignored and replaced by #ko if ko is an array or a string)
  ko: knobs orders     (value, string or array)
  dk: knobs max x-ord  (value)
  vo: variables orders (string or array, defined orders of variables)
  vn: variables names  (not used by gtpsa but used by damap)

  default: nv=6, mo=2, nk=0, ko=1, dk=0, vo=nil, vn={'x','px','y','py','t','pt'}

  gtpsad(nil)                               : 6 mvars of order 2.
  gtpsad(3)         -> nv=3                 : 3 mvars of order 2.
  gtpsad{mo=3}      -> mo=3                 : 6 mvars of order 3.
  gtpsad(4,3)       -> nv=4,mo=3            : 4 mvars of order 3.
  gtpsad{nv=4,mo=3}                         : as above.
  gtpsad(4,3,100,1) -> nv=4,mo=3,nk=10,ko=1 : 4 mvars of ord.3, 10 knobs of ord.1.
  gtpsad{nv=4,mo=3,nk=100,ko=1}             : as above.
  gtpsad(4,3,100,2,1) -> nv=4,mo=3,nk=10,ko=2,dk=1
                    : 4 mvars of order 3, 10 knobs of order 2 without crossterm.
  gtpsad{nv=4,mo=3,nk=100,ko=2,dk=1}        : as above.

  gtpsad{mo={3,2}}                          : 2 mvars of order 3 and 2 resp.
  gtpsad{mo={3,2}, nk=100}                  : 2 mvars of order 3 and 2 resp.,
         each mvars contains 102 vars (2 mvars + 100 knobs) of orders 3,2,1,1..

  gtpsad{mo={3,3}, vo={2,2,1,2}, dk=1}  : 2 mvars of order 3,
    each mvars contains 4 vars (2 mvars + 2 knobs) of orders 2,2,1,2,
                                knobs x-order is limited to 1 (no cross-terms).
--]=]

local function gtpsad (nv_, mo_, nk_, ko_, dk_, vo_, vn_)
  local is = is_mappable(nv_)
  local nv = is and nv_.nv or nv_ or 6       -- number of map variables
  local mo = is and nv_.mo or mo_ or 2       -- map variables orders
  local nk = is and nv_.nk or nk_            -- number of knob variables
  local ko = is and nv_.ko or ko_            -- knob variables orders
  local dk = is and nv_.dk or dk_ or 0       -- knob variables max cross-orders
  local vo = is and nv_.vo or vo_ or nil     -- variables orders
  local vn = is and nv_.vn or vn_ or nil     -- variables names (not used)

  if is_integer(nv) and is_integer(mo) and is_nil(vo) then
    if is_nil(nk or ko) then
      return _C.mad_desc_newn(nv, mo)
    elseif is_integer(nk) and is_integer(ko) then
      return _C.mad_desc_newk(nv, mo, nk, ko, dk)
    end
  end

  if is_integer(nv) and is_integer(mo) then
    mo = monomial(nv, mo)
  elseif is_lengthable(mo) then
    mo = monomial(mo) -- nv ignored
  else
    error("invalid map variables specification (GTPSA descriptor)")
  end

  if is_nil(nk or ko) then
    if is_nil(vo) then
      return _C.mad_desc_newm(mo.n, mo.data)
    else
      vo = monomial(vo)
      return _C.mad_desc_newv(mo.n, mo.data, vo.n, vo.data)
    end
  end

  if is_integer(nk) and is_integer(ko) then
    ko = monomial(nk, ko)
  elseif is_lengthable(ko) then
    ko = monomial(ko) -- nk ignored
  else
    error("invalid knob variables specification (GTPSA descriptor)")
  end

  if is_nil(vo) then
    return _C.mad_desc_newkv(mo.n, mo.data, ko.n, ko.data, 0, nil, dk)
  else
    vo = monomial(vo)
    return _C.mad_desc_newkv(mo.n, mo.data, ko.n, ko.data, vo.n, vo.data, dk)
  end
end

gtpsad() -- set default desc to nv=6,mo=2

-- allocators -----------------------------------------------------------------o

local function tpsa_alloc (d, mo)
  local len = _C.mad_desc_ordlen(d, mo)
  assert(len <= 2^30, "tpsa is too large")
  local tpsa = tpsa_ctor(len) -- VLA
--  if len < _C.mad_alloc_threshold then
--    tpsa = tpsa_ctor(len) -- VLA
--  else
--    assert(len <= 2^30, "tpsa is too large")
--    local siz = tpsa_size + len*dbl_sz
--    tpsa = assert(_C.mad_calloc(1,siz), "out of memory")
--    tpsa = ffi.gc(ffi.cast(tpsa_cref, tpsa), _C.mad_free)
--  end
  _C.mad_tpsa_init(tpsa, d, mo, 0, mo)
  return tpsa
end

local function ctpsa_alloc (d, mo)
  local len = _C.mad_desc_ordlen(d, mo)
   assert(len <= 2^29, "ctpsa is too large")
  local tpsa = ctpsa_ctor(len) -- VLA
--  if len <= _C.mad_alloc_threshold/2 then
--    tpsa = ctpsa_ctor(len) -- VLA
--  else
--    assert(len <= 2^29, "ctpsa is too large")
--    local siz = ctpsa_size + len*cpx_sz
--    tpsa = assert(_C.mad_calloc(1,siz), "out of memory")
--    tpsa = ffi.gc(ffi.cast(ctpsa_cref, tpsa), _C.mad_free)
--  end
  _C.mad_ctpsa_init(tpsa, d, mo, 0, mo)
  return tpsa
end

-- ctors ----------------------------------------------------------------------o

-- tpsa()        -> last d
-- tpsa(mo)      -> last d, mo
-- tpsa(t)       -> t.mo
-- tpsa(d)       -> d.mo
-- tpsa(t|d, mo) -> mo

local function tpsa (td, mo_)
  if is_number(td) and is_nil(mo_) then
    mo_, td = td -- right shift
  end
  local tbl
  if is_nil(td) then
    td      = _C.mad_desc_curr
    mo_     = mo_ or td.mo       -- mo = d.mo
  elseif is_gtpsad(td) then
    mo_     = mo_ or td.mo       -- mo = d.mo
  elseif isa_tpsa(td) then
    mo_, td = mo_ or td.mo, td.d -- mo = t.mo
  elseif is_table(td) or is_matrix(td) then
    td, tbl = _C.mad_desc_curr, td
    mo_     = mo_ or td.mo       -- mo = d.mo
  end
  assert(is_gtpsad(td)  , "invalid argument #1 (GTPSA descriptor expected)")
  assert(is_integer(mo_), "invalid argument #2 (integer expected)")
  local t = tpsa_alloc(td, max(0, min(mo_, td.mo)))
  if tbl then t:setv(1,tbl) end
  return t
end

local function ctpsa (td, mo_)
  if is_number(td) and is_nil(mo_) then
    mo_, td = td -- right shift
  end
  local tbl
  if is_nil(td) then
    td      = _C.mad_desc_curr
    mo_     = mo_ or td.mo       -- mo = d.mo
  elseif is_gtpsad(td) then
    mo_     = mo_ or td.mo       -- mo = d.mo
  elseif isa_tpsa(td) then
    mo_, td = mo_ or td.mo, td.d -- mo = t.mo
  elseif is_table(td) or is_cmatrix(td) then
    td, tbl = _C.mad_desc_curr, td
    mo_     = mo_ or td.mo       -- mo = d.mo
  end
  assert(is_gtpsad(td)  , "invalid argument #1 (GTPSA descriptor expected)")
  assert(is_integer(mo_), "invalid argument #2 (integer expected)")
  local t = ctpsa_alloc(td, max(0, min(mo_, td.mo)))
  if tbl then t:setv(1,tbl) end
  return t
end

-- checkers -------------------------------------------------------------------o

local function chksiz (r, x, y) -- add, sub, mul
  y = y or x
  assert(x.d == y.d and (is_nil(r) or r.d == x.d and r.mo >= max(x.mo,y.mo)),
         "incompatible GTPSA order or descriptor")
  return r
end

-- maxord, maxlen, ordlen, gtrunc, dump ---------------------------------------o

MR.__len  = \x     -> _C.mad_tpsa_len (x)
MC.__len  = \x     -> _C.mad_ctpsa_len(x)

MR.maxord = \x     -> _C.mad_desc_maxord(x.d)
MR.maxlen = \x     -> _C.mad_desc_maxlen(x.d)
MR.ordlen = \x,mo_ -> _C.mad_desc_ordlen(x.d, mo_ or x.mo)
MR.gtrunc = \x,to_ -> _C.mad_desc_gtrunc(x.d, to_ or _C.mad_tpsa_same)

MR.is_valid = \x   -> _C.mad_tpsa_is_valid (x)
MC.is_valid = \x   -> _C.mad_ctpsa_is_valid(x)

MR.debug  = \x,nam_,fil_ => _C.mad_tpsa_debug (x, nam_, fil_) return x end
MC.debug  = \x,nam_,fil_ => _C.mad_ctpsa_debug(x, nam_, fil_) return x end

-- same, copy, convert, clear, scalar -----------------------------------------o

-- x:same()
-- x:same(e)
-- x:same(e,mo)
-- x:same(nil,mo)
-- x:same(mo) => x:same(e), i.e. wrong order

function MR.__same (x, e_, mo_)
  if is_nil(e_) or is_number(e_) then
    return  tpsa_alloc(x.d, mo_ or x.mo)
  elseif is_complex(e_) then
    return ctpsa_alloc(x.d, mo_ or x.mo)
  else
    error("invalid argument #2 (nil or scalar expected)")
  end
end

function MC.__same (x, e_, mo_)
  if is_nil(e_) or is_complex(e_) then
    return ctpsa_alloc(x.d, mo_ or x.mo)
  elseif is_number(e_) then
    return  tpsa_alloc(x.d, mo_ or x.mo)
  else
    error("invalid argument #2 (nil or scalar expected)")
  end
end

function MR.__copy (x, y_)
  if is_nil(y_) then
    x, y_ = tpsa_alloc(x.d, x.mo), x
    _C.mad_tpsa_copy(y_, x)
  else
    assert(is_tpsa(y_), "invalid argument #2 (tpsa expected)")
    if x ~= y_ then _C.mad_tpsa_copy(y_, chksiz(x,y_)) end
  end
  return x
end

function MC.__copy (x, y_)
  if is_nil(y_) then
    x, y_ = ctpsa_alloc(x.d, x.mo), x
    _C.mad_ctpsa_copy(y_, x)
  elseif is_tpsa(y_) then
    x, y_ = chksiz(x,y_) and ctpsa_alloc(x.d, x.mo), x
    _C.mad_ctpsa_complex(y_, nil, x)
  else
    assert(is_ctpsa(y_), "invalid argument #2 (ctpsa expected)")
    if x ~= y_ then _C.mad_ctpsa_copy(y_, chksiz(x,y_)) end
  end
  return x
end

function MR.convert (x, y, tbl_)
  assert(is_tpsa(y), "invalid argument #2 (tpsa expected)")
  local n, m = 0
  if tbl_ then
    assert(is_table(tbl_), "invalid argument #3 (table expected)")
    n = #tbl_
    m = int_arr(n) ; for i=1,n do m[i-1] = tbl_[i] end
  end
  _C.mad_tpsa_convert(x, y, n, m)
  return y
end

function MC.convert (x, y, tbl_)
  assert(is_ctpsa(y), "invalid argument #2 (ctpsa expected)")
  local n, m = 0
  if tbl_ then
    assert(is_table(tbl_), "invalid argument #3 (table expected)")
    n = #tbl_
    m = int_arr(n) ; for i=1,n do m[i-1] = tbl_[i] end
  end
  _C.mad_ctpsa_convert(x, y, n, m)
  return y
end

function MR.clear (x)
  _C.mad_tpsa_clear(x) return x
end

function MC.clear (x)
  _C.mad_ctpsa_clear(x) return x
end

function MR.scalar (x, e_, iv_, scl_) -- clear + set0(e1) + set1(iv, scl or 1)
  _C.mad_tpsa_scalar(x, e_ or 0, iv_ or 0, scl_ or 0) return x
end

function MC.scalar (x, e_, iv_, scl_) -- clear + set0(e1) + set1(iv, scl or 1)
  e_, scl_ = complex(e_), complex(slc_)
  _C.mad_ctpsa_scalar_r(x, e_.re, e_.im, iv_ or 0, scl_.re, slc_.im) return x
end

-- indexing ------------------------------------------------------------------o

function MR.get_idx (x, m) -- mono -> idx
  m = is_table(m) and monomial(m) or m
  assert(is_monomial(m), "invalid argument #2 (table or monomial expected)")
  return _C.mad_tpsa_idxm(x, m.n, m.ord)+1
end

function MC.get_idx (x, m) -- mono -> idx
  m = is_table(m) and monomial(m) or m
  assert(is_monomial(m), "invalid argument #2 (table or monomial expected)")
  return _C.mad_ctpsa_idxm(x, m.n, m.ord)+1
end

function MR.get_idx_sparse (x, tbl) -- tbl = {idx1, ord1, idx2, ord2, ... } -> idx
  assert(is_table(tbl), "invalid argument #2 (table expected)")
  local n = #tbl
  local m = int_arr(n) ; for i=1,n do m[i-1] = tbl[i] end
  return _C.mad_tpsa_idxsm(x, n, m)+1
end

function MC.get_idx_sparse (x, tbl) -- tbl = {idx1, ord1, idx2, ord2, ... } -> idx
  assert(is_table(tbl), "invalid argument #2 (table expected)")
  local n = #tbl
  local m = int_arr(n) ; for i=1,n do m[i-1] = tbl[i] end
  return _C.mad_ctpsa_idxsm(x, n, m)+1
end

function MR.get_mono (x, i, r) -- idx -> mono
  assert(is_integer(i), "invalid argument #2 (index expected)")
  local m = r or monomial(x.d.nv)
  assert(is_monomial(m), "invalid argument #2 (table or monomial expected)")
  return _C.mad_tpsa_mono(t, m.n, m.ord, i) -- set m, return order
end

function MC.get_mono (x, i, r) -- idx -> mono
  assert(is_integer(i), "invalid argument #2 (index expected)")
  local m = r or monomial(x.d.nv)
  assert(is_monomial(m), "invalid argument #2 (table or monomial expected)")
  return _C.mad_ctpsa_mono(t, m.n, m.ord, i) -- set m, return order
end

-- getters and setters --------------------------------------------------------o

function MR.get0 (x)
  return x.coef[0]
end

function MC.get0 (x)
  return x.coef[0]
end

function MR.set0 (x, a, b)
  if is_nil(b) then a, b = 0, a end
  _C.mad_tpsa_set0(x, a, b) return x
end

function MC.set0 (x, a, b)
  if is_nil(b) then a, b = 0, a end
  a, b = complex(a), complex(b)
  _C.mad_ctpsa_set0_r(x, a.re, a.im, b.re, b.im) return x
end

function MR.get (x, m) -- idx or str or mono -> num
  if is_integer(m) then
    return m == 1 and x.coef[0] or _C.mad_tpsa_geti(x, m-1)
  elseif is_string(m) then
    return _C.mad_tpsa_gets(x, #m, m)
  else
    m = is_table(m) and monomial(m) or m
    assert(is_monomial(m), "invalid argument #2 (integer, string, table or monomial expected)")
    return _C.mad_tpsa_getm(x, m.n, m.ord)
  end
end

function MC.get (x, m) -- idx or str or mono -> cnum
  if is_integer(m) then
    if m == 1
    then return x.coef[0]
    else _C.mad_ctpsa_geti_r(x, m-1, cres) return cres[0]
    end
  elseif is_string(m) then
    _C.mad_ctpsa_gets(x, #m, m, cres) return cres[0]
  else
    m = is_table(m) and monomial(m) or m
    assert(is_monomial(m), "invalid argument #2 (integer, string, table or monomial expected)")
    _C.mad_ctpsa_getm_r(x, m.n, m.ord, cres) return cres[0]
  end
end

function MR.set (x, m, a, b)
  if is_nil(b) then a, b = 0, a end
  if is_integer(m) then
    if m == 1
    then _C.mad_tpsa_set0(x,      a, b) return x
    else _C.mad_tpsa_seti(x, m-1, a, b) return x
    end
  elseif is_string(m) then
    _C.mad_tpsa_sets(x, #m, m, a, b) return x
  else
    m = is_table(m) and monomial(m) or m
    assert(is_monomial(m), "invalid argument #2 (integer, string, table or monomial expected)")
    _C.mad_tpsa_setm(x, m.n, m.ord, a, b) return x
  end
end

function MC.set (x, m, a, b)
  if is_nil(b) then a, b = 0, a end
  a, b = complex(a), complex(b)
  if is_integer(m) then
    if m == 1
    then _C.mad_ctpsa_set0_r(x,      a.re, a.im, b.re, b.im) return x
    else _C.mad_ctpsa_seti_r(x, m-1, a.re, a.im, b.re, b.im) return x
    end
  elseif is_string(m) then
    _C.mad_ctpsa_sets_r(x, #m, m, a.re, a.im, b.re, b.im) return x
  else
    m = is_table(m) and monomial(m) or m
    assert(is_monomial(m), "invalid argument #2 (integer, string, table or monomial expected)")
    _C.mad_ctpsa_setm_r(x, m.n, m.ord, a.re, a.im, b.re, b.im) return x
  end
end

-- sparse getters and setters -------------------------------------------------o

function MR.get_sparse (x, tbl) -- tbl = {idx1, ord1, idx2, ord2, ... } -> num
  assert(is_table(tbl), "invalid argument #2 (table expected)")
  local n = #tbl
  local m = int_arr(n) ; for i=1,n do m[i-1] = tbl[i] end
  return _C.mad_tpsa_getsm(x, n, m)
end

function MC.get_sparse (x, tbl) -- tbl = {idx1, ord1, idx2, ord2, ... } -> cnum
  assert(is_table(tbl), "invalid argument #2 (table expected)")
  local n = #tbl
  local m = int_arr(n) ; for i=1,n do m[i-1] = tbl[i] end
  _C.mad_ctpsa_getsm_r(x, n, m, cres) return cres[0]
end

function MR.set_sparse (x, tbl, a, b) -- tbl = {idx1, ord1, idx2, ord2, ... }
  assert(is_table(tbl), "invalid argument #2 (table expected)")
  if is_nil(b) then a, b = 0, a end
  local n = #tbl
  local m = int_arr(n) ; for i=1,n do m[i-1] = tbl[i] end
  _C.mad_tpsa_setsm(x, n, m, a, b) return x
end

function MC.set_sparse (x, tbl, a, b) -- tbl = {idx1, ord1, idx2, ord2, ... }
  assert(is_table(tbl), "invalid argument #2 (table expected)")
  if is_nil(b) then a, b = 0, a end
  a, b = complex(a), complex(b)
  local n = #tbl
  local m = int_arr(n) ; for i=1,n do m[i-1] = tbl[i] end
  _C.mad_ctpsa_setsm_r(x, n, m, a.re, a.im, b.re, b.im) return x
end

-- table/vector getters and setters -------------------------------------------o

function MR.getv (x, i, a)
  assert(is_integer(i), "invalid argument #2 (integer expected)")
  if is_integer(a) then a = vector(a) end
  assert(is_matrix (a), "invalid argument #3 (vector expected)")
  _C.mad_tpsa_getv(x, i-1, a:size(), a.data)
  return a
end

function MC.getv (x, i, a)
  assert(is_integer(i), "invalid argument #2 (integer expected)")
  if is_integer(a) then a = cvector(a) end
  assert(is_cmatrix(a), "invalid argument #3 (cvector expected)")
  _C.mad_ctpsa_getv(x, i-1, a:size(), a.data)
  return a
end

function MR.setv (x, i, a)
  assert(is_integer(i), "invalid argument #2 (integer expected)")
  if is_vector(a) then
    _C.mad_tpsa_setv(x, i-1, a:size(), a.data)
  elseif is_iterable(a) then
    for j,v in ipairs(a) do
      _C.mad_tpsa_seti(x, j+i-2, 0, v)
    end
  else error("invalid argument #3 (table or vector expected)")
  end
  return x
end

function MC.setv (x, i, a)
  assert(is_integer(i), "invalid argument #2 (integer expected)")
  if is_cvector(a) then
    _C.mad_ctpsa_setv(x, i-1, a:size(), a.data)
  elseif is_iterable(a) then
    for j,v in ipairs(a) do
      v = complex(v)
      _C.mad_ctpsa_seti_r(x, j+i-2, 0, 0, v.re, v.im)
    end
  else error("invalid argument #3 (table or cvector expected)")
  end
  return x
end

-- conversion -----------------------------------------------------------------o

function MR.complex (_, re_, im_, r) -- (re,im) -> r, r can be x
  local re, im = re_ or im_, im_ or re_
  assert(is_tpsa(re) and is_tpsa(im), "invalid argument #2 or #3 (tpsa expected)")
  r = chksiz(r,re,im) or ctpsa(re, max(re.mo, im.mo))
  _C.mad_ctpsa_complex(re_, im_, r) return r
end

function MC.real (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_real(x, r) return r
end

function MC.imag (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_imag(x, r) return r
end

-- operators ------------------------------------------------------------------o

-- unm

function MR.__unm (x, _, r) -- note: _ is dummy arg, see Lua specs.
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_scl(x, -1, r) return r
end

function MC.__unm (x, _, r) -- note: _ is dummy arg, see Lua specs.
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_scl_r(x, -1, 0, r) return r
end

-- equ

local function tpsa_eqn (x, y, tol)
  return x.hi == 0 and abs(x.coef[0]-y) <= tol
end

local function tpsa_eqc (x, y, tol)
  return x.hi == 0 and abs(          y.im) <= tol
                   and abs(x.coef[0]-y.re) <= tol
end

local function ctpsa_eqn (x, y, tol)
  return x.hi == 0 and abs(x.coef[0].im  ) <= tol
                   and abs(x.coef[0].re-y) <= tol
end

local function ctpsa_eqc (x, y, tol)
  return x.hi == 0 and abs(x.coef[0].re-y.re) <= tol
                   and abs(x.coef[0].im-y.im) <= tol
end

function MR.__req_cpx (y, x, tol_)               -- cpx == tpsa
  tol_ = tol_ or 0
  assert(is_number(tol_), "invalid argument #3 (number expected)")
  return tpsa_eqc(y, x, tol_)
end

function MR.__eq (x, y, tol_)
  tol_ = tol_ or 0
  assert(is_number(tol_), "invalid argument #3 (number expected)")
  if is_nil(y) then
    return false
  elseif is_number(x) then                       -- num == tpsa
    return tpsa_eqn(y, x, tol_)
  elseif is_number(y) then                       -- tpsa == num
    return tpsa_eqn(x, y, tol_)
  elseif is_complex(y) then                      -- tpsa == cpx
    return tpsa_eqc(x, y, tol_)
  elseif is_ctpsa(y) then                        -- tpsa == ctpsa
    assert(x.d == y.d, "incompatible GTPSA descriptor")
    return _C.mad_ctpsa_equt(y, x, tol_)
  elseif is_tpsa(y) and is_tpsa(x) then          -- tpsa == tpsa
    assert(x.d == y.d, "incompatible GTPSA descriptor")
    return _C.mad_tpsa_equ(x, y, tol_)
  elseif has_method(y, '__req_tpsa') then        -- tpsa + ?
    return y:__req_tpsa(x, r)
  end
  error("invalid arguments (unsupported GTPSA operation '==')")
end

function MC.__req_cpx (y, x, tol_)               -- cpx == tpsa
  tol_ = tol_ or 0
  assert(is_number(tol_), "invalid argument #3 (number expected)")
  return ctpsa_eqc(y, x, tol_)
end

function MC.__eq (x, y, tol_)
  tol_ = tol_ or 0
  assert(is_number(tol_), "invalid argument #3 (number expected)")
  if is_nil(y) then
    return false
  elseif is_number(x) then                       -- num == ctpsa
    return ctpsa_eqn(y, x, tol_)
  elseif is_number(y) then                       -- ctpsa == num
    return ctpsa_eqn(x, y, tol_)
  elseif is_complex(y) then                      -- ctpsa == cpx
    return ctpsa_eqc(x, y, tol_)
  elseif is_tpsa(y) then                         -- ctpsa == tpsa
    assert(x.d == y.d, "incompatible GTPSA descriptor")
    return _C.mad_ctpsa_equt(x, y, tol_)
  elseif is_ctpsa(y) and is_ctpsa(x) then        -- ctpsa == ctpsa
    assert(x.d == y.d, "incompatible GTPSA descriptor")
    return _C.mad_ctpsa_equ(x, y, tol_)
  elseif has_method(y, '__req_ctpsa') then       -- ctpsa + ?
    return y:__req_ctpsa(x, r)
  end
  error("invalid arguments (unsupported GTPSA operation '==')")
end

-- add (see also kadd)

function MR.__radd_cpx (y, x, r)                 -- cpx + tpsa
  if y.hi == 0 then return x + y.coef[0] end     -- promote to num
  r = chksiz(r,y) or ctpsa_alloc(y.d, y.mo)      -- promote to ctpsa
  _C.mad_ctpsa_complex(y, nil, r)
  _C.mad_ctpsa_set0_r(r, 1, 0, x.re, x.im) return r
end

function MR.__add (x, y, r)
  if is_number(x) then                           -- num + tpsa
    if y.hi == 0 then return x + y.coef[0] end   -- promote to num
    r = chksiz(r,y) or tpsa_alloc(y.d, y.mo)
    _C.mad_tpsa_copy(y, r)
    _C.mad_tpsa_set0(r, 1, x) return r
  elseif is_number(y) then                       -- tpsa + num
    if x.hi == 0 then return x.coef[0] + y end   -- promote to num
    r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
    _C.mad_tpsa_copy(x, r)
    _C.mad_tpsa_set0(r, 1, y) return r
  elseif is_complex(y) then                      -- tpsa + cpx
    if x.hi == 0 then return x.coef[0] + y end   -- promote to num
    r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)    -- promote to ctpsa
    _C.mad_ctpsa_complex(x, nil, r)
    _C.mad_ctpsa_set0_r(r, 1, 0, y.re, y.im) return r
  elseif is_ctpsa(y) then                        -- tpsa + ctpsa
    if x.hi == 0 and y.hi == 0 then return x.coef[0] + y.coef[0] end
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_tadd(x, y, r) return r
  elseif is_tpsa(y) and is_tpsa(x) then          -- tpsa + tpsa
    if x.hi == 0 and y.hi == 0 then return x.coef[0] + y.coef[0] end
    r = chksiz(r,x,y) or tpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_tpsa_add(x, y, r) return r
  elseif has_method(y, '__radd_tpsa') then       -- tpsa + ?
    return y:__radd_tpsa(x, r)
  end
  error("invalid arguments (unsupported GTPSA operation '+')")
end

function MC.__radd_cpx (y, x, r)                 -- cpx + ctpsa
  if y.hi == 0 then return x + y.coef[0] end     -- promote to cpx
  r = chksiz(r,y) or ctpsa_alloc(y.d, y.mo)
  _C.mad_ctpsa_copy(y, r)
  _C.mad_ctpsa_set0_r(r, 1, 0, x.re, x.im) return r
end

function MC.__add (x, y, r)
  if is_number(x) then                           -- num + ctpsa
    if y.hi == 0 then return x + y.coef[0] end   -- promote to cpx
    r = chksiz(r,y) or ctpsa_alloc(y.d, y.mo)
    _C.mad_ctpsa_copy(y, r)
    _C.mad_ctpsa_set0_r(r, 1, 0, x, 0) return r
  elseif is_number(y) then                       -- ctpsa + num
    if x.hi == 0 then return x.coef[0] + y end   -- promote to cpx
    r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
    _C.mad_ctpsa_copy(x, r)
    _C.mad_ctpsa_set0_r(r, 1, 0, y, 0) return r
  elseif is_complex(y) then                      -- ctpsa + cpx
    if x.hi == 0 then return x.coef[0] + y end   -- promote to cpx
    r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
    _C.mad_ctpsa_copy(x, r)
    _C.mad_ctpsa_set0_r(r, 1, 0, y.re, y.im) return r
  elseif is_tpsa(y) then                         -- ctpsa + tpsa
    if x.hi == 0 and y.hi == 0 then return x.coef[0] + y.coef[0] end
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_addt(x, y, r) return r
  elseif is_ctpsa(y) and is_ctpsa(x) then        -- ctpsa + ctpsa
    if x.hi == 0 and y.hi == 0 then return x.coef[0] + y.coef[0] end
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_add(x, y, r) return r
  elseif has_method(y, '__radd_ctpsa') then      -- ctpsa + ?
    return y:__radd_ctpsa(x, r)
  end
  error("invalid arguments (unsupported GTPSA operation '+')")
end

-- sub (see also kadd)

function MR.__rsub_cpx (y, x, r)                 -- cpx - tpsa
  if y.hi == 0 then return x - y.coef[0] end     -- promote to num
  r = chksiz(r,y) or ctpsa_alloc(y.d, y.mo)      -- promote to ctpsa
  _C.mad_ctpsa_complex(y, nil, r)
  _C.mad_ctpsa_set0_r(r, 1, 0, x.re, x.im) return r
end

function MR.__sub (x, y, r)
  if is_number(x) then                           -- num - tpsa
    if y.hi == 0 then return x - y.coef[0] end   -- promote to num
    r = chksiz(r,y) or tpsa_alloc(y.d, y.mo)
    _C.mad_tpsa_scl(y, -1, r)
    _C.mad_tpsa_set0(r, 1, x) return r
  elseif is_number(y) then                       -- tpsa - num
    if x.hi == 0 then return x.coef[0] - y end   -- promote to num
    r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
    _C.mad_tpsa_copy(x, r)
    _C.mad_tpsa_set0(r, 1, -y) return r
  elseif is_complex(y) then                      -- tpsa - cpx
    if x.hi == 0 then return x.coef[0] - y end   -- promote to num
    r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)    -- promote to ctpsa
    _C.mad_ctpsa_copy(x, r)
    _C.mad_ctpsa_set0_r(r, 1, 0, -y.re, -y.im) return r
  elseif is_ctpsa(y) then                        -- tpsa - ctpsa
    if x.hi == 0 and y.hi == 0 then return x.coef[0] - y.coef[0] end
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_tsub(x, y, r) return r
  elseif is_tpsa(y) and is_tpsa(x) then          -- tpsa - tpsa
    if x.hi == 0 and y.hi == 0 then return x.coef[0] - y.coef[0] end
    r = chksiz(r,x,y) or tpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_tpsa_sub(x, y, r) return r
  elseif has_method(y, '__rsub_tpsa') then       -- tpsa - ?
    return y:__rsub_tpsa(x, r)
  end
  error("invalid arguments (unsupported GTPSA operation '-')")
end

function MC.__rsub_cpx (y, x, r)                 -- cpx - ctpsa
  if y.hi == 0 then return x - y.coef[0] end     -- promote to cpx
  r = chksiz(r,y) or ctpsa_alloc(y.d, y.mo)
  _C.mad_ctpsa_copy(y, r)
  _C.mad_ctpsa_set0_r(r, 1, 0, x.re, x.im) return r
end

function MC.__sub (x, y, r)
  if is_number(x) then                           -- num - ctpsa
    if y.hi == 0 then return x - y.coef[0] end   -- promote to cpx
    r = chksiz(r,y) or ctpsa_alloc(y.d, y.mo)
    _C.mad_ctpsa_scl(y, -1, r)
    _C.mad_ctpsa_set0_r(r, 1, 0, x, 0) return r
  elseif is_number(y) then                       -- ctpsa - num
    if x.hi == 0 then return x.coef[0] - y end   -- promote to cpx
    r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
    _C.mad_ctpsa_copy(x, r)
    _C.mad_ctpsa_set0_r(r, 1, 0, -y, 0) return r
  elseif is_complex(y) then                      -- ctpsa - cpx
    if x.hi == 0 then return x.coef[0] - y end   -- promote to cpx
    r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
    _C.mad_ctpsa_copy(x, r)
    _C.mad_ctpsa_set0_r(r, 1, 0, -y.re, -y.im) return r
  elseif is_tpsa(y) then                         -- ctpsa - tpsa
    if x.hi == 0 and y.hi == 0 then return x.coef[0] - y.coef[0] end
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_subt(x, y, r) return r
  elseif is_ctpsa(y) and is_ctpsa(x) then        -- ctpsa - ctpsa
    if x.hi == 0 and y.hi == 0 then return x.coef[0] - y.coef[0] end
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_sub(x, y, r) return r
  elseif has_method(y, '__rsub_ctpsa') then      -- ctpsa - ?
    return y:__rsub_ctpsa(x, r)
  end
  error("invalid arguments (unsupported GTPSA operation '-')")
end

-- mul

function MR.__rmul_cpx (y, x, r)                 -- cpx * tpsa
  if y.hi == 0 then return x * y.coef[0] end     -- promote to num
  r = chksiz(r,y) or ctpsa_alloc(y.d, y.mo)      -- promote to ctpsa
  _C.mad_ctpsa_complex(y, nil, r)
  _C.mad_ctpsa_scl_r(r, x.re, x.im, r) return r
end

function MR.__mul (x, y, r)
  if is_number(x) then                           -- num * tpsa
    if y.hi == 0 then return x * y.coef[0] end   -- promote to num
    r = chksiz(r,y) or tpsa_alloc(y.d, y.mo)
    _C.mad_tpsa_scl(y, x, r) return r
  elseif is_number(y) then                       -- tpsa * num
    if x.hi == 0 then return x.coef[0] * y end   -- promote to num
    r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
    _C.mad_tpsa_scl(x, y, r) return r
  elseif is_complex(y) then                      -- tpsa * cpx
    if x.hi == 0 then return x.coef[0] * y end   -- promote to num
    r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)    -- promote to ctpsa
    _C.mad_ctpsa_complex(x, nil, r)
    _C.mad_ctpsa_scl_r(r, y.re, y.im, r) return r
  elseif is_ctpsa(y) then                        -- tpsa * ctpsa
    if x.hi == 0 and y.hi == 0 then return x.coef[0] * y.coef[0] end
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_tmul(x, y, r) return r
  elseif is_tpsa(y) and is_tpsa(x) then          -- tpsa * tpsa
    if x.hi == 0 and y.hi == 0 then return x.coef[0] * y.coef[0] end
    r = chksiz(r,x,y) or tpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_tpsa_mul(x, y, r) return r
  elseif has_method(y, '__rmul_tpsa') then       -- tpsa * ?
    return y:__rmul_tpsa(x, r)
  end
  error("invalid arguments (unsupported GTPSA operation '*')")
end

function MC.__rmul_cpx (y, x, r)                 -- cpx * ctpsa
  if y.hi == 0 then return x * y.coef[0] end     -- promote to cpx
  r = chksiz(r,y) or ctpsa_alloc(y.d, y.mo)
  _C.mad_ctpsa_scl_r(y, x.re, x.im, r) return r
end

function MC.__mul (x, y, r)
  if is_number(x) then                           -- num * ctpsa
    if y.hi == 0 then return x * y.coef[0] end   -- promote to cpx
    r = chksiz(r,y) or ctpsa_alloc(y.d, y.mo)
    _C.mad_ctpsa_scl_r(y, x, 0, r) return r
  elseif is_number(y) then                       -- ctpsa * num
    if x.hi == 0 then return x.coef[0] * y end   -- promote to cpx
    r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
    _C.mad_ctpsa_scl_r(x, y, 0, r) return r
  elseif is_complex(y) then                      -- ctpsa * cpx
    if x.hi == 0 then return x.coef[0] * y end   -- promote to cpx
    r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
    _C.mad_ctpsa_scl_r(x, y.re, y.im, r) return r
  elseif is_tpsa(y) then                         -- ctpsa * tpsa
    if x.hi == 0 and y.hi == 0 then return x.coef[0] * y.coef[0] end
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_mult(x, y, r) return r
  elseif is_ctpsa(y) and is_ctpsa(x) then        -- ctpsa * ctpsa
    if x.hi == 0 and y.hi == 0 then return x.coef[0] * y.coef[0] end
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_mul(x, y, r) return r
  elseif has_method(y, '__rmul_ctpsa') then      -- ctpsa * ?
    return y:__rmul_ctpsa(x, r)
  end
  error("invalid arguments (unsupported GTPSA operation '*')")
end

-- element wise mul (.*)

function MR.__emul (x, y, r_)
  if has_method(y,'__remul_tpsa') then           -- tpsa .* ?
    return y:__remul_tpsa(x, r_)
  end
  error("invalid arguments (unsupported GTPSA operation '.*'')")
end

function MC.__emul (x, y, r_)
  if has_method(y,'__remul_ctpsa') then          -- ctpsa .* ?
    return y:__remul_ctpsa(x, r_)
  end
  error("invalid arguments (unsupported GTPSA operation '.*'')")
end

-- div

function MR.__rdiv_cpx (y, x, r)                 -- cpx / tpsa
  if y.hi == 0 then return x / y.coef[0] end     -- promote to num
  r = chksiz(r,y) or ctpsa_alloc(y.d, y.mo)      -- promote to ctpsa
  _C.mad_ctpsa_complex(y, nil, r)
  _C.mad_ctpsa_inv_r(r, x.re, x.im, r) return r
end

function MR.__div (x, y, r)
  if is_number(x) then                           -- num / tpsa
    if y.hi == 0 then return x / y.coef[0] end   -- promote to num
    r = chksiz(r,y) or tpsa_alloc(y.d, y.mo)
    _C.mad_tpsa_inv(y, x, r) return r
  elseif is_number(y) then                       -- tpsa / num
    if x.hi == 0 then return x.coef[0] / y end   -- promote to num
    r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
    _C.mad_tpsa_scl(x, 1/y, r) return r
  elseif is_complex(y) then                      -- tpsa / cpx
    if x.hi == 0 then return x.coef[0] / y end   -- promote to num
    r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)    -- promote to ctpsa
    local _y = 1/y
    _C.mad_ctpsa_complex(x, nil, r)
    _C.mad_ctpsa_scl_r(r, _y.re, _y.im, r) return r
  elseif is_ctpsa(y) then                        -- tpsa / ctpsa
    if x.hi == 0 and y.hi == 0 then return x.coef[0] / y.coef[0] end
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_tdiv(x, y, r) return r
  elseif is_tpsa(y) and is_tpsa(x) then          -- tpsa / tpsa
    if x.hi == 0 and y.hi == 0 then return x.coef[0] / y.coef[0] end
    r = chksiz(r,x,y) or tpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_tpsa_div(x, y, r) return r
  elseif has_method(y, '__rdiv_tpsa') then       -- tpsa / ?
    return y:__rdiv_tpsa(x, r)
  end
  error("invalid arguments (unsupported GTPSA operation '/')")
end

function MC.__rdiv_cpx (y, x, r)                 -- cpx / ctpsa
  if y.hi == 0 then return x / y.coef[0] end     -- promote to cpx
  r = chksiz(r,y) or ctpsa_alloc(y.d, y.mo)
  _C.mad_ctpsa_inv_r(y, x.re, x.im, r) return r
end

function MC.__div (x, y, r)
  if is_number(x) then                           -- num / ctpsa
    if y.hi == 0 then return x / y.coef[0] end   -- promote to cpx
    r = chksiz(r,y) or ctpsa_alloc(y.d, y.mo)
    _C.mad_ctpsa_inv_r(y, 1/x, 0, r) return r
  elseif is_number(y) then                       -- ctpsa / num
    if x.hi == 0 then return x.coef[0] / y end   -- promote to cpx
    r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
    _C.mad_ctpsa_scl_r(x, 1/y, 0, r) return r
  elseif is_complex(y) then                      -- ctpsa / cpx
    if x.hi == 0 then return x.coef[0] / y end   -- promote to cpx
    r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
    local _y = 1/y
    _C.mad_ctpsa_scl_r(x, _y.re, _y.im, r) return r
  elseif is_tpsa(y) then                         -- ctpsa / tpsa
    if x.hi == 0 and y.hi == 0 then return x.coef[0] / y.coef[0] end
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_divt(x, y, r) return r
  elseif is_ctpsa(y) and is_ctpsa(x) then        -- ctpsa / ctpsa
    if x.hi == 0 and y.hi == 0 then return x.coef[0] / y.coef[0] end
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_div(x, y, r) return r
  elseif has_method(y, '__rdiv_ctpsa') then      -- ctpsa / ?
    return y:__rdiv_ctpsa(x, r)
  end
  error("invalid arguments (unsupported GTPSA operation '/')")
end

-- element wise div (./)

function MR.__ediv (x, y, r_)
  if has_method(y,'__rediv_tpsa') then           -- tpsa ./ ?
    return y:__rediv_tpsa(x, r_)
  end
  error("invalid arguments (unsupported GTPSA operation './'')")
end

function MC.__ediv (x, y, r_)
  if has_method(y,'__rediv_ctpsa') then          -- ctpsa ./ ?
    return y:__rediv_ctpsa(x, r_)
  end
  error("invalid arguments (unsupported GTPSA operation './'')")
end

-- element wise mod (.%)

function MR.__emod (x, y, r_)
  if has_method(y,'__remod_tpsa') then           -- tpsa .% ?
    return y:__remod_tpsa(x, r_)
  end
  error("invalid arguments (unsupported GTPSA operation '.%'')")
end

function MC.__emod (x, y, r_)
  if has_method(y,'__remod_ctpsa') then          -- ctpsa .% ?
    return y:__remod_ctpsa(x, r_)
  end
  error("invalid arguments (unsupported GTPSA operation '.%'')")
end

-- pow = exp(y*log(x))

function MR.__rpow_cpx (y, x, r)                 -- cpx ^ tpsa
  if y.hi == 0 then return x ^ y.coef[0] end     -- promote to num
  r = chksiz(r,y) or ctpsa_alloc(y.d, y.mo)      -- promote to ctpsa
  local logx = log(x)
  _C.mad_ctpsa_complex(y, nil, r)
  _C.mad_ctpsa_scl_r(r, logx.re, logx.im, r)
  _C.mad_ctpsa_exp(r, r) return r
end

function MR.__pow (x, y, r)
  if is_number(x) then                           -- num ^ tpsa
    if y.hi == 0 then return x ^ y.coef[0] end   -- promote to num
    r = chksiz(r,y) or tpsa_alloc(y.d, y.mo)
    _C.mad_tpsa_scl(y, log(x), r)
    _C.mad_tpsa_exp(r, r) return r
  elseif is_number(y) then                       -- tpsa ^ num
    if x.hi == 0 then return x.coef[0] ^ y end   -- promote to num
    r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
    if is_integer(y)
    then _C.mad_tpsa_powi(x, y, r) return r
    else _C.mad_tpsa_pown(x, y, r) return r
    end
  elseif is_complex(y) then                      -- tpsa ^ cpx
    if x.hi == 0 then return x.coef[0] ^ y end   -- promote to num
    r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)    -- promote to ctpsa
    _C.mad_ctpsa_complex(x, nil, r)
    _C.mad_ctpsa_pown_r(x, y.re, y.im, r) return r
  elseif is_ctpsa(y) then                        -- tpsa ^ ctpsa
    if x.hi == 0 and y.hi == 0 then return x.coef[0] ^ y.coef[0] end
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_complex(x, nil, r)
    _C.mad_ctpsa_pow(r, y, r) return r
  elseif is_tpsa(y) and is_tpsa(x) then          -- tpsa ^ tpsa
    if x.hi == 0 and y.hi == 0 then return x.coef[0] ^ y.coef[0] end
    r = chksiz(r,x,y) or tpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_tpsa_pow(x, y, r) return r
  elseif has_method(y, '__rpow_tpsa') then       -- tpsa ^ ?
    return y:__rpow_tpsa(x, r)
  end
  error("invalid arguments (unsupported GTPSA operation '^')")
end

function MC.__rpow_cpx (y, x, r)                 -- cpx ^ ctpsa
  if y.hi == 0 then return x ^ y.coef[0] end     -- promote to cpx
  r = chksiz(r,y) or ctpsa_alloc(y.d, y.mo)
  local logx = log(x)
  _C.mad_ctpsa_scl_r(y, logx.re, logx.im, r)
  _C.mad_ctpsa_exp(r, r) return r
end

function MC.__pow (x, y, r)
  if is_number(x) then                           -- num ^ ctpsa
    if y.hi == 0 then return x ^ y.coef[0] end   -- promote to cpx
    r = chksiz(r,y) or ctpsa_alloc(y.d, y.mo)
    local logx = log(complex(x))
    _C.mad_ctpsa_scl_r(y, logx.re, logx.im, r)
    _C.mad_ctpsa_exp(r, r) return r
  elseif is_number(y) then                       -- ctpsa ^ num
    if x.hi == 0 then return x.coef[0] ^ y end   -- promote to cpx
    r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
    if is_integer(y)
    then _C.mad_ctpsa_powi(x, y, r) return r
    else y = complex(y)
         _C.mad_ctpsa_pown_r(x, y.re, y.im, r) return r
    end
  elseif is_complex(y) then                      -- ctpsa ^ cpx
    if x.hi == 0 then return x.coef[0] ^ y end   -- promote to cpx
    r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
    _C.mad_ctpsa_pown_r(x, y.re, y.im, r) return r
  elseif is_tpsa(y) then                         -- ctpsa ^ tpsa
    if x.hi == 0 and y.hi == 0 then return x.coef[0] ^ y.coef[0] end
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_complex(y, nil, r)
    _C.mad_ctpsa_pow(x, r, r) return r
  elseif is_ctpsa(y) and is_ctpsa(x) then        -- ctpsa ^ ctpsa
    if x.hi == 0 and y.hi == 0 then return x.coef[0] ^ y.coef[0] end
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_pow(x, y, r) return r
  elseif has_method(y, '__rpow_ctpsa') then      -- ctpsa ^ ?
    return y:__rpow_ctpsa(x, r)
  end
  error("invalid arguments (unsupported GTPSA operation '^')")
end

-- element wise pow (.%)

function MR.__epow (x, y, r_)
  if has_method(y,'__repow_tpsa') then           -- tpsa .% ?
    return y:__repow_tpsa(x, r_)
  end
  error("invalid arguments (unsupported GTPSA operation '.%'')")
end

function MC.__epow (x, y, r_)
  if has_method(y,'__repow_ctpsa') then          -- ctpsa .% ?
    return y:__repow_ctpsa(x, r_)
  end
  error("invalid arguments (unsupported GTPSA operation '.%'')")
end

-- tpsa functions -------------------------------------------------------------o

function MR.abs (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_abs(x,r) return r
end

function MR.nrm1 (x)
  return _C.mad_tpsa_nrm1(x)
end

function MR.nrm2 (x)
  return _C.mad_tpsa_nrm2(x)
end

function MR.deriv (x, m, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  if is_integer(m) then
    _C.mad_tpsa_deriv(x, r, m) return r
  else
    m = is_table(m) and monomial(m) or m
    assert(is_monomial(m), "invalid argument #2 (table or monomial expected)")
    _C.mad_tpsa_derivm(x, r, m.n, m.ord) return r
  end
end

function MR.poisson (x, y, n, r)
  assert(is_integer(n), "invalid arguments (unsupported GTPSA operation '[,]')")
  if is_tpsa(y) then
    r = chksiz(r,x,y) or tpsa_alloc(x.d, max(x.mo,y.mo))
    _C.mad_tpsa_poisson (x, y, r, n) return r
  elseif is_ctpsa(y) then
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo,y.mo))
    _C.mad_ctpsa_tpoiss(x, y, r, n) return r
  end
  error("invalid arguments (unsupported GTPSA operation '[,]')")
end

function MR.acc (x, v, r)  -- r += v*x
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_acc(x, v, r) return r
end

function MR.scl (x, v, r) -- r = v*x
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_scl(x, v, r) return r
end

function MR.inv (x, v_, r)  -- r = v/x
  if is_tpsa(v_) and is_nil(r) then
    v_, r = nil, v_ -- right shift
  end
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_inv(x, v_ or 1, r) return r
end

function MR.invsqrt (x, v_, r) -- r = v/sqrt(x)
  if is_tpsa(v_) and is_nil(r) then
    v_, r = nil, v_ -- right shift
  end
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_invsqrt(x, v_ or 1, r) return r
end

function MR.sqrt (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_sqrt(x, r) return r
end

function MR.exp (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_exp(x, r) return r
end

function MR.log (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_log(x, r) return r
end

function MR.sincos (x, rs, rc)
  rs = chksiz(rs,x) or tpsa_alloc(x.d, x.mo)
  rc = chksiz(rc,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_sincos(x, rs, rc) return rs, rc
end

function MR.sin (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_sin(x, r) return r
end

function MR.cos (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_cos(x, r) return r
end

function MR.tan (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_tan(x, r) return r
end

function MR.cot (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_cot(x, r) return r
end

function MR.sincosh (x, rs, rc)
  rs = chksiz(rs,x) or tpsa_alloc(x.d, x.mo)
  rc = chksiz(rc,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_sincosh(x, rs, rc) return rs, rc
end

function MR.sinh (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_sinh(x, r) return r
end

function MR.cosh (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_cosh(x, r) return r
end

function MR.tanh (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_tanh(x, r) return r
end

function MR.coth (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_coth(x, r) return r
end

function MR.asin (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_asin(x, r) return r
end

function MR.acos (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_acos(x, r) return r
end

function MR.atan (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_atan(x, r) return r
end

function MR.acot (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_acot(x, r) return r
end

function MR.asinh (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_asinh(x, r) return r
end

function MR.acosh (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_acosh(x, r) return r
end

function MR.atanh (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_atanh(x, r) return r
end

function MR.acoth (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_acoth(x, r) return r
end

function MR.sinc (x, r) -- sin(x)/x
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_sinc(x, r) return r
end

function MR.erf (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_erf(x, r) return r
end

function MR.erfc (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_erfc(x, r) return r
end

-- ctpsa functions ------------------------------------------------------------o

function MC.abs (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_abs(x,r) return r
end

function MC.arg (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_arg(x,r) return r
end

function MC.conj (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_conj(x,r) return r
end

function MC.nrm1 (x)
  _C.mad_ctpsa_nrm1(x, cres) return cres[0]
end

function MC.nrm2 (x)
  _C.mad_ctpsa_nrm2(x, cres) return cres[0]
end

function MC.deriv (x, m, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  if is_integer(m) then
    _C.mad_ctpsa_deriv(x, r, m) return r
  else
    m = is_table(m) and monomial(m) or m
    assert(is_monomial(m), "invalid argument #2 (table or monomial expected)")
    _C.mad_cpsa_derivm(x, r, m.n, m.ord) return r
  end
end

function MC.poisson(x, y, n, r)
  assert(is_integer(n), "invalid arguments (unsupported GTPSA operation '[,]')")
  if is_tpsa(y) then
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo,y.mo))
    _C.mad_ctpsa_poisst (x, y, r, n) return r
  elseif is_ctpsa(y) then
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo,y.mo))
    _C.mad_ctpsa_poisson(x, y, r, n) return r
  end
  error("invalid arguments (unsupported GTPSA operation '[,]')")
end

function MC.acc (x, v, r)  -- r += v*x
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_acc(x, v, r) return r
end

function MC.scl (t, v, r) -- r = v*x
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_scl(t, v, r) return r
end

function MC.inv (x, v_, r)  -- r = v/x
  if is_ctpsa(v_) and is_nil(r) then
    v_, r = nil, v_ -- right shift
  end
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  v_ = complex(v_ or 1)
  _C.mad_ctpsa_inv_r(x, v_.re, v_.im, r) return r
end

function MC.invsqrt (x, v_, r) -- r = v/sqrt(x)
  if is_ctpsa(v_) and is_nil(r) then
    v_, r = nil, v_ -- right shift
  end
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  v_ = complex(v_ or 1)
  _C.mad_ctpsa_invsqrt(x, v_.re, v_.im, r) return r
end

function MC.sqrt (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_sqrt(x, r) return r
end

function MC.exp (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_exp(x, r) return r
end

function MC.log (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_log(x, r) return r
end

function MC.sincos (x, rs, rc)
  rs = chksiz(rs,x) or ctpsa_alloc(x.d, x.mo)
  rc = chksiz(rc,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_sincos(x, rs, rc) return rs, rc
end

function MC.sin (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_sin(x, r) return r
end

function MC.cos (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_cos(x, r) return r
end

function MC.tan (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_tan(x, r) return r
end

function MC.cot (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_cot(x, r) return r
end

function MC.sincosh (x, rs, rc)
  rs = chksiz(rs,x) or ctpsa_alloc(x.d, x.mo)
  rc = chksiz(rc,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_sincosh(x, rs, rc) return rs, rc
end

function MC.sinh (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_sinh(x, r) return r
end

function MC.cosh (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_cosh(x, r) return r
end

function MC.tanh (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_tanh(x, r) return r
end

function MC.coth (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_coth(x, r) return r
end

function MC.asin (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_asin(x, r) return r
end

function MC.acos (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_acos(x, r) return r
end

function MC.atan (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_atan(x, r) return r
end

function MC.acot (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_acot(x, r) return r
end

function MC.asinh (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_asinh(x, r) return r
end

function MC.acosh (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_acosh(x, r) return r
end

function MC.atanh (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_atanh(x, r) return r
end

function MC.acoth (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_acoth(x, r) return r
end

function MC.sinc (x, r) -- sin(x)/x
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_sinc(x, r) return r
end

function MC.erf (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_erf(x, r) return r
end

function MC.erfc (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_erfc(x, r) return r
end

-- tpsa high level functions --------------------------------------------------o

function MR.axpb (x, a, b, r) -- r = ax+b
  assert(is_number(a) and is_number(b), "invalid argument #2 or #3 (number expected)")
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_axpb(a,x,b,r) return r
end

function MR.axpbypc (x, y, a, b, c, r) -- r = ax+by+c
  assert(is_tpsa(y), "invalid argument #2 (tpsa expected)")
  assert(is_number(a) and is_number(b) and is_number(c),
         "invalid argument #3, #4 or #5 (number expected)")
  r = chksiz(r,x,y) or tpsa_alloc(x.d, max(x.mo,y.mo))
  _C.mad_tpsa_axpbypc(a,x,b,y,c,r) return r
end

function MR.axypb (x, y, a, b, r) -- r = axy+b
  assert(is_tpsa(y), "invalid argument #2 (tpsa expected)")
  assert(is_number(a) and is_number(b), "invalid argument #3 or #4 (number expected)")
  r = chksiz(r,x,y) or tpsa_alloc(x.d, max(x.mo,y.mo))
  _C.mad_tpsa_axypb(a,x,y,b,r) return r
end

function MR.axypbzpc (x, y, z, a, b, c, r) -- r = axy+bz+c
  assert(is_tpsa(y) and is_tpsa(z), "invalid argument #2 or #3 (tpsa expected)")
  assert(is_number(a) and is_number(b) and is_number(c),
         "invalid argument #4, #5 or #6 (number expected)")
  r = chksiz(r,x,y) and chksiz(r,z) or tpsa_alloc(x.d, max(x.mo,y.mo,z.mo))
  _C.mad_tpsa_axypbzpc(a,x,y,b,z,c,r) return r
end

function MR.axypbvwpc (x, y, v, w, a, b, c, r) -- r = axy+bvw+c
  assert(is_tpsa(y) and is_tpsa(v) and is_tpsa(w),
         "invalid argument #2, #3 or #4 (tpsa expected)")
  assert(is_number(a) and is_number(b) and is_number(c),
         "invalid argument #5, #6 or #7 (number expected)")
  r = chksiz(r,x,y) and chksiz(r,v,w) and chksiz(r,x,v) or
      tpsa_alloc(x.d, max(x.mo,y.mo,v.mo,w.mo))
  _C.mad_tpsa_axypbvwpc(a,x,y,b,v,w,c,r) return r
end

function MR.ax2pby2pcz2 (x, y, z, a, b, c, r) -- r = ax^2+by^2+cz^2
  assert(is_tpsa(y) and is_tpsa(z), "invalid argument #2 or #3 (tpsa expected)")
  assert(is_number(a) and is_number(b) and is_number(c),
         "invalid argument #4, #5 or #6 (number expected)")
  r = chksiz(r,x,y) and chksiz(r,x,z) or tpsa_alloc(x.d, max(x.mo,y.mo,z.mo))
  _C.mad_tpsa_ax2pby2pcz2(a,x,b,y,c,z,r) return r
end

function MR.axpsqrtbpcx2 (x, a, b, c, r) -- r = ax+sqrt(b+cx^2)
  assert(is_number(a) and is_number(b) and is_number(c),
         "invalid argument #2, #3 or #4 (scalar expected)")
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_axpsqrtbpcx2(x, a, b, c, r) return r
end

function MR.logaxpsqrtbpcx2 (x, a, b, c, r) -- r = log(ax+sqrt(b+cx^2))
  assert(is_number(a) and is_number(b) and is_number(c),
         "invalid argument #2, #3 or #4 (scalar expected)")
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_logaxpsqrtbpcx2(x, a, b, c, r) return r
end

function MR.logxdy (x, y, r) -- r = log(x/y)
  assert(is_tpsa(y), "invalid argument #2 (tpsa expected)")
  r = chksiz(r,x,y) or tpsa_alloc(x.d, max(x.mo,y.mo))
  _C.mad_tpsa_logxdy(x, y, r) return r
end

-- ctpsa high level functions -------------------------------------------------o

function MC.axpb (x, a, b, r) -- r = ax+b
  assert(is_scalar(a) and is_scalar(b), "invalid argument #2 or #3 (scalar expected)")
  a, b = complex(a), complex(b)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_axpb_r(a.re,a.im, x, b.re,b.im, r) return r
end

function MC.axpbypc (x, y, a, b, c, r) -- r = ax+by+c
  assert(is_ctpsa(y), "invalid argument #2 (ctpsa expected)")
  assert(is_scalar(a) and is_scalar(b) and is_scalar(c),
         "invalid argument #3, #4 or #5 (scalar expected)")
  a, b, c = complex(a), complex(b), complex(c)
  r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo,y.mo))
  _C.mad_ctpsa_axpbypc_r(a.re,a.im, x, b.re,b.im, y, c.re,c.im, r) return r
end

function MC.axypb (x, y, a, b, r) -- r = axy+b
  assert(is_ctpsa(y), "invalid argument #2 (ctpsa expected)")
  assert(is_scalar(a) and is_scalar(b), "invalid argument #3 or #4 (scalar expected)")
  a, b = complex(a), complex(b)
  r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo,y.mo))
  _C.mad_ctpsa_axypb_r(a.re,a.im, x, y, b.re,b.im, r) return r
end

function MC.axypbzpc (x, y, z, a, b, c, r) -- r = axy+bz+c
  assert(is_ctpsa(y) and is_ctpsa(z), "invalid argument #2 or #3 (ctpsa expected)")
  assert(is_scalar(a) and is_scalar(b) and is_scalar(c),
         "invalid argument #4, #5 or #6 (scalar expected)")
  a, b, c = complex(a), complex(b), complex(c)
  r = chksiz(r,x,y) and chksiz(r,z) or ctpsa_alloc(x.d, max(x.mo,y.mo,z.mo))
  _C.mad_ctpsa_axypbzpc_r(a.re,a.im, x, y, b.re,b.im, z, c.re,c.im, r) return r
end

function MC.axypbvwpc (x, y, v, w, a, b, c, r) -- r = axy+bvw+c
  assert(is_ctpsa(y) and is_ctpsa(v) and is_ctpsa(w),
         "invalid argument #2, #3 or #4 (ctpsa expected)")
  assert(is_scalar(a) and is_scalar(b) and is_scalar(c),
         "invalid argument #5, #6 or #7 (scalar expected)")
  r = chksiz(r,x,y) and chksiz(r,v,w) and chksiz(r,x,v) or
      ctpsa_alloc(x.d, max(x.mo,y.mo,v.mo,w.mo))
  _C.mad_ctpsa_axypbvwpc_r(a.re,a.im, x,y, b.re,b.im, v,w, c.re,c.im, r) return r
end

function MC.ax2pby2pcz2 (x, y, z, a, b, c, r) -- r = ax^2+by^2+cz^2
  assert(is_ctpsa(y) and is_ctpsa(z), "invalid argument #2 or #3 (ctpsa expected)")
  assert(is_scalar(a) and is_scalar(b) and is_scalar(c),
         "invalid argument #4, #5 or #6 (scalar expected)")
  r = chksiz(r,x,y) and chksiz(r,x,z) or ctpsa_alloc(x.d, max(x.mo,y.mo,z.mo))
  _C.mad_ctpsa_ax2pby2pcz2_r(a.re,a.im, x, b.re,b.im, y, c.re,c.im, z, r) return r
end

function MC.axpsqrtbpcx2 (x, a, b, c, r) -- r = ax+sqrt(b+cx^2)
  assert(is_scalar(a) and is_scalar(b) and is_scalar(c),
         "invalid argument #2, #3 or #4 (scalar expected)")
  a, b, c = complex(a), complex(b), complex(c)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_axpsqrtbpcx2_r(x, a.re,a.im, b.re,b.im, c.re,c.im, r) return r
end

function MC.logaxpsqrtbpcx2 (x, a, b, c, r) -- r = log(ax+sqrt(b+cx^2))
  assert(is_scalar(a) and is_scalar(b) and is_scalar(c),
         "invalid argument #2, #3 or #4 (scalar expected)")
  a, b, c = complex(a), complex(b), complex(c)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_logaxpsqrtbpcx2_r(x, a.re,a.im, b.re,b.im, c.re,c.im, r) return r
end

function MC.logxdy (x, y, r) -- r = log(x/y)
  assert(is_ctpsa(y), "invalid argument #2 (tpsa expected)")
  r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo,y.mo))
  _C.mad_ctpsa_logxdy(x, y, r) return r
end

-- I/O ------------------------------------------------------------------------o

function MR.write (x, filnam_, name_, eps_)
  local file = openfile(filnam_, 'w', '.dat')
  _C.mad_tpsa_print(x, name_, eps_ or -1, file)
  if is_string(filnam_) then file:close() else file:flush() end
  return x
end

function MC.write (x, filnam_, name_, eps_)
  local file = openfile(filnam_, 'w', '.dat')
  _C.mad_ctpsa_print(x, name_, eps_ or -1, file)
  if is_string(filnam_) then file:close() else file:flush() end
  return x
end

function MR.print (x, name_, eps_)
  if is_nil(eps_) and is_number(name_) then
    name_, eps_ = nil, name_ -- right shift
  end
  return x:write(nil, name_, eps_)
end

function MR.read (_, filnam_)
  local file = openfile(filnam_, 'r', '.dat')
  local d = _C.mad_tpsa_scan_hdr(file)
  local x = tpsa(d)
  _C.mad_tpsa_scan_coef(x, file)
  if is_string(filnam_) then file:close() end
  return x
end

function MC.read (_, filnam_)
  local file = openfile(filnam_, 'r', '.dat')
  local d = _C.mad_tpsa_cscan_hdr(file)
  local x = ctpsa(d)
  _C.mad_ctpsa_cscan_coef(x, file)
  if is_string(filnam_) then file:close() end
  return x
end

-- metamethods ----------------------------------------------------------------o

MR.unm = \x,r_ -> MR.__unm(x,nil,r_)
MC.unm = \x,r_ -> MC.__unm(x,nil,r_)

MR.  add, MR.  sub, MR.  mul, MR.  div, MR.  pow =
MR.__add, MR.__sub, MR.__mul, MR.__div, MR.__pow

MC.  add, MC.  sub, MC.  mul, MC.  div, MC.  pow =
MC.__add, MC.__sub, MC.__mul, MC.__div, MC.__pow

MR.  emul, MR.  ediv, MR.  emod, MR.  epow =
MR.__emul, MR.__ediv, MR.__emod, MR.__epow

MC.  emul, MC.  ediv, MC.  emod, MC.  epow =
MC.__emul, MC.__ediv, MC.__emod, MC.__epow

MR.  eq, MR.  same, MR.  copy, MR.length =
MR.__eq, MR.__same, MR.__copy, MR.__len

MC.  eq, MC.  same, MC.  copy, MC.length =
MC.__eq, MC.__same, MC.__copy, MC.__len

MR.__index = MR
MC.__index = MC

function MR.__newindex (_, i)
  error("invalid GTPSA member '".. tostring(i) .."'")
end

-- MR -> MC -------------------------------------------------------------------o

for k,v in pairs(MR) do
  if is_nil(MC[k]) then MC[k] = v end
end

-- TODO: set concepts for MR and MC

-- env ------------------------------------------------------------------------o

MAD.typeid.is_gtpsad = is_gtpsad
MAD.typeid.is_tpsa   = is_tpsa
MAD.typeid.is_ctpsa  = is_ctpsa
MAD.typeid.isa_tpsa  = isa_tpsa

-- metatables -----------------------------------------------------------------o

MR.__metatable = MR
MC.__metatable = MC

ffi.metatype( tpsa_ctor, MR)
ffi.metatype(ctpsa_ctor, MC)

-- end ------------------------------------------------------------------------o
return {
   tpsa  =  tpsa,
  ctpsa  = ctpsa,
  gtpsad = gtpsad,
  -- __help = require 'madh_gtpsa',
}
