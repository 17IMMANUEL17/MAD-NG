--[=[
 o-----------------------------------------------------------------------------o
 |
 | Least Squares Optimizer module
 |
 | Methodical Accelerator Design - Copyright (c) 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - TODO

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local ffi = require 'ffi'
local _C, option, ivector, vector, matrix                        in MAD
local is_callable                                                in MAD.typeid
local assertf, errorf, printf                                    in MAD.utility
local eps, inf                                                   in MAD.constant
local abs, rand                                                  in MAD.gmath

local max in math

-- New algos ------------------------------------------------------------------o

ffi.cdef [[
enum {
 /* extra MAD algorithms */
  NLOPT_LD_LMDIF     = NLOPT_NUM_ALGORITHMS, /* start where NLOPT stops */
  NLOPT_LD_JACOBIAN,

  NLOPT_NUM_ALGOS, /* not an algorithm, just the number of them */
}
]]

-- helper ---------------------------------------------------------------------o

local function dspmat(mat, nam)
  -- duplicate from madl_match.mad ;-(
  if mat ~= nil then
    local fmt = option.numfmt;
    option.numfmt = "% -.16e" ; mat:print(nam) ; option.numfmt = fmt
  end
end

local function eval_fun (env)
  local var = env.__var
  local grdf in var

  var.grdf = false ; var.fun() ; var.grdf = grdf  -- compute function (only)
end

local function eval_jac (env)
  local var = env.__var

  var.funf = true ; var.fun() ; var.funf = nil    -- compute jacobian (only)
end

-- Check/adjust variables to domain -------------------------------------------o

local function check_vars (env)
  local var = env.__var
  local n, x, dx, xslp, xmin, xmax in var
  local nadj = 0

  -- check slope and bounding box
  for i=1,n do
    if dx[i]*xslp[i] < 0 then
      x[i], dx[i], nadj = x[i]+dx[i], 0, nadj+1
    elseif x[i] < xmin[i] then
      x[i], dx[i], nadj = xmin[i], dx[i]+x[i]-xmin[i], nadj+1
    elseif x[i] > xmax[i] then
      x[i], dx[i], nadj = xmax[i], dx[i]+x[i]-xmax[i], nadj+1
    end
  end

  if env.debug >= 1 and nadj > 0 then
    io.write("nlopt: ", nadj, " variables ajusted (bounds or slope).\n")
  end

  return nadj
end

--[[ MAD-X rules: same as forcing xmin/xmax...
  local dv = min(max(1e-12, xstp[i]), (xmin[i] - x[i])*0.5)
  x[i], nadj = xmin[i]+2*dv, nadj+1
  local dv = min(max(1e-12, xstp[i]), (x[i] - xmax[i])*0.5)
  x[i], nadj = xmax[i]-2*dv, nadj+1
--]]

local function adjust_vars (env)
  local var = env.__var
  local n, x, dx, xmin, xmax in var
  local scl = 1

  for i=1,n do
    if dx[i] ~= 0 then
      local s = 1
          if x[i] < xmin[i] then s = 1 + (x[i]-xmin[i])/dx[i]
      elseif x[i] > xmax[i] then s = 1 + (x[i]-xmax[i])/dx[i] end
      if s < scl then scl = s end
    end
  end

      if scl < 0.1 then check_vars(env) -- scale is too small, cut
  elseif scl <  1  then                 -- scale is fine, adjust length
    x:add(dx,x) ; dx:mul(scl,dx) ; x:sub(dx,x)

    if env.debug >= 1 then
      io.write("nlopt: variables step scaled by ", scl, ".\n")
    end
  end
end

-- Stopping criteria ----------------------------------------------------------o

local function check_stop (env)
  local var = env.__var
  local status = var.status

  env.dtime = os.clock()-var.time0 -- update timer (after fun call)

  if env.stop then
    var.status = _C.NLOPT_FORCED_STOP
    if env.debug >= 1 then io.write("nlopt: forced to stop.\n") end

  elseif var.maxcall > 0 and env.ncall >= var.maxcall then
   var.status = _C.NLOPT_MAXEVAL_REACHED

  elseif var.maxtime > 0 and env.dtime >= var.maxtime then
   var.status = _C.NLOPT_MAXTIME_REACHED

  elseif var.ccnt > 0 then
    -- not a feasible point -> continue

  elseif var.fval <= var.fmin then
    var.status = _C.NLOPT_STOPVAL_REACHED

  elseif abs(var.fstp) - var.ftol <= 0 or
         abs(var.fstp) - var.frtol*abs(var.fval) <= 0 then
    var.status = _C.NLOPT_FTOL_REACHED

  elseif var.xtolf and env.ncall > 1 then
    local ax, adx = abs(var.x), abs(var.dx)

    if (adx - var.xtol):max() <= 0 or (adx - var.xrtol*ax):max() <= 0 then
      var.status = _C.NLOPT_XTOL_REACHED

    elseif (adx - eps*ax):max() <= 0 then
      var.status = _C.NLOPT_ROUNDOFF_LIMITED
    end
  end

  return var.status ~= status
end

-- Bisection ------------------------------------------------------------------o

local function bisection (env, bisec)
  local var = env.__var
  local x, dx, fun, fval, grdf, backup in var
  local bak, ret = backup(var)

  var.grdf = false                               -- disable Jacobian
  for i=1,bisec do
    if env.debug >= 1 then printf("nlopt: trying Bisection %d.\n", i) end
    dx:div(2,dx) ; x:add(dx,x) ; var.fval = fval -- for var.fstp
    ret = fun()                                  -- call user command/function
    if ret and var.fval < fval then break end    -- new minimum found
  end
  var.grdf = grdf                                -- restore Jacobian

  if var.fval < fval then                        -- new minimum found
    if env.debug >= 1 then io.write("nlopt: Bisection succeeded.\n") end
    if check_stop(env) then return true end      -- check criteria
    var.funf = true ; fun() ; var.funf = nil     -- compute Jacobian (only)
  elseif var.fval > fval or not ret then
    if env.debug >= 1 then io.write("nlopt: Bisection failed, restoring.\n") end
    backup(bak, var)                             -- restore initial case
  end
end

-- Remove useless (or invalid) constraints and variables ----------------------o

local function reject_cons (env, A, B, ir)
  local i, tol = 1, env.objective.jtol or eps
  local fn = \t,x => if x <= tol^2 then t[#t+1]=i end i=i+1 return t end

  -- compute row norm, collect rows to remove
  A:sumsqr'row' :foldl(fn, ir)

  -- debug info
  if ir[1] and env.debug >= 1 then
    io.write("nlopt: Rejecting constraints (rows) no ")
    for i=1,#ir do io.write(ir[i], " ") end
    io.write("\n")
  end

  -- remove selected rows
  A:remrow(ir) ; B:remrow(ir)

  return #ir
end

local function reject_vars (env, A, rx, rdx, ic)
  local n, xslp, xmin, xmax in env.__var
  local j, k, iic = 1, 0, {}

  for i=1,n do
    -- column already rejected
    if i == ic[j] then j, k = j+1, k+1
    -- check slope and bounding box, collect columns to remove
    else
      local ii = i-k
      local xi = rx[ii]-rdx[ii]
      if rdx[ii]*xslp[i] < 0 then -- or xi < xmin[i] or xi > xmax[i] then
        table.insert(ic,j,i) ; iic[#iic+1], j = ii, j+1
      end
    end
  end

  -- debug info
  if iic[1] and env.debug >= 1 then
    io.write("nlopt: Rejecting variables (cols) no ")
    for i=1,#ic do io.write(ic[i], " ") end
    io.write("\n")
  end

  -- remove selected columns
  A:remcol(iic) ; rx:remrow(iic)

  return #iic
end

-- Levenberg-Marquardt --------------------------------------------------------o

local function ld_lmdif (env)
  local var, objective = env.__var, env.objective
  local n, p, q, x, dx, eval, ejac, lval, ljac, jacf, backup in var
  local jrand, jitr, jtau, bisec in objective

  -- default setup
  jrand = jrand == true and rand or jrand
  jitr, jtau, bisec = jitr or 20, jtau or 1e-3, bisec or 3

  -- check domain (and adjust x to bbox)
  check_vars(env)

  -- compute function (only)
  eval_fun(env)

  -- check stopping criteria
  if check_stop(env) then return true end

  -- LM persistent variables
  local bak, nu, mu = {}, 2

  while true do
    -- compute jacobian
    eval_jac(env)

    -- build Ax=b
    local J, B = matrix(p+q,n), vector(p+q)
        if ljac == nil then ejac:copy(J) ; eval:copy(B)
    elseif ejac == nil then ljac:copy(J) ; lval:copy(B)
    else   ejac:concat(ljac, J) ;  eval:concat(lval, B)
    end
    local A, G, ir = J:tmul(J), J:tmul(B), {}

    -- initialise damping term.
    if mu == nil then mu = jtau*A:max('diag') end

    -- debug info
    if env.debug >= 2 then
      dspmat(J, "J") ; dspmat(B, "B") ;
      dspmat(A, "A") ; dspmat(G, "G") ;
    end

    -- reject constraints with insufficient row norm in Jacobian (jtol)
    reject_cons(env, A, G, ir)

    -- backup current status
    backup(var, bak)

  ::damping_loop::

    local ic, rx, rdx, rk, sv = {}, x:copy()

    -- solve and reduce damped system
    for i=1,jitr do
      -- A = A + mu*I
      local A = A:mapij \x,i,j -> i==j and x+mu or x

      -- one Gauss-Newton step using SVD to find min_x ||b - Ax||
      rdx, rk, sv = A:ssolve(G, objective.rcond)

      -- debug info
      if env.debug >= 1 then
        io.write("nlopt: Gauss-Newton step using SVD, \z
                  rank=", rk, ", rcond=", objective.rcond or 'eps', '\n')
        if env.debug >= 2 then
          dspmat(A, "A") ; dspmat(G, "G") ; dspmat(sv, "JACOBIAN-SV")
        end
      end

      -- reject variables with wrong slope
      if not jacf or reject_vars(env, A, rx, rdx, ic) == 0 then break end
    end

    -- update variables, rejected variables don't move
    rdx:copy(dx):insvec(ic,0) ; x:sub(dx,x)

    -- adjust domain (i.e. scale or cut dx to fit bbox)
    adjust_vars(env)

    -- compute function (only)
    eval_fun(env)

    -- check stopping criteria
    if check_stop(env) then return true end

    -- try bisection if fval increases
    if var.fstp > 0 and bisec >= 1 and bisection(env,bisec) then return true end

    -- check step improvement (update damping term)
    local dF, dL = 0, dx:dot(mu*dx+G)
    if eval then dF = dF + bak.eval:sumsqr() - var.eval:sumsqr() end
    if lval then dF = dF + bak.lval:sumsqr() - var.lval:sumsqr() end
    local rho = dF/dL

    -- debug info
    if env.debug >= 2 then
      printf("mu=% -.6e, rho=% -.6e, dF=% -.6e, dL=% -.6e\n", mu, rho, dF, dL)
    end

    if rho > 0 then   -- decrease damping term, reset nu
      mu, nu = mu*max(1/3, 1-(2*rho-1)^3), 2
    else              -- increase damping term, cancel step, restore backup
      backup(bak, var)
      mu, nu = mu*nu, 2*nu
      goto damping_loop
    end
  end
end

-- Jacobian -------------------------------------------------------------------o

local function ld_jacobian (env)
  local var, objective = env.__var, env.objective
  local n, p, q, x, dx, eval, ejac, lval, ljac, jacf in var
  local jrand, jitr, bisec in objective

  -- default setup
  jrand, jitr, bisec = jrand == true and rand or jrand, jitr or 20, bisec or 3

  -- check domain (and adjust x to bbox)
  check_vars(env)

  -- compute function (only)
  eval_fun(env)

  -- check stopping criteria
  if check_stop(env) then return true end

  while true do
    -- compute jacobian
    eval_jac(env)

    -- build Jx=b
    local J, B, rx = matrix(p+q,n), vector(p+q), x:copy()
        if ljac == nil then ejac:copy(J) ; eval:copy(B)
    elseif ejac == nil then ljac:copy(J) ; lval:copy(B)
    else   ejac:concat(ljac, J) ;  eval:concat(lval, B)
    end

    -- debug info
    if env.debug >= 2 then dspmat(J, "J") ; dspmat(B, "B") end

    local ir, ic, rdx, rk, sv = {}, {}

    -- reject constraints with insufficient row norm in Jacobian (jtol)
    reject_cons(env, J, B, ir)

    -- solve and reduce system
    for i=1,jitr do
      -- one Newton-Raphson step using SVD to find min_x ||b - Jx||
      rdx, rk, sv = J:ssolve(B, objective.rcond)

      -- debug info
      if env.debug >= 1 then
        io.write("nlopt: Newton-Raphson step using SVD, \z
                  rank=", rk, ", rcond=", objective.rcond or 'eps', '\n')
        if env.debug >= 2 then
          dspmat(J, "J") ; dspmat(B, "B") ; dspmat(sv, "JACOBIAN-SV")
        end
      end

      -- reject variables with wrong slope
      if not jacf or reject_vars(env, J, rx, rdx, ic) == 0 then break end
    end

    -- add some randomness to dx
    if jrand then
      rdx:print('rdx')
      rdx:map(\x -> x+(jrand()-jrand())*var.hjac, 'in')
      rdx:print('rdx rand')
    end

    -- update variables, rejected variables don't move
    rdx:copy(dx):insvec(ic,0) ; x:sub(dx,x)

    -- adjust domain (i.e. scale or cut dx to fit bbox)
    adjust_vars(env)

    -- compute function (only)
    eval_fun(env)

    -- check stopping criteria
    if check_stop(env) then return true end

    -- try bisection if fval increases
    if var.fstp > 0 and bisec >= 1 and bisection(env,bisec) then return true end
  end
end

-- LSOPT lib ------------------------------------------------------------------o

local dispatch = {
  [_C.NLOPT_LD_LMDIF   ] = ld_lmdif,
  [_C.NLOPT_LD_JACOBIAN] = ld_jacobian,
}

local function lsoptrun (env)
  local var = env.__var
  local fun = dispatch[var.method.id]

  -- optimizer (protected call)
  return pcall(fun, env)
end

-- end ------------------------------------------------------------------------o
return lsoptrun
