--[=[
 o-----------------------------------------------------------------------------o
 |
 | Least Squares Optimizer module
 |
 | Methodical Accelerator Design - Copyright (c) 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - TODO

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local ffi = require 'ffi'
local _C, vector, matrix in MAD

local abs in math

ffi.cdef [[
enum {
 /* extra MAD algorithms */
  NLOPT_LD_LMDIF = NLOPT_NUM_ALGORITHMS, /* start where NLOPT stops */
  NLOPT_LD_JACOBIAN,

  NLOPT_NUM_ALGOS, /* not an algorithm, just the number of them */
}
]]

-- Levenberg-Marquardt --------------------------------------------------------o

local function ld_lmdif (env)
  local var = env.__var
  print("ld_lmdif")
  for k,v in pairs(var.method) do print(k,v) end
end

-- Jacobian -------------------------------------------------------------------o

local function ld_jacobian (env)
  local var = env.__var
  local bisect in env.objective
  local fmin, maxcall in var
  local n, p, q, x, dx, fun, fgrd, eval, ejac, lval, ljac in var

  local J = matrix(p+q,n)
  local B = vector(p+q)

!  print("\nmaxcall=", maxcall)

  while env.ncall < maxcall do
!    print("ncall=", env.ncall+1)
    local fval = fun()

!    print("fval=", fval)
!    if eval then eval:print("eval") end
!    if lval then lval:print("lval") end

    if var.ccnt == 0 then -- feasible point?
      if fval < fmin then
        var.status = _C.NLOPT_STOPVAL_REACHED
        return true
      end
    end

        if ljac == nil then ejac:copy(J) ; eval:copy(B)
    elseif ejac == nil then ljac:copy(J) ; lval:copy(B)
    else   ejac:concat(ljac, J) ;  eval:concat(lval, B)
    end

    local xx, xs, rnk = J:ssolve(B) -- rcond...
!    print("rnk=", rnk)
    xx:copy(dx) ; x:sub(dx,x)
!    dx:print('dx')
  end

  var.status = _C.NLOPT_MAXEVAL_REACHED
  return true
end

-- LSOPT lib ------------------------------------------------------------------o

local dispatch = {
  [_C.NLOPT_LD_LMDIF   ] = ld_lmdif,
  [_C.NLOPT_LD_JACOBIAN] = ld_jacobian,
}

local function lsoptrun (env)
  local var = env.__var
  local fun = dispatch[var.method.id]

  -- optimize (protected call to C API)
  return pcall(fun, env)
end

-- end ------------------------------------------------------------------------o
return lsoptrun
