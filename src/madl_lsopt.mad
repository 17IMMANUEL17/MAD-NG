--[=[
 o-----------------------------------------------------------------------------o
 |
 | Least Squares Optimizer module
 |
 | Methodical Accelerator Design - Copyright (c) 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - TODO

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local ffi = require 'ffi'
local _C, option, ivector, vector, matrix                        in MAD
local is_callable                                                in MAD.typeid
local assertf, errorf, printf                                    in MAD.utility
local eps, inf                                                   in MAD.constant
local abs, rand                                                  in MAD.gmath

local max in math

-- New algos ------------------------------------------------------------------o

ffi.cdef [[
enum {
 /* extra MAD algorithms */
  NLOPT_LD_LMDIF     = NLOPT_NUM_ALGORITHMS, /* start where NLOPT stops */
  NLOPT_LD_JACOBIAN,

  NLOPT_NUM_ALGOS, /* not an algorithm, just the number of them */
}
]]

-- helper ---------------------------------------------------------------------o

local function dspmat(mat, nam)
  -- duplicate from madl_match.mad ;-(
  if mat ~= nil then
    local fmt = option.numfmt;
    option.numfmt = "% -.16e" ; mat:print(nam) ; option.numfmt = fmt
  end
end

local function eval_fun (env)
  local var = env.__var
  local grdf in var
  var.grdf = false
  local ret = var.fun()   -- compute function (only)
  var.grdf = grdf
  return ret
end

local function eval_jac (env)
  local var = env.__var
  var.funf = true
  local ret = var.fun()   -- compute jacobian (only)
  var.funf = nil
  return ret
end

local function save_adjrej (rej, irc)
  local cur = rej.cur
  rej.n = rej.n+1
  table.clear(cur) ; cur.n = 1
  for _,i in ipairs(irc) do rej[i], cur[i] = (rej[i] or 0)+1, 1 end
end

-- Check/adjust variables to domain -------------------------------------------o

local function adjust_vars (env, av_)
  local var, trc = env.__var, env.info >= 3
  local n, x, dx, xslp, xmin, xmax in var
  local av = av_ or {}

  -- adjust slope and bounding box
  for i=1,n do
    if dx[i]*xslp[i] < 0 then
      x[i], dx[i], av[#av+1] = x[i]+dx[i], 0, i                -- cancel move
      if trc then printf("nlopt: adjusting variable (slope) no %d\n", i) end
    elseif x[i] < xmin[i] then
      x[i], dx[i], av[#av+1] = xmin[i], dx[i]+x[i]-xmin[i], i  -- move to min
      if trc then printf("nlopt: adjusting variable (< min) no %d\n", i) end
    elseif x[i] > xmax[i] then
      x[i], dx[i], av[#av+1] = xmax[i], dx[i]+x[i]-xmax[i], i  -- move to max
      if trc then printf("nlopt: adjusting variable (> max) no %d\n", i) end
    end
  end

  return av
end

local function check_vars (env, av_)
  local var, trc = env.__var, env.info >= 3
  local n, x, dx, xslp, xmin, xmax in var
  local scl = 1

  -- compute scale factor
  for i=1,n do
    if dx[i] ~= 0 and dx[i]*xslp[i] >= 0 then
      local s = 1
          if x[i] < xmin[i] then s = 1 + (x[i]-xmin[i])/dx[i]
      elseif x[i] > xmax[i] then s = 1 + (x[i]-xmax[i])/dx[i] end
      if s < scl then scl = s end
    end
  end

  -- adjust length if scale is within one order of magnitude
  if scl > 0.1 and scl < 1 then
    x:add(dx,x) ; dx:mul(scl,dx) ; x:sub(dx,x)
    if trc then printf("nlopt: variables step dx scaled by % -.6e.\n", scl) end
  end

  return adjust_vars(env, av_) -- final validation
end

-- Remove useless (or invalid) constraints and variables ----------------------o

local function reject_cons (env, A, B, ir_)
  local var, trc = env.__var, env.info >= 3
  local crej, ccur = var.crej, var.crej.cur
  local i, tol2 = 1, (env.objective.jtol or eps)^2
  local fn = \t,x => if x <= tol2 then t[#t+1]=i end i=i+1 return t end
  local ir = ir_ or {}

  -- compute row norm, collect rows to remove
  A:sumsqr'row' :foldl(fn, ir)

  if ir[1] then
    -- keep at least first row...
    if #ir == A.nrow then table.remove(ir,1) end

    -- remove selected rows
    A:remrow(ir) ; B:remrow(ir)

    -- info
    if trc then
      io.write("nlopt: rejecting constraints (jac) no ")
      for i=1,#ir do io.write(ir[i], " ") end
      io.write("\n")
    end
  end

  return ir
end

local function reject_vars (env, A, rx, rdx, ic_)
  if var.jacstra == 0 or A.ncol <= A.nrow then return {} end

  local var, trc = env.__var, env.info >= 3
  local n, xslp, xmin, xmax, jacstra in var
  local xrej, xcur = var.xrej, var.xrej.cur
  local iic, ic, mc = {}, ic_ or {}, A.ncol-A.nrow

  -- reject by slope                                               -- jstra >= 1
  local j, k = 1, 0
  for i=1,n do
    if i == ic[j] then j, k = j+1, k+1 ; goto continue end -- already rejected

    local ii = i-k
    local xi = rx[ii]-rdx[ii]
    if #iic >= mc then                    -- too many variables removed
      if trc then printf("nlopt: limit of %d variables rejected\n", #ic) end
      if jacstra >= 3 then var.jacstra = 0 end                     -- jstra >= 3
      break
    elseif rdx[ii]*xslp[i] < 0 then       -- bad slope
      table.insert(ic,j,i) ; iic[#iic+1], j = ii, j+1
      if trc then printf("nlopt: rejecting variable (slope) no %d\n", i) end
    end
    ::continue::
  end

  -- reject by bounding box                                        -- jstra >= 2
  if jacstra >= 2 then
    local j, k = 1, 0
    for i=1,n do
      if i == ic[j] then j, k = j+1, k+1 ; goto continue end -- already rejected

      local ii = i-k
      local xi = rx[ii]-rdx[ii]
      if #iic >= mc then                    -- too many variables removed
        if trc then printf("nlopt: limit of %d variables rejected\n", #ic) end
        if jacstra >= 3 then var.jacstra = 0 end                   -- jstra >= 3
        break
      elseif xi < xmin[i] then              -- outside bounding box
        table.insert(ic,j,i) ; iic[#iic+1], j = ii, j+1
        if trc then printf("nlopt: rejecting variable (< min) no %d\n", i) end
      elseif xi > xmax[i] then              -- outside bounding box
        table.insert(ic,j,i) ; iic[#iic+1], j = ii, j+1
        if trc then printf("nlopt: rejecting variable (> max) no %d\n", i) end
      end
      ::continue::
    end
  end

  if iic[1] then
    -- keep at least one variable
    if #iic == A.ncol then table.remove(iic,1) end

    -- remove selected columns
    A:remcol(iic) ; rx:remvec(iic)
  end

  return iic
end

-- Bisection ------------------------------------------------------------------o

local function bisection (env, bisec)
  local var, trc = env.__var, env.info >= 2
  local x, dx, fval, bak, backup in var
  local nbi, ret = 0

  backup(var, bak)

  for i=1,bisec do
    if trc then printf("nlopt: trying Bisection %d.\n", i) end
    dx:div(2,dx) ; x:add(dx,x) ; var.fval = fval        -- for proper var.fstp
    ret = eval_fun(env)                                 -- call user cmd/fun
    if ret and var.fval < fval then                     -- better minimum found
      nbi, fval = i, var.fval ; backup(var, bak)        -- update backup
    elseif nbi > 0 then break end                       -- getting worst, stop
  end

  backup(bak, var)                                    -- restore best/init case

  if nbi > 0 then                                     -- new minimum found
    if trc then printf("nlopt: Bisection succeeded [%d].\n", nbi) end
    if var.chkstp(env) then return true end           -- check criteria
  elseif var.fval > fval or not ret then
    if trc then io.write("nlopt: Bisection failed.\n") end
  end

  return nbi
end

-- Levenberg-Marquardt --------------------------------------------------------o

local function ld_lmdif (env)
  local var, objective = env.__var, env.objective
  local x, dx, fgrd, c, cjac, jacf, xadj, xrej, crej, jacstra, backup in var
  local jitr, jtau, bisec in objective

  -- default setup
  jitr, jtau, bisec = jitr or 10, jtau or 1e-3, bisec or 0

  -- adjust domain (i.e. adjust x to fit bbox if any)
  save_adjrej(xadj, adjust_vars(env))

  -- compute function (only)
  eval_fun(env)

  -- check stopping criteria
  if var.chkstp(env) then return true end

  -- persistent variables
  local bak, nu, mu = {}, 2

  while true do
    -- compute jacobian
    eval_jac(env)

    if cjac:is_const() then -- Jacobian is full of zeros
      var.status = _C.NLOPT_ROUNDOFF_LIMITED ; return
    end

    -- build Jx=B
    local J, B = cjac:copy(), c:copy()

    -- reject constraints with insufficient row norm in Jacobian (jtol)
    save_adjrej(crej, reject_cons(env, J, B))

    -- build Ax=G
    local A, G = J:tmul(J), J:tmul(B)

    -- debug info
    if env.debug >= 2 then dspmat(A, "A") ; dspmat(G, "G") ; end

    -- initialise damping term
    if mu == nil then mu = jtau*A:max('diag') end

    -- backup current status
    backup(var, bak)

  ::damping_loop::
    if nu > 2 and env.info >= 2 then
      printf("nlopt: LMD rolling back, trying with mu=% -.5e\n", mu)
    end

    -- solve and reduce damped system
    local itr, ic, rx, rdx, rk, sv = 1, {}, x:copy()
    while itr <= jitr do
      -- A = A + mu*I
      local A = A:mapij \x,i,j -> i==j and x+mu or x

      -- one Gauss-Newton step using SVD to find min_x ||G - Ax||
      rdx, rk, sv = A:ssolve(G, objective.rcond)

      -- debug info
      if env.info >= 3 then
        printf("nlopt: Gauss-Newton step using SVD, \z
               rank=%d, rcond=%-.6e, scond=%-.6e\n",
               rk, objective.rcond or 'eps', sv[1]/(sv[rk] or 0))
      end
      if env.debug >= 2 then dspmat(sv, "LMDIF-SV") end

      -- reject variables with wrong slope (see also jstra)
      if #reject_vars(env, A, rx, rdx, ic) == 0 then break end
      itr = itr + 1
    end

    -- change strategy if max jitr reached (madx-like)
    if itr > jitr and jacstra == 3 then var.jacstra = 0 end

    -- update variables, rejected variables don't move
    rdx:copy(dx):insvec(ic,0) ; x:sub(dx,x) ; save_adjrej(xrej, ic)

    -- check domain (and adjust if needed)
    save_adjrej(xadj, check_vars(env))

    -- compute function (only)
    eval_fun(env)

    -- check stopping criteria
    if var.chkstp(env) then return true end

    -- try bisection if fval increases
    local nbi = 0
    if var.fstp > 0 and bisec >= 1 then
      nbi = bisection(env, bisec)
      if nbi == true then return true end
    end

    -- check LM-step quality (vs linear model)
    local dF, dL = bak.c:sumsqr()-var.c:sumsqr(), dx:dot(mu*dx+G)
    local rho = dF/dL

    -- debug info
    if env.debug >= 2 then
      printf("LMDIF: mu=% -.5e, nu=%d, rho=% -.5e, dF=% -.5e, dL=% -.5e\n",
              mu, nu, rho, dF, dL)
    end

    if dL > 0 and dF > 0 then -- decrease damping term, reset nu (LM step)
      mu, nu = mu*max(1/3, 1-(2*rho-1)^3), 2
    elseif nbi > 0 then       -- decrease damping term, reset nu (Bisec step)
      mu, nu = mu/(nbi+1), 2
    else                      -- increase damping term, cancel step
      backup(bak, var)
      mu, nu = mu*nu, 2*nu
      goto damping_loop
    end
  end
end

-- Jacobian -------------------------------------------------------------------o

local function ld_jacobian (env)
  local var, objective = env.__var, env.objective
  local x, dx, fgrd, c, cjac, jacf, xadj, xrej, crej in var
  local jitr, bisec in objective

  -- default setup
  jitr, bisec = jitr or 10, bisec or 3

  -- adjust domain (i.e. adjust x to fit bbox if any)
  save_adjrej(xadj, adjust_vars(env))

  -- compute function (only)
  eval_fun(env)

  -- check stopping criteria
  if var.chkstp(env) then return true end

  while true do
    -- compute jacobian
    eval_jac(env)

    if cjac:is_const() then -- Jacobian is full of zeros
      var.status = _C.NLOPT_ROUNDOFF_LIMITED ; return
    end

    -- build Jx=B
    local J, B = cjac:copy(), c:copy()

    -- reject constraints with insufficient row norm in Jacobian (jtol)
    save_adjrej(crej, reject_cons(env, J, B))

    -- solve and reduce system
    local itr, ic, rx, rdx, rk, sv = 1, {}, x:copy()
    while itr <= jitr do
      -- one Newton-Raphson step using SVD to find min_x ||B - Jx||
      rdx, rk, sv = J:ssolve(B, objective.rcond)

      -- debug info
      if env.info >= 3 then
        printf("nlopt: Newton-Raphson step using SVD, \z
               rank=%d, rcond=%-.6e, scond=%-.6e\n",
               rk, objective.rcond or 'eps', sv[1]/(sv[rk] or 0))
      end
      if env.debug >= 2 then dspmat(sv, "JACOBIAN-SV") end

      -- reject variables with wrong slope (and bbox, see also jstra)
      if #reject_vars(env, J, rx, rdx, ic) == 0 then break end
      itr = itr + 1
    end

    -- change strategy if jitr reached (madx-like)
    if itr > jitr and jacstra == 3 then var.jacstra = 0 end

    -- update variables, rejected variables don't move
    rdx:copy(dx):insvec(ic,0) ; x:sub(dx,x) ; save_adjrej(xrej, ic)

    -- check domain (and adjust if needed)
    save_adjrej(xadj, check_vars(env))

    -- compute function (only)
    eval_fun(env)

    -- check stopping criteria
    if var.chkstp(env) then return true end

    -- try bisection if fval increases
    if var.fstp > 0 and bisec >= 1 then
      if bisection(env, bisec) == true then return true end
    end
  end
end

--    -- add some randomness to dx
--    jrand = jrand == true and rand or jrand
--    if jrand then
--      rdx:print('rdx')
--      rdx:map(\dx -> 0.5*(1+jrand())*dx, 'in')
--      rdx:print('rdx rand')
--    end

-- LSOPT lib ------------------------------------------------------------------o

local dispatch = {
  [_C.NLOPT_LD_LMDIF   ] = ld_lmdif,
  [_C.NLOPT_LD_JACOBIAN] = ld_jacobian,
}

local function lsoptrun (env)
  return dispatch[env.__var.method.id](env)
end

--  local var = env.__var
--  local fun = dispatch[var.method.id]()
--
--  -- optimizer (protected call)
--  return pcall(fun, env)

-- end ------------------------------------------------------------------------o
return lsoptrun
