--[=[
 o-----------------------------------------------------------------------------o
 |
 | Generalised Truncated Power Series module
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provides full set of functions and operations on real and complex TPSA.
  - Support monomials with knobs and inhomogeneous orders.

 o-----------------------------------------------------------------------------o
]=]

local MR, MC = {}, {}

-- locals ---------------------------------------------------------------------o

local ffi = require 'ffi'
local istype   in ffi
local min, max in math

local _C, tostring, complex in MAD

-- To review
local monomial                                                   in MAD
local is_nil, is_number, is_string, is_complex, is_table,
      is_iterable, is_mappable                                   in MAD.typeid

-- tmp for returned values
local  res = ffi.new 'double [1]'
local cres = ffi.new 'complex[1]'

-- constants
local dbl_sz = ffi.sizeof 'double'
local cpx_sz = ffi.sizeof 'complex'

-- types ----------------------------------------------------------------------o

ffi.cdef [[
typedef unsigned int bit_t; // mad_bit.h

struct desc { // warning: must be kept identical to C definition
  const int   id;         // index in list of registered descriptors
  const int   nmv, nv;    // number of mvars, number of all vars
  const ord_t mo, ko,     // maximum order for mvars and knobs (mo=max(mvar_ords[]))
              trunc;      // truncation order for operations; always <= mo
  const ord_t
       *const mvar_ords,  // mvars orders[nmv] (for each TPSA in map)
       *const  var_ords;  //  vars orders[nv ] (max order for each monomial variable)
};            // end of compatibility with Lua FFI (rest is not visible)

struct tpsa { // warning: must be kept identical to C definition
  const desc_t *const d;  // ptr to descriptor
  const ord_t lo, hi, mo; // lowest/highest used ord, trunc ord
  const bit_t nz;         // non-zero homogeneous polynomials
  const num_t coef[?];
};

struct ctpsa { // warning: must be kept identical to C definition
  const desc_t *const d;  // ptr to descriptor
  const ord_t lo, hi, mo; // lowest/highest used ord, trunc ord
  const bit_t nz;         // non-zero homogeneous polynomials
  const cnum_t coef[?];
};

struct tpsa_ccast { // warning: must be kept identical to C definition
  const desc_t *d;
  ord_t lo, hi, mo;
  bit_t nz;
  num_t coef[?];
};
]]

local  desc_ctor = ffi.typeof 'struct  desc '
local  tpsa_ctor = ffi.typeof 'struct  tpsa '
local  tpsa_cref = ffi.typeof 'struct  tpsa&'
local ctpsa_ctor = ffi.typeof 'struct ctpsa '
local ctpsa_cref = ffi.typeof 'struct ctpsa&'
local  tpsa_ccst = ffi.typeof 'struct  tpsa_ccast&'

local   int_arr  = ffi.typeof 'int [?]'
local  tpsa_arr  = ffi.typeof 'struct  tpsa* [?]'
local ctpsa_arr  = ffi.typeof 'struct ctpsa* [?]'

local is_desc  = \x -> istype( desc_ctor, x)
local is_tpsa  = \x -> istype( tpsa_ctor, x)
local is_ctpsa = \x -> istype(ctpsa_ctor, x)
local isa_tpsa = \x -> is_tpsa(x) or is_ctpsa(x)

local desc_curr = nil -- current descriptor (last used)

-- descriptors ----------------------------------------------------------------o

--[=[
  nv: number of map variables (when mo is a value)
  mo: map variables orders (array or value)
  vo: variables orders (array) with vo[i] <= mo[i]
  ko: max 'knobs' cross-orders (max order of cross terms)

  ex0:    desc(nil)                           : 6 mvars of order 2.
  ex1.0:  desc(3)         -> mo=3             : 6 mvars of order 3.
  ex2.0:  desc(4,3)       -> nv=4,mo=3        : 4 mvars of order 3.
  ex3.0:  desc{3,3}       -> mo={3,3}         : 2 mvars of order 3.
  ex1.1:  desc{mo=3}      -> mo=3             : 6 mvars of order 3.
  ex2.1:  desc{nv=4,mo=3} -> nv=4,mo=3        : 4 mvars of order 3.
  ex3.1:  desc{mo={3,3}}  -> mo={3,3}         : 2 mvars of order 3.
  ex4.1:  desc{mo={3,3}, vo={2,2,1,1}, ko=1}  : 2 mvars of order 3,
          each mvars contains 4 vars (2 mvars + 2 knobs) of orders 2,2,1,1,
                            knobs x-order is limited to 1 (no cross-terms).
--]=]

local function desc (nv_, mo_)
  if is_nil(mo_) then
    mo_, nv_ = nv_ -- right shift
  end

  local ism = is_mappable(mo_)
  local nv = ism and mo_.nv or nv_ or 6
  local mo = ism and mo_.mo or mo_ or 2
  local vo = ism and mo_.vo or nil
  local ko = ism and mo_.ko or nil

  if is_number(nv) and is_number(mo) then      -- ex 0, 1.0, 2.0, 1.1, 2.1
    return _C.mad_desc_newn(nv, mo)
  end

  if is_iterable(mo) and is_nil(vo) then       -- ex 3.0, 3.1
    local m = mono(mo)
    return _C.mad_desc_newm(m.n, m.data)
  end

  if is_iterable(mo) and is_iterable(vo) then  -- ex 4.1
    local m, v = mono(mo), mono(vo)
    return _C.mad_desc_newm(m.n, m.data, v.n, v.m, ko)
  end

  error("invalid combination of arguments (gtpsa descriptor)")
end

-- allocators -----------------------------------------------------------------o

local function tpsa_alloc (d, mo)
  assert(is_desc(d), "invalid argument #1 (GTPSA descriptor expected)")
  local len, tpsa = _C.mad_desc_tpsa_len(d, mo), nil
  if len < _C.mad_alloc_threshold then
    tpsa = tpsa_ctor(len, d, mo, 0, mo) -- VLA
  else
    assert(len <= 2^30, "tpsa is too large")
    local siz = ffi.sizeof(tpsa_ctor, len)
    local ptr = assert(_C.mad_calloc(1,siz), "out of memory")
    tpsa = ffi.gc(ffi.cast(tpsa_cref, ptr), _C.mad_free)
    local t = ffi.cast(tpsa_ccst, tpsa)
    t.d, t.lo, t.mo = d, mo, mo -- see tpsa_newd() in mad_tpsa.c
  end
  desc_curr = d
  return tpsa
end

local function ctpsa_alloc (d, mo)
  assert(is_desc(d), "invalid argument #1 (GTPSA descriptor expected)")
  local len, ctpsa = _C.mad_desc_tpsa_len(d, mo), nil
  if len < (_C.mad_alloc_threshold/2) then
    ctpsa = ctpsa_ctor(len, d, mo, 0, mo)
  else
    assert(len <= 2^29, "ctpsa is too large")
    local siz = ffi.sizeof(ctpsa_ctor, len)
    local ptr = assert(_C.mad_calloc(1,siz), "out of memory")
    ctpsa = ffi.gc(ffi.cast(ctpsa_cref, ptr), _C.mad_free)
    local t = ffi.cast(tpsa_ccst, tpsa)
    t.d, t.lo, t.mo = d, mo, mo
  end
  desc_curr = d
  return ctpsa
end

-- ctors ----------------------------------------------------------------------o

-- tpsa()        -> last d
-- tpsa(t)       -> t.mo
-- tpsa(d)       -> d.mo
-- tpsa(t|d, mo) -> mo

local function tpsa (td, mo_)
  if is_number(td) and is_nil(mo_) then
    mo_, td = td -- right shift
  end
  if is_nil(td) then
    td      = desc_curr or desc(mo_)
    mo_     = mo_ or td.mo       -- mo = d.mo
  elseif is_desc(td) then
    mo_     = mo_ or td.mo       -- mo = d.mo
  elseif isa_tpsa(td) then
    mo_, td = mo_ or td.mo, td.d -- mo = t.mo
  else
    error("invalid argument #1 (GTPSA or descriptor expected)")
  end
  assert(is_number(mo_), "invalid argument #2 (number expected)")
  return tpsa_alloc(td, max(0, min(mo_, td.mo)))
end

local function ctpsa (td, mo_)
  if is_number(td) and is_nil(mo_) then
    mo_, td = td -- right shift
  end
  if is_nil(td) then
    td      = desc_curr or desc(mo_)
    mo_     = mo_ or td.mo       -- mo = d.mo
  elseif is_desc(td) then
    mo_     = mo_ or td.mo       -- mo = d.mo
  elseif isa_tpsa(td) then
    mo_, td = mo_ or td.mo, td.d -- mo = t.mo
  else
    error("invalid argument #1 (GTPSA or descriptor expected)")
  end
  assert(is_number(mo_), "invalid argument #2 (number expected)")
  return ctpsa_alloc(td, max(0, min(mo_, td.mo)))
end

-- checkers -------------------------------------------------------------------o

local function chksiz (r, x, y) -- add, sub, mul
  assert( is_nil(r) or (r.mo >= x.mo and r.d == x.d and
         (is_nil(y) or  r.mo >= y.mo and r.d == y.d)),
         "incompatible GTPSA order or descriptor")
  return r
end

-- same, copy -----------------------------------------------------------------o

function MR.__same (x, y_, e_)
  if is_nil(e_) and is_complex(y_) then -- shift right
    e_, y_ = y_
  end
  assert(is_nil(y_) or isa_tpsa(y_), "invalid argument #2 (GTPSA expected)")
  local mo = max(x.mo, y_ and y_.mo)
  return is_complex(e_) and ctpsa(x, mo) or tpsa(x, mo)
end

function MC.__same (x, y_)
  assert(is_nil(y_) or isa_tpsa(y_), "invalid argument #2 (GTPSA expected)")
  local mo = max(x.mo, y_ and y_.mo)
  return ctpsa(x, mo)
end

function MR.__copy (x, y_)
  if is_nil(y_) then
    x, y_ = tpsa_alloc(x.d, x.mo), x
    _C.mad_tpsa_copy(y_, x)
  else
    assert(is_tpsa(y_), "invalid argument #2 (tpsa expected)")
    if x ~= y_ then _C.mad_tpsa_copy(y_, chksiz(x,y_)) end
  end
  return x
end

function MC.__copy (x, y_)
  if is_nil(y_) then
    x, y_ = ctpsa_alloc(x.d, x.mo), x
    _C.mad_ctpsa_copy(y_, x)
  elseif is_tpsa(y_) then
    x, y_ = chksiz(x,y_) and ctpsa_alloc(x.d, x.mo), x
    _C.mad_ctpsa_complex(y_, nil, x)
  else
    assert(is_ctpsa(y_), "invalid argument #2 (ctpsa expected)")
    if x ~= y_ then _C.mad_ctpsa_copy(y_, chksiz(x,y_)) end
  end
  return x
end

-- conversion -----------------------------------------------------------------o

function MR.complex (_, re_, im_, r) -- require a (c)tpsa to be called
  local re, im = re_ or im_, im_ or re_
  assert(is_tpsa(re) and is_tpsa(im), "invalid argument #2 or #3 (tpsa expected)")
  r = chksiz(r,y) or ctpsa(re, max(re.mo, im.mo))
  _C.mad_ctpsa_complex(re_, im_, r)
  return r
end

function MR.scalar (x, e_)
 e_ = e_ or 0
 assert(is_number(e_), "invalid argument #2 (number expected)")
  _C.mad_tpsa_scalar(x, e_)
  return x
end

function MC.scalar (x, e_)
 e_ = e_ or 0i
 assert(is_complex(e_), "invalid argument #2 (complex expected)")
 _C.mad_ctpsa_scalar_r(x, e_.re, e_.im)
 return x
end

MR.clear = \x => _C.mad_tpsa_clear (x) return x end
MC.clear = \x => _C.mad_ctpsa_clear(x) return x end

-- operators ------------------------------------------------------------------o

-- unm

function MR.__unm (x, _, r) -- note: _ is dummy arg, see Lua specs.
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_scl(x, -1, r)
  return r
end

function MC.__unm (x, _, r) -- note: _ is dummy arg, see Lua specs.
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_scl_r(x, -1, 0, r)
  return r
end

-- equ

local function tpsa_eqn (x, y, tol)
  return x.hi == 0 and abs(x.coef[0]-y) <= tol
end

local function tpsa_eqc (x, y, tol)
  return x.hi == 0 and abs(          y.im) <= tol
                   and abs(x.coef[0]-y.re) <= tol
end

local function ctpsa_eqn (x, y, tol)
  return x.hi == 0 and abs(x.coef[0].im  ) <= tol
                   and abs(x.coef[0].re-y) <= tol
end

local function ctpsa_eqc (x, y, tol)
  return x.hi == 0 and abs(x.coef[0].re-y.re) <= tol
                   and abs(x.coef[0].im-y.im) <= tol
end

function MR.__req_cpx (y, x, tol_)               -- cpx == tpsa
  tol_ = tol_ or 0
  assert(is_number(tol_), "invalid argument #3 (number expected)")
  return tpsa_eqc(y, x, tol_)
end

function MR.__eq (x, y, tol_)
  tol_ = tol_ or 0
  assert(is_number(tol_), "invalid argument #3 (number expected)")
  if is_nil(y) then
    return false
  elseif is_number(x) then                       -- num == tpsa
    return tpsa_eqn(y, x, tol_)
  elseif is_number(y) then                       -- tpsa == num
    return tpsa_eqn(x, y, tol_)
  elseif is_complex(y) then                      -- tpsa == cpx
    return tpsa_eqc(x, y, tol_)
  elseif is_ctpsa(y) then                        -- tpsa == ctpsa
    assert(x.d == y.d, "incompatible GTPSA descriptor")
    return _C.mad_ctpsa_equt(y, x, tol_)
  elseif is_tpsa(y) and is_tpsa(x) then          -- tpsa == tpsa
    assert(x.d == y.d, "incompatible GTPSA descriptor")
    return _C.mad_tpsa_equ(x, y, tol_)
  elseif has_method(y, '__req_tpsa') then        -- tpsa + ?
    return y:__req_tpsa(x, r)
  end
  error("invalid arguments (unsupported GTPSA operation '==')")
end

function MC.__req_cpx (y, x, tol_)               -- cpx == tpsa
  tol_ = tol_ or 0
  assert(is_number(tol_), "invalid argument #3 (number expected)")
  return ctpsa_eqc(y, x, tol_)
end

function MC.__eq (x, y, tol_)
  tol_ = tol_ or 0
  assert(is_number(tol_), "invalid argument #3 (number expected)")
  if is_nil(y) then
    return false
  elseif is_number(x) then                       -- num == ctpsa
    return ctpsa_eqn(y, x, tol_)
  elseif is_number(y) then                       -- ctpsa == num
    return ctpsa_eqn(x, y, tol_)
  elseif is_complex(y) then                      -- ctpsa == cpx
    return ctpsa_eqc(x, y, tol_)
  elseif is_tpsa(y) then                         -- ctpsa == tpsa
    assert(x.d == y.d, "incompatible GTPSA descriptor")
    return _C.mad_ctpsa_equt(x, y, tol_)
  elseif is_ctpsa(y) and is_ctpsa(x) then        -- ctpsa == ctpsa
    assert(x.d == y.d, "incompatible GTPSA descriptor")
    return _C.mad_ctpsa_equ(x, y, tol_)
  elseif has_method(y, '__req_ctpsa') then       -- ctpsa + ?
    return y:__req_ctpsa(x, r)
  end
  error("invalid arguments (unsupported GTPSA operation '==')")
end

-- add (see also kadd)

function MR.__radd_cpx (y, x, r)                 -- cpx + tpsa
  if y.hi == 0 then return x + y.coef[0] end     -- promote to num
  r = chksiz(r,y) or ctpsa_alloc(y.d, y.mo)      -- promote to ctpsa
  _C.mad_ctpsa_complex(y, nil, r)
  _C.mad_ctpsa_set0_r(r, 1, 0, x.re, x.im) return r
end

function MR.__add (x, y, r)
  if is_number(x) then                           -- num + tpsa
    if y.hi == 0 then return x + y.coef[0] end   -- promote to num
    r = chksiz(r,y) or tpsa_alloc(y.d, y.mo)
    _C.mad_tpsa_copy(y, r)
    _C.mad_tpsa_set0(r, 1, x) return r
  elseif is_number(y) then                       -- tpsa + num
    if x.hi == 0 then return x.coef[0] + y end   -- promote to num
    r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
    _C.mad_tpsa_copy(x, r)
    _C.mad_tpsa_set0(r, 1, y) return r
  elseif is_complex(y) then                      -- tpsa + cpx
    if x.hi == 0 then return x.coef[0] + y end   -- promote to num
    r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)    -- promote to ctpsa
    _C.mad_ctpsa_complex(x, nil, r)
    _C.mad_ctpsa_set0_r(r, 1, 0, y.re, y.im) return r
  elseif is_ctpsa(y) then                        -- tpsa + ctpsa
    if x.hi == 0 and y.hi == 0 then return x.coef[0] + y.coef[0] end
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_tadd(x, y, r) return r
  elseif is_tpsa(y) and is_tpsa(x) then          -- tpsa + tpsa
    if x.hi == 0 and y.hi == 0 then return x.coef[0] + y.coef[0] end
    r = chksiz(r,x,y) or tpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_tpsa_add(x, y, r) return r
  elseif has_method(y, '__radd_tpsa') then       -- tpsa + ?
    return y:__radd_tpsa(x, r)
  end
  error("invalid arguments (unsupported GTPSA operation '+')")
end

function MC.__radd_cpx (y, x, r)                 -- cpx + ctpsa
  if y.hi == 0 then return x + y.coef[0] end     -- promote to cpx
  r = chksiz(r,y) or ctpsa_alloc(y.d, y.mo)
  _C.mad_ctpsa_copy(y, r)
  _C.mad_ctpsa_set0_r(r, 1, 0, x.re, x.im) return r
end

function MC.__add (x, y, r)
  if is_number(x) then                           -- num + ctpsa
    if y.hi == 0 then return x + y.coef[0] end   -- promote to cpx
    r = chksiz(r,y) or ctpsa_alloc(y.d, y.mo)
    _C.mad_ctpsa_copy(y, r)
    _C.mad_ctpsa_set0_r(r, 1, 0, x, 0) return r
  elseif is_number(y) then                       -- ctpsa + num
    if x.hi == 0 then return x.coef[0] + y end   -- promote to cpx
    r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
    _C.mad_ctpsa_copy(x, r)
    _C.mad_ctpsa_set0_r(r, 1, 0, y, 0) return r
  elseif is_complex(y) then                      -- ctpsa + cpx
    if x.hi == 0 then return x.coef[0] + y end   -- promote to cpx
    r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
    _C.mad_ctpsa_copy(x, r)
    _C.mad_ctpsa_set0_r(r, 1, 0, y.re, y.im) return r
  elseif is_tpsa(y) then                         -- ctpsa + tpsa
    if x.hi == 0 and y.hi == 0 then return x.coef[0] + y.coef[0] end
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_addt(x, y, r) return r
  elseif is_ctpsa(y) and is_ctpsa(x) then        -- ctpsa + ctpsa
    if x.hi == 0 and y.hi == 0 then return x.coef[0] + y.coef[0] end
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_add(x, y, r) return r
  elseif has_method(y, '__radd_ctpsa') then      -- ctpsa + ?
    return y:__radd_ctpsa(x, r)
  end
  error("invalid arguments (unsupported GTPSA operation '+')")
end

-- sub (see also kadd)

function MR.__rsub_cpx (y, x, r)                 -- cpx - tpsa
  if y.hi == 0 then return x - y.coef[0] end     -- promote to num
  r = chksiz(r,y) or ctpsa_alloc(y.d, y.mo)      -- promote to ctpsa
  _C.mad_ctpsa_complex(y, nil, r)
  _C.mad_ctpsa_set0_r(r, 1, 0, x.re, x.im) return r
end

function MR.__sub (x, y, r)
  if is_number(x) then                           -- num - tpsa
    if y.hi == 0 then return x - y.coef[0] end   -- promote to num
    r = chksiz(r,y) or tpsa_alloc(y.d, y.mo)
    _C.mad_tpsa_scl(y, -1, r)
    _C.mad_tpsa_set0(r, 1, x) return r
  elseif is_number(y) then                       -- tpsa - num
    if x.hi == 0 then return x.coef[0] - y end   -- promote to num
    r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
    _C.mad_tpsa_copy(x, r)
    _C.mad_tpsa_set0(r, 1, -y) return r
  elseif is_complex(y) then                      -- tpsa - cpx
    if x.hi == 0 then return x.coef[0] - y end   -- promote to num
    r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)    -- promote to ctpsa
    _C.mad_ctpsa_copy(x, r)
    _C.mad_ctpsa_set0_r(r, 1, 0, -y.re, -y.im) return r
  elseif is_ctpsa(y) then                        -- tpsa - ctpsa
    if x.hi == 0 and y.hi == 0 then return x.coef[0] - y.coef[0] end
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_tsub(x, y, r) return r
  elseif is_tpsa(y) and is_tpsa(x) then          -- tpsa - tpsa
    if x.hi == 0 and y.hi == 0 then return x.coef[0] - y.coef[0] end
    r = chksiz(r,x,y) or tpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_tpsa_sub(x, y, r) return r
  elseif has_method(y, '__rsub_tpsa') then       -- tpsa - ?
    return y:__rsub_tpsa(x, r)
  end
  error("invalid arguments (unsupported GTPSA operation '-')")
end

function MC.__rsub_cpx (y, x, r)                 -- cpx - ctpsa
  if y.hi == 0 then return x - y.coef[0] end     -- promote to cpx
  r = chksiz(r,y) or ctpsa_alloc(y.d, y.mo)
  _C.mad_ctpsa_copy(y, r)
  _C.mad_ctpsa_set0_r(r, 1, 0, x.re, x.im) return r
end

function MC.__sub (x, y, r)
  if is_number(x) then                           -- num - ctpsa
    if y.hi == 0 then return x - y.coef[0] end   -- promote to cpx
    r = chksiz(r,y) or ctpsa_alloc(y.d, y.mo)
    _C.mad_ctpsa_scl(y, -1, r)
    _C.mad_ctpsa_set0_r(r, 1, 0, x, 0) return r
  elseif is_number(y) then                       -- ctpsa - num
    if x.hi == 0 then return x.coef[0] - y end   -- promote to cpx
    r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
    _C.mad_ctpsa_copy(x, r)
    _C.mad_ctpsa_set0_r(r, 1, 0, -y, 0) return r
  elseif is_complex(y) then                      -- ctpsa - cpx
    if x.hi == 0 then return x.coef[0] - y end   -- promote to cpx
    r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
    _C.mad_ctpsa_copy(x, r)
    _C.mad_ctpsa_set0_r(r, 1, 0, -y.re, -y.im) return r
  elseif is_tpsa(y) then                         -- ctpsa - tpsa
    if x.hi == 0 and y.hi == 0 then return x.coef[0] - y.coef[0] end
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_subt(x, y, r) return r
  elseif is_ctpsa(y) and is_ctpsa(x) then        -- ctpsa - ctpsa
    if x.hi == 0 and y.hi == 0 then return x.coef[0] - y.coef[0] end
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_sub(x, y, r) return r
  elseif has_method(y, '__rsub_ctpsa') then      -- ctpsa - ?
    return y:__rsub_ctpsa(x, r)
  end
  error("invalid arguments (unsupported GTPSA operation '-')")
end

-- mul

function MR.__rmul_cpx (y, x, r)                 -- cpx * tpsa
  if y.hi == 0 then return x * y.coef[0] end     -- promote to num
  r = chksiz(r,y) or ctpsa_alloc(y.d, y.mo)      -- promote to ctpsa
  _C.mad_ctpsa_complex(y, nil, r)
  _C.mad_ctpsa_scl_r(r, x.re, x.im, r) return r
end

function MR.__mul (x, y, r)
  if is_number(x) then                           -- num * tpsa
    if y.hi == 0 then return x * y.coef[0] end   -- promote to num
    r = chksiz(r,y) or tpsa_alloc(y.d, y.mo)
    _C.mad_tpsa_scl(y, x, r) return r
  elseif is_number(y) then                       -- tpsa * num
    if x.hi == 0 then return x.coef[0] * y end   -- promote to num
    r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
    _C.mad_tpsa_scl(x, y, r) return r
  elseif is_complex(y) then                      -- tpsa * cpx
    if x.hi == 0 then return x.coef[0] * y end   -- promote to num
    r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)    -- promote to ctpsa
    _C.mad_ctpsa_complex(x, nil, r)
    _C.mad_ctpsa_scl_r(r, y.re, y.im, r) return r
  elseif is_ctpsa(y) then                        -- tpsa * ctpsa
    if x.hi == 0 and y.hi == 0 then return x.coef[0] * y.coef[0] end
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_tmul(x, y, r) return r
  elseif is_tpsa(y) and is_tpsa(x) then          -- tpsa * tpsa
    if x.hi == 0 and y.hi == 0 then return x.coef[0] * y.coef[0] end
    r = chksiz(r,x,y) or tpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_tpsa_mul(x, y, r) return r
  elseif has_method(y, '__rmul_tpsa') then       -- tpsa * ?
    return y:__rmul_tpsa(x, r)
  end
  error("invalid arguments (unsupported GTPSA operation '*')")
end

function MC.__rmul_cpx (y, x, r)                 -- cpx * ctpsa
  if y.hi == 0 then return x * y.coef[0] end     -- promote to cpx
  r = chksiz(r,y) or ctpsa_alloc(y.d, y.mo)
  _C.mad_ctpsa_scl_r(y, x.re, x.im, r) return r
end

function MC.__mul (x, y, r)
  if is_number(x) then                           -- num * ctpsa
    if y.hi == 0 then return x * y.coef[0] end   -- promote to cpx
    r = chksiz(r,y) or ctpsa_alloc(y.d, y.mo)
    _C.mad_ctpsa_scl_r(y, x, 0, r) return r
  elseif is_number(y) then                       -- ctpsa * num
    if x.hi == 0 then return x.coef[0] * y end   -- promote to cpx
    r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
    _C.mad_ctpsa_scl_r(x, y, 0, r) return r
  elseif is_complex(y) then                      -- ctpsa * cpx
    if x.hi == 0 then return x.coef[0] * y end   -- promote to cpx
    r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
    _C.mad_ctpsa_scl_r(x, y.re, y.im, r) return r
  elseif is_tpsa(y) then                         -- ctpsa * tpsa
    if x.hi == 0 and y.hi == 0 then return x.coef[0] * y.coef[0] end
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_mult(x, y, r) return r
  elseif is_ctpsa(y) and is_ctpsa(x) then        -- ctpsa * ctpsa
    if x.hi == 0 and y.hi == 0 then return x.coef[0] * y.coef[0] end
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_mul(x, y, r) return r
  elseif has_method(y, '__rmul_ctpsa') then      -- ctpsa * ?
    return y:__rmul_ctpsa(x, r)
  end
  error("invalid arguments (unsupported GTPSA operation '*')")
end

-- div

function MR.__rdiv_cpx (y, x, r)                 -- cpx / tpsa
  if y.hi == 0 then return x / y.coef[0] end     -- promote to num
  r = chksiz(r,y) or ctpsa_alloc(y.d, y.mo)      -- promote to ctpsa
  _C.mad_ctpsa_complex(y, nil, r)
  _C.mad_ctpsa_inv_r(r, x.re, x.im, r) return r
end

function MR.__div (x, y, r)
  if is_number(x) then                           -- num / tpsa
    if y.hi == 0 then return x / y.coef[0] end   -- promote to num
    r = chksiz(r,y) or tpsa_alloc(y.d, y.mo)
    _C.mad_tpsa_inv(y, x, r) return r
  elseif is_number(y) then                       -- tpsa / num
    if x.hi == 0 then return x.coef[0] / y end   -- promote to num
    r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
    _C.mad_tpsa_scl(x, 1/y, r) return r
  elseif is_complex(y) then                      -- tpsa / cpx
    if x.hi == 0 then return x.coef[0] / y end   -- promote to num
    r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)    -- promote to ctpsa
    local _y = 1/y
    _C.mad_ctpsa_complex(x, nil, r)
    _C.mad_ctpsa_scl_r(r, _y.re, _y.im, r) return r
  elseif is_ctpsa(y) then                        -- tpsa / ctpsa
    if x.hi == 0 and y.hi == 0 then return x.coef[0] / y.coef[0] end
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_tdiv(x, y, r) return r
  elseif is_tpsa(y) and is_tpsa(x) then          -- tpsa / tpsa
    if x.hi == 0 and y.hi == 0 then return x.coef[0] / y.coef[0] end
    r = chksiz(r,x,y) or tpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_tpsa_div(x, y, r) return r
  elseif has_method(y, '__rdiv_tpsa') then       -- tpsa / ?
    return y:__rdiv_tpsa(x, r)
  end
  error("invalid arguments (unsupported GTPSA operation '/')")
end

function MC.__rdiv_cpx (y, x, r)                 -- cpx / ctpsa
  if y.hi == 0 then return x / y.coef[0] end     -- promote to cpx
  r = chksiz(r,y) or ctpsa_alloc(y.d, y.mo)
  _C.mad_ctpsa_inv_r(y, x.re, x.im, r) return r
end

function MC.__div (x, y, r)
  if is_number(x) then                           -- num / ctpsa
    if y.hi == 0 then return x / y.coef[0] end   -- promote to cpx
    r = chksiz(r,y) or ctpsa_alloc(y.d, y.mo)
    _C.mad_ctpsa_inv_r(y, 1/x, 0, r) return r
  elseif is_number(y) then                       -- ctpsa / num
    if x.hi == 0 then return x.coef[0] / y end   -- promote to cpx
    r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
    _C.mad_ctpsa_scl_r(x, 1/y, 0, r) return r
  elseif is_complex(y) then                      -- ctpsa / cpx
    if x.hi == 0 then return x.coef[0] / y end   -- promote to cpx
    r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
    local _y = 1/y
    _C.mad_ctpsa_scl_r(x, _y.re, _y.im, r) return r
  elseif is_tpsa(y) then                         -- ctpsa / tpsa
    if x.hi == 0 and y.hi == 0 then return x.coef[0] / y.coef[0] end
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_divt(x, y, r) return r
  elseif is_ctpsa(y) and is_ctpsa(x) then        -- ctpsa / ctpsa
    if x.hi == 0 and y.hi == 0 then return x.coef[0] / y.coef[0] end
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_div(x, y, r) return r
  elseif has_method(y, '__rdiv_ctpsa') then      -- ctpsa / ?
    return y:__rdiv_ctpsa(x, r)
  end
  error("invalid arguments (unsupported GTPSA operation '/')")
end

-- I/O -----------------------------------------------------------------------o

-- metamethods ----------------------------------------------------------------o

MR.unm = \x,r_ -> MR.__unm(x,nil,r_)
MC.unm = \x,r_ -> MC.__unm(x,nil,r_)

MR.  add, MR.  sub, MR.  mul, MR.  div, MR.  eq, MR.  same, MR.  copy =
MR.__add, MR.__sub, MR.__mul, MR.__div, MR.__eq, MR.__same, MR.__copy

MC.  add, MC.  sub, MC.  mul, MC.  div, MC.  eq, MC.  same, MC.  copy =
MC.__add, MC.__sub, MC.__mul, MC.__div, MC.__eq, MC.__same, MC.__copy

-- MR.  pow =
-- MR.__pow

MR.__index = MR
MC.__index = MC

function MR.__newindex (_, i)
  error("invalid GTPSA member '".. tostring(i) .."'")
end

-- MR -> MC -------------------------------------------------------------------o

for k,v in pairs(MR) do
  if is_nil(MC[k]) then MC[k] = v end
end

-- TODO: set concepts for MR and MC

-- env ------------------------------------------------------------------------o

MAD.typeid.is_tpsa  = is_tpsa
MAD.typeid.is_ctpsa = is_ctpsa
MAD.typeid.isa_tpsa = isa_tpsa

-- metatables -----------------------------------------------------------------o

ffi.metatype( tpsa_ctor, MR)
ffi.metatype(ctpsa_ctor, MC)

-- end ------------------------------------------------------------------------o
return {
   tpsa      =  tpsa,
  ctpsa      = ctpsa,
  gtpsa_desc =  desc,
  __help     = require 'madh_tpsa',
}
