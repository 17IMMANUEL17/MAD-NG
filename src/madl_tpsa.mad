--[=[
 o-----------------------------------------------------------------------------o
 |
 | Generalised Truncated Power Series module
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provides full set of functions and operations on real and complex TPSA.
  - Support monomials with knobs and inhomogeneous orders.

 o-----------------------------------------------------------------------------o
]=]

local MR, MC = {}, {}

-- locals ---------------------------------------------------------------------o

local ffi = require 'ffi'
local istype in ffi

local _C, tostring, complex in MAD

-- local mono  = require 'mono'
-- local xxx in MAD.monomial

local monomial                                                   in MAD
local ident, swap, compose, bind1st                              in MAD.gfunc
local random, carg, real, imag, conj, norm, proj, rect, polar,
      ceil, floor, frac, trunc, round, abs, exp, log, log10, sqrt,
      sin, cos, tan, sinh, cosh, tanh, asin, acos, atan, asinh,
      acosh, atanh, erf, tgamma, lgamma, min, max, inf,
      sumsqr, sumabs, minabs, maxabs                             in MAD.gmath
local unm, add, mul, mod, pow, lbool, lnot, land, lor, eq, opstr in MAD.operator

local is_nil, is_number, is_string, is_table, is_iterable,
      is_mappable                                                in MAD.typeid

-- tmp for returned values
local  res = ffi.new 'double [1]'
local cres = ffi.new 'complex[1]'

-- constants
local dbl_sz = ffi.sizeof 'double'
local cpx_sz = ffi.sizeof 'complex'

-- types ----------------------------------------------------------------------o

ffi.cdef [[
typedef unsigned int bit_t; // mad_bit.h

struct desc { // warning: must be kept identical to C definition
  int   id;          // index in list of registered descriptors
  int   nmv, nv;     // number of mvars, number of all vars
  ssz_t nc;          // number of coefs (length of TPSA)
  ord_t mo, ko,      // maximum order for mvars and knobs (mo=max(mvar_ords[]))
        trunc;       // truncation order for operations; always <= mo
  const ord_t
        *mvar_ords,  // mvars orders[nmv] (for each TPSA in map) -- used just for desc comparison
        * var_ords;  //  vars orders[nv ] (max order for each monomial variable)
};            // end of compatibility with Lua FFI (rest is not visible)

struct tpsa { // warning: must be kept identical to C definition
  desc_t *d;           // ptr to descriptor
  ord_t   lo, hi, mo;  // lowest/highest used ord, trunc ord
  bit_t   nz;          // non-zero homogeneous polynomials
  num_t   coef[?];
};

struct ctpsa { // warning: must be kept identical to C definition
  desc_t *d;           // ptr to descriptor
  ord_t   lo, hi, mo;  // lowest/highest used ord, trunc ord
  bit_t   nz;          // non-zero homogeneous polynomials
  cnum_t  coef[?];
};
]]

local  desc_ctor = ffi.typeof ' desc_t '
local  tpsa_ctor = ffi.typeof ' tpsa_t '
local  tpsa_cref = ffi.typeof ' tpsa_t&'
local ctpsa_ctor = ffi.typeof 'ctpsa_t '
local ctpsa_cref = ffi.typeof 'ctpsa_t&'

local int_arr    = ffi.typeof 'int     [?]'
local tpsa_arr   = ffi.typeof 'tpsa_t* [?]'

local is_desc  = \x -> istype( desc_ctor, x)
local is_tpsa  = \x -> istype( tpsa_ctor, x)
local is_ctpsa = \x -> istype(ctpsa_ctor, x)
local isa_tpsa = \x -> is_tpsa(x) or is_ctpsa(x)

-- allocators -----------------------------------------------------------------o

local function tpsa_alloc (d, mo)
  assert(is_desc(d), "invalid argument #1 (GTPSA descriptor expected)")
  local len, tpsa = d.nc, nil
  if len < _C.mad_alloc_threshold then
    tpsa = tpsa_ctor(len) -- VLA
  else
    assert(len <= 2^30, "tpsa is too large")
    local siz = ffi.sizeof(tpsa_ctor, 0) + len*dbl_sz
    local ptr = assert(_C.mad_calloc(1,siz), "out of memory")
    tpsa = ffi.gc(ffi.cast(tpsa_cref, ptr), _C.mad_free)
  end
  tpsa.d = d
  tpsa.lo, tpsa.hi, tpsa.mo = mo, 0, mo
  tpsa.nz, tpsa.coef[0] = 0, 0
  return tpsa
end

local function ctpsa_alloc (d, mo)
  assert(is_desc(d), "invalid argument #1 (GTPSA descriptor expected)")
  local len, ctpsa = d.nc, nil
  if len < (_C.mad_alloc_threshold/2) then
    ctpsa = ctpsa_ctor(len)
  else
    assert(len <= 2^29, "ctpsa is too large")
    local siz = ffi.sizeof(ctpsa_ctor, 0) + len*cpx_sz
    local ptr = assert(_C.mad_calloc(1,siz), "out of memory")
    tpsa = ffi.gc(ffi.cast(ctpsa_cref, ptr), _C.mad_free)
  end
  ctpsa.d = d
  ctpsa.lo, ctpsa.hi, ctpsa.mo = mo, 0, mo
  ctpsa.nz, ctpsa.coef[0] = 0, 0
  return ctpsa
end

-- ctors ----------------------------------------------------------------------o

-- nv: number of map variables (when mo is a value)
-- mo: map variables orders (array or value)
-- vo: variables orders (array) with vo[i] <= mo[i]
-- ko: max 'knobs' cross-orders (max order of cross terms)

-- ex0:    desc(nil)                           : 6 mvars of order 2.
-- ex1.0:  desc(3)         -> mo=3             : 6 mvars of order 3.
-- ex2.0:  desc(4,3)       -> nv=4,mo=3        : 4 mvars of order 3.
-- ex3.0:  desc{3,3}       -> mo={3,3}         : 2 mvars of order 3.
-- ex1.1:  desc{mo=3}      -> mo=3             : 6 mvars of order 3.
-- ex2.1:  desc{nv=4,mo=3} -> nv=4,mo=3        : 4 mvars of order 3.
-- ex3.1:  desc{mo={3,3}}  -> mo={3,3}         : 2 mvars of order 3.
-- ex4.1:  desc{mo={3,3}, vo={2,2,1,1}, ko=1}  : 2 mvars of order 3,
--         each mvars contains 4 vars (2 mvars + 2 knobs) of orders 2,2,1,1,
--                           knobs x-order is limited to 1 (no cross-terms).

local function desc (nv_, mo_)
  if is_nil(mo_) then
    mo_, nv_ = nv_ -- right shift
  end

  local ism = is_mappable(mo_)
  local nv = ism and mo_.nv or nv_ or 6
  local mo = ism and mo_.mo or mo_ or 2
  local vo = ism and mo_.vo or nil
  local ko = ism and mo_.ko or nil

  if is_number(nv) and is_number(mo) then      -- ex 0, 1.0, 2.0, 1.1, 2.1
    return _C.mad_desc_newn(nv, mo)
  end

  if is_iterable(mo) and is_nil(vo) then       -- ex 3.0, 3.1
    local m = mono(mo)
    return _C.mad_desc_newm(m.n, m.data)
  end

  if is_iterable(mo) and is_iterable(vo) then  -- ex 4.1
    local m, v = mono(mo), mono(vo)
    return _C.mad_desc_newm(m.n, m.data, v.n, v.m, ko)
  end

  error("invalid combination of arguments (GTPSA descriptor)")
end

-- tpsa(t)       -> t.mo
-- tpsa(d)       -> d.mo
-- tpsa(t|d, mo) -> mo

local function tpsa (td, mo_)
  if isa_tpsa(td) then
    mo_, td = mo_ or td.mo, td.d -- mo = t.mo
  else
    assert(is_desc(td), "invalid argument #1 (tpsa or descriptor expected)")
    mo_     = mo_ or td.mo       -- mo = d.mo
  end
  assert(is_number(mo_), "invalid argument #2 (number expected)")
  return tpsa_alloc(td, max(0, min(mo_, td.mo)))
end

local function tpsa (td, mo_)
  if isa_tpsa(td) then
    mo_, td = mo_ or td.mo, td.d -- mo = t.mo
  else
    assert(is_desc(td), "invalid argument #1 (tpsa or descriptor expected)")
    mo_     = mo_ or td.mo       -- mo = d.mo
  end
  assert(is_number(mo_), "invalid argument #2 (number expected)")
  return ctpsa_alloc(td, max(0, min(mo_, td.mo)))
end

-- env ------------------------------------------------------------------------o

MAD.typeid.is_tpsa  = is_tpsa
MAD.typeid.is_ctpsa = is_ctpsa
MAD.typeid.isa_tpsa = isa_tpsa

-- metatables -----------------------------------------------------------------o

ffi.metatype( tpsa_ctor, MR)
ffi.metatype(ctpsa_ctor, MC)

-- end ------------------------------------------------------------------------o
return {
   tpsa      =  tpsa,
  ctpsa      = ctpsa,
  gtpsa_desc =  desc,
  __help     = require 'madh_tpsa',
}
