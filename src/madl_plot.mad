--[=[
 o-----------------------------------------------------------------------------o
 |
 | Plot module
 |
 | Methodical Accelerator Design - Copyright CERN 2015+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 |          A.Z. Teska, aleksandra.teska at cern.ch
 |          A. Bloch, aurelien.bloch at cern.ch
 | Contrib: F.R. Leiro
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provides plotting

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local ffi = require "ffi"
local dat = require "madl_plotdat"

local Object, Command, fun, vector, survey, filesys, atexit      in MAD
local sign, tan, min, max, abs, sqrt, inf, pi                    in MAD.gmath
local lshift                                                     in MAD.operator
local strinterp, setkeys, tblcpy, runonce, fileexists            in MAD.utility
local is_nil, is_number, is_table, is_mtable, is_string,
      is_sequence, is_rawtable                                   in MAD.typeid

-- Utility --------------------------------------------------------------------o

ffi.cdef[[
void Sleep(int ms);
int poll(struct pollfd *fds, unsigned long nfds, int timeout);
]]

local sleep
if ffi.os == "Windows"
then sleep = \s -> ffi.C.Sleep(s)
else sleep = \s -> ffi.C.poll(nil, 0, s)
end

MAD.utility.sleep = sleep

-- global default -------------------------------------------------------------o

local _dflt = {
  color        = "red",
  style        = "linespoints",
  dashtype     = "solid",
  linewidth    = 1,
  pointsize    = 1,
  pointtype    = 1,
  originx      = 0,
  originy      = 0,
  psizex       = 1,
  psizey       = 1,
  laysize      = 0.15,
  multisize    = 0.05,
  elemwidth    = 0.07,
  elemwidth_in = 1,
  padding      = 0.025,
  middle       = 0.5,
  layonly      = 1,
  ocolor       = "white",
  ostyle       = "solid 1.0",
}

local tmpfolder = "TMP_MAD_PLOT/"
local tmplock   = tmpfolder .. "madplot.lock"

-- tmp files ------------------------------------------------------------------o

local _handlepool, _warn, max_tmp_file = {}, true, 25
local _filepool, lock

-- lock for atomic operation (blocking)
local function plot_lock ()
  if not fileexists(tmpfolder) then
    local status,msg = filesys.mkdir(tmpfolder)
    if not status and msg~="File exists" then
      error("couldn't create TMP_MAD_PLOT")
    end
  end
  if not lock then lock = assert(io.open(tmplock, "w")) end
  while not filesys.lock(lock, "w") do sleep(100) end
end

-- unlock for atomic operation
local function plot_unlock ()
  filesys.unlock(lock)
end

-- clear the list of handle of non-existing file
local function clear_handle (sid_)
  plot_lock()
  local isbusy = false
  for fname,v in pairs(_handlepool) do
    if not fileexists(fname) then
      _handlepool[fname] = nil
    elseif sid_ == v[1] then
      isbusy = true
    end
  end
  plot_unlock()
  return isbusy
end

-- remove unused tmp file
local function clean_tmp ()
  if not fileexists(tmpfolder) then return end
  plot_lock()
  for name in filesys.dir(tmpfolder) do
    if string.find(name, "madplot%-%d+") then
      local fname = tmpfolder .. name
      local file  = io.open(fname)
      if file and filesys.lock(file, "r") and not _handlepool[fname] then
        os.remove(fname)
      end
      if file then file:close() end
    end
  end
  _filepool = nil
  plot_unlock()
  clear_handle()
end

-- initialize the list of available tmp file
local function setup_files()
  clean_tmp()
  entry = 1
  local tmpfile = tmpfolder .. "madplot-"
  _filepool     = {}
  for i=max_tmp_file,1,-1 do
    local file = tmpfile .. i
    if not fileexists(file) then
      _filepool[entry] = file
      entry = entry + 1
    end
  end
end

local plot_atexit = \ atexit(clean_tmp)
-- return an available tmp file and its name (blocking)
local function get_tmpfile()
  runonce(plot_atexit)
  if not is_rawtable(_filepool) then setup_files() end
  plot_lock()
  local fname, warn = false, false
  while true do
    fname = table.remove(_filepool)
    if fname and not fileexists(fname) then break end
    if _warn and warn then
      print("MAD Plot Warning : no available tmpfile (see documentation)")
      _warn = false
    end
    plot_unlock(); sleep(100); plot_lock()
    setup_files()
    warn = true
  end
  local file = assert(io.open(fname, "w"))
  _handlepool[fname] = file
  filesys.lock(file, "w")
  plot_unlock()
  return file, fname
end

-- gplot ----------------------------------------------------------------------o

-- gnuplot list, hidden key for sid
local _gplist, _sid = { max = 25 }, {}

-- get gnuplot from id and create it if necessary
local function get_gp (sid)
  local gnuplot = _gplist[sid]
  if not gnuplot then
    gnuplot = assert(io.popen("gnuplot", "w"))
    gnuplot:setvbuf("line")
    _gplist[sid] = gnuplot
  end
  return gnuplot
end

-- write command to gnuplot
local function gp_write (gplot, ...)
  get_gp(gplot[_sid]):write(..., "\n")
end

-- printf command to gnuplot
local function gp_printf (gplot, str, ...)
  get_gp(gplot[_sid]):write(string.format(str, ...), "\n")
end

-- set the sid of a gplot
local function gp_setsid (gplot, sid)
  assert(is_number(sid), "invalid argument #1 (number expected)")
  if sid < 1 or _gplist.max < sid then
    error("invalid argument #1 (number should be comprise between 1 and "
      .. _gplist.max .. " )")
  end
  gplot[_sid] = sid
end

-- test if tmpFile exist for this sid
local function gp_isBusy (gplot)
 return clear_handle(gplot[_sid])
end

local gplot_ = Object 'gplot' {
  sid           = \gplot -> gplot[_sid],
  [_sid]        = 1,
}:set_methods {
  write         = gp_write,
  printf        = gp_printf,
  set_sid       = gp_setsid,
  is_busy       = gp_isBusy,
  clean_tmpFile = clean_tmp,
}:set_readonly()

local gplot = gplot_ {}

-- initialization -------------------------------------------------------------o

local init_cmd = [[
#== initialization =============================================================
if (!(exist("MAD_MIN") && exist("MAD_MAX"))) {
  MAD_MIN = ${oshft};
  MAD_MAX = -1;
}
MAD_RESET_OBJECT = "unset for [i=MAD_MIN:MAD_MAX] object i"
MAD_RESET_LABEL  = "unset for [i=MAD_MIN:MAD_MAX] label i"
if (!(exist("MAD_OLD_TERM") && exist("MAD_NEW_TERM"))) {
  MAD_OLD_TERM = "";
  MAD_NEW_TERM = "";
}
MAD_SET_TERM = "if (!(MAD_OLD_TERM eq MAD_NEW_TERM)) { \
  @MAD_NEW_TERM; \
  MAD_OLD_TERM = MAD_NEW_TERM; \
}"
#===============================================================================

]]

-- dump header and set terminal to script file
local function setup_cmd (self)
  local output, scrdump in self
  local file, fname = get_tmpfile()
  gplot:set_sid(self.sid)
  file:write(init_cmd % self)

  if is_number(output) then
    file:write("MAD_NEW_TERM = \"set term ${term} ${output} size ${wsizex},${wsizey} \z
      enhanced font '${font},${fontsize}'\"\n" % self)
  elseif is_string(output) then
    file:write("MAD_NEW_TERM = \"set term pdfcairo; set out '"
      .. output .. "'\"\n")
  end

  file:write("@MAD_SET_TERM\n")
  return file, fname
end

local function gnuplot_rm(fname)
  if jit.os == "Windows"
  then gplot:printf("system 'del %s >nul 2>&1'", fname)
  else gplot:printf("system '\\rm -f %s'"      , fname)
  end
end

local function gnuplot_mv(fname, uname)
  if jit.os == "Windows"
  then gplot:printf("system 'move /Y %s %s'", fname, uname)
  else gplot:printf("system '\\mv %s %s'"   , fname, uname)
  end
end

local function teardown_cmd (self, file, fname)
  local scrdump, output in self
  file:flush()
  if output then
    gplot:printf("load('%s')", fname)
    if is_string(scrdump)
    then gnuplot_mv(fname, scrdump)
    else gnuplot_rm(fname)
    end
  else
    if is_string(scrdump) then
      os.rename(fname, scrdump)
    else
      os.remove(fname)
      print("MAD Plot Warning : no scrdump nor output provided - Nothing done")
    end
  end
end

-- layout ---------------------------------------------------------------------o

-- element flag for layout
local flayangle = MAD.element.flags.layangle
local flayout   = MAD.element.flags.layout
local flays     = lshift(1, flayangle) + lshift(1, flayout)

--  adjust "out of plot" layout coordinate
local xadjust    = \xs,ys,base,l -> xs*l + base
local yadjust    = \size  -> \xs,ys,base -> size*ys + base
--  adjust "in plot" layout coordinate
local xadjust_in = \size  -> \xs,ys,base -> xs*base[1] + size*ys*base[2] + base[3]
local yadjust_in = \size  -> \xs,ys,base -> xs*base[1] + size*ys*base[2] + base[3]

-- return the shape of an element in x and y
local function eShap (param, elem, dir)
  local kindcolor in param
  local shape        = dat[elem.kind]
  local el, dash, sh = shape.ellipse, shape.dashtype, shape.shape
  local color, style

  if is_table(kindcolor) and kindcolor[elem.kind] then
    local cs = kindcolor[elem.kind]
    color = is_table(cs) and cs.fillcolor or is_string(cs) and cs or shape.fillcolor
    style = is_table(cs) and cs.fillstyle or shape.fillstyle
  elseif kindcolor then
    color, style = shape.fillcolor, shape.fillstyle
  else
    color, style = _dflt.ocolor, _dflt.ostyle
  end
  local eColor = { color = color, style = style }

  sh = sh and elem.l == 0 and elem.kind ~= "marker" and dat.default.shape or sh
  -- if only a ellipse
  if not is_table(sh) then return el, dash, eColor end

  local ysym, yscl, func = shape.ysym, (shape.yscl or 1), nil
  local yshft = shape.yshft and sign(elem[shape.yshft]) or 0
  yshft = yshft * (shape.yfact or 1)
  if is_number(ysym) then -- for symmetric shapes
    func = {
      \y -> ((   y + yshft)*yscl),
      \y -> ((-1*y + yshft)*yscl),
    }
  else
    local fv = sign(elem[ysym] or 1)
    ysym = (ysym == "angle") and fv*dir or fv
    func = {\y -> ((ysym*y + yshft)*yscl) }
  end
  return el, dash, eColor, sh.x, sh.y, func
end

-- stream polygon data
local function layout_poly (param, len, xorig, yorig, x_sh, y_sh, dash, eColor, func)
  local fpwrite, xadjust, yadjust, ref in param
  for i=1,#func do
    for j=1,#x_sh do
      local xj, yj = x_sh[j], y_sh[j]
      local dashtype = dash and "dashtype '" .. dash .. "'" or ""
      fpwrite("set object %d polygon front fc rgb '%s' fs %s \z
        border rgb 'black' %s \\\n",
        param.oid, eColor.color, eColor.style, dashtype)
      local cmd = "from"

      for k=1,#xj do
        local xk, yk = xj[k], func[i](yj[k])
        xk, yk = xadjust(xk, yk, xorig, len), yadjust(xk, yk, yorig)
        local next = (k == #xj) and "" or " \\"
        fpwrite("  %s %.5e, %s %.5e%s\n", cmd, xk, ref, yk, next)
        cmd = "to"
      end
      param.oid = param.oid + 1
    end
  end
  fpwrite("\n")
end

-- stream ellipse data
local function layout_ellipse (param, len, el, xorig, yorig, dash, eColor, size)
  local fpwrite, xadjust, yadjust, ref in param
  local cx, cy = xadjust(0, 0, xorig, len), yadjust(0, 0, yorig)
  local sx, sy = len, el*size
  local dashtype = dash or ""
  fpwrite("set object %d ellipse front at %.5e, %s %.5e \\\n\z
    size %.5e, %s %.5e front fc rgb '%s' fs %s border rgb 'black' %s \n",
    param.oid, cx, ref, cy, sx, ref, sy,
    eColor.color, eColor.style, dashtype)
  param.oid = param.oid + 1
end

-- stream element label data
local function layout_label(param, name, kind, xorig, yorig)
  local fpwrite, oid, ref, xadjust, yadjust in param
  local x, y = xadjust(0, 0, xorig, 1), yadjust(0, 0, yorig)
  label = name .. " [" .. kind .. "]"
  fpwrite("set label %d back at %.5e, %s %.5e '%s' hypertext \z
    point pt 4 ps 1 lc 'white'\n", oid, x, ref, y, label)
end

-- stream beam line data
local function layout_bline (param, bline)
  local fpwrite, ref in param
  local prevX, prevY = bline.x[1], bline.y[1]
  for i=2,#bline.y do
    local xi, yi = bline.x[i], bline.y[i]
    fpwrite("set object %d polygon front dashtype solid \\\n\z
      from first %.5e, %s %.5e to first %.5e, %s %.5e to first %.5e, %s %.5e\n",
      param.oid, prevX, ref, prevY, xi, ref, yi, prevX, ref, prevY)
    param.oid = param.oid + 1
    prevX, prevY = xi, yi
  end
end

-- process data for "out of plot" layout
local function layout_process(param, pseq)
  local seqshift, nturn, layangle in param
  local range, seq, disty, distx  in pseq
  local size    = nturn*seq:length_of(range)
  local xs, ys  = table.new(size, 0), table.new(size, 0)
  local bline   = { x = { }, y={ } }
  local deltaY  = disty
  local prevs_sh, angle, j, dir = 0, 0, 1, seq.direction
  for i, elem, s in seq:iter(range, nturn) do
    local s_sh   = s + elem.l/2
    deltaY       = deltaY - tan(dir*angle)*(s_sh-prevs_sh)
    xs[j], ys[j] = s_sh + distx + seqshift, deltaY
    prevs_sh     = s_sh
    pseq.xmin, pseq.xmax = min(pseq.xmin, xs[j]), max(pseq.xmax, xs[j])
    pseq.ymin, pseq.ymax = min(pseq.ymin, ys[j]), max(pseq.ymax, ys[j])
    if elem:is_selected(flayangle) and layangle then
      angle = angle + elem.angle
      table.insert(bline.x, xs[j]); table.insert(bline.y, ys[j])
    end
    j = j + 1
  end
  table.insert(bline.x, xs[#xs]); table.insert(bline.x, 1, xs[1])
  table.insert(bline.y, ys[#ys]); table.insert(bline.y, 1, ys[1])
  pseq.xs, pseq.ys, pseq.bline = xs, ys, bline
end

-- process data "in plot" layout (see help for formulas)
local function layout_process_in(param, pseq)
  local seqlabel, nturn, A0, X0 in param
  local range, seq    in pseq
  local size       = nturn*seq:length_of(range)
  local xs, ys     = table.new(size, 0), table.new(size, 0)
  local bline      = { x = table.new(size, 0), y = table.new(size, 0) }
  local srv        = survey { sequence = seq, range = range, A0=A0, X0=X0 }
  local idx, j     = 0, 1
  local labx, laby = seqlabel[1], seqlabel[2]

  for i, elem in seq:iter(range, nturn) do
    local line_idx = srv:index_of(elem.name, idx)
    if is_table(line_idx) then line_idx = line_idx[1] end
    idx = line_idx
    local line     = srv:getrow(line_idx)
    local prevLine, x1, y1, xas, yas, xbs, ybs

    repeat
      prevLine = (line_idx~=1) and srv:getrow(line_idx-1) or { x=0, y=0, z=0 }
      x1, y1   = prevLine[labx], prevLine[laby]
      x2, y2   = line[labx], line[laby]
      xas, yas = 0.5*(x2 - x1), 0.5*(y2 - y1)
      line_idx = line_idx - 1
    until xas ~= 0 or yas ~= 0 or line_idx <= 1

    if xas == 0 and yas == 0 then
      xbs, ybs   = 0, 1
    else
      local xx, yy = (x1 - x2), (y2 - y1)
      local sqrt_  = 1 / sqrt( yy^2 + xx^2 )
      xbs, ybs = yy*sqrt_, xx*sqrt_
    end

    if elem.l == 0
    then xshft, yshft = x2, y2
    else xshft, yshft = x1 + xas, y1 + yas
    end

    xs[j], ys[j]         = {xas, xbs, xshft}, {yas, ybs, yshft}
    pseq.xmin, pseq.xmax = min(pseq.xmin, xshft), max(pseq.xmax, xshft)
    pseq.ymin, pseq.ymax = min(pseq.ymin, yshft), max(pseq.ymax, yshft)
    table.insert(bline.x, xshft); table.insert(bline.y, yshft)
    j = j + 1
  end
  pseq.xs, pseq.ys, pseq.bline = xs, ys, bline
end

-- stream a signle layout
local function layout (param, pseq)
  local elemminlen, kindselect, elemwidth, elemname, nturn, kindcolor in param
  local seq, range, xs, ys, bline                                     in pseq
  local dir, j  = seq.direction, 1

  layout_bline(param, bline)
  for i, elem, s in seq:iter(range, nturn) do
    local len, ekind    = elem.l, elem.kind
    local is_flagged   = elem:test_flags(flays)
    local is_vkind     = not kindselect or kind[ekind]
    local xorig, yorig = xs[j], ys[j]

    if is_flagged or (len >= elemminlen and is_vkind) then
      local sh_l = len / 2
      local el, dash, eColor, x_sh, y_sh, func = eShap(param, elem, dir)

      if elemname  then layout_label(param, elem.name, ekind, xorig, yorig) end

      if not is_nil(el) and len ~= 0 then
        layout_ellipse(param, len, el, xorig, yorig, dash, eColor, elemwidth)
      end

      if not is_nil(x_sh) then
        layout_poly(param, sh_l, xorig, yorig, x_sh, y_sh, dash, eColor, func)
      end
    end
    j = j + 1
  end
end

-- compute bounding box and scale data accordingly
-- post processing for "out of plot" layout
local function layout_post(param, pseqs, ymin, ymax)
  local sequence, laypos, layonly, elemwidth, elemscale in param
  param.laysize  = param.laysize
    or (layonly and _dflt.layonly)
    or (is_rawtable(sequence) and _dflt.laysize + _dflt.multisize*#sequence)
    or _dflt.laysize
  elemwidth     = (elemwidth or _dflt.elemwidth) * elemscale
  local pad     = _dflt.padding
  local ybbox   = abs(ymax - ymin) + 2.4*elemwidth + 2*pad
  local yfactor = param.laysize / ybbox
  elemwidth     = elemwidth * yfactor
  if laypos == "top"    then laypos =1-(ymax*yfactor + 1.2*elemwidth + pad) end
  if laypos == "bottom" then laypos =  -ymin*yfactor + 1.2*elemwidth + pad  end
  if laypos == "middle" then laypos = _dflt.middle end
  param.elemwidth = elemwidth

  for i=1,#pseqs do
    local pseq = pseqs[i]
    local ys, bline in pseq
    pseq.ys      = fun.map(\y -> y*yfactor + laypos, ys):totable()
    pseq.bline.y = fun.map(\y -> y*yfactor + laypos, bline.y):totable()
  end
end

-- post processing for "in plot" layout
local function layout_post_in(param, ymin, ymax)
  local elemwidth, elemscale in param
  elemwidth       = elemwidth or (abs(ymax - ymin) * 1.2*_dflt.elemwidth_in/100)
  param.elemwidth = elemwidth * elemscale
end

-- main layout function
local function multi_layout (param)
  local sequence, fpwrite, range, seqdistx, seqdisty,
    elemwidth, elemscale, laypos, xrange                  in param
  local is_in = (laypos == "in")
  param.ref = is_in and "" or "screen"
  local xmin, xmax, ymin, ymax = inf, -inf, inf, -inf
  local pseqs = { }
  local seqs = is_rawtable(sequence) and sequence or
               is_sequence(sequence) and {sequence} or
               error("Invalid sequence input")

  for i=1,#seqs do
    local distx = (i~=1) and (is_table(seqdistx) and seqdistx[i-1] or seqdistx) or 0
    local disty = (i~=1) and (is_table(seqdisty) and seqdisty[i-1] or seqdisty) or 0
    local rg    = (#seqs > 1) and is_table(range) and range[i] or range or nil
    local pseq  = {
      xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax,
      seq = seqs[i], distx = distx, disty = disty, range=rg
    }
    if is_in
    then layout_process_in(param, pseq)
    else layout_process(param, pseq)
    end
    xmin, xmax = min(xmin, pseq.xmin), max(xmax, pseq.xmax)
    ymin, ymax = min(ymin, pseq.ymin), max(ymax, pseq.ymax)
    pseqs[i]   = pseq
  end

  if is_in
  then layout_post_in(param, ymin, ymax)
  else layout_post(param, pseqs, ymin, ymax)
  end
  param.xadjust = is_in and xadjust_in(param.elemwidth) or xadjust
  param.yadjust = is_in and yadjust_in(param.elemwidth) or yadjust(param.elemwidth)

  for i=1,#pseqs do
    local pseq = pseqs[i]
    layout(param, pseq)
  end

  fpwrite("MAD_MAX = %.5e\n", param.oid)
  xmin, xmax = xmin - param.elemwidth, xmax + param.elemwidth
  ymin, ymax = ymin - param.elemwidth, ymax + param.elemwidth
  if not xrange           then fpwrite("set xrange [%.5e:%.5e]\n", xmin, xmax) end
  if not yrange and is_in then fpwrite("set yrange [%.5e:%.5e]\n", ymin, ymax) end
end

-- plot -----------------------------------------------------------------------o

-- get vector from label
local function getv (data, tbl, label)
  if label then
    if data and data[label] then
      return data[label]
    elseif tbl[label] then
      return tbl[label], true
    else
      error("invalid label")
    end
  end
end

-- parse input axis and apply func to each label
local function parse_axis (param, func)
  local _axis = {"x1y1", "x1y2", "x2y1", "x2y2"}
  for _,axis_name in ipairs(_axis) do
    local axis = param[axis_name]
    if is_string(axis) then                  -- e.g. x1y1 = "y1"
      func(param, nil, {axis}, axis_name)
    elseif is_table(axis) then
      if #axis ~= 0 then
        func(param, nil, axis, axis_name)    -- e.g. x1y1 = {"y1", "y2"}
      end
      for x,ys in kpairs(axis) do
        if is_string(ys) then                -- e.g. x1y1 = { x1 = "y1" }
          func(param, x, {ys}, axis_name)
        elseif is_table(ys) then             -- e.g. x1y1 = { x1 = {"y1", "y2"}}
          func(param, x, ys, axis_name)
        end
      end
    end
  end
end

-- stream one plot data (called by parse_axis)
local function plot_data (param, xlbl, ylbl)
  local fpwrite, tablerange, data, table in param
  local datai, iter, tbl, key = 1

  if table
  then iter, tbl, key = table:iter(tablerange)
  else iter, tbl, key = ipairs(data[ylbl[1]])
  end

  local get_data = \lbl, row ->
    data  and data[lbl] and data[lbl][datai] or
    table and row       and row[lbl]

  fpwrite("# %-9s ", xlbl or "index")
  for j, lbl in ipairs(ylbl) do
    fpwrite("%-11s ", lbl)
  end
  fpwrite("\n")

  for i, row in iter, tbl, key do
    fpwrite("%.5e ", get_data(xlbl, row) or datai)
    for j, lbl in ipairs(ylbl) do
      local val = get_data(lbl, row)
      if not is_number(val) then error("MAD Plot : invalid data") end
      fpwrite("%.5e ", val)
    end
    fpwrite("\n")
    datai = datai + 1
  end
  fpwrite("\n\n")
end

-- parse dashtypes and add '' if it is a pattern : e.g.: ".-- "
local function parse_dash (dashtypes, datastyle, y)
  local dash = datastyle and datastyle.dashtype or is_table(dashtypes) and
    (dashtypes[y] or _dflt.dashtype) or dashtypes
  if string.match(dash, "[.%-_ ]+") then return "'" .. dash .. "'" end
  return dash
end

-- Create interpolation variable for the plot command (called by parse_axis)
local function plot_cmd (param, _, ys, axis)
  local pwrite, colors, styles, dashtypes, pointsizes,
    pointtypes, linewidths, legend, datastyles, intpol in param
  local add = \k,v => intpol[k..intpol.id] = v end

  for i, y in ipairs(ys) do
    local values = {
      color     = datastyles[y] and datastyles[y].color     or is_table(colors)     and (colors[y]     or _dflt.color)     or colors,
      style     = datastyles[y] and datastyles[y].style     or is_table(styles)     and (styles[y]     or _dflt.style)     or styles,
      pointsize = datastyles[y] and datastyles[y].pointsize or is_table(pointsizes) and (pointsizes[y] or _dflt.pointsize) or pointsizes,
      pointtype = datastyles[y] and datastyles[y].pointtype or is_table(pointtypes) and (pointtypes[y] or _dflt.pointtype) or pointtypes,
      linewidth = datastyles[y] and datastyles[y].linewidth or is_table(linewidths) and (linewidths[y] or _dflt.linewidth) or linewidths,
      dashtype  = parse_dash(dashtypes, datastyles[y], y),
      title     = (legend == false) and ""
                    or is_table(legend) and
                      ( legend[y] == false and "" or legend[y] )
                    or y,
      axis      = axis,
      col       = i + 1,
    }

    if intpol.id == 1
    then add("cmd", "plot "); add("data", "'$MAD_DATA' ")
    else add("cmd", "     "); add("data", "''          ")
    end

    add("index", "index ${databi} " % param)
    add("using", "using 1:${col} "  % values)
    add("style", "${style} "        % values)

    if string.match(values.style, "lines")
    then add("lines" , "dashtype ${dashtype} linewidth ${linewidth} " % values)
    else add("lines" , "")
    end

    if string.match(values.style, "points")
    then add("points", "pointsize ${pointsize} pointtype ${pointtype} " %values)
    else add("points", "")
    end

    add("color", "linecolor '${color}' " % values)
    add("title", "title '${title}' "     % values)
    add("axes" , "axes ${axis} "         % values)
    intpol.id = intpol.id + 1
  end
  param.databi = param.databi + 1
end

local function cmd_interpolate (param)
  local pwrite, intpol, plotcmd, plotvar in param
  local cmd = ""
  if is_string(plotcmd) then
    cmd = plotcmd
  else
    for i=1,intpol.id-1 do
      local cmdi = "${cmd${id}}${data${id}}${index${id}}${using${id}}\z
                    with ${style${id}}${lines${id}}${points${id}}\z
                    ${color${id}}${title${id}}${axes${id}},\\\n"
      intpol.id = i
      cmd = cmd .. (cmdi % intpol)
    end
  end
  if is_table(plotvar) then tblcpy(plotvar, false, intpol) end
  pwrite(cmd % intpol)
end

-- set the range command for all axis
local function set_ranges (param)
  local fpwrite in param
  local names = {"xrange", "x2range", "yrange", "y2range"}
  for _,rname in ipairs(names) do
    local range = param[rname]
    if range then fpwrite("set %s [%.5e:%.5e]\n", rname, range[1], range[2]) end
  end
end

-- set label command for each axis
local function set_label (param)
  local fpwrite in param
  local names = {"xlabel", "x2label", "ylabel", "y2label"}
  for _,lname in ipairs(names) do
    local label = param[lname]
    if label then fpwrite("set %s '%s'\n", lname, label) end
  end
end

-- set tics for each used axis
local function set_tics (param)
  local x2y1, x2y2, x1y2, x2y2, pwrite in param
  if x2y1 or x2y2 then pwrite("set xtics nomirror\nset x2tics nomirror\n") end
  if x1y2 or x2y2 then pwrite("set ytics nomirror\nset y2tics nomirror\n") end
end

-- set remaining parameters (miscellaneous)
local function set_misc (param)
  local fpwrite, psizex, psizey, originx, originy, grid,
    border, title, legendpos, titlefont, titlesize,
    legendfont, legendsize                                in param
  if grid   then fpwrite("set grid %s\n", grid)     end
  if border then fpwrite("set border %s\n", border) end
  if title  then
    local font, size = titlefont or "", titlesize or ""
    title = title % param
    fpwrite("set title '%s' font '%s,%s'\n", title, font, size)
  end
  if legendpos then
    local font, size = legendfont or "", legendsize or ""
    fpwrite("set key %s font '%s,%s'\n", legendpos, font, size)
  end
  if psizey or psizex then
    psizex, psizey = psizex or _dflt.psizex, psizey or _dflt.psizey
    fpwrite("set size %.5e, %.5e\n", psizex, psizey)
  end
  if originy or originx then
    originx, originy = originx or _dflt.originx, originy or _dflt.originy
    fpwrite("set origin %.5e, %.5e\n", originx, originy)
  end
end

-- main plot function
local function plot (param)
  local pwrite, plotcmd, plotcfg in param
  set_ranges(param)
  set_label(param)
  set_tics(param)
  set_misc(param)

  pwrite("$MAD_DATA << EOD\n")
  parse_axis(param, plot_data)
  pwrite("EOD\n\n")

  if plotcfg then pwrite(plotcfg .. "\n") end
  parse_axis(param, plot_cmd)
  cmd_interpolate(param)
  pwrite("\n")
end

-- command --------------------------------------------------------------------o

-- create a graph with both the layout and the plot part
local function composed_plot (param)
  local laypos, psizey, originy in param

  multi_layout(param)

  local laysize in param
  if laypos == "top" or laypos == "bottom" then
    param.psizey = psizey or _dflt.psizey - laysize
  end
  param.originy = originy or laypos == "bottom" and laysize
                          or _dflt.originy
  plot(param)
end

-- initialize the table of parameters
local function init_param(self, file)
  local table, oshft, kindselect, name, date, time in self
  local param = {
    version = tostring(MAD.env.version),
    name    = name or is_table(table) and table.title or "",
    date    = date or is_table(table) and table.date  or "",
    time    = time or is_table(table) and table.time  or "",
    databi  = 0,
    intpol  = { id = 1 },
    plotter = file,
    oid     = oshft,
    fpwrite = \... -> file:write(string.format(...)),
    pwrite  = \... -> file:write(...)
  }
  if kindselect then -- build dictionary
    setkeys(kindselect)
  end
  setmetatable(param, {__index=self})
  return param
end

local layout_only = [[
unset key
unset tics
unset border
plot x lc 'white'
]]

local function exec (self)
  local file, fname = setup_cmd(self)
  if self.sequence ~= "keep" then
    file:write("@MAD_RESET_OBJECT\n")
    file:write("@MAD_RESET_LABEL\n")
  elseif self.range then
    print("MAD Plot Warning : sequence=\"keep\" and range is \z
      provided - range is ignored")
  end

  if self.prolog then file:write(self.prolog, "\n") end
  local param = init_param(self, file)

  local has_plot   = is_mtable(self.table) or is_table(self.data)
  local has_layout = is_rawtable(self.sequence) or is_sequence(self.sequence)
  if has_plot and has_layout then
    composed_plot(param)
  elseif has_plot then
    plot(param)
  elseif has_layout then
    param.layonly = true
    multi_layout(param)
    param.fpwrite(layout_only)
  end

  if self.epilog then file:write(self.epilog, "\n") end
  teardown_cmd(self, file, fname)
  return self
end

local plot = Command "plot" {

  -- stream id
  sid         = 1,

  -- user command
  prolog      = nil,     -- string
  epilog      = nil,     -- string

  -- windows setup
  term        = "wxt",
  wsizex      = 800,
  wsizey      = 500,

  -- output
  output      = 1,       -- ("filename") -> pdf | number -> wid
  scrdump     = nil,     -- ("filename")

  -- table or data input
  data        = nil,     -- { x=tbl.x, y=vec } (precedence over table)
  table       = nil,
  tablerange  = nil,     -- { min, max }

  -- sequence input
  sequence    = nil,
  range       = nil,     -- {"E.DS.L5.B1","S.DS.R5.B1"} or {122.2, 543} etc...
  seqdisty    = 0,       -- x >= 0 or { x1, x2, ... }
  seqdistx    = 0,       -- x >= 0 or { x1, x2, ... }
  seqshift    = 0,       -- x > =0
  seqlabel    = { "x", "z" },
  nturn       = 0,
  X0          = { 0, 0, 0 },
  A0          = { 0, 0, 0 },

  -- layout style
  laypos      = "top",   -- top | bottom | middle | in | 0 < x < 1
  laysize     = nil,     -- 0 < x < 1
  elemname    = true,
  elemwidth   = nil,     -- unsigned size of element before elemscale
  elemscale   = 1,       -- multiplier or default size
  elemminlen  = 0,       -- x > 0
  layangle    = true,
  kindselect  = nil,     -- { "quadrupole", "sbend" }
  kindcolor   = true,    -- { "quadrupole" = "blue",
                         --   "sbend" = {fillcolor="blue", fillstyle="solid"}}
                         -- true -> use default

  -- axis selection (and names)
  x1y1        = nil,     -- e.g. x1y1 = { x1 = {"y1", "y2"}, x2 = {"y3", "y4"}}
  x1y2        = nil,     -- e.g. x1y1 = { x1 = {"y1", "y2"}}
  x2y1        = nil,     -- e.g. x1y1 = { x1 = "y1"}
  x2y2        = nil,     -- e.g. x1y1 = {"y1", "y2"}
                         -- e.g. x1y1 = "y1"
  -- labels
  title       = "${name} MAD ${version}, ${date}, ${time}",
  legend      = nil,     -- { y = "distance" }
  xlabel      = nil,     -- strings
  x2label     = nil,
  ylabel      = nil,
  y2label     = nil,

  -- axis ranges
  xrange      = nil,     -- { min, max }
  x2range     = nil,
  yrange      = nil,
  y2range     = nil,

  -- plot command configuration
  plotcfg     = nil,     -- string
  plotvar     = nil,
  plotcmd     = nil,     -- string

  -- plot style
  originx     = nil,     -- 0 < x < 1
  originy     = nil,     -- 0 < x < 1
  psizex      = nil,     -- 0 < x < 1
  psizey      = nil,     -- 0 < x < 1

  -- data style
  datastyles  = {},      -- { y = { style = "lines", color = "blue"} }
  styles      = "lines", -- { y = "lines" }
  colors      = "red",   -- { y = "green" }
  dashtypes   = "solid", -- { y = "..-- " }
  linewidths  = 1,       -- { y = 2.3     }
  pointtypes  = 1,       -- { y = 2       }
  pointsizes  = 1,       -- { y = 2.3     }

  -- decoration
  font        = "Times New Roman",
  fontsize    = 14,
  titlefont   = nil,
  titlesize   = nil,
  legendfont  = nil,
  legendsize  = nil,
  legendpos   = "left top",
  grid        = "",
  border      = 15,

  -- object shift
  oshft       = 1000000,

  -- build the command (do not execute)
  exec        = exec,
} :set_readonly()

-- end ------------------------------------------------------------------------o

return {
  plot  = plot,
  gplot = gplot
}