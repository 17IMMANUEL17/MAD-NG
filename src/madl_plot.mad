--[=[
 o-----------------------------------------------------------------------------o
 |
 | Plot module
 |
 | Methodical Accelerator Design - Copyright CERN 2015+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 |          A.Z. Teska, aleksandra.teska at cern.ch
 |          A. Bloch, aurelien.bloch at cern.ch
 | Contrib: F.R. Leiro
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provides plotting

 o-----------------------------------------------------------------------------o
]=]

local dat = require 'madl_plotdat'
local is_nil, is_number, is_table, is_mtable, is_string,
  is_sequence, is_rawtable                                    in MAD.typeid
local Command, fun, vector, survey                            in MAD
local strinterp, fileexists                                   in MAD.utility
local sign, tan, min, max, abs, sqrt, inf, pi                 in MAD.gmath
local lshift in MAD.operator

-- Utility --------------------------------------------------------------------o

local ffi = require("ffi")

ffi.cdef[[
void Sleep(int ms);
int poll(struct pollfd *fds, unsigned long nfds, int timeout);
]]

local sleep
if ffi.os == "Windows"
then sleep = \s -> ffi.C.Sleep(s)
else sleep = \s -> ffi.C.poll(nil, 0, s)
end

local function lock_file (fname, time, timeout)
  local waited = 0
  local lock   = fname .. ".lock"
  while fileexists(lock) do
    sleep(time)
    waited = waited + time
    if timeout and waited > timeout then
      os.remove(lock)
      error("lock file \"" .. lock .. "\" prevent us from proceeding")
    end
  end
  io.open(lock, "w"):close()
end

local unlock_file = \fname -> os.remove(fname .. ".lock")

MAD.utility.sleep       = sleep
MAD.utility.lock_file   = lock_file
MAD.utility.unlock_file = unlock_file

-- global default -------------------------------------------------------------o

local _dflt = {
  color        = 'red',
  style        = 'linespoints',
  dashtype     = 'solid',
  linewidth    = 1,
  pointsize    = 1,
  pointtype    = 1,
  filename     = "plot.pdf",
  scrdump      = "plot.gp",
  originx      = 0,
  originy      = 0,
  psizex       = 1,
  psizey       = 1,
  laysize      = 0.15,
  multisize    = 0.05,
  elemwidth    = 0.07,
  elemwidth_in = 1,
  padding      = 0.025,
  middle       = 0.5,
  layonly      = 1,
}

-- GC -------------------------------------------------------------------------o
-- Use Garbage collector trick to properly remove temporary files
local gcf = {}

local plotgc = ffi.gc(ffi.new("int*"), \ =>
    for i=1,#gcf do
      os.remove(gcf[i])
    end
  end
)

local function gc_file (fname, lock)
  table.insert(gcf, fname)
  if lock then table.insert(gcf, fname .. ".lock") end
  return fname
end

-- gplot ----------------------------------------------------------------------o

local _gpd, _tmpf = {}, {}

local function gp_create (gplot, id)
  local gnuplot = assert(io.popen('gnuplot', 'w'))
  gnuplot:setvbuf("line")
  gplot[_gpd ][id] = gnuplot
  gplot[_tmpf][id] = gc_file(os.tmpname(), true)
  return gnuplot
end

local function gp_isBusy (gplot, id)
  return fileexists(gplot[_tmpf][id] .. ".lock")
end

local function gp_get (gplot, id, curr_)
  local dat = gplot[_gpd]
  if is_nil( dat[id] )              then gp_create( gplot, id ) end
  if id ~= '__cur_id' and not curr_ then dat.__cur_id = id      end
  return dat[id]
end

local function gp_getlock (gplot, id)
  local gnuplot = gp_get(gplot, id, true)
  local file    = gplot[_tmpf][id]
  return gnuplot, file
end

local function gp_call (gplot, id, ...)
  local gnuplot
  if is_number(id) then
    gnuplot = gp_get(gplot, id)
    gnuplot:write(..., "\n")
  else
    gnuplot = gp_get(gplot, gplot.__cur_id)
    gnuplot:write(id, ..., "\n")
  end
end

local gplot = {
  is_busy = gp_isBusy,
  [{}]    = plotgc,
  [_tmpf] = { },
  [_gpd]  = { __cur_id = 1 },
}

setmetatable(gplot, {
  __index = gp_get,
  __call  = gp_call,
})

-- initialization -------------------------------------------------------------o

local init_cmd = [[
#== initialization =============================================================
if (!(exist("MAD_MIN") && exist("MAD_MAX"))) {
  MAD_MIN = $oshft;
  MAD_MAX = -1;
}
MAD_RESET_OBJECT = "unset for [i=MAD_MIN:MAD_MAX] object i"
MAD_RESET_LABEL  = "unset for [i=MAD_MIN:MAD_MAX] label i"
if (!(exist("MAD_OLD_TERM") && exist("MAD_NEW_TERM"))) {
  MAD_OLD_TERM = "";
  MAD_NEW_TERM = "";
}
MAD_SET_TERM = "if (!(MAD_OLD_TERM eq MAD_NEW_TERM)) { \
  @MAD_NEW_TERM; \
  MAD_OLD_TERM = MAD_NEW_TERM; \
}"
#===============================================================================

]]

-- open files and gnuplot and set terminal when necessary
local function setup_cmd (self)
  local output, scrdump in self
  local gp, streamf = output and gp_getlock(gplot, self.sid)
                              or nil, gc_file(os.tmpname(), true)
  local file, fname

  if scrdump then
    fname = is_string(scrdump) and scrdump or _dflt.scrdump
    lock_file(fname, 100)
    gc_file(fname .. ".lock")
  else
    fname = streamf
  end
  lock_file(streamf, 100)
  file = io.open(fname, "w")

  file:write(init_cmd % self)

  if is_number(output) then
    file:write("MAD_NEW_TERM = \"set term $term $output size $wsizex,$wsizey \z
      enhanced font '$font,$fontsize'\"\n" % self)
  elseif output then
    local filename = is_string(output) and output or _dflt.filename
    file:write("MAD_NEW_TERM = \"set term pdfcairo; set out '"
      .. filename .. "'\"\n")
  end

  file:write("@MAD_SET_TERM\n")

  return gp, file, streamf, fname
end

local function gnuplot_rm(gp, fname)
  if jit.os == "Windows"
  then gp:write("system 'del "  ..fname.." >nul 2>&1'\n")
  else gp:write("system '\\rm -f "..fname.."'\n")
  end
end

local function teardown_cmd (self, gp, file, streamf, fname)
  file:close()
  if self.output then
    gp:write("load('" .. fname .. "')\n")
    if self.scrdump then gnuplot_rm(gp, fname .. ".lock") end
    gnuplot_rm(gp, streamf)
    gnuplot_rm(gp, streamf .. ".lock")
    gp:flush()
  else
    if self.scrdump then os.remove(fname .. ".lock") end
    os.remove(streamf)
    os.remove(streamf .. ".lock")
  end
end

-- layout ---------------------------------------------------------------------o

-- element flag for layout
local flayangle = MAD.element.flags.layangle
local flayout   = MAD.element.flags.layout
local flays     = lshift(1, flayangle) + lshift(1, flayout)

--  adjust "out of plot" layout coordinate
local xadjust    = \xs,ys,base,l -> xs*l + base
local yadjust    = \size  -> \xs,ys,base -> size*ys + base
--  adjust "in plot" layout coordinate
local xadjust_in = \size  -> \xs,ys,base -> xs*base[1] + size*ys*base[2] + base[3]
local yadjust_in = \size  -> \xs,ys,base -> xs*base[1] + size*ys*base[2] + base[3]

-- return the shape of an element in x and y
local function eShap (elem, dir)
  local shape = dat[elem.kind]
  local el, dash, sh = shape.ellipse, shape.dashtype, shape.shape

  sh = sh and elem.l == 0 and elem.kind ~= "marker" and dat.default.shape or sh
  -- if only a ellipse
  if not is_table(sh) then return el, dash end

  local ysym, yscl, func = shape.ysym, (shape.yscl or 1), nil
  local yshft = shape.yshft and sign(elem[shape.yshft]) or 0
  if is_number(ysym) then -- for symmetric shapes
    func = {
      \y -> ((   y + yshft)*yscl),
      \y -> ((-1*y + yshft)*yscl),
    }
  else
    local fv = sign(elem[ysym] or 1)
    ysym = (ysym == "angle") and fv*dir or fv
    func = {\y -> ((ysym*y + yshft)*yscl) }
  end
  return el, dash, sh.x, sh.y, func
end

-- stream polygon data
local function layout_poly (param, len, xorig, yorig, x_sh, y_sh, dash, func)
  local fpwrite, xadjust, yadjust, ref in param
  for i=1,#func do
    for j=1,#x_sh do
      local xj, yj = x_sh[j], y_sh[j]
      local dashtype = dash and "dashtype '" .. dash .. "'" or ""
      fpwrite("set object %d polygon front fc rgb 'white' fs solid 1.0 \z
        border rgb 'black' %s \\\n", param.oid, dashtype)
      local cmd = "from"

      for k=1,#xj do
        local xk, yk = xj[k], func[i](yj[k])
        xk, yk = xadjust(xk, yk, xorig, len), yadjust(xk, yk, yorig)
        local next = (k == #xj) and "" or "\\"
        fpwrite("  %s %f, %s %f %s\n", cmd, xk, ref, yk, next)
        cmd = "to"
      end
      param.oid = param.oid + 1
    end
  end
  fpwrite("\n")
end

-- stream ellipse data
local function layout_ellipse (param, len, el, xorig, yorig, dash, size)
  local fpwrite, xadjust, yadjust, ref in param
  local cx, cy = xadjust(0, 0, xorig, len), yadjust(0, 0, yorig)
  local sx, sy = len, el*size
  local dashtype = dash or ""
  fpwrite("set object %d ellipse front at %f, %s %f \\\n\z
    size %f, %s %f front fc rgb 'white' fs solid 1.0 border rgb 'black' %s \n",
    param.oid, cx, ref, cy, sx, ref, sy, dashtype)
  param.oid = param.oid + 1
end

-- stream element label data
local function layout_label(param, name, kind, xorig, yorig)
  local fpwrite, oid, ref, xadjust, yadjust in param
  local x, y = xadjust(0, 0, xorig, 1), yadjust(0, 0, yorig)
  label = name .. " [" .. kind .. "]"
  fpwrite("set label %d back at %f, %s %f '%s' hypertext \z
    point pt 4 ps 1 lc 'white'\n", oid, x, ref, y, label)
end

-- stream beam line data
local function layout_bline (param, bline)
  local fpwrite, ref in param
  local prevX, prevY = bline.x[1], bline.y[1]
  for i=2,#bline.y do
    local xi, yi = bline.x[i], bline.y[i]
    fpwrite("set object %d polygon front dashtype solid \\\n\z
      from first %f, %s %f to first %f, %s %f to first %f, %s %f\n",
      param.oid, prevX, ref, prevY, xi, ref, yi, prevX, ref, prevY)
    param.oid = param.oid + 1
    prevX, prevY = xi, yi
  end
end

-- process data for "out of plot" layout
local function layout_process(param, pseq)
  local seqshift, nturn, layangle in param
  local range, seq, disty, distx  in pseq
  local size    = nturn*seq:length_of(range)
  local xs, ys  = table.new(size, 0), table.new(size, 0)
  local bline   = { x = { }, y={ } }
  local deltaY  = disty
  local prevs_sh, angle, j, dir = 0, 0, 1, seq.direction
  for i, elem, s in seq:iter(range, nturn) do
    local s_sh   = s + elem.l/2
    deltaY       = deltaY - tan(dir*angle)*(s_sh-prevs_sh)
    xs[j], ys[j] = s_sh + distx + seqshift, deltaY
    prevs_sh     = s_sh
    pseq.xmin, pseq.xmax = min(pseq.xmin, xs[j]), max(pseq.xmax, xs[j])
    pseq.ymin, pseq.ymax = min(pseq.ymin, ys[j]), max(pseq.ymax, ys[j])
    if elem:is_selected(flayangle) and layangle then
      angle = angle + elem.angle
      table.insert(bline.x, xs[j]); table.insert(bline.y, ys[j])
    end
    j = j + 1
  end
  table.insert(bline.x, xs[#xs]); table.insert(bline.x, 1, xs[1])
  table.insert(bline.y, ys[#ys]); table.insert(bline.y, 1, ys[1])
  pseq.xs, pseq.ys, pseq.bline = xs, ys, bline
end

-- process data "in plot" layout (see help for formulas)
local function layout_process_in(param, pseq)
  local seqlabel, nturn, A0, X0 in param
  local range, seq    in pseq
  local size       = nturn*seq:length_of(range)
  local xs, ys     = table.new(size, 0), table.new(size, 0)
  local bline      = { x = table.new(size, 0), y = table.new(size, 0) }
  local srv        = survey { sequence = seq, range = range, A0=A0, X0=X0 }
  local idx, j     = 0, 1
  local labx, laby = seqlabel[1], seqlabel[2]

  for i, elem in seq:iter(range, nturn) do
    local line_idx = srv:index_of(elem.name, idx)
    if is_table(line_idx) then line_idx = line_idx[1] end
    idx = line_idx
    local line     = srv:get_row(line_idx)
    local prevLine, x1, y1, xas, yas, xbs, ybs

    repeat
      prevLine = (line_idx~=1) and srv:get_row(line_idx-1) or { x=0, y=0, z=0 }
      x1, y1   = prevLine[labx], prevLine[laby]
      x2, y2   = line[labx], line[laby]
      xas, yas = 0.5*(x2 - x1), 0.5*(y2 - y1)
      line_idx = line_idx - 1
    until xas ~= 0 or yas ~= 0 or line_idx <= 1

    if xas == 0 and yas == 0 then
      xbs, ybs   = 0, 1
    else
      local xx, yy = (x1 - x2), (y2 - y1)
      local sqrt_  = 1 / sqrt( yy^2 + xx^2 )
      xbs, ybs = yy*sqrt_, xx*sqrt_
    end

    if elem.l == 0
    then xshft, yshft = x2, y2
    else xshft, yshft = x1 + xas, y1 + yas
    end

    xs[j], ys[j]         = {xas, xbs, xshft}, {yas, ybs, yshft}
    pseq.xmin, pseq.xmax = min(pseq.xmin, xshft), max(pseq.xmax, xshft)
    pseq.ymin, pseq.ymax = min(pseq.ymin, yshft), max(pseq.ymax, yshft)
    table.insert(bline.x, xshft); table.insert(bline.y, yshft)
    j = j + 1
  end
  pseq.xs, pseq.ys, pseq.bline = xs, ys, bline
end

-- stream a signle layout
local function layout (param, pseq)
  local elemminlen, elemkind, elemwidth, elemname, nturn in param
  local seq, range, xs, ys, bline                in pseq
  local dir, j  = seq.direction, 1

  layout_bline(param, bline)
  for i, elem, s in seq:iter(range, nturn) do
    local len, kind    = elem.l, elem.kind
    local is_flagged   = elem:test_flags(flays)
    local is_vkind     = not elemkind or elemkind[kind]
    local xorig, yorig = xs[j], ys[j]

    if is_flagged or (len >= elemminlen and is_vkind) then
      local sh_l = len / 2
      local el, dash, x_sh, y_sh, func  = eShap(elem, dir)

      if elemname  then layout_label(param, elem.name, kind, xorig, yorig) end

      if not is_nil(el) and len ~= 0 then
        layout_ellipse(param, len, el, xorig, yorig, dash, elemwidth)
      end

      if not is_nil(x_sh) then
        layout_poly(param, sh_l, xorig, yorig, x_sh, y_sh, dash, func)
      end
    end
    j = j + 1
  end
end

-- compute bounding box and scale data accordingly
-- post processing for "out of plot" layout
local function layout_post(param, pseqs, ymin, ymax)
  local sequence, laypos, layonly, elemwidth, elemscale in param
  param.laysize  = param.laysize
    or (layonly and _dflt.layonly)
    or (is_rawtable(sequence) and _dflt.laysize + _dflt.multisize*#sequence)
    or _dflt.laysize
  elemwidth     = (elemwidth or _dflt.elemwidth) * elemscale
  local pad     = _dflt.padding
  local ybbox   = abs(ymax - ymin) + 2*elemwidth + 2*pad
  local yfactor = param.laysize / ybbox
  elemwidth     = elemwidth * yfactor
  if laypos == "top"    then laypos =1-(ymax*yfactor + elemwidth + pad) end
  if laypos == "bottom" then laypos =  -ymin*yfactor + elemwidth + pad  end
  if laypos == "middle" then laypos = _dflt.middle end
  param.elemwidth = elemwidth

  for i=1,#pseqs do
    local pseq = pseqs[i]
    local ys, bline in pseq
    pseq.ys      = fun.map(\y -> y*yfactor + laypos, ys):totable()
    pseq.bline.y = fun.map(\y -> y*yfactor + laypos, bline.y):totable()
  end
end

-- post processing for "in plot" layout
local function layout_post_in(param, ymin, ymax)
  local elemwidth, elemscale in param
  elemwidth       = elemwidth or (abs(ymax - ymin) * _dflt.elemwidth_in / 100)
  param.elemwidth = elemwidth * elemscale
end

-- main layout function
local function multi_layout (param)
  local sequence, fpwrite, range, seqdistx, seqdisty,
    elemwidth, elemscale, laypos, xrange                  in param
  local is_in = (laypos == "in")
  param.ref = is_in and "" or "screen"
  local xmin, xmax, ymin, ymax = inf, -inf, inf, -inf
  local pseqs = { }
  local seqs = is_rawtable(sequence) and sequence or
               is_sequence(sequence) and {sequence} or
               error("Invalid sequence input")

  for i=1,#seqs do
    local distx = (i~=1) and (is_table(seqdistx) and seqdistx[i-1] or seqdistx) or 0
    local disty = (i~=1) and (is_table(seqdisty) and seqdisty[i-1] or seqdisty) or 0
    local rg    = (#seqs > 1) and is_table(range) and range[i] or range or nil
    local pseq  = {
      xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax,
      seq = seqs[i], distx = distx, disty = disty, range=rg
    }
    if is_in
    then layout_process_in(param, pseq)
    else layout_process(param, pseq)
    end
    xmin, xmax = min(xmin, pseq.xmin), max(xmax, pseq.xmax)
    ymin, ymax = min(ymin, pseq.ymin), max(ymax, pseq.ymax)
    pseqs[i]   = pseq
  end

  if is_in
  then layout_post_in(param, ymin, ymax)
  else layout_post(param, pseqs, ymin, ymax)
  end
  param.xadjust = is_in and xadjust_in(param.elemwidth) or xadjust
  param.yadjust = is_in and yadjust_in(param.elemwidth) or yadjust(param.elemwidth)

  for i=1,#pseqs do
    local pseq = pseqs[i]
    layout(param, pseq)
  end

  fpwrite("MAD_MAX = %f\n", param.oid)
  xmin, xmax = xmin - param.elemwidth, xmax + param.elemwidth
  ymin, ymax = ymin - param.elemwidth, ymax + param.elemwidth
  if not xrange           then fpwrite("set xrange [%s:%s]\n", xmin, xmax) end
  if not yrange and is_in then fpwrite("set yrange [%s:%s]\n", ymin, ymax) end
end

-- plot -----------------------------------------------------------------------o

-- get vector from label
local function getv (data, tbl, label)
  if label then
    if data and data[label] then
      return data[label]
    elseif tbl[label] then
      return tbl[label], true
    else
      error("invalid label")
    end
  end
end

-- parse input axis and apply func to each label
local function parse_axis (param, func)
  local _axis = {'x1y1', 'x1y2', 'x2y1', 'x2y2'}
  for _,axis_name in ipairs(_axis) do
    local axis = param[axis_name]
    if is_string(axis) then                  -- e.g. x1y1 = 'y1'
      func(param, nil, axis, axis_name)
    elseif is_table(axis) and axis[1] then   -- e.g. x1y1 = {'y1', 'y2'}
      for i,y in ipairs(axis) do
        func(param, nil, y, axis_name)
      end
    elseif is_table(axis) then
      for x,y in pairs(axis) do
        if is_string(y) then                 -- e.g. x1y1 = { x1 = 'y1' }
          func(param, x, y, axis_name)
        elseif is_table(y) then              -- e.g. x1y1 = { x1 = {'y1', 'y2'}}
          for _,yi in pairs(y) do
            func(param, x, yi, axis_name)
          end
        end
      end
    end
  end
end

-- stream one plot data (used in parse_axis)
local function plot_data (param, xlbl, ylbl)
  local pwrite, tablerange, data, table in param
  local x, tblx = getv(data, table, xlbl)
  local y, tbly = getv(data, table, ylbl)
  local ix      = tblx and tablerange and tablerange[1] or 1
  local iy      = tbly and tablerange and tablerange[1] or 1
  local len

  if (tblx or tbly) and tablerange
  then len = tablerange[2] - tablerange[1] + 1
  else len = #y
  end

  assert(ix + len - 1 <= #x , "Invalid data size or tablerange")
  assert(iy + len - 1 <= #y , "Invalid data size or tablerange")
  for i=1,len do
    -- use index if xlbl not specified
    local xi = x and x[ix] or i
    pwrite(xi, " ", y[iy], "\n")
    ix, iy = ix + 1, iy + 1
  end
  pwrite("e\n")
end

-- parse dashtypes and add '' if it is a pattern : e.g.: ".-- "
local function parse_dash (dashtypes, y)
  local dash = is_table(dashtypes) and
    (dashtypes[y] or _dflt.dashtype) or dashtypes
  if string.match(dash, "[.%-_ ]+") then return "'" .. dash .. "'" end
  return dash
end

-- stream the gnuplot 'plot' command (used in parse_axis)
local function plot_cmd (param, _, y, axis)
  local pwrite, colors, styles, dashtypes, pointsizes,
    pointtypes, linewidths, legendnames in param
  local values = {
    color     = is_table(colors) and (colors[y] or _dflt.color) or colors,
    style     = is_table(styles) and (styles[y] or _dflt.style) or styles,
    dashtype  = parse_dash(dashtypes, y),
    pointsize = is_table(pointsizes)  and (pointsizes[y] or _dflt.pointsize) or pointsizes,
    pointtype = is_table(pointtypes)  and (pointtypes[y] or _dflt.pointtype) or pointtypes,
    linewidth = is_table(linewidths)  and (linewidths[y] or _dflt.linewidth) or linewidths,
    title     = is_table(legendnames) and legendnames[y] or y,
    axis      = axis,
  }
  local cmd = "$cmd using 1:2 with $style "
  if string.match(values.style, "lines") then
    cmd = cmd .. "dashtype $dashtype linewidth $linewidth "
  end
  if string.match(values.style, "points") then
    cmd = cmd .. "pointsize $pointsize pointtype $pointtype "
  end
  cmd = cmd .. "linecolor '$color' title '$title' axes $axis,\\\n"
  cmd = strinterp(cmd, values, false) % param
  param.cmd = "     '' "               -- only the first command need "plot '-'"
  pwrite(cmd)
end

-- set the range command for all axis
local function set_ranges (param)
  local fpwrite in param
  local names = {'xrange', 'x2range', 'yrange', 'y2range'}
  for _,rname in ipairs(names) do
    local range = param[rname]
    if range then fpwrite("set %s [%f:%f]\n", rname, range[1], range[2]) end
  end
end

-- set label command for each axis
local function set_label (param)
  local fpwrite in param
  local names = {'xlabel', 'x2label', 'ylabel', 'y2label'}
  for _,lname in ipairs(names) do
    local label = param[lname]
    if label then fpwrite("set %s '%s'\n", lname, label) end
  end
end

-- set tics for each used axis
local function set_tics (param)
  local x2y1, x2y2, x1y2, x2y2, pwrite in param
  if x2y1 or x2y2 then pwrite("set xtics nomirror \nset x2tics nomirror \n") end
  if x1y2 or x2y2 then pwrite("set ytics nomirror \nset y2tics nomirror \n") end
end

-- set remaining parameters (miscellaneous)
local function set_misc (param)
  local psizex, psizey, originx, originy, grid, border,
    title, legendpos, plotter                             in param
  local wrt = \s,... => plotter:write(string.format(s,...) % param) end
  if grid   then wrt("set %s\n", grid)          end
  if border then wrt("set border %s\n", border) end
  if title  then
    local font = param.titlefont or ""
    local size = param.titlesize or ""
    wrt("set title '%s' font '%s,%s'\n", title, font, size)
  end
  if legendpos then
    local font = param.legendfont or ""
    local size = param.legendsize or ""
    local cmd  = "set key %s font '%s,%s'\n"
    wrt(cmd, legendpos, font, size)
  end
  if psizey or psizex then
    psizex, psizey = psizex or _dflt.psizex, psizey or _dflt.psizey
    wrt("set size %f, %f\n", psizex, psizey)
  end
  if originy or originx then
    originx, originy = originx or _dflt.originx, originy or _dflt.originy
    wrt("set origin %f, %f\n", originx, originy)
  end
end

-- main plot function
local function plot (param)
  set_ranges(param)
  set_label(param)
  set_tics(param)
  set_misc(param)
  param.cmd = "plot '-'" -- first plot command initialization
  parse_axis(param, plot_cmd)
  param.pwrite("\n")
  parse_axis(param, plot_data)
end

-- command --------------------------------------------------------------------o

-- create a graph with both the layout and the plot part
local function composed_plot (param)
  local laypos, psizey, originy in param

  multi_layout(param)

  local laysize in param
  if laypos == "top" or laypos == "bottom" then
    param.psizey = psizey or _dflt.psizey - laysize
  end
  param.originy = originy or laypos == "bottom" and laysize
                          or _dflt.originy
  plot(param)
end

-- initialize the table of parameters
local function init_param(self, file)
  local param = {
    version = tostring(MAD.env.version),
    name    = self.name or is_table(self.table) and self.table.title or "",
    date    = self.date or is_table(self.table) and self.table.date  or "",
    time    = self.time or is_table(self.table) and self.table.time  or "",
    plotter = file,
    oid     = self.oshft,
    fpwrite = \... -> file:write(string.format(...)),
    pwrite  = \... -> file:write(...)
  }
  if self.elemkind then -- build dictionary
    param.elemkind = {}
    fun.foreach(\e => param.elemkind[e] = true end, self.elemkind)
  end

  setmetatable(param, {__index=self})
  return param
end

local layout_only = [[
unset key
unset tics
unset border
plot x lc 'white'
]]

local function exec (self)
  local gp, file, streamf, fname = setup_cmd(self)

  if self.sequence ~= "keep" then
    file:write("@MAD_RESET_OBJECT\n")
    file:write("@MAD_RESET_LABEL\n")
  elseif self.range then
    print("MAD Plot Warning : sequence=\"keep\" and range is \z
      provided - range is ignored")
  end

  if self.prolog then file:write(self.prolog, "\n") end
  local param = init_param(self, file)

  local has_plot   = is_mtable(self.table) or is_table(self.data)
  local has_layout = is_rawtable(self.sequence) or is_sequence(self.sequence)
  if has_plot and has_layout then
    composed_plot(param)
  elseif has_plot then
    plot(param)
  elseif has_layout then
    param.layonly = true
    multi_layout(param)
    param.fpwrite(layout_only)
  end

  if self.epilog then file:write(self.epilog, "\n") end
  teardown_cmd(self, gp, file, streamf, fname)
  return self
end

local plot = Command 'plot' {

  -- stream id
  sid         = 1,

  -- user command
  prolog      = false,   -- string
  epilog      = false,   -- string

  -- windows setup
  term        = 'wxt',
  wsizex      = 800,
  wsizey      = 500,

  -- output
  output      = 1,       -- ("filename"|true) -> pdf | number -> wid
  scrdump     = false,   -- ("filename"|true)

  -- table or data input
  data        = false,   -- { x=tbl.x, y=vec } (precedence over table)
  table       = false,
  tablerange  = false,   -- { min, max }

  -- sequence input
  sequence    = false,
  range       = false,   -- {'E.DS.L5.B1','S.DS.R5.B1'} or {122.2, 543} etc...
  seqdisty    = 0,       -- x >= 0 or { x1, x2, ... }
  seqdistx    = 0,       -- x >= 0 or { x1, x2, ... }
  seqshift    = 0,       -- x > =0
  seqlabel    = { 'x', 'z' },
  nturn       = 0,
  X0          = { 0, 0, 0 },
  A0          = { 0, 0, 0 },

  -- layout style
  laypos      = "top",   -- top | bottom | middle | in | 0 < x < 1
  laysize     = false,   -- 0 < x < 1
  elemname    = true,
  elemwidth   = false,   -- unsigned size of element before elemscale
  elemscale   = 1,       -- multiplier or default size
  elemkind    = false,   -- { "quadrupole", "sbend" }
  elemminlen  = 0,       -- x > 0
  layangle    = true,

  -- axis selection (and names)
  x1y1        = false,   -- e.g. x1y1 = { x1 = {'y1', 'y2'}, x2 = {'y3', 'y4'}}
  x1y2        = false,   -- e.g. x1y1 = { x1 = {'y1', 'y2'}}
  x2y1        = false,   -- e.g. x1y1 = { x1 = 'y1'}
  x2y2        = false,   -- e.g. x1y1 = {'y1', 'y2'}
                         -- e.g. x1y1 = 'y1'
  -- axis labels
  xlabel      = false,   -- strings
  x2label     = false,
  ylabel      = false,
  y2label     = false,

  -- axis ranges
  xrange      = false,   -- { min, max }
  x2range     = false,
  yrange      = false,
  y2range     = false,

  -- plot style
  originx     = false,   -- 0 < x < 1
  originy     = false,   -- 0 < x < 1
  psizex      = false,   -- 0 < x < 1
  psizey      = false,   -- 0 < x < 1
  styles      = 'lines', -- { y = 'lines' }
  colors      = 'red',   -- { y = 'green' }
  dashtypes   = 'solid', -- { y = '..-- ' }
  linewidths  = 1,       -- { y = 2.3     }
  pointtypes  = 1,       -- { y = 2       }
  pointsizes  = 1,       -- { y = 2.3     }

  -- decoration
  font        = "Times New Roman",
  fontsize    = 14,
  title       = "$name MAD $version, $date, $time",
  titlefont   = false,
  titlesize   = false,
  legendnames = false,   -- { y = 'distance' }
  legendfont  = false,
  legendsize  = false,
  legendpos   = "left top",
  grid        = 'grid',
  border      = 15,

  -- object shift
  oshft       = 1000000,

  -- build the command (do not execute)
  exec        = exec,
} :set_readonly()

-- end ------------------------------------------------------------------------o

return {
  plot  = plot,
  gplot = gplot
}