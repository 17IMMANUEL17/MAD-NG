--[=[
 o-----------------------------------------------------------------------------o
 |
 | Plot module
 |
 | Methodical Accelerator Design - Copyright CERN 2015+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 |          A.Z. Teska, aleksandra.teska at cern.ch
 | Contrib: F.R. Leiro
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provides ploting

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local dat = require 'madl_plotdat'
local range, nrange, vector, element, totable, same                in MAD
local isa_matrix, is_range, is_table, is_number, is_string, is_nil in MAD.typeid
local min, max, abs, exp                                           in MAD.gmath
local pow                                                          in MAD.operator

-- implementation -------------------------------------------------------------o

local function copy(tbl)
  local out = {}
  for k,v in pairs(tbl) do out[k] = v end
  return out
end

local function keys_tbl(t1, t2, keys)
  local t = {}
  if   t1
  then for j,k in ipairs(keys) do t[k] = t1[k] or t2[k] end
  else for j,k in ipairs(keys) do t[k] = t2[k]          end
  end
  return t
end

local function tbl_concat(t, ...)
  local t = t or {}
  local n = select('#', ...)
  for i=1,n do
    local elem = select(i, ...)
    for j=1,#elem do table.insert(t, elem[j]) end
  end
  return t
end

local function find_key(inp, key)
  local indx
  for i,line in ipairs(inp) do if line:find(key) then indx = i end end
  return indx
end

--scalling
local function chksize(rng, start, stop)
  if rng:size() <= stop then start, stop = rng.start, rng.stop end
  return start, stop
end

local function scale_tbl(tbl, start, stop)
  local r = {}
  for j=1,stop-start do r[j] = tbl[start+j] end
  return r
end

local function scale_dat(src, keys, rng)
  local d_src = {}
  local start, stop = 1, #src[keys[1]]
  start, stop = chksize(rng, start, stop)
  for j,k in ipairs(keys) do
    if isa_matrix(src[k])
    then d_src[k] = src[k]:getv(start..stop )
    else d_src[k] = scale_tbl(src[k],start,stop)
    end
  end
  return d_src
end

local function scale_axis(src, keys, margin)
  if is_nil(keys[1]) then return 0,0 end
  local vmin, vmax = vector(#keys), vector(#keys)
  for i,key in ipairs(keys) do
    local min, max = src[key]:min(), src[key]:max()
    vmin:seti(i, min)
    vmax:seti(i, max)
  end
  local min, max, x = vmin:min(), vmax:max()
  if margin then
    if is_number(margin)
    then x = margin
    else x = 0.1
    end
    local marg = x*(max-min)
    if marg == 0 then marg = x end
    return min-marg, max+marg
  end
  return min, max
end

local function scale_rng(src, rng)
  if     is_range(rng) then return rng
  elseif is_table(rng) then
    local  start,  stop = 1     , #src
    local rstart, rstop = rng[1], rng[2]
    local vmin, vmax, c = {}, {}
    c=1; src:mapij(\x,i,j => if x>=rstart then vmin[c]=i; c=c+1 end end, {})
    c=1; src:mapij(\x,i,j => if x> rstop  then vmax[c]=i; c=c+1 end end, {})
    start = vmin[1]
    if vmax[1]       then stop = vmax[1]-1 end                                  -- add WARNING(bigger then data)
    if rng [2] == -1 then stop = #src      end
    return start..stop
  end
end

--layout
local xadjst = \x,l,s -> x*l + s-l
local yadjst = \y,h   -> y*h
local hadjst = \y,h   -> y*(1-exp(-0.2*( pow(abs(h), 1/4)) ))

local function delta(refer, l)
  local d
  if     refer == 'exit'   then d = 0
  elseif refer == 'entry'  then d = l
  elseif refer == 'center' then d = l/2
  else                          d = 0
  end
  return d
end

local function sh_get(sh)
  local x_sh, y_sh = {}, {}
  if is_table(sh.x[1]) then
    for i=1,#sh.x do
      x_sh[i] = vector(sh.x[i])
      y_sh[i] = vector(sh.y[i])
    end
  else
    x_sh, y_sh = {vector(sh.x)}, {vector(sh.y)}
  end
  return x_sh, y_sh
end

local function layout(seq, range, refer)
  local xl, yl, c = {}, {}, 1
  local del = {}
  local flag, start = true
  for i,elem in seq:iter(range) do
    local s = seq:s_pos(i)
    local kind, l = elem.kind, elem.l
    if s and l then
      del[i] = delta(refer, l)
      if flag == true then start=i; flag=false  end
      s = s + del[start]
      local h,sh = elem[dat[kind].str_k] or 1
      if     dat[kind].shape then sh = dat[kind].shape
      elseif h > 0           then sh = dat[kind].shape_f
      else                        sh = dat[kind].shape_d
      end
      local x_sh, y_sh = sh_get(sh)
      for j=1,#x_sh do
        local x, y = x_sh[j], y_sh[j]
        xl[c] = x:map( \x xadjst(x+1, l, s) )
        yl[c] = y:map( \y yadjst(y, 1     ) )
        --if     h ~= 1 and h > 0 then yl[c] = hadjst(yl[c], h)
        --elseif h ~= 1           then yl[c] =-hadjst(yl[c], h)
        --end
        c = c+1
      end
    end
  end
  return { x=xl, y=yl }
end

-- plot options
local function axis_title(src)
  if src then
    local label = ""
    for _,key in pairs(src) do label = label..key.." " end
    return label
  end
end

local function mk_title(self)
  local table, title in self
  local src = {
    version = tostring(MAD.env.version),
    name    = self.name or is_table(table) and self.table.title or "",
    date    = self.date or is_table(table) and self.table.date  or "",
    time    = self.time or is_table(table) and self.table.time  or "",
  }
  return title % src
end

local function script_name(pdfname)
  if   pdfname then return string.match(pdfname, "(%w+)%.")..".gp"
  else              return "script.gp"                              end
end

local function interpol(str)
  local out
  if     str == 'lines'       then out = "with lines       dashtype  dtt"
  elseif str == 'linespoints' then out = "with linespoints pointtype ptt pointsize pts"
  elseif str == 'points'      then out = "with points      pointtype ptt pointsize pts"
  else                             out = str
  end
  return out
end

local function multi_axes(self, out, out2)
  local axes = {}
  local s, s2 = #out, #out2
  if out  then for i=1  ,s    do axes[i] = "x1y1" end end
  if out2 then for i=1+s,s+s2 do axes[i] = "x1y2" end end
  return axes
end

local function templ_style(inp, out, keys)
  local r = copy(out)
  if inp then
    for k,v in pairs(inp) do
      local indx = find_key(keys, k) - 1
      if indx then r[indx] = v end
    end
  end
  return r
end

-- saving to template
local function data_to_templ(src, keys)
  local s = src[keys[1]]
  local t = {"\n"}
  for i=2,#s+1 do
    for j,k in ipairs(keys) do
      if t[i] then t[i] = t[i]..src[k][i-1].." "
      else         t[i] =       src[k][i-1].." "
      end
    end
    t[i] = t[i].."\n"
  end
  t[#s+2] = "e\n"
  return t
end

local function layout_to_templ(src, keys)
  local s = src[keys[1]]
  local t = {"\n"}
  local c = 2
  for i=1,#s do
    for ii=1,#s[i] do
      for j,k in ipairs(keys) do
        if t[c]
        then t[c] = t[c]..src[k][i][ii].." "
        else t[c] =       src[k][i][ii].." "
        end
      end
      t[c] = t[c].."\n"; c=c+1
    end
    t[c] = "\n"; c=c+1
  end
  t[c] = "e\n"
  return t
end

-- template

local function templ_interp(temp, src)
  for i,line in ipairs(temp) do
    temp[i] = line % src      -- interpolate strings
  end
end

local function templ_fill(temp, inp, key)
  local c, n = 1
  for i,line in ipairs(temp) do
    temp[i], n = string.gsub( line, key, inp[c] )
    if n == 1 and c < #inp then c=c+1 end
  end
end

local function templ_print(temp, pipe)
  for i =1,#temp do pipe:write(temp[i]) end
end
local template = {
  "set multiplot \n"                 ,
  "set $grid \n"                     ,
  "set lmargin at screen $lmargin \n",
  "set rmargin at screen $rmargin \n",
  "set size 1,$sizeplot \n"          ,
  "set title '$title'  \n"           ,
}
local templ_end = {
  "set key $legendpos \n"            ,
  "set xlabel '$xlabel' \n"    ,
  "set ylabel '$ylabel' \n"    ,
  "set xrange [$xmin:$xmax] \n",
  "set yrange [$ymin:$ymax] \n",
}
local templ_plot     = { "plot " }
local templ_vaxis    = { "'-' using 1:count every 1::0 $plotstyle linecolor 'colors' title 'vkeys' axes setaxes,\\\n" }
local templ_preamble = { "#$preamble \n" }
local templ_unmult   = {"\nunset multiplot \n" }
local templ_window   = { "set terminal x11 $window font '$fontname, $fontsize'\n" }
local templ_tofile   = {
  "set terminal $terminaltype $window font '$fontname, $fontsize' enhanced color\n",
  "set output '|ps2pdf - $pdfname' \n",
}
local templ_unaxes = {
  "unset x2label \n"  ,
  "unset x2tics \n"   ,
  "unset y2tics \n"   ,
  "unset y2label \n"  ,
  "unset xzeroaxis \n",
}
local templ_multiv = {
  "set ytics nomirror \n"         ,
  "set y2tics \n"                 ,
  "set tics out \n"               ,
  "set y2label '$ylabel2' \n"     ,
  "set y2range [$ymin2:$ymax2] \n",
}
local templ_multih = {
  "set xtics nomirror \n"         ,
  "set x2tics \n"                 ,
  "set tics out \n"               ,
  "set x2label '$xlabel2' \n"     ,
  "set x2range [$xmin2:$xmax2] \n",
}
local templ_lay = {
  "unset tmargin \n"    ,
  "unset bmargin \n"    ,
  "unset title  \n"     ,
  "unset arrow \n"      ,
  "unset ylabel \n"     ,
  "unset xlabel \n"     ,
  "unset xtics \n"      ,
  "unset ytics \n"      ,
  "unset y2tics \n"     ,
  "unset y2label \n"    ,
  "unset key \n"        ,
  "set xzeroaxis \n"    ,
  "set border 0 \n"     ,
  "set size 1,0.15 \n"  ,
  "set origin 0,0.85 \n",
  "set yrange [-1:1] \n",
  "plot '-' u 1:2 w lines linestyle 1 linecolor rgb 'black' \n",
}
local templ_lay_off = {
  "set border \n"    ,
  "set origin 0,0 \n",
  "set xtics \n"     ,
  "set ytics \n"     ,
}

-- plotting command -----------------------------------------------------------o
local mtable, Command in MAD
local templ_save, pdfonefile = {}, {}

local gp = setmetatable({},{
  __index = \gp,id => gp[id] = io.popen("gnuplot", "w") ; return gp[id] end
})

local function templ_multiaxes(self, size)
  local templ = {}
  for i=1,size do templ = tbl_concat( templ, templ_vaxis ) end
  return templ
end

local function templ_operations(self, pdfonefile, templ_input, size)
  local pdfname, preamble, haxis, vaxis, vaxis2, haxis2, multiplot, window, multiplot in self
  local templ, templ_dat = {}
  if     pdfname and pdfname == pdfonefile then templ = tbl_concat( {}  ,                               template )
  elseif pdfname                           then templ = tbl_concat( {}  , templ_unmult  , templ_tofile, template )
  else                                          templ = tbl_concat( {}  , templ_unmult  , templ_window, template )
                                                templ_save = {}                                                       end
  if not window then window = "size 800, 500" end
  if     preamble               then templ = tbl_concat( {}   , templ_preamble, templ                               ) end
  if     vaxis2 and haxis2      then templ = tbl_concat( templ, templ_multih  , templ_multiv, templ_end, templ_plot )
  elseif vaxis2                 then templ = tbl_concat( templ, templ_multiv  ,               templ_end, templ_plot )
  elseif haxis2                 then templ = tbl_concat( templ, templ_multih  ,               templ_end, templ_plot )
  else                               templ = tbl_concat( templ,                               templ_end, templ_plot ) end
  if     multiplot              then templ = tbl_concat( {}, templ_plot )
                                     multiplot = false                                                                end
  for i = 1,size do templ_dat = tbl_concat( templ_dat, templ_input.data ) end
  templ = tbl_concat( templ, templ_input.multiaxes, templ_dat, templ_input.sequ )
  if not multiplot and vaxis2 or haxis2 then templ = tbl_concat( templ, templ_unaxes ) end

  return templ, templ_save
end

local function sequ(self)
  local sequence, range, refer in self
  local templ = {}
  assert(sequence.kind == 'sequence' and sequence.is_sequence == true, "invalid sequence")
  local lay     = layout         ( sequence, range, refer )
  local lay_dat = layout_to_templ( lay, {'x','y'}  )
  local min = lay.x[1]     :min()
  local max = lay.x[#lay.x]:max()
  self.datrange = {min, max}
  self.xmin = min
  self.xmax = max
  templ = tbl_concat( {}, templ_lay, lay_dat, templ_lay_off, templ_unmult )
  return templ
end

local function style_plots(self, out, keys, templ, axes)
  --local size = #self.vaxis + #self.vaxis2
  local dashtypes, colors in dat
  local ptt  = totable(1..(#out))
  local pts  = totable(vector(#out):fill(1))
  local yout = tbl_concat({}, out)
  local style  = {
    vkeys   = templ_style( self.vkeys     , yout     , keys ),
    colors  = templ_style( self.colors    , colors   , keys ),
    dtt     = templ_style( self.dashtypes , dashtypes, keys ),
    setaxes = templ_style( self.axes      , axes     , keys ),
    ptt     = templ_style( self.pointtypes, ptt      , keys ),
    pts     = templ_style( self.pointsizes, pts      , keys ),
    count   = 2..(#out)+1,
  }
  for k,v in pairs(style) do templ_fill( templ, v, k ) end
  return templ
end

local function creat_gpcopy(templ, name)
  local script = script_name(name)
  local fp = io.open(script, "w")
  templ_print( templ, fp )
  fp:close()
end

function exec(self)
  -- data scalling
  local inp = totable( self.haxis )
  local out = totable( self.vaxis )
  local inp2, out2
  if self.haxis2 then inp2 = totable( self.haxis2 ) else inp2 = {} end
  if self.vaxis2 then out2 = totable( self.vaxis2 ) else out2 = {} end
  local keys        = tbl_concat( {}, inp, inp2, out, out2 )
  local keysVectors = keys_tbl  ( self.table , self.data, keys )
  local datasize    = #keysVectors[inp[1]]
  self.datrange     = 1..datasize
  --self.datrange = self.datrange or 1..datasize
  local drng        = scale_rng( datasize   , self.datrange )
  local src         = scale_dat( keysVectors, keys, drng    )

  -- template operations
  local id in self
  local size = #out + #out2
  local templ_input = {
    data      = data_to_templ  ( src , keys )                   ,  -- data to plot
    multiaxes = templ_multiaxes( self, size )                   ,  -- multiple axes
    sequ      = self.sequence and sequ( self, self.refer ) or {},  -- sequence plot
  }
  local templ, templ_save = templ_operations( self, pdfonefile[id], templ_input, size )

  local hlimit  = { scale_axis( src, inp , self.hmargin ) }
  local vlimit  = { scale_axis( src, out , self.vmargin ) }
  local hlimit2 = { scale_axis( src, inp2, self.hmargin ) }
  local vlimit2 = { scale_axis( src, out2, self.vmargin ) }
  -- template interpolation
  local to_interpolate = {
    terminaltype = self.terminaltype,
    window    = self.window , -- merge with xsize, ysize -- self.window or "size $xsize, $ysize",
    xsize     = self.size.x ,
    ysize     = self.size.y ,
    pdfname   = self.pdfname,
    grid      = self.grid   ,
    lmargin   = self.margins.left ,
    rmargin   = self.margins.right,
    sizeplot  = self.sequence and 0.85 or 1,
    title     = mk_title(self),
    legendpos = self.legendpos,
    preamble  = self.preamble ,
    fontname  = self.font.name,
    fontsize  = self.font.size,
    -- x1y1 options
    xlabel = self.xlabel~="" and self.xlabel or axis_title(inp),
    ylabel = self.ylabel~="" and self.ylabel or axis_title(out),
    xmin   = self.xmin or hlimit[1],
    xmax   = self.xmax or hlimit[2],
    ymin   = self.ymin or vlimit[1],
    ymax   = self.ymax or vlimit[2],
    plotstyle = interpol(self.plotstyle),
    --x2y2 options
    ylabel2 = self.ylabel2~="" and self.ylabel2 or axis_title(inp2),
    xlabel2 = self.xlabel2~="" and self.xlabel2 or axis_title(out2),
    xmax2   = self.xmax2 or hlimit2[1],
    ymax2   = self.ymax2 or hlimit2[2],
    xmin2   = self.xmin2 or vlimit2[1],
    ymin2   = self.ymin2 or vlimit2[2],
  }
  templ_interp( templ, to_interpolate )
  local output = tbl_concat( out, out2 )
  local axes   = multi_axes( self, out, out2 )         -- multiple axes
  templ = style_plots(self, output, keys, templ, axes) -- style of plots
  -- pipe
  templ_print( templ, gp[id] )
  gp[id]:flush()
  -- save in same pdf
  local pdfname in self
  if pdfname == pdfonefile[id]
  then templ_save = tbl_concat(templ_save, templ)
  else templ_save = templ
  end
  if self.gpcopy then creat_gpcopy(templ_save, self.pdfname) end -- save .gp

  pdfonefile[id] = pdfname
  return self
end

local plot = Command 'plot' {
  -- gnuplot setup
  terminaltype = "postscript",
  font = {name = "Times-Roman", size = 18},
  legendpos = "left top",
  grid      = 'grid',
  window    = "", --"size $xsize, $ysize",
  size      = {x = 20, y =10.5},
  datrange  = false, --1..100,
  margins   = {left = 0.1, right = 0.9},
  id        = 1,
  multiplot = false,
  -- input
  table    = false,
  data     = false,
  sequence = false,
  haxis    = 'x',
  haxis2   = false,
  vaxis    = 'y',
  vaxis2   = false,
  vaxis3   = false,
  vaxis4   = false,
  -- seq input
  refer    = 'exit',
  range    = {1,-1},
  -- saving to file
  pdfname  = false,
  gpcopy   = false,
  -- inp operations
  hmargin  = false,
  vmargin  = true ,
  -- x1y1 options
  xlabel  = "",
  ylabel  = "",
  xmin = false, xmax = false,
  ymin = false, ymax = false,
  -- x2y2 options
  xlabel2 = "",
  ylabel2 = "",
  ylabel3 = "",
  ylabel4 = "",
  xmin2 = false, xmax2 = false,
  ymin2 = false, ymax2 = false,
  -- plot style
  plotstyle = 'linespoints',
  axes       = false,
  colors     = false,
  pointtypes = false,
  pointsizes = false,
  dashtypes  = false,
  vkeys      = false,
  title      = "$name MAD $version, $date, $time",
  exec = exec,
} :set_readonly()

-- end ------------------------------------------------------------------------o
return {
  plot   = plot  ,
  __help = __help,
}