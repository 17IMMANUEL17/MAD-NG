--[=[
 o-----------------------------------------------------------------------------o
 |
 | Plot module
 |
 | Methodical Accelerator Design - Copyright CERN 2015+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 |          A.Z. Teska, aleksandra.teska at cern.ch
 |          A. Bloch, aurelien.bloch at cern.ch
 | Contrib: F.R. Leiro
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provides plotting

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local ffi = require 'ffi'
local dat = require 'madl_plotdat'

local Command, fun, vector, survey, filesys                      in MAD
local sign, tan, min, max, abs, sqrt, inf, pi                    in MAD.gmath
local lshift                                                     in MAD.operator
local strinterp, setkeys, strsplitall, atexit, runonce,
      fileexists                                                 in MAD.utility
local is_nil, is_number, is_table, is_mtable, is_string,
      is_sequence, is_rawtable                                   in MAD.typeid

-- Utility --------------------------------------------------------------------o

ffi.cdef[[
void Sleep(int ms);
int poll(struct pollfd *fds, unsigned long nfds, int timeout);
int getpid(void);
int GetCurrentProcessId(void);
]]

local sleep, pid
if ffi.os == "Windows" then
  sleep = \s -> ffi.C.Sleep(s)
  pid   = ffi.C.GetCurrentProcessId()
else
  sleep = \s -> ffi.C.poll(nil, 0, s)
  pid   = ffi.C.getpid()
end

MAD.utility.pid   = pid
MAD.utility.sleep = sleep

-- global default -------------------------------------------------------------o

local _dflt = {
  color        = 'red',
  style        = 'linespoints',
  dashtype     = 'solid',
  linewidth    = 1,
  pointsize    = 1,
  pointtype    = 1,
  originx      = 0,
  originy      = 0,
  psizex       = 1,
  psizey       = 1,
  laysize      = 0.15,
  multisize    = 0.05,
  elemwidth    = 0.07,
  elemwidth_in = 1,
  padding      = 0.025,
  middle       = 0.5,
  layonly      = 1,
}

local tmpfolder = "TMP_MAD_PLOT/"
local tmplock   = tmpfolder .. "madplot.lock"

-- gplot ----------------------------------------------------------------------o

local _gpd = {}

local function gp_create (gplot, id)
  local gnuplot = assert(io.popen('gnuplot', 'w'))
  gnuplot:setvbuf("line")
  gplot[_gpd][id] = gnuplot
  return gnuplot
end

local function gp_isBusy (gplot, id)
  local _id = id or gplot[_gpd].__cur_id
  if not fileexists(tmpfolder) then return false end
  for name in filesys.dir(tmpfolder) do
    if string.find(name, "madplot%-%d+") then
      local file = io.open(tmpfolder .. name, "r")
      if file then
        local line = file:read("*line")
        if line and tonumber(strsplitall(line, "#", 2)[1]) == pid then
          return true
        end
      end
    end
  end
  return false
end

local function gp_get (gplot, id, curr_)
  local dat = gplot[_gpd]
  if is_nil( dat[id] )              then gp_create( gplot, id ) end
  if id ~= '__cur_id' and not curr_ then dat.__cur_id = id      end
  return dat[id]
end

local function gp_call (gplot, id, ...)
  local gnuplot
  if is_number(id) then
    gnuplot = gp_get(gplot, id)
    gnuplot:write(..., "\n")
  else
    gnuplot = gp_get(gplot, gplot.__cur_id)
    gnuplot:write(id, ..., "\n")
  end
end

local gplot = {
  is_busy   = gp_isBusy,
  clean_tmp = clean_tmp,
  option    = { pending = 10 },
  [_gpd]    = { __cur_id = 1 },
}

setmetatable(gplot, {
  __index = gp_get,
  __call  = gp_call,
})

-- tmp files ------------------------------------------------------------------o

local function clean_tmp (strict_)
  if not fileexists(tmpfolder) then return end
  for name in filesys.dir(tmpfolder) do
    if strict_ then
      os.remove(tmpfolder .. name)
    elseif string.find(name, "madplot%-%d+") then
      local fname = tmpfolder .. name
      local file = io.open(fname, "r")
      if file then
        local line = file:read("*line")
        if line and tonumber(strsplitall(line, "#", 2)[1]) == pid then
          file:close()
          os.remove(fname)
        end
      end
    end
  end
  filesys.rmdir(tmpfolder)
end

local function block (handle, time)
  while not filesys.lock(handle, "w") do sleep(time) end
  return handle
end

local _filepool
local function setup_files()
  -- runonce(\ atexit(clean_tmp))           -- TODO check why segfault in finalizer
  if not fileexists(tmpfolder) then
    local status,msg = filesys.mkdir(tmpfolder)
    if not status and msg~="File exists" then
      error("couldn't create TMP_MAD_PLOT")
    end
  end
  entry = 1
  local tmpfile = tmpfolder .. "madplot-"
  for i=gplot.option.pending,1,-1 do
    local file = tmpfile .. i
    if not fileexists(file) then
      _filepool[entry] = file
      entry = entry + 1
    end
  end
end

local function get_tmpfile()
  if not is_rawtable(_filepool) then _filepool = {}; setup_files() end
  local lock = block(assert(io.open(tmplock, "w")), 100)
  local fname, warn = false, 0
  while true do
    fname = table.remove(_filepool)
    if fname and not fileexists(fname) then break end
    if warn == 1 then
      print("MAD Plot Warning : no available tmpfile (see documentation)")
    end
    filesys.unlock(lock); sleep(100); block(lock)
    setup_files()
    warn = warn + 1
  end
  local file = assert(io.open(fname, "w"))
  filesys.unlock(lock)
  return file, fname
end

-- initialization -------------------------------------------------------------o

local init_cmd = [[
#== initialization =============================================================
if (!(exist("MAD_MIN") && exist("MAD_MAX"))) {
  MAD_MIN = ${oshft};
  MAD_MAX = -1;
}
MAD_RESET_OBJECT = "unset for [i=MAD_MIN:MAD_MAX] object i"
MAD_RESET_LABEL  = "unset for [i=MAD_MIN:MAD_MAX] label i"
if (!(exist("MAD_OLD_TERM") && exist("MAD_NEW_TERM"))) {
  MAD_OLD_TERM = "";
  MAD_NEW_TERM = "";
}
MAD_SET_TERM = "if (!(MAD_OLD_TERM eq MAD_NEW_TERM)) { \
  @MAD_NEW_TERM; \
  MAD_OLD_TERM = MAD_NEW_TERM; \
}"
#===============================================================================

]]

-- open files and gnuplot and set terminal when necessary
local function setup_cmd (self)
  local output, scrdump in self
  local gp      = output and gp_get(gplot, self.sid, true)
  local file, fname = get_tmpfile()
  file:write("#", pid, "#", self.sid, "\n")
  file:write(init_cmd % self)

  if is_number(output) then
    file:write("MAD_NEW_TERM = \"set term ${term} ${output} size ${wsizex},${wsizey} \z
      enhanced font '${font},${fontsize}'\"\n" % self)
  elseif is_string(output) then
    file:write("MAD_NEW_TERM = \"set term pdfcairo; set out '"
      .. output .. "'\"\n")
  end

  file:write("@MAD_SET_TERM\n")
  return gp, file, fname
end

local function gnuplot_rm(gp, fname)
  if jit.os == "Windows"
  then gp:write("system 'del "    , fname, " >nul 2>&1'\n")
  else gp:write("system '\\rm -f ", fname, "'\n")
  end
end

local function gnuplot_mv(gp, fname, uname)
  if jit.os == "Windows"
  then gp:write("system 'move /Y ", fname, " ", uname, "'\n")
  else gp:write("system '\\mv "   , fname, " ", uname, "'\n")
  end
end

local function teardown_cmd (self, gp, file, fname)
  file:close()
  if self.output then
    gp:write("load('" .. fname .. "')\n")
    if is_string(self.scrdump)
    then gnuplot_mv(gp, fname, self.scrdump)
    else gnuplot_rm(gp, fname)
    end
    gp:flush()
  else
    if is_string(self.scrdump) then
      os.rename(fname, self.scrdump)
    else
      os.remove(fname)
      print("MAD Plot Warning : no scrdump nor output provided - Nothing done")
    end
  end
end

-- layout ---------------------------------------------------------------------o

-- element flag for layout
local flayangle = MAD.element.flags.layangle
local flayout   = MAD.element.flags.layout
local flays     = lshift(1, flayangle) + lshift(1, flayout)

--  adjust "out of plot" layout coordinate
local xadjust    = \xs,ys,base,l -> xs*l + base
local yadjust    = \size  -> \xs,ys,base -> size*ys + base
--  adjust "in plot" layout coordinate
local xadjust_in = \size  -> \xs,ys,base -> xs*base[1] + size*ys*base[2] + base[3]
local yadjust_in = \size  -> \xs,ys,base -> xs*base[1] + size*ys*base[2] + base[3]

-- return the shape of an element in x and y
local function eShap (elem, dir)
  local shape = dat[elem.kind]
  local el, dash, sh = shape.ellipse, shape.dashtype, shape.shape

  sh = sh and elem.l == 0 and elem.kind ~= "marker" and dat.default.shape or sh
  -- if only a ellipse
  if not is_table(sh) then return el, dash end

  local ysym, yscl, func = shape.ysym, (shape.yscl or 1), nil
  local yshft = shape.yshft and sign(elem[shape.yshft]) or 0
  if is_number(ysym) then -- for symmetric shapes
    func = {
      \y -> ((   y + yshft)*yscl),
      \y -> ((-1*y + yshft)*yscl),
    }
  else
    local fv = sign(elem[ysym] or 1)
    ysym = (ysym == "angle") and fv*dir or fv
    func = {\y -> ((ysym*y + yshft)*yscl) }
  end
  return el, dash, sh.x, sh.y, func
end

-- stream polygon data
local function layout_poly (param, len, xorig, yorig, x_sh, y_sh, dash, func)
  local fpwrite, xadjust, yadjust, ref in param
  for i=1,#func do
    for j=1,#x_sh do
      local xj, yj = x_sh[j], y_sh[j]
      local dashtype = dash and "dashtype '" .. dash .. "'" or ""
      fpwrite("set object %d polygon front fc rgb 'white' fs solid 1.0 \z
        border rgb 'black' %s \\\n", param.oid, dashtype)
      local cmd = "from"

      for k=1,#xj do
        local xk, yk = xj[k], func[i](yj[k])
        xk, yk = xadjust(xk, yk, xorig, len), yadjust(xk, yk, yorig)
        local next = (k == #xj) and "" or " \\"
        fpwrite("  %s %.5e, %s %.5e%s\n", cmd, xk, ref, yk, next)
        cmd = "to"
      end
      param.oid = param.oid + 1
    end
  end
  fpwrite("\n")
end

-- stream ellipse data
local function layout_ellipse (param, len, el, xorig, yorig, dash, size)
  local fpwrite, xadjust, yadjust, ref in param
  local cx, cy = xadjust(0, 0, xorig, len), yadjust(0, 0, yorig)
  local sx, sy = len, el*size
  local dashtype = dash or ""
  fpwrite("set object %d ellipse front at %.5e, %s %.5e \\\n\z
    size %.5e, %s %.5e front fc rgb 'white' fs solid 1.0 border rgb 'black' %s \n",
    param.oid, cx, ref, cy, sx, ref, sy, dashtype)
  param.oid = param.oid + 1
end

-- stream element label data
local function layout_label(param, name, kind, xorig, yorig)
  local fpwrite, oid, ref, xadjust, yadjust in param
  local x, y = xadjust(0, 0, xorig, 1), yadjust(0, 0, yorig)
  label = name .. " [" .. kind .. "]"
  fpwrite("set label %d back at %.5e, %s %.5e '%s' hypertext \z
    point pt 4 ps 1 lc 'white'\n", oid, x, ref, y, label)
end

-- stream beam line data
local function layout_bline (param, bline)
  local fpwrite, ref in param
  local prevX, prevY = bline.x[1], bline.y[1]
  for i=2,#bline.y do
    local xi, yi = bline.x[i], bline.y[i]
    fpwrite("set object %d polygon front dashtype solid \\\n\z
      from first %.5e, %s %.5e to first %.5e, %s %.5e to first %.5e, %s %.5e\n",
      param.oid, prevX, ref, prevY, xi, ref, yi, prevX, ref, prevY)
    param.oid = param.oid + 1
    prevX, prevY = xi, yi
  end
end

-- process data for "out of plot" layout
local function layout_process(param, pseq)
  local seqshift, nturn, layangle in param
  local range, seq, disty, distx  in pseq
  local size    = nturn*seq:length_of(range)
  local xs, ys  = table.new(size, 0), table.new(size, 0)
  local bline   = { x = { }, y={ } }
  local deltaY  = disty
  local prevs_sh, angle, j, dir = 0, 0, 1, seq.direction
  for i, elem, s in seq:iter(range, nturn) do
    local s_sh   = s + elem.l/2
    deltaY       = deltaY - tan(dir*angle)*(s_sh-prevs_sh)
    xs[j], ys[j] = s_sh + distx + seqshift, deltaY
    prevs_sh     = s_sh
    pseq.xmin, pseq.xmax = min(pseq.xmin, xs[j]), max(pseq.xmax, xs[j])
    pseq.ymin, pseq.ymax = min(pseq.ymin, ys[j]), max(pseq.ymax, ys[j])
    if elem:is_selected(flayangle) and layangle then
      angle = angle + elem.angle
      table.insert(bline.x, xs[j]); table.insert(bline.y, ys[j])
    end
    j = j + 1
  end
  table.insert(bline.x, xs[#xs]); table.insert(bline.x, 1, xs[1])
  table.insert(bline.y, ys[#ys]); table.insert(bline.y, 1, ys[1])
  pseq.xs, pseq.ys, pseq.bline = xs, ys, bline
end

-- process data "in plot" layout (see help for formulas)
local function layout_process_in(param, pseq)
  local seqlabel, nturn, A0, X0 in param
  local range, seq    in pseq
  local size       = nturn*seq:length_of(range)
  local xs, ys     = table.new(size, 0), table.new(size, 0)
  local bline      = { x = table.new(size, 0), y = table.new(size, 0) }
  local srv        = survey { sequence = seq, range = range, A0=A0, X0=X0 }
  local idx, j     = 0, 1
  local labx, laby = seqlabel[1], seqlabel[2]

  for i, elem in seq:iter(range, nturn) do
    local line_idx = srv:index_of(elem.name, idx)
    if is_table(line_idx) then line_idx = line_idx[1] end
    idx = line_idx
    local line     = srv:getrow(line_idx)
    local prevLine, x1, y1, xas, yas, xbs, ybs

    repeat
      prevLine = (line_idx~=1) and srv:getrow(line_idx-1) or { x=0, y=0, z=0 }
      x1, y1   = prevLine[labx], prevLine[laby]
      x2, y2   = line[labx], line[laby]
      xas, yas = 0.5*(x2 - x1), 0.5*(y2 - y1)
      line_idx = line_idx - 1
    until xas ~= 0 or yas ~= 0 or line_idx <= 1

    if xas == 0 and yas == 0 then
      xbs, ybs   = 0, 1
    else
      local xx, yy = (x1 - x2), (y2 - y1)
      local sqrt_  = 1 / sqrt( yy^2 + xx^2 )
      xbs, ybs = yy*sqrt_, xx*sqrt_
    end

    if elem.l == 0
    then xshft, yshft = x2, y2
    else xshft, yshft = x1 + xas, y1 + yas
    end

    xs[j], ys[j]         = {xas, xbs, xshft}, {yas, ybs, yshft}
    pseq.xmin, pseq.xmax = min(pseq.xmin, xshft), max(pseq.xmax, xshft)
    pseq.ymin, pseq.ymax = min(pseq.ymin, yshft), max(pseq.ymax, yshft)
    table.insert(bline.x, xshft); table.insert(bline.y, yshft)
    j = j + 1
  end
  pseq.xs, pseq.ys, pseq.bline = xs, ys, bline
end

-- stream a signle layout
local function layout (param, pseq)
  local elemminlen, elemkind, elemwidth, elemname, nturn in param
  local seq, range, xs, ys, bline                in pseq
  local dir, j  = seq.direction, 1

  layout_bline(param, bline)
  for i, elem, s in seq:iter(range, nturn) do
    local len, kind    = elem.l, elem.kind
    local is_flagged   = elem:test_flags(flays)
    local is_vkind     = not elemkind or elemkind[kind]
    local xorig, yorig = xs[j], ys[j]

    if is_flagged or (len >= elemminlen and is_vkind) then
      local sh_l = len / 2
      local el, dash, x_sh, y_sh, func  = eShap(elem, dir)

      if elemname  then layout_label(param, elem.name, kind, xorig, yorig) end

      if not is_nil(el) and len ~= 0 then
        layout_ellipse(param, len, el, xorig, yorig, dash, elemwidth)
      end

      if not is_nil(x_sh) then
        layout_poly(param, sh_l, xorig, yorig, x_sh, y_sh, dash, func)
      end
    end
    j = j + 1
  end
end

-- compute bounding box and scale data accordingly
-- post processing for "out of plot" layout
local function layout_post(param, pseqs, ymin, ymax)
  local sequence, laypos, layonly, elemwidth, elemscale in param
  param.laysize  = param.laysize
    or (layonly and _dflt.layonly)
    or (is_rawtable(sequence) and _dflt.laysize + _dflt.multisize*#sequence)
    or _dflt.laysize
  elemwidth     = (elemwidth or _dflt.elemwidth) * elemscale
  local pad     = _dflt.padding
  local ybbox   = abs(ymax - ymin) + 2*elemwidth + 2*pad
  local yfactor = param.laysize / ybbox
  elemwidth     = elemwidth * yfactor
  if laypos == "top"    then laypos =1-(ymax*yfactor + elemwidth + pad) end
  if laypos == "bottom" then laypos =  -ymin*yfactor + elemwidth + pad  end
  if laypos == "middle" then laypos = _dflt.middle end
  param.elemwidth = elemwidth

  for i=1,#pseqs do
    local pseq = pseqs[i]
    local ys, bline in pseq
    pseq.ys      = fun.map(\y -> y*yfactor + laypos, ys):totable()
    pseq.bline.y = fun.map(\y -> y*yfactor + laypos, bline.y):totable()
  end
end

-- post processing for "in plot" layout
local function layout_post_in(param, ymin, ymax)
  local elemwidth, elemscale in param
  elemwidth       = elemwidth or (abs(ymax - ymin) * _dflt.elemwidth_in / 100)
  param.elemwidth = elemwidth * elemscale
end

-- main layout function
local function multi_layout (param)
  local sequence, fpwrite, range, seqdistx, seqdisty,
    elemwidth, elemscale, laypos, xrange                  in param
  local is_in = (laypos == "in")
  param.ref = is_in and "" or "screen"
  local xmin, xmax, ymin, ymax = inf, -inf, inf, -inf
  local pseqs = { }
  local seqs = is_rawtable(sequence) and sequence or
               is_sequence(sequence) and {sequence} or
               error("Invalid sequence input")

  for i=1,#seqs do
    local distx = (i~=1) and (is_table(seqdistx) and seqdistx[i-1] or seqdistx) or 0
    local disty = (i~=1) and (is_table(seqdisty) and seqdisty[i-1] or seqdisty) or 0
    local rg    = (#seqs > 1) and is_table(range) and range[i] or range or nil
    local pseq  = {
      xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax,
      seq = seqs[i], distx = distx, disty = disty, range=rg
    }
    if is_in
    then layout_process_in(param, pseq)
    else layout_process(param, pseq)
    end
    xmin, xmax = min(xmin, pseq.xmin), max(xmax, pseq.xmax)
    ymin, ymax = min(ymin, pseq.ymin), max(ymax, pseq.ymax)
    pseqs[i]   = pseq
  end

  if is_in
  then layout_post_in(param, ymin, ymax)
  else layout_post(param, pseqs, ymin, ymax)
  end
  param.xadjust = is_in and xadjust_in(param.elemwidth) or xadjust
  param.yadjust = is_in and yadjust_in(param.elemwidth) or yadjust(param.elemwidth)

  for i=1,#pseqs do
    local pseq = pseqs[i]
    layout(param, pseq)
  end

  fpwrite("MAD_MAX = %.5e\n", param.oid)
  xmin, xmax = xmin - param.elemwidth, xmax + param.elemwidth
  ymin, ymax = ymin - param.elemwidth, ymax + param.elemwidth
  if not xrange           then fpwrite("set xrange [%s:%s]\n", xmin, xmax) end
  if not yrange and is_in then fpwrite("set yrange [%s:%s]\n", ymin, ymax) end
end

-- plot -----------------------------------------------------------------------o

-- get vector from label
local function getv (data, tbl, label)
  if label then
    if data and data[label] then
      return data[label]
    elseif tbl[label] then
      return tbl[label], true
    else
      error("invalid label")
    end
  end
end

-- parse input axis and apply func to each label
local function parse_axis (param, func)
  local _axis = {'x1y1', 'x1y2', 'x2y1', 'x2y2'}
  for _,axis_name in ipairs(_axis) do
    local axis = param[axis_name]
    if is_string(axis) then                  -- e.g. x1y1 = 'y1'
      func(param, nil, axis, axis_name)
    elseif is_table(axis) then
      for x,y in pairs(axis) do
        if is_number(x) then                 -- e.g. x1y1 = {'y1', 'y2'}
          func(param, nil, y, axis_name)
        elseif is_string(y) then             -- e.g. x1y1 = { x1 = 'y1' }
          func(param, x, y, axis_name)
        elseif is_table(y) then              -- e.g. x1y1 = { x1 = {'y1', 'y2'}}
          for _,yi in pairs(y) do
            func(param, x, yi, axis_name)
          end
        end
      end
    end
  end
end

-- stream one plot data (used in parse_axis)
local function plot_data (param, xlbl, ylbl)
  local fpwrite, tablerange, data, table in param
  local x, tblx = getv(data, table, xlbl)
  local y, tbly = getv(data, table, ylbl)
  local ix      = tblx and tablerange and tablerange[1] or 1
  local iy      = tbly and tablerange and tablerange[1] or 1
  local len

  if (tblx or tbly) and tablerange
  then len = tablerange[2] - tablerange[1] + 1
  else len = #y
  end

  assert(not x or ix + len - 1 <= #x , "Invalid data size or tablerange")
  assert(iy + len - 1 <= #y , "Invalid data size or tablerange")
  for i=1,len do
    -- use index if xlbl not specified
    local xi = x and x[ix] or i
    fpwrite("%.5e %.5e\n", xi, y[iy])
    ix, iy = ix + 1, iy + 1
  end
  fpwrite("e\n")
end

-- parse dashtypes and add '' if it is a pattern : e.g.: ".-- "
local function parse_dash (dashtypes, datastyle, y)
  local dash = datastyle and datastyle.dashtype or is_table(dashtypes) and
    (dashtypes[y] or _dflt.dashtype) or dashtypes
  if string.match(dash, "[.%-_ ]+") then return "'" .. dash .. "'" end
  return dash
end

-- stream the gnuplot 'plot' command (used in parse_axis)
local function plot_cmd (param, _, y, axis)
  local pwrite, colors, styles, dashtypes, pointsizes,
    pointtypes, linewidths, legend, datastyles in param
  local values = {
    color     = datastyles[y] and datastyles[y].color     or is_table(colors)     and (colors[y]     or _dflt.color)     or colors,
    style     = datastyles[y] and datastyles[y].style     or is_table(styles)     and (styles[y]     or _dflt.style)     or styles,
    pointsize = datastyles[y] and datastyles[y].pointsize or is_table(pointsizes) and (pointsizes[y] or _dflt.pointsize) or pointsizes,
    pointtype = datastyles[y] and datastyles[y].pointtype or is_table(pointtypes) and (pointtypes[y] or _dflt.pointtype) or pointtypes,
    linewidth = datastyles[y] and datastyles[y].linewidth or is_table(linewidths) and (linewidths[y] or _dflt.linewidth) or linewidths,
    dashtype  = parse_dash(dashtypes, datastyles[y], y),
    title     = (legend == false) and ''
                  or is_table(legend) and
                    ( legend[y] == false and '' or legend[y] )
                  or y,
    axis      = axis,
  }
  local cmd = "${cmd} using 1:2 with ${style} "
  if string.match(values.style, "lines") then
    cmd = cmd .. "dashtype ${dashtype} linewidth ${linewidth} "
  end
  if string.match(values.style, "points") then
    cmd = cmd .. "pointsize ${pointsize} pointtype ${pointtype} "
  end
  cmd = cmd .. "linecolor '${color}' title '${title}' axes ${axis},\\\n"
  cmd = strinterp(cmd, values, '=') % param
  param.cmd = "     '' "               -- only the first command need "plot '-'"
  pwrite(cmd)
end

-- set the range command for all axis
local function set_ranges (param)
  local fpwrite in param
  local names = {'xrange', 'x2range', 'yrange', 'y2range'}
  for _,rname in ipairs(names) do
    local range = param[rname]
    if range then fpwrite("set %s [%.5e:%.5e]\n", rname, range[1], range[2]) end
  end
end

-- set label command for each axis
local function set_label (param)
  local fpwrite in param
  local names = {'xlabel', 'x2label', 'ylabel', 'y2label'}
  for _,lname in ipairs(names) do
    local label = param[lname]
    if label then fpwrite("set %s '%s'\n", lname, label) end
  end
end

-- set tics for each used axis
local function set_tics (param)
  local x2y1, x2y2, x1y2, x2y2, pwrite in param
  if x2y1 or x2y2 then pwrite("set xtics nomirror\nset x2tics nomirror\n") end
  if x1y2 or x2y2 then pwrite("set ytics nomirror\nset y2tics nomirror\n") end
end

-- set remaining parameters (miscellaneous)
local function set_misc (param)
  local psizex, psizey, originx, originy, grid, border,
    title, legendpos, plotter                             in param
  local wrt = \s,... => plotter:write(string.format(s,...) % param) end
  if grid   then wrt("set grid %s\n", grid)     end
  if border then wrt("set border %s\n", border) end
  if title  then
    local font = param.titlefont or ""
    local size = param.titlesize or ""
    wrt("set title '%s' font '%s,%s'\n", title, font, size)
  end
  if legendpos then
    local font = param.legendfont or ""
    local size = param.legendsize or ""
    local cmd  = "set key %s font '%s,%s'\n"
    wrt(cmd, legendpos, font, size)
  end
  if psizey or psizex then
    psizex, psizey = psizex or _dflt.psizex, psizey or _dflt.psizey
    wrt("set size %.5e, %.5e\n", psizex, psizey)
  end
  if originy or originx then
    originx, originy = originx or _dflt.originx, originy or _dflt.originy
    wrt("set origin %.5e, %.5e\n", originx, originy)
  end
end

-- main plot function
local function plot (param)
  set_ranges(param)
  set_label(param)
  set_tics(param)
  set_misc(param)
  param.cmd = "plot '-'" -- first plot command initialization
  parse_axis(param, plot_cmd)
  param.pwrite("\n")
  parse_axis(param, plot_data)
end

-- command --------------------------------------------------------------------o

-- create a graph with both the layout and the plot part
local function composed_plot (param)
  local laypos, psizey, originy in param

  multi_layout(param)

  local laysize in param
  if laypos == "top" or laypos == "bottom" then
    param.psizey = psizey or _dflt.psizey - laysize
  end
  param.originy = originy or laypos == "bottom" and laysize
                          or _dflt.originy
  plot(param)
end

-- initialize the table of parameters
local function init_param(self, file)
  local param = {
    version = tostring(MAD.env.version),
    name    = self.name or is_table(self.table) and self.table.title or "",
    date    = self.date or is_table(self.table) and self.table.date  or "",
    time    = self.time or is_table(self.table) and self.table.time  or "",
    plotter = file,
    oid     = self.oshft,
    fpwrite = \... -> file:write(string.format(...)),
    pwrite  = \... -> file:write(...)
  }
  if self.elemkind then -- build dictionary
    setkeys(self.elemkind)
  end

  setmetatable(param, {__index=self})
  return param
end

local layout_only = [[
unset key
unset tics
unset border
plot x lc 'white'
]]

local function exec (self)
  local gp, file, fname = setup_cmd(self)
  if self.sequence ~= "keep" then
    file:write("@MAD_RESET_OBJECT\n")
    file:write("@MAD_RESET_LABEL\n")
  elseif self.range then
    print("MAD Plot Warning : sequence=\"keep\" and range is \z
      provided - range is ignored")
  end

  if self.prolog then file:write(self.prolog, "\n") end
  local param = init_param(self, file)

  local has_plot   = is_mtable(self.table) or is_table(self.data)
  local has_layout = is_rawtable(self.sequence) or is_sequence(self.sequence)
  if has_plot and has_layout then
    composed_plot(param)
  elseif has_plot then
    plot(param)
  elseif has_layout then
    param.layonly = true
    multi_layout(param)
    param.fpwrite(layout_only)
  end

  if self.epilog then file:write(self.epilog, "\n") end
  teardown_cmd(self, gp, file, fname)
  return self
end

local plot = Command 'plot' {

  -- stream id
  sid         = 1,

  -- user command
  prolog      = false,   -- string
  epilog      = false,   -- string

  -- windows setup
  term        = 'wxt',
  wsizex      = 800,
  wsizey      = 500,

  -- output
  output      = 1,       -- ("filename") -> pdf | number -> wid
  scrdump     = false,   -- ("filename")

  -- table or data input
  data        = false,   -- { x=tbl.x, y=vec } (precedence over table)
  table       = false,
  tablerange  = false,   -- { min, max }

  -- sequence input
  sequence    = false,
  range       = false,   -- {'E.DS.L5.B1','S.DS.R5.B1'} or {122.2, 543} etc...
  seqdisty    = 0,       -- x >= 0 or { x1, x2, ... }
  seqdistx    = 0,       -- x >= 0 or { x1, x2, ... }
  seqshift    = 0,       -- x > =0
  seqlabel    = { 'x', 'z' },
  nturn       = 0,
  X0          = { 0, 0, 0 },
  A0          = { 0, 0, 0 },

  -- layout style
  laypos      = "top",   -- top | bottom | middle | in | 0 < x < 1
  laysize     = false,   -- 0 < x < 1
  elemname    = true,
  elemwidth   = false,   -- unsigned size of element before elemscale
  elemscale   = 1,       -- multiplier or default size
  elemkind    = false,   -- { "quadrupole", "sbend" }
  elemminlen  = 0,       -- x > 0
  layangle    = true,

  -- axis selection (and names)
  x1y1        = false,   -- e.g. x1y1 = { x1 = {'y1', 'y2'}, x2 = {'y3', 'y4'}}
  x1y2        = false,   -- e.g. x1y1 = { x1 = {'y1', 'y2'}}
  x2y1        = false,   -- e.g. x1y1 = { x1 = 'y1'}
  x2y2        = false,   -- e.g. x1y1 = {'y1', 'y2'}
                         -- e.g. x1y1 = 'y1'
  -- labels
  title       = "${name} MAD ${version}, ${date}, ${time}",
  legend      = nil,     -- { y = 'distance' }
  xlabel      = false,   -- strings
  x2label     = false,
  ylabel      = false,
  y2label     = false,

  -- axis ranges
  xrange      = false,   -- { min, max }
  x2range     = false,
  yrange      = false,
  y2range     = false,

  -- plot style
  originx     = false,   -- 0 < x < 1
  originy     = false,   -- 0 < x < 1
  psizex      = false,   -- 0 < x < 1
  psizey      = false,   -- 0 < x < 1

  -- data style
  datastyles  = {},      -- { y = { style = 'lines', color = 'blue'} }
  styles      = 'lines', -- { y = 'lines' }
  colors      = 'red',   -- { y = 'green' }
  dashtypes   = 'solid', -- { y = '..-- ' }
  linewidths  = 1,       -- { y = 2.3     }
  pointtypes  = 1,       -- { y = 2       }
  pointsizes  = 1,       -- { y = 2.3     }

  -- decoration
  font        = "Times New Roman",
  fontsize    = 14,
  titlefont   = false,
  titlesize   = false,
  legendfont  = false,
  legendsize  = false,
  legendpos   = "left top",
  grid        = '',
  border      = 15,

  -- object shift
  oshft       = 1000000,

  -- build the command (do not execute)
  exec        = exec,
} :set_readonly()

-- end ------------------------------------------------------------------------o

return {
  plot  = plot,
  gplot = gplot
}