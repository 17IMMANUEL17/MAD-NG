--[=[
 o-----------------------------------------------------------------------------o
 |
 | Plot module
 |
 | Methodical Accelerator Design - Copyright CERN 2015+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 |          A.Z. Teska, aleksandra.teska at cern.ch
 | Contrib: F.R. Leiro
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provides ploting

 o-----------------------------------------------------------------------------o
]=]

-- help -----------------------------------------------------------------------o

local __help = {}
__help.plot = [[
NAME
  plot -- Plot

SYNOPSIS
  TODO

DESCRIPTION
  The module plot provides...

RETURN VALUES
  The plot command

SEE ALSO
  element, sequence, track
]]

-- locals ---------------------------------------------------------------------o

local dat = require 'madl_plotdat'
local range, nrange, vector, element, totable                      in MAD
local isa_matrix, is_range, is_table, is_vector, is_nil, is_string in MAD.typeid
local min, max                                                     in MAD.gmath
local chain, duplicate                                             in MAD.fun

-- implementation -------------------------------------------------------------o

local to_tbl = \x => if is_string(x) then return totable(x) else return x end end

local function keys_tbl(t1, t2, keys)
  local table = {}
  if   t1 then for j,k in ipairs(keys) do table[k] = t1[k] or t2[k] end
  else         for j,k in ipairs(keys) do table[k] = t2[k]          end end
  return table
end

local function mk_tbl(t1, t2)
  local tbl = {}
  for i,k in ipairs(t1) do tbl[i]     = k end
  for i,k in ipairs(t2) do tbl[i+#t1] = k end
  return tbl
end

local function chain_tbl(t1, t2, ...)
  local t = {}
  for _it, k, v in chain(t1, t2, ...) do table.insert(t, k) end
  return t
end

local function plotter(src, output, keys) -- TODO
  local s = src[keys[1]]
  for i=1,#s do
    if is_vector(s[i]) then
      for ii=1,#s[i] do
        for j,k in ipairs(keys) do
          output:write(src[k][i][ii]," ")
        end
        output:write("\n")
      end
    else
      for j,k in ipairs(keys) do
        output:write(src[k][i]," ")
      end
    end
    output:write("\n")
  end
  output:close()
end

--scalling
local function scale_rng(src, rng)
  if     is_range(rng) then return rng
  elseif is_table(rng) then
    local  start,  stop = 1     , #src
    local rstart, rstop = rng[1], rng[2]
    local vmin, vmax, c = {}, {}
    c=1; src:mapij(\x,i,j => if x>rstart then vmin[c]=i; c=c+1 end end, {})
    c=1; src:mapij(\x,i,j => if x>rstop  then vmax[c]=i; c=c+1 end end, {})
    start = vmin[1]
    if vmax[1]       then stop = vmax[1]-1 end                                  -- add WARNING(bigger then data)
    if rng [2] == -1 then stop = #src      end
    return start..stop
  end
end

local function chksize(rng, start, stop)
  if rng:size() <= stop then start, stop = rng.start, rng.stop end
  return start, stop
end

local function scale_tbl(tbl, start, stop) -- check luafun usage
  local r = {}
  for j=1,stop-start do r[j] = tbl[start+j] end
  return r
end

local function scale_dat(src, keys, rng) -- check luafun usage
  local d_src = {}
  local start, stop = 1, #src[keys[1]]
  start, stop = chksize(rng, start, stop)
  for j,k in ipairs(keys) do
    if isa_matrix(src[k]) then d_src[k]=src[k]:getv(start..stop )
                          else d_src[k]=scale_tbl(src[k],start,stop) end
  end
  return d_src
end

local function scale_axis(src, keys, margin) --add margin option
  local vmin, vmax = vector(#keys), vector(#keys)
  for i,key in ipairs(keys) do
    local min = src[key]:min()
    local max = src[key]:max()
    vmin:seti(i, min)
    vmax:seti(i, max)
  end
  if margin then return 0.9*vmin:min(), 1.1*vmax:max() end
  return vmin:min(), vmax:max()

end

--titles
local function axis_title(src)
  local label = ""
  for _,key in pairs(src) do label = label..key.." " end
  return label
end

local function mktitle(title, notitle, name, date, time)
  local ver = tostring(MAD.env.version)
  if     notitle == true  then return ""
  elseif is_string(title) then return title
  else                         return name..", MAD "..ver..", "..date.." "..time end
end

--layout
local xadjst = \x,l,s -> (x * l + s - l)
local yadjst = \y,h   -> (y * h        )

local function sh_get(sh)
  local x_sh, y_sh = {}, {}
  if is_table(sh.x[1]) then for i=1,#sh.x do x_sh[i] = vector(sh.x[i])
                                             y_sh[i] = vector(sh.y[i])  end
                       else x_sh, y_sh = {vector(sh.x)}, {vector(sh.y)}     end
  return  x_sh, y_sh
end

local function layout(seq, start, stop)
  local xl, yl, c = {}, {}, 1
  local s_pos in seq
  for i=start,stop do
    local elem, s = seq[i]   , s_pos[i]
    local kind, l = elem.kind, elem.l
    if s and l then
      local h,sh = elem[dat[kind].str_k] or 1
      if     dat[kind].shape then sh = dat[kind].shape
      elseif h > 0           then sh = dat[kind].shape_f
                             else sh = dat[kind].shape_d end
      local x_sh, y_sh = sh_get(sh)
      for j=1,#x_sh do
        local x, y = x_sh[j], y_sh[j]
        xl[c] = x:map(\x xadjst(x, l, s))
        yl[c] = y:map(\y yadjst(y, 1   ))
        c = c+1
      end
    end
  end
  return { x=xl, y=yl }
end

-- template
local function temp_fill(temp, src)
  local templ = {}
  for i,line in ipairs(temp) do
    templ[i], n = string.gsub( line, "%$(%w+)", src )
  end
  return templ
end

local function find_key(inp, key)
  local indx
  for i,line in ipairs(inp) do if line:find(key) then indx = i end end
  return indx
end

local function temp_multiplot(temp, inp, key, start)
  local s, lnr = #inp, find_key(temp, key)
  if lnr then
    for i=#temp,lnr,-1 do temp[i+s-1]=temp[i] end
    for i=0,s-1 do temp[lnr+i]=temp[lnr]      end
    for i=0,s-1 do temp[lnr+i]=temp[lnr+i]:gsub( key    , tostring(i+start+2))
                   temp[lnr+i]=temp[lnr+i]:gsub('ytitle', inp[i+1]           ) end
  end
end

local function temp_add(temp, inp, key, start)
  local template = chain_tbl(temp, {} )
  local lnr, s   = find_key (temp, key), #inp
  if lnr then
    for i=#temp,lnr,-1 do template[i+s-1]=temp[i] end
    for i=start,s      do template[lnr+i]=inp [i] end
  end
  return template
end

local function temp_colors(temp, color)
  local c = 1
  for i,line in ipairs(temp) do
    temp[i], n = string.gsub( line, "colors", color[c] )
    if n == 1 then c=c+1 end
  end
end

local function temp_print(temp, printer)
  for i =1,#temp do printer:write(temp[i]) end
  printer:close()
end

local template = {
  "set multiplot \n"                 ,
  "set $grid \n"                     ,
  "set lmargin at screen $lmargin \n",
  "set rmargin at screen $rmargin \n",
  "set size 1,$sizeplot \n"          ,
  "set title '$gtitle'  \n",
  "set xlabel '$xlabel' \n"          ,
  "set ylabel '$ylabel' \n"          ,
  "set xrange [$xmin:$xmax] \n"      ,
  "set yrange [$ymin:$ymax] \n"      ,
  "plot ",
  "'$plotdata' using 1:count  every 1::0 $interpolate  linetype $linetype linecolor 'colors' title 'ytitle' axes x1y1,\\\n",
}

local temp_preamble = { "#$preamble \n" }
local temp_nocopy   = { "set terminal x11 persist \n" }
local temp_hardcopy = {
  "set terminal $terminaltype size $xsize cm, $ysize cm enhanced color \n",
  "set output '$filename'  \n",
}
local temp_multiv = {
  "set ytics nomirror \n"         ,
  "set y2tics \n"                 ,
  "set tics out \n"               ,
  "set y2label '$ylabel2' \n"     ,
  "set y2range [$ymin2:$ymax2] \n",
}
local temp_multih = {
  "set xtics nomirror \n"         ,
  "set x2tics \n"                 ,
  "set tics out \n"               ,
  "set x2label '$xlabel2' \n"     ,
  "set x2range [$xmin2:$xmax2] \n",
}
local temp_vaxis2  = {"'$plotdata' using 1:count2 every 1::0 $interpolate linetype $linetype linecolor 'colors' title 'ytitle' axes x1y2,\\\n"}
local temp_hvaxis2 = {"'$plotdata' using 1:count2 every 1::0 $interpolate linetype $linetype linecolor 'colors' title 'ytitle' axes x2y2,\\\n"}
--local temp_haxis2  = {"'$plotdata' using 1:count2 every 1::0 $interpolate linewidth $linewidth linecolor 'colors' title 'ytitle' axes x2y1,\\\n"}
local temp_lay = {
  "\nunset tmargin \n"  ,
  "unset bmargin \n"    ,
  "unset title  \n"     ,
  "unset arrow \n"      ,
  "unset ylabel \n"     ,
  "unset xlabel \n"     ,
  "unset xtics \n"      ,
  "unset ytics \n"      ,
  "unset y2tics \n"     ,
  "unset y2label \n"    ,
  "unset key \n"        ,
  "set xzeroaxis \n"    ,
  "set border 0 \n"     ,
  "set size 1,0.15 \n"  ,
  "set origin 0,0.85 \n",
  "set yrange [-1:1] \n",
  "plot '$layoutdata' u 1:2 w lines linestyle 1 linecolor rgb 'black' \n",
}
-- plotting command -----------------------------------------------------------o
local mtable, Command in MAD

function exec(self)
  print(self.filename)
  local gp_script = io.open(self.script    , "w")
  local plot_data = io.open(self.plotdata  , "w")
  local lay_data  = io.open(self.layoutdata, "w")
  local temp = template

  if self.hardcopy then temp = mk_tbl(temp_hardcopy, temp)
                   else temp = mk_tbl(temp_nocopy  , temp) end
  if self.preamble then temp = mk_tbl(temp_preamble, temp) end

  if self.table then
    local title, date, time in self.table
    self.gtitle =  mktitle(self.title, self.notitle, title, date, time)
  else
    self.gtitle = " "
  end

  if self.sequence then
    local seq = self.sequence
    assert(seq.kind == 'sequence' and seq.is_sequence == true, "invalid sequence")
    local start, stop = seq:range_index (self.range)
    local lay         = layout( seq, start, stop )
    self.sizeplot = 0.85
    self.datrange = {1,-1}
    temp = chain_tbl(temp, temp_lay)
    plotter( lay, lay_data, {'x','y'} )
  end

  if self.color then
    for k,v in pairs(self.color) do
      local indx = find_key(self.keys, k)
      if indx then self.colors[indx] = v end
    end
  end

  if self.VAXIS2 and self.HAXIS2 then
    local inp2, out2 = to_tbl (self.HAXIS2), to_tbl (self.VAXIS2)
    self.keys    = chain_tbl(self.inp, inp2, self.out, out2)
    self.ylabel2, self.xlabel2 = axis_title( out2 ), axis_title( inp2 )
    self.vlimit2 = { scale_axis( self.src, out2, self.margin ) }
    self.hlimit2 = { scale_axis( self.src, inp2, self.margin ) }
    temp = chain_tbl( temp, temp_hvaxis2 )
    temp = temp_add ( temp, temp_multih, "gtitle", 1 )
    temp = temp_add ( temp, temp_multiv, "gtitle", 1 )
    temp_multiplot  ( temp, out2       , "count2", #inp2+#self.out )
    temp_multiplot  ( temp, self.out   , 'count' , #inp2           )
  elseif self.VAXIS2 then
    local out2   = to_tbl (self.VAXIS2)
    self.keys    = chain_tbl(self.keys, out2 )
    self.ylabel2 = axis_title( out2 )
    self.vlimit2 = { scale_axis( self.src, out2, self.margin ) }
    temp = chain_tbl( temp, temp_vaxis2 )
    temp = temp_add ( temp, temp_multiv, "gtitle", 1         )
    temp_multiplot  ( temp, out2       , "count2", #self.out )
  elseif self.HAXIS2 then
    local inp2   = to_tbl (self.HAXIS2)
    self.keys    = chain_tbl(self.inp , inp2, self.keys )
    self.xlabel2 = axis_title( inp2 )
    self.hlimit2 = { scale_axis( self.src, inp2, self.margin ) }
    temp = temp_add ( temp, temp_multih, "gtitle", 1     )
    temp_multiplot  ( temp, self.out   , 'count' , #inp2 )
  end

  plotter( self.src, plot_data, self.keys )
  temp = temp_fill( temp, self       )
  temp_multiplot  ( temp, self.out , 'count', 0)
  temp_colors     ( temp, self.colors)
  temp_print      ( temp, gp_script  )
  os.execute("gnuplot "..self.script )
end

local plot = Command 'plot' {
  preamble = nil,
  hardcopy = nil,
  table    = nil,
  data     = nil,
  sequence = nil,
  HAXIS    = 'x',
  VAXIS    = 'y',
  VAXIS2   = nil,
  filename     = "test.pdf"      ,
  plotdata     = "dataplot.dat"  ,
  layoutdata   = "datalayout.dat",
  script       = "plotter.gp"    ,
  terminaltype = "pdf"           , --"postscript eps",
  fonttype     = "Times-Roman"   ,
  fontsize     = 22 ,
  xsize        = 27 ,
  ysize        = 17 ,
  lmargin      = 0.1,
  rmargin      = 0.9,
  sizeplot     = 1  ,
  margin = true,

  range    = {1,-1},
  datrange = \s 1..#s.ktbl[s.inp[1]],
  hlimit   = \s { scale_axis( s.src, s.inp , s.margin ) }       ,
  vlimit   = \s { scale_axis( s.src, s.out , s.margin ) }       ,
  xmin     = \s s.hlimit[1] , xmax  = \s s.hlimit[2] ,
  ymin     = \s s.vlimit[1] , ymax  = \s s.vlimit[2] ,
  xlabel   = \s axis_title( s.inp ),
  ylabel   = \s axis_title( s.out ),
  notitle  = nil,
  title    = nil,
  noversion   = nil,
  interpolate = "" ,
  grid = 'grid',

  vlimit2  = {nil, nil},
  ymin2    = \s s.vlimit2[1], ymax2 = \s s.vlimit2[2],
  ylabel2  = "",
  xlimit2  = {nil, nil},
  xmin2    = \s s.hlimit2[1], xmax2 = \s s.hlimit2[2],
  xlabel2  = "",

  linewidth = 1,
  --linestyle = 1,
  linetype = 1,
  color  = {},
  colors = { "red"        , "purple", "brown"    , "yellow"  , "turquoise",
             "green"      , "blue"  , "orange"   , "violet"  , "pink"     ,
             "greenyellow", "gray"  , "dark-grey", "dark-red", "gold"     ,
             "orangered4" , "brown4" },
-- non-user option
  inp  = \s to_tbl (s.HAXIS),
  out  = \s to_tbl (s.VAXIS),
  keys = \s mk_tbl   (s.inp   , s.out             ), -- chain_tbl does not work
  ktbl = \s keys_tbl (s.table , s.data, s.keys    ),
  drng = \s scale_rng(s.ktbl[s.inp[1]], s.datrange),
  src  = \s scale_dat(s.ktbl  , s.keys, s.drng    ),
  exec = exec,
} :set_readonly()

-- end ------------------------------------------------------------------------o
return {
  plot   = plot  ,
  __help = __help,
}


