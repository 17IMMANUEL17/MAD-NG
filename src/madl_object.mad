--[=[
 o-----------------------------------------------------------------------------o
 |
 | Object module (object model)
 |
 | Methodical Accelerator Design - Copyright CERN 2015+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide an object model to support prototype-based programming with value
    semantic for functions stored in variables and further extensions.

 o-----------------------------------------------------------------------------o
]=]

local M = { __help = {} }

-- help -----------------------------------------------------------------------o

M.__help.self = [=[
NAME
  object -- manage object model

SYNOPSIS
  obj1 = Object {}               -- create a new empty object
  obj2 = Object { ... }          -- create a new object with values
  obj3 = Object 'name' { ... }   -- create a new object with name and values
  obj4 = obj3 'name' { ... }     -- create a new object from parent (class)

DESCRIPTION
  The object module implements the necessary machinery to support prototype-
  based programming with value semantic for functions and further extensions:
  - On read, the lookup of values and functions follows the inheritance down to
    Object. If the retrieved value is a function, it is called with self passed
    as argument #1 (can be ignored) and the result is returned (i.e. function
    with value semantic).
  - On write, the value is simply stored in the current object (no lookup). To
    override this behavior, just (re)defined the __newindex metamethod using
    set_metamethod with overriding allowed (use with care!).
  - On build, the new instance is connected to its parent (inheritance). If the
    new instance has a defined __init metamethod (shared), it will be called on
    the new instance and non-nil result or the new instance will be returned.
  - To set:
    + variables (inherited), use set_variable.
    + functions (inherited) n-ary or avoid value semantic, use set_function.
    + metamethods (shared), use set_metamethod.
    + set, setf, setmm are set_variable, set_function, set_metamethod aliases.
  - Root 'Object' defines the following variables:
    + 'name'  points to 'self' name unless overridden (alias)
    + '__par' points to 'self' parent unless overridden (alias)
    + '__var' points to 'self' variables unless overridden (alias)
    + '__id'  holds 'self' name if provided (variable)
  - Each object inherits the following methods:
    #, name, is_object, is_instanceOf, isa, set, setf, setmm, set_variable,
    set_function, set_metamethod, dump.

RETURN VALUES
  A table constaining Object, the root constructor of objects, and the helpers
  is_object and is_instanceOf for function-like usage in case the argument #1
  might not be a valid object.

ERROR
  Objects constructors trig an error if the argument #1is not a string (name) or
  a raw table (variables). Using an object incompletely initialized (e.g. with a
  name but no value) trigs also an error.

EXAMPLES
  Point = MAD.Object {}          -- point is an instance of Object
  p1 = Point { x=2, y=2 }        -- p1 is an instance of Point
  p2 = p1 { x=3 }                -- p2 is an instance of p1 and inherits p1.y
  p1.x, p1.z = 1, 3              -- set p1.x, p1.z
  print(p1.x, p1.y, p1.z)        -- print 1 2 3
  print(p2.x, p2.y, p2.z)        -- print 3 1 3

SEE ALSO
  None.
]=]

-- documentation --------------------------------------------------------------o

M.__help['object model scheme'] = [=[

Schematic object-model representation:
--------------------------------------

  o0 = MAD.Object
  o1 = o0 'obj1' {*o1-var*}
  o2 = o1 'obj2' {*o2-var*}
  o3 = o1 'obj3' {*o3-var*}
                                               +-------------+
                             +---------------+>| *meta-tbl*  |<------------+
+---------+                  |   +---------+ | | metamethods | +---------+ |
|  *o2*   |                  |   |  *o1*   | | +-------------+ |  *o0*   | |
|  [meta] |------------------+   |  [meta] |-+                 |  [meta] |-+
| __index |------------------|-+ | __index |-----------------+ | __index |--->.
|         |  +-----------+   | | |         |  +-----------+  | |         |
|   [var] |->|  *o2-var* |   | | |   [var] |->| *o1-var*  |  | |   [var] |-+
+---------+  |    [meta] |-+ | | +---------+  |    [meta] |-+| +---------+ |
     ^       | variables | | | |      ^       | variables | ||             |
     |       +-----------+ | | |      |       +-----------+ ||        +----+
     +---------------------+ | |      |             ^       ||        v
+---------+                  | |      +-------------|-------+|  +-----------+
|  *o3*   |                  | |      |             |        |  | *o0-var*  |
|  [meta] |------------------+ |      |             |        +->|    [meta] |->.
| __index |--------------------+--------------------+           | variables |
|         |  +-----------+                                      +-----------+
|   [var] |->| *o3-var*  |
+---------+  |    [meta] |-+
     ^       | variables | |
     |       +-----------+ |
     +---------------------+
]=]

-- examples -------------------------------------------------------------------o

M.__help['object model examples'] = [=[

Catching creation:
------------------
  Example how to count the number of objects created

  local count = 0
  local set_counter = \s s:setmm { __init =\=> count=count+1 end }
  set_counter(MAD.Object) -- count children creation

Catching writes:
----------------
  Example how to set a notification-on-write with logging

  local function set_notification (self)
    local nwidx = rawget(getmetatable(self),'__newindex')
    local mm = \s,k,v =>
      trace(s,k,v) -- logging
      nwidx(s,k,v) -- forward, mandatory!
    end
    self:set_metamethod({__newindex = mm}, true) -- override!
  end
  set_notification(MAD.Object) -- notify writes to any children

Forwarding to parent:
---------------------
  Example how to forbid status change through set_readonly

  local ro_obj = Object {} :set_readonly(true) -- set status
  local parent = ro_obj.parent
  ro_obj:set_function {
    set_readonly = \s,f =>                     -- block any changes for ro_obj
      assert(s ~= ro_obj, "invalid argument #1 (forbidden access to 'ro_obj')")
      return parent.set_readonly(s,f)          -- forward to parent for children
    end
  }

Copying status to children:
---------------------------
  Example how to make children of ro_obj readonly by default (but modifiable)

  ro_obj:set_metamethod {__init = \s -> s:set_readonly(true) }
]=]

-- locals ---------------------------------------------------------------------o

local is_nil, is_boolean, is_string, is_table, is_rawtable, is_function,
      is_metaname, is_callable in require 'madl_utils'

-- implementation -------------------------------------------------------------o

-- metatable of objects
local MT = {}

-- protected keys to object members, true functions and readonly flag
local var, fct, rof = {}, {}, {}

-- instance and metatable of 'incomplete objects' proxy
local var0 = setmetatable({}, {
  __index     := error "forbidden read access to incomplete object",
  __newindex  := error "forbidden write access to incomplete object",
  __metatable = false,
})

-- metatable of 'true functions' proxy
local MF = {
  __call      = \t,... -> t[fct](...),
  __metatable = false,
}

-- helpers

local function init (a)
  local m = rawget(getmetatable(a), '__init')
  return m and m(a) or a
end

local function parent (a)
  return getmetatable(rawget(a,'__index'))
end

local function fproxy (f)
  return setmetatable({[fct]=f}, MF)
end

local function is_fproxy (a)
  return is_table(a) and rawget(a,fct) ~= nil
end

local function is_object (a)
  return is_table(a) and rawget(a,var) ~= nil
end

local function is_readonly (a)
  return is_table(a) and rawget(a,rof) == true
end

local function set_readonly (a, b)
  assert(rawget(a,var) ~= M,
         "invalid argument #1 (forbidden access to 'Object')")
  assert(is_nil(b) or is_boolean(b),
         "invalid argument #2 (boolean or nil expected)")
  rawset(a, rof, b)
  return a
end

local function is_instanceOf (a, b)
  assert(is_object(b), "invalid argument #2 (object expected)")
  if not is_object(a) then return false end
  while a and a ~= b do a = parent(a) end
  return a == b
end

-- objects are proxies controlling variables access and inheritance

function MT:__call (a, b) -- object constructor (define the object-model)
  if is_string(a) then                                  -- named object
    if is_nil(b) then
      local obj = {__id=a, [var]=var0, __index=self[var]} -- proxy
      return setmetatable(obj, getmetatable(self))      -- incomplete object
    elseif is_rawtable(b) then
      local obj = {__id=a, [var]=b, __index=self[var]}  -- proxy
      setmetatable(b, obj)                              -- set fast inheritance
      return init(setmetatable(obj, getmetatable(self)))-- complete object
    end
  elseif is_rawtable(a) then
    if self[var] == var0 then                           -- finalize named object
      a.__id, self.__id = self.__id
      self[var] = setmetatable(a, self);                -- set fast inheritance
      return init(self)
    else                                                -- named object
      local obj = {[var]=a, __index=self[var]}          -- proxy
      setmetatable(a, obj)                              -- set fast inheritance
      return init(setmetatable(obj, getmetatable(self)))-- complete object
    end
  end
  error(is_nil(b)
        and "invalid argument #1 to constructor (string or raw table expected)"
        or  "invalid argument #2 to constructor (raw table expected)")
end

function MT:__index (k)
  local v = self[var][k]                       -- inheritance of variables
  if is_function(v)
  then return v(self)                          -- function with value semantic
  else return v end
end

function MT:__newindex (k, v)
  assert(rawget(self,rof)~=true, "forbidden write access to readonly object")
  self[var][k] = v
end

function MT:__len ()
  return #self[var]
end

local function iterk (self, k)
  local v
  k, v = next(self[var], k)
  if is_function(v)
  then return k, v(self)
  else return k, v end
end

function MT:__pairs ()
  return iterk, self, nil
end

local function iteri (self, i)
  i = i + 1
  local v = rawget(self[var], i)
  if is_function(v) then return i, v(self)
  elseif v ~= nil   then return i, v end
end

function MT:__ipairs()
  return iteri, self, 0
end

-- object methods

M.__help.is_object = [=[
NAME
  is_object, is_instanceOf,            -- identify object class
  is_readonly, set_readonly.           -- check and set object status

SYNOPSIS
  is_object(obj)
  is_readonly(obj)
  is_instanceOf(obj,class)

  obj:is_readonly()
  obj:is_instanceOf(class)
  obj:set_readonly(boolean or nil)

DESCRIPTION
  The is_instanceOf method follows and check the objects hierarchy from obj down
  to class or Object if class is not in the hierarchy of obj. The is_object
  function is equivalent to is_instanceOf(obj, Object) but faster. The method
  set_readonly protects or unprotects against write access (weak protection).

RETURN VALUES
  is_object and is_instanceOf return true if obj inherits from Object or class
  respectively. is_readonly returns true if obj is read only. set_readonly
  returns the object.

ERROR
  is_instanceOf trigs an error if the argument #2 (class) is not a valid object.
  set_readonly trigs an error if the argument #2 is not a boolean or nil or if
  argument #1 is Object itself.

EXAMPLES
  local is_object, is_instanceOf, is_readonly, Object in MAD
  print( is_object 'yes' )                    -- false
  print( is_object(Object) )                  -- true
  print( is_object(Object {}) )               -- true

  print( is_instanceOf('yes', Object) )       -- false
  print( is_instanceOf(Object, Object) )      -- true
  print( is_instanceOf(Object {},Object) )    -- true

  print( is_readonly(Object) )                -- true
  Object.a = 2                                -- error
  Object {} :set_readonly(true).a = 2         -- error

SEE ALSO
  None.
]=]
M.__help.is_readonly   = M.__help.is_object
M.__help.is_instanceOf = M.__help.is_object
M.__help.set_readonly  = M.__help.is_object

M.__help.iterators = [=[
NAME
  #, pairs, ipairs    -- length operator and iterators

SYNOPSIS
  #obj
  for k,v in  pairs(obj) do ... end
  for i,v in ipairs(obj) do ... end

DESCRIPTION
  The length operator is equivalent to the table length operator applied to the
  object variables. The pairs and ipairs iterators iterate respectively over all
  the keys and over all the list keys (indexes) of the object variables, but
  not over the inherited variables. The function value semantic is preserved.

RETURN VALUES
  The length operator returns the number of items in the list part of the
  object. The pairs and ipairs operators return the appropriate arguments for
  stateless iterators, that is the iterator function, the object and the
  pre-initial key.

EXAMPLES
  local p0 = MAD.Object 'p0' { 2, 3, 4, x=1, y=2, z:=3 }
  local p1 = p0 'p1' { 7, 8, x=-1, y={} }

  for i=1,#p0           do print(i,    p0[i]) end
  for i=1,#p1           do print(i,    p1[i]) end
  for k,v in  pairs(p0) do print(k, v, p0[k]) end
  for k,v in  pairs(p1) do print(k, v, p1[k]) end
  for i,v in ipairs(p0) do print(i, v, p0[i]) end
  for i,v in ipairs(p1) do print(i, v, p1[i]) end

SEE ALSO
  None.
]=]
M.__help.length = M.__help.iterators
M.__help.pairs  = M.__help.iterators
M.__help.ipairs = M.__help.iterators

M.__help.get = [=[
NAME
  get_variable, get_allkeys, set_variable, set_function, set_metamethod,
  get, getk, set, setf, setmm.

SYNOPSIS
  obj:get_variable  ({...} [, eval])
  obj:set_variable  ({...} [, override])
  obj:set_function  ({...} [, override [, strict]])
  obj:set_metamethod({...} [, override [, strict]])
  obj:get_allkeys   (depthlevel)

DESCRIPTION
  The get_variable method gets values from a raw table containing the list of
  keys to get, following the value semantic of functions unless eval is 'false'.
  The get_allkeys collect all the variables keys of an object, including those
  inherited from parents up to depthlevel or Object (excluded). The set_variable
  method sets or updates values from a raw table. The set_function method sets
  or updates functions from a raw table in a special way that bypasses the value
  semantic of functions in the object model and enforces the call semantic. The
  set_metamethod method sets metamethods from a raw table that are shared by
  children (see the object model scheme). The methods get, set, setf and setmm
  are aliases for get_variable, set_variable, set_function, set_metamethod
  respectively. The default value for override is 'true' for set_variable and
  set_function and 'false' for set_metamethod. The default value for eval and
  strict is 'true'. The default value for depthlevel is 'huge'.

RETURN VALUE
  A table containing the key-value pairs for the specified keys for the method
  get_variable, a table containing all the variables keys for the method
  get_allkeys, and the object itself for other methods.

ERRORS
  All these methods trig an error if argument #1 is not a valid object and if
  argument #2 is not a raw table. The method set_function trig an error if
  values in the raw table (argument #2) are not callable. All these methods
  except get_variable trig an error if keys in the raw table (argument #2)
  already exist and overriding is not allowed by argument #3. The components for
  set_function must be callable, unless strict is 'false'. The metamethod names
  for set_metamethod must be one of the supported Lua metamethod name or the MAD
  specific __init metamethod name, unless strict is 'false'.

EXAMPLES
  Point = MAD.Object {}                -- point is an instance of Object
  p1 = Point { x=2, y=2 }              -- p1 is an instance of Point
  p1:set { x=1, z=3 }                  -- update p1.x and set p1.z
  p1:set { z2=\s 2*s.z }               -- set p1.z2 = 2*p1.z
  p1.z3=\s 3*s.z                       -- set p1.z3 = 3*p1.z
  p1:setf { zn=\s,n n*s.z }            -- set function p1:zn(n) = n*p1.z
  print(p1.x, p1.y, p1.z, p1.z2, p1.z3, p1:zn(4))
    1       2       3       6       9       12
  t = p1:get{'x','y','z','z2','z3'}    -- get variables values
  print(t.x, t.y, t.z, t.z2, t.z3)
    1       2       3       6       9
  t = p1:get(p1:getk())                -- get all variables values

SEE ALSO
  None.
]=]
M.__help.getk           = M.__help.get
M.__help.set            = M.__help.get
M.__help.setf           = M.__help.get
M.__help.setmm          = M.__help.get
M.__help.get_key        = M.__help.get
M.__help.set_variable   = M.__help.get
M.__help.set_function   = M.__help.get
M.__help.set_metamethod = M.__help.get

local function get_allkeys (self, level)
  assert(is_object(self) , "invalid argument #1 (object expected)")
  local var, key = self[var], {}

  while var ~= M and level > 0 do
    for k in pairs(var) do key[k] = k end
    level, self = level-1, parent(self)
    var = self[var]
  end

  for k in pairs(key) do
    key[#key+1], key[k] = key[k], nil
  end
  return key
end

local function get_variable (self, tbl, eval)
  assert(is_object(self) , "invalid argument #1 (object expected)")
  assert(is_rawtable(tbl), "invalid argument #2 (raw table expected)")
  local var, res = self[var], {}
  if eval ~= false
  then for _,k in ipairs(tbl) do res[k] = self[k] end
  else for _,k in ipairs(tbl) do res[k] = var [k] end
  end
  return res
end

local function set_variable (self, tbl, override)
  assert(is_object(self) , "invalid argument #1 (object expected)")
  assert(is_rawtable(tbl), "invalid argument #2 (raw table expected)")
  local var = self[var]
  for k,v in pairs(tbl) do
    assert(is_nil(rawget(var,k)) or override~=false, "cannot override variable")
    rawset(var, k, v)
  end
  return self
end

local function set_function (self, tbl, override, strict)
  assert(is_object(self) , "invalid argument #1 (object expected)")
  assert(is_rawtable(tbl), "invalid argument #2 (raw table expected)")
  local var = self[var]
  for k,f in pairs(tbl) do
    assert(is_callable(f) or strict==false, "invalid value (callable expected)")
    assert(is_nil(rawget(var,k)) or override~=false, "cannot override function")
    rawset(var, k, is_function(f) and fproxy(f) or f)
  end
  return self
end

local function set_metamethod (self, tbl, override, strict)
  assert(is_object(self) , "invalid argument #1 (object expected)")
  assert(is_rawtable(tbl), "invalid argument #2 (raw table expected)")
  local sm, pm = getmetatable(self), getmetatable(parent(self)) or MT
  if sm == pm then -- create a new metatable if shared with parent
    sm={} ; for k,v in pairs(pm) do sm[k] = v end
  end
  for k,mm in pairs(tbl) do
    assert(is_metaname(k) or strict==false, "invalid key (metamethod expected)")
    assert(is_nil(rawget(sm,k)) or override==true, "cannot override metamethod")
    rawset(sm, k, mm)
  end
  return setmetatable(self, sm)
end

-- debug

local function rawdump (self, file_, level_, indent_, vars_)
  local sv = self[var]
--  print('self.name=', self.name, 'self', self, 'var', sv, 'parent', parent(self))
  local file, level, indent, vars =
    file_ or io.stdout, level_ or 1e9, indent_ or 1, vars_ or {}
  -- header
  for i=1,indent-1 do file:write("  ") end -- indent
  file:write("+ [", tostring(sv), "]\n")
  -- variables
  for k,v in pairs(sv) do
    for i=1,indent do file:write("  ") end -- indent
    file:write(tostring(k))
        if is_string(v) then file:write(": '", tostring(v):sub(1,15), "'")
    elseif is_fproxy(v) then file:write(": [", tostring(v[fct]), "]")
                        else file:write(":  ", tostring(v)) end
    if vars[k] and string.sub(k,1,2) ~= '__' then -- mark overrides
      file:write(" (")
      for i=1,vars[k] do file:write('*') end
      file:write(")");
    end
    vars[k] = (vars[k] or 0)+1
    file:write("\n")
  end
  -- parent
  if level > 1 and sv ~= M then
    rawdump(parent(self), file, level-1, indent+1, vars)
  end
end

-- root Object = module

local Object = setmetatable({[var]=M, [rof]=true},MT)

 -- parent link
setmetatable(M, Object)

-- methods
M.is_readonly    = fproxy( is_readonly    )
M.is_instanceOf  = fproxy( is_instanceOf  )
M.set_readonly   = fproxy( set_readonly   )
M.get_allkeys    = fproxy( get_allkeys    )
M.get_variable   = fproxy( get_variable   )
M.set_variable   = fproxy( set_variable   )
M.set_function   = fproxy( set_function   )
M.set_metamethod = fproxy( set_metamethod )
M.rawdump        = fproxy( rawdump        )

-- aliases
M.get, M.getk, M.set, M.setf, M.setmm = M.get_variable, M.get_allkeys,
  M.set_variable, M.set_function, M.set_metamethod

-- members
M.__id   = 'Object'
M.__par  = parent
M.__var  = \s rawget(s,var) -- alias
M.name   = \s s.__id        -- alias
M.parent = \s s.__par       -- alias

-- end ------------------------------------------------------------------------o
return {
  Object        = Object,
  is_object     = is_object,
  is_readonly   = is_readonly,
  is_instanceOf = is_instanceOf,

  __help        = M.__help,
}
