--[=[
 o-----------------------------------------------------------------------------o
 |
 | Object module (object model)
 |
 | Methodical Accelerator Design - Copyright CERN 2015+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide an object model to support prototype-based programming with value
    semantic for functions stored in variables and further extensions.

 o-----------------------------------------------------------------------------o
]=]

local M = {}

-- locals ---------------------------------------------------------------------o

local is_nil, is_boolean, is_string, is_table, is_rawtable, is_function,
      is_metaname in MAD
local bset, btst, bclr, bnot in MAD.operator
local is_callable, is_iterable, is_mappable in MAD.concept

-- implementation -------------------------------------------------------------o

-- root of all objects
local Object

-- metatable of objects
local MT = {}

-- object members,
local var = {} -- key

-- reserved flags (bit num)
local flg = {} -- key
local flg_ro, flg_cl = 0, 1 -- flags for readonly and class

-- instance and metatable of 'incomplete objects' proxy
local var0 = setmetatable({}, {
  __index     := error "forbidden read access to incomplete object",
  __newindex  := error "forbidden write access to incomplete object",
  __metatable = false,
})

-- metatable of 'true functions' proxy
local fct = {} -- key

local MF = {
  __call      = \s,... -> rawget(s,fct)(...),
  __metatable = false,
}

-- helpers

local function init (a)
  local m = rawget(getmetatable(a), '__init')
  return m and m(a) or a
end

local function parent (a)
  return getmetatable(rawget(a,'__index'))
end

local function fproxy (f)
  return setmetatable({[fct]=f}, MF)
end

local function fclass (a)
  return btst(rawget(a,flg) or 0, flg_cl)
end

local function freadonly (a)
  return btst(rawget(a,flg) or 0, flg_ro)
end

local function is_fproxy (a)
  return is_table(a) and rawget(a,fct) ~= nil
end

local function is_object (a) -- exported
  return is_table(a) and rawget(a,var) ~= nil
end

local function is_class (a) -- exported
  return is_table(a) and fclass(a)
end

local function is_readonly (a) -- exported
  return is_table(a) and freadonly(a)
end

local function set_class (a) -- not exported
  rawset(a,flg, bset(rawget(a,flg) or 0, flg_cl))
  return a
end

-- metamethods

-- objects are proxies controlling variables access and inheritance
function MT:__call (a, b) -- object constructor (define the object-model)
  if is_string(a) then                                  -- named object
    if is_nil(b) then
      local obj = {__id=a, [var]=var0, __index=rawget(self,var)} -- proxy
      return setmetatable(obj, getmetatable(self))      -- incomplete object
    elseif is_rawtable(b) then
      local obj = {[var]=b, __index=rawget(self,var)}   -- proxy
      b.__id=a  setmetatable(b, obj)  set_class(self)   -- set fast inheritance
      return init(setmetatable(obj, getmetatable(self)))-- complete object
    end
  elseif is_rawtable(a) then
    if rawget(self,var) == var0 then                    -- finalize named object
      a.__id, self.__id = self.__id
      rawset(self,var, setmetatable(a, self));          -- set fast inheritance
      set_class(parent(self))
      return init(self)
    else                                                -- unnamed object
      local obj = {[var]=a, __index=rawget(self,var)}   -- proxy
      setmetatable(a, obj)  set_class(self)             -- set fast inheritance
      return init(setmetatable(obj, getmetatable(self)))-- complete object
    end
  end
  error(is_nil(b)
        and "invalid argument #1 to constructor (string or raw table expected)"
        or  "invalid argument #2 to constructor (raw table expected)")
end

function MT:__index (k)
  local v = rawget(self,var)[k]                      -- inheritance of variables
  if is_function(v)
  then return v(self)                            -- function with value semantic
  else return v end
end

function MT:__newindex (k, v)
  assert(not freadonly(self), "forbidden write access to readonly object")
  rawget(self,var)[k] = v
end

function MT:__len ()
  return #rawget(self,var)
end

function MT:__pairs ()
 return pairs(rawget(self,var))
end

function MT:__ipairs()
 return ipairs(rawget(self,var))
end

-- methods

local function set_readonly (a, b) -- exported
  assert(a ~= Object, "invalid argument #1 (forbidden access to 'Object')")
  assert(is_nil(b) or is_boolean(b),
                      "invalid argument #2 (boolean or nil expected)")
  if b ~= false
  then rawset(a,flg, bset(rawget(a,flg) or 0, flg_ro))
  else rawset(a,flg, bclr(rawget(a,flg) or 0, flg_ro)) end
  return a
end

local function is_instanceOf (a, b) -- exported
  assert(is_object(b), "invalid argument #2 (object expected)")
  if not is_object(a) then return false end
  while a and a ~= b do a = parent(a) end
  return a == b
end

local function get_raw (self, k)
  return rawget(rawget(self,var),k)    -- no inheritance nor function evaluation
end

local function get_variable (self, lst, eval)
  assert(is_object(self) , "invalid argument #1 (object expected)")
  assert(is_iterable(lst), "invalid argument #2 (iterable expected)")
  local var, res = rawget(self,var), {}
  if eval ~= false
  then for _,k in ipairs(lst) do res[k] = self[k] end
  else for _,k in ipairs(lst) do res[k] = var [k] end
  end
  return res
end

local function set_variable (self, tbl, override)
  assert(is_object(self) , "invalid argument #1 (object expected)")
  assert(is_mappable(tbl), "invalid argument #2 (mappable expected)")
  local var = rawget(self,var)
  for k,v in pairs(tbl) do
    assert(is_nil(rawget(var,k)) or override~=false, "cannot override variable")
    rawset(var, k, v)
  end
  return self
end

local function set_function (self, tbl, override, strict)
  assert(is_object(self) , "invalid argument #1 (object expected)")
  assert(is_mappable(tbl), "invalid argument #2 (mappable expected)")
  local var = rawget(self,var)
  for k,f in pairs(tbl) do
    assert(is_callable(f) or strict==false, "invalid value (callable expected)")
    assert(is_nil(rawget(var,k)) or override~=false, "cannot override function")
    rawset(var, k, is_function(f) and fproxy(f) or f)
  end
  return self
end

local function set_metamethod (self, tbl, override, strict)
  assert(is_object(self) , "invalid argument #1 (object expected)")
  assert(is_mappable(tbl), "invalid argument #2 (mappable expected)")
  local sm, pm = getmetatable(self), getmetatable(parent(self)) or MT
  if sm == pm then -- create new metatable if same as parent
    assert(not fclass(self), "invalid metatable (class unexpected)")
    sm={} for k,v in pairs(pm) do sm[k] = v end
  end
  for k,mm in pairs(tbl) do
    assert(is_metaname(k) or strict==false, "invalid key (metamethod expected)")
    assert(is_nil(rawget(sm,k)) or override==true, "cannot override metamethod")
    rawset(sm, k, mm)
  end
  return setmetatable(self, sm)
end

local function get_varkey (self, class, pattern)
  class, pattern = class or Object, pattern or ''
  assert(is_object(self)   , "invalid argument #1 (object expected)")
  assert(is_object(class)  , "invalid argument #2 (object expected)")
  assert(is_string(pattern), "invalid argument #3 (string expected)")
  local key = {}
  while self and self ~= class do
    for k in pairs(rawget(self,var)) do key[k] = k end
    self = parent(self)
  end
  assert(self == class, "invalid argument #2 (parent of argument #1 expected)")
  local res = {}
  for k in pairs(key) do
    if is_string(k) and string.find(k, pattern) then
      res[#res+1] = k
    end
  end
  return res
end

-- flags

local function set_flag (self, n)
  assert(is_object(self), "invalid argument #1 (object expected)")
  assert(n > flg_cl and btst(self.__flg, n), "invalid flag (reserved)")
  rawset(self,flg, bset(rawget(self,flg) or 0, n))
  return self
end

local function test_flag (self, n)
  assert(is_object(self), "invalid argument #1 (object expected)")
  return btst(rawget(self,flg) or 0, n)
end

local function clear_flag (self, n)
  assert(is_object(self), "invalid argument #1 (object expected)")
  assert(n > flg_cl and btst(self.__flg, n), "invalid flag (reserved)")
  rawset(self,flg, bclr(rawget(self,flg) or 0, n))
  return self
end

local function reserve_flag (self, n)
  assert(is_object(self), "invalid argument #1 (object expected)")
  assert(n > flg_cl and btst(self.__flg, n), "invalid flag (reserved)")
  self.__flg = bset(self.__flg, n)
  return self
end

-- environments

local env = {} -- key

local function open_env (self)
  assert(is_object(self), "invalid argument #1 (object expected)")
  assert(rawget(self,env) == nil, "invalid environment (already in use)")
  rawset(self, env, getfenv(2))
  setfenv(2, self)
  return self
end

local function used_env (self)
  assert(is_object(self), "invalid argument #1 (object expected)")
  return rawget(self,env) ~= nil
end

local function close_env (self)
  assert(is_object(self), "invalid argument #1 (object expected)")
  assert(rawget(self,env) ~= nil, "invalid environment (not open)")
  setfenv(2, rawget(self,env))
  rawset(self, env, nil)
  return self
end

local function dump_env (self) -- for debug
  for k,v in pairs(self) do
    if is_rawtable(v) then
      for k,v in pairs(v) do
        print(k,'=',v)
      end
    elseif is_object(v) then
      print(k,'=',v.name)
    else
      print(k,'=',v)
    end
  end
end

-- TODO: show (__tostring?) command...

-- debug

local function strdump (self, class, pattern)
  class, pattern = class or Object, pattern or ''
  assert(is_object(self)   , "invalid argument #1 (object expected)")
  assert(is_object(class)  , "invalid argument #2 (object expected)")
  assert(is_string(pattern), "invalid argument #3 (string expected)")
  local cnt, res, spc, str = {}, {}, ""
  while self and self ~= class do
    local vars = rawget(self,var)
    -- header
    str = rawget(vars, '__id') and (" '"..vars.__id.."'") or ""
    res[#res+1] = spc.."+ ["..tostring(vars).."]"..str
    spc = spc .. "  "
    -- variables
    for k,v in pairs(vars) do
      if is_string(k) and k ~= '__id' and string.find(k, pattern) then
        str = spc .. tostring(k)
            if is_string(v) then str = str..": '"..tostring(v):sub(1,15).."'"
        elseif is_fproxy(v) then str = str..": ["..tostring(rawget(v,fct)).."]"
        else                     str = str..":  "..tostring(v) end
        if cnt[k]
        then str = str.." ("..string.rep('*', cnt[k])..")" -- mark overrides
        else cnt[k] = 0 end
        cnt[k] = cnt[k] + 1
        res[#res+1] = str
      end
    end
    self = parent(self)
  end
  assert(self == class, "invalid argument #2 (parent of argument #1 expected)")
  res[#res+1] = ''
  return table.concat(res, '\n')
end

-- root Object variables = module
Object = setmetatable({[var]=M, [flg]=bset(0,flg_ro)},MT)

 -- parent link
setmetatable(M, Object)

-- methods
M.is_class       = fproxy( is_class       )
M.is_readonly    = fproxy( is_readonly    )
M.is_instanceOf  = fproxy( is_instanceOf  )
M.set_readonly   = fproxy( set_readonly   )
M.get_raw        = fproxy( get_raw        )
M.get_varkey     = fproxy( get_varkey     )
M.get_variable   = fproxy( get_variable   )
M.set_variable   = fproxy( set_variable   )
M.set_function   = fproxy( set_function   )
M.set_metamethod = fproxy( set_metamethod )
M.set_flag       = fproxy( set_flag       )
M.test_flag      = fproxy( test_flag      )
M.clear_flag     = fproxy( clear_flag     )
M.reserve_flag   = fproxy( reserve_flag   )
M.open_env       = fproxy( open_env       )
M.used_env       = fproxy( used_env       )
M.close_env      = fproxy( close_env      )
M.strdump        = fproxy( strdump        )

-- aliases
M.get, M.getk, M.set, M.setf, M.setmm = M.get_variable, M.get_varkey,
  M.set_variable, M.set_function, M.set_metamethod

M.fset, M.ftst, M.fclr = M.set_flag, M.test_flag, M.clear_flag

-- Object members
M.__id     = 'Object'
M.__flg    = bnot(0x3)
M.__par    = parent
M.__var    = \s rawget(s,var) -- alias
M.name     = \s s.__id        -- alias
M.parent   = \s s.__par       -- alias

-- help
M.__help = require 'madh_object'
MAD.utility.defhelp(M, 'object')

-- end ------------------------------------------------------------------------o
return {
  Object        = Object,
  is_class      = is_class,
  is_object     = is_object,
  is_readonly   = is_readonly,
  is_instanceOf = is_instanceOf,

  __help        = M.__help,
}
