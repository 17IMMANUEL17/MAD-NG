--[=[
 o-----------------------------------------------------------------------------o
 |
 | object module (object model)
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide an object model to support prototype-based programming with value
    semantic for functions stored in variables and further extensions.

 o-----------------------------------------------------------------------------o
]=]

local M = {}

-- locals ---------------------------------------------------------------------o

local is_nil, is_boolean, is_number, is_string, is_table, is_rawtable,
      is_function, is_functor, is_metaname,is_callable, is_iterable,
      is_mappable                                               in MAD.typeid
local bset, btst, bclr, bnot, band, bor, lshift, eq             in MAD.operator
local bsearch, lsearch, kpairs, openfile                        in MAD.utility
local functor                                                   in MAD.gfunc

-- implementation -------------------------------------------------------------o

-- Root of all objects, forward declaration
local object

-- object members
local _var = {} -- hidden key

-- reserved flags (bits)
local _flg = {} -- hidden key
local flg_ro, flg_cl = 0, 1 -- flags id for readonly and class
local flg_free = 2          -- used flags (0 - 1), free flags (2 - 31)

-- instance and metatable of 'incomplete objects' proxy
local var0 = setmetatable({}, {
  __index     := error("forbidden read access to incomplete object" , 2),
  __newindex  := error("forbidden write access to incomplete object", 2),
  __metatable  = false,
})

-- helpers

local function name (a)
  local var = rawget(a,_var)
  return rawget(var,'__id') or ('? <: ' .. var.__id)
end

local function init (a)
  local init = rawget(getmetatable(a), '__init')
  if init then return init(a) end
  return a
end

local function parent (a)
  return getmetatable(rawget(a,'__index'))
end

local function fclass (a)
  return btst(rawget(a,_flg) or 0, flg_cl)
end

local function freadonly (a)
  return btst(rawget(a,_flg) or 0, flg_ro)
end

local function set_class (a)
  rawset(a,_flg, bset(rawget(a,_flg) or 0, flg_cl))
  return a
end

local function is_object (a) -- exported
  return is_table(a) and rawget(a,_var) ~= nil
end

local function is_class (a) -- exported
  return is_table(a) and fclass(a)
end

local function is_instanceOf (a, b) -- exported
  if is_object(a) and is_class(b) then
    repeat a = parent(a) until not a or rawequal(a,b)
    return not not a
  end
  return false
end

-- metamethods

local MT = {}

-- objects are proxies controlling variables access and inheritance
function MT:__call (a, b) -- object constructor (define the object-model)
  if is_string(a) or is_nil(a) then                     -- [un]named object
    if is_nil(b) then
      local obj = {__id=a, [_var]=var0, __index=rawget(self,_var)} -- proxy
      return setmetatable(obj, getmetatable(self))      -- incomplete object
    elseif is_rawtable(b) then
      local obj = {[_var]=b, __index=rawget(self,_var)} -- proxy
      b.__id=a ; setmetatable(b, obj) ; set_class(self) -- set fast inheritance
      return init(setmetatable(obj, getmetatable(self)))-- complete object
    end
  elseif is_rawtable(a) then
    if rawget(self,_var) == var0 then                   -- finalize named object
      a.__id, self.__id = self.__id, nil
      rawset(self,_var, setmetatable(a, self));         -- set fast inheritance
      set_class(parent(self))
      return init(self)
    else                                                -- unnamed object
      local obj = {[_var]=a, __index=rawget(self,_var)} -- proxy
      setmetatable(a, obj) ; set_class(self)            -- set fast inheritance
      return init(setmetatable(obj, getmetatable(self)))-- complete object
    end
  end
  error(is_nil(b) and "invalid argument #1 (string or raw table expected)"
                  or  "invalid argument #2 (raw table expected)", 2)
end

local function raw_len (self)
  return rawlen(rawget(self,_var))    -- no inheritance
end

local function raw_get (self, k)
  return rawget(rawget(self,_var),k)  -- no inheritance nor function evaluation
end

local function raw_set (self, k, v)
  rawset(rawget(self,_var), k, v)     -- no protection!!
end

local function var_raw (self, k)
  return rawget(self,_var)[k]         -- no function evaluation with inheritance
end

local function var_val (self, k, v)   -- string key with value function
  if type(k) == 'string' and type(v) == 'function'
  then return v(self)
  else return v end
end

local function var_get (self, k) -- reusing var_raw and var_val kills the inlining
  local v = rawget(self,_var)[k]
  if type(k) == 'string' and type(v) == 'function'
  then return v(self)
  else return v end
end

function MT:__index (k)          -- reusing var_raw and var_val kills the inlining
  local v = rawget(self,_var)[k]
  if type(k) == 'string' and type(v) == 'function'
  then return v(self)
  else return v end
end

function MT:__newindex (k, v)
  if freadonly(self) or type(k) == 'string' and string.sub(k,1,2) == '__' then
    error("forbidden write access to '" .. name(self) ..
          "' (readonly object or variable)", 2)
  end
  rawget(self,_var)[k] = v      -- note: must use [k] for var0
end

function MT:__len ()
  local var = rawget(self,_var)
  if is_nil(var[1]) then return 0 end -- fast
  while is_nil(rawget(var,1)) do      -- slow
    var  = rawget(self,'__index')
    self = getmetatable(var)
  end
  return rawlen(var)
end

local function iter (var, key) -- scan only numbers and strings
  local k, v = next(var, key)
  while type(k) ~= 'string' and type(k) ~= 'number' and k do
    k, v = next(var, k)
  end
  return k, v
end

local function pairs_iter (self)
  return iter, rawget(self,_var), nil
end

local function ipairs_iter (self)
  return ipairs(rawget(self,_var))
end

MT.__pairs  =  pairs_iter
MT.__ipairs = ipairs_iter

function MT:__tostring()
  return string.format("object: '%s' %p", name(self), self)
end

-- methods

local function is_readonly (self)
  assert(is_object(self), "invalid argument #1 (object expected)")
  return freadonly(self)
end

local function set_readonly (self, set_)
  assert(is_object(self), "invalid argument #1 (object expected)")
  if set_ ~= false
  then rawset(self, _flg, bset(rawget(self,_flg) or 0, flg_ro))
  else rawset(self, _flg, bclr(rawget(self,_flg) or 0, flg_ro))
  end
  return self
end

local function get_variables (self, lst, noeval_)
  assert(is_object(self) , "invalid argument #1 (object expected)")
  assert(is_iterable(lst), "invalid argument #2 (iterable expected)")
  local n   = #lst
  local res = table.new(0,n)
  local get = noeval_ == true and var_raw or var_get
  for i=1,n do res[lst[i]] = get(self, lst[i]) end
  return res -- key -> val
end

local function set_variables (self, tbl, override_)
  assert(is_object(self)    , "invalid argument #1 (object expected)")
  assert(is_mappable(tbl)   , "invalid argument #2 (mappable expected)")
  assert(not freadonly(self), "forbidden write access to readonly object")
  local var = rawget(self,_var)
  local id  = rawget(var,'__id')
  for k,v in pairs(tbl) do
    assert(is_nil(rawget(var,k)) or override_ ~= false, "cannot override variable")
    var[k] = v
  end
  var.__id = id
  return self
end

local function wrap_variables (self, tbl)
  assert(is_object(self)    , "invalid argument #1 (object expected)")
  assert(is_mappable(tbl)   , "invalid argument #2 (mappable expected)")
  assert(not freadonly(self), "forbidden write access to readonly object")
  local var = rawget(self,_var)
  local id  = rawget(var,'__id')
  for k,f in pairs(tbl) do
    local v, newv = var[k]
    assert(not is_nil(v) , "invalid variable (nil value)")
    assert(is_callable(f), "invalid wrapper (callable expected)")
    if is_callable(v) then newv = f(v) else newv = f(\ v) end -- simplify user's side.
    if is_functor(v) and not is_functor(newv) then
      newv = functor(newv)                   -- newv must maintain v's semantic.
    end
    var[k] = newv
  end
  var.__id = id
  return self
end

local function set_methods (self, tbl, override_, strict_)
  assert(is_object(self)    , "invalid argument #1 (object expected)")
  assert(is_mappable(tbl)   , "invalid argument #2 (mappable expected)")
  assert(not freadonly(self), "forbidden write access to readonly object")
  local var = rawget(self,_var)
  local id  = rawget(var,'__id')
  for k,f in pairs(tbl) do
    assert(is_string(k), "invalid key (function name expected)")
    assert(is_callable(f) or strict_ == false, "invalid value (callable expected)")
    assert(is_nil(rawget(var,k)) or override_ ~= false, "cannot override function")
    var[k] = is_function(f) and functor(f) or f
  end
  var.__id = id
  return self
end

local function set_metamethods (self, tbl, override_, strict_)
  assert(is_object(self)    , "invalid argument #1 (object expected)")
  assert(is_mappable(tbl)   , "invalid argument #2 (mappable expected)")
  assert(not freadonly(self), "forbidden write access to readonly object")
  local sm, pm = getmetatable(self), getmetatable(parent(self)) or MT
  if sm == pm then -- create new metatable if same as parent
    assert(not fclass(self), "invalid metatable write access (unexpected class)")
    sm=table.new(0,8) for k,v in pairs(pm) do sm[k] = v end
    pm.__metatable = nil -- unprotect change
    setmetatable(self, sm)
    pm.__metatable, sm.__metatable = pm, sm
  end
  for k,mm in pairs(tbl) do
    assert(is_metaname(k) or strict_ == false, "invalid key (metamethod expected)")
    assert(is_nil(rawget(sm,k)) or override_ == true, "cannot override metamethod")
    sm[k] = mm
  end
  return self
end

local function final_err (self)
  error("invalid object creation ('"..name(self).."' is qualified as final)", 2)
end

local function set_final (self)
  return set_metamethods(self, {__call=final_err}, true)
end

local function get_varkeys (self, class_)
  assert(is_object(self)                    , "invalid argument #1 (object expected)")
  assert(is_nil(class_) or is_object(class_), "invalid argument #2 (object expected)")
  local lst, key = table.new(8,1), table.new(0,8)
  while self and not rawequal(self, class_) do
    for k,v in kpairs(self) do
      if not (key[k] or is_functor(v)) and is_string(k) and string.sub(k,1,2) ~= '__'
      then lst[#lst+1], key[k] = k, k
      end
    end
    self = parent(self)
  end
  assert(rawequal(self, class_),"invalid argument #2 (parent of argument #1 expected)")
  return lst
end

local function insert (self, idx_, val)
  assert(is_object(self)    , "invalid argument #1 (object expected)")
  assert(not freadonly(self), "forbidden write access to readonly object")
  table.insert(rawget(self,_var), idx_, val)
  return self
end

local function remove (self, idx_)
  assert(is_object(self)    , "invalid argument #1 (object expected)")
  assert(not freadonly(self), "forbidden write access to readonly object")
  return table.remove(rawget(self,_var), idx_)
end

local function move (self, idx1, idx2, idxto, dest_)
  dest_ = dest_ or self
  assert(is_object(self)     , "invalid argument #1 (object expected)")
  assert(is_object(dest_)    , "invalid argument #2 (object expected)")
  assert(not freadonly(dest_), "forbidden write access to readonly object")
  table.move(rawget(self,_var), idx1, idx2, idxto, rawget(dest_,_var))
  return dest_
end

local function sort (self, cmp_)
  assert(is_object(self)    , "invalid argument #1 (object expected)")
  assert(not freadonly(self), "forbidden write access to readonly object")
  table.sort(rawget(self,_var), cmp_)
  return self
end

local function bsearch_ (self, val, cmp_, low_, high_)
  assert(is_object(self), "invalid argument #1 (object expected)")
  return bsearch(rawget(self,_var), val, cmp_, low_, high_)
end

local function lsearch_ (self, val, equ_, low_, high_)
  assert(is_object(self), "invalid argument #1 (object expected)")
  return lsearch(rawget(self,_var), val, equ_, low_, high_)
end

local function clear_array (self)
  assert(is_object(self)    , "invalid argument #1 (object expected)")
  assert(not freadonly(self), "forbidden write access to readonly object")
  local var = rawget(self,_var)
  for i=1,rawlen(var) do var[i]=nil end
  return self
end

local function clear_variables (self)
  assert(is_object(self)    , "invalid argument #1 (object expected)")
  assert(not freadonly(self), "forbidden write access to readonly object")
  local var = rawget(self,_var)
  local id  = rawget(var,'__id')
  for k in kpairs(self) do var[k]=nil end
  var.__id = id
  return self
end

local function clear_all (self)
  assert(is_object(self)    , "invalid argument #1 (object expected)")
  assert(not freadonly(self), "forbidden write access to readonly object")
  local var = rawget(self,_var)
  local id  = rawget(var,'__id')
  for k in pairs_iter(self) do var[k]=nil end -- table.clear destroys all keys
  var.__id = id
  return self
end

-- inheritance

local function set_parent (self, newp)
  assert(is_object(self), "invalid argument #1 (object expected)")
  assert(is_object(newp), "invalid argument #2 (object expected)")
  if freadonly(self) then
    error("forbidden write access to readonly object '" .. name(self) .. "'", 2)
  end
  local spar = self.parent
  if getmetatable(newp) ~= getmetatable(spar) then
    error("new and current parent do not share same metamethods")
  end
  if newp.parent ~= spar.parent then
    error("new and current parent do not inherit from same direct parent")
  end
  rawset(self,'__index', rawget(newp,_var))
  set_class(newp)
  return self
end

-- copy

local function same (self, name_)
  assert(is_object(self)                  ,"invalid argument #1 (object expected)")
  assert(is_nil(name_) or is_string(name_),"invalid argument #2 (string expected)")
  -- same shares the same parent
  local par = parent(self)
  local sam = par(name_, {})
  -- metatable
  local sm, pm = getmetatable(self), getmetatable(par)
  if sm ~= pm then -- copy metatable
    local cm=table.new(0,8) for k,v in pairs(sm) do cm[k] = v end
    sm.__metatable = nil
    setmetatable(sam, cm)
    sm.__metatable, cm.__metatable = sm, cm
  end
  return sam
end

local function copy (self, name_)
  assert(is_object(self)                  ,"invalid argument #1 (object expected)")
  assert(is_nil(name_) or is_string(name_),"invalid argument #2 (string expected)")
  local cpy = same(self, name_ or raw_get(self,'__id'))
  local var, cvar = rawget(self,_var), rawget(cpy,_var)
  local id  = rawget(cvar,'__id')
  for k,v in pairs_iter(self) do cvar[k] = v end
  cvar.__id = id
  return cpy
end

MT.__same = same
MT.__copy = copy

-- flags

local flg_mask = lshift(-1, flg_free)
local flg_notmask = bnot(flg_mask)

local function test_flag (self, n)
  assert(is_object(self), "invalid argument #1 (object expected)")
  assert(is_number(n)   , "invalid argument #2 (number expected)")
  return btst(rawget(self,_flg) or 0, n)
end

local function set_flag (self, n)
  assert(is_object(self), "invalid argument #1 (object expected)")
  assert(is_number(n)   , "invalid argument #2 (number expected)")
  if n >= flg_free then
    rawset(self, _flg, bset(rawget(self,_flg) or 0, n))
  end
  return self
end

local function clear_flag (self, n)
  assert(is_object(self), "invalid argument #1 (object expected)")
  assert(is_number(n)   , "invalid argument #2 (number expected)")
  if n >= flg_free then
    rawset(self, _flg, bclr(rawget(self,_flg) or 0, n))
  end
  return self
end

local function get_flags (self)
  assert(is_object(self), "invalid argument #1 (object expected)")
  return rawget(self,_flg) or 0
end

local function test_flags (self, flags)
  assert(is_object(self) , "invalid argument #1 (object expected)")
  assert(is_number(flags), "invalid argument #2 (number expected)")
  return band(rawget(self,_flg) or 0, flags) ~= 0
end

local function set_flags (self, flags)
  assert(is_object(self) , "invalid argument #1 (object expected)")
  assert(is_number(flags), "invalid argument #2 (number expected)")
  flags = band(flags, flg_mask)
  rawset(self, _flg, bor(rawget(self, _flg) or 0, flags))
  return self
end

local function clear_flags (self, flags)
  assert(is_object(self) , "invalid argument #1 (object expected)")
  assert(is_number(flags), "invalid argument #2 (number expected)")
  flags = band(flags, flg_mask)
  rawset(self, _flg, band(rawget(self, _flg) or 0, bnot(flags)))
  return self
end

-- environments

local _env = {} -- hidden key

local function open_env (self, ctx_)
  assert(is_object(self), "invalid argument #1 (object expected)")
  assert(is_nil(ctx_) or is_function(ctx_) or is_number(ctx_) and ctx_ >= 1,
                          "invalid argument #2 (not a function or < 1)")
  ctx_ = is_function(ctx_) and ctx_ or is_number(ctx_) and ctx_+1 or 2
  assert(is_nil(rawget(self,_env)), "invalid environment (already open)")
  rawset(self, _env, { ctx=ctx_, env=getfenv(ctx_) })
  rawset(self, self.__id, self) -- self reference
  setfenv(ctx_, self)
  return self
end

local function is_open_env (self)
  assert(is_object(self), "invalid argument #1 (object expected)")
  return not is_nil(rawget(self,_env))
end

local function reset_env (self) -- if an error occurs while in the environment
  assert(is_object(self), "invalid argument #1 (object expected)")
  rawset(self, _env, nil)
  rawset(self, self.__id, nil) -- clear self reference
  return self
end

local function close_env (self)
  assert(is_object(self), "invalid argument #1 (object expected)")
  local env = rawget(self,_env)
  assert(not is_nil(env), "invalid environment (not open)")
  setfenv(env.ctx, env.env)
  return reset_env(self)
end

local function dump_env (self) -- for debug
  for k,v in pairs(rawget(self,_var)) do
    if is_rawtable(v) then
      for k,v in pairs(v) do
        print(k,'=',v)
      end
    elseif is_object(v) then
      print(k,'=',name(v))
    else
      print(k,'=',v)
    end
  end
end

-- I/O ------------------------------------------------------------------------o

-- dump obj members (including controlled inheritance)
local function dumpobj (self, filnam_, class_, pattern_)
  if is_object(filnam_) and is_nil(pattern_) then
    filnam_, class_, pattern_ = nil, filnam_, class_ -- right shift
  end
  if is_string(class_) and is_nil(pattern_) then
    class_, pattern_ = nil, class_                   -- right shift
  end

  class_, pattern_ = class_ or object, pattern_ or ''
  assert(is_object(self)    , "invalid argument #1 (object expected)")
  assert(is_object(class_)  , "invalid argument #3 (object expected)")
  assert(is_string(pattern_), "invalid argument #4 (string expected)")

  local tostring in MAD
  local n, cnt, res, spc, str = 0, {}, {}, ""
  while self and not rawequal(self, class_) do
    local var = rawget(self,_var)
    -- header
    local id = rawget(var, '__id')
    n, str = n+1, id and (" '" .. id .. "'") or ""
    res[n] = spc .. "+ " .. tostring(self)
    spc = spc .. "   "
    -- variables
    for k,v in kpairs(self) do
      if is_string(k) and string.sub(k,1,2) ~= '__' and string.find(k,pattern_) then
        str = spc .. tostring(k)
        if is_string(v) then
          str = str .. " : '" .. tostring(v):sub(1,15) .. "'"
        elseif is_function(v) then
          str = str .. " := " .. tostring(v(self))
        else
          str = str .. " :  " .. tostring(v)
        end
        if cnt[k]
        then str = str .. " (" .. string.rep('*', cnt[k]) .. ")" -- mark overrides
        else cnt[k] = 0
        end
        cnt[k], n = cnt[k]+1, n+1
        res[n] = str
      end
    end
    self = parent(self)
  end
  assert(rawequal(self, class_), "invalid argument #2 (parent of argument #1 expected)")

  -- return result as a string
  if filnam_ == '-' then return table.concat(res, '\n') end

  -- dump to file
  local file = openfile(filnam_, 'w', '.dat')
  for _,s in ipairs(res) do file:write(s,'\n') end
  if is_string(filnam_) then file:close() else file:flush() end

  return self
end

-- members --------------------------------------------------------------------o

M.__id  = 'object'
M.__par = parent
M.first_free_flag = flg_free

-- methods
M.is_class        = functor( is_class        )
M.is_readonly     = functor( is_readonly     )
M.is_instanceOf   = functor( is_instanceOf   )

M.set_parent      = functor( set_parent      )
M.set_readonly    = functor( set_readonly    )
M.set_final       = functor( set_final       )

M.get_varkeys     = functor( get_varkeys     )
M.get_variables   = functor( get_variables   )
M.set_variables   = functor( set_variables   )
M.wrap_variables  = functor( wrap_variables  )

M.set_methods     = functor( set_methods     )
M.set_metamethods = functor( set_metamethods )

M.insert          = functor( insert          )
M.remove          = functor( remove          )
M.move            = functor( move            )
M.sort            = functor( sort            )
M.bsearch         = functor( bsearch_        )
M.lsearch         = functor( lsearch_        )
M.clear_array     = functor( clear_array     )
M.clear_variables = functor( clear_variables )
M.clear_all       = functor( clear_all       )

M.same            = functor( same            )
M.copy            = functor( copy            )

M.raw_len         = functor( raw_len         )
M.raw_get         = functor( raw_get         )
M.raw_set         = functor( raw_set         )

M.var_raw         = functor( var_raw         )
M.var_val         = functor( var_val         )
M.var_get         = functor( var_get         )

M.set_flag        = functor( set_flag        )
M.test_flag       = functor( test_flag       )
M.clear_flag      = functor( clear_flag      )
M.get_flags       = functor( get_flags       )
M.set_flags       = functor( set_flags       )
M.test_flags      = functor( test_flags      )
M.clear_flags     = functor( clear_flags     )

M.open_env        = functor( open_env        )
M.reset_env       = functor( reset_env       )
M.close_env       = functor( close_env       )
M.is_open_env     = functor( is_open_env     )

M.dumpobj         = functor( dumpobj         )

-- aliases
M.parent = parent
M.name   = \s -> s.__id
M.set    = M.set_variables
M.get    = M.get_variables

-- env ------------------------------------------------------------------------o

MAD.typeid.is_class      = is_class
MAD.typeid.is_object     = is_object
MAD.typeid.is_instanceOf = is_instanceOf

-- metatables -----------------------------------------------------------------o

-- root object variables = module
object = setmetatable({[_var]=M}, MT)

 -- parent link
setmetatable(M, object)

-- protect against changing metatable
MT.__metatable = MT

-- set as readonly
object:set_readonly()

-- end ------------------------------------------------------------------------o
return {
  object = object,
  -- __help = require 'madh_object',
}
