--[=[
 o-----------------------------------------------------------------------------o
 |
 | Object module (object model)
 |
 | Methodical Accelerator Design - Copyright CERN 2015+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide an object model to support prototype-based programming with value
    semantic for functions stored in variables and further extensions.

 o-----------------------------------------------------------------------------o
]=]

local M = { __help = {} }

-- help -----------------------------------------------------------------------o

M.__help.self = [=[
NAME
  object -- creates objects

SYNOPSIS
  obj1 = Object {}               -- create a new empty object
  obj2 = Object { ... }          -- create a new object with values
  obj3 = Object 'name' { ... }   -- create a new object with name and values
  obj4 = obj3 'name' { ... }     -- create a new object from parent (class)

DESCRIPTION
  The object module implements the necessary machinery to support prototype-
  based programming with value semantic for functions and further extensions:
  - On read, the lookup of values and functions follows the inheritance down to
    Object with the following precedence: immediate methods (object), variables,
    inherited methods (parent). If the retrieved value is a function, it is
    called with self passed as argument #1 (can be ignored) and the result is
    returned (i.e. function with value semantic).
  - On write, the value is simply stored in the current object (no lookup). To
    override this behavior, just (re)defined the __newindex metamethod using
    set_metamethod with allowed overriding (use with care!).
  - On build, the new instance is connected to its parent (inheritance). If the
    new instance has a defined __init metamethod (shared), it will be called on
    the new instance and non-nil result or the new instance will be returned.
    This feature is particularly useful to copy immediate methods to new
    instances.
  - To set:
    + variables (multi set), use set_variable.
    + functions with arguments or avoid value semantic, use set_function.
    + immediate methods (inherited), use set_method.
    + metamethods (shared), use set_metamethod.
    + set, setf, setm, setmm are shortcuts for set_variable, set_function,
      set_method, set_metamethod.
  - Root 'Object' defines the following variables:
    + 'name'  points to 'self' name unless overridden (alias)
    + '__par' points to 'self' parent unless overridden (alias)
    + '__var' points to 'self' variables unless overridden (alias)
    + '__id'  holds 'self' name if provided (variable)
  - Each object inherits the following methods:
    #, name, is_object, is_instanceOf, isa, set, setf, setm, setmm,
    set_variable, set_function, set_method, set_metamethod, set_parent, dump.

RETURN VALUES
  A table constaining Object, the root constructor of objects, and the helpers
  is_object and is_instanceOf for function-like usage in case the argument #1
  might not be a valid object.

ERROR
  Objects constructors trig an error if the optional argument #1 (name) is not a
  string or if the argument #1 (if a name is provided) or #2 is not a raw table.
  Using an object incompletely initialized (e.g. with a name but no value) trigs
  also an error.

EXAMPLES
  Point = MAD.Object {}          -- point is an instance of Object
  p1 = Point { x=2, y=2 }        -- p1 is an instance of Point
  p2 = p1 { x=3 }                -- p2 is an instance of p1 and inherits p1.y
  p1.x, p1.z = 1, 3              -- set p1.x, p1.z
  print(p1.x, p1.y, p1.z)        -- print 1 2 3
  print(p2.x, p2.y, p2.z)        -- print 3 1 3

SEE ALSO
  None.
]=]

-- documentation --------------------------------------------------------------o

M.__help.object_model_scheme = [=[

Schematic object-model representation:
--------------------------------------

  o0 = MAD.Object
  o1 = o0 'obj1' {*o1-var*}
  o2 = o1 'obj2' {*o2-var*}
  o3 = o1 'obj3' {*o3-var*}
                                               +-------------+
                             +---------------+>| *meta-tbl*  |<------------+
+---------+                  |   +---------+ | | metamethods | +---------+ |
|  *o2*   |                  |   |  *o1*   | | +-------------+ |  *o0*   | |
|  [meta] |------------------+   |  [meta] |-+                 |  [meta] |-+
|   [par] |------------------|-->|   [par] |------------------>|   [par] |--->.
| __index |------------------|-+ | __index |-----------------+ | __index |--->.
|         |  +-----------+   | | |         |  +-----------+  | |         |
|   [var] |->|  *o2-var* |   | | |   [var] |->| *o1-var*  |  | |   [var] |-+
| methods |  |    [meta] |-+ | | | methods |  |    [meta] |-+| | methods | |
+---------+  | variables | | | | +---------+  | variables | || +---------+ |
     ^       +-----------+ | | |      ^       +-----------+ ||        +----+
     +---------------------+ | |      |             ^       ||        v
+---------+                  | |      +-------------|-------+|  +-----------+
|  *o3*   |                  | |      |             |        |  | *o0-var*  |
|  [meta] |------------------+ |      |             |        +->|    [meta] |->.
|   [par] |--------------------|------+             |           | variables |
| __index |--------------------+--------------------+           +-----------+
|         |  +-----------+
|   [var] |->| *o3-var*  |
| methods |  |    [meta] |-+
+---------+  | variables | |
     ^       +-----------+ |
     +---------------------+
]=]
-- For details, see the 3 lines of the 'unamed obj' compound statement in __call
-- constructor

-- examples -------------------------------------------------------------------o

M.__help.object_model_examples = [=[

Catching creation:
------------------
  Example how to count the number of objects created

  local count = 0
  local function set_counter (self)
    local mm = function (self)
      count = count + 1
      return self
    end
    self:set_metamethod { __init = mm }
  end
  set_counter(MAD.Object) -- before any child creation

Catching writes:
----------------
  Example how to set a notification-on-write with logging

  local function set_notification (self)
    local nwidx = rawget(getmetatable(self),'__newindex')
    local mm = function (self, k, v)
      trace(self, k, v) -- logging
      nwidx(self, k, v) -- forward, mandatory!
    end
    self:set_metamethod({__newindex = mm}, true) -- override!
  end
  set_notification(MAD.Object) -- before any child creation
]=]

-- locals ---------------------------------------------------------------------o

local is_nil, is_string, is_table, is_rawtable, is_function, is_callable
      in require 'madl_utils'

-- implementation -------------------------------------------------------------o

-- metamethods
local meta = { -- from lj_obj.h + __init
  '__add', '__call', '__concat', '__div', '__eq', '__gc', '__index', '__init',
  '__ipairs', '__le', '__len', '__lt', '__metatable', '__mod', '__mode',
  '__mul', '__new', '__newindex', '__pairs', '__pow', '__sub', '__tostring',
  '__unm',
}
for _,v in ipairs(meta) do meta[v]=v end -- build dictionary

-- special protected keys to store parent and object members
local par, var, var0 = {}, {}, setmetatable({}, {
  __index    := error "incomplete object initialization",
  __newindex := error "incomplete object initialization",
})

-- metatable of objects
local MT = {}

-- metatable of 'true functions' proxy
local MTF = {
  __call      = \t,... -> t[1](...),
  __index    := error       "function object",
  __newindex := error "const function object",
}

-- helpers

local function is_proxy (a)
  return is_table(a) and getmetatable(a) == MTF
end

local function is_object (a)
  return is_table(a) and rawget(a,var) ~= nil
end

local function is_instanceOf (a, b)
  assert(is_object(b), "invalid argument #2 (object expected)")
  if not is_object(a) then return false end
  while a and a ~= b do a = rawget(a,par) end
  return a == b
end

local function get (self, k) -- object lookup
  return self and (rawget(self,k) or get(rawget(self,par),k))
end

-- objects are proxies controlling variables access and inheritance

local function init(a)
  local m = rawget(getmetatable(a), '__init')
  return m and m(a) or a
end

function MT:__call (a) -- object constructor (define the object-model)
  if is_string(a) then -- named object
    local obj = {__id=a, [par]=self, [var]=var0, __index=self[var]} -- proxy
    return setmetatable(obj, getmetatable(self)) -- incomplete object
  elseif is_rawtable(a) then
    if self[var] == var0 then -- finalize named object
      if rawget(self,'__id') ~= nil then a.__id, self.__id = self.__id end
      self[var] = setmetatable(a, self); -- set fast inheritance
      return init(self)
    else -- unnamed object
      local obj = {[par]=self, [var]=a, __index=self[var]} -- proxy
      setmetatable(a, obj)                               -- set fast inheritance
      return init(setmetatable(obj, getmetatable(self))) -- complete object
    end
  end
  error("invalid argument #1 to object constructor (string or table expected)")
end

function MT:__index (k) -- (+eval+inheritance)
  local v = self[var][k]                       -- inheritance of variables
  if is_function(v) then return v(self)        -- function with value semantic
  else return v or get(rawget(self,par),k) end -- inheritance of methods
end

function MT:__newindex (k, v)
  self[var][k] = v
end

function MT:__len   () return #self[var]        end
function MT:__pairs () return pairs(self[var])  end
function MT:__ipairs() return ipairs(self[var]) end

-- object methods

M.__help.isa = [=[
NAME
  is_object, is_instanceOf, isa.       -- identify object parent

SYNOPSIS
  is_object(obj)

  isa(obj,class)
  is_instanceOf(obj,class)

  obj:isa(class)
  obj:is_instanceOf(class)

DESCRIPTION
  Method is_instanceOf follows and check the objects hierarchy from obj down to
  class. Function is_object(obj) is equivalent to is_instanceOf(obj, Object) but
  faster. Method isa is an alias for is_instanceOf.

RETURN VALUES
  is_object, is_instanceOf return true if obj inherits from Object or class
  respectively.

ERROR
  is_instanceOf trig an error if the argument #2 (class) is not a valid object.

EXAMPLES
  local is_object, is_instanceOf, Object in MAD
  print( is_object 'yes' )                    -- false
  print( is_object(Object) )                  -- true
  print( is_object(Object {}) )               -- true

  print( is_instanceOf('yes', Object) )       -- false
  print( is_instanceOf(Object, Object) )      -- true
  print( is_instanceOf(Object {},Object) )    -- true

SEE ALSO
  None.
]=]
M.__help.is_object     = M.__help.isa
M.__help.is_instanceOf = M.__help.isa

M.is_instanceOf = is_instanceOf
M.isa           = is_instanceOf

M.__help.set = [=[
NAME
  set_variable, set_function, set_method, set_metamethod.
  set, setf, setm, setmm.

SYNOPSIS
  set_variable  (obj, {...} [, override])
  set_function  (obj, {...} [, override])
  set_method    (obj, {...} [, override])
  set_metamethod(obj, {...} [, override])

  obj:set_variable  ({...} [, override])
  obj:set_function  ({...} [, override])
  obj:set_method    ({...} [, override])
  obj:set_metamethod({...} [, override])

DESCRIPTION
  The set_variable method sets or updates values from a raw table. The
  set_function method sets functions in a special way to bypass the automatic
  value semantic of the object model and enforce the call semantic. The
  set_method method sets functions as immediate methods that can be inherited by
  children (see the 'On read' semantic in the object model). The set_metamethod
  method sets functions as metamethods that are shared by children (see the
  object model scheme). Metamethods names must be one of the supported Lua
  metamethod or the MAD specific __init metamethod. Methods set, setf, setm and
  setmm are valid shortcuts for set_variable, set_function, set_method,
  set_metamethod respectively. The default value for override is 'false' for all
  methods except set and set_variable, for which this is 'true'.

RETURN VALUE
  The object.

ERRORS
  All these methods trig an error if argument #1 is not a valid object. Methods
  set_variable, set_function, set_method and set_metamethod trig an error if
  argument #2 is not a raw table. Methods set_function, set_method and
  set_metamethod trig an error if values in the raw table (argument #2) are not
  callable. All these methods trig an error if keys in the raw table (argument
  #2) already exist and overriding is not allowed by argument #3.

EXAMPLES
  Point = MAD.Object {}                -- point is an instance of Object
  p1 = Point { x=2, y=2 }              -- p1 is an instance of Point
  p1:set { x=1, z=3 }                  -- update p1.x and set p1.z
  p1:set { z2=\s 2*s.z }               -- set p1.z2 = 2*p1.z
  p1.z3=\s 3*s.z                       -- set p1.z3 = 3*p1.z
  p1:setf { zn=\s,n n*s.z }            -- set function p1:zn(n) = n*p1.z
  print(p1.x, p1.y, p1.z, p1.z2, p1.z3, p1:zn(4))
    1       2       3       6       9       12

SEE ALSO
  None.
]=]
M.__help.setf           = M.__help.set
M.__help.setm           = M.__help.set
M.__help.setmm          = M.__help.set
M.__help.set_variable   = M.__help.set
M.__help.set_function   = M.__help.set
M.__help.set_method     = M.__help.set
M.__help.set_metamethod = M.__help.set

function M:set_variable (tbl, override)
  assert(is_object(self) , "invalid argument #1 (object expected)")
  assert(is_rawtable(tbl), "invalid argument #2 (raw table expected)")
  local var = self[var]
  for k,v in pairs(tbl) do
    assert(is_nil(rawget(var,k)) or override~=false, "cannot override function")
    var[k] = v
  end
  return self
end

function M:set_function (tbl, override)
  assert(is_object(self) , "invalid argument #1 (object expected)")
  assert(is_rawtable(tbl), "invalid argument #2 (raw table expected)")
  local var = self[var]
  for k,f in pairs(tbl) do
    assert(is_callable(f), "invalid component (callable expected)")
    assert(is_nil(rawget(var,k)) or override==true, "cannot override function")
    var[k] = is_function(f) and setmetatable({f}, MTF) or f
  end
  return self
end

function M:set_method (tbl, override)
  assert(is_object(self) , "invalid argument #1 (object expected)")
  assert(is_rawtable(tbl), "invalid argument #2 (raw table expected)")
  for k,m in pairs(tbl) do
    assert(meta[k] ~= k  , "invalid key (metamethod detected)")
    assert(is_callable(m), "invalid component (callable expected)")
    assert(is_nil(rawget(self,k)) or override==true, "cannot override method")
    rawset(self, k, m)
  end
  return self
end

function M:set_metamethod (tbl, override)
  assert(is_object(self) , "invalid argument #1 (object expected)")
  assert(is_rawtable(tbl), "invalid argument #2 (raw table expected)")
  local sm, pm = getmetatable(self), getmetatable(rawget(self,par))
  if sm == pm then -- create a new metatable if shared with parent
    sm={} ; for _,v in ipairs(meta) do sm[v] = pm[v] end
  end
  for k,mm in pairs(tbl) do
    assert(meta[k] == k  , "invalid key (metamethod expected)")
    assert(is_callable(mm), "invalid component (callable expected)")
    assert(is_nil(rawget(sm,k)) or override==true, "cannot override metamethod")
    rawset(sm, k, mm)
  end
  return setmetatable(self, sm)
end

M.set   = M.set_variable
M.setf  = M.set_function
M.setm  = M.set_method
M.setmm = M.set_metamethod

M.__help.set_parent = [=[
NAME
  set_parent.

SYNOPSIS
  set_parent(obj, class [, 'name'])
  obj:set_parent(class [, 'name'])

DESCRIPTION
  The set_parent method changes or sets the parent (class) of a valid object or
  a raw table and optionally set its name. This method is _not_ equivalent to
  the constructor of objects because the raw table will become the object, not
  the values. This method is better suited to turn a module with methods into an
  object.

RETURN VALUE
  The object.

ERRORS
  The set_parent function trigs an error if the argument #1 is not a valid
  object or a raw table, or it is Object, and if the argument #2 is not a valid
  object.

EXAMPLES
  MAD.set_parent({...}, Object, 'myobject')

SEE ALSO
  None.
]=]

function M:set_parent (class, name)
  assert(self ~= M       , "'Object' must stay the root of objects")
  assert(is_object(self) or is_rawtable(self),
                           "invalid argument #1 (raw table or object expected)")
  assert(is_object(class), "invalid argument #2 (object expected)")
  rawset(self, par, class)
  rawset(self, '__index', class[var])
  if is_rawtable(self) then
    rawset(self, var, setmetatable({__id=name},self))
  end
  setmetatable(self, getmetatable(class))
  return self
end

-- debug

function M:dump (file_, level_, indent_, vars_)
  local sv = self[var]
  local file, level, indent, vars =
    file_ or io.stdout, level_ or 1e6, indent_ or 1, vars_ or {}
  -- header
  for i=1,indent-1 do file:write("  ") end -- indent
  file:write("+ [", tostring(sv), "]\n")
  -- variables
  for k,v in pairs(sv) do
    for i=1,indent do file:write("  ") end -- indent
    file:write(tostring(k))
        if is_string(v) then file:write(": '", tostring(v)   , "'")
    elseif is_proxy (v) then file:write(": [", tostring(v[1]), "]")
                        else file:write(":  ", tostring(v)) end
    if vars[k] and string.sub(k,1,2) ~= '__' then -- mark overrides
      file:write(" (")
      for i=1,vars[k] do file:write('*') end
      file:write(")");
    end
    vars[k] = (vars[k] or 0)+1
    file:write("\n")
  end
  -- parent
  if level > 1 and self ~= M then
    self[par]:dump(file, level-1, indent+1, vars)
  end
end

-- root Object = module

M[var] = {
  __id ='Object',
  __par=\s rawget(s,par), -- alias
  __var=\s rawget(s,var), -- alias
  name =\s s.__id,        -- alias
}

-- end ------------------------------------------------------------------------o
return {
  Object        = setmetatable(M,MT){},
  is_object     = is_object,
  is_instanceOf = is_instanceOf,
}
