--[=[
 o-----------------------------------------------------------------------------o
 |
 | Generic math module
 |
 | Methodical Accelerator Design - Copyright CERN 2015+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Extends math module and provides object-oriented dispatch to math functions.
  - Defines the 'format' for printing numbers.

 o-----------------------------------------------------------------------------o
]=]

local M = { __help = {} }

-- help -----------------------------------------------------------------------o

M.__help.self = [=[
NAME
  gmath -- generic math functions and constants

SYNOPSIS
  eps, huge, tiny, I, inf, Inf, nan, NaN, pi, Pi,                    (constants)
  angle, abs, ceil, floor, round, frac, trunc, sqrt,         (generic functions)
  exp, log, log10, sin, cos, tan, asin, acos, atan, sinh, cosh, tanh,
  acosh, asinh, atanh, erf, tgamma, lgamma,
  carg, real, imag, conj, norm, unit, proj, rect,    (generic complex functions)
  polar,
  unm, add, sub, mul, div, mod, pow,                    (operators as functions)
  eq, ne, lt, le, gt, ge,
  atan2, ldexp, frexp, fpow, fmod, modf, max, min,       (non-generic functions)
  sign, step, sinc, deg, rad, random, randomseed.

DESCRIPTION
  The module gmath provides generic functions that wraps common math functions
  with object-oriented dispatch for non-numbers. It also adds few useful
  constants, functions and generic functions. The generic function
  angle(x,y) is equivalent to atan2(y,x) (for numbers only). The generic
  functions trunc and frac are equivalent to first(modf(x)) and second(modf(x))
  respectively (for numbers only). All operators have binary generic functions
  wrappers except unm (unary minus).

RETURN VALUE
  A table constaining these functions and constants.

ERROR
  See ISO/IEC 9899:1999 (and ISO/IEC 9899:2011).

SEE ALSO
  math, complex.
]=]

M.__help['Trigonometric mnemonics'] = [=[
Trigonometric mnemonics:
------------------------

deg      0      30     45     60     90
rad      0     pi/6   pi/4   pi/3   pi/2
sin     √0/2   √1/2   √2/2   √3/2   √4/2
cos     √4/2   √3/2   √2/2   √1/2   √0/2   sin(90 - angle)
tan     0/√3   1/√3    1     √3/1   √3/0   sin/cos

45   : square 1-1  , diag.  √2  , hypot 1 -> sides √2/2
30-60: equil. 1-1-1, height √3/2, hypot 1 -> sides 1/2 and √3/2
]=]

-- locals ---------------------------------------------------------------------o

local _C                 in require 'madl_cmad'
local is_number, defhelp in require 'madl_utils'
local first, second      in require 'madl_gfunc'

local abs, acos, asin, atan, atan2, ceil, cos, cosh, deg, exp, floor, fmod,
      frexp, huge, ldexp, log, log10, max, min, modf, pi, pow, rad, random,
      randomseed, sin, sinh, sqrt, tan, tanh in math

-- t={}; for k in pairs(math) do t[#t+1]=k end;
-- table.sort(t); print(table.concat(t,', '))

-- implementation -------------------------------------------------------------o

-- constants
M.eps  = 2.2204460492503130e-16
M.huge = 1.7976931348623158e+308
M.tiny = 2.2250738585072012e-308

M.I    = 1i
M.inf  = 1/0
M.Inf  = 1/0
M.nan  = 0/0
M.NaN  = 0/0
M.pi   = pi
M.Pi   = pi

-- generic functions
M.angle = \x,y -> is_number(x) and atan2(y,x) or x:angle(y)
M.abs   = \x   -> is_number(x) and abs(x)     or x:abs()

M.ceil  = \x -> is_number(x) and ceil (x)        or x:ceil ()
M.floor = \x -> is_number(x) and floor(x)        or x:floor()
M.round = \x -> is_number(x) and (x>0 and floor(x+0.5) or x<0 and ceil(x-0.5) or x) or x:round()
M.frac  = \x -> is_number(x) and second(modf(x)) or x:frac ()
M.trunc = \x -> is_number(x) and first (modf(x)) or x:trunc()

M.sqrt  = \x -> is_number(x) and sqrt (x) or x:sqrt ()
M.exp   = \x -> is_number(x) and exp  (x) or x:exp  ()
M.log   = \x -> is_number(x) and log  (x) or x:log  ()
M.log10 = \x -> is_number(x) and log10(x) or x:log10()

M.sin   = \x -> is_number(x) and sin  (x) or x:sin  ()
M.cos   = \x -> is_number(x) and cos  (x) or x:cos  ()
M.tan   = \x -> is_number(x) and tan  (x) or x:tan  ()
M.sinh  = \x -> is_number(x) and sinh (x) or x:sinh ()
M.cosh  = \x -> is_number(x) and cosh (x) or x:cosh ()
M.tanh  = \x -> is_number(x) and tanh (x) or x:tanh ()

M.asin  = \x -> is_number(x) and asin (x) or x:asin ()
M.acos  = \x -> is_number(x) and acos (x) or x:acos ()
M.atan  = \x -> is_number(x) and atan (x) or x:atan ()
M.asinh = \x -> is_number(x) and _C.mad_num_asinh(x) or x:asinh()
M.acosh = \x -> is_number(x) and _C.mad_num_acosh(x) or x:acosh()
M.atanh = \x -> is_number(x) and _C.mad_num_atanh(x) or x:atanh()

M.erf   = \x -> is_number(x) and _C.mad_num_erf(x)    or x:erf()
M.tgamma= \x -> is_number(x) and _C.mad_num_tgamma(x) or x:tgamma()
M.lgamma= \x -> is_number(x) and _C.mad_num_lgamma(x) or x:lgamma()

-- complex generic functions
M.carg  = \x -> is_number(x) and (x>=0 and 0 or x<0 and pi or x) or x:carg()
M.real  = \x -> is_number(x) and x                               or x:real()
M.imag  = \x -> is_number(x) and 0                               or x:imag()
M.conj  = \x -> is_number(x) and x                               or x:conj()
M.norm  = \x -> is_number(x) and abs(x)                          or x:norm()
M.unit  = \x -> is_number(x) and x/abs(x)                        or x:unit()
M.proj  = \x -> is_number(x) and (x+0i):proj()                   or x:proj()
M.rect  = \x -> is_number(x) and abs(x)                          or x:rect()
M.polar = \x -> is_number(x) and abs(x)+M.carg(x)*1i             or x:polar()

-- non-generic functions
M.atan2      = atan2
M.ldexp      = ldexp
M.frexp      = frexp
M.fpow       = pow
M.fmod       = fmod
M.modf       = modf
M.max        = max
M.min        = min
M.deg        = deg
M.rad        = rad
M.random     = random
M.randomseed = randomseed

M.sign  = \x -> x>=0 and 1 or x<0 and -1 or x
M.step  = \x -> x>=0 and 1 or x<0 and  0 or x
M.sinc  = \x -> abs(x)<1e-10 and 1 or sin(x)/x

-- operators
M.unm   = \x   -> -x
M.add   = \x,y ->  x + y
M.sub   = \x,y ->  x - y
M.mul   = \x,y ->  x * y
M.div   = \x,y ->  x / y
M.mod   = \x,y ->  x % y
M.pow   = \x,y ->  x ^ y

-- logical
M.eq    = \x,y -> x == y
M.ne    = \x,y -> x ~= y
M.lt    = \x,y -> x <  y
M.le    = \x,y -> x <= y
M.gt    = \x,y -> x >  y
M.ge    = \x,y -> x >= y

-- end ------------------------------------------------------------------------o
return defhelp(M)
