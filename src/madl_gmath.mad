--[=[
 o-----------------------------------------------------------------------------o
 |
 | Generic math module
 |
 | Methodical Accelerator Design - Copyright CERN 2015+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Extends math module and provides object-oriented dispatch to math functions.
  - Defines the 'format' for printing numbers.

 o-----------------------------------------------------------------------------o
]=]

local M = { __help = {} }

-- help -----------------------------------------------------------------------o

M.__help.self = [=[
NAME
  gmath -- generic math functions and constants

SYNOPSIS
  abs, acos, asin, atan, ceil, cos, cosh, deg, exp, floor, log,
  log10, max, min, modf, rad, sin, sinh, sqrt, tan, tanh,    (generic functions)
  atan2, fmod, frexp, ldexp, random, randomseed,         (non-generic functions)
  acosh, angle, asinh, atanh, erf, frac, gamma, lgamma,
  round, sign, sinc, step, trunc,                      (extra generic functions)
  unm, add, sub, mul, div, mod, pow,
  eq, ne, lt, le, gt, ge,                               (operators as functions)
  carg, real, imag, conj, norm, rect, polar,         (generic complex functions)
  eps, huge, tiny, I, inf, Inf, nan, NaN, pi, Pi,                    (constants)
  option { format }.                                                     (setup)

DESCRIPTION
  The module gmath provides generic functions that wraps common math functions
  with object-oriented dispatch for non-numbers. It also adds few useful
  constants, functions, generic functions and options. The function angle is the
  generic function for atan2. The generic function frac returns the values of
  the function modf swapped (fractional part first). All operators as functions
  are binary functions except unm (unary minus). The function angle is the only
  generic function accepting two arguments. The functions min and max are the
  only generic functions accepting a variable number of arguments.

RETURN VALUE
  A table constaining these functions and constants.

ERROR
  See ISO/IEC 9899:1999 (and ISO/IEC 9899:2011).

SEE ALSO
  math, complex.
]=]

-- locals ---------------------------------------------------------------------o

local _C              in require 'madl_cmad'
local is_number, swap in require 'madl_utils'
local istype          in require 'ffi'
local format          in string

local
  abs, acos, asin, atan, ceil, cos, cosh, deg, exp, floor, log, log10, max,
  min, modf, rad, sin, sinh, sqrt, tan, tanh,             -- (generic functions)
  atan2, fmod, frexp, ldexp, random, randomseed,       -- (functions wo generic)
  pow,                                               -- (operators as functions)
  huge, pi in math                                                -- (constants)

-- t={}; for k in pairs(math) do t[#t+1]=k end;
-- table.sort(t); print(table.concat(t,', '))

-- implementation -------------------------------------------------------------o

-- options
M.option = {
  format = "%.16g",
}

-- constants
M.eps  = 2.2204460492503131e-16
M.huge = 1.7976931348623158e+308
M.tiny = 2.2250738585072012e-308

M.I    = 1i
M.inf  = 1/0
M.Inf  = 1/0
M.nan  = 0/0
M.NaN  = 0/0
M.pi   = pi
M.Pi   = pi

-- functions
M.randomseed = randomseed
M.random     = random
M.atan2      = atan2
M.ldexp      = ldexp
M.frexp      = frexp
M.fmod       = fmod

-- generic unary functions
M.abs   = \x -> is_number(x) and abs  (x)  or x:abs  ()
M.acos  = \x -> is_number(x) and acos (x)  or x:acos ()
M.asin  = \x -> is_number(x) and asin (x)  or x:asin ()
M.atan  = \x -> is_number(x) and atan (x)  or x:atan ()
M.ceil  = \x -> is_number(x) and ceil (x)  or x:ceil ()
M.cos   = \x -> is_number(x) and cos  (x)  or x:cos  ()
M.cosh  = \x -> is_number(x) and cosh (x)  or x:cosh ()
M.deg   = \x -> is_number(x) and deg  (x)  or x:deg  ()
M.exp   = \x -> is_number(x) and exp  (x)  or x:exp  ()
M.floor = \x -> is_number(x) and floor(x)  or x:floor()
M.log   = \x -> is_number(x) and log  (x)  or x:log  ()
M.log10 = \x -> is_number(x) and log10(x)  or x:log10()
M.rad   = \x -> is_number(x) and rad  (x)  or x:rad  ()
M.sin   = \x -> is_number(x) and sin  (x)  or x:sin  ()
M.sinh  = \x -> is_number(x) and sinh (x)  or x:sinh ()
M.sqrt  = \x -> is_number(x) and sqrt (x)  or x:sqrt ()
M.tan   = \x -> is_number(x) and tan  (x)  or x:tan  ()
M.tanh  = \x -> is_number(x) and tanh (x)  or x:tanh ()

M.modf  = \x => if is_number(x) then return modf(x) else return x:modf() end end

M.asinh = \x -> is_number(x) and _C.mad_num_asinh(x)  or x:asinh()
M.acosh = \x -> is_number(x) and _C.mad_num_acosh(x)  or x:acosh()
M.atanh = \x -> is_number(x) and _C.mad_num_atanh(x)  or x:atanh()

M.erf   = \x -> is_number(x) and _C.mad_num_erf(x)    or x:erf()
M.gamma = \x -> is_number(x) and _C.mad_num_gamma(x)  or x:gamma()
M.lgamma= \x -> is_number(x) and _C.mad_num_lgamma(x) or x:lgamma()

-- generic binary functions
M.angle = \x,y -> is_number(x) and atan2(x,y) or x:angle(y)
--M.mod = \x,y -> is_number(x) and fmod (x,y) or x:mod  (y)
--M.pow = \x,y -> is_number(x) and pow  (x,y) or x:pow  (y)

-- generic variadic functions
M.max   = \x,... -> is_number(x) and max(x,...) or x:max(...)
M.min   = \x,... -> is_number(x) and min(x,...) or x:min(...)

-- extra generic functions
M.sign  = \x -> is_number(x) and (x<0 and -1 or 1) or x:sign()
M.step  = \x -> is_number(x) and (x<0 and  0 or 1) or x:step()
M.sinc  = \x -> is_number(x) and (abs(x)<1e-10 and 1 or sin(x)/x) or x:sinc()
M.frac  = \x -> swap(M.modf(x))
M.trunc = \x -> is_number(x) and (x<0 and ceil(x) or floor(x)) or x:trunc()
M.round = \x -> is_number(x) and (x<0 and ceil(x-0.5) or floor(x+0.5)) or x:round()

-- operators
M.unm   = \x   -> -x
M.add   = \x,y ->  x + y
M.sub   = \x,y ->  x - y
M.mul   = \x,y ->  x * y
M.div   = \x,y ->  x / y
M.mod   = \x,y ->  x % y
M.pow   = \x,y ->  x ^ y

-- logical
M.eq    = \x,y -> x == y
M.ne    = \x,y -> x ~= y
M.lt    = \x,y -> x <  y
M.le    = \x,y -> x <= y
M.gt    = \x,y -> x >  y
M.ge    = \x,y -> x >= y

-- complex generic functions
M.carg  = \x -> is_number(x) and (x<0 and pi or 0) or x:carg()
M.real  = \x -> is_number(x) and x                 or x:real()
M.imag  = \x -> is_number(x) and 0                 or x:imag()
M.conj  = \x -> is_number(x) and x                 or x:conj()
M.norm  = \x -> is_number(x) and abs(x)            or x:norm()
M.rect  = \x -> is_number(x) and x                 or x:rect()
M.polar = \x -> is_number(x) and x                 or x:polar()

-- end ------------------------------------------------------------------------o
return M
