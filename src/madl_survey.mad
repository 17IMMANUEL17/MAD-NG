--[=[
 o-----------------------------------------------------------------------------o
 |
 | Survey module
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - TODO

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local vector, matrix, element, mtable, command                   in MAD

local is_sequence, is_boolean, is_number, is_integer,
      is_table, is_callable, is_mappable, is_matrix              in MAD.typeid
local fnone, ffalse, ftrue, functor, chain, achain               in MAD.gfunc
local action                                                     in MAD.symint
local tblcat, errorf                                             in MAD.utility
local minlen, minang                                             in MAD.constant

local abs, min in math

local is_implicit = element.drift.is_implicit

-- integrator schemes ---------------------------------------------------------o

local thinonly, thickonly, driftonly                             in MAD.symint

-- geometric maps -------------------------------------------------------------o

local str_drift, tlt_thin, tlt_thick                             in MAD.geomap

local xrotation, yrotation, srotation, translate,
      changeref, changedir, changenrj                            in MAD.geomap

-- debug ----------------------------------------------------------------------o

local nodump = true

local function mdump(str, ...)
  if nodump then return end
  print(str, ...)
end

-- element tracking -----------------------------------------------------------o

local function trackelm (elm, mflw, track, thick, thin)
  local tlt = elm.tilt
  local mis = mflw.misalign
  mflw.etlt = tlt

  changeref(elm, mflw,  mis)
  track    (elm, mflw,   1 , thick, thin)
  changeref(elm, mflw, -mis)
end

-- kinds ----------------------------------------------------------------------o

local function track_marker (elm, mflw)
  mdump('\ntrack_marker', elm.name, 'l=', elm.l)

  mflw.etlt = 0
  thinonly(elm, mflw, 1, nil, fnone)
end

local function track_drift (elm, mflw)
  mdump('\ntrack_drift', elm.name, 'l=', elm.l)

  local l in elm
  mflw.el = l

  local thick = abs(l) >= minlen and thickonly or driftonly

  if is_implicit(elm) then
    mflw.etlt = 0
    local track = mflw.implicit and thick or driftonly
    track(elm, mflw, 1, str_drift)
  else
    trackelm(elm, mflw, thick, str_drift, nil)
  end
end

local function track_thin (elm, mflw)
  mdump('\ntrack_thin', elm.name, 'l=', elm.l, 'angle=', elm.angle, 'tilt=', elm.tilt)

  local l, angle, tilt in elm
  mflw.el, mflw.ang, mflw.etlt = l, angle, tilt
  trackelm(elm, mflw, thinonly, nil, tlt_thin)
end

local function track_thick (elm, mflw)
  mdump('\ntrack_thick', elm.name, 'l=', elm.l, 'angle=', elm.angle, 'tilt=', elm.tilt)

  local l, angle, tilt in elm
  mflw.el, mflw.ang, mflw.etlt = l, angle, tilt
  local thick = abs(l) >= minlen and thickonly or driftonly
  trackelm(elm, mflw, thick, tlt_thick, nil)
end

-- load maps into elements ----------------------------------------------------o

local invalid = \e ->
  errorf("invalid survey element %s of kind %s with length %s",
         e.name, e.kind, e.l)

local E = element

-- warning: class protection set by alt. 'nolookup' object model can be BYPASSED
--          because classes are modified before any use of 'survey' attribute
--          by any children at the time of module loading...

-- kind maps

E. thin_element:setv({ survey = functor( track_thin   ) }, 'init')
E.drift_element:setv({ survey = functor( track_drift  ) }, 'init')
E.thick_element:setv({ survey = functor( track_thick  ) }, 'init')
E.specl_element:setv({ survey = functor( track_marker ) }, 'init')
E.patch_element:setv({ survey = functor( invalid      ) }, 'init') -- avoid missing definition
E.extra_element:setv({ survey = functor( invalid      ) }, 'init') -- forbidden in track

-- patches

E.xrotation:setv({ survey = functor( xrotation ) }, 'init')
E.yrotation:setv({ survey = functor( yrotation ) }, 'init')
E.srotation:setv({ survey = functor( srotation ) }, 'init')
E.translate:setv({ survey = functor( translate ) }, 'init')
E.changeref:setv({ survey = functor( changeref ) }, 'init')
E.changedir:setv({ survey = functor( changedir ) }, 'init')
E.changenrj:setv({ survey = functor( changenrj ) }, 'init')

-- survey mtable --------------------------------------------------------------o

local function save_dat (elm, mflw, lw, islc)
  local name, kind, angle, tilt in elm
  local A, V, ds, sdir, tdir, spos, turn, mtbl, relative, mapsave in mflw
  local x, y, z      = V[1], V[2], V[3]
  local th, phi, psi = A[1], A[2], A[3]

  local lw = relative and lw*islc or islc<0 and -1-islc or lw*islc
  local dsw = ds*lw

  local W = mapsave and mflw.W:copy()

  -- keep order!
  mtbl = mtbl + { name, kind, spos+dsw, dsw, angle*lw*sdir, tilt*sdir,
                  x, y, z, th, phi, psi, psi+tilt*sdir, islc, turn, tdir, W }
  return true
end

local function save_imp (elm, mflw, lw, islc)
  if not elm:is_implicit() then
    return save_dat(elm, mflw, lw, islc)
  end
  return false
end

local function save_obs (elm, mflw, lw, islc)
  if elm:is_observed() and mflw.turn % mflw.observe == 0 then
    return save_dat(elm, mflw, lw, islc)
  end
  return false
end

local header = {
  'direction', 'observe', 'implicit', 'relative',
}

local function make_mtable (self, obs)
  local title, range, nturn, dir, implicit, relative, mapsave in self
  local sequ, nrow = self.sequence

  if obs > 0 then
    nrow = nturn+1 -- assume 1 observation point per turn
  else
    nrow = sequ:length_of(range, nturn)*(implicit and 2 or 1)
  end

  -- keep order!
  return mtable 'survey' {
    title=title or sequ.name, type='survey', header=header, reserve=nrow,
    direction=dir, observe=obs, implicit=implicit, relative=relative,
    {'name'}, 'kind', 's', 'l', 'angle', 'tilt',
    'x', 'y', 'z', 'theta', 'phi', 'psi', 'globaltilt',
    'slc', 'turn','tdir',  -- t-direction of the tracking: sdir * seq.dir
    mapsave and 'W' or nil -- optional column to save the orientation matrix
  }
end

-- trace survey internal actions ----------------------------------------------o

local act2str = {
  [fnone   ] = 'fnone'   , [ftrue   ] = 'ftrue'   , [ffalse  ] = 'ffalse',
  [save_dat] = 'save_all', [save_imp] = 'save_imp', [save_obs] = 'save_obs',
}

local function trace_action (mflw)
  local atentry, atslice, atexit, ataper, atsave in mflw

  local estr = act2str[atentry] or 'usrdef'
  local sstr = act2str[atslice] or 'usrdef'
  local xstr = act2str[atexit ] or 'usrdef'
  local ostr = act2str[atsave ] or 'usrdef'

  trace(2, "survey actions: atentry=%s, atslice=%s, atexit=%s, atsave=%s",
           estr, sstr, xstr, ostr)
end

-- survey mflow ---------------------------------------------------------------o

local function make_mflow (self)
  -- check sequence
  local sequ = assert(self.sequence, "missing sequence")
  assert(is_sequence(sequ), "invalid sequence")

  -- build iterator (track direction)
  local range, dir, nturn in self
  local iter, state, init = sequ:siter(range, nturn, dir)

  -- saving data, build mtable
  local save, observe, implicit, relative in self
  if is_boolean(observe) then observe = observe and 1 or 0 end
  assert(is_boolean(save)    , "invalid save (boolean expected)")
  assert(is_boolean(implicit), "invalid implicit (boolean expected)")
  assert(is_boolean(relative), "invalid relative (boolean expected)")
  assert(is_integer(observe) and observe >= 0
                             , "invalid observe (positive integer expected)")

  -- sequence and time direction
  local edir = sequ.dir
  local tdir = dir*edir
  assert(tdir == 1 or tdir == -1, "invalid time direction (1 or -1 expected)")

  -- setup default sclicing
  local nslice in self
  local nslc = is_number(nslice) and nslice or is_table(nslice) and #nslice
  assert(is_integer(nslc) and nslc > 0,
         "invalid nslice (positive integer or array of slice weights expected)")

  -- setup default misalign
  local misalign in self
  assert(is_integer(misalign) and misalign >= 0,
         "invalid misalign (positive integer expected)")

  -- retrieve default actions (avoid evaluation in case of functions)
  local atentry = self:var_raw 'atentry'
  local atslice = self:var_raw 'atslice'
  local atexit  = self:var_raw 'atexit'
  local atsave  = self:var_raw 'atsave'

  assert(is_callable(atentry), "invalid atentry (callable expected)")
  assert(is_callable(atslice), "invalid atslice (callable expected)")
  assert(is_callable(atexit ), "invalid atexit (callable expected)")
  assert(is_callable(atsave ), "invalid atsave (callable expected)")

  -- chain atsave, atentry, atslice and atexit to fill table (if not disabled)
  local mtbl, fill
  if save then
    mtbl = make_mtable(self, observe)

    if atsave ~= ffalse then
      fill = observe  >  0    and save_obs or
             implicit ~= true and save_imp or save_dat

      atsave = (atsave == fnone or atsave == ftrue) and
                fill or achain(fill, atsave)
      atexit = (atexit == fnone or atexit == ftrue) and atsave or
                atexit ~= ffalse and chain(atexit, atsave) or atexit
      if atentry == ftrue then atentry = atsave end
      if atslice == ftrue then atslice = chain(atslice, action('atsave')) end
    end
  end

  if fill ~= save_dat then implicit = false end

  -- retrieve initial conditions
  local s0, X0, A0, W0, mapsave in self
  assert(is_number  (s0)    , "invalid s0 (number expected)")
  assert(is_mappable(X0)    , "invalid X0 (mappable expected)")
  assert(is_mappable(A0)    , "invalid A0 (mappable expected)")
  assert(is_boolean(mapsave), "invalid mapsave (boolean expected)")

  if W0 then
    assert(is_matrix(W0), "invalid W0 (matrix expected)")
    A0[1], A0[2], A0[3] = W0:torotmad(A0[1], A0[2], A0[3])
  end

  -- precedence of initial conditions
  local mflw = table.new(0,50)

  local x   = X0[1] or X0.x
  local y   = X0[2] or X0.y
  local z   = X0[3] or X0.z
  local the = A0[1] or A0.theta
  local phi = A0[2] or A0.phi
  local psi = A0[3] or A0.psi

  -- complete mflow
  mflw.sequ=sequ             -- current sequence
  mflw.mtbl=mtbl             -- current mtable (nil if no save)
  mflw.sdir=dir              -- s-direction of tracking
  mflw.tdir=tdir             -- t-direction of tracking
  mflw.edir=edir             -- current element direction
  mflw.eidx=init             -- current element index
  mflw.turn=1                -- current turn index

  mflw.s0=s0                 -- initial s-position (i.e. offset)
  mflw.ds=nil                -- s-length of results (signed)
  mflw.spos=nil              -- s-position of results (signed)
  mflw.nslc=nslc             -- number of slices for each element
  mflw.nslice=nslice         -- slices for each element
  mflw.misalign=misalign     -- 0 none, 1 main, 2 +error

  mflw.save=save             -- save data
  mflw.observe=observe       -- save observed elements every n turns
  mflw.implicit=implicit     -- save also implicit elements
  mflw.relative=relative     -- save length of slices

  mflw.atentry=atentry       -- action when entering an element
  mflw.atslice=atslice       -- action after each element slices
  mflw.atexit=atexit         -- action when exiting an element
  mflw.atsave=atsave         -- action after saving in mtable

  mflw.usrdef=self.usrdef    -- user defined data

  mflw.mapsave=mapsave       -- save orientation matrix

  -- global frame (exposed vars)
  mflw.V=vector(3):fill{x,y,z}         -- displacement vector
  mflw.W=matrix(3):rotmad(the,phi,psi) -- orientation matrix (rotations)
  mflw.A=vector(3):fill{the,phi,psi}   -- oriented angles

  -- internal vars for survey (varying states) --

  -- for processing elements local frame
  mflw.__edat = setmetatable({
    el=0,                    -- current element length
    ang=0,                   -- current element angle
    etlt=0,                  -- current element tilt angle
    eslc=0,                  -- current element number of slices
    R=vector(3),             -- displacement vector
    S=matrix(3),             -- orientation matrix (rotations)
    T=matrix(3),             -- transformation matrix if tilted
    U=vector(3),             -- temporary vector for calculations
  }, {__index=mflw})

  -- for processing sequence elements by nstep
  mflw.__sitr={iter=iter, state=state} -- sequence iterator state

  return mflw
end

-- survey command -------------------------------------------------------------o

local _id = {} -- identity

local function exec (self)
  local mflw, mtbl

  -- retrieve or build mflw (and mtbl)
  if self.mflow then
    assert(self.mflow.__surv == _id, "invalid mflow (survey mflow expected)")
    mflw = self.mflow
  else
    mflw = make_mflow(self)
    mflw.__surv = _id
  end
  mtbl = mflw.mtbl

  -- check number of element to track
  local nstep in self
  if nstep == 0 then return mtbl, mflw end

  -- retrieve information
  local s0, eidx, sequ, atentry, atexit in mflw
  local iter, state in mflw.__sitr
  local ne = #sequ

  -- debug actions setup
  if MAD.option.debug >= 2 then trace_action(mflw) end

  -- geometric tracking
  for ei,elm,spos,ds in iter, state, eidx do
    mflw.eidx = ei ; mflw.spos = s0+spos ; mflw.ds = ds
    atentry   (elm, mflw.__edat, 0, -1)
    elm:survey(     mflw.__edat       )
    atexit    (elm, mflw.__edat, 0, -2)

    -- check for end of turn
    if ei == ne then mflw.turn = mflw.turn + 1 end
    -- check remaining number of element to track
    nstep = nstep-1
    if nstep == 0 then return mtbl, mflw, ei end
  end

  return mtbl, mflw
end

local _na, _nyi -- not applicable, not yet implemented

local survey = command 'survey' {
  beam=_na,         -- N/A                                                (mflw)
  sequence=nil,     -- sequence (required)                                (mflw)
  range=nil,        -- range of tracking                                  (iter)
  dir=1,            -- s-direction of tracking (1 or -1)                  (mflw)

  s0=0,             -- initial s                                          (mflw)
  X0={0,0,0},       -- initial coordinates x, y, z                        (mflw)
  A0={0,0,0},       -- initial angles theta, phi, psi                     (mflw)
  W0=nil,           -- initial W matrix (compagnion of X0)                (mflw)

  mapdef=_na,       -- always use matrix formalism (i.e. true)            (mflw)
  mapsave=false,    -- save the orientation matrix W (rotations)          (mflw)

  nturn=1,          -- number of turns                                    (iter)
  nstep=-1,         -- number of elements to track                        (iter)
  nslice=1,         -- number of slice for each element                   (mflw)
  model=_na,        -- N/A                                                (mflw)
  method=_na,       -- N/A                                                (mflw)
  totalpath=_na,    -- N/A                                                (mflw)
  radiate=_na,      -- N/A                                                (mflw)
  misalign=0,       -- 0 none, 1 main, 2 +error                           (mflw)

  save=true,        -- create mtable and save results                     (mtbl)
  title=nil,        -- title of mtable (default seq.name)                 (mtbl)
  implicit=true,    -- save also in implicit elements                     (mtbl)
  relative=false,   -- save length of slices instead from element start   (mtbl)
  observe=false,    -- save only in observed elements (every n turns)     (mtbl)

  atentry=fnone,    -- action called when entering an element             (mflw)
  atslice=fnone,    -- action called after each element slices            (mflw)
  atexit=fnone,     -- action called when exiting an element              (mflw)
  ataper=_na,       -- N/A                                                (mflw)
  atsave=fnone,     -- action called after saving in mtable               (mflw)

  usrdef=nil,       -- user defined data attached to the mflow            (mflw)

  mflow=nil,        -- mflow, exclusive with other attributes except nstep
  exec=exec,        -- command to execute upon children creation
} :set_readonly()   -- reference survey command is readonly

-- end ------------------------------------------------------------------------o
return { survey = survey }
