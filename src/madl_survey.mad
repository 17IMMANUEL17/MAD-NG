--[=[
 o-----------------------------------------------------------------------------o
 |
 | Survey module
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - TODO

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local vector, matrix, element, mtable, command, object          in MAD
local fnone                                                     in MAD.gfunc
local is_sequence, is_boolean, is_number, is_integer,
      is_callable, is_mappable, is_implicit                     in MAD.typeid
local errorf                                                    in MAD.utility
local test_flag                                                 in object
local abs                                                       in math

-- geometric maps -------------------------------------------------------------o

local geomap = require "madl_geomap"

-- integrator schemes ---------------------------------------------------------o

local symint = require 'madl_symint'
local integr = symint.thick

-- special --------------------------------------------------------------------o

local invalid = \e ->
  errorf("invalid element %s of kind %s with length %s", e.name, e.kind, e.l)

-- load maps into elements of element module ----------------------------------o

local E = element

E. thin_element :set_methods { survey = geomap.thin  }
E.drift_element :set_methods { survey = geomap.drift }
E.thick_element :set_methods { survey = geomap.thick }
E.extra_element :set_methods { survey = invalid }

E.special       :set_methods { survey = fnone   }
E.patch         :set_methods { survey = invalid }

E.srotation     :set_methods { survey = geomap.srotation }
E.xrotation     :set_methods { survey = geomap.xrotation }
E.yrotation     :set_methods { survey = geomap.yrotation }
E.translate     :set_methods { survey = geomap.translate }
E.changedir     :set_methods { survey = geomap.changedir }
E.changeref     :set_methods { survey = geomap.changeref }

-- survey command -------------------------------------------------------------o

local _srv = {}

local function save_all (elm, mflw)
  local name, kind, l, angle, tilt in elm

  if not is_implicit(elm) then
    local A, W in mflw
    A[1], A[2], A[3] = W:torotmad(A[1], A[2], A[3])
  end

  local V, A, dir, sdir, spos, mtbl in mflw
  local x, y, z      = V[1], V[2], V[3]
  local th, phi, psi = A[1], A[2], A[3]

  -- keep order!
  mtbl = mtbl + { name, kind, spos+l*dir, l, angle*sdir, tilt,
                  x, y, z, th, phi, psi, psi+tilt*sdir, sdir }
end

local function save_elm (elm, mflw)
  if not is_implicit(elm) then save_all(elm, mflw) end
end

local function make_mtable (self)
  local range, nturn in self
  local sequ = self.sequence
  local dir  = self.dir or 1 -- direction of the tracking
  local nrow = 2*sequ:length_of(range, nturn)

  return mtable 'survey' {
    type='survey', title=sequ.name, direction=dir, reserve=nrow,
    {'name'}, 'kind', 's', 'l', 'angle', 'tilt',
    'x', 'y', 'z', 'theta', 'phi', 'psi', 'globaltilt',
    'sdir', -- s-direction of the tracking: self.dir * sequ.dir
  }
end

local function make_mflow (self)
  if self.mflow then
    assert(self.mflow[_srv] == _srv, "invalid mflow (survey mflow expected)")
    return self.mflow
  end

  -- check sequence
  local sequ = assert(self.sequence, "missing sequence")
  assert(is_sequence(sequ), "invalid sequence")
  local seqdir = sequ.direction
  assert(is_number(seqdir) and abs(seqdir) == 1,
         "invalid sequence direction (1 or -1 expected)")

  -- retrieve initial conditions
  local x0, y0, z0, theta0, phi0, psi0, X0, A0 in self
  assert(is_mappable(X0), "invalid X0 (mappable expected)")
  assert(is_mappable(A0), "invalid A0 (mappable expected)")

  local x     = x0     or X0.x     or X0[1] or 0
  local y     = y0     or X0.y     or X0[2] or 0
  local z     = z0     or X0.z     or X0[3] or 0
  local theta = theta0 or A0.theta or A0[1] or 0
  local phi   = phi0   or A0.phi   or A0[2] or 0
  local psi   = psi0   or A0.psi   or A0[3] or 0

  -- build iterator
  local range, dir, nturn in self
  local iter, state, init = sequ:siter(range, nturn, dir)

  -- build mtable
  local save, implicit in self
  assert(is_boolean(save) or is_callable(save),
         "invalid save (boolean or callable expected)")

  local mtbl, fill
  if save then
    mtbl = make_mtable(self)
    fill = is_callable(save) and save or implicit and save_all or save_elm
  else
    fill = fnone
  end

  -- setup default sclicing
  local nslice, noslice in self
  assert(is_integer(nslice) and nslice > 0, "invalid nslice (positive integer expected)")
  assert(is_boolean(noslice)              , "invalid noslice (boolean expected)")
  nslice = noslice and 1 or nslice

  -- retrieve default actions
  local atentry, atslice, atexit in self
  atentry = atentry or fnone
  atslice = atslice or fnone
  atexit  = atexit  or fnone
  assert(is_callable(atentry), "invalid atentry (callable expected)")
  assert(is_callable(atslice), "invalid atslice (callable expected)")
  assert(is_callable(atexit ), "invalid atexit (callable expected)")

  -- build mflow
  return {
    sequ=sequ,                         -- current sequence
    mtbl=mtbl,                         -- current mtable (nil if no save)
    dir=dir,                           -- direction of tracking
    sdir=dir*seqdir,                   -- s-direction of tracking

    fill=fill,                         -- fill/add one row to mtable (if any)
    nslice=nslice,                     -- number of slice for each element
    noslice=noslice,                   -- nslice=1 with highest precedence

    idx=init,                          -- index of the current element
    spos=0,                            -- s-position of the current element
    npos=nil,                          -- integrator step: nil, 'first', 'last'

    atentry=atentry,                   -- action when entering an element
    atslice=atslice,                   -- action after each element slices
    atexit =atexit,                    -- action when exiting an element

    -- global frame (see geomap)
    V=vector(3):fill{x,y,z},           -- displacement vector
    W=matrix(3):rotmad(theta,phi,psi), -- orientation matrix (rotations)
    A=vector(3):fill{theta,phi,psi},   -- oriented angles (for output)

    -- local frame (see geomap) at element slices or exit
    R=vector(3),                       -- displacement vector
    S=matrix(3),                       -- orientation matrix (rotations)
    T=matrix(3),                       -- transformation matrix if tilted
    U=vector(3),                       -- temporary vector

    -- internal vars for survey
    __iter=iter, __state=state,        -- iterator and iteraror state
    [_srv]=_srv                        -- hidden key
  }
end

local function exec (self)
  -- build mflow
  local mflw = make_mflow(self)

  -- retrieve information
  local nstep in self
  local idx, __iter, __state in mflw
  local mtbl, fill, atentry, atexit in mflw

  if nstep == 0 then return mtbl, mflw end

  -- geometric tracking
  for i,elm,spos in __iter, __state, idx do
    mflw.idx, mflw.spos = i, spos
    atentry(elm, mflw)
    integr (elm, mflw, 1, elm.survey)
    atexit (elm, mflw)
    fill   (elm, mflw)

    -- check remaining number of element to track
    nstep = nstep-1
    if nstep == 0 then return mtbl, mflw, elm end
  end

  return mtbl, mflw
end

local survey = command 'Survey' {
  sequence=nil,   -- sequence (required)                                  (mflw)
  range=nil,      -- range of tracking                                    (iter)
  dir=1,          -- direction of tracking (1 or -1)                      (mflw)

  X0={0,0,0},     -- initial coordinates                                  (mflw)
  A0={0,0,0},     -- initial angles                                       (mflw)

  nturn=0,        -- number of extra turns                                (iter)
  nstep=-1,       -- number of elements to track                          (iter)
  nslice=1,       -- number of slice for each element                     (mflw)

  save=true,      -- save data to mtable                                  (mtbl)
  implicit=true,  -- save implicit elements to mtable                     (mtbl)
  noslice=false,  -- discard nslice with highest precedence               (mflw)

  atentry=nil,    -- function to call when entering an element            (mflw)
  atslice=nil,    -- function to call after each element slices           (mflw)
  atexit=nil,     -- function to call when exiting an element             (mflw)

  mflow=nil,      -- current mflow, exclusive with other attributes except nstep

  exec=exec,      -- command to execute upon children creation
} :set_readonly() -- reference survey command is readonly

-- end ------------------------------------------------------------------------o
return { survey = survey }
