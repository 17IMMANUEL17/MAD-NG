--[=[
 o-----------------------------------------------------------------------------o
 |
 | Survey module
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - TODO

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local vector, matrix, element, mtable, command, object       in MAD
local fnone                                                  in MAD.gfunc
local is_nil, is_sequence                                    in MAD.typeid
local minlen, minang                                         in MAD.constant
local observe                                                in element.flags
local errorf                                                 in MAD.utility

local raw_get                                                in object
local abs, sin, cos                                          in math

-- maps -----------------------------------------------------------------------o

local geomap = require "madl_geomap"

-- special --------------------------------------------------------------------o

local invalid = \e ->
  errorf("invalid element %s of kind %s with length %s", e.name, e.kind, e.l)

-- load maps into elements of element module ----------------------------------o

local E = element

E. thin_element :set_methods { survey = geomap.thin  }
E.drift_element :set_methods { survey = geomap.drift }
E.thick_element :set_methods { survey = geomap.thick }
E.extra_element :set_methods { survey = invalid }

E.special       :set_methods { survey = fnone   }
E.patch         :set_methods { survey = invalid }

E.srotation     :set_methods { survey = geomap.srotation }
E.xrotation     :set_methods { survey = geomap.xrotation }
E.yrotation     :set_methods { survey = geomap.yrotation }
E.translate     :set_methods { survey = geomap.translate }
E.changedir     :set_methods { survey = geomap.changedir }
E.changeref     :set_methods { survey = geomap.changeref }

-- angles adjustment ----------------------------------------------------------o

local function update_angles (m)
  local A, W in m
  A[1], A[2], A[3] = W:torotmad(A[1], A[2], A[3])
end

-- survey command -------------------------------------------------------------o

local _srv = {}

local function make_mtable (self)
  if self.mtable then
    assert(self.mtable[_srv] == _srv, "invalid survey mtable")
    return self.mtable
  end

  if not self.save then return nil end -- nothing to build

  local range, nturn in self
  local seq  = self.sequence
  local nrow = 2*seq:length_of(range, nturn)

  return mtable 'survey' {
    type='survey', title=seq.name, direction=seq.direction, reserve=nrow,
    {'name'}, 'kind', 's', 'l', 'angle', 'tilt',
    'x', 'y', 'z', 'theta', 'phi', 'psi', 'globaltilt',
    [_srv]=_srv,
  }
end

local function make_mflow (self)
  if self.mflow then
    assert(self.mflow[_srv] == _srv, "invalid survey mflow")
    return self.mflow
  end

  local x, y, z, theta, phi, psi, X0, A0 in self
  x     = x     or X0.x     or X0[1] or 0
  y     = y     or X0.y     or X0[2] or 0
  z     = z     or X0.z     or X0[3] or 0
  theta = theta or A0.theta or A0[1] or 0
  phi   = phi   or A0.phi   or A0[2] or 0
  psi   = psi   or A0.psi   or A0[3] or 0

  local seq = self.sequence

  local range, nturn, save, drift in self
  local dir = seq.direction
  local V   = vector(3):fill  {x,y,z}
  local W   = matrix(3):rotmad(theta, phi, psi)
  local A   = vector(3):fill  {theta, phi, psi}
  local R, S, T, U = vector(3), matrix(3), matrix(3), vector(3)
  local iter, state, init = seq:siter(range, nturn)

  return { A=A, V=V, W=W,                                   -- initial vars
           R=R, S=S, T=T, U=U,                              -- internal vars
           dir=dir, ndft=0,                                 -- internal status
           iter=iter, state=state, init=init,               -- iterator status
           seq=seq, save=save,                              -- user status
           [_srv]=_srv }
end

local function fill_mtable (tbl, elm, map, spos)
  local name, kind, l, angle, tilt in elm
  local V, A, s, dir in map
  local x, y, z      = V[1], V[2], V[3]
  local th, phi, psi = A[1], A[2], A[3]

   -- implicit drift
   if raw_get(elm,'implicit') then
    name = name..map.ndft
    map.ndft = map.ndft+1
  end

  -- keep order!
  tbl = tbl +
    { name, kind, spos+l*dir, l, angle, tilt, x, y, z, th, phi, psi, psi+tilt }
end

local function exec (self)
  local seq = assert(self.sequence, "missing sequence")
  assert(is_sequence(seq), "invalid sequence")

  -- build mflow and mtable
  local map = make_mflow (self)
  local tbl = make_mtable(self)

  -- retrieve information
  local iter, state, init, save, onestep in map

  -- geometric tracking
  for _,elm,spos in iter,state,init do
    elm:survey(map)
    if not raw_get(elm, 'implicit') then update_angles(map) end
    if save    then fill_mtable(tbl, elm, map, spos) end
    if onestep then return tbl, map, elm end
  end

  return tbl, map
end

local survey = command 'Survey' {
  X0={0,0,0}, A0={0,0,0}, nturn=0, direction=1, save=true, onestep=false,
  exec=exec,
} :set_readonly()

-- end ------------------------------------------------------------------------o
return { survey = survey }
