--[=[
 o-----------------------------------------------------------------------------o
 |
 | Survey module
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - TODO

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local vector, matrix, element, mtable, command                    in MAD

local is_sequence, is_boolean, is_number, is_integer,
      is_table, is_callable, is_mappable, is_matrix               in MAD.typeid
local fnone, ffalse, ftrue, functor, achain                       in MAD.gfunc
local tblcat, errorf                                              in MAD.utility

local min in math

-- integrator schemes ---------------------------------------------------------o

local thickonly                                                   in MAD.symint

-- geometric maps -------------------------------------------------------------o

local thin, drift, thick, xrotation, yrotation, srotation,
      translate, changeref, changedir, changenrj                  in MAD.geomap

-- load maps into elements ----------------------------------------------------o

local invalid = \e ->
  errorf("invalid survey element %s of kind %s with length %s",
         e.name, e.kind, e.l)

local E = element

-- warning: class protection set by alt. 'nolookup' object model can be BYPASSED
--          because classes are modified before any use of 'survey' attribute
--          by any children at the time of module loading...

-- kind maps

E. thin_element:setv({ survey = functor( thin    ) }, 'init')
E.drift_element:setv({ survey = functor \e,m -> thickonly(e,m,1, drift, nil) }, 'init')
E.thick_element:setv({ survey = functor \e,m -> thickonly(e,m,1, thick, nil) }, 'init')
E.specl_element:setv({ survey = functor( invalid ) }, 'init')  -- avoid missing definition
E.patch_element:setv({ survey = functor( invalid ) }, 'init')  -- avoid missing definition
E.extra_element:setv({ survey = functor( invalid ) }, 'init')  -- forbidden in survey

-- special maps

E.marker   :setv({ survey = functor( fnone     ) }, 'init')
E.xrotation:setv({ survey = functor( xrotation ) }, 'init')
E.yrotation:setv({ survey = functor( yrotation ) }, 'init')
E.srotation:setv({ survey = functor( srotation ) }, 'init')
E.translate:setv({ survey = functor( translate ) }, 'init')
E.changeref:setv({ survey = functor( changeref ) }, 'init')
E.changedir:setv({ survey = functor( changedir ) }, 'init')
E.changenrj:setv({ survey = functor( changenrj ) }, 'init')

-- survey mtable --------------------------------------------------------------o

local function save_dat (elm, mflw, lw, slc)
  local name, kind, angle, tilt in elm

  local A, V, ds, sdir, tdir, spos, turn, mtbl, atsave, relative, mapsave in mflw
  local x, y, z      = V[1], V[2], V[3]
  local th, phi, psi = A[1], A[2], A[3]

  lw = relative and lw*max(0,min(1,slc)) or slc<0 and 1 or lw*slc
  local dsw = ds*lw

  local W = mapsave and mflw.W:copy()

  -- keep order!
  mtbl = mtbl + { name, kind, spos+dsw, dsw, angle*lw*sdir, tilt*sdir,
                  x, y, z, th, phi, psi, psi+tilt*sdir, slc, turn, tdir, W }
  -- user action
  atsave(elm, mflw, lw, slc)
end

local function save_imp (elm, mflw, lw, slc)
  if not elm:is_implicit() then
    save_dat(elm, mflw, lw, slc)
  end
end

local function save_obs (elm, mflw, lw, slc)
  if elm:is_observed() and mflw.turn % mflw.observe == 0 then
    save_dat(elm, mflw, lw, slc)
  end
end

local header = {
  'direction', 'observe', 'implicit', 'relative',
}

local function make_mtable (self, obs)
  local title, range, nturn, dir, implicit, relative, mapsave in self
  local sequ, nrow = self.sequence

  if obs > 0 then
    nrow = nturn+1 -- assume 1 observation point per turn
  else
    nrow = sequ:length_of(range, nturn)*(implicit and 2 or 1)
  end

  -- keep order!
  return mtable 'survey' {
    title=title or sequ.name, type='survey', header=header, reserve=nrow,
    direction=dir, observe=obs, implicit=implicit, relative=relative,
    {'name'}, 'kind', 's', 'l', 'angle', 'tilt',
    'x', 'y', 'z', 'theta', 'phi', 'psi', 'globaltilt',
    'slc', 'turn','tdir',  -- t-direction of the tracking: sdir * seq.dir
    mapsave and 'W' or nil -- optional column to save the orientation matrix
  }
end

-- trace survey internal actions ----------------------------------------------o

local act2str = {
  [fnone   ] = 'fnone'   , [ftrue   ] = 'ftrue'   , [ffalse  ] = 'ffalse',
  [save_dat] = 'save_all', [save_imp] = 'save_imp', [save_obs] = 'save_obs',
}

local function trace_action (mflw)
  local atentry, atslice, atexit, ataper, atsave in mflw

  local estr = act2str[atentry] or 'usrdef'
  local sstr = act2str[atslice] or 'usrdef'
  local xstr = act2str[atexit ] or 'usrdef'
  local ostr = act2str[atsave ] or 'usrdef'

  trace(2, "survey actions: atentry=%s, atslice=%s, atexit=%s, atsave=%s",
           estr, sstr, xstr, ostr)
end

-- survey mflow ---------------------------------------------------------------o

local function make_mflow (self)
  -- check sequence
  local sequ = assert(self.sequence, "missing sequence")
  assert(is_sequence(sequ), "invalid sequence")

  -- build iterator
  local range, dir, nturn in self
  local iter, state, init = sequ:siter(range, nturn, dir)

  -- saving data, build mtable
  local save, observe, implicit, relative in self
  local fill, mtbl = fnone
  if is_boolean(observe) then observe = observe and 1 or 0 end
  assert(is_boolean(save)    , "invalid save (boolean expected)")
  assert(is_boolean(implicit), "invalid implicit (boolean expected)")
  assert(is_boolean(relative), "invalid relative (boolean expected)")
  assert(is_integer(observe) and observe >= 0
                             , "invalid observe (positive integer expected)")
  if save then
    mtbl = make_mtable(self, observe)
    fill = observe  >  0    and save_obs or
           implicit ~= true and save_imp or save_dat
  end

  -- time direction
  local tdir = dir*sequ.dir
  assert(tdir == 1 or tdir == -1, "invalid time direction (1 or -1 expected)")

  -- setup default sclicing
  local nslice in self
  assert(is_integer(nslice) and nslice > 0,
                                "invalid nslice (positive integer expected)")

  -- retrieve default actions (avoid evaluation in case of functions)
  local atentry = self:var_raw 'atentry'
  local atslice = self:var_raw 'atslice'
  local atexit  = self:var_raw 'atexit'
  local atsave  = self:var_raw 'atsave'

  assert(is_callable(atentry), "invalid atentry (callable expected)")
  assert(is_callable(atslice), "invalid atslice (callable expected)")
  assert(is_callable(atexit ), "invalid atexit (callable expected)")
  assert(is_callable(atsave ), "invalid atsave (callable expected)")

  -- wrap atentry, atslice and atexit to fill table (if needed)
  if save then
    if atentry ~= fnone and atentry ~= ffalse then
      atentry = atentry == ftrue and fill or achain(atentry, fill)
    end
    if atslice ~= fnone and atslice ~= ffalse then
      atslice = atslice == ftrue and fill or achain(atslice, fill)
    end
    if atexit  ~= fnone and atexit  ~= ffalse then
      atexit  = atexit  == ftrue and fill or achain(atexit , fill)
    end
  end

  -- retrieve initial conditions
  local s0, X0, A0, W0, mapsave in self
  assert(is_number  (s0)    , "invalid s0 (number expected)")
  assert(is_mappable(X0)    , "invalid X0 (mappable expected)")
  assert(is_mappable(A0)    , "invalid A0 (mappable expected)")
  assert(is_boolean(mapsave), "invalid mapsave (boolean expected)")

  if W0 then
    assert(is_matrix(W0), "invalid W0 (matrix expected)")
    A0[1], A0[2], A0[3] = W0:torotmad(A0[1], A0[2], A0[3])
  end

  -- precedence of initial conditions
  local mflw = table.new(0,50)

  local x     = X0[1] or X0.x
  local y     = X0[2] or X0.y
  local z     = X0[3] or X0.z
  local theta = A0[1] or A0.theta
  local phi   = A0[2] or A0.phi
  local psi   = A0[3] or A0.psi

  local V = vector(3):fill{x,y,z}
  local W = matrix(3):rotmad(theta,phi,psi)
  local A = vector(3):fill{theta,phi,psi}

  -- complete mflow
  mflw.sequ=sequ             -- current sequence
  mflw.mtbl=mtbl             -- current mtable (nil if no save)
  mflw.sdir=dir              -- s-direction of tracking
  mflw.tdir=tdir             -- t-direction of tracking
  mflw.eidx=init             -- current element index
  mflw.turn=1                -- current turn index

  mflw.s0=s0                 -- initial s-position (i.e. offset)
  mflw.ds=nil                -- s-length of results (signed)
  mflw.spos=nil              -- s-position of results (signed)
  mflw.nslice=nslice         -- number of slice for each element

  mflw.save=save             -- save data
  mflw.observe=observe       -- save observed elements every n turns
  mflw.implicit=implicit     -- save also implicit elements
  mflw.relative=relative     -- save length of slices

  mflw.atentry=atentry       -- action when entering an element
  mflw.atslice=atslice       -- action after each element slices
  mflw.atexit=atexit         -- action when exiting an element
  mflw.atsave=atsave         -- action when saving a row in mtable

  mflw.usrdef=self.usrdef    -- user defined data

  mflw.mapsave=mapsave       -- save orientation matrix

  -- global frame (see geomap)
  mflw.V=V                   -- displacement vector
  mflw.W=W                   -- orientation matrix (rotations)
  mflw.A=A                   -- oriented angles

  -- local frame (see geomap) at element slices or exit
  mflw.R=vector(3)           -- displacement vector
  mflw.S=matrix(3)           -- orientation matrix (rotations)
  mflw.T=matrix(3)           -- transformation matrix if tilted
  mflw.U=vector(3)           -- temporary vector for calculations

  -- internal vars for survey
  mflw.__survitr={iter=iter, state=state}   -- iterator and iteraror state

  return mflw
end

-- survey command -------------------------------------------------------------o

local _id = {} -- identity

local function exec (self)
  local mflw, mtbl

  -- retrieve or build mflw (and mtbl)
  if self.mflow then
    assert(self.mflow.__trck == _id, "invalid mflow (survey mflow expected)")
    mflw = self.mflow
  else
    mflw = make_mflow(self)
    mflw.__trck = _id
  end
  mtbl = mflw.mtbl

  -- check number of element to track
  local nstep in self
  if nstep == 0 then return mtbl, mflw end

  -- retrieve information
  local s0, eidx, sequ, atentry, atexit in mflw
  local iter, state in mflw.__survitr
  local ne = #sequ

  -- debug actions setup
  if MAD.option.debug >= 2 then trace_action(mflw) end

  -- geometric tracking
  for ei,elm,spos,ds in iter, state, eidx do
    mflw.eidx = ei ; mflw.spos = s0+spos ; mflw.ds = ds
    atentry   (elm, mflw, 0,  0)
    elm:survey(     mflw       )
    atexit    (elm, mflw, 0, -1)

    -- check for end of turn
    if ei == ne then mflw.turn = mflw.turn + 1 end
    -- check remaining number of element to track
    nstep = nstep-1
    if nstep == 0 then return mtbl, mflw, ei end
  end

  return mtbl, mflw
end

local _na -- not applicable (see track)

local survey = command 'survey' {
  beam=_na,         -- N/A                                                (mflw)
  sequence=nil,     -- sequence (required)                                (mflw)
  range=nil,        -- range of tracking                                  (iter)
  dir=1,            -- s-direction of tracking (1 or -1)                  (mflw)

  s0=0,             -- initial s                                          (mflw)
  X0={0,0,0},       -- initial coordinates x, y, z                        (mflw)
  A0={0,0,0},       -- initial angles theta, phi, psi                     (mflw)

  mapdef=_na,       -- always use matrix formalism (i.e. true)            (mflw)
  mapsave=false,    -- save the orientation matrix W (rotations)          (mflw)
  W0=nil,           -- initial W matrix (compagnion of X0)                (mflw)

  nturn=1,          -- number of turns                                    (iter)
  nstep=-1,         -- number of elements to track                        (iter)
  nslice=1,         -- number of slice for each element                   (mflw)
  model=_na,        -- N/A
  method=_na,       -- N/A                                                (mflw)
  totalpath=_na,    -- N/A                                                (mflw)

  save=true,        -- create mtable and save results                     (mtbl)
  title=nil,        -- title of mtable (default seq.name)                 (mtbl)
  implicit=true,    -- save also in implicit elements                     (mtbl)
  relative=false,   -- save length of slices instead from element start   (mtbl)
  observe=false,    -- save only in observed elements (every n turns)     (mtbl)

  atentry=fnone,    -- action called when entering an element             (mflw)
  atslice=fnone,    -- action called after each element slices            (mflw)
  atexit=ftrue,     -- action called when exiting an element              (mflw)
  ataper=_na,       -- N/A                                                (mflw)
  atsave=fnone,     -- action called when saving a row in mtable          (mflw)

  usrdef=nil,       -- user defined data attached to the mflow            (mflw)

  mflow=nil,        -- mflow, exclusive with other attributes except nstep

  exec=exec,        -- command to execute upon children creation
} :set_readonly()   -- reference survey command is readonly

-- end ------------------------------------------------------------------------o
return { survey = survey }
