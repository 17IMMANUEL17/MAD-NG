--[=[
 o-----------------------------------------------------------------------------o
 |
 | Synchrotron Radiation module
 |
 | Methodical Accelerator Design - Copyright (c) 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide routines for synchrotron radiation.

 o-----------------------------------------------------------------------------o
]=]

local M = {}

-- locals ---------------------------------------------------------------------o

local _C, beam   in MAD
local hypot      in MAD.gmath
local is_damap   in MAD.typeid
local printf     in MAD.utility
local eps        in MAD.constant
local tobit, bor in MAD.operator

local mapkind = { part=tobit(1), damap=tobit(2) } -- from track...

local function track_photon (m, i, nrj, px, py)   -- see track...
  -- take care of mflw wrappers (e.g. __edat and __sdat in track)
  m = assert(getmetatable(mflw).__index, "corrupted mflow wrapper (unexpected)")

  local x, y in m[i]
  if is_damap(m[i]) then x, y = x:get0(), y:get0() end

  local phb = beam { particle="photon", energy=nrj }
  local ph = {x=x, px=px, y=y, py=py, t=0, pt=0, beam=phb, id=#m, status='Xset'}

  table.insert(m, m.npar, ph)
  m.npar, m.tpar, m.nphot = m.npar+1, m.tpar+1, m.nphot+1
  m.mknd = bor(m.mknd, mapkind.part)
end

function M.srad_savp (elm, m, lw, islc)
  for i=1,m.npar do
    local px, py in m[i]
    if is_damap(m[i]) then px, py = px:get0(), py:get0() end
    m[i].px0, m[i].py0 = px, py
  end
end

function M.srad_avrg (elm, m, lw, islc)
  local el, eh, debug in m
  local gamma = m.beam.gamma

  for i=1,m.npar do
    local px, py, pt, px0, py0, beam in m[i]
    if is_damap(m[i]) then px, py = px:get0(), py:get0() end

    local dpx = px-px0 + lw*el*eh
    local dpy = py-py0
    local kck = hypot(dpx, dpy)

    if kck > eps then
      local gamma = beam and beam.gamma or gamma
      local nrj = _C.mad_rad_nrjloss_average(gamma, kck, lw*el)

      if nrj > 0 and debug >= 3 then
        printf("particle %d lost an average of %.5e GeV\n", m[i].id, nrj)
      end

      m[i].pt = pt - nrj
    end
    m[i].px0, m[i].py0 = px, py
  end
end

function M.srad_quant (elm, m, lw, islc)
  local el, eh, tphot, debug in m
  local gamma = m.beam.gamma
  local elw = el*lw

  for i=1,m.npar do
    local px, py, pt, px0, py0, beam in m[i]
    if is_damap(m[i]) then px, py = px:get0(), py:get0() end

    local dpx = px-px0 + elw*eh
    local dpy = py-py0
    local kck = hypot(dpx, dpy)

    if kck > eps then
      local gamma = beam and beam.gamma or gamma
      local fpath = _C.mad_rad_synrad_prob(gamma, kck)
      local nphot, nrj = 0, 0

      while fpath >= 0 do
        local dnrj = _C.mad_rad_nrjloss_quantum(gamma, kck, elw)
        fpath = fpath - _C.mad_rad_freepath(gamma, kck, elw)
        nrj, nphot = nrj+dnrj, nphot+1
        if tphot then track_photon(m, i, dnrj, px, py) end
      end

      if nrj > 0 and debug >= 3 then
        printf("particle %d lost %.5e GeV in %d photons\n", m[i].id, nrj, nphot)
      end

      m[i].pt = pt - nrj
    end
    m[i].px0, m[i].py0 = px, py
  end
end

-- end ------------------------------------------------------------------------o
return { synrad = M }
