--[=[
 o-----------------------------------------------------------------------------o
 |
 | Matrix module
 |
 | Methodical Accelerator Design - Copyright CERN 2015+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provides full set of functions and operations on real and complex matrices.
  - Vectors are column oriented matrices, i.e. implemented as [n x 1] matrices.

 o-----------------------------------------------------------------------------o
]=]

local MR, MC = { __help = {} }, {}

-- help -----------------------------------------------------------------------o

MR.__help.self = [=[
NAME
  matrix -- real and complex vectors and matrices

SYNOPSIS
  mr1 = matrix(nrow [, ncol])          -- default ncol = nrow (square matrix)
  mr2 = matrix {{...}, ...}            -- from table (nrow length must be equal)

  mc1 = cmatrix(nrow [, ncol])         -- complex variant
  mc2 = cmatrix {{...}, ...}           -- complex variant

  vr1 = vector(nrow)                   -- vector = [nrow x 1] (column matrix)
  vr2 = vector {...}                   -- from table (column vector)

  vc1 = cvector(nrow)                  -- complex variant
  vc2 = cvector {...}                  -- complex variant

DESCRIPTION
  The module matrix implements the operators and math functions on matrices:
  is_matrix, is_cmatrix, isa_matrix, is_vector, is_cvector, isa_vector,
  nrow, ncol, size (length), sizes, tsizes,
  zeros, ones, eye, fill, reshape,                                    (in place)
  get, get0, geti, geti0, getv, getdiag, getrow, getcol, getsub,
  set, set0, seti, seti0, setv, setdiag, setrow, setcol, setsub,
  same, copy, concat,
  foreach, mapv, mapr, map, map2, map3, foldl, foldr, scanl, scanr, filter,

  (minus) -, +, -, *, /, %, ^, ==, #, [], ..,
  unm, add, sub, mul (emul), div (ediv), mod, pow, eq,
  transpose, t, conjugate, conj, trace, tr,
  dot, inner, cross, mixed, outer,

  carg, real, imag, conj, norm, unit, rect, polar,
  ceil, floor, frac, trunc, round,
  abs, angle, exp, log, sqrt,
  sin, cos, tan, sinh, cosh, tanh,
  asin, acos, atan, asinh, acosh, atanh,
  erf, tgamma, lgamma,

  solve, svd, eigen,
  fft, ifft, rfft, irfft, conv, corr, covar.

RETURN VALUES
  The constructed matrices, vectors are specialized matrices.

ERRORS
  TODO

EXAMPLES
  m1 = matrix(2,3)                    -- matrix [2 x 3]
  m2 = matrix(3)                      -- square matrix [3 x 3]
  m3 = vector(3)                      -- column vector [3 x 1]
  m4 = matrix {{1,2},{3,4},{5,6}}     -- from table [3 x 2]
  m5 = vector {1,2,3,4,5,6}           -- column vector [6 x 1] = {{1},{2},...}
  m6 = vector {{1,2,3,4,5,6}}         -- row vector [1 x 6]

  c1 = cmatrix(2,3)                   -- cmatrix [2 x 3]
  c2 = cmatrix {{1,2+2i},{3,4+2i},{5,6+2i}}
  c3 = cvector {1,2,3,4,5,6}          -- column cvector [6 x 1]
  c4 = cvector {{1,2,3,4,5,6}}        -- row cvector [1 x 6]
  c5 = c2:transpose()                 -- row cmatrix, transpose conjugate
  I6 = cmatrix(6):eye()               -- identity cmatrix [6 x 6]

SEE ALSO
  gmath, gfunc, complex
]=]

-- documentation --------------------------------------------------------------o

MR.__help['3D Geometry'] = [=[
Useful relations of 3D geometry:
  inner prod:   u'.v = |u|.|v| cos(u^v)
  cross prod:   uxv = |u|.|v| sin(u^v) \vec{n}
  mixed prod:   (uxv)'.w = u'.(vxw) = det(u,v,w)
  outer prod:   u.v' = matrix
  dbl x-prod:   ux(vxw) = (u.w) \vec{v} - (u.v) \vec{w}
                (uxv)xw = (u.w) \vec{v} - (v.w) \vec{u}
  norm      :   |u| = sqrt(u'.u)
  angle     :   u^v = acos(u'.v / |u|.|v|)  in [0,pi] (or [-pi,pi] if n)
  unit      :   u / |u|
  projection:   u'.v
  projector :   I -   u.u' / u'.u
  reflector :   I - 2 u.u' / u'.u
  area      :   |uxv|
  volume    :   |(uxv)'.w|
  unitary   :   |u| = 1
  orthogonal:   u'.v = 0
  collinear :   |uxv| = 0
  coplanar  :   (uxv)'.w = 0
]=]

MR.__help['Matrix properties'] = [=[
Useful properties of square matrix:
  symmetric :   M = M',  positive-definite:  v' M v > 0 (positive-semidef >= 0)
  hermitian :   M = M^*, complex symmetric, v^* M v > 0 (negative-def < 0)
  skew/anti :   M = -M' (skew-symmetric), M = -M^* (skew-hermitian)
  invertible:   M M^-1 = M^-1 M = I (M^-1 exists) det(M) ~=  0 (i.e. GL(n))
                                                  det(M)  = +1 (i.e. SL(n))
  normal    :   M M' = M' M
  orthogonal:   M M' = M' M = I => M^-1 = M',     det(M)  = ±1 (i.e.  O(n))
                row/col form an orthonormal basis det(M)  = +1 (i.e. SO(n))
  unitary   :   M M^* = I, complex orthogonal,   |det(M)| = +1 (i.e.  U(n))
                row/col form an orthonormal basis det(M)  = +1 (i.e. SU(n))
  symplectic:   M' J M = J => M^-1 = J^-1 M'      det(M)  = ±1 (i.e. Sp(n))
                J = {{0,I},{-I,0}}, J^-1 = J' = -J, J^2 = -I, det(J) = 1
                J is the reference non-singular skew-symmetric bilinear form
                symp M = {{A,B},{C,D}} <=> A'D - C'B = 1, A'C = C'A, B'D = D'B
]=]

-- locals ---------------------------------------------------------------------o

local new, istype, metatype, cast, typeof, sizeof, fill, cdef, gc
      in require 'ffi'

local _C, is_nil, is_boolean, is_number, is_string, is_table, is_complex,
      is_scalar, is_callable, is_iterable, is_indexable, has_method,
      carg, real, imag, conj, norm, rect, polar,
      abs, ceil, floor, exp, log, sqrt,
      sin, cos, tan, sinh, cosh, tanh,
      asin, acos, atan, asinh, acosh, atanh,
      unm, add, mul, mod, pow, min, max, ident, land, lor,
      compose, tostring, defhelp in MAD

-- tmp for returned values
local cres = new 'complex[1]'

-- scalar repeater
local rep_mt = { __len := 2^31, __index = \s s[1] }
local rep    = \x -> setmetatable({x}, rep_mt)

-- types ----------------------------------------------------------------------o

cdef [[
typedef struct { int32_t nr, nc; double  data[?]; }  matrix_t;
typedef struct { int32_t nr, nc; complex data[?]; } cmatrix_t;
]]

local  matrix_ctor = typeof ' matrix_t'
local cmatrix_ctor = typeof 'cmatrix_t'
local  matrix_cref = typeof ' matrix_t&'
local cmatrix_cref = typeof 'cmatrix_t&'

local is_matrix  = \x -> istype( matrix_ctor, x)
local is_cmatrix = \x -> istype(cmatrix_ctor, x)
local isa_matrix = \x -> is_matrix(x) or is_cmatrix(x)
local is_vector  = \x -> is_matrix(x)  and (x.nr == 1 or x.nc == 1)
local is_cvector = \x -> is_cmatrix(x) and (x.nr == 1 or x.nc == 1)
local isa_vector = \x -> isa_matrix(x) and (x.nr == 1 or x.nc == 1)

MR.is_matrix  = is_matrix
MR.is_cmatrix = is_cmatrix
MR.isa_matrix = isa_matrix
MR.is_vector  = is_vector
MR.is_cvector = is_cvector
MR.isa_vector = isa_vector

-- allocators -----------------------------------------------------------------o

local function matrix_alloc (nr, nc)
  local len, mat = nr*nc, nil
  if len < _C.mad_alloc_threshold then
    mat = matrix_ctor(len) -- VLA
  else
    local siz = sizeof(matrix_ctor, len)
    local ptr = _C.mad_malloc(siz)
    mat = gc(cast(matrix_cref, ptr), _C.mad_free)
    fill(mat, siz)
  end
  mat.nr, mat.nc = nr, nc
  return mat
end

local function cmatrix_alloc (nr, nc)
  local len, mat = nr*nc, nil
  if len < _C.mad_alloc_threshold/2 then
    mat = cmatrix_ctor(len) -- VLA
  else
    local siz = sizeof(cmatrix_ctor, len)
    local ptr = _C.mad_malloc(siz)
    mat = gc(cast(cmatrix_cref, ptr), _C.mad_free)
    fill(mat, siz)
  end
  mat.nr, mat.nc = nr, nc
  return mat
end

local function fromtable (ctor, tbl)
  local nr, nc = #tbl or 0, is_table(tbl[1]) and #tbl[1] or 1
  assert(nr > 0 and nc > 0, "invalid argument #1 (non-empty table expected)")
  return ctor(nr,nc):fill(tbl)
end

-- constructors ---------------------------------------------------------------o

local function matrix (nr, nc_)
  if is_table(nr) then
    return fromtable(matrix_alloc, nr)
  end
  local nc = nc_ or nr -- square
  assert(is_number(nr) and nr > 0 and is_number(nc) and nc > 0,
         "invalid argument #1 or #2 (nrow[,ncol] or table [of tables] expected)")
  return matrix_alloc(nr, nc)
end

local function cmatrix (nr, nc_)
  if is_table(nr) then
    return fromtable(cmatrix_alloc, nr)
  end
  local nc = nc_ or nr -- square
  assert(is_number(nr) and nr > 0 and is_number(nc) and nc > 0,
         "invalid argument #1 or #2 (nrow[,ncol] or table [of tables] expected)")
  return cmatrix_alloc(nr, nc)
end

local  vector = \n ->  matrix(n, 1)
local cvector = \n -> cmatrix(n, 1)

-- helpers --------------------------------------------------------------------o

local function chksiz (r, x, y) -- add, sub
  assert(is_nil(r) or (r.nr == x.nr and r.nc == x.nc) and
         is_nil(y) or (y.nr == x.nr and y.nc == x.nc),
         "incompatible matrix sizes")
  return r
end

local function chksizm (r, x, y) -- mul
  assert(is_nil(r) or (r.nr == x.nr and r.nc == y.nc) and x.nc == y.nr,
         "incompatible matrix sizes")
  return r
end

local function chksizd (r, x, y) -- div
  assert(is_nil(r) or (r.nr == x.nr and r.nc == y.nr) and x.nc == y.nc,
         "incompatible matrix sizes")
  return r
end

local function chksizt (r, x) -- transpose
  assert(is_nil(r) or (r.nr == x.nc and r.nc == x.nr),
         "incompatible matrix sizes")
  return r
end

local idx0  = \i,j,c   -> ( i   *c +  j   )
local idx   = \i,j,c   -> ((i-1)*c + (j-1))

local geti0 = \x,i     -> x.data[i]
local seti0 = \x,i,e   => x.data[i] = e end
local geti  = \x,i     -> x.data[i-1]
local seti  = \x,i,e   => x.data[i-1] = e end
local get0  = \x,i,j   -> x.data[idx0(i, j, x.nc)]
local set0  = \x,i,j,e => x.data[idx0(i, j, x.nc)] = e end
local get   = \x,i,j   -> x.data[idx (i, j, x.nc)]
local set   = \x,i,j,e => x.data[idx (i, j, x.nc)] = e end

-- get, set -------------------------------------------------------------------o

MR._geti0 = geti0
MR._seti0 = seti0
MR._geti  = geti
MR._seti  = seti
MR._get0  = get0
MR._set0  = set0
MR._get   = get
MR._set   = set

MR.geti0 = \x,i   -> 0 <= i and i <  x.nr*x.nc                     and geti0(x, i) or nil
MR.geti  = \x,i   -> 1 <= i and i <= x.nr*x.nc                     and geti (x, i) or nil
MR.get0  = \x,i,j -> 0 <= i and i <  x.nr and 0 <= j and j <  x.nc and get0(x,i,j) or nil
MR.get   = \x,i,j -> 1 <= i and i <= x.nr and 1 <= j and j <= x.nc and get (x,i,j) or nil

function MR.seti0 (x, i, e)
  assert(0 <= i and i < x.nr*x.nc, "0-index out of bounds")
  seti0(x, i, e)
end

function MR.seti (x, i, e)
  assert(1 <= i and i <= x.nr*x.nc, "1-index out of bounds")
  seti(x, i, e)
end

function MR.set0 (x, i, j, e)
  assert(0 <= i and i < x.nr and 0 <= j and j < x.nc, "0-index out of bounds")
  set0(x, i, j, e)
end

function MR.set (x, i, j, e)
  assert(1 <= i and i <= x.nr and 1 <= j and j <= x.nc, "1-index out of bounds")
  set(x, i, j, e)
end

-- size, same -----------------------------------------------------------------o

MR.nrow   = \x -> x.nr
MR.ncol   = \x -> x.nc
MR.size   = \x -> x.nr * x.nc
MR.sizes  = \x -> (x.nr, x.nc)
MR.tsizes = \x -> (x.nc, x.nr)

--   valid invocation: x:same(), x:same(e), x:same(nr, nc), x:same(e, nr, nc)
-- invalid invocation: x:same(e, nr), will be interpreted as x:same(nr, nc)
function MR.same (x, e_, nr_, nc_)
  if is_nil(e_) then
    e_ = x.data[0]
  elseif is_nil(nr_) then
    -- nothing
  elseif is_nil(nc_) then
    nr_, nc_, e_ = e_, nr_, x.data[0]
  end
  if is_number(e_) then
    return matrix(nr_ or x.nr, nc_ or x.nc)
  elseif is_complex(e_) then
    return cmatrix(nr_ or x.nr, nc_ or x.nc)
  end
  error("invalid argument #2 (scalar expected)")
end

-- zeros, ones, eye, symp, circ, fill, vec, reshape (in place) ----------------o

function MR.zeros (x)
  fill(x.data, sizeof(is_matrix(x) and 'double' or 'complex', x:size()))
  return x
end

function MR.ones (x, e_)
  local n, e = x:size(), e_ or 1
  for i=0,n-1 do seti0(x,i,e) end
  return x
end

function MR.eye (x, e_) -- zeros + diag
  local n, nc, e = x:size(), x:ncol(), e_ or 1
  x:zeros()
  for i=0,n-1,nc+1 do seti0(x,i,e) end
  return x
end

function MR.symp (x, t_) -- zeros + symp
  local nr, nc = x:sizes()
  assert(nr == nc and nr%2 == 0, "invalid argument #1 (2n square matrix expected)")
  local t, n2 = t_ or 'J', nr/2
  x:zeros()
  if t == 'J'
  then for i=1,n2 do set(x,2*i-1,2*i,1) set(x,2*i,2*i-1,-1) end
  else for i=1,n2 do set(x,i,n2+i,1)    set(x,n2+i,i,-1)    end
  end
  return x
end

function MR.circ (x, v)
  local d
  if isa_vector(v) then
    d = v:nrow() == 1 and 'row' or 'col'
  else
    assert(is_iterable(v), "invalid argument #2 (iterable expected)")
    if is_iterable(v[1])
    then d, v = 'row', v[1]
    else d    = 'col'
    end
  end
  local k, nr, nc = 0, x:sizes()
  if d == 'row' then
    for i=1,nr do
    for j=nc-i+2,nc do seti0(x,k, v[j]) k=k+1 end
    for j=1,nc-i+1  do seti0(x,k, v[j]) k=k+1 end
    end
  else
    for i=1,nr do
    for j= i,  1,-1 do seti0(x,k, v[j]) k=k+1 end
    for j=nc,i+1,-1 do seti0(x,k, v[j]) k=k+1 end
    end
  end
  return x
end

function MR.fill (x, a)
  local nr, nc = x:sizes()
  if is_scalar(a) then
    a = rep(a)
  elseif is_callable(a) then -- generator
    for i=1,nr do
    for j=1,nc do set(x,i,j, a(get(x,i,j), i,j)) end end
    return x
  end
  if is_iterable(a) then
    if is_iterable(a[1]) then -- 2D container
      for i=1,nr do
      for j=1,nc do set(x,i,j, a[i][j]) end end
    else                       -- 1D container (or scalar)
      for i=1,nr*nc do seti(x,i, a[i]) end
    end
    return x
  end
  error("invalid argument #2 (scalar, callable or indexable expected)")
end

function MR.vec (x, d_)
  local n = x:size()
  if d_ == 'row'
  then x.nr, x.nc = 1, n
  else x.nr, x.nc = n, 1
  end
  return x
end

function MR.reshape (x, nr_, nc_)
  local nr, nc = nr_ or x.nr, nc_ or x.nc
  assert(nr*nc <= x:size(), "invalid new matrix sizes")
  x.nr, x.nc = nr, nc
  return x
end

function MR._reshape (x, nr_, nc_)
  -- no check, user is responsible for keeping track of the size allocated
  -- accessing data beyond allocated size trigs a segmentation fault
  x.nr, x.nc = nr_ or x.nr, nc_ or x.nc
  return x
end

-- rotations (in place) -------------------------------------------------------o

local mrot = require 'madl_matrot'

for k,v in pairs(mrot) do MR[k] = v end

-- getx, setx -----------------------------------------------------------------o

function MR.getv (x, ij, r_)
  if is_number(ij) then ij = {ij} end
  local r = r_ or x:same(#ij,1)
  assert(is_iterable(ij), "invalid argument #2 (iterable expected)")
  assert(is_iterable(r ), "invalid argument #3 (iterable expected)")
  for i,ii in ipairs(ij) do r[i] = x:geti(ii) end
  return r
end

function MR.setv (x, ij, y)
  if is_number(ij) then ij = {ij} end
  if is_scalar(y) then y = rep(y) end
  assert(is_iterable(ij), "invalid argument #2 (iterable expected)")
  assert(is_iterable(y ), "invalid argument #3 (scalar or iterable expected)")
  for i,ii in ipairs(ij) do x:seti(ii, y[i]) end
  return x
end

function MR.getdiag (x, r_)
  local n = min(x:sizes())
  local r = r_ or x:same(n,1)
  assert(is_iterable(r), "invalid argument #2 (iterable expected)")
  for i=1,n do r[i] = get(x,i,i) end
  return r
end

function MR.setdiag (x, y)
  if is_scalar(y) then y = rep(y) end
  assert(is_iterable(y), "invalid argument #2 (scalar or iterable expected)")
  local n = min(#y, x:sizes())
  for i=1,n do set(x,i,i, y[i]) end
  return x
end

function MR.getrow (x, ir, r_)
  if is_number(ir) then ir = {ir} end
  local k, nc = 1, x:ncol()
  local r = r_ or x:same(#ir,nc)
  assert(is_iterable(ir), "invalid argument #2 (iterable expected)")
  assert(is_iterable(r ), "invalid argument #3 (iterable expected)")
  for _,i in ipairs(ir) do
  for j=1,nc do r[k] = x:get(i,j) ; k=k+1 end end
  return r
end

function MR.setrow (x, ir, y)
  if is_number(ir) then ir = {ir} end
  if is_scalar(y) then y = rep(y) end
  assert(is_iterable(ir), "invalid argument #2 (iterable expected)")
  assert(is_iterable(y ), "invalid argument #3 (scalar or iterable expected)")
  local k, nc = 1, x:ncol()
  for _,i in ipairs(ir) do
  for j=1,nc do x:set(i,j, y[k]) ; k=k+1 end end
  return x
end

function MR.getcol (x, jc, r_)
  if is_number(jc) then jc = {jc} end
  local k, nr = 1, x:nrow()
  local r = r_ or x:same(nr,#jc)
  assert(is_iterable(jc), "invalid argument #2 (iterable expected)")
  assert(is_iterable(r ), "invalid argument #3 (iterable expected)")
  for _,j in ipairs(jc) do
  for i=1,nr do r[k] = x:get(i,j) ; k=k+1 end end
  return r
end

function MR.setcol (x, jc, y)
  if is_number(jc) then jc = {jc} end
  if is_scalar(y) then y = rep(y) end
  assert(is_iterable(jc), "invalid argument #2 (iterable expected)")
  assert(is_iterable(y ), "invalid argument #3 (scalar or iterable expected)")
  local k, nr = 1, x:nrow()
  for _,j in ipairs(jc) do
  for i=1,nr do x:set(i,j, y[k]) ; k=k+1 end end
  return x
end

function MR.getsub (x, ir, jc, r_)
  if is_number(ir) then ir = {ir} end
  if is_number(jc) then jc = {jc} end
  local r = r_ or x:same(#ir,#jc)
  assert(is_iterable(ir), "invalid argument #2 (iterable expected)")
  assert(is_iterable(jc), "invalid argument #3 (iterable expected)")
  assert(is_iterable(r ), "invalid argument #4 (iterable expected)")
  local k = 1
  for _,i in ipairs(ir) do
  for _,j in ipairs(jc) do r[k] = x:get(i,j) ; k=k+1 end end
  return r
end

function MR.setsub (x, ir, jc, y)
  if is_number(ir) then ir = {ir} end
  if is_number(jc) then jc = {jc} end
  if is_scalar(y) then y = rep(y) end
  assert(is_iterable(ir), "invalid argument #2 (iterable expected)")
  assert(is_iterable(jc), "invalid argument #3 (iterable expected)")
  assert(is_iterable(y ), "invalid argument #4 (scalar or iterable expected)")
  local k = 1
  for _,i in ipairs(ir) do
  for _,j in ipairs(jc) do x:set(i,j, y[k]) ; k=k+1 end end
  return x
end

-- foreach, filter, map, fold, scan -------------------------------------------o

function MR.foreach (x, f)
  assert(is_callable(f), "invalid argument #2 (callable expected)")
  local nr, nc = x:sizes()
  for i=1,nr do
  for j=1,nc do f(get(x,i,j), i,j) end end
  return x
end

function MR.filter (x, f, r_)
  assert(is_callable(f), "invalid argument #2 (callable expected)")
  local r = r_ or x:same()
  assert(is_iterable(r), "invalid argument #3 (iterable expected)")
  local k, nr, nc = 1, x:sizes()
  for i=1,nr do
  for j=1,nc do
    if f(get(x,i,j), i,j) == true then
      r[k], k = get(x,i,j), k+1
    end
  end end
  return r, k
end

function MR.mapr (x, f, ij, r_)
  if is_number(ij) then ij = {ij} end
  assert(is_callable(f), "invalid argument #2 (callable expected)")
  assert(is_iterable(ij), "invalid argument #3 (iterable expected)")
  local r = r_ or x:same()
  assert(is_iterable(r), "invalid argument #4 (iterable expected)")
  for _,i in ipairs(ij) do r[i] = f(x:geti(i), i) end
  return r
end

function MR.mapv (x, f, r_)
  assert(is_callable(f), "invalid argument #2 (callable expected)")
  local r0 = f(get(x,1,1), 1)
  local r = r_ or x:same(r0)
  assert(is_iterable(r), "invalid argument #3 (iterable expected)")
  local n = x:size()
  r[1] = r0
  for i=2,n do r[i] = f(geti(x,i), i) end
  return r
end

function MR.map (x, f, r_)
  assert(is_callable(f), "invalid argument #2 (callable expected)")
  local r0 = f(get(x,1,1), 1,1)
  local r = r_ or x:same(r0)
  assert(is_iterable(r), "invalid argument #3 (iterable expected)")
  local c0, nr, nc, ij = 2, x:sizes()
  r[1] = r0
  for i=1 ,nr do
  for j=c0,nc do ij=idx(i,j,nc)+1 ; r[ij] = f(geti(x,ij), i,j)
  end c0=1 end
  return r
end

function MR.map2 (x, y, f, r_)
  if is_scalar(y) then y = rep(y) end
  assert(is_iterable(y), "invalid argument #2 (scalar or iterable expected)")
  assert(is_callable(f), "invalid argument #3 (callable expected)")
  local r0 = f(get(x,1,1), y[1], 1,1)
  local r = r_ or x:same(r0)
  assert(is_iterable(r), "invalid argument #4 (iterable expected)")
  local c0, nr, nc, ij = 2, x:sizes()
  r[1] = r0
  for i=1 ,nr do
  for j=c0,nc do ij=idx(i,j,nc)+1 ; r[ij] = f(geti(x,ij), y[ij])
  end c0=1 end
  return r
end

function MR.map3 (x, y, z, f, r_)
  if is_scalar(y) then y = rep(y) end
  if is_scalar(z) then z = rep(z) end
  assert(is_iterable(y), "invalid argument #2 (scalar or iterable expected)")
  assert(is_iterable(z), "invalid argument #3 (scalar or iterable expected)")
  assert(is_callable(f), "invalid argument #4 (callable expected)")
  local r0 = f(get(x,1,1), y[1], z[1], 1,1)
  local r = r_ or x:same(r0)
  assert(is_iterable(r), "invalid argument #5 (iterable expected)")
  local c0, nr, nc, ij = 2, x:sizes()
  r[1] = r0
  for i=1 ,nr do
  for j=c0,nc do ij=idx(i,j,nc)+1 ; r[ij] = f(geti(x,ij), y[ij], z[ij])
  end c0=1 end
  return r
end

local function prep_fold (x, r, d, s)
  if is_nil(d) then
    if is_nil(r) or is_scalar(r)
    then d = 'vec'  -- x:fold(f,r) -> x:fold(f,r,'vec') (r scalar)
    else d = 'row'  -- x:fold(f,r) -> x:fold(f,r,'row') (r iterable)
    end
  end
  local nr, nc, i0 = x:sizes()
  if d == 'vec' then
    i0 = s == 1 and 1 or nr*nc
    r = geti(x,i0)
  elseif d == 'row' then
    r = r or x:same(nr,1)
    i0 = s == 1 and 1 or nc
    for i=1,nr do r[i] = get(x,i,i0) end
  elseif d == 'col' then
    r = r or x:same(1,nc)
    i0 = s == 1 and 1 or nr
    for j=1,nc do r[j] = get(x,i0,j) end
  end
  return r, d
end

function MR.foldl (x, f, r_, d_, x0_)
  assert(is_callable(f), "invalid argument #2 (callable expected)")
  if is_string(r_) then r_, d_, x0_ = nil, r_, is_nil(x0_) and d_ or x0_ end
  if not (is_nil(d_) or is_string(d_)) and is_nil(x0_) then d_, x0_ = nil, d_ end
  assert(is_nil(r_) or is_scalar(r_) or is_iterable(r_),
         "invalid argument #3 (scalar or iterable expected)")
  local r, d = prep_fold(x, r_, d_, 1)
  local nr, nc, rr = x:sizes()
  if d == 'vec' then        -- fold as vector (default)
    if x0_ ~= nil then r = f(x0_, r) end
    for i=2,nr*nc   do r = f(r, geti(x,i)) end
  elseif d == 'row' then    -- fold rows
    for i=1,nr      do rr = r[i]
    if x0_ ~= nil then rr = f(x0_, rr) end
    for j=2,nc      do rr = f(rr, get(x, i,j)) end r[i] = rr end
  elseif d == 'col' then    -- fold columns
    for j=1,nc      do rr = r[j]
    if x0_ ~= nil then rr = f(x0_, rr) end
    for i=2,nr      do rr = f(rr, get(x, i,j)) end r[j] = rr end
  else
    error("invalid argument #4 ('vec|row|col' expected)")
  end
  return r
end

function MR.foldr (x, f, r_, d_, x0_)
  assert(is_callable(f), "invalid argument #2 (callable expected)")
  if is_string(r_) then r_, d_, x0_ = nil, r_, is_nil(x0_) and d_ or x0_ end
  if not (is_nil(d_) or is_string(d_)) and is_nil(x0_) then d_, x0_ = nil, d_ end
  assert(is_nil(r_) or is_scalar(r_) or is_iterable(r_),
         "invalid argument #3 (scalar or iterable expected)")
  local r, d = prep_fold(x, r_, d_, -1)
  local nr, nc, rr = x:sizes()
  if d == 'vec' then        -- fold as vector (default)
    if x0_ ~= nil    then r = f(r, x0_) end
    for i=nr*nc-1,1,-1 do r = f(geti(x,i), r) end
  elseif d == 'row' then    -- fold rows
    for i=nr  ,1,-1 do rr = r[i]
    if x0_ ~= nil then rr = f(rr, x0_) end
    for j=nc-1,1,-1 do rr = f(get(x, i,j), rr) end r[i] = rr end
  elseif d == 'col' then    -- fold columns
    for j=nc  ,1,-1 do rr = r[j]
    if x0_ ~= nil then rr = f(rr, x0_) end
    for i=nr-1,1,-1 do rr = f(get(x, i,j), rr) end r[j] = rr end
  else
    error("invalid argument #4 ('vec|row|col' expected)")
  end
  return r
end

local function prep_scan (x, r, d, s)
  if is_nil(d) then
    if is_nil(r)
    then d = 'vec'  -- x:scan(f)   -> x:scan(f,'vec')
    else d = 'row'  -- x:scan(f,r) -> x:scan(f,r,'row') (r iterable)
    end
  end
  local nr, nc, i0 = x:sizes()
  if d == 'vec' then
    r = r or x:same(nr*nc,1)
    i0 = s == 1 and 1 or nr*nc
    r[i0] = geti(x,i0)
  elseif d == 'row' then
    r = r or x:same()
    i0 = s == 1 and 1 or nc
    for i=1,nr do r[idx(i,i0,nc)+1] = get(x,i,i0) end
  elseif d == 'col' then
    r = r or x:same()
    i0 = s == 1 and 1 or nr
    for j=1,nc do r[idx(i0,j,nc)+1] = get(x,i0,j) end
  end
  return r, d
end

function MR.scanl (x, f, r_, d_, x0_)
  assert(is_callable(f), "invalid argument #2 (callable expected)")
  if is_string(r_) then r_, d_, x0_ = nil, r_, is_nil(x0_) and d_ or x0_ end
  if not (is_nil(d_) or is_string(d_)) and is_nil(x0_) then d_, x0_ = nil, d_ end
  assert(is_nil(r_) or is_iterable(r_), "invalid argument #3 (iterable expected)")
  local r, d = prep_scan(x, r_, d_, 1)
  local nr, nc, rr = x:sizes()
  if d == 'vec' then                           -- scan as vector (default)
    rr = r[1]
    if x0_ ~= nil then rr = f(x0_, rr)         r[1] = rr end
    for i=2,nr*nc   do rr = f(rr, geti(x,i))   r[i] = rr end
  elseif d == 'row' then                       -- scan rows
    for i=1,nr      do rr = r[idx(i,1,nc)+1]
    if x0_ ~= nil then rr = f(x0_, rr)         r[idx(i,1,nc)+1] = rr end
    for j=2,nc      do rr = f(rr, get(x, i,j)) r[idx(i,j,nc)+1] = rr end end
  elseif d == 'col' then                       -- scan columns
    for j=1,nc      do rr = r[idx(1,j,nc)+1]
    if x0_ ~= nil then rr = f(x0_, rr)         r[idx(1,j,nc)+1] = rr end
    for i=2,nr      do rr = f(rr, get(x, i,j)) r[idx(i,j,nc)+1] = rr end end
  else
    error("invalid argument #4 ('vec|row|col' expected)")
  end
  return r
end

function MR.scanr (x, f, r_, d_, x0_)
  assert(is_callable(f), "invalid argument #2 (callable expected)")
  if is_string(r_) then r_, d_, x0_ = nil, r_, is_nil(x0_) and d_ or x0_ end
  if not (is_nil(d_) or is_string(d_)) and is_nil(x0_) then d_, x0_ = nil, d_ end
  assert(is_nil(r_) or is_iterable(r_), "invalid argument #3 (iterable expected)")
  local r, d = prep_scan(x, r_, d_, -1)
  local nr, nc, rr = x:sizes()
  if d == 'vec' then                            -- scan as vector (default)
    rr = r[nr*nc]
    if x0_ ~= nil    then rr = f(rr, x0_)       r[nr*nc] = rr end
    for i=nr*nc-1,1,-1 do rr = f(geti(x,i), rr) r[i    ] = rr end
  elseif d == 'row' then                        -- scan rows
    for i=nr  ,1,-1 do rr = r[idx(i,nc,nc)+1]
    if x0_ ~= nil then rr = f(rr, x0_)          r[idx(i,nc,nc)+1] = rr end
    for j=nc-1,1,-1 do rr = f(get(x, i,j), rr)  r[idx(i, j,nc)+1] = rr end end
  elseif d == 'col' then                        -- scan columns
    for j=nc  ,1,-1 do rr = r[idx(nr,j,nc)+1]
    if x0_ ~= nil then rr = f(rr, x0_)          r[idx(nr,j,nc)+1] = rr end
    for i=nr-1,1,-1 do rr = f(get(x, i,j), rr)  r[idx(i ,j,nc)+1] = rr end end
  else
    error("invalid argument #4 ('vec|row|col' expected)")
  end
  return r
end

-- conjugate, transpose -------------------------------------------------------o

function MR.conjugate (x, r_)
  local r = chksiz(r_,x) or matrix(x:sizes())
  _C.mad_vec_copy(x.data, r.data, x:size()) -- copy
  return r
end

MR.conj = MR.conjugate -- shortcut

function MC.conjugate (x, r_)
  local r = chksiz(r_,x) or cmatrix(x:sizes())
  _C.mad_cvec_conj(x.data, r.data, x:size()) -- conjugate
  return r
end

MC.conj = MC.conjugate -- shortcut

function MR.transpose (x, r_)
  local r = chksizt(r_,x) or matrix(x:tsizes())
  _C.mad_mat_trans(x.data, r.data, x:sizes())  -- transpose
  return r
end

MR.t = MR.transpose -- shortcut

function MC.transpose (x, r_, c_)
  if is_boolean(r_) and is_nil(c_) then r_, c_ = nil, r_ end
  local r = chksizt(r_,x) or cmatrix(x:tsizes())
  if c_ == false
  then _C.mad_cmat_trans (x.data, r.data, x:sizes())  -- transpose (no conj.)
  else _C.mad_cmat_ctrans(x.data, r.data, x:sizes())  -- conjugate transpose
  end
  return r
end

MC.t = MC.transpose -- shortcut

function MR.trace (x)
  local r, nr, nc = 0, x:sizes()
  for i=0,nr*nc-1,nc+1 do r = r + geti0(x,i) end
  return r
end

MR.tr = MR.trace -- shortcut

-- inner, cross, mixed, outer -------------------------------------------------o


-- Frobenius norm (consistent with inner product)
function MR.norm (x)
  -- sqrt( (x:t() * x):tr() ) without temporary
  return sqrt(_C.mad_vec_dot(x.data, x.data, x:size()))
end

function MC.norm (x)
  -- sqrt( (x:t() * x):tr() ) without temporary
  _C.mad_cvec_dot_r(x.data, x.data, cres, x:size())
  return sqrt(cres[0])
end

function MR.inner (x, y)
  -- (x:t() * y):tr() without temporary
  assert(isa_matrix(y), "invalid argument #2 (matrix expected)")
  chksiz(x,y)

  if is_matrix(y)
  then return _C.mad_mat_dot   (x.data, y.data,       x:ncol(), y:ncol(), x:nrow())
  else        _C.mad_mat_dotm_r(x.data, y.data, cres, x:ncol(), y:ncol(), x:nrow())
       return cres[0]
  end
end

MR.dot = MR.inner -- shortcut

function MC.inner (x, y)
  -- (x:t() * y):tr() without temporary
  assert(isa_matrix(y), "invalid argument #2 (matrix expected)")
  chksiz(x,y)

  if is_matrix(y)
  then _C.mad_cmat_dotm_r(x.data, y.data, cres, x:ncol(), y:ncol(), x:nrow())
  else _C.mad_cmat_dot_r (x.data, y.data, cres, x:ncol(), y:ncol(), x:nrow())
  end
  return cres[0]
end

MC.dot = MC.inner -- shortcut

function MR.cross (x, y, r_)
  assert(isa_matrix(y), "invalid argument #2 (matrix expected)")
  local nr, nc = x:sizes()
  assert(nr == 3, "invalid matrix sizes")
  local r = chksiz(r_,x,y) or is_matrix(x) and is_matrix(y) and matrix(3,nc) or cmatrix(3,nc)
  local i0, i1, i2 = 0, nc, 2*nc
  for i=0,nc-1 do
    r.data[i0] = x.data[i1] * y.data[i2] - x.data[i2] * y.data[i1]
    r.data[i1] = x.data[i2] * y.data[i0] - x.data[i0] * y.data[i2]
    r.data[i2] = x.data[i0] * y.data[i1] - x.data[i1] * y.data[i0]
    i0, i1, i2 = i0+1, i1+1, i2+1
  end
  return r
end

function MR.mixed (x, y, z, r_)
  -- x:cross(y):inner(z) without temporary
  assert(isa_matrix(y), "invalid argument #2 (matrix expected)")
  assert(isa_matrix(z), "invalid argument #3 (matrix expected)")
  local nr, nc = x:sizes()
  assert(nr == 3, "invalid matrix sizes")
  -- single mixed product (r_ ignored)
  if nc == 1 then
    assert(nr == y:nrow() and 1 == y:ncol() and
           nr == z:nrow() and 1 == z:ncol(), "incompatible matrix sizes")
    return conj(x.data[1] * y.data[2] - x.data[2] * y.data[1]) * z.data[0] +
           conj(x.data[2] * y.data[0] - x.data[0] * y.data[2]) * z.data[1] +
           conj(x.data[0] * y.data[1] - x.data[1] * y.data[0]) * z.data[2]
  end
  -- multiple mixed products
  local r = r_ or is_matrix(x) and is_matrix(y) and matrix(nc,1) or cmatrix(nc,1)
  assert(nr == y:nrow() and nc == y:ncol() and
         nr == z:nrow() and nc == z:ncol() and
         nc == r:nrow() and 1  == r:ncol(), "incompatible matrix sizes")
  local i0, i1, i2 = 0, nc, 2*nc
  for i=0,nc-1 do
    r.data[i] = conj(x.data[i1] * y.data[i2] - x.data[i2] * y.data[i1]) * z.data[i0] +
                conj(x.data[i2] * y.data[i0] - x.data[i0] * y.data[i2]) * z.data[i1] +
                conj(x.data[i0] * y.data[i1] - x.data[i1] * y.data[i0]) * z.data[i2]
    i0, i1, i2 = i0+1, i1+1, i2+1
  end
  return r
end

function MR.outer (x, y, r_)
  -- x * y:t() without temporary
  assert(isa_matrix(y), "invalid argument #2 (matrix expected)")
  local nr, nc = x:nrow(), y:nrow()
  assert(x:ncol() == 1 and y:ncol() == 1, "incompatible matrix sizes")
  local r = r_ or is_matrix(x) and is_matrix(y) and matrix(nr,nc) or cmatrix(nr,nc)
  assert(nr == r:nrow() and nc == r:ncol(), "incompatible matrix sizes")
  for i=0,nr-1 do
  for j=0,nc-1 do set0(r,i,j, x.data[i] * conj(y.data[j])) end end
  return r
end

-- norm, unit, center, angle (in place) ---------------------------------------o

-- Frobenius norm (consistent with inner product)
function MR.norm (x)
  -- sqrt( (x:t() * x):tr() ) without temporary
  return sqrt(_C.mad_vec_dot(x.data, x.data, x:size()))
end

function MC.norm (x)
  -- sqrt( (x:t() * x):tr() ) without temporary
  _C.mad_cvec_dot_r(x.data, x.data, cres, x:size())
  return sqrt(cres[0])
end

function MR.unit (x, r_)
  local n = x:norm()
  assert(n ~= 0, "null matrix norm")
  local r = chksiz(r_,x) or x
  _C.mad_vec_divn(x.data, n, r.data, r:size())
  return r
end

function MC.unit (x, r_)
  local n = x:norm()
  assert(n ~= 0, "null matrix norm")
  local r = chksiz(r_,x) or x
  _C.mad_vec_divc_r(x.data, n.re, n.im, r.data, r:size())
  return r
end

function MR.center (x, r_) -- center data on mean
  local r = chksiz(r_,x) or x
  if is_vector(x)
  then _C.mad_vec_center(x.data, r.data, x:size())
  else _C.mad_mat_center(x.data, r.data, x:nrow(), x:ncol())
  end
  return r
end

function MC.center (x, r_) -- center data on mean
  local r = chksiz(r_,x) or x
  if is_cvector(x)
  then _C.mad_cvec_center(x.data, r.data, x:size())
  else _C.mad_cmat_center(x.data, r.data, x:nrow(), x:ncol())
  end
  return r
end

function MR.angle (x, y, n_)
  local w = x:inner(y)
  local v = x:norm() * y:norm()
  assert(v ~= 0, "null vector norm") -- convention: return pi/2 ?
  local a = acos(w / v) -- [0, pi]
  if n_ and x:mixed(y, n_) < 0 then a = -a end -- [-pi, pi]
  return a
end

-- generic functions ----------------------------------------------------------o

MR.copy  = \x,r_ -> x:mapv(ident, r_)

MR.abs   = \x,r_ -> x:mapv(abs  , r_)

MR.ceil  = \x,r_ -> x:mapv(ceil , r_)
MR.floor = \x,r_ -> x:mapv(floor, r_)
MR.round = \x,r_ -> x:mapv(round, r_)
MR.frac  = \x,r_ -> x:mapv(frac , r_)
MR.trunc = \x,r_ -> x:mapv(trunc, r_)

MR.sqrt  = \x,r_ -> x:mapv(sqrt , r_)
MR.exp   = \x,r_ -> x:mapv(exp  , r_)
MR.log   = \x,r_ -> x:mapv(log  , r_)
MR.log10 = \x,r_ -> x:mapv(log10, r_)

MR.sin   = \x,r_ -> x:mapv(sin  , r_)
MR.cos   = \x,r_ -> x:mapv(cos  , r_)
MR.tan   = \x,r_ -> x:mapv(tan  , r_)
MR.sinh  = \x,r_ -> x:mapv(sinh , r_)
MR.cosh  = \x,r_ -> x:mapv(cosh , r_)
MR.tanh  = \x,r_ -> x:mapv(tanh , r_)

MR.asin  = \x,r_ -> x:mapv(asin , r_)
MR.acos  = \x,r_ -> x:mapv(acos , r_)
MR.atan  = \x,r_ -> x:mapv(atan , r_)
MR.asinh = \x,r_ -> x:mapv(asinh, r_)
MR.acosh = \x,r_ -> x:mapv(acosh, r_)
MR.atanh = \x,r_ -> x:mapv(atanh, r_)

MR.erf   = \x,r_ -> x:mapv(erf   , r_)
MR.tgamma= \x,r_ -> x:mapv(tgamma, r_)
MR.lgamma= \x,r_ -> x:mapv(lgamma, r_)

MR.carg  = \x,r_ -> x:mapv(carg , r_)
MR.real  = \x,r_ -> x:mapv(real , r_)
MR.imag  = \x,r_ -> x:mapv(imag , r_)
MR.proj  = \x,r_ -> x:mapv(proj , r_)
MR.rect  = \x,r_ -> x:mapv(rect , r_)
MR.polar = \x,r_ -> x:mapv(polar, r_)

-- special folds --------------------------------------------------------------o

MR.min     = \x,r_,d_ -> x:foldl(min,r_,d_)
MR.max     = \x,r_,d_ -> x:foldl(max,r_,d_)
MR.sum     = \x,r_,d_ -> x:foldl(add,r_,d_)
MR.product = \x,r_,d_ -> x:foldl(mul,r_,d_)

local pred = nil
local all = \r,x land(r, pred(x))
local any = \r,x lor (r, pred(x))

function MR.all (x,p,r_,d_)
  assert(is_nil(pred), "reentrant use of all (not expected)")
  pred=p
  local res = x:foldl(all,r_,d_,true)
  pred=nil
  return res
end

function MR.any (x,p,r_,d_)
  assert(is_nil(pred), "reentrant use of any (not expected)")
  pred=p
  local res = x:foldl(any,r_,d_,false)
  pred=nil
  return res
end

-- generic operators ----------------------------------------------------------o

MR.__unm = \x  ,r_ -> x:mapv(   unm, r_)
MR.__mod = \x,y,r_ -> x:map2(y, mod, r_)
MR.__pow = \x,y,r_ -> x:map2(y, pow, r_)

--[[ TODO
  mexp, mlog, msqrt, mpow using Padé Approximants
]]

function MR.__eq (x, y) -- add tol?
  if is_scalar(y) then
    for i=0,x:size()-1 do
      if x.data[i] ~= y then return false end
    end
    return true
  end
  if x:nrow() ~= y:nrow() or x:ncol() ~= y:ncol() then return false end
  for i=0,x:size()-1 do
    if x.data[i] ~= y.data[i] then return false end
  end
  return true
end

-- add

function MR.__radd_cpx (y, x, r)                  -- cpx + mat => cpx + vec
  r = chksiz(r,y) or cmatrix(y:sizes())
  _C.mad_vec_addc_r(y.data, x.re, x.im, r.data, r:size()) return r
end

function MR.__add (x, y, r)
  if is_number(x) then                           -- num + mat => num + vec
    r = chksiz(r,y) or matrix(y:sizes())
    _C.mad_vec_addn(y.data, x, r.data, r:size()) return r
  elseif is_number(y) then                       -- mat + num => vec + num
    r = chksiz(r,x) or matrix(x:sizes())
    _C.mad_vec_addn(x.data, y, r.data, r:size()) return r
  elseif is_complex(y) then                      -- mat + cpx => vec + cpx
    r = chksiz(r,x) or cmatrix(x:sizes())
    _C.mad_vec_addc_r(x.data, y.re, y.im, r.data, r:size()) return r
  elseif is_matrix(y) and is_matrix(x) then      -- mat + mat => vec + vec
    r = chksiz(r,x,y) or matrix(x:sizes())
    _C.mad_vec_add(x.data, y.data, r.data, r:size()) return r
  elseif is_cmatrix(y) then                      -- mat + cmat => vec + cvec
    r = chksiz(r,x,y) or cmatrix(x:sizes())
    _C.mad_cvec_addv(y.data, x.data, r.data, r:size()) return r
  elseif has_method(y, '__radd_mat') then        -- mat + ?
    return y:__radd_mat(x, r)
  end
  error("invalid arguments (unsupported matrix operation)")
end

function MC.__radd_cpx (y, x, r)                  -- cpx + cmat => cpx + cvec
  r = chksiz(r,y) or cmatrix(y:sizes())
  _C.mad_cvec_addc_r(y.data, x.re, x.im, r.data, r:size()) return r
end

function MC.__add (x, y, r)
  if is_number(x) then                           -- num + cmat => num + cvec
    r = chksiz(r,y) or cmatrix(y:sizes())
    _C.mad_cvec_addn(y.data, x, r.data, r:size()) return r
  elseif is_number(y) then                       -- cmat + num => cvec + num
    r = chksiz(r,x) or cmatrix(x:sizes())
    _C.mad_cvec_addn(x.data, y, r.data, r:size()) return r
  elseif is_complex(y) then                      -- cmat + cpx => cvec + cpx
    r = chksiz(r,x) or cmatrix(x:sizes())
    _C.mad_cvec_addc_r(x.data, y.re, y.im, r.data, r:size()) return r
  elseif is_matrix(y) then                       -- cmat + mat => cvec + vec
    r = chksiz(r,x,y) or cmatrix(x:sizes())
    _C.mad_cvec_addv(x.data, y.data, r.data, r:size()) return r
  elseif is_cmatrix(y) and is_cmatrix(x) then    -- cmat + cmat => cvec + cvec
    r = chksiz(r,x,y) or cmatrix(x:sizes())
    _C.mad_cvec_add(x.data, y.data, r.data, r:size()) return r
  elseif has_method(y, '__radd_cmat') then       -- cmat + ?
    return y:__radd_cmat(x, r)
  end
  error("invalid arguments (unsupported matrix operation)")
end

-- sub

function MR.__rsub_cpx (y, x, r)                  -- cpx - mat => cpx - vec
  r = chksiz(r,y) or cmatrix(y:sizes())
  _C.mad_vec_subc_r(y.data, x.re, x.im, r.data, r:size()) return r
end

function MR.__sub (x, y, r)
  if is_number(x) then                           -- num - mat => num - vec
    r = chksiz(r,y) or matrix(y:sizes())
    _C.mad_vec_subn(y.data, x, r.data, r:size()) return r
  elseif is_number(y) then                       -- mat - num => vec + -num
    r = chksiz(r,x) or matrix(x:sizes())
    _C.mad_vec_addn(x.data, -y, r.data, r:size()) return r
  elseif is_complex(y) then                      -- mat - cpx => vec + -cpx
    r = chksiz(r,x) or cmatrix(x:sizes())
    _C.mad_vec_addc_r(x.data, -y.re, -y.im, r.data, r:size()) return r
  elseif is_matrix(y) and is_matrix(x) then      -- mat - mat => vec - vec
    r = chksiz(r,x,y) or matrix(x:sizes())
    _C.mad_vec_sub(x.data, y.data, r.data, r:size()) return r
  elseif is_cmatrix(y) then                      -- mat - cmat => vec - cvec
    r = chksiz(r,x,y) or cmatrix(x:sizes())
    _C.mad_cvec_subv(y.data, x.data, r.data, r:size()) return r
  elseif has_method(y, '__rsub_mat') then        -- mat - ?
    return y:__rsub_mat(x, r)
  end
  error("invalid arguments (unsupported matrix operation)")
end

function MC.__rsub_cpx (y, x, r)                  -- cpx - cmat => cpx - cvec
  r = chksiz(r,y) or cmatrix(y:sizes())
  _C.mad_cvec_subc_r(y.data, x.re, x.im, r.data, r:size()) return r
end

function MC.__sub (x, y, r)
  if is_number(x) then                           -- num - cmat => num - cvec
    r = chksiz(r,y) or cmatrix(y:sizes())
    _C.mad_cvec_subn(y.data, x, r.data, r:size()) return r
  elseif is_number(y) then                       -- cmat - num => cvec + -num
    r = chksiz(r,x) or cmatrix(x:sizes())
    _C.mad_cvec_addn(x.data, -y, r.data, r:size()) return r
  elseif is_complex(y) then                      -- cmat - cpx => cvec + -cpx
    r = chksiz(r,x) or cmatrix(x:sizes())
    _C.mad_cvec_addc_r(x.data, -y.re, -y.im, r.data, r:size()) return r
  elseif is_matrix(y) then                       -- cmat - mat => cvec - vec
    r = chksiz(r,x,y) or cmatrix(x:sizes())
    _C.mad_cvec_subv(x.data, y.data, r.data, r:size()) return r
  elseif is_cmatrix(y) and is_cmatrix(x) then    -- cmat - cmat => cvec - cvec
    r = chksiz(r,x,y) or cmatrix(x:sizes())
    _C.mad_cvec_sub(x.data, y.data, r.data, r:size()) return r
  elseif has_method(y, '__rsub_cmat') then       -- cmat - ?
    return y:__rsub_cmat(x, r)
  end
  error("invalid arguments (unsupported matrix operation)")
end

-- mul

function MR.__rmul_cpx (y, x, r)                  -- cpx * mat => cpx * vec
  r = chksiz(r,y) or cmatrix(y:sizes())
  _C.mad_vec_mulc_r(y.data, x.re, x.im, r.data, r:size()) return r
end

function MR.__mul (x, y, r)
  if is_number(x) then                           -- num * mat => num * vec
    r = chksiz(r,y) or matrix(y:sizes())
    _C.mad_vec_muln(y.data, x, r.data, r:size()) return r
  elseif is_number(y) then                       -- mat * num => vec * num
    r = chksiz(r,x) or matrix(x:sizes())
    _C.mad_vec_muln(x.data, y, r.data, r:size()) return r
  elseif is_complex(y) then                      -- mat * cpx => vec * cpx
    r = chksiz(r,x) or cmatrix(x:sizes())
    _C.mad_vec_mulc_r(x.data, y.re, y.im, r.data, r:size()) return r
  elseif is_matrix(y) and is_matrix(x) then      -- mat * mat => vec * vec
    r = chksizm(r,x,y) or matrix(x:nrow(), y:ncol())
    _C.mad_mat_mul(x.data, y.data, r.data, r:nrow(), r:ncol(), x:ncol()) return r
  elseif is_cmatrix(y) then                      -- mat * cmat => vec * cvec
    r = chksizm(r,x,y) or cmatrix(x:nrow(), y:ncol())
    _C.mad_mat_mulm(x.data, y.data, r.data, r:nrow(), r:ncol(), x:ncol()) return r
  elseif has_method(y, '__rmul_mat') then        -- mat * ?
    return y:__rmul_mat(x, r)
  end
  error("invalid arguments (unsupported matrix operation)")
end

function MC.__rmul_cpx (y, x, r)                  -- cpx * cmat => cpx * cvec
  r = chksiz(r,y) or cmatrix(y:sizes())
  _C.mad_cvec_mulc_r(y.data, x.re, x.im, r.data, r:size()) return r
end

function MC.__mul (x, y, r)
  if is_number(x) then                           -- num * cmat => num * cvec
    r = chksiz(r,y) or cmatrix(y:sizes())
    _C.mad_cvec_muln(y.data, x, r.data, r:size()) return r
  elseif is_number(y) then                       -- cmat * num => cvec * num
    r = chksiz(r,x) or cmatrix(x:sizes())
    _C.mad_cvec_muln(x.data, y, r.data, r:size()) return r
  elseif is_complex(y) then                      -- cmat * cpx => cvec * cpx
    r = chksiz(r,x) or cmatrix(x:sizes())
    _C.mad_cvec_mulc_r(x.data, y.re, y.im, r.data, r:size()) return r
  elseif is_matrix(y) then                       -- cmat * mat => cvec * vec
    r = chksizm(r,x,y) or cmatrix(x:nrow(), y:ncol())
    _C.mad_cmat_mulm(x.data, y.data, r.data, r:nrow(), r:ncol(), x:ncol()) return r
  elseif is_cmatrix(y) and is_cmatrix(x) then    -- cmat * cmat => cvec * cvec
    r = chksizm(r,x,y) or cmatrix(x:nrow(), y:ncol())
    _C.mad_cmat_mul(x.data, y.data, r.data, r:nrow(), r:ncol(), x:ncol()) return r
  elseif has_method(y, '__rmul_cmat') then         -- cmat * ?
    return y:__rmul_cmat(x, r)
  end
  error("invalid arguments (unsupported matrix operation)")
end

-- div

function MR.__rdiv_cpx (y, x, r, rcond_)          -- cpx / mat
  r = chksiz(r,y) or cmatrix(y:sizes())
  _C.mad_mat_invc_r (y.data, x.re, x.im, r.data, y:nrow(), y:ncol(), rcond_ or -1) return r
end

function MR.__div (x, y, r, rcond_)
  if is_number(x) then                           -- num / mat
    r = chksiz(r,y) or matrix(y:sizes())
    _C.mad_mat_invn (y.data, x, r.data, y:nrow(), y:ncol(), rcond_ or -1) return r
  elseif is_number(y) then                       -- mat / num => vec / num
    r = chksiz(r,x) or matrix(x:sizes())
    _C.mad_vec_divn(x.data, y, r.data, r:size()) return r
  elseif is_complex(y) then                      -- mat / cpx => vec / cpx
    r = chksiz(r,x) or cmatrix(x:sizes())
    _C.mad_vec_divc_r(x.data, y.re, y.im, r.data, r:size()) return r
  elseif is_matrix(y) and is_matrix(x) then      -- mat / mat => vec / vec
    r = chksizd(r,x,y) or matrix(x:nrow(), y:nrow())
    _C.mad_mat_div(x.data, y.data, r.data, r:nrow(), r:ncol(), x:ncol(), rcond_ or -1) return r
  elseif is_cmatrix(y) then                      -- mat / cmat => vec / cvec
    r = chksizd(r,x,y) or cmatrix(x:nrow(), y:nrow())
    _C.mad_mat_divm(x.data, y.data, r.data, r:nrow(), r:ncol(), x:ncol(), rcond_ or -1) return r
  elseif has_method(y, '__rdiv_mat') then        -- mat / ?
    return y:__rdiv_mat(x, r)
  end
  error("invalid arguments (unsupported matrix operation)")
end

function MC.__rdiv_cpx (y, x, r, rcond_)         -- cpx / cmat
  r = chksiz(r,y) or cmatrix(y:sizes())
  _C.mad_cmat_invc_r(y.data, x.re, x.im, r.data, y:nrow(), y:ncol(), rcond_ or -1)
  return r
end

function MC.__div (x, y, r, rcond_)
  if is_number(x) then                           -- num / cmat => num / cvec
    r = chksiz(r,y) or cmatrix(y:sizes())
    _C.mad_cmat_invn(y.data, x, r.data, y:nrow(), y:ncol(), rcond_ or -1) return r
  elseif is_number(y) then                       -- cmat / num => cvec / num
    r = chksiz(r,x) or cmatrix(x:sizes())
    _C.mad_cvec_divn(x.data, y, r.data, r:size()) return r
  elseif is_complex(y) then                      -- cmat / cpx => cvec / cpx
    r = chksiz(r,x) or cmatrix(x:sizes())
    _C.mad_cvec_divc_r(x.data, y.re, y.im, r.data, r:size()) return r
  elseif is_matrix(y) then                       -- cmat / mat => cvec / vec
    r = chksizd(r,x,y) or cmatrix(x:nrow(), y:nrow())
    _C.mad_cmat_divm(x.data, y.data, r.data, r:nrow(), r:ncol(), x:ncol(), rcond_ or -1) return r
  elseif is_cmatrix(y) and is_cmatrix(x) then    -- cmat / cmat => cvec / cvec
    r = chksizd(r,x,y) or cmatrix(x:nrow(), y:nrow())
    _C.mad_cmat_div(x.data, y.data, r.data, r:nrow(), r:ncol(), x:ncol(), rcond_ or -1) return r
  elseif has_method(y, '__rdiv_cmat') then       -- cmat / ?
    return y:__rdiv_cmat(x, r)
  end
  error("invalid arguments (unsupported matrix operation)")
end

-- element wise mul and div

function MR.emul (x, y, r_)
  assert(isa_matrix(y), "invalid argument #2 (matrix expected)")
  local r = chksiz(r_,x,y) or is_matrix(y) and matrix(x:sizes()) or cmatrix(x:sizes())
  if is_matrix(y)
  then _C.mad_vec_mul  (x.data, y.data, r.data, r:size())
  else _C.mad_cvec_mulv(y.data, x.data, r.data, r:size())
  end
  return r
end

function MC.emul (x, y, r_)
  assert(isa_matrix(y), "invalid argument #2 (matrix expected)")
  local r = chksiz(r_,x,y) or cmatrix(x:sizes())
  if is_matrix(y)
  then _C.mad_cvec_mulv(y.data, x.data, r.data, r:size())
  else _C.mad_cvec_mul (x.data, y.data, r.data, r:size())
  end
  return r
end

function MR.ediv (x, y, r_)
  assert(isa_matrix(y), "invalid argument #2 (matrix expected)")
  local r = chksiz(r_,x,y) or is_matrix(y) and matrix(x:sizes()) or cmatrix(x:sizes())
  if is_matrix(y)
  then _C.mad_vec_div (x.data, y.data, r.data, r:size())
  else _C.mad_vec_divv(x.data, y.data, r.data, r:size())
  end
  return r
end

function MC.ediv (x, y, r_)
  assert(isa_matrix(y), "invalid argument #2 (matrix expected)")
  local r = chksiz(r_,x,y) or cmatrix(x:sizes())
  if is_matrix(y)
  then _C.mad_cvec_divv(x.data, y.data, r.data, r:size())
  else _C.mad_cvec_div (x.data, y.data, r.data, r:size())
  end
  return r
end

-- linear algebra -------------------------------------------------------------o

function MR.solve (a, b, rcond_)
  return b:t():div(a:t(), nil, rcond_):t()
end

function MR.svd (x)
  local nr, nc = x:sizes()
  local rs, ru, rv, info = matrix(min(nr,nc),1)
  if is_matrix(x) then
    ru, rv = matrix(nr,nr), matrix(nc,nc)
    info = _C.mad_mat_svd (x.data, ru.data, rs.data, rv.data, x:nrow(), x:ncol())
  else
    ru, rv = cmatrix(nr,nr), cmatrix(nc,nc)
    info = _C.mad_cmat_svd(x.data, ru.data, rs.data, rv.data, x:nrow(), x:ncol())
  end
  return ru, rs, rv, info
end

function MR.eigen (x)
  local nr, nc = x:sizes()
  assert(nr == nc, "matrix must be square")
  local w, vl, vr, info = cmatrix(nr, 1)
  if is_matrix(x) then
    vl, vr = matrix(nr,nr), matrix(nr,nr)
    info = _C.mad_mat_eigen (x.data, w.data, vl.data, vr.data, x:nrow())
  else
    vl, vr = cmatrix(nr,nr), cmatrix(nr,nr)
    info = _C.mad_cmat_eigen(x.data, w.data, vl.data, vr.data, x:nrow())
  end
  return w, vl, vr, info
end

-- FFT, convolution, correlation, covrariance ---------------------------------o

function MR.fft (x, r_)
  local nr, nc = x:sizes()
  local r = chksiz(r_, x) or cmatrix(nr,nc)
  if nr == 1 or nc == 1 then -- 1D FFT
    if is_matrix(x)
    then _C.mad_vec_fft (x.data, r.data, x:size())
    else _C.mad_cvec_fft(x.data, r.data, x:size())
    end
  else                       -- 2D FFT
    if is_matrix(x)
    then _C.mad_mat_fft (x.data, r.data, x:nrow(), x:ncol())
    else _C.mad_cmat_fft(x.data, r.data, x:nrow(), x:ncol())
    end
  end
  return r
end

function MR.ifft (x, r_)
  local nr, nc = x:sizes()
  local r = chksiz(r_, x) or cmatrix(nr,nc)
  if nr == 1 or nc == 1
  then _C.mad_cvec_ifft(x.data, r.data, x:size())           -- 1D FFT
  else _C.mad_cmat_ifft(x.data, r.data, x:nrow(), x:ncol()) -- 2D FFT
  end
  return r
end

function MR.rfft (x, r_)
  assert(is_matrix(x), "matrix must be real")
  local nr, nc = x:sizes()
  local r
  if nr == 1 or nc == 1 then -- 1D FFT
    nr, nc = floor(nr/2+1), floor(nc/2+1)
    r = r_ or cmatrix(nr,nc)
    assert(nr == r:nrow() and nc == r:ncol(), "incompatible matrix sizes")
    _C.mad_vec_rfft(x.data, r.data, x:size())
  else                       -- 2D FFT
    nc = floor(nc/2+1)
    r = r_ or cmatrix(nr,nc)
    assert(nr == r:nrow() and nc == r:ncol(), "incompatible matrix sizes")
    _C.mad_mat_rfft(x.data, r.data, x:nrow(), x:ncol())
  end
  return r
end

function MR.irfft (x, r_) -- r_ can be the length
  assert(not r_ or is_matrix(r_), "result matrix must be real")
  local nr, nc = x:sizes()
  local r
  if nr == 1 or nc == 1 then -- 1D FFT
    nr, nc = max(1,(nr-1)*2), max(1,(nc-1)*2)
    r = r_ or matrix(nr,nc)
    assert(nr == r:nrow() or nr+1 == r:nrow() and
           nc == r:ncol() or nc+1 == r:ncol(), "incompatible matrix sizes")
    _C.mad_cvec_irfft(x.data, r.data, r:size())
  else                       -- 2D FFT
    nc = (nc-1)*2
    r = r_ or matrix(nr,nc)
    assert(nr == r:nrow() and
           nc == r:ncol() or nc+1 == r:ncol(), "incompatible matrix sizes")
    _C.mad_cmat_irfft(x.data, r.data, r:nrow(), r:ncol())
  end
  return r
end

function MR.conv (x, y, r_) -- convolution theorem
  local r = r_ or x:same()
  if is_matrix(x) then -- mat
    local xf = x:rfft()
    if x == y then return xf:emul(xf      ,xf):irfft(r)
    else           return xf:emul(y:rfft(),xf):irfft(r)
    end
  else             -- cmat
    local xf = x:fft()
    if x == y then return xf:emul(xf     ,xf):ifft(r)
    else           return xf:emul(y:fft(),xf):ifft(r)
    end
  end
end

function MR.corr (x, y, r_) -- correlation theorem
  local r = r_ or x:same()
  if is_matrix(x) then -- mat
    local xf, yf = x:rfft()
    if x == y then     return xf:emul(xf:conj(  ),xf):irfft(r)
    else yf = y:rfft() return xf:emul(yf:conj(yf),xf):irfft(r)
    end
  else             -- cmat
    local xf, yf = x:fft()
    if x == y then     return xf:emul(xf:conj(  ),xf):ifft(r)
    else yf = y:fft()  return xf:emul(yf:conj(yf),xf):ifft(r)
    end
  end
end

function MR.covar (x, y, r_) -- covariance of random (row) vectors
  local xc = x:center(x:same())
  if x == y then return xc:corr(xc                , r_)
  else           return xc:corr(y:center(y:same()), r_)
  end
end

-- concatenation, conversion --------------------------------------------------o

MR.__len = MR.size

function MR.__concat (x, y, v_, r_)
  assert(isa_matrix(y), "matrix expected for 2nd argument")
  local nrx, ncx = x:sizes()
  local nry, ncy = y:sizes()
  if is_nil(v_) or v_ == 'col' then -- concat columns (vectical)
    local nr, nc = nrx + nry, ncx
    local r = r_ or is_matrix(x) and is_matrix(y) and matrix(nr,nc) or cmatrix(nr,nc)
    assert(ncx == ncy and nr == r:nrow() and nc == r:ncol(), "incompatible matrix sizes")
    local nx, ny = nrx * nc, nry * nc
    for i=0,nx-1 do seti0(r,i   , geti0(x,i)) end
    for i=0,ny-1 do seti0(r,i+nx, geti0(y,i)) end
  elseif v_ == 'row' then           -- concat rows (horizontal)
    local nr, nc = nrx, ncx + ncy
    local r = r_ or is_matrix(x) and is_matrix(y) and matrix(nr,nc) or cmatrix(nr,nc)
    assert(nrx == nry and nr == r:nrow() and nc == r:ncol(), "incompatible matrix sizes")
    for i=0,nr do
      for j=0,ncx-1 do set0(r,i,j    , get0(x,i,j)) end
      for j=0,ncy-1 do set0(r,i,j+ncx, get0(y,i,j)) end
    end
  else
    error("invalid argument #3 ('row|col' expected)")
  end
  return r
end

function MR.__tostring (x, sep_, lsep_)
  local nr, nc = x:sizes()
  local r, c = table.new(nr,0), table.new(nc,0)
  for i=0,nr-1 do
    for j=0,nc-1 do
      c[j+1] = tostring(get0(x,i,j))
    end
    r[i+1] = table.concat(c, sep_ or ' ')
  end
  return table.concat(r, lsep_ or '\n')
end

function MR.__totable (x, r_)
  local nr, nc = x:sizes()
  local r = r_ or table.new(nr,0)
  assert(type(r) == 'table', "invalid argument #2 (table expected)")
  for i=0,nr-1 do
    local c = r[i+1] or table.new(nc,0)
    assert(type(c) == 'table', "invalid argument #2, (table of tables expected)")
    for j=0,nc-1 do c[j+1] = get0(x,i,j) end
    r[i+1] = c
  end
  return r
end

function linspace (start, stop, n_)
  local n = n_ or 100
  assert(is_number(n) or n > 0, "invalid argument #3 (size expected)")
  local v = (is_complex(start) or is_complex(stop)) and cvector(n) or vector(n)
  local step = n > 1 and (stop-start)/(n-1) or 0
  for i=0,n-1 do seti0(v, i, start+step*i) end
  return v
end

function logspace (start, stop, n_)
  local n = n_ or 100
  assert(is_number(n) or n > 0, "invalid argument #3 (size expected)")
  local v = (is_complex(start) or is_complex(stop)) and cvector(n) or vector(n)
  local logstart, logstop = log(start), log(stop)
  local logstep = n > 1 and (logstop-logstart)/(n-1) or 0
  for i=0,n-1 do seti0(v, i, exp(logstart+logstep*i)) end
  return v
end

-- metamethods ----------------------------------------------------------------o

MR.  unm, MR.  add, MR.  sub, MR.  mul, MR.  div, MR.  mod, MR.  pow =
MR.__unm, MR.__add, MR.__sub, MR.__mul, MR.__div, MR.__mod, MR.__pow

MC.  add, MC.  sub, MC.  mul, MC.  div =
MC.__add, MC.__sub, MC.__mul, MC.__div

MR.  eq, MR.length, MR.  concat =
MR.__eq, MR.__len , MR.__concat

local function iter (x, i)
  if i < x:size() then return i+1, geti0(x, i) end
end

MR.__ipairs = \s -> (iter, s, 0)

function MR.__index (s, i)
  if is_number(i) then return s:geti(i) else return MR[i] end
end

function MC.__index (s, i)
  if is_number(i) then return s:geti(i) else return MC[i] end
end

function MR.__newindex (s, i, x)
  if is_number(i)
  then s:seti(i, x)
  else error("invalid matrix member '"..tostring(i).."'")
  end
end

-- matrices -------------------------------------------------------------------o

defhelp(MR) -- todo: per function help -> 'matrix'

for k,v in pairs(MR) do
  if is_nil(MC[k]) then MC[k] = v end
end

metatype( matrix_ctor, MR)
metatype(cmatrix_ctor, MC)

-- end ------------------------------------------------------------------------o
return {
  vector     = vector,
  cvector    = cvector,
  matrix     = matrix,
  cmatrix    = cmatrix,

  is_vector  = is_vector,
  is_matrix  = is_matrix,
  is_cvector = is_cvector,
  is_cmatrix = is_cmatrix,
  isa_vector = isa_vector,
  isa_matrix = isa_matrix,

  linspace   = linspace,
  logspace   = logspace,

  __help     = MR.__help
}
