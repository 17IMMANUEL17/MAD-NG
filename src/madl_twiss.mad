--[=[
 o-----------------------------------------------------------------------------o
 |
 | Twiss module
 |
 | Methodical Accelerator Design - Copyright (c) 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - TODO

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local command, track, cofind, option, warn, vector, matrix        in MAD
local normal, optfun, betablk, dp2pt, has_dpt,
      ofname, ofcname, cvindex, msort                             in MAD.gphys
local ffalse, ftrue, fnone, chain, achain                         in MAD.gfunc
local tblcat, tblcpy, tblrep, assertf, errorf, printf             in MAD.utility
local is_nil, is_true, is_boolean, is_number, is_iterable,
      is_mappable, is_callable, is_vector, is_damap               in MAD.typeid
local atins                                                       in MAD.symint
local abs, min, max, sqrt, floor                                  in math

local chromdp = 1e-6

local assert, error, getmetatable, setmetatable, table =
      assert, error, getmetatable, setmetatable, table

local r4 = 1..4
local I4 = matrix(4):eye()
local I6 = matrix(6):eye()

-- helpers --------------------------------------------------------------------o

local function mdump (mflw, msg_, str_)
  local fmt = option.format
  local msg, str = msg_ or '', str_ or 'M'
  option.format = "% 10.5f"
  for i=1,mflw.npar or #mflw do
    printf("%s%d: ", msg, i)
    mflw[i]:get0():print(str,1e-12,'line')
    if option.debug >= 3 then
      mflw[i]:get1():print(' "     ')
    end
  end
  option.format = fmt
end

-- twiss mtable ---------------------------------------------------------------o

local cvtlst = {'deltap',
                'q1', 'q2', 'q3', 'dq1', 'dq2', 'dq3',
                'alfap','etap','gammatr','synch_1'}

local function fill_sum (mflw)
  local mtbl, __twdat in mflw

  -- chromaticity
  if __twdat.chrm then
    local q1, q2, q3, dq1, dq2, dq3, chrm in __twdat
    local deltap in mtbl
    local n = floor(#q1/2)

    for i=1,mflw.npar do
      local id = mflw[i].id
      if id > n then id = id-n end
      if not dq1[id] then
        dq1[id] = (q1[id+n] - q1[id])/chrm
        dq2[id] = (q2[id+n] - q2[id])/chrm
        dq3[id] = (q3[id+n] - q3[id])/chrm
      end
    end

    -- cleaning
    for i=n+1,2*n   do q1[i], q2[i], q3[i] = nil, nil, nil end
    for i=1,#deltap do deltap[i]           = nil           end
  end

  -- momentum compaction & phase slip factors, gamma transition
  local synch_1, alfap, etap, gammatr in __twdat
  local len, beam = mflw.sequ.l, mflw.beam
  local n = #synch_1

  for i=1,mflw.npar do
    local id, beam = mflw[i].id, mflw[i].beam or beam
    if id > n then id = id-n end
    if not alfap[id] then
      local ap = synch_1[id]/len
      local as = sqrt(abs(ap))
      alfap  [id] = ap
      etap   [id] = as > 0 and ap - 1/beam.gamma^2 or 0
      gammatr[id] = as > 0 and as/ap or 0
    end
  end

  -- link data to mtbl
  for i=2,#cvtlst do -- skip deltap
    local k = cvtlst[i]
    mtbl[k] = __twdat[k]
  end

  -- mute list of 0 or 1 number into 0 or the number in header
  for _,k in ipairs(cvtlst) do
    local v = mtbl[k]
    if is_iterable(v) then
      local n = #v
          if n == 0 then mtbl[k] = 0
      elseif n == 1 then mtbl[k] = v[1]
      end
    end
  end
end

local function fill (elm, mflw, lw, islc)
!  printf("tw_fill: islc=%2d, elm=%s\n", islc, elm.name)

  local npar, mtbl, __twdat in mflw
  local orow, ofun, onam, q1, q2, q3 in __twdat

-- print("twfill", elm.name, #mtbl, npar, orow)

  for i=1,npar do
    local m = mflw[i]
    if not m.nosave then
      local id, of = m.id, ofun[m.id]

      orow = orow + 1
      -- save optical functions (keep order !)
      for _,k in ipairs(onam) do mtbl[k][orow] = of[k] end
      -- save phase advances
      mtbl.mu1[orow], mtbl.mu2[orow], mtbl.mu3[orow] = q1[id], q2[id], q3[id]
    end
  end

  __twdat.orow = orow
  return true
end

-- optfun (action) ------------------------------------------------------------o

local function optfunact (elm, mflw, lw, islc)
  if not mflw.__twdat then return end
!  printf("tw_ofun: islc=%2d, elm=%s\n", islc, elm.name)

  local npar, eh, clw, __twdat in mflw
  local opar, ofun, omat, pclw, q1, q2, q3, synch_1 in __twdat

  for i=1,npar do
    local m = mflw[i]
    local id, of = m.id, ofun[m.id]

    -- backup phases and horizontal dispersion
    local mu1_, mu2_, mu3_ = of.mu1 or 0, of.mu2 or 0, of.mu3 or 0
    local dx_ = of.dx or 0

    optfun(m:get1(omat), of)

    -- adjust the phases
    local dmu1, dmu2, dmu3 = of.mu1-mu1_, of.mu2-mu2_, of.mu3-mu3_

    if dmu1 < 0 then dmu1 = dmu1+1 end
    if dmu2 < 0 then dmu2 = dmu2+1 end
    if dmu3 < 0 then dmu3 = dmu3+1 end

    -- update the tunes
    q1[id] = q1[id] + dmu1
    q2[id] = q2[id] + dmu2
    q3[id] = q3[id] + dmu3

    if option.debug >= 2 then
      io.write("Phase advance (%d): ", id,
               ", mu1=", q1[id], ", mu2=", q1[id], ", mu3=", q1[id], "\n")
    end

    -- update first synch integral by step average TODO: REVIEW vs MADX!
    if id <= opar then
      synch_1[id] = synch_1[id] + eh*(clw-pclw)*(of.dx+dx_)/2
    end
  end

  __twdat.pclw = islc == -2 and 0 or clw
end

-- chrom option ---------------------------------------------------------------o

local function chrom_dps (self)
  local chrom, deltap = self.chrom, self.deltap or 0
  local cdp = chrom == true and chromdp or chrom
  local dps = is_number(deltap) and {deltap} or deltap
  assert(is_number  (cdp), "invalid chrom attribute (number expected)")
  assert(is_iterable(dps), "invalid deltap attribute (iterable expected)")

  -- double the list of deltap
  local ndp  = #dps
  local cdps = table.new(2*ndp,0)
  for i,v in ipairs(dps) do
    cdps[i], cdps[i+ndp] = v, v+cdp
  end

  -- update self
  self.deltap = cdps
end

-- beta0 block ----------------------------------------------------------------o

local function twiss_betblk (self, mflw)
  local beta0, coupling in self
  local __twdat in mflw

  if not beta0 or not is_mappable(beta0[1]) then
    beta0 = {beta0}
  end

  local findco = false

  for i=1,mflw.npar do
    local m = mflw[i]
    if m.status == 'Xset' then
      local id = m.id0 or m.id
      if beta0[id] then
        local of = tblcpy(beta0[id]) ; of.id = m.id
        -- get linear normal form A from beta0 block and set damap
        m:set1(betablk(of,true)).status = 'Bset'
        -- save beta0 block
        __twdat.ofun[m.id] = of
      else              -- search for closed orbit
        findco = true
      end
    end
  end

  if self.cofind == true and findco == false then
    self.cofind = false -- closed orbit search not needed (was requested)

    if option.debug >= 2 then
      io.write("No particle found (only beta0 or damap), cofind disabled\n")
    end
  end
end

-- closed orbit ---------------------------------------------------------------o

local function twiss_cofind (self, mflw0)
  local npar in mflw0
  local X0, Xi = table.new(npar,0), table.new(npar,0)

  -- get initial guess(es)
  local j = 1
  for i=1,npar do
    local m = mflw0[i]
    if m.status == 'Xset' then
      X0[j], Xi[j]  = m:get0():totable(), i
      X0[j].beam, j = m.beam, j+1
    end
  end

  -- nothing to process (no particles)
  if j == 1 then return end

  local mapdef = not self.codiff -- nil or false codiff use {xy=1}
  local codiff = self.codiff == true and cofind.codiff or self.codiff

  -- retrieve closed orbit(s) [TODO: disable knobs]
  local _, mflw = cofind { exec=false } :copy_variables(self)
                         { X0=X0, deltap=0, save=false, nstep=-1,
                           mapdef=mapdef, codiff=codiff }

  -- update damaps with their closed orbit (tw: i, co: j)
  for j=1,mflw.tpar do
    local m, m0 = mflw[j], mflw0[Xi[mflw[j].id]]
    m0.status = m.status
    if m.status == 'stable' then
      m0:setvar(is_damap(m) and m:get0() or m)
      m0.coR = m.coR -- backup one-turn-map from last cofind iteration
    end
  end

  -- report
  if mflw.npar ~= mflw.tpar then
    warn("%d/%d particles are unstable/singular/lost after closed orbit search",
         mflw.tpar - mflw.npar, mflw.tpar)
    msort(mflw0)
  end
end

-- track one-turn-map ---------------------------------------------------------o

local function twiss_track (self, mflw0)
  local npar in mflw0
  local X0, Xi = table.new(npar,0), table.new(npar,0)

  -- track 'Xset' and 'stable' damaps
  local j = 1
  for i=1,npar do
    local m = mflw0[i]
    if m.status == 'Xset' or m.status == 'stable' then
      X0[j], Xi[j]  = m:get0():totable(), i
      X0[j].beam, j = m.beam, j+1
    end
  end

  -- nothing to process (no damaps)
  if j == 1 then return end

  -- get one-turn-maps to user-defined orders
  local _, mflw = track { exec=false } :copy_variables(self)
                        { X0=X0, deltap=0, save=false, nstep=-1 }

  -- update damaps with their one-turn-map on the closed orbit (tw: i, tk: j)
  for j=1,mflw.tpar do
    local m, m0 = mflw[j], mflw0[Xi[mflw[j].id]]
    if m.status == 'Xset'
    then m:copy(m0)
    else warn("unexpected damap (%d) status (%s) after tracking on closed orbit",
              m.id, m.status) end
  end

  -- report
  if mflw.npar ~= mflw.tpar then
    warn("%d/%d particles lost after during tracking on the closed orbit",
         mflw.tpar - mflw.npar, mflw.tpar)
    msort(mflw0)
  end
end

-- normal/closed forms --------------------------------------------------------o

local function check_normal (R, A, of)
  local fmt = option.format
  option.format = "% .5e"
  io.write("Checking normal form vs optical functions\n")
  R:print('R') ; A:print('A') ; show(of); betablk(of):print('A(optfun)')
  option.format = fmt
end

local function twiss_nform (self, mflw)
  local beta0, coupling in self
  local npar, __twdat in mflw

  for i=1,npar do
    local m = mflw[i]

    if m.status ~= 'Bset' then
      local X, R = m:get0(), m:get1()
      local rnk = has_dpt(R) and 6 or 4

      -- get linear normal form A from one-turn map R
      local A, W, info = normal(R, rnk) -- TODO: high order normal form

      -- get initial linear optical functions and phase advances
      local of = optfun(A, rnk, coupling, W)

      -- set damap
      m:setvar(X):set1(A)

      -- check normal form
      if option.debug >= 2 then check_normal(R, A, of) end

      -- clear initial phase advances, set id
      of.id, of.mu1, of.mu2, of.mu3 = m.id, 0, 0, 0

      -- save beta0 block
      __twdat.ofun[m.id] = of
    end
  end
end

-- extend track mflw and mtbl -------------------------------------------------o

local twheader = {
  'chrom', 'coupling',
  'q1', 'q2', 'q3', 'dq1', 'dq2', 'dq3', 'alfap', 'etap', 'gammatr',
  'synch_1', -- see also cvtlst above
}

local function twiss_init (self, mflw)
  local save, chrom, coupling in self
  local npar, mtbl, __twdat in mflw
  local n = npar

  -- do not save extra rows created by chrom
  if chrom then
    n = npar/2
    for i=n+1,npar do mflw[i].nosave=true end
  end

  -- add twiss data to mflw
  __twdat.orow = 0
  __twdat.pclw = 0
  __twdat.opar = n
  __twdat.omat = matrix(6)
  __twdat.onam = coupling and ofcname or ofname
  __twdat.chrm = chrom == true and chromdp or chrom or nil

  -- tunes and chromaticities
  __twdat.q1, __twdat.dq1 = tblrep(0,npar), table.new(n,0)
  __twdat.q2, __twdat.dq2 = tblrep(0,npar), table.new(n,0)
  __twdat.q3, __twdat.dq3 = tblrep(0,npar), table.new(n,0)

  -- synch integ. 1, momentum compaction & phase slip factors, gamma transition
  __twdat.synch_1 = tblrep(0,n)
  __twdat.alfap   = table.new(n,0)
  __twdat.etap    = table.new(n,0)
  __twdat.gammatr = table.new(n,0)

  if save then
    -- extend mtbl
    mtbl.type     = 'twiss'
    mtbl.header   = tblcat(mtbl.header, twheader)

    mtbl.chrom    = chrom
    mtbl.coupling = coupling

    -- add twiss columns and type to mtbl
    for _,k in ipairs(mflw.__twdat.onam) do mtbl:addcol(k,{}) end
  end

  return mflw
end

-- twiss mflow ----------------------------------------------------------------o

local function make_mflow (self)
  local save, chrom, mapdef in self

  -- wrap actions (see track)
  if save then
    local atsave = self:var_raw 'atsave' -- prevent evaluation
    self.atsave = not atsave and fill or achain(fill, atsave)
  end
  -- action for optical function calculation
  local sliceact = achain(atins, optfunact)
  local atslice  = self:var_raw 'atslice' -- prevent evaluation
  local atexit   = self:var_raw 'atexit'  -- prevent evaluation
  self. atslice  = not atslice and sliceact  or chain(atslice, sliceact )
  self. atexit   = not atexit  and optfunact or chain(atexit , optfunact)

  -- double the deltaps of self
  if save and chrom then chrom_dps(self) end

  -- enforce damaps orders (default is 1)
  if not mapdef or is_true(mapdef) then self.mapdef = {xy=1} end

  -- prepare tracking template
  local _, mflw = track { exec=false } :copy_variables(self) { nstep=0 }
  if mflw.npar == 0 then return mflw end -- no more particles...
  if option.debug > 2 then mdump(mflw,'da.') end

  -- prepare mflw to twiss extensions
  mflw.__twdat = {ofun={}}

  -- setup beta block status (update mflw and self.cofind)
  twiss_betblk(self, mflw)
  if option.debug > 2 then mdump(mflw,'bb.') end

  -- search for closed orbits (update mflw)
  if self.cofind ~= false then
    twiss_cofind(self, mflw)
    if mflw.npar == 0 then return mflw end -- no more particles...
    if option.debug > 2 then mdump(mflw,'co.') end
  end

  -- track one-turn-map (update mflw)
  twiss_track(self, mflw)
  if mflw.npar == 0 then return mflw end -- no more particles...
  if option.debug > 2 then mdump(mflw,'tk.') end

  -- compute normal forms (update mflw)
  twiss_nform(self, mflw)
  if option.debug > 2 then mdump(mflw,'nf.') end

  -- return extended mflw and mtbl (if save)
  return twiss_init(self, mflw)
end

-- twiss command --------------------------------------------------------------o

local _id = {} -- identity (unique)

local function exec (self)
  local mflw

  -- retrieve or build mflw (and extend mtbl)
  if self.mflow then
    assert(self.mflow.__twss == _id, "invalid mflow (twiss mflow expected)")
    mflw = self.mflow
  else
    mflw = make_mflow(self) -- the real work is done here!
    mflw.__twss = _id
    if not mflw.__twdat then
      warn("twiss not completed (all damaps were unstable/singular/lost)")
      return mflw.mtbl, mflw
    end
  end

  -- track the normal form(s)
  local nstep, mapdump in self
  local mtbl, mflw, ei = track { mflow=mflw, nstep=nstep, mapdump=mapdump }

  -- finalise twiss calculation (tunes, chromas, etc)
  if not ei and mtbl then fill_sum(mflw) end

  return mflw.mtbl, mflw, ei
end

-- attributes set to nil will use the default from track by inheritance

local twiss = command 'twiss' {
  beam=nil,          -- beam (required or sequence.beam)                  (trck)
  sequence=nil,      -- sequence (required)                               (trck)
  range=nil,         -- range of tracking                                 (trck)
  dir=nil,           -- s-direction of tracking (1 or -1)                 (trck)

  s0=nil,            -- initial s (offset)                                (trck)
  X0=nil,            -- initial X coordinates (or damap, or list of)      (trck)
  deltap=nil,        -- initial deltap(s)                                 (trck)
  beta0=nil,         -- initial beta block (or list of)                   (twss)

  chrom=false,       -- compute chromaticity by finite difference         (twss)
  coupling=false,    -- compute optical functions for non-diagonal modes  (twss)

  mapdef=true,       -- always use damap formalism (true => {xy=1})       (twss)
  mapsave=nil,       -- save damap in the mtable                          (twss)
  mapdump=nil,       -- dump X and R after each element                   (twss)

  nturn=nil,         -- number of turns                                   (trck)
  nstep=nil,         -- number of elements to track for last phase        (trck)
  nslice=nil,        -- number of slices (or weights) for each element    (trck)
  method=nil,        -- method or order for integration (1 to 8)          (trck)
  model=nil,         -- model for integration ('DKD' or 'TKT')            (trck)
  implicit=nil,      -- slice implicit elements too                       (trck)
  misalign=nil,      -- consider misalignment errors                      (trck)
  fringe=nil,        -- activate fringe fields (0..7)                     (trck)
  radiate=nil,       -- radiate at slices (NYI)                           (trck)
  totalpath=nil,     -- 't' is the totalpath                              (trck)

  save=true,         -- create mtable and save results                    (mtbl)
  title=nil,         -- title of mtable (default seq.name)                (mtbl)
  observe=0,         -- save after all elements                           (mtbl)
  savesel=nil,       -- save selector (predicate)                         (mtbl)

  atentry=nil,       -- action called when entering an element  (ataper)  (trck)
  atslice=nil,       -- action called after each element slices (atsave)  (trck)
  atexit=nil,        -- action called when exiting an element   (atsave)  (trck)
  ataper=nil,        -- action called when checking for aperture          (trck)
  atsave=nil,        -- action called when saving in mtable               (trck)

  cofind=false,      -- search for closed orbit (default is false)        (cofn)
  cotol=nil,         -- closed orbit tolerance (i.e. |dX|)                (cofn)
  coiter=nil,        -- maximum number of iterations                      (cofn)
  codiff=nil,        -- finite differences step for jacobian (or true)    (cofn)
  comethod=nil,      -- default algorithm                                 (cofn)
  X1=nil,            -- optional final coordinates translation            (cofn)

  usrdef=nil,        -- user defined data attached to the mflow           (trck)

  mflow=nil,         -- mflow, exclusive with other attributes except nstep
  exec=exec,         -- command to execute upon children creation

  __attr = tblcat(   -- list of all setup attributes
    cofind.__attr,
    {'beta0', 'chrom', 'coupling'},
    {noeval=cofind.__attr.noeval}
  )
} :set_readonly() -- reference twiss command is readonly

-- end ------------------------------------------------------------------------o
return { twiss = twiss }
