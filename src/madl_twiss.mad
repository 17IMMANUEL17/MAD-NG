--[=[
 o-----------------------------------------------------------------------------o
 |
 | Twiss module
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - TODO

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local matrix, command, track, cofind, gphys, option               in MAD
local normal, optfun, phasadv, betablk, dp2pt, has_dp,
      ofname, ofcname, cvindex                                    in gphys
local fnone, ffalse, ftrue, achain                                in MAD.gfunc
local tblcat, tblcpy, tbldup, assertf                             in MAD.utility
local is_nil, is_true, is_boolean, is_number, is_iterable,
      is_mappable, is_damap, is_matrix, is_optfun                 in MAD.typeid

local abs, min, floor                                             in math

local chromdp = 1e-6

-- twiss mtable ---------------------------------------------------------------o

local function fill_sum (mflw)
  local mtbl in mflw
  local chrm in mflw.__twdat

  -- TODO: momentum compaction factor
  -- TODO: gramma transition

  -- chromaticity (BUG: indexes are wrong for lost particles and/or deltap)
  if chrm then

    local n = floor(#mtbl.q1/2)
    for i=1,n do
      mtbl.dq1[i] = (mtbl.q1[n+i] - mtbl.q1[i])/chrm
      mtbl.dq2[i] = (mtbl.q2[n+i] - mtbl.q2[i])/chrm
      mtbl.dq3[i] = (mtbl.q3[n+i] - mtbl.q3[i])/chrm
    end

    -- cleaning
    for i=n+1,2*n do
      mtbl.q1[i], mtbl.q2[i], mtbl.q3[i] = nil, nil, nil
    end
  end

  -- cleaning
  mtbl._mu1, mtbl._mu2, mtbl._mu3 = nil, nil, nil
end

local function fill (elm, mflw, lw, islc)
  local mtbl, npar in mflw
  local n = #mtbl-npar -- complete last npar row partially filled by track

  local ofun, ocpl, onam, omat in mflw.__twdat
  local q1, q2, q3, _mu1, _mu2, _mu3 in mtbl

  for i=1,npar do
    local par = mflw[i]
    assertf(is_damap(par), "unexpected particle %d (damap expected)", i)

    -- TO FIX: dispersion is wrong as extracted matrix is A not R...
    optfun(par:get1(omat), ofun, ocpl)

    -- adjust the phases
    local  mu1,  mu2,  mu3 in ofun
    local dmu1, dmu2, dmu3 = mu1-_mu1[i], mu2-_mu2[i], mu3-_mu3[i]

    if dmu1 < 0 then dmu1 = dmu1+1 end
    if dmu2 < 0 then dmu2 = dmu2+1 end
    if dmu3 < 0 then dmu3 = dmu3+1 end

    -- compute the tunes, backup the phases
    q1[i], _mu1[i] = q1[i] + dmu1, mu1
    q2[i], _mu2[i] = q2[i] + dmu2, mu2
    q3[i], _mu3[i] = q3[i] + dmu3, mu3

    -- fill table
    ofun.mu1, ofun.mu2, ofun.mu3 = q1[i], q2[i], q3[i]

    for _,k in ipairs(onam) do
      mtbl[k][n+i] = ofun[k]
    end
  end
  return true
end

-- chrom option ---------------------------------------------------------------o

local function twiss_chrom (self, trck0)
    local chrom, deltap = self.chrom, self.deltap or trck0.deltap
    local cdp = is_boolean(chrom) and chromdp  or chrom
    local dps = is_number(deltap) and {deltap} or deltap
    assert(is_number  (cdp), "invalid chrom attribute (number expected)")
    assert(is_iterable(dps), "invalid deltap attribute (iterable expected)")

    -- double the list of deltap
    local ndp  = #dps
    local cdps = table.new(2*ndp,1)
    for i,v in ipairs(dps) do
      cdps[i], cdps[i+ndp] = v, v+cdp
    end

    -- update deltap, keep track of initial #deltap
    trck0.deltap, cdps.ndp = cdps, ndp
end

-- close orbit ----------------------------------------------------------------o

local function twiss_cofind (self, mflw0)

  -- collect X0s that would need a closed orbit search
  local npar = mflw0.npar
  local j, X0 = 1, table.new(npar,0)
  for i=1,npar do
    if mflw0[i].status == 'Xset' then
      X0[j], j = mflw0[i], j+1
    end
  end

  -- no particles to setup
  if j == 1 then return end

  -- prepare cofind template
  local twcofind = cofind 'twcofind' { exec=false } :copy_variables(self)

  -- retrieve closed orbit(s)
  local mapdef, mapdump = self.comapdef or true, self.comapdump
  local _, mflw = twcofind { X0=X0, save=false, mapdef=mapdef, mapdump=mapdump }

  -- save results back to mflw0
  local nlos = 0
  for i=1,j-1 do
    local m  = mflw[i]
    local i0 = X0[m.id].id
    if m.status == 'cofound' then
      mflw0[i0], m.id = m, i0
    else
      warn("particle %d lost during closed orbit seach (reason: %s)", i0, m.status)
      nlos = nlos+1
    end
  end

  if nlos > 0 then
    errorf("%d particles lost during closed orbit search, twiss aborts", nlos)
  end
end

-- init track -----------------------------------------------------------------o

local function twiss_track0 (self, X0, R0, ofun0)
  local mapdef, chrom, beam, save in self
  local atsave = self:var_raw 'atsave' -- prevent evaluation

  -- wrap atsave
  if save and atsave ~= ffalse then
      atsave = (atsave == fnone or atsave == ftrue) and
                fill or achain(fill, atsave)
  end

  -- prepare track template
  local trck0 = track 'track0' { exec=false } :copy_variables(self)

  -- prepare track command
  local mtbl, mflw = trck0 'twtrack0' {
    X0=X0, R0=R0, atsave=atsave, nstep=0, -- only init
    mapdef = is_true(mapdef) and {xy=2} or mapdef,
  }
  local npar = mflw.npar

  -- extend mflw and mtbl
  if save then
    -- add twiss data to mflw
    local coupling in self
    mflw.__twdat = {
      ofun = ofun0,
      ocpl = coupling,
      omat = matrix(6),
      onam = coupling and ofcname or ofname,
      chrm = chrom,
      npar = npar,
    }
    -- add twiss columns and type to mtbl
    mtbl.type  = 'twiss'
    for _,k in ipairs(mflw.__twdat.onam) do mtbl:addcol(k,{}) end
    -- init phase and tunes
    local n = #mflw
    mtbl.q1, mtbl._mu1, mtbl.dq1 = tbldup(0,n), tbldup(0,n), tbldup(0,npar)
    mtbl.q2, mtbl._mu2, mtbl.dq2 = tbldup(0,n), tbldup(0,n), tbldup(0,npar)
    mtbl.q3, mtbl._mu3, mtbl.dq3 = tbldup(0,n), tbldup(0,n), tbldup(0,npar)
    mtbl.chromdp = chrom
  end

  return mflw
end

-- trace twiss normal form ----------------------------------------------------o

local function trace_normal (R, A)
  local fmt = option.format
  option.format = "% 10.5f"
  R :print('R1') ; A :print('A1')
  local R2, A2 = betablk(ofun0)
  R2:print('R2') ; A2:print('A2')
  option.format = fmt
end

-- twiss mflow ----------------------------------------------------------------o

local function make_mflow (self)
  local chrom, coupling, save in self

  -- prepare track template
  local trck0 = track 'twtrack' { exec=false } :copy_variables(self)

  -- double the deltaps
  if chrom and save then twiss_chrom(self, trck0) end

  -- let's track build initial damaps (e.g. handle deltap and check attributes)
  local _, mflw0 = trck0 { nstep=0, save=false }
  local npar = mflw0.npar

  -- search for missing closed orbit (or stop), doesn't change npar.
  twiss_cofind(self, mflw0)

  -- extract normal forms
  local X, A, ofun0 = table.new(npar,0), table.new(npar,0), table.new(npar,0)

  for i=1,npar do
    local Xi  = mflw0[i]:get0()
    local Ri  = mflw0[i]:get1()
    local rnk = has_dp(Ri, self.codptol) and 6 or 4

    -- 4D case
    if rnk == 4 then Ri = Ri:getsub(1..4,1..4) end

    -- get linear normal form A from one-turn map R
    local Ai, Vi, Wi = normal(Ri)

    -- get initial linear optical functions and phase advances
    local ofun0i = phasadv(Wi, optfun(Ai, nil, coupling))

print('mu1=', ofun0i.mu1,'mu2=', ofun0i.mu2,'mu3=', ofun0i.mu3)

    -- TODO: high order normal form

    -- debug normal form
    if option.debug >= 2 then trace_normal(Ri, Ai) end

    -- back to 6D (TODO: check 5D...)
    if rnk == 4 then Ai = matrix(6):eye():setsub(1..4,1..4, Ai) end

    X[i], A[i], ofun0[i] = Xi, Ai, ofun0
  end

  -- init track with normal forms A and compute optfun
  return twiss_track0(self, X, A, ofun0)
end

-- twiss command --------------------------------------------------------------o

local _id = {} -- identity

local function exec (self)
  local mflw, mtbl, ei

  -- retrieve or build mflw (and extend mtbl)
  if self.mflow then
    assert(self.mflow.__twss == _id, "invalid mflow (twiss mflow expected)")
    mflw = self.mflow
  else
    mflw = make_mflow(self) -- the real work is done here.
    mflw.__twss = _id
  end

  -- track normal form(s)
  mtbl, mflw, ei = track 'twtrack' { mflow=mflw, nstep=self.nstep }

  if ei == nil and not is_nil(mtbl) then
    fill_sum(mflw)
  end

  return mtbl, mflw, ei
end

-- attributes set to nil will use the default from track by inheritance

local twiss = command 'twiss' {
  beam=nil,          -- beam (required or sequence.beam)                  (trck)
  sequence=nil,      -- sequence (required)                               (trck)
  range=nil,         -- range of tracking                                 (trck)
  dir=nil,           -- s-direction of tracking (1 or -1)                 (trck)

  s0=nil,            -- initial s                                         (trck)
  X0=nil,            -- initial X coordinates (or damap, or list of)      (trck)
  R0=nil,            -- initial R matrix (companion of X0)                (trck)
  beta0=nil,         -- initial beta0 block to build uncoupled R0         (trck)
  deltap=nil,        -- initial deltap(s)                                 (trck)

  mapdef=true,       -- always use damap formalism (true => {xy=2})       (trck)
  mapsave=nil,       -- save damap in the mtable                          (trck)
  mapdump=nil,       -- dump X and R after each element                   (trck)

  nturn=nil,         -- number of turns                                   (trck)
  nstep=nil,         -- number of elements to track                       (trck)
  npart=nil,         -- number of particles/damaps (or #X0)               (trck)
  nslice=nil,        -- number of slice for each element                  (trck)
  implicit=nil,      -- slice implicit elements too                       (trck)
  model=nil,         -- model for integration ('DKD' or 'TKT')            (trck)
  method=nil,        -- method or order for integration (1 to 8)          (trck)
  totalpath=nil,     -- 't' is the totalpath                              (trck)
  radiate=false,     -- radiate at slices (NYI)                           (trck)
  misalign=nil,      -- consider misalignment errors                      (trck)

  save=true,         -- create mtable and save results                    (mtbl)
  title=nil,         -- title of mtable (default seq.name)                (mtbl)
  savesel=nil,       -- save selector (predicate)                         (mtbl)
  relative=nil,      -- save length of slices instead from element start  (mtbl)
  observe=false,     -- save only in observed elements (every n turns)    (mtbl)
  coupling=false,    -- save optical functions for non-diagonal blocks    (mtbl)
  chrom=false,       -- compute chromaticity by finite difference         (twss)

  usrdef=nil,        -- user defined data attached to the mflow           (trck)

  atentry=nil,       -- action called when entering an element            (trck)
  atslice=nil,       -- action called after each element slices           (trck)
  atexit=nil,        -- action called when exiting an element             (trck)
  ataper=nil,        -- action called after checking for aperture         (trck)
  atsave=fnone,      -- action called after saving in mtable              (trck)

  cotol=nil,         -- closed orbit tolerance                            (cofn)
  coiter=nil,        -- maximum number of iteration                       (cofn)
  codiff=nil,        -- finite differences step for jacobian              (cofn)
  codptol=nil,       -- 4D vs 6D dp tolerance                             (cofn)
  comethod=nil,      -- default optimizer                                 (cofn)
  comapdef=nil,      -- optional mapdef for cofind                        (cofn)
  comapdump=nil,     -- dump X and R after each element                   (cofn)
  cowarn=nil,        -- commute errors into warnings                      (cofn)
  X1=nil,            -- optional final coordinates translation            (cofn)

  mflow=nil,         -- mflow, exclusive with other attributes except nstep
  exec=exec,         -- command to execute upon children creation

  __attr = tblcat(   -- list of all setup attributes
    {'chrom', 'coupling', 'comapdef', 'comapdump'},
    cofind.__attr,
    {noeval=cofind.__attr.noeval}
  )
} :set_readonly() -- reference twiss command is readonly

-- end ------------------------------------------------------------------------o
return { twiss = twiss }
