--[=[
 o-----------------------------------------------------------------------------o
 |
 | Twiss module
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - TODO

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local matrix, command, track, cofind        in MAD
local normal, optfun, ofname                in MAD.gphys
local fnone, bind1st                        in MAD.gfunc
local is_damap                              in MAD.typeid
local abs                                   in math

-- close orbit ----------------------------------------------------------------o

local function twiss_cofind (self)

  -- retrieve closed orbit
  local X, R, rnk, typ, itr = cofind 'cotwiss' {
    -- forward options to cofind
    beam     = self.beam,
    sequence = self.sequence,
    range    = self.range,
    sdir     = self.sdir,

    s0       = self.s0,
    X0       = self.X0,
    X1       = self.X1,

    nturn    = self.nturn,
    nslice   = self.nslice,
    method   = self.method,

    cotol    = self.cotol,
    coiter   = self.coiter,
    codiff   = self.codiff,
    codptol  = self.codptol,
    cousemap = self.cousemap,
    comethod = self.comethod,
  }

  if typ == 'Singular' then
    error("unable to find closed orbit during twiss initialization")
  end

  return X, R, rnk
end

-- init track A ---------------------------------------------------------------o

local function twiss_track0 (self, X, A)

  -- capture initial mtbl and mflw
  return track 'twtrack0' {

    -- forwarded options
    beam      = self.beam,
    sequence  = self.sequence,
    range     = self.range,
    sdir      = self.sdir,

    s0        = self.s0,
    X0        = X,
    R0        = A,

    mapdef    = self.mapdef,
    mapsave   = self.mapsave,

    nturn     = self.nturn,
    nstep     = 0,
    nslice    = self.nslice,
    method    = self.method,
    totalpath = self.totalpath,

    save      = self.save,
    nofill    = self.nofill,
    observe   = self.observe,
    implicit  = self.implicit,

    atentry   = self.atentry,
    atslice   = self.atslice,
    atexit    = self.atexit,
    atfill    = self.atfill,
  }
end

-- optfun filling -------------------------------------------------------------o

local function twiss_fill (fill, elm, mflw, lw_)
  -- forward mtable fill
  if not fill(elm, mflw, lw_) then return end

  -- complete fill with twiss parameters
  local mtbl, npar, R in mflw
  local n = #mtbl-npar

  for i=1,npar do
    local damap = mflw[i]
    if is_damap(damap) then -- skip particles
      local A = damap:get1()
      local ofun = optfun(A, R, mflw.optfun)
      for _,k in ipairs(ofname) do
        mtbl[k][n+i] = ofun[k] or 0
      end
    end
  end
end

-- twiss command --------------------------------------------------------------o

local function exec (self)
  -- find closed orbit
  local X, R, rnk = twiss_cofind(self)

  -- 4D case
  if rnk == 4 then R = R:getsub(1..4,1..4) end

  -- get linear normal form A of one-turn map R
  local A, V, W, info = normal(R)

  -- get initial linear optical functions and phase advances from normal form A
--  local optfun0 = optfun(A, R, W)
  local optfun0 = table.new(0,50)
  optfun0.rank = rnk

  -- (re)extend to 6D if needed
  if rnk == 4 then
    R = matrix(6):eye():setsub(1..4, 1..4, R)
    A = matrix(6):eye():setsub(1..4, 1..4, A)
  end

  -- init track of normal form A
  local mtbl, mflw = twiss_track0(self, X, A)

  -- wrap fill
  if mflw.fill ~= fnone then
    for _,k in ipairs(ofname) do mtbl:addcol(k,{}) end
    mflw.fill   = bind1st(twiss_fill, mflw.fill)
    mflw.optfun = optfun0
    mflw.R      = R
  end

  mtbl, mflw = track 'twtrack' { mflow=mflw, nstep=self.nstep }

  -- TODO: build summary mtable

  -- to remove
--  print("show optfun0")
--  show(optfun0)

  -- dump results
--  if true then
--    local printf in MAD.utility
--    local q1 , q2 , q3  = 0, 0, 0
--    local mu1, mu2, mu3 = 0, 0, 0
--    for i=1,#mtbl do
--      local A = mtbl[i].damap:get1()
--      local optfun = optfun(A, R)
--      q1 = q1 + optfun.mu1 - mu1
--      q2 = q2 + optfun.mu2 - mu2
--      q3 = q3 + optfun.mu3 - mu3
--      mu1, mu2, mu3 = optfun.mu1, optfun.mu2, optfun.mu3
--      printf('mu1=%14.8e, mu2=%14.8e\n', optfun.mu1, optfun.mu2)
--      printf('q1 =%14.8e, q2 =%14.8e\n', q1, q2)
--    end
--    show(optfun0)
--  end

  return mtbl, mflw
end

local _na -- not applicable (see track or cofind)

local twiss = command 'twiss' {
  -- attributes (not required) set to nil will use the default from track
  beam=nil,          -- beam (required)                                   (trck)
  sequence=nil,      -- sequence (required)                               (trck)
  range=nil,         -- range of tracking                                 (trck)
  dir=1,             -- s-direction of tracking (1 or -1)                 (trck)

  s0=nil,            -- initial s                                         (trck)
  X0=nil,            -- initial X coordinates (or damap, or list of)      (trck)

  mapdef=true,       -- always use damap formalism (true => {xy=2})       (trck)
  mapsave=nil,       -- save damap in the mtable                          (trck)
  R0=nil,            -- initial R matrix (compagnion of X0)               (trck)

  nturn=nil,         -- number of turns                                   (trck)
  nstep=nil,         -- number of elements to track                       (trck)
  nslice=nil,        -- number of slice for each element                  (trck)
  method=nil,        -- method for integration                            (trck)
  totalpath=nil,     -- 't' is the totalpath                              (trck)

  save=true,        -- create mtable and save results                     (mtbl)
  title=nil,        -- title of mtable (default seq.name)                 (mtbl)
  implicit=true,    -- save also in implicit elements                     (mtbl)
  relative=false,   -- save length of slices instead from element start   (mtbl)
  observe=false,    -- save only in observed elements (every n turns)     (mtbl)

  atentry=nil,       -- action to call when entering an element           (trck)
  atslice=nil,       -- action to call after each element slices          (trck)
  atexit=nil,        -- action to call when exiting an element            (trck)
  atsave=nil,        -- action called when saving a row in mtable         (trck)

  cotol=nil,         -- closed orbit tolerance                            (cofn)
  coiter=nil,        -- maximum number of iteration                       (cofn)
  codiff=nil,        -- finite differences steps                          (cofn)
  codptol=nil,       -- static vs dynamic tolerance                       (cofn)
  comethod=nil,      -- default optimizer                                 (cofn)
  comapdef=nil,      -- optional mapdef for cofind                        (cofn)
  cowarn=nil,        -- commute errors into warnings                      (cofn)
  X1=nil,            -- optional final coordinates translation            (cofn)

  mflow=nil,      -- current mflow, exclusive with other attributes except nstep

  exec=exec,      -- command to execute upon children creation
} :set_readonly() -- reference twiss command is readonly

-- end ------------------------------------------------------------------------o
return { twiss = twiss }
