--[=[
 o-----------------------------------------------------------------------------o
 |
 | Twiss module
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - TODO

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local matrix, command, track, cofind, gphys, option, warn         in MAD
local normal, optfun, phasadv, betablk, dp2pt, has_dpt,
      ofname, ofcname, cvindex                                    in gphys
local ffalse, ftrue, achain                                       in MAD.gfunc
local tblcat, tblcpy, tblrep, assertf, printf, rep                in MAD.utility
local is_nil, is_true, is_boolean, is_number, is_iterable,
      is_mappable, is_matrix, is_damap, is_matrix, is_optfun      in MAD.typeid

local abs, min, floor                                             in math

local chromdp = 1e-6

local assert, error, getmetatable, setmetatable, table =
      assert, error, getmetatable, setmetatable, table

-- twiss mtable ---------------------------------------------------------------o

local function fill_sum (mflw)
  local mtbl in mflw

  -- TODO: momentum compaction factor, gamma transition

  -- chromaticity
  if mflw.__twdat.chrm then
    local q1, q2, q3, dq1, dq2, dq3, chromdp in mtbl
    local n = floor(#q1/2)

    -- tag lost damaps
    for i=mflw.npar+1,mflw.tpar do
      local id, st = mflw[i].id, mflw[i].status
      if id > n then id = id-n end
      dq1[id], dq2[id], dq3[id] = st, st, st
    end

    -- other damaps
    for i=1,mflw.npar do
      local id = mflw[i].id
      if id > n then id = id-n end
      if not dq1[id] then
        dq1[id] = (q1[id+n] - q1[id])/chromdp
        dq2[id] = (q2[id+n] - q2[id])/chromdp
        dq3[id] = (q3[id+n] - q3[id])/chromdp
        printf("id=%d, q1=%.12e, q1dp=%.12e, dq1=%.12e\n\z
                .     q2=%.12e, q2dp=%.12e, dq2=%.12e\n",
                id, q1[id], q1[id+n], dq1[id], q2[id], q2[id+n], dq2[id])
      end
    end

    -- cleaning
    for i=n+1,2*n do
      q1[i], q2[i], q3[i] = nil, nil, nil
    end
  end
end

local function fill (elm, mflw, lw, islc)
  local mtbl, npar in mflw
  local n = #mtbl-npar -- complete last npar row partially filled by track

  local ofun, ocpl, onam, omat in mflw.__twdat
  local q1, q2, q3 in mtbl

  for i=1,npar do
    local m = mflw[i]
    local id, of = m.id, ofun[m.id]
    assertf(is_damap(m), "unexpected particle %d (damap expected)", id)

    -- backup phases
    local mu1_, mu2_, mu3_ = of.mu1, of.mu2, of.mu3

    -- TO FIX: dispersion is wrong when extracted from A instead of R...
    optfun(m:get1(omat), of, ocpl)

    -- adjust the phases
    local  mu1,  mu2,  mu3 in of
    local dmu1, dmu2, dmu3 = mu1-mu1_, mu2-mu2_, mu3-mu3_

    if dmu1 < 0 then dmu1 = dmu1+1 end
    if dmu2 < 0 then dmu2 = dmu2+1 end
    if dmu3 < 0 then dmu3 = dmu3+1 end

    -- compute the tunes
    q1[id] = q1[id] + dmu1
    q2[id] = q2[id] + dmu2
    q3[id] = q3[id] + dmu3

    -- fill table (keep order !)
    if not mflw[i].nosave then
      for _,k in ipairs(onam) do mtbl[k][n+i] = of[k] end
    end

    mtbl.mu1[n+i], mtbl.mu2[n+i], mtbl.mu3[n+i] = q1[id], q2[id], q3[id]
  end
  return true
end

-- chrom option ---------------------------------------------------------------o

local function chrom_dps (self)
  local chrom, deltap = self.chrom, self.deltap or 0
  local cdp = is_boolean(chrom) and chromdp  or chrom
  local dps = is_number(deltap) and {deltap} or deltap
  assert(is_number  (cdp), "invalid chrom attribute (number expected)")
  assert(is_iterable(dps), "invalid deltap attribute (iterable expected)")

  -- double the list of deltap
  local ndp  = #dps
  local cdps = table.new(2*ndp,0)
  for i,v in ipairs(dps) do
    cdps[i], cdps[i+ndp] = v, v+cdp
  end

  -- update self
  self.deltap = cdps
end

-- close orbit ----------------------------------------------------------------o

local function twiss_cofind (self, twmflw)
  if not self.cofind then return end

  local cof, cor = self.cofind, self.coref
  local notrk, X0 = {notrack=true,status='notrack'}, table.new(twmflw.npar,0)
  if cof == true then cof = rep(true, twmflw.npar) end
  if cor == true then cor = 1 end

  -- select closed orbit(s)
  for i=1,twmflw.npar do
    local m = twmflw[i]
    X0[i] = cof[m.id0 or m.id] == true and m:get0() or notrk
  end

  -- retrieve closed orbit(s)
  local twcofind = cofind 'twcofind' { exec=false } :copy_variables(self)
  local _, comflw, Xc = twcofind { X0=X0, deltap=0, save=false, nstep=-1,
                                   mapdef=self.comapdef, mapdump=self.comapdump }

  -- save results back
  local nlos = 0
  for i=1,comflw.npar do
    local m = comflw[i]
    if m.status == 'stable' then
      twmflw[i]:translate(Xc[i]-X0[i],'in')
    elseif cor and cof[m.id0 or m.id] then
      twmflw[i]:translate(Xc[cor]-X0[i],'in')
    else -- status: 'unstable' | 'singular' | 'lost'
      warn("particle %d lost during closed orbit search (reason: %s)", m.id0, m.status)
      nlos = nlos+1
    end
  end

  -- debug output
  if option.debug > 2 then
    printf("#particles: in %d, out %d\n", twmflw.npar, comflw.npar)
    for i=1,comflw.npar do
      printf("id(in,out): (%d,%d), status: %s -> %s\n",
             twmflw[i].id, comflw[i].id, twmflw[i].status, comflw[i].status)
      if is_matrix(Xc[i]) and comflw[i].status == 'stable' then
        X0    [i]       :print('X0_in ','line')
        Xc    [i]       :print('X0_co ','line')
        comflw[i]:get0():print('X0_co1','line')
        twmflw[i]:get0():print('X0_out','line')
      end
    end
  end

  -- correct behaviour?
  if nlos > 0 then
    errorf("%d particles lost during closed orbit search, twiss aborts", nlos)
  end
end

-- init track -----------------------------------------------------------------o

local function twiss_track0 (self, X0, R0, ofun0)
  local mapdef, save in self
  local atsave = self:var_raw 'atsave' or ftrue -- prevent evaluation

  -- wrap atsave (see track)
  if save and atsave ~= ffalse then
    atsave = atsave == ftrue and fill or achain(fill, atsave)
  end

  -- prepare track command
  local trck0      = track 'track0' { exec=false } :copy_variables(self)
  local mtbl, mflw = trck0 'twiss'  {
    X0=X0, R0=R0, deltap=0, atsave=atsave, nstep=0, -- init only
    mapdef=is_true(mapdef) and {xy=2} or mapdef,
  }

!  print("DUMP MAPS")
!  for i=1,#mflw do
!    mflw[i]:print()
!  end

  -- extend mflw and mtbl
  if save then
    local chrom, coupling in self
    local n = mflw.npar
    -- add twiss data to mflw
    mflw.__twdat = {
      ofun = ofun0,
      ocpl = coupling,
      omat = matrix(6),
      onam = coupling and ofcname or ofname,
      chrm = chrom,
      npar = n,
    }
    if chrom then -- do not save extra rows due to chrom
      for i=n/2+1,n do mflw[i].nosave=true end
    end
    -- add twiss columns and type to mtbl
    mtbl.type = 'twiss'
    for _,k in ipairs(mflw.__twdat.onam) do mtbl:addcol(k,{}) end
    -- init tunes and chromaticities
    mtbl.q1, mtbl.dq1 = tblrep(0,n), table.new(n/2,0)
    mtbl.q2, mtbl.dq2 = tblrep(0,n), table.new(n/2,0)
    mtbl.q3, mtbl.dq3 = tblrep(0,n), table.new(n/2,0)
    mtbl.chromdp = chrom == true and chromdp or chrom or nil
  end

  return mflw
end

-- normal/closed forms --------------------------------------------------------o

local function trace_normal (R, A, of)
  local fmt = option.format
  option.format = "% 10.5f"
  R :print('R1') ; A :print('A1')
  local R2, A2 = betablk(of)
  R2:print('R2') ; A2:print('A2')
  option.format = fmt
end

local r4 = 1..4

local function track_closed (self, mflw) -- TODO: high order normal form
  local npar = mflw.npar
  local X, A, ofun0 = table.new(npar,0), table.new(npar,0), table.new(npar,0)

  for i=1,npar do
    local Xi  = mflw0[i]:get0()
    local Ri  = mflw0[i]:get1()
    local rnk = has_dpt(Ri, self.codptol) and 6 or 4
    local R6

    -- 4D case
    if rnk == 4 then R6, Ri = Ri, Ri:getsub(r4,r4) end

    -- get linear normal form A from one-turn map R
    local Ai, Vi, Wi = normal(Ri)

    -- get initial linear optical functions and phase advances
    local ofi = phasadv(Wi, optfun(Ai, nil, coupling))

    -- clear phase advances
    ofi.mu1, ofi.mu2, ofi.mu3 = 0, 0, 0

    -- debug normal form
    if option.debug >= 2 then trace_normal(Ri, Ai, ofi) end

    -- back to 6D (TODO: check 5D...)
    if rnk == 4 then
      local fmt = option.format
      option.format = "% -.8e"
      R6:print('R6') ; Ai:print('Ai')
      Ai = matrix(6):eye():setsub(r4,r4,Ai) -- TODO 5D :setsub(r4,6,R6)
      Xi[5] = 0 -- reset time
      Ai:print('Ai') ; Xi:print('Xi')
      option.format = fmt
    end

    X[i], A[i], ofun0[i] = Xi, Ai, ofi
    -- update mflw!
  end
end

-- twiss mflow ----------------------------------------------------------------o

local function make_mflow (self)
  local chrom, save in self

  -- double the deltaps of self
  if chrom and save then chrom_dps(self) end

  -- let's track build damaps (e.g. handle deltap and check attributes)
  local twtrack    = track 'twtrack' { exec=false } :copy_variables(self)
  local mtbl, mflw = twtrack         { nstep=0 }

  -- search for closed orbits, translate maps (update mflw)
  twiss_cofind(self, mflw)

  -- get one-turn-maps to user-defined orders
  track { mflow=mflw }

  -- get closed forms (normal forms)
!  twiss_closed(self, mflw)

  return mflw
end

-- twiss command --------------------------------------------------------------o

local _id = {} -- identity (unique)

local function exec (self)
  local mflw, mtbl, ei

  -- retrieve or build mflw (and extend mtbl)
  if self.mflow then
    assert(self.mflow.__twss == _id, "invalid mflow (twiss mflow expected)")
    mflw = self.mflow
  else
    mflw = make_mflow(self) -- the real work is done here!
    mflw.__twss = _id
  end

  -- track the form(s)
!  mtbl, mflw, ei = track 'twtrack' { mflow=mflw, nstep  =self.nstep,
!                                                 mapdump=self.mapdump }

!  if ei == nil and not is_nil(mtbl) then
!    fill_sum(mflw)
!  end

  return mtbl, mflw, ei
end

-- attributes set to nil will use the default from track by inheritance

local twiss = command 'twiss' {
  beam=nil,          -- beam (required or sequence.beam)                  (trck)
  sequence=nil,      -- sequence (required)                               (trck)
  range=nil,         -- range of tracking                                 (trck)
  dir=nil,           -- s-direction of tracking (1 or -1)                 (trck)

  s0=nil,            -- initial s (offset)                                (trck)
  X0=nil,            -- initial X coordinates (or damap, or list of)      (trck)
  O0=nil,            -- initial orbit translation to apply to all X0      (trck)
  R0=nil,            -- initial R matrix (companion of X0 for damap)      (trck)
  beta0=nil,         -- initial beta0 block to build R0                   (trck)
  deltap=nil,        -- initial deltap(s)                                 (trck)

  mapdef=true,       -- always use damap formalism (true => {xy=2})       (trck)
  mapsave=nil,       -- save damap in the mtable                          (trck)
  mapdump=nil,       -- dump X and R after each element                   (trck)

  nturn=nil,         -- number of turns                                   (trck)
  nstep=nil,         -- number of elements to track                       (trck)
  npart=nil,         -- number of particles/damaps (or #X0)               (trck)
  nslice=nil,        -- number of slices (or weights) for each element    (trck)
  method=nil,        -- method or order for integration (1 to 8)          (trck)
  model=nil,         -- model for integration ('DKD' or 'TKT')            (trck)
  implicit=nil,      -- slice implicit elements too                       (trck)
  fringe=nil,        -- activate fringe fields (0..7)                     (trck)
  radiate=nil,       -- radiate at slices (NYI)                           (trck)
  misalign=nil,      -- consider misalignment errors                      (trck)
  totalpath=nil,     -- 't' is the totalpath                              (trck)

  save=true,         -- create mtable and save results                    (mtbl)
  title=nil,         -- title of mtable (default seq.name)                (mtbl)
  observe=false,     -- save after all elements                           (mtbl)
  coupling=false,    -- save optical functions for non-diagonal modes     (mtbl)
  chrom=false,       -- compute chromaticity by finite difference         (twss)
  savesel=nil,       -- save selector (predicate)                         (mtbl)

  atentry=nil,       -- action called when entering an element  (ataper)  (trck)
  atslice=nil,       -- action called after each element slices (atsave)  (trck)
  atexit=nil,        -- action called when exiting an element   (atsave)  (trck)
  ataper=nil,        -- action called when checking for aperture          (trck)
  atsave=nil,        -- action called when saving in mtable               (trck)

  cofind=true,       -- search for closed orbit                           (cofn)
  coref=false,       -- use particle at coref index as reference orbit    (twss)
  cotol=nil,         -- closed orbit tolerance                            (cofn)
  coiter=nil,        -- maximum number of iteration                       (cofn)
  codiff=nil,        -- finite differences step for jacobian              (cofn)
  codptol=nil,       -- 4D vs 6D dpt tolerance                            (cofn)
  comethod=nil,      -- default optimizer                                 (cofn)
  comapdef=nil,      -- mapdef for cofind                                 (cofn)
  comapdump=nil,     -- dump X and R after each element                   (cofn)
  cowarn=nil,        -- commute errors into warnings                      (cofn)
  X1=nil,            -- optional final coordinates translation            (cofn)

  usrdef=nil,        -- user defined data attached to the mflow           (trck)

  mflow=nil,         -- mflow, exclusive with other attributes except nstep
  exec=exec,         -- command to execute upon children creation

  __attr = tblcat(   -- list of all setup attributes
    {'chrom', 'coupling', 'cofind', 'coref', 'comapdef', 'comapdump'},
    cofind.__attr,
    {noeval=cofind.__attr.noeval}
  )
} :set_readonly() -- reference twiss command is readonly

-- end ------------------------------------------------------------------------o
return { twiss = twiss }
