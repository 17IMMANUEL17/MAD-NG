--[=[
 o-----------------------------------------------------------------------------o
 |
 | Twiss module
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - TODO

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local matrix, command, track, cofind                              in MAD
local normal, optfun, phasadv, betablk, has_dp, ofname, ofcname   in MAD.gphys
local fnone, ffalse, ftrue, achain                                in MAD.gfunc
local is_nil, is_true, is_mappable, is_damap                      in MAD.typeid
local tblcpy, assertf                                             in MAD.utility
local abs                                                         in math

-- twiss mtable ---------------------------------------------------------------o

local function fill_sum (mflw)
  local mtbl in mflw
  local n = #mtbl

  -- tunes (for now...)
  mtbl.q1 = mtbl.mu1[n]
  mtbl.q2 = mtbl.mu2[n]
  mtbl.q3 = mtbl.mu3[n]

  -- TODO: momentum compaction factor
  -- TODO: gramma transition
  -- TODO: chromaticity
  -- TODO: chromatic functions
end

local function fill (elm, mflw, lw, islc)
  local mtbl, npar in mflw
  local n = #mtbl-npar

  local ofun, ocpl, onam, omat in mflw.__twdat

  for i=1,npar do
    local par = mflw[i]
    assertf(is_damap(par), "unexpected particle %d (damap expected)", i)
    optfun(par:get1(omat), ofun, ocpl)
    for _,k in ipairs(onam) do
      mtbl[k][n+i] = ofun[k]
    end
  end
  return true
end

-- close orbit ----------------------------------------------------------------o

local function twiss_cofind (self, X0, R0)

  -- retrieve closed orbit
  local X, R, rnk, typ, itr = cofind 'twcofind' {
    -- forward options to cofind
    beam     = self.beam,
    sequence = self.sequence,
    range    = self.range,
    dir      = self.dir,

    s0       = self.s0,
    X0       = X0,

    mapdef   = self.comapdef,
    R0       = R0,

    nturn    = self.nturn,
    nslice   = self.nslice,
    model    = self.model,
    method   = self.method,

    atentry  = self:var_raw 'atentry', -- prevent evaluation
    atslice  = self:var_raw 'atslice',
    atexit   = self:var_raw 'atexit' ,
    ataper   = self:var_raw 'ataper' ,

    usrdef   = self.usrdef, -- user defined data

    cotol    = self.cotol,
    coiter   = self.coiter,
    codiff   = self.codiff,
    codptol  = self.codptol,
    comethod = self.comethod,
    cowarn   = self.cowarn,
    X1       = self.X1,
  }

  if typ == 'Singular' then
    error("unable to find closed orbit during twiss initialization")
  end

  return X, R, rnk
end

-- init track -----------------------------------------------------------------o

local function twiss_track0 (self, X0, R0, ofun0)
  local mapdef, save in self
  local atsave = self:var_raw 'atsave' -- prevent evaluation

  -- wrap atsave
  if save and atsave ~= ffalse then
      atsave = (atsave == fnone or atsave == ftrue) and
                fill or achain(fill, atsave)
  end

  local mtbl, mflw = track 'twtrack0' {
    -- forwarded options
    beam      = self.beam,
    sequence  = self.sequence,
    range     = self.range,
    dir       = self.dir,

    s0        = self.s0,
    X0        = X0,
    R0        = R0,

    mapdef    = is_true(mapdef) and {xy=2} or mapdef,
    mapsave   = self.mapsave,

    nturn     = self.nturn,
    nstep     = 0,                      -- do only initialisation
    nslice    = self.nslice,
    model     = self.model,
    method    = self.method,
    totalpath = self.totalpath,
    radiate   = self.radiate,

    save      = self.save,
    title     = self.title,
    implicit  = self.implicit,
    relative  = self.relative,
    observe   = self.observe,

    atentry   = self:var_raw 'atentry', -- prevent evaluation
    atslice   = self:var_raw 'atslice',
    atexit    = self:var_raw 'atexit' ,
    ataper    = self:var_raw 'ataper' ,
    atsave    = atsave,

    usrdef    = self.usrdef, -- user defined data
  }

  -- extend mflw and mtbl
  if save then
    -- add twiss data to mflw
    local coupling in self
    mflw.__twdat = {
      ofun = ofun0,
      ocpl = coupling,
      omat = matrix(6),
      onam = coupling and ofcname or ofname,
    }
    -- add twiss columns and type to mtbl
    mtbl.type  = 'twiss'
    for _,k in ipairs(mflw.__twdat.onam) do mtbl:addcol(k,{}) end
  end

  return mflw
end

-- trace twiss normal form ----------------------------------------------------o

local function trace_normal (R, A)
  local fmt = MAD.option.format
  MAD.option.format = "% 10.5f"
  R :print('R1') ; A :print('A1')
  local R2, A2 = betablk(ofun0)
  R2:print('R2') ; A2:print('A2')
  MAD.option.format = fmt
end

-- twiss mflow ----------------------------------------------------------------o

local function make_mflow (self)
  local X0, R0, beta0 in self

  -- validate initial conditions
  if is_nil(X0) then X0 = track.X0 end
  assert(is_mappable(X0), "invalid X0 (mappable expected)")
  if not is_mappable(X0[1]) then
    X0, R0, beta0 = {X0}, {R0}, {beta0}
  end

  local npar = #X0
  local Xn, An, ofun0 = table.new(npar,0), table.new(npar,0)

  for i=1,npar do
    -- precedence of initial conditions
    local X0i, R0i
    if is_damap(X0[i]) then
      X0i, R0i = X0[i]:get0(), X0[i]:get1()
    elseif R0[i] then
      X0i, R0i = X0[i], R0[i]
    elseif beta0[i] then
      X0i, R0i = X0[i], betablk(beta0[i])
    end

    -- find closed orbit or use initial conditions
    local X, R, rnk

    if R0i then
      X, R, rnk = X0i, R0i, has_dp(R0i, self.codptol) and 6 or 4
    else
      X, R, rnk = twiss_cofind(self, X0i, R0i)
    end

    -- 4D case
    if rnk == 4 then R = R:getsub(1..4,1..4) end

    -- get linear normal form A from one-turn map R
    local A, V, W, info = normal(R)

    -- get initial linear optical functions and phase advances
    ofun0 = phasadv(W, optfun(A, nil, self.coupling))

    -- TODO: high order normal form

    -- debug normal form
    if MAD.option.debug >= 2 then trace_normal(R, A) end

    -- back to 6D
    if rnk == 4 then A = matrix(6):eye():setsub(1..4, 1..4, A) end

    Xn[i], An[i] = X, A
  end

  -- init track with normal form A and compute optfun
  return twiss_track0(self, Xn, An, ofun0)
end

-- twiss command --------------------------------------------------------------o

local _id = {} -- identity

local function exec (self)
  local mflw, mtbl, ei

  if self.mflow then
    assert(self.mflow.__twss == _id, "invalid mflow (twiss mflow expected)")
    mflw = self.mflow
  else
    mflw = make_mflow(self)
    mflw.__twss = _id
  end

  mtbl, mflw, ei = track 'twtrack' { mflow=mflw, nstep=self.nstep }

  if ei == nil and mtbl ~= nil then
    fill_sum(mflw)
  end

  return mtbl, mflw, ei
end

local _na, _nyi -- not applicable, not yet implemented

local twiss = command 'twiss' {
  -- attributes (not required) set to nil will use the default from track
  beam=nil,          -- beam (required or sequence.beam)                  (trck)
  sequence=nil,      -- sequence (required)                               (trck)
  range=nil,         -- range of tracking                                 (trck)
  dir=nil,           -- s-direction of tracking (1 or -1)                 (trck)

  s0=nil,            -- initial s                                         (trck)
  X0=nil,            -- initial X coordinates (or damap, or list of)      (trck)
  R0=nil,            -- initial R matrix (companion of X0)                (trck)
  beta0=nil,         -- initial beta0 block to build uncoupled R0         (trck)

  mapdef=true,       -- always use damap formalism (true => {xy=2})       (trck)
  mapsave=nil,       -- save damap in the mtable                          (trck)

  nturn=nil,         -- number of turns                                   (trck)
  nstep=nil,         -- number of elements to track                       (trck)
  nslice=nil,        -- number of slice for each element                  (trck)
  model=nil,         -- model for integration                             (trck)
  method=nil,        -- method or order for integration                   (trck)
  totalpath=nil,     -- 't' is the totalpath                              (trck)
  radiate=_nyi,      -- radiate at slices                                 (trck)

  save=true,         -- create mtable and save results                    (mtbl)
  title=nil,         -- title of mtable (default seq.name)                (mtbl)
  implicit=true,     -- save also in implicit elements                    (mtbl)
  relative=nil,      -- save length of slices instead from element start  (mtbl)
  observe=false,     -- save only in observed elements (every n turns)    (mtbl)
  coupling=false,    -- save optical functions for non-diagonal blocks    (mtbl)

  atentry=nil,       -- action called when entering an element            (trck)
  atslice=nil,       -- action called after each element slices           (trck)
  atexit=nil,        -- action called when exiting an element             (trck)
  ataper=nil,        -- action called after checking for aperture         (trck)
  atsave=fnone,      -- action called after saving in mtable              (trck)

  usrdef=nil,        -- user defined data attached to the mflow           (trck)

  cotol=nil,         -- closed orbit tolerance                            (cofn)
  coiter=nil,        -- maximum number of iteration                       (cofn)
  codiff=nil,        -- finite differences steps                          (cofn)
  codptol=nil,       -- static vs dynamic tolerance                       (cofn)
  comethod=nil,      -- default optimizer                                 (cofn)
  comapdef=nil,      -- optional mapdef for cofind                        (cofn)
  cowarn=nil,        -- commute errors into warnings                      (cofn)
  X1=nil,            -- optional final coordinates translation            (cofn)

  mflow=nil,      -- current mflow, exclusive with other attributes except nstep
  exec=exec,      -- command to execute upon children creation
} :set_readonly() -- reference twiss command is readonly

-- end ------------------------------------------------------------------------o
return { twiss = twiss }
