--[=[
 o-----------------------------------------------------------------------------o
 |
 | Dynamic 6D maps
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: I. Shreyber, irina.tecker at cern.ch
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide a catalog of dynamical 6D maps (i.e. track)
    maps must have the following calling convention:
      dynmap(elm, map, len)
    (see the symplectic integrators)
  - TODO: list the expected fields for elm and map

 o-----------------------------------------------------------------------------o
]=]

local M = {}

-- locals ---------------------------------------------------------------------o

local matrix                                                     in MAD
local is_nil                                                     in MAD.typeid
local minlen, minang, clight                                     in MAD.constant

local abs, sqrt, max, sin, cos, tan, asin, acos, atan, atan2,
      sinh, cosh, sinc, fact, twopi                              in MAD.gmath

local minvolt, volt_c = 1e-6, 1e-3

-- forward declarations -------------------------------------------------------o

-- patches
-- local entry_patch, exit_patch                                     -- patches
-- local xrotation, yrotation, srotation                             -- rotations
-- local translate, changedir, changeref                             -- specials

-- drifts
-- local straight_drift , rbend_drift, quadrupole_drift              -- straight
-- local polar_drift    , sbend_drift, combined_drift                -- curved
-- local solenoid_drift                                              -- solenoid
-- local twcavity_drift                                              -- cavities

-- kicks
-- local thin_kick                                                   -- thin
-- local straight_kick  , quadrupole_kick                            -- straight
-- local polar_kick     , combined_kick                              -- curved
-- local rfcavity_kick  , twcavity_kick                              -- cavities

-- fringes
-- local straight_fringe                                             -- straight
-- local polar_fringe   , sbend_fringe                               -- curved
-- local solenoid_fringe                                             -- solenoid
-- local rfcavity_fringe, twcavity_fringe                            -- cavities

-- helpers --------------------------------------------------------------------o

local function bxby (nmul, knl, ksl, x, y, lw)
  if nmul == 0 then return 0, 0 end
  -- bdir, charge?

  local by = lw*knl[nmul] / fact(nmul-1)
  local bx = lw*ksl[nmul] / fact(nmul-1)
  local byt

  for i=nmul-1,1,-1 do
    byt = x*by - y*bx + lw*knl[i] / fact(i-1)
    bx  = y*by + x*bx + lw*ksl[i] / fact(i-1)
    by  = byt
  end
  return bx, by
end

local function drift (l, m) -- exact, l~=0
  if abs(l) < minlen then return end
  l = l*m.bdir

  local x, px, y, py, t, pt, T in m
  local _beta = 1/m.beam.beta
  local l_pz = l/sqrt(1 + 2*_beta*pt + pt^2 - px^2 - py^2)

  m.x = x + px*l_pz
  m.y = y + py*l_pz
  m.t = t - (_beta+pt)*l_pz + (1-T)*l*_beta
end

local function drift_adj (l, m) -- drift adjustment (quad, sbend)
  if abs(l) < minlen then return end
  drift(l, m)
  m.x = m.x - m.px*l*m.bdir
  m.y = m.y - m.py*l*m.bdir
end

local function tilt (a, m) -- exact, a~=0
  if abs(a) < minang then return end
  a = a*m.bdir

  local x, px, y, py in m
  local sa, ca = sin(a), cos(a)

  m.x  = ca*x  + sa*y
  m.y  = ca*y  - sa*x
  m.px = ca*px + sa*py
  m.py = ca*py - sa*px
end

-- patches --------------------------------------------------------------------o

-- X-rotation (pitch)

function M.xrotation (elm, m, _)  -- Rx(phi) [ROT_YZR]
  local phi = (elm.phi or 0) + (elm.dphi or 0)
  if abs(phi) < minang then return end

  local x, px, y, py, t, pt, sdir in m
  local sa, ca, ta = sin(phi*sdir), cos(phi*sdir), tan(phi*sdir)
  local _beta = 1/m.beam.beta
  local    pz = sqrt(1 + 2*_beta*pt + pt^2 - px^2 - py^2)
  local   _pz = 1/pz
  local   ptt = 1 - ta*py*_pz
  local  _ptt = 1/ptt

  m.y  = y/(ca*ptt)
  m.py = ca*py + sa*pz
  m.x  = x + ta*y*px*_pz*_ptt
  m.t  = t - ta*y   *_pz*_ptt*(_beta+pt)
end

-- Y-rotation (yaw)

function M.yrotation (elm, m, _)  -- Ry(theta) [ROT_XZR or PROT]
  local theta = (elm.theta or 0) + (elm.dtheta or 0)
  if abs(theta) < minang then return end

  local x, px, y, py, t, pt, sdir in m
  local sa, ca, ta = sin(theta*sdir), cos(theta*sdir), tan(theta*sdir)
  local _beta = 1/m.beam.beta
  local    pz = sqrt(1 + 2*_beta*pt + pt^2 - px^2 - py^2)
  local   _pz = 1/pz
  local   ptt = 1 - ta*px*_pz
  local  _ptt = 1/ptt

  m.x  = x/(ca*ptt)
  m.px = ca*px + sa*pz
  m.y  = y + ta*x*py*_pz*_ptt
  m.t  = t - ta*x   *_pz*_ptt*(_beta+pt)
end

-- S-rotation (roll, tilt)

function M.srotation (elm, m, _)  -- Rz(psi) [XYrot]
  local psi = (elm.psi or 0) + (elm.dpsi or 0)
  tilt(psi, m)
end

-- Translation (dz treated as a drift)

function M.translate (elm, m, _)
  local dx = (elm.x or 0) + (elm.dx or 0)
  local dy = (elm.y or 0) + (elm.dy or 0)
  local dz = (elm.z or 0) + (elm.dz or 0)
  local bdir in m

  drift(dz, m)
  m.x = m.x - dx*bdir
  m.y = m.y - dy*bdir
end

-- Changedir (reverse x and angles)

function M.changedir(_, m, _)
  m.sdir = -m.sdir
  m.bdir = -m.bdir
end

-- Forward patch

function M.fwdpatch (elm, m, _)
  M.xrotation(elm, m)    -- phi  : Elevation angle.
  M.yrotation(elm, m)    -- theta: Azimuthal angle.
  M.srotation(elm, m)    -- psi  : Roll      angle.
  M.translate(elm, m)
end

-- Backward patch

function M.bwdpatch (elm, m, _)
  M.translate(elm, m)
  M.srotation(elm, m)    -- psi  : Roll      angle.
  M.yrotation(elm, m)    -- theta: Azimuthal angle.
  M.xrotation(elm, m)    -- phi  : Elevation angle.
end

-- Entry/Exit patches

function M.entry_patch (elm, m, _)
  M.fwdpatch(elm, m)
  tilt(elm.tilt, m)
end

function M.exit_patch (elm, m, _)
  tilt(-elm.tilt, m)
  M.bwdpatch(elm, m)
end

-- drifts ---------------------------------------------------------------------o

function M.straight_drift (elm, m, l)
  drift(l, m)
end

function M.rbend_drift (elm, m, l) -- exact, l~=0
  local knl in m
  if abs(knl[1]) < minang then
    return drift(l,m)
  end

  local x, px, y, py, t, pt, bdir, T in m
  local _beta = 1/m.beam.beta
  local lw = l/elm.l
  local k0 = bdir*lw*knl[1]

  local pz = sqrt(1 + 2*_beta*pt + pt^2 - px^2 - py^2)
  local pt = sqrt(1 + 2*_beta*pt + pt^2 - py^2)
  local xp = px - k0
  local ps = sqrt(1 + 2*_beta*pt + pt^2 - xp^2 - py^2)
  local xs = (asin(px/pt) - asin(xp/pt))/k0

  m.x  = x + (ps-pz)/k0
  m.px = xp
  m.y  = y + py*xs
  m.t  = t - (_beta+pt)*xs + (1-T)*l*_beta
end

function M.solenoid_drift (elm, m, l) -- exact, l~=0
  if abs(m.ksi) < minang then
    return M.rbend_drift(elm,m,l)
  end

  local x, px, y, py, t, pt, T, bdir in m
  local _beta = 1/m.beam.beta
  local _el = 1/elm.l

  local bsol = m.ksi*bdir*_el/2
  local xp = px + bsol*y
  local yp = py - bsol*x

  local l_pz  = l/sqrt(1 + 2*_beta*pt + pt^2 - xp^2 - yp^2)
  local angle = l_pz*bsol

  local ca, sa, sc = cos(angle), sin(angle), sinc(angle)

  local xt  = ca*x  + l_pz*sc*px
  local pxt = ca*px - l_pz*sc*x *bsol^2
  local yt  = ca*y  + l_pz*sc*py
  local pyt = ca*py - l_pz*sc*y *bsol^2

  m.x  = ca*xt  + sa*yt
  m.px = ca*pxt + sa*pyt
  m.y  = ca*yt  - sa*xt
  m.py = ca*pyt - sa*pxt

  m.t  = t - (_beta+pt)*l_pz + (1-T)*l*_beta
end

function M.quadrupole_drift (elm, m, l) -- comb_drift with angle == 0
  local _el   = 1/elm.l
  local _beta = 1/m.beam.beta
  local l_bet2_gam2 = l/(m.beam.gamma^2-1)

  local knl, bdir in m
  local k0, k1 = bdir*knl[1]*_el, bdir*knl[2]*_el
  local w2 = abs(k1)
  local w  = sqrt(w2)

  -- TODO: case w=0...
  local cw, sw = cos (w*l), sin (w*l)/w
  local ch, sh = cosh(w*l), sinh(w*l)/w

  if k1 < 0 then
    cw, sw, ch, sh = ch, sh, cw, sw
  end

  local npos in m
  if npos == 'last' then
    drift_adj(l  , m) ; m.npos = nil
  elseif npos == nil then
    drift_adj(l/2, m)
  end

  local x, px, y, py, t, pt in m
  local m16 = (1-cw)/w2

  m.x  =    cw*x + sw*px -k0*m16
  m.px = -w*sw*x + cw*px -k0*sw
  m.y  =    ch*y + sh*py
  m.py =  w*sh*y + ch*py
  m.t  = t + l_bet2_gam2*pt

  if npos == 'first' then
    drift_adj(l  , m) ; m.npos = nil
  elseif npos == nil then
    drift_adj(l/2, m)
  end
end

function M.combined_drift (elm, m, l)
  local _el   = 1/elm.l
  local _beta = 1/m.beam.beta
  local l_bet2_gam2 = l/(m.beam.gamma^2-1)

  local angle = elm.angle
  local lw    = l*_el
  local h     = lw*angle
  local hbar  = h*_beta

  local knl, bdir in m
  local k0, k1 = bdir*knl[1]*_el, bdir*knl[2]*_el
  local hk0pk1 = h*k0+k1
  local wx2, wy2 = abs(hk0pk1), abs(k1)
  local wx , wy  = sqrt(wx2), sqrt(wy2)

  local cx, sx, cy, sy
  if hk0pk1 < 0
  then cx, sx = cosh(wx*l), sinh(wx*l)/wx -- check wx == 0
  else cx, sx = cos (wx*l), sin (wx*l)/wx -- check wx == 0
  end
  if k1 < 0
  then cy, sy = cosh(wy*l), sinh(wy*l)/wy -- check wy == 0
  else cy, sy = cos (wy*l), sin (wy*l)/wy -- check wy == 0
  end

  local npos in m
  if npos == 'last' then
    drift_adj(l  , m) ; m.npos = nil
  elseif npos == nil then
    drift_adj(l/2, m)
  end

  local x, px, y, py, t, pt in m
  local m16, m56 = (1-cx)/wx2, hbar^2*(l-sx)/wx2

  m.x  =      cx*x + sx*px + hbar*m16*pt + (h-k0)*m16
  m.px = -wx2*sx*x + cx*px + hbar*sx*pt  + (h-k0)*sx
  m.y  =      cy*y + sy*py
  m.py =  wy2*sy*y + cy*py
  m.t  = t - hbar*(sx*x+m16*px) + (l_bet2_gam2-m56)*pt

  if npos == 'first' then
    drift_adj(l  , m) ; m.npos = nil
  elseif npos == nil then
    drift_adj(l/2, m)
  end
end

function M.polar_drift (elm, m, l) -- exact, l~=0, k0=angle
  local rho = elm.l/(elm.angle*m.sdir)
  local ang = l/rho
  local sa, ca, ta, sa2 = sin(ang), cos(ang), tan(ang), sin(ang/2)

  local x, px, y, py, t, pt, T in m
  local _beta = 1/m.beam.beta
  local pz  = sqrt(1 + 2*_beta*pt + pt^2 - px^2 - py^2)
  local _pz = 1/pz
  local ptt = 1 - ta*px*_pz
  local xr  = (x+rho)*ta*_pz

  m.x  = (x + rho*(2*sa2^2 + sa*px*_pz))/(ca*ptt)
  m.px = ca*px + sa*pz
  m.y  = y + xr*py/ptt
  m.t  = t - xr*(_beta+pt)/ptt + (1-T)*l*_beta
end

function M.sbend_drift (elm, m, l) -- exact, l~=0, k0~=angle
  local angle in elm
  local knl in m
  if abs(angle - knl[1]) < minang then
    return polar_drift(elm,m,l)
  end
  error("NYI")
end

-- PRECEDENCE SHOULD BE OUTSIDE INTEGRATORS
--local function combined_drift (elm, m, l) -- angle, k0, k1 (tunes)
--  if abs(m.knl[2]) < minang then -- Put these checks outside the integrator
--    if abs(angle) < minang then
--      return rbend_drift(elm,m,l)
--    else
--      return sbend_drift(elm,m,l)
--    end
--  else
--    if abs(angle) < minang then
--      return quadrupole_drift(elm,m,l)
--    else
--      return combined_drift  (elm,m,l)
--    end
--  end
--end

-- kicks ----------------------------------------------------------------------o

-- Special case TO BE REVIEWED !!!
function M.thin_kick (elm, m, _) -- l=0 (ignored)
  local nmul in m
  if nmul == 0 then return end

--  local knlt, kslt = elm.knl or {}, elm.ksl or {} -- BUG: not retrieved by getmul
--  local knl1, ksl1 = (knlt[1] or 0), (kslt[1] or 0)

  local x, px, y, py, bdir, knl, ksl in m
  local bx, by = bxby(nmul, knl, ksl, x, y, 1)

  m.px = px - bdir*(by + knl[1])
  m.py = py + bdir*(bx - ksl[1])

  if knl1 ~= 0 or ksl1 ~= 0 then
    local t, pt in m
    local _beta = 1/m.beam.beta
    local pz = sqrt(1 + 2*_beta*pt + pt^2)

    local l = elm.lrad or 0 -- TODO: check if lrad or l?
    if l ~= 0 then -- dipole focusing and deltap
      m.px = m.px - knl[1]^2*x/l + bdir*knl[1]*(pz-1)
      m.py = m.py - ksl[1]^2*y/l + bdir*ksl[1]*(pz-1)
    end
--    m.t = t + bdir*(knl1*x - ksl1*y) * (_beta+pt)/pz
    m.t = t - bdir*(knl[1]*x - ksl[1]*y) * (_beta+pt)/pz
  end
end

function M.straight_kick (elm, m, l) -- l~=0
  local nmul in m
  if nmul == 0 then return end

  local x, px, y, py, knl, ksl, bdir in m
  local lw = abs(elm.l)>minlen and l/elm.l or 1
  local bx, by = bxby(nmul, knl, ksl, x, y, lw)

  m.px = px - bdir*by
  m.py = py + bdir*bx
end

function M.quadrupole_kick (elm, m, l)
  if abs(m.knl[2]) < minang then -- should never occur due to precedences
    return M.rfcavity_kick(elm,m,l)
  end

  local x, px, y, py, t, pt, bdir, T, nmul, knl, ksl in m
  local _beta = 1/m.beam.beta
  local pz = sqrt(1 + 2*_beta*pt + pt^2) - 1

  local lw = l/elm.l
  local bx, by = bxby(nmul, knl, ksl, x, y, lw)

   m.px = px + lw*knl[1]*(pz-pt)*_beta
   m.t  = t  - lw*knl[1]*((pt+_beta)/(1+pz) - _beta)*x

   m.px = m.px - bdir*(by - lw*(knl[1] - knl[2]*x))
   m.py = m.py + bdir*(bx - lw*          knl[2]*y )
end

function M.polar_kick (elm, m, l) -- [PTC] SKICK
  local angle in elm
  if abs(angle) < minang then -- should never occur due to precedences
    return M.straight_kick(elm,m,l)
  end

  local x, px, y, py, nmul, knl, ksl, bdir in m
  local lw = l/elm.l
  local bx, by = bxby(nmul, knl, ksl, x, y, lw) -- TODO: GETELECTRIC

  local h = lw*angle
  m.px = px - bdir*by*(1 + h*x)
  m.py = py + bdir*bx*(1 + h*x)
end

function combined_kick (elm, m, l) -- angle, k0, k1 (tunes)
--  local knl in m
--  if abs(knl[2]) < minang then
    return M.polar_kick(elm,m,l)
--  end
  -- error("NYI") -- TODO
end

function rfcavity_kick (elm, m, l) --RF CAV, CRAB, RFMULT with l>0 kick (kickcavr)
  --local vrf in m
  --if abs(vrf) < minvolt then
    return M.straight_kick(elm,m,l) -- WARNING: NYI
  --end

-- missing input: tt, phase, phase0, ff, ph, a, r, nbessel, freq, volt, lag

--  local x, px, y, py, t, pt, bdir, nmul, knl, ksl in m
--  local volt, freq, lag, nbessel in elm
--
--  if freq == 0 then
--    error("Frequency number has to be defined for RF Cavity (i.e. harmon NYI) "
--          .. elm.name)
--  end
--
--  local pc = m.beam.pc
--  local omega = twopi*freq / clight
--  local vl    = bdir*l*volt*volt_c/pc
--  local df, f, r2 = 0, 1, 1
--
--  do i=1,nbessel
--    r2  = -r2*(ko*omega)^2/(4*(i+1)^2)
--    dr2 =  r2*i
--    df  =  df + 2*dr2
--    r2  =  r2*(x^2+y^2)
--    f   =  f + r2
--  end
--
--  local ff, ph = elm.f or {}, elm.ph or {}
--  local a , r  = elm.a or  0, elm.r or 0
--  local arg = omega*(t + tt) + phasе + ph + phase0
--
--  if nbessel > 0 then
--    m.px = px-x*ff[ko]* df * vl * cos(arg)/(omega)
--    m.py = py-y*ff[ko]* df * vl * cos(arg)/(omega)
--  end
--
--  m.pt = m.pt -ff*f*vl*sin(arg)
--
--  local lw = elm.l>0 and l/elm.l or 1
--  local bx, by = bxby(nmul, knl, ksl, x, y, lw)
--
--  m.px = m.px - ff[ko]*           bdir*by/pc*(a + r*cos(arg))
--  m.py = m.py + ff[ko]*           bdir*bx/pc*(a + r*cos(arg))
--  m.pt = m.pt + ff[ko]*(ko*omega)*bdir*by/pc*     r*sin(arg)

--[[ useful???
  by = -lw*knl[nmul] / fact(nmul-1) / nmul
  bx = -lw*ksl[nmul] / fact(nmul-1) / nmul

  for i=nmul-1,1,-1 do
    byt = x*by - y*bx - lw*knl[i] / fact(i-1) / i
    bx  = y*by + x*bx - lw*ksl[i] / fact(i-1) / i
    by  = byt
  end

  byt = x*by - y*bx
  bx  = y*by + x*bx
  by  = byt
]]
end

-- fringes --------------------------------------------------------------------o

local function sbend_face (elm, m, h)
  local x, px, y, py, t, pt, bdir in m
  local k0 = elm.k0 or 0
  local _beta = 1/m.beam.beta

  if bdir == 1 then -- to insure reversal symmetry ; horizontal wedge (only dir)
    px = px +(bdir*k0*h/2)*x^2
  end

  local ptt =        sqrt(1 + 2*pt*_beta + pt^2 - px^2)
  local xi  = bdir*sqrt(1 + 2*pt*_beta + pt^2)*k0*h/ptt^2
  local dxi_px   =  2*px*xi/ptt^2
  local dxi_ddel = -2*xi*(1 + pt)/ptt^2

  x  = x / (1-dxi_px*y^2)
  px = px - xi*y^2
  py = py - 2*xi*x*y
  t  = t  - dxi_ddel*x*y^2

  if(bdir == -1) then -- to insure reversal symmetry; horizontal wedge (only dir)
    px = px +(bdir*k0*h/2)*x^2
  end

  m.x  = x
  m.px = px
  m.py = py
  m.t  = t
end

local function sbend_wedge (elm, m, e)
  local x, px, y, py, t, pt, T, bdir in m
  local k0 = elm.k0 or 0
  local _beta = 1/m.beam.beta
  local b1 = bdir*k0
  local sa, ca, sa2 = sin(e), cos(e), sin(2*e)

  if b1 == 0 then
    yrot_track (elm, m, e) return
  end

  local pz  = sqrt(1 + 2*_beta*pt + pt^2 - px^2 - py^2)
  local ptt = sqrt(1 + 2*_beta*pt + pt^2        - py^2)
  local pxt = px*ca + (pz - b1*x)*sa
  local pzs = sqrt(1 + 2*_beta*pt + pt^2 - py^2 - pxt^2)
  local yt  = (e + asin(px/ptt) - asin(pxt/ptt)) / b1

  m.x  = x*ca + (x*px*sa2 + sa^2*(2*x*pz-b1*x^2)) / (pzs+pz*ca-px*sa)
  m.px = pxt
  m.y  = y + py * yt
  m.t  = t - yt*(_beta + pt)
end

local function sbend_fringe_field (elm, m, pos)
--  TODO: FINT and FINTX to have different FINT at entrance /exit
  local x, px, y, py, t, pt, T in m
  local k0   = elm.k0 or 0
  local _beta = 1/m.beam.beta
-- soft edge
  local fint = elm.fint or 0  -- fringe field integral at entrance and exit of the bend
  local hgap = elm.hgap or 0  -- half gap of the magnet
  local fsad = 0

  if fint*hgap ~= 0.0 then  -- soft edge
      fsad = 1/(fint*hgap*2)/36
  end

  local b = m.beam.charge*k0
  if pos == 'exit' then
     b = -b
  end

  local pz = sqrt(1 + 2*_beta*pt + pt^2 - px^2 - py^2)
  local time_fac = _beta + pt
  local rel_p    = sqrt(1 + 2*_beta*pt + pt^2)

  local c3=b^2*fsad/rel_p

  local xp, yp = px/pz or 0, py/pz or 0
  local d = matrix { -- to remove!
    { (1+xp^2) / pz, xp*yp    / pz, -time_fac*xp /pz^2 },
    {  xp*yp   / pz, (1+yp^2) / pz, -time_fac*yp /pz^2 },
    { -xp          ,   -yp        ,  time_fac    /pz   },
  }

  local fi0 = atan((xp/(1 + yp^2)))-2*b*fint*hgap*(1 + xp^2*(2 + yp^2))*pz
  local co2 = b/cos(fi0)^2
  local co1 = co2/(1 + (xp/(1 + yp^2))^2)

  local fi = {0, 0, 0}
  fi[1] =    co1 /       (1 + yp^2) - 2*co2*b*fint*hgap* (2*xp*(2 + yp^2)*pz)
  fi[2] =-2*co1*xp*yp/(1 + yp^2)^2  - 2*co2*b*fint*hgap* (2*xp^2*yp)*pz
  fi[3] =                           - 2*co2*b*fint*hgap* (1 + xp^2*(2 + yp^2))

  fi0=b*tan(fi0)

  b=0
  for i=1,3 do -- y column
    b=fi[i]*d:get(i,2) + b
  end
  m.y  = 2*m.y/(1 + sqrt(1 - 2*b*m.y))
  m.py = py - fi0*m.y

  b=0
  for i=1,3 do -- x column
    b=fi[i]*d:get(i,1) + b
  end
  m.x = m.x+0.5*b*m.y^2

  b=0
  for i=1,3 do -- z column
    b=fi[i]*d:get(i,3) + b
  end
  m.t = t + 0.5*b*m.y^2

  -- soft edge
  m.py = m.py - 4*c3*m.y^3
  m.t  = m.t  +   c3*m.y^4/rel_p^2*time_fac
end

local function mult_fringe_field (elm, m)
  local x, px, y, py, bdir, nmul, knl, ksl in m
  local _beta = 1/m.beam.beta
  local _l = 1/elm.l

  local rx, ix, fx, fy, fxx, fxy, fyx, fyy = 1, 0, 0, 0, 0, 0, 0, 0

	for i=1, nmul do
	  local drx, dix = rx, ix
    rx  = drx*x - dix*y
    ix  = drx*y + dix*x

    local ni, nf = -bdir/(4*(i+1)), i+2/i
    local lkn, lks = knl[i]*_l, ksl[i]*_l

    local u   =  ni*(lkn*rx  - lks*ix )
    local v   =  ni*(lkn*ix  + lks*rx )
    local du  =  ni*(lkn*drx - lks*dix)
    local dv  =  ni*(lkn*dix + lks*drx)
	  local dux =   i*du
    local dvx =   i*dv
    local duy =  -i*dv
    local dvy =   i*du

    fx  = fx  +   u*x + nf*       v*y
    fy  = fy  +   u*y - nf*       v*x
    fxx = fxx + dux*x + nf*     dvx*y + u
    fyy = fyy + duy*y - nf*     dvy*x + u
    fxy = fxy + duy*x + nf*(v + dvy*y)
    fyx = fyx + dux*y - nf*(v - dvx*x)
	end

  local _pz = 1/sqrt(1 + 2*pt*_beta + pt^2)
  local a = 1 - fxx*_pz
  local d = 1 - fyy*_pz
  local b =   - fyx*_pz
  local c =   - fxy*_pz
  local _det = 1/(a*d - b*c)

  m.x  = x - fx*_pz
  m.y  = y - fy*_pz
  m.px = (d*px - b*py)*_det
  m.py = (a*py - c*px)*_det
  m.t  = t + (_beta+pt)*(m.px*fx + m.py*fy)*_pz^3
end

local function straight_fringe_field (elm, m)
-- Lee-Whiting formula, E. Forest ch 13.2.3, eq 13.33
	local x, px, y, py, t, pt, T, bdir in m
  local k0   = elm.k0 or 0
  local _beta = 1/m.beam.beta
-- soft edge
  local fint = elm.fint or 0  -- fringe field integral at entrance and exit of the bend
  local hgap = elm.hgap or 0  -- half gap of the magnet

  local _pz  = 1/sqrt(1 + 2*_beta*pt + pt^2 )
  local time_fac = (_beta + pt)*_pz

  local a2, b2 = elm.ksl[2]/elm.l or 0, elm.knl[2]/elm.l or 0
  local b  = sqrt(b2^2 + a2^2)

  local f1 = -bdir*fint*abs(fint)*b*_pz/24.0
  local f2 =  hgap*b*_pz

  local ang=-atan2(a2,b2)/2

  tilt(-ang or 0, m)

  m.t = t - time_fac*(f1*x + f2*(1+f1/2)*px*_pz*exp(-f1))*px*_pz
          + time_fac*(f1*y + f2*(1-f1/2)*py*_pz*exp( f1))*py*_pz

  m.x = x*exp( f1) + px*f2*_pz
  m.y = y*exp(-f1) - py*f2*_pz

  m.px = px*exp(-f1)
  m.py = py*exp( f1)

  tilt(-ang or 0, m)
end

function sbend_fringe_ptc (elm, m, pos)
  if pos == 'entry' and not elm.kill_ent_fringe then
    local e, h = elm.e1 or 0, elm.h1 or 0
    if abs(e) < minang then
      sbend_face         (elm, m,  h)
      sbend_fringe_field (elm, m,  'entry')
    else
      yrotation          (elm, m,  e)
      sbend_face         (elm, m,  h)
      sbend_fringe_field (elm, m,  'entry')
      sbend_wedge        (elm, m, -e)
    end
    return
  end

  if pos == 'exit' and not elm.kill_exi_fringe then
    local e, h = elm.e2 or 0, elm.h2 or 0
    if abs(e) < minang then
      sbend_fringe_field (elm, m, 'exit')
      sbend_face         (elm, m,  h)
    else
      sbend_wedge        (elm, m, -e)
      sbend_fringe_field (elm, m, 'exit')
      sbend_face         (elm, m,  h)
      yrotation          (elm, m,  e)
    end
    return
  end
end

function M.straight_fringe (elm, m, l)
  local nmul, sdir in m
  if nmul == 0 then return end

  if pos == 'entry' then
	  local e, h = elm.e1 or 0, elm.h1 or 0
    if sdir == 1 then
    	M.yrotation         (elm, m, e)
    	M.sbend_face        (elm, m, h)
    	M.sbend_fringe_field(elm, m, 'entry')
	  else
      M.sbend_fringe_field(elm, m, 'entry')
      M.sbend_face        (elm, m, h)
      M.yrotation         (elm, m, e)
    end
    mult_fringe_field     (elm, m, 'entry')
    straight_fringe_field (elm, m, 'entry')
    return
  end

  if pos == 'exit' then
    local e, h = elm.e2 or 0, elm.h2 or 0
    straight_fringe_field (elm, m, 'exit')
    mult_fringe_field     (elm, m, 'exit')
  	if sdir == 1 then
      M.sbend_fringe_field(elm, m, 'exit')
      M.sbend_face        (elm, m, h)
      M.yrotation         (elm, m, e)
	  else
  	  M.yrotation         (elm, m, e)
  	  M.sbend_face        (elm, m, h)
  	  M.sbend_fringe_field(elm, m, 'exit')
    end
    return
  end
end

function M.solenoid_fringe (elm, m, l)
--  local ksi in m
--  if abs(ksi) < minang then -- should never occur due to precedences
    return M.straight_fringe(elm,m,l)
--  end
  -- error("NYI") -- TODO
end

local rfcavity_fringe_ptc -- forward

function M.rfcavity_fringe (elm, m, l)
--  local v in m
--  if abs(v) < minvolt then -- should never occur due to precedences
    return M.straight_fringe(elm,m,l)
--  end
  -- rfcavity_fringe_ptc(elm, m, l) -- TODO
end

local sbend_fringe_ptc -- forward

function M.sbend_fringe (elm, m, l)
  local angle in elm
  if abs(angle) < minang then -- should never occur due to precedences
    return straight_fringe(elm,m,l)
  end
  sbend_fringe_ptc(elm, m, l)
end

-- cavities -------------------------------------------------------------------o

--[=[
local function rfcavity_kick (elm, m, l) -- RF CAV, CRAB, RFMULT with l>0 kick (kickcavr)
  local x, px, y, py, t, pt, nmul, bdir in m
  local tt, phase, phase0 = elm.tt or 0, elm.phase or 0, elm.phase0 or 0
  local ff, ph = elm.f or {}, elm.ph or {}
  local a, r = elm.a or  0, elm.r or 0

  -- nocavity.and.(.not.always_on)  return
  if 'nocavity' and (not 'always_on') then return end -- non-sense!!!

  local pc = m.beam.pc
  local volt_c = 1.0e-3
  local freq, harm, volt, lag = elm.freq or 0, elm.harm or 0, elm.volt or 0, elm.lag or 0
  local nbessel, nf = elm.nbessel or  0, elm.nf or 1
  if freq == 0 and harm == 0 then
    error("either frequency or harmonic number has to be defined for RF Cavity "
          .. elm.name)
  end

  local omega = twopi*freq / clight
  local vl    = m.bdir*l*volt*volt_c/pc
  local df, f, r2 = 0, 1, 1

  for ko=1,nf do -- over modes
    for i=1,nbessel do
      r2  = -r2*(ko*omega)^2/(4*(i+1)^2)
      dr2 =  r2*i
      df  =  df + 2*dr2
      r2  =  r2*(x^2+y^2)
      f   =  f + r2
    end

    if nbessel > 0 then
      m.px = px-x*ff[ko]* df * vl * cos(arg)/(ko*omega)
      m.py = py-y*ff[ko]* df * vl * cos(arg)/(ko*omega)
    end

    local arg = ko*omega*(t + tt) + phas + ph[ko] + phase0
    m.pt = m.pt -ff[ko]*f*vl*sin(arg)

    local lw, byt = elm.l>0 and l/elm.l or 1
    local by = lw*knl[nmul] / fact(nmul-1)
    local bx = lw*ksl[nmul] / fact(nmul-1)

    for i=nmul-1,1,-1 do
      byt = x*by - y*bx + lw*knl[i] / fact(i-1)
      bx  = y*by + x*bx + lw*ksl[i] / fact(i-1)
      by  = byt
    end

    m.px = m.px - ff[ko]*bdir*by/pc*(a + r*cos(arg))
    m.py = m.py + ff[ko]*bdir*bx/pc*(a + r*cos(arg))

    by = -lw*knl[nmul] / fact(nmul-1) / nmul
    bx = -lw*ksl[nmul] / fact(nmul-1) / nmul

    for i=nmul-1,1,-1 do
      byt = x*by - y*bx - lw*knl[i] / fact(i-1) / i
      bx  = y*by + x*bx - lw*ksl[i] / fact(i-1) / i
      by  = byt
    end

    byt = x*by - y*bx
    bx  = y*by + x*bx
    by  = byt

    m.pt = m.pt + ff[ko]*(ko*omega)*bdir*by/pc * r *sin(arg)
  end --over modes
end

local function rfcavity_thin_kick (elm, m, l) -- for tracking thin rf mult
  local x, px, y, py, t, pt, nmul, bdir in m
  local tt, phase, phase0 = elm.tt or 0, elm.phase or 0, elm.phase0 or 0
  local ff, ph = elm.f or {}, elm.ph or {}
  local a, r = elm.a or  0, elm.r or 0
  -- nocavity.and.(.not.always_on)  return
  if 'nocavity' and (not 'always_on') then return end -- non-sense!!!

  local pc = beam.pc
  local volt =elm.volt
  local volt_c = 1.0e-3
  local omega = twopi*freq / clight

  for ko=1,nf do -- over modes
    local arg = ko*omega*(t + tt) + phas + ph[ko] + phase0
    m.pt = m.pt - bdir*volt_c*ff[ko]*volt*sin(arg)/pc

    -- BUG: knl, ksl never retrieved
    local lw, byt = elm.l>0 and l/elm.l or 1
    local by = lw*knl[nmul] / fact(nmul-1)
    local bx = lw*ksl[nmul] / fact(nmul-1)

    for i=nmul-1,1,-1 do
      byt = x*by - y*bx + lw*knl[i] / fact(i-1)
      bx  = y*by + x*bx + lw*ksl[i] / fact(i-1)
      by  = byt
    end

    m.px = m.px - ff[ko]*bdir*by/pc*(a + r*cos(arg))
    m.py = m.py + ff[ko]*bdir*bx/pc*(a + r*cos(arg))

    by = -lw*knl[nmul] / fact(nmul-1) / nmul
    bx = -lw*ksl[nmul] / fact(nmul-1) / nmul

    for i=nmul,2,-1 do
      byt = x*by - y*bx - lw*knl[i-i] / fact(i-2) / (i-1)
      bx  = y*by + x*bx - lw*ksl[i-i] / fact(i-2) / (i-1)
      by  = byt
    end

    byt = x*by - y*bx
    bx  = y*by + x*bx
    by  = byt

    m.t = t - ff[ko]*(ko*omega)*bdir*by/pc * r *sin(arg)
  end --over modes
end

local function adjust_time_cav(elm, m, pos)
  local x, px, y, py, t, pt, T, dir in m
  local _beta = 1/m.beam.beta

  local delta_e = elm.delta_e or 0
  if pos == 'entry' then
    delta_e = pt
    if 'nocavity' and (not 'always_on') then return end -- non-sense!!!

    if elm.l < minlen then
      rfcavity_thin_kick(elm, m)
      delta_e=(m.pt - delta_e)*m.beam.pc -- side effects?
    end
  else
    if elm.l < minlen then return end
    t = t - elm.l*_beta -- TO CHECK      -- side effects?
    delta_e = (pt - delta_e)*m.beam.pc   -- side effects?
  end
end

local function rfcavity_fringe_ptc (elm, m, pos)
  local x, px, y, py, t, pt, T, dir in m

  if ('nocavity' and (not 'always_on')) then return end -- non-sense!!!

  if elm.kill_fringe     == 1                     or
     elm.kill_ent_fringe == 1 and pos ==  'entry' or
     elm.kill_ext_fringe == 1 and pos ==  'exit' then return end

  adjust_time_cav(elm, m, 'entry')

  if not ('fringe' or elm.nbessel == -1) then return end
  if elm.l < minlen then return end

  local kbmad = 0
  if elm.nbessel == -1 then kbmad = 1 end

  local z = 0
  if pos == 'entry' then z = elm.l end
  local freq, volt = elm.freg or 0, elm.volt or 0
  local volt_c = 1.0e-3
  local pc = m.beam.pc
  local omega = twopi*freq / clight
  local vl = m.bdir*volt*volt_c/pc
  if pos == 'exit' then vl = -vl end

  local tt, phase, phase0 = elm.tt or 0, elm.phase or 0, elm.phase0 or 0
  local ph = elm.f or {}, elm.ph or {}
  local nf = elm.nf or 1

  for ko=1,nf do   -- over modes
   s1 = cos(kbmad*ko*omega*z)*sin(ko*omega*(t+tt) + phas + phase0 + ph[ko])
   c1 = cos(kbmad*ko*omega*z)*cos(ko*omega*(t+tt) + phas + phase0 + ph[ko])
   m.px = m.px + 0.5*vl*s1*m.x
   m.py = m.py + 0.5*vl*s1*m.y
   m.pt = m.pt - 0.25*(m.x^2 + m.y^2)*vl*c1*omega*ko
  end

  adjust_time_cav(elm, m, 'exit')
end
--]=]

-- end ------------------------------------------------------------------------o
return M
