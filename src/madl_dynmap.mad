--[=[
 o-----------------------------------------------------------------------------o
 |
 | Dynamic 6D maps
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: I. Shreyber, irina.tecker at cern.ch
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide a catalog of dynamical 6D maps (i.e. track)
    maps must have the following calling convention:
      dynmap(elm, map, length_weight)
    (see the symplectic integrators)
  - TODO: list the expected fields for elm and map

 o-----------------------------------------------------------------------------o
]=]

local M = {}

-- PTC variables:
-- L     thick weighted length
-- LD    thick weighted arc length
-- YL    kick  weighted length
-- B     relativistic beta0
-- B0    curvature = angle/LD
-- BN(1) k0
-- BN(2) k1
-- DIR   tracking direction

-- Note:
-- Is (_beta+pt) in t eq. shouldn't be sqrt((_beta+pt)^2 - (_beta*_gamma)^2) ??
-- is it a 1st order approximation?

-- locals ---------------------------------------------------------------------o

local vector, matrix                                             in MAD
local is_nil, is_number, is_damap                                in MAD.typeid
local minlen, minang, minstr, clight, twopi                      in MAD.constant
local printf                                                     in MAD.utility

local fnone                                                      in MAD.gfunc
local abs, sqrt, max, sin, cos, tan, asin, acos, atan, atan2,
      sinh, cosh, sinc                                           in MAD.gmath

-- field mutipoles ------------------------------------------------------------o

local function bxby (nmul, knl, ksl, x, y)
  local bx, by, byt = 0, 0

  for i=nmul,1,-1 do
    byt = by*x - bx*y + knl[i]
    bx  = by*y + bx*x + ksl[i]
    by  = byt
  end

  return bx, by
end

-- TODO: hbxby (nmul, knl, ksl, x, y, h) using CTPSA for knl & ksl [GETANBN]

-- patches (lw_ == 0 disable the patches) -------------------------------------o

-- X-rotation

local function xrotation (elm, m, lw_)  -- Rx(ax) [ROT_YZ]
  if lw_ == 0 then return end

  local ax = is_number(elm) and elm or elm.angle*m.tdir
  if abs(ax) < minang then return end

  local ax = ax*(lw_ or 1)
  local sa, ca, ta = sin(ax), cos(ax), tan(ax)
  local _beta = 1/m.beam.beta

  m:dump(elm, 'xrotation:0')

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beta = beam and 1/beam.beta or _beta
    local    pz = sqrt(1 + (2*_beta)*pt + pt^2 - px^2 - py^2)
    local   _pz = 1/pz
    local   ptt = 1 - ta*py*_pz
    local  _ptt = y/ptt
    local  _pzt = ta*_pz*_ptt

    -- eq. 127 in Forest06
    m[i].y  = _ptt/ca
    m[i].py = ca*py + sa*pz
    m[i].x  = x + _pzt*px
    m[i].t  = t - _pzt*(_beta+pt)
  end

  m:dump(elm, 'xrotation:1')
end

M.xrotation = xrotation

-- Y-rotation

local function yrotation (elm, m, lw_)  -- Ry(ay) [ROT_XZ]
  if lw_ == 0 then return end

  local ay = is_number(elm) and elm or elm.angle*m.tdir
  if abs(ay) < minang then return end

  local ay = ay*(lw_ or 1)
  local sa, ca, ta = sin(ay), cos(ay), tan(ay)
  local _beta = 1/m.beam.beta

  m:dump(elm, 'yrotation:0')

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beta = beam and 1/beam.beta or _beta
    local    pz = sqrt(1 + (2*_beta)*pt + pt^2 - px^2 - py^2)
    local   _pz = 1/pz
    local   ptt = 1 - ta*px*_pz
    local  _ptt = x/ptt
    local  _pzt = ta*_pz*_ptt

    -- eq. 127 in Forest06
    m[i].x  = _ptt/ca
    m[i].px = ca*px + sa*pz
    m[i].y  = y + _pzt*py
    m[i].t  = t - _pzt*(_beta+pt)
  end

  m:dump(elm, 'yrotation:1')
end

M.yrotation = yrotation

-- S-rotation

local function srotation (elm, m, lw_)  -- Rz(az) [ROT_XY]
  if lw_ == 0 then return end

  local az = is_number(elm) and elm or elm.angle*m.tdir
  if abs(az) < minang then return end

  local az = az*(lw_ or 1)
  local sa, ca = sin(az), cos(az)

  m:dump(elm, 'srotation:0')

  for i=1,m.npar do
    local x, px, y, py in m[i]
    local nx  = ca*x  + sa*y
    local npx = ca*px + sa*py

    m[i].y    = ca*y  - sa*x
    m[i].py   = ca*py - sa*px
    m[i].x    = nx
    m[i].px   = npx
  end

  m:dump(elm, 'srotation:1')
end

M.srotation = srotation

-- Translation

local function translate (elm, m, lw_) -- [TRANS]
  if lw_ == 0 then return end

  local dx, dy, ds = elm.dx or 0, elm.dy or 0, elm.ds or 0
  if abs(dx)+abs(dy)+abs(ds) < minlen then return end

  local tdir in m
  local lw = lw_ or 1
  local dx, dy = dx*lw*tdir, dy*lw*tdir

  m:dump(elm, 'translate:0')

  if abs(ds) < minlen then
    for i=1,m.npar do
      local x, y in m[i]
      m[i].x = x - dx
      m[i].y = y - dy
    end
    return
  end

  -- ds is treated as a drift without correction for the time of flight
  local l = ds*lw*m.sdir
  local _beta = m.beam.beta
  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beta = beam and 1/beam.beta or _beta
    local l_pz = l/sqrt(1 + (2*_beta)*pt + pt^2 - px^2 - py^2)

    m[i].x = x - l_pz*px - dx
    m[i].y = y - l_pz*py - dy
    m[i].t = t + l_pz*(_beta+pt)
  end

  m:dump(elm, 'translate:1')
end

M.translate = translate

-- Changeref (generic patch, lw_>0: RT, lw_<0: TR)

function M.changeref (elm, m, lw_)
  if lw_ == 0 then return end
  local lw = lw_ or 1

  local dx  , dy  , ds   = elm.dx     or 0, elm.dy   or 0, elm.ds   or 0
  local dthe, dphi, dpsi = elm.dtheta or 0, elm.dphi or 0, elm.dpsi or 0

  local trn = abs(dx  )+abs(dy  )+abs(ds  ) >= minlen
  local rot = abs(dthe)+abs(dphi)+abs(dpsi) >= minang

  if not (trn or rot) then return end

  m:dump(elm, 'changeref:0')

  -- forward : x1' = R*x1+T
  -- backward: x1  = R^-1*(x1'-T)

  if lw > 0 then
      translate({dx=dx,dy=dy,ds=ds}, m, 1)
    if rot then
      yrotation({angle= dthe}, m, 1)
      xrotation({angle=-dphi}, m, 1)
      srotation({angle= dpsi}, m, 1)
    end
  else
    if rot then
      srotation({angle= dpsi}, m, -1)
      xrotation({angle=-dphi}, m, -1)
      yrotation({angle= dthe}, m, -1)
    end
      translate({dx=dx,dy=dy,ds=ds}, m, -1)
  end

  m:dump(elm, 'changeref:1')
end

-- Changedir (reverse mflow t-direction)

function M.changedir (elm_, m, lw_)
  if lw_ == 0 then return end

  m:dump(elm, 'changedir:0')

  m.edir = -m.edir
  m.tdir = -m.tdir

  m:dump(elm, 'changedir:1')
end

-- Changenrj (change particles energy)

function M.changenrj (elm, m, lw_)  -- (option to reset pt?)
  if lw_ == 0 then return end

  local dnrj in elm
  if dnrj == 0 then return end

  local tdir, beam in m
  beam.energy = beam.energy + dnrj*tdir

  m:dump(elm, 'changenrj:0')

  for i=1,m.npar do
    beam = m[i].beam
    if beam then
      beam.energy = beam.energy + dnrj*tdir
    end
  end

  m:dump(elm, 'changenrj:1')
end

-- misalignments (lw_ == 0 disable the misalignments) -------------------------o

local T  = vector(3) -- misalignment translation
local R  = matrix(3) -- misalignment rotation
local Tb = vector(3) -- misalignment translation at exit (Tbar)
local Rb = matrix(3) -- misalignment rotation    at exit (Rbar)

local misalignexi -- forward declaration

-- Misalign (lw_>0: entry, lw_<0: exit)

local misalignexi

function M.misalign (elm, m, lw_)
  if lw_ == 0 then return end
  if (lw_ or 1) < 0 then return misalignexi(elm, m) end

  local dx  , dy  , ds   = elm.dx     or 0, elm.dy   or 0, elm.ds   or 0
  local dthe, dphi, dpsi = elm.dtheta or 0, elm.dphi or 0, elm.dpsi or 0

  local trn = abs(dx  )+abs(dy  )+abs(ds  ) >= minlen
  local rot = abs(dthe)+abs(dphi)+abs(dpsi) >= minang

  if not (trn or rot) then return end

  m:dump(elm, 'misalign:0')

  local sdir, tdir in m

  -- misalignment at entry and local/global frames
  -- forward : x1' = R*x1+T
  -- backward: x1  = R^-1*(x1'-T)

  -- reuse patches without directions
  if sdir > 0 then
      translate({dx=dx*tdir,dy=dy*tdir,ds= ds}, m,  1)
    if rot then
      yrotation( dthe, m,  1)
      xrotation(-dphi, m,  1)
      srotation( dpsi, m,  1)
    end
  else
    if rot then
      srotation( dpsi, m, -1)
      xrotation(-dphi, m, -1)
      yrotation( dthe, m, -1)
    end
      translate({dx=dx*tdir,dy=dy*tdir,ds=-ds}, m, -1)
  end

  m:dump(elm, 'misalign:1')
end

function misalignexi (elm, m)
  local dx  , dy  , ds   = elm.dx     or 0, elm.dy   or 0, elm.ds   or 0
  local dthe, dphi, dpsi = elm.dtheta or 0, elm.dphi or 0, elm.dpsi or 0

  local trn = abs(dx  )+abs(dy  )+abs(ds  ) >= minlen
  local rot = abs(dthe)+abs(dphi)+abs(dpsi) >= minang

  if not (trn or rot) then return end

  m:dump(elm, 'misalignexi:0')

  local el, ang, tlt, sdir, tdir in m

  -- translation
  if trn then T:fill{dx, dy, ds} else T:zeros() end

  -- rotation
  if rot then R:rotzxy(-dphi, dthe, dpsi) end

  -- compute Rbar, Tbar
  _C.mad_mat_rtbar(Rb.data, Tb.data, abs(el), ang, tlt, rot and R.data or nil, T.data)

  -- misalignment at exit and local/global frames
  -- forward : x2  = Rb^-1*(x2'-Tb)
  -- backward: x2' = Rb*x2+Tb

  -- reuse patches without directions
  if sdir > 0 then
    if rot then
      local ax, ay, az = Rb:torotzxy()
      srotation(az, m, -1)
      xrotation(ax, m, -1)
      yrotation(ay, m, -1)
    end
      translate({dx=Tb[1]*tdir,dy=Tb[2]*tdir,ds= Tb[3]}, m, -1)
  else
      translate({dx=Tb[1]*tdir,dy=Tb[2]*tdir,ds=-Tb[3]}, m,  1)
    if rot then
      local ax, ay, az = Rb:torotzxy()
      yrotation(ay, m,  1)
      xrotation(ax, m,  1)
      srotation(az, m,  1)
    end
  end

  m:dump(elm, 'misalignexi:1')
end

-- THIN -----------------------------------------------------------------------o

function M.mult_kick (elm, m, lw) -- [KICKT]                                    checked
  if m.nmul == 0 then return end

  local el, tdir, beam, nmul, knl, ksl in m
  local wchg  = lw*tdir*beam.charge
  local _beta = 1/beam.beta
  local bend = abs(knl[1])+abs(ksl[1]) >= minstr

  m:dump(elm, 'mult_kick:0')

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local  wchg = beam and lw*tdir*beam.charge or wchg
    local _beta = beam and 1/beam.beta or _beta
    local bx,by = bxby(nmul, knl, ksl, x, y)

    m[i].px = px - wchg*(by - knl[1])
    m[i].py = py + wchg*(bx - ksl[1])

    -- dipole focusing and delta_p
    if bend then
      local dp = sqrt(1 + (2*_beta)*pt + pt^2) - 1
      m[i].px = m[i].px + (wchg*knl[1])*dp
      m[i].py = m[i].py + (wchg*ksl[1])*dp
      m[i].t  = t - wchg*(knl[1]*x - ksl[1]*y) * (_beta+pt)/(1+dp)

      if el ~= 0 then
        m[i].px = m[i].px - (knl[1]^2/el)*x
        m[i].py = m[i].py - (ksl[1]^2/el)*y
      end
    end
  end

  m:dump(elm, 'mult_kick:1')
end

-- DKD [INTER_STREX] ----------------------------------------------------------o

function M.strex_drift (elm, m, lw) -- [DRIFT]                                  checked
  if abs(m.el) < minlen then return end

  local el, eld, beam, T in m
  local l, ld = el*lw, (eld or el)*lw
  local _beta = 1/beam.beta

  m:dump(elm, 'strex_drift:0')

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beta = beam and 1/beam.beta or _beta
    local  l_pz = l/sqrt(1 + (2*_beta)*pt + pt^2 - px^2 - py^2)

    m[i].x = x + px*l_pz
    m[i].y = y + py*l_pz
    m[i].t = t - (_beta+pt)*l_pz + (1-T)*ld*_beta
  end

  m:dump(elm, 'strex_drift:1')
end

function M.strex_kick (elm, m, lw, no_k0l) -- [KICKEX]                          checked
  if m.nmul == 0 then return end

  local tdir, beam, nmul, knl, ksl in m
  local wchg = lw*tdir*beam.charge
  local dby  = no_k0l == true and -knl[1] or 0

  m:dump(elm, 'strex_kick:0')

  for i=1,m.npar do
    local x, px, y, py, beam in m[i]
    local wchg = beam and lw*tdir*beam.charge or wchg
    local bx,by = bxby(nmul, knl, ksl, x, y)

    m[i].px = px - wchg*(by+dby)
    m[i].py = py + wchg* bx
  end

  m:dump(elm, 'strex_kick:1')
end

M.strex_fringe = fnone -- TODO: see below

-- DKD [KICKERS] --------------------------------------------------------------o

function M.kicker_kick (elm, m, lw)
  local hk, vk, tdir, beam in m
  local wchg = lw*tdir*beam.charge

  m:dump(elm, 'kicker_kick:0')

  for i=1,m.npar do
    local px, py, beam in m[i]
    local wchg = beam and lw*tdir*beam.charge or wchg

    m[i].px = px + wchg*hk
    m[i].py = py + wchg*vk
  end

  m:dump(elm, 'kicker_kick:1')
end

-- DKD [INTER_TEAPOT, l ~= 0, angle ~= 0] -------------------------------------o

function M.curex_drift (elm, m, lw) -- [SPROT]                                  checked
  local el, eld, ang, rho, beam, T in m
  local ld, ang = (eld or el)*lw, ang*lw   -- A, R = ang, rho
  local _beta = 1/beam.beta
  local sa, ca, ta, sa2 = sin(ang), cos(ang), tan(ang), sin(ang/2)

  m:dump(elm, 'curex_drift:0')

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beta = beam and 1/beam.beta or _beta
    local    pz = sqrt(1 + (2*_beta)*pt + pt^2 - px^2 - py^2)
    local   _pz = 1/pz
    local   pxt = px*_pz
    local   ptt = (1 - ta*pxt)*ca
    local  _ptt = 1/ptt
    local   pst = (x+rho)*sa*_pz*_ptt

    m[i].x  = (x + rho*(2*sa2^2 + sa*pxt))*_ptt
    m[i].px = ca*px + sa*pz
    m[i].y  = y + pst*py
    m[i].t  = t - pst*(_beta+pt) + (1-T)*ld*_beta
  end

  m:dump(elm, 'curex_drift:1')
end

function M.curex_kick (elm, m, lw, no_k0l) -- [SKICK]                           checked
  local ang, rho, tdir, beam, nmul, knl, ksl in m
  local bdir = beam.charge*tdir
  local wchg = bdir*lw
  local dby  = no_k0l == true and -knl[1] or knl[1]-ang*bdir
  local eh   = 1/rho

  m:dump(elm, 'curex_kick:0')

  for i=1,m.npar do
    local x, px, y, py, beam in m[i]
    local wchg = beam and beam.charge*lw*tdir or wchg
    local bx, by = bxby(nmul, knl, ksl, x, y)

    -- TODO: should use TPSA in hbxby
    m[i].px = px - ((1+eh*x)*wchg)*(by+dby)
    m[i].py = py +           wchg * bx
  end

  m:dump(elm, 'curex_kick:1')
end

-- TKT [INTER_TEAPOT, angle ~= 0] ---------------------------------------------o

function M.sbend_thick (elm, m, lw) -- [SSEC] A=ang, R=rho, B0=1/R, BN(1)=k0    checked
  local el, eld, ang, rho, k0, beam, T in m
  local ld, ang, k0 = (eld or el)*lw, ang*lw, k0*m.edir
  local _beta, k0q = 1/beam.beta, k0*beam.charge
  local sa, ca = sin(ang), cos(ang)

  m:dump(elm, 'sbend_thick:0')

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beta = beam and 1/beam.beta or _beta
    local   k0q = beam and k0*beam.charge or k0q
    local  pw2 = 1 + (2*_beta)*pt + pt^2 - py^2
    local   pz = sqrt(pw2 - px^2)                                      -- PZ
    local  pzx = pz - k0q*(rho+x)
    local  npx =  ca*px + sa*pzx                                       -- XN(2)
    local  dpx = -sa*px + ca*pzx                                       -- DPX'
    local  pzs = sqrt(pw2 - npx^2)                                     -- PZS
    local  ptt = sqrt(pw2)                                             -- PT
    local _ptt = 1/ptt
    local  dxs = (ang + asin(px*_ptt) - asin(npx*_ptt))/k0q            -- XN(3)

    -- eq. 126 in Forest06
    m[i].x  = (pzs-dpx)/k0q - rho  -- could be numerically unstable    -- XN(1)
    m[i].px = npx                                                      -- XN(2)
    m[i].y  = y + dxs*py                                               -- XN(3)
    m[i].t  = t - dxs*(_beta+pt) + (1-T)*ld*_beta                      -- XN(6)
  end

  m:dump(elm, 'sbend_thick:1')
end

M.sbend_kick = \el,m,lw -> M.curex_kick(el,m,lw,true)

-- TKT [INTER_STREX] ----------------------------------------------------------o

function M.rbend_thick (elm, m, lw) -- [SPAR]                                   checked
  local el, eld, k0, knl, beam, T in m
  local l, ld, k0 = el*lw, eld*lw, k0*m.edir
  local _beta, _k0q, k0lq = 1/beam.beta, 1/k0*beam.charge, knl[1]*beam.charge

  m:dump(elm, 'rbend_thick:0')

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beta = beam and 1/beam.beta or _beta
    local _k0q  = beam and 1/(k0*beam.charge) or _k0q
    local  k0lq = beam and knl[1]*beam.charge or k0lq

    local  pw2 = 1 + (2*_beta)*pt + pt^2 - py^2
    local   pz = sqrt(pw2 - px^2)
    local  ptt = sqrt(pw2)
    local _ptt = 1/ptt
    local  npx = px - k0lq
    local  pzs = sqrt(pw2 - npx^2)
    local   nx = x + (pzs-pz)*_k0q
    local  pzt = (asin(px*_ptt) - asin(npx*_ptt))*_k0q

    -- eq. 129 in Forest06
    m[i].x  = nx
    m[i].px = npx
    m[i].y  = y + pzt*py
    m[i].t  = t - pzt*(_beta+pt) + (1-T)*ld*_beta
  end

  m:dump(elm, 'rbend_thick:1')
end

M.rbend_kick = \el,m,lw -> M.strex_kick(el,m,lw,true)

-- TKT [INTER_TKTF] -----------------------------------------------------------o

local function drift_adj (elm, m, l) -- [KICKPATH] drift adjustment             checked
  local ca, sa, beam, T in m
  local _beta = 1/beam.beta

  m:dump(elm, 'drift_adj:0')

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beta = beam and 1/beam.beta or _beta
    local l_pz = l/sqrt(1 + (2*_beta)*pt + pt^2 - px^2 - py^2)

    m[i].x = x + px*(l_pz-l)
    m[i].y = y + py*(l_pz-l)
    m[i].t = t - (_beta+pt)*l_pz + (1-T)*l*_beta
  end

  m:dump(elm, 'drift_adj:1')
end

-- h == 0

function M.quad_thick (elm, m, lw) -- [PUSHTKT7]                                checked
  local el, k1, edir, tdir, beam in m
  local l = el*lw
  local chg = beam.charge

  -- [GETMAT7, w ~= 0]
  local ws = k1*edir < 0 and -1 or 1
  local w  = sqrt(abs(k1))*tdir*ws
  local cx, sx = cos (w*l), sin (w*l)
  local cy, sy = cosh(w*l), sinh(w*l)
  local mx1, mx2 = sx/w, -sx*w
  local my1, my2 = sy/w,  sy*w

  m:dump(elm, 'quad_thick:0')

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local chg = beam and beam.charge or chg

    if ws ~= chg then -- swap x <-> y
      ws, cx, cy, mx1, mx2, my1, my2 = -ws, cy, cx, my1, my2, mx1, mx2
    end

    local nx  = x*cx  + px*mx1
    local npx = x*mx2 + px*cx
    local ny  = y*cy  + py*my1
    local npy = y*my2 + py*cy

    m[i].x  = nx
    m[i].px = npx
    m[i].y  = ny
    m[i].py = npy
  end

  m:dump(elm, 'quad_thick:1')
end

function M.quad_kick (elm, m, lw, ii) -- [KICKTKT7]                             checked
  local el, tdir, beam, nmul, knl, ksl in m
  local l = el*lw
  local bdir = beam.charge*tdir

  if ii >= 0 then drift_adj(elm, m, ii == 0 and l/2 or l) end

  m:dump(elm, 'quad_kick:0')

  for i=1,m.npar do
    local x, px, y, py, beam in m[i]
    local  bdir = beam and beam.charge*tdir or bdir
    local bx,by = bxby(nmul, knl, ksl, x, y)

    m[i].px = px - (l*bdir)*(by - knl[2]*x)
    m[i].py = py + (l*bdir)*(bx - knl[2]*y)
  end

  m:dump(elm, 'quad_kick:1')

  if ii <= 0 then drift_adj(elm, m, ii == 0 and l/2 or l) end
end

-- h == 0, skew (tilted by k1s)

function M.quad_sthick (elm, m, lw) -- [PUSHTKT7]                               checked
  local el, k1, ca, sa, edir, tdir, beam in m
  local l = el*lw
  local chg = beam.charge

  -- [GETMAT7, w ~= 0]
  local ws = k1*edir < 0 and -1 or 1
  local w  = sqrt(abs(k1))*tdir*ws
  local cx, sx = cos (w*l), sin (w*l)
  local cy, sy = cosh(w*l), sinh(w*l)
  local mx1, mx2 = sx/w, -sx*w
  local my1, my2 = sy/w,  sy*w

  m:dump(elm, 'quad_sthick:0')

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local chg = beam and beam.charge or chg

    if ws ~= chg then -- swap x <-> y
      ws, cx, cy, mx1, mx2, my1, my2 = -ws, cy, cx, my1, my2, mx1, mx2
    end

    local nx  = ca*x  + sa*y
    local npx = ca*px + sa*py
    local ny  = ca*y  - sa*x
    local npy = ca*py - sa*px

    x  = nx*cx  + npx*mx1
    px = nx*mx2 + npx*cx
    y  = ny*cy  + npy*my1
    py = ny*my2 + npy*cy

    m[i].x  = ca*x  - sa*y
    m[i].px = ca*px - sa*py
    m[i].y  = ca*y  + sa*x
    m[i].py = ca*py + sa*px
  end

  m:dump(elm, 'quad_sthick:1')
end

function M.quad_skick (elm, m, lw, ii) -- [KICKTKT7]                            checked
  local el, tdir, beam, nmul, knl, ksl in m
  local l = el*lw
  local bdir = beam.charge*tdir

  if ii >= 0 then drift_adj(elm, m, ii == 0 and l/2 or l) end

  m:dump(elm, 'quad_skick:0')

  for i=1,m.npar do
    local x, px, y, py, beam in m[i]
    local  bdir = beam and beam.charge*tdir or bdir
    local bx,by = bxby(nmul, knl, ksl, x, y)

    m[i].px = px - (l*bdir)*(by - (knl[2]*x - ksl[2]*y))
    m[i].py = py + (l*bdir)*(bx - (knl[2]*y + ksl[2]*x))
  end

  m:dump(elm, 'quad_skick:1')

  if ii <= 0 then drift_adj(elm, m, ii == 0 and l/2 or l) end
end

-- h ~= 0

function M.quad_hthick (elm, m, lw) -- [PUSHTKT7]                               unchecked
  local el, rho, k0, k1, edir, tdir, beam in m
  local l, h, c = el*lw, edir/rho, beam.charge

  -- [GETMAT7, w ~= 0]
  local kx, ky = k1+h*k0, k1
  local wxs = kx*edir < 0 and -c or c
  local wys = ky*edir < 0 and -c or c
  local wx  = sqrt(abs(kx))*tdir*wxs
  local wy  = sqrt(abs(ky))*tdir*wys
  local chg, cx, sx, cy, sy, mx12, mx21, mx13, my12, my21, mx33

  m:dump(elm, 'quad_hthick:0')

  for i=1,m.npar do
    local x, px, y, py, t, pt in m[i]
    local beam = m[i].beam or beam
    local h_b = h/beam.beta

    if chg ~= beam.charge then -- [GETMAT7, w ~= 0]
      chg = beam.charge
      wxs, wys = -wxs, -wys

      if wxs < 0
      then cx, sx = cosh(wx*l), sinh(wx*l)
      else cx, sx = cos (wx*l), sin (wx*l)
      end
      if wys < 0
      then cy, sy = cos (wy*l), sin (wy*l)
      else cy, sy = cosh(wy*l), sinh(wy*l)
      end

--    mx11, mx22, my11, my22 = cx, cx, cy, cy
      mx12, mx21, mx13 = sx/wx, -sx*wx*wxs, (1-cx  )/wx^2*wxs
      my12, my21, mx33 = sy/wy,  sy*wy*wys, (l-mx21)/wx^2*wxs
    end

--[[ PTC matrix form
    { cx            , sx/wx                , h*(1-cx)/wx2*ws*_beta     ,
     -sx*wx*ws      , cx                   , h*sx/wx                   ,
      h*sx/wx*_beta , h*(1-cx)/wx2*ws*_beta, h^2*(l-sx/wx)/wx2*ws*_beta }
    { cy            , sy/wy                , 0                         ,
      sy*wy*ws      , cy                   , 0                          }
--]]
    local nx  = x*cx         + px*mx12       + pt*(mx13*h_b)
    local npx = x*mx21       + px*cx         + pt*(mx12*h_b)
    local ny  = y*cy         + py*my12
    local npy = y*my21       + py*cy
    local nt  = x*(mx12*h_b) + px*(mx13*h_b) + pt*(mx33*h^2)

    m[i].x   = nx
    m[i].y   = ny
    m[i].px  = npx
    m[i].py  = npy
    m[i].t   = t - nt
  end

  m:dump(elm, 'quad_hthick:1')
end

function M.quad_hkick (elm, m, lw, ii) -- [KICKTKT7]                            unchecked
  local el, rho, edir, tdir, beam, nmul, knl, ksl in m
  local l, h = el*lw, edir/rho
  local _beta = 1/beam.beta
  local  bdir = beam.charge*tdir

  if ii >= 0 then drift_adj(elm, m, ii == 0 and l/2 or l) end

  m:dump(elm, 'quad_hkick:0')

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beam = beam and 1/beam.beta or _beta
    local  bdir = beam and beam.charge*tdir or bdir
    local    pz = sqrt(1 + (2*_beta)*pt + pt^2) - 1
    local bx,by = bxby(nmul, knl, ksl, x, y)

                                  -- PTC uses h here vvv instead of knl[1], TBC
    m[i].px = px + (l*bdir)*(h*(pz-pt*_beta) - (by - knl[1] - knl[2]*x))
    m[i].py = py + (l*bdir)*(                  (bx          - knl[2]*y))
    m[i].t  =  t - (l*h)*((_beta+pt)/(1+pz) - _beta)*x
  end

  m:dump(elm, 'quad_hkick:1')

  if ii <= 0 then drift_adj(elm, m, ii == 0 and l/2 or l) end
end

-- TKT [INTER_SOL5] -----------------------------------------------------------o

function M.solen_thick (elm, m, lw) -- [KICK_SOL]                              checked
  local el, ks, beam, T in m
  local l = el*lw
  local bsol = 0.5*ks*beam.charge
  local _beta = 1/beam.beta

  m:dump(elm, 'solen_thick:0')

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beta = beam and 1/beam.beta or _beta
    local  bsol = beam and 0.5*ks*beam.charge or bsol
    local    xp = px + bsol*y
    local    yp = py - bsol*x
    local  l_pz = l/sqrt(1 + (2*_beta)*pt + pt^2 - xp^2 - yp^2)
    local   ang = l_pz*bsol

    local ca, sa, sc = cos(ang), sin(ang), sinc(ang)

    local lsc = l_pz*sc
    local xt  = ca*x  + lsc*px
    local pxt = ca*px - lsc*x *bsol^2
    local yt  = ca*y  + lsc*py
    local pyt = ca*py - lsc*y *bsol^2

    m[i].x  = ca*xt  + sa*yt
    m[i].px = ca*pxt + sa*pyt
    m[i].y  = ca*yt  - sa*xt
    m[i].py = ca*pyt - sa*pxt
    m[i].t  = t - (_beta+pt)*l_pz + (1-T)*l*_beta
  end

  m:dump(elm, 'solen_thick:1')
end

M.solen_fringe = fnone -- TODO

-- rfcavity [INTER_CAV4] ------------------------------------------------------o

function M.rfcav_kick (elm, m, lw) -- [KICKCAV, FEVAL_CAVR?]
  local volt, freq, lag, tdir, beam in m
  local omega = freq*(twopi*1e6/clight)
  local phase = lag * twopi
  local _pc   = 1/beam.pc
  local chg   = beam.charge
  local vl    = lw*chg*tdir*volt*1e-3

--  print('vl=', vl*_pc, 'omega=', omega, 'phase=', phase, 'p0c=', beam.pc, 'yl=', el*lw)

  m:dump(elm, 'rfcav_kick:0')

  for i=1,m.npar do
    local t, pt, beam in m[i]
    local _pc = beam and 1/beam.charge      or _pc
    local  vl = beam and vl*chg*beam.charge or  vl
    local dpt = vl*_pc*sin(phase - omega*t)

--    print('pt=', m[i].pt, 'dpt=', dpt)

    m[i].pt = pt + dpt
  end

  m:dump(elm, 'rfcav_kick:1')
end

function M.rfcav_kickn (elm, m, lw) -- [KICKCAV, nmul ~= 0 or nbsl ~= 0]
  local volt, freq, lag, tdir, nbsl, nmul, knl, ksl, beam in m
  local omega = freq*(twopi/clight*1e6)
  local phase = lag * twopi
  local _pc   = 1/beam.pc
  local chg   = beam.charge
  local bdir  = lw*chg*tdir
  local vl    = bdir*volt*1e-3

  m:dump(elm, 'rfcav_kickn:0')

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local ph = phase - omega*t
    local sa, ca = sin(ph), cos(ph)

    local _pc, vl, bdir = _pc, vl, bdir
    if beam then
      _pc, vl, bdir = 1/beam.pc, vl*chg*beam.charge, bdir*chg*beam.charge
    end

    -- single mode (ko=1)
    local df, f, r2 = 0, 1, 1

    -- bessel modes
    if nbsl > 0 then
      for i=1,nbsl do
        r2 = -r2*omega^2/(4*(i+1)^2)
        df =  df + 2*r2*i
        r2 =  r2*(x^2+y^2)
        f  =  f + r2
      end

      local c1 = df*vl*_pc*ca/omega

      px = px - x*c1
      py = py - y*c1
    end

    -- kick
    pt = pt + f*vl*_pc*sa

    if nmul > 0 then
      local bx,by,byt = bxby(nmul, knl, ksl, x, y)

      px = px - bdir* by*_pc *ca
      py = py + bdir* bx*_pc *ca

      by = -knl[nmul]/nmul
      bx = -ksl[nmul]/nmul

      for i=nmul-1,1,-1 do
        byt = x*by - y*bx - knl[i]/i
        bx  = y*by + x*bx - ksl[i]/i
        by  = byt
      end
      byt = x*by - y*bx -- extra terms?
      bx  = y*by + x*bx
      by  = byt

      pt = pt + omega*bdir* by*_pc *sa
    end

    m[i].px = px
    m[i].py = py
    m[i].pt = pt
  end

  m:dump(elm, 'rfcav_kickn:1')
end

function M.rfcav_fringe (elm, m, lw_) -- [ADJUST_TIME_CAV4 only, no FRINGECAV]
  if lw_ == 0 then return end
  local lw = lw_ or 1

  local sdir in m

  m:dump(elm, 'rfcav_fringe:0')

  if sdir*lw == 1 then
-- print(lw == 1 and 'forward entry' or 'backward exit')
    -- TODO: FRINGECAV
    assert(m.Tbak == nil, "inconsistent totalpath when entering rfcavity")
    m.Tbak, m.T = m.T, 1
  end

  if lw == -1 and m.Tbak ~= m.T then
    local dt = (m.T-m.Tbak)*m.el / m.beam.beta
    for i=1,m.npar do
      m[i].t = m[i].t + dt
    end
--    print('rfcav-1: total path compensated')
  end

  if sdir*lw == -1 then
-- print(lw == -1 and 'forward exit' or 'backward entry')
    m.T, m.Tbak = m.Tbak, nil
    -- TODO: FRINGECAV
  end

  m:dump(elm, 'rfcav_fringe:1')
end

-------------------------------------------------------------------------------o
-------------------------------------------------------------------------------o

-- combined function magnets --------------------------------------------------o

-- TKT [INTER_TEAPOT] ---------------------------------------------------------o

function M.combi_thick (elm, m, l) -- [??]
 error("NYI")
  local k0, k1, l, angle in elm
  l, angle = l*lw, angle*lw
  if abs(k0*l-angle) < minstr and abs(k1*l) < minstr then
    return M.sbend_thick(elm, m, lw)
  end

  m:dump(elm, 'combi_thick:0')

  local _el   = 1/elm.l
  local _beta = 1/m.beam.beta
  local l_bet2_gam2 = l/(m.beam.gamma^2-1)

  local angle = elm.angle
  local lw    = l*_el
  local h     = lw*angle
  local hbar  = h*_beta

  local knl, bdir in m
  local k0, k1 = bdir*knl[1]*_el, bdir*knl[2]*_el
  local hk0pk1 = h*k0+k1
  local wx2, wy2 = abs(hk0pk1), abs(k1)
  local wx , wy  = sqrt(wx2), sqrt(wy2)

  local cx, sx, cy, sy
  if hk0pk1 < 0
  then cx, sx = cosh(wx*l), sinh(wx*l)/wx -- check wx == 0
  else cx, sx = cos (wx*l), sin (wx*l)/wx -- check wx == 0
  end
  if k1 < 0
  then cy, sy = cosh(wy*l), sinh(wy*l)/wy -- check wy == 0
  else cy, sy = cos (wy*l), sin (wy*l)/wy -- check wy == 0
  end

--  local npos in m
--  drift_adj(elm, m, l/2)

  local x, px, y, py, t, pt in m
  local m16, m56 = (1-cx)/wx2, hbar^2*(l-sx)/wx2

  m.x  =      cx*x + sx*px + hbar*m16*pt + (h-k0)*m16
  m.px = -wx2*sx*x + cx*px + hbar*sx*pt  + (h-k0)*sx
  m.y  =      cy*y + sy*py
  m.py =  wy2*sy*y + cy*py
  m.t  = t - hbar*(sx*x+m16*px) + (l_bet2_gam2-m56)*pt

--  drift_adj(elm, m, l/2)

  m:dump(elm, 'combi_thick:1')
end

function M.combi_kick (elm, m, l) -- [??]
  error("NYI")
  m:dump(elm, 'combi_kick:0')
  m:dump(elm, 'combi_kick:1')
end

M.combi_fringe = fnone

-- fringes --------------------------------------------------------------------o

 -- forward declarations
local sbend_face, sbend_wedge, sbend_fringe, mad8_wedge, mult_fringe, stra_fringe

function M.strex_fringe (elm, m, lw)  -- [FRINGE_STREX]
  error("NYI")
  if lw_ == 0 then return end
  local lw = lw_ or 1

  if m.nmul == 0 then return end -- switched off

  m:dump(elm, 'strex_fringe:0')

  local sdir, tdir in m

  if sdir*lw == 1 then
-- print(lw == 1 and 'forward entry' or 'backward exit')
    local e, h = m.e1, (elm.h1 or 0)*tdir
      yrotation   ( e, m,  1)
      sbend_face  ( h, m,  1)
    if not elm.kill_ent_fringe then
      local fh = (elm.hgap or 0)*(elm.fint or 0.5)*sdir
      sbend_fringe(fh, m,  1)
    end
      mult_fringe ( e, m,  1)
      stra_fringe (-e, m,  1)
  else
-- print(lw == -1 and 'forward exit' or 'backward entry')
    local e, h = m.e2, (elm.h2 or 0)*tdir
      stra_fringe (-e, m, -1)
      mult_fringe ( e, m, -1)
    if not elm.kill_exi_fringe then
      local fh = (elm.hgap or 0)*(elm.fintx or elm.fint or 0.5)*sdir
      sbend_fringe(fh, m, -1)
    end
      sbend_face  ( h, m, -1)
      yrotation   (-e, m, -1)
  end

  m:dump(elm, 'strex_fringe:1')
end

M.strex_fringe = fnone -- for now...

function M.curex_fringe (elm, m, lw_) -- [FRINGE_TEAPOT]
  if lw_ == 0 then return end
  local lw = lw_ or 1

  if m.nmul == 0  then return end -- switched off

  m:dump(elm, 'curex_fringe:0')

  local sdir, tdir in m

  if sdir*lw == 1 then
-- print(lw == 1 and 'forward entry' or 'backward exit')
    local e, h = m.e1, (elm.h1 or 0)*tdir
      yrotation   ( e, m,  1)
      sbend_face  ( h, m,  1)
    if not elm.kill_ent_fringe then
      local fh = (elm.hgap or 0)*(elm.fint or 0.5)*sdir
      sbend_fringe(fh, m,  1)
    end
      mad8_wedge  ( e, m,  1)
      sbend_wedge (-e, m,  1)
  else
-- print(lw == -1 and 'forward exit' or 'backward entry')
    local e, h = m.e2, (elm.h2 or 0)*tdir
      sbend_wedge (-e, m, -1)
      mad8_wedge  ( e, m, -1)
    if not elm.kill_exi_fringe then
      local fh = (elm.hgap or 0)*(elm.fintx or elm.fint or 0.5)*sdir
      sbend_fringe(fh, m, -1)
    end
      sbend_face  ( h, m, -1)
      yrotation   (-e, m, -1)
  end

  m:dump(elm, 'curex_fringe:1')
end

function M.dipeg_fringe (elm, m, lw_) -- [MADX dipedge]                         unchecked
  if lw_ == 0  or abs(m.k0) < minstr then return end
  local lw = lw_ or 1

  if m.nmul == 0 then return end -- switched off

  local sdir, edir, k0, beam in m
  local corr, e = 0

  if sdir*lw == 1 then
    e = m.e1
    if not elm.kill_ent_fringe then
      corr = k0^2*(elm.hgap or 0)*(elm.fint or 0.5)
    end
  else
    e = m.e2
    if not elm.kill_exi_fringe then
      corr = k0^2*(elm.hgap or 0)*(elm.fintx or elm.fint or 0.5)
    end
  end

  if e == 0 and corr == 0 then return end

  m:dump(elm, 'dipeg_fringe:0')

  local chg = beam.charge
  local k0  = k0*edir
  local r21 = k0*tan(e)
  local r43 = corr == 0 and -r21 or -k0 * tan(e - corr/cos(e)*(1+sin(e)^2))

  for i=1,m.npar do
    local x, px, y, py, beam in m[i]
    local chg = beam and beam.charge or chg

    m[i].px = px + chg*r21*x
    m[i].py = py + chg*r43*y
  end

  m:dump(elm, 'dipeg_fringe:1')
end

-- fringes helpers ------------------------------------------------------------o

function sbend_face (h, m, lw) -- [NEWFACE]
  local k0, edir, beam in m
  local k0 = k0*h/2*edir

  if abs(k0) < minstr then return end

  m:dump(h, 'sbend_face:0')

  local _beta = 1/beam.beta
  local chg = beam.charge

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beta = beam and 1/beam.beta or _beta
    local chg   = beam and beam.charge or chg

    if lw == 1 then -- to insure reversal symmetry ; horizontal wedge (only dir)
      px = px + chg*k0*x^2
    end

    local dpp      =  1 + 2*pt*_beta + pt^2
    local _pt2     =  1/(dpp - px^2)
    local xi       =  2*k0*lw*sqrt(dpp)*_pt2
    local dxi_px   =  2*px*xi          *_pt2
    local dxi_ddel = -2   *xi*(1+pt)   *_pt2

    x  = x / (1-dxi_px*y^2)
    px = px - xi*y^2
    py = py - 2*xi*x*y
    t  = t  - dxi_ddel*x*y^2

    if lw == -1 then -- to insure reversal symmetry; horizontal wedge (only dir)
      px = px - chg*k0*x^2
    end

    m[i].x  = x
    m[i].px = px
    m[i].py = py
    m[i].t  = t
  end

  m:dump(h, 'sbend_face:1')
end

function mad8_wedge (e, m, lw) -- [FRINGE_TEAPOT]
  local k1, edir, beam in m
  if abs(k1*e) < minstr then return end

  m:dump(e, 'mad8_wedge:0')

  local k1e = k1*e * edir*beam.charge
  for i=1,m.npar do
    local x, px, y, py in m[i]
    m[i].px = px + k1e*(x^2-y^2)
    m[i].py = py - k1e*(2*x*y)
  end

  m:dump(e, 'mad8_wedge:1')
end

function sbend_wedge (e, m, lw) -- [WEDGE]
  if abs(e) < minang then return end

  local k0, edir, beam in m
  if abs(k0) < minstr then return yrotation(e,m,lw) end

  m:dump(e, 'sbend_wedge:0')

  local _beta = 1/beam.beta
  local b1 = k0*edir*beam.charge
  local sa, ca, sa2 = sin(e), cos(e), sin(2*e)

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beta = beam and 1/beam.beta or _beta

    local pzy = 1 + 2*_beta*pt + pt^2 - py^2
    local pz  = sqrt(pzy - px^2)
    local pxt = px*ca + (pz - b1*x)*sa
    local pzs = sqrt(pzy - pxt^2)
    local _zy = 1/sqrt(pzy)
    local yt  = (e + asin(px*_zy) - asin(pxt*_zy)) / b1

    m[i].x  = x*ca + x*(px*sa2 + sa^2*(2*pz - b1*x)) / (pzs + pz*ca - px*sa)
    m[i].px = pxt
    m[i].y  = y + py * yt
    m[i].t  = t - yt*(_beta + pt)
  end

  m:dump(e, 'sbend_wedge:1')
end

function sbend_fringe (fh, m, lw) -- [FRINGE_DIPOLE]
  local k0, edir, beam in m
  if abs(fh)+abs(k0) < minstr then return end

  local  fsad = abs(fh) ~= 0 and 1/(2*36*fh) or 0
  local  b0   = edir*beam.charge*k0*lw
  local _beta = 1/beam.beta

  m:dump(fh, 'sbend_fringe:0')

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beta = beam and 1/beam.beta or _beta
    local b0 = beam and edir*beam.charge*k0*lw or b0

    local dpp = 1 + 2*_beta*pt + pt^2
    local  pz = sqrt(dpp - px^2 - py^2)
    local _pz = 1/pz
    local relp = 1/sqrt(dpp)
    local tfac = -(_beta + pt)

    local c2 = b0*fh*2
    local c3 = b0^2*fsad*relp

    local xp,  yp  = px/pz, py/pz
    local xyp, yp2 = xp*yp, 1+yp^2
    local xp2,_yp2 = xp^2 , 1/yp2

    -- many of the terms below are very small, i.e. have negligible effect...

    local fi0 = atan((xp*_yp2)) - c2*(1 + xp2*(1+yp2))*pz
    local co2 = b0/cos(fi0)^2
    local co1 = co2/(1 + (xp*_yp2)^2)*_yp2
    local co3 = co2*c2

    local fi1 =    co1          - co3*2*xp*(1+yp2)*pz
    local fi2 = -2*co1*xyp*_yp2 - co3*2*xp*xyp    *pz
    local fi3 =                 - co3*(1 + xp2*(1+yp2))

    local kx = fi1*(1+xp2)*_pz   + fi2*xyp*_pz       - fi3*xp
    local ky = fi1*xyp*_pz       + fi2*yp2*_pz       - fi3*yp
    local kz = fi1*tfac*xp*_pz^2 + fi2*tfac*yp*_pz^2 - fi3*tfac*_pz

    y = 2*y / (1 + sqrt(1-2*ky*y))
    x = x + 0.5*kx*y^2
    t = t + 0.5*kz*y^2
    py = py - b0*tan(fi0)*y

    -- soft edge (negligible?)
    py = py - 4*c3*y^3
    t  = t  +   c3*y^4*relp^2*tfac

    m[i].x  = x
    m[i].y  = y
    m[i].py = py
    m[i].t  = t
  end

  m:dump(fh, 'sbend_fringe:1')
end

!! --- TODO -------------------------------------------------------------------o

function mult_fringe (elm, m) -- [??]
  error("NYI")
  local x, px, y, py, bdir, nmul, knl, ksl in m
  local _beta = 1/m.beam.beta
  local _l = 1/elm.l

  m:dump(elm, 'mult_fringe:0')

  local rx, ix, fx, fy, fxx, fxy, fyx, fyy = 1, 0, 0, 0, 0, 0, 0, 0

	for i=1, nmul do
	  local drx, dix = rx, ix
    rx  = drx*x - dix*y
    ix  = drx*y + dix*x

    local ni, nf = -bdir/(4*(i+1)), i+2/i
    local lkn, lks = knl[i]*_l, ksl[i]*_l

    local u   =  ni*(lkn*rx  - lks*ix )
    local v   =  ni*(lkn*ix  + lks*rx )
    local du  =  ni*(lkn*drx - lks*dix)
    local dv  =  ni*(lkn*dix + lks*drx)
	  local dux =   i*du
    local dvx =   i*dv
    local duy =  -i*dv
    local dvy =   i*du

    fx  = fx  +   u*x + nf*       v*y
    fy  = fy  +   u*y - nf*       v*x
    fxx = fxx + dux*x + nf*     dvx*y + u
    fyy = fyy + duy*y - nf*     dvy*x + u
    fxy = fxy + duy*x + nf*(v + dvy*y)
    fyx = fyx + dux*y - nf*(v - dvx*x)
	end

  local _pz = 1/sqrt(1 + 2*pt*_beta + pt^2)
  local a = 1 - fxx*_pz
  local d = 1 - fyy*_pz
  local b =   - fyx*_pz
  local c =   - fxy*_pz
  local _det = 1/(a*d - b*c)

  m.x  = x - fx*_pz
  m.y  = y - fy*_pz
  m.px = (d*px - b*py)*_det
  m.py = (a*py - c*px)*_det
  m.t  = t + (_beta+pt)*(m.px*fx + m.py*fy)*_pz^3

  m:dump(elm, 'mult_fringe:1')
end

function stra_fringe (elm, m) -- [??]
  error("NYI")
-- Lee-Whiting formula, E. Forest ch 13.2.3, eq 13.33
	local x, px, y, py, t, pt, T, bdir in m
  local k0   = elm.k0 or 0
  local _beta = 1/m.beam.beta

  m:dump(elm, 'stra_fringe:0')

-- soft edge
  local fint = elm.fint or 0  -- fringe field integral at entrance and exit of the bend
  local hgap = elm.hgap or 0  -- half gap of the magnet

  local _pz  = 1/sqrt(1 + 2*_beta*pt + pt^2 )
  local time_fac = (_beta + pt)*_pz

  local a2, b2 = elm.ksl[2]/elm.l or 0, elm.knl[2]/elm.l or 0
  local b  = sqrt(b2^2 + a2^2)

  local f1 = -bdir*fint*abs(fint)*b*_pz/24.0
  local f2 =  hgap*b*_pz

  local ang=-atan2(a2,b2)/2

  srotation(-ang or 0, m)

  m.t = t - time_fac*(f1*x + f2*(1+f1/2)*px*_pz*exp(-f1))*px*_pz
          + time_fac*(f1*y + f2*(1-f1/2)*py*_pz*exp( f1))*py*_pz

  m.x = x*exp( f1) + px*f2*_pz
  m.y = y*exp(-f1) - py*f2*_pz

  m.px = px*exp(-f1)
  m.py = py*exp( f1)

  srotation(-ang or 0, m)

  m:dump(elm, 'stra_fringe:1')
end

-- end ------------------------------------------------------------------------o
return { dynmap = M }
