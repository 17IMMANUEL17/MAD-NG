--[=[
 o-----------------------------------------------------------------------------o
 |
 | Dynamic 6D maps
 |
 | Methodical Accelerator Design - Copyright (c) 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: I. Shreyber, irina.tecker at cern.ch
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide a catalog of dynamical 6D maps (i.e. track)
    maps must have the following calling convention:
      dynmap(elm, map, length_weight)
    (see the symplectic integrators)
  - TODO: list the expected fields for elm and map

 o-----------------------------------------------------------------------------o
]=]

local M = {}

--[=[
Notes about directions and quantities:
  element direction   edir: affects curvatures (edir = seq.dir).
  track direction (s) sdir: affects lengths    (sdir = cmd.dir).
  time direction  (t) tdir: affects angles     (tdir = edir x sdir).
  beam direction      bdir: affects strengths  (bdir = edir x sdir x chg).
--]=]

--[=[
Notes about PTC variables vs MAD:
  DIR  : tracking direction        = sdir
  B    : relativistic beta0        = beta
  L    : thick weighted length     = lw*el
  YL   : kick  weighted length     = lw*el
  LD   : thick weighted arc length = lw*(eld or el)
  B0   : curvature = angle/LD      = eh
  BN(1): dip  normal strength      = k0
  AN(1): dip  skew   strength      = k0s
  BN(2): quad normal strength      = k1
  AN(2): quad skew   strength      = k1s
  BN(3): sext normal strength      = k2
  AN(3): sext skew   strength      = k2s
  etc...
--]=]

--[=[
Notes and questions:
  Is (_beta+pt) in t eq. shouldn't be sqrt((_beta+pt)^2 - (_beta*_gamma)^2) ??
  is it a 1st order approximation?
--]=]

-- locals ---------------------------------------------------------------------o

local vector, matrix                                             in MAD
local is_nil, is_number, is_damap                                in MAD.typeid
local minlen, minang, minstr, clight, pi, twopi                  in MAD.constant
local printf                                                     in MAD.utility
local tobit, btst, bor                                           in MAD.operator

local abs, sqrt, exp, sin, cos, tan, asin, acos, atan, atan2,
      sinh, cosh, sinc, sinhc                                    in MAD.gmath

local min, max in math
local assert = assert

local    pi_clight =    pi/clight
local twopi_clight = twopi/clight

-- field mutipoles ------------------------------------------------------------o

local function bxby (nmul, knl, ksl, x, y)
  local bx, by, byt = ksl[nmul], knl[nmul]

  for i=nmul-1,1,-1 do
    byt = by*x - bx*y + knl[i]
    bx  = by*y + bx*x + ksl[i]
    by  = byt
  end

  return bx, by
end

local function bxbyh (nmul, knl, ksl, x, y, h) -- [GETMAGNETIC] TODO: useful?
  error("NYI")
  local bx, by, byt = ksl[nmul], knl[nmul]

  for i=nmul-1,1,-1 do
    byt = by*x - bx*y + knl[i]
    bx  = by*y + bx*x + ksl[i]
    by  = byt
  end

  return bx, by
end

-- patches --------------------------------------------------------------------o

-- X-rotation

local function xrotation (elm, m, lw_)  -- Rx(ax) [ROT_YZ]                   -- checked
  local ax = is_number(elm) and elm or elm.angle*m.tdir
  if abs(ax) < minang then return end

  m:mdump(elm, 'xrotation:0')

  local ax = ax*(lw_ or 1)
  local sa, ca, ta = sin(ax), cos(ax), tan(ax)
  local _beta = 1/m.beam.beta

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beta = beam and 1/beam.beta or _beta
    local    pz = sqrt(1 + (2*_beta)*pt + pt^2 - px^2 - py^2)
    local   _pz = 1/pz
    local   ptt = 1 - ta*py*_pz
    local  _ptt = y/ptt
    local  _pzt = ta*_pz*_ptt

    -- eq. 127 in Forest06
    m[i].y  = _ptt/ca
    m[i].py = ca*py + sa*pz
    m[i].x  = x + _pzt*px
    m[i].t  = t - _pzt*(_beta+pt)
  end

  m:mdump(elm, 'xrotation:1')
end

M.xrotation = xrotation

-- Y-rotation

local function yrotation (elm, m, lw_)  -- Ry(ay) [ROT_XZ]                   -- checked
  local ay = is_number(elm) and elm or elm.angle*m.tdir
  if abs(ay) < minang then return end

  m:mdump(elm, 'yrotation:0')

  local ay = ay*(lw_ or 1)
  local sa, ca, ta = sin(ay), cos(ay), tan(ay)
  local _beta = 1/m.beam.beta

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beta = beam and 1/beam.beta or _beta
    local    pz = sqrt(1 + (2*_beta)*pt + pt^2 - px^2 - py^2)
    local   _pz = 1/pz
    local   ptt = 1 - ta*px*_pz
    local  _ptt = x/ptt
    local  _pzt = ta*_pz*_ptt

    -- eq. 127 in Forest06
    m[i].x  = _ptt/ca
    m[i].px = ca*px + sa*pz
    m[i].y  = y + _pzt*py
    m[i].t  = t - _pzt*(_beta+pt)
  end

  m:mdump(elm, 'yrotation:1')
end

M.yrotation = yrotation

-- S-rotation

local function srotation (elm, m, lw_)  -- Rz(az) [ROT_XY]                   -- checked
  local az = is_number(elm) and elm or elm.angle*m.tdir
  if abs(az) < minang then return end

  m:mdump(elm, 'srotation:0')

  local az = az*(lw_ or 1)
  local sa, ca = sin(az), cos(az)

  for i=1,m.npar do
    local x, px, y, py in m[i]
    local nx  = ca*x  + sa*y
    local npx = ca*px + sa*py

    m[i].y    = ca*y  - sa*x
    m[i].py   = ca*py - sa*px
    m[i].x    = nx
    m[i].px   = npx
  end

  m:mdump(elm, 'srotation:1')
end

M.srotation = srotation

-- Translation

local function translate (elm, m, lw_) -- [TRANS]                            -- unchecked
  local dx, dy, ds = elm.dx or 0, elm.dy or 0, elm.ds or 0
  if abs(dx)+abs(dy)+abs(ds) < minlen then return end

  m:mdump(elm, 'translate:0')

  local tdir in m
  local lw = lw_ or 1
  local dx, dy = dx*lw*tdir, dy*lw*tdir

  if abs(ds) < minlen then
    for i=1,m.npar do
      local x, y in m[i]
      m[i].x = x - dx
      m[i].y = y - dy
    end
    return
  end

  -- ds is treated as a drift without correction for the time of flight
  local l = ds*lw*m.sdir
  local _beta = m.beam.beta
  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beta = beam and 1/beam.beta or _beta
    local l_pz = l/sqrt(1 + (2*_beta)*pt + pt^2 - px^2 - py^2)
    local   dt = l_pz*(_beta+pt)

    m[i].x = x + px*l_pz - dx
    m[i].y = y + py*l_pz - dy
    m[i].t = t - dt
  end

  m:mdump(elm, 'translate:1')
end

M.translate = translate

-- Changeref (generic patch, lw_>0: RT, lw_<0: TR)

function M.changeref (elm, m, lw_)                                           -- unchecked
  local lw = lw_ or 1
  local dx  , dy  , ds   = elm.dx     or 0, elm.dy   or 0, elm.ds   or 0
  local dthe, dphi, dpsi = elm.dtheta or 0, elm.dphi or 0, elm.dpsi or 0

  local trn = abs(dx  )+abs(dy  )+abs(ds  ) >= minlen
  local rot = abs(dthe)+abs(dphi)+abs(dpsi) >= minang

  if not (trn or rot) then return end

  m:mdump(elm, 'changeref:0')

  -- forward : x1' = R*x1+T
  -- backward: x1  = R^-1*(x1'-T)

  if lw > 0 then
      translate({dx=dx,dy=dy,ds=ds}, m, 1)
    if rot then
      yrotation({angle= dthe}, m, 1)
      xrotation({angle=-dphi}, m, 1)
      srotation({angle= dpsi}, m, 1)
    end
  else
    if rot then
      srotation({angle= dpsi}, m, -1)
      xrotation({angle=-dphi}, m, -1)
      yrotation({angle= dthe}, m, -1)
    end
      translate({dx=dx,dy=dy,ds=ds}, m, -1)
  end

  m:mdump(elm, 'changeref:1')
end

-- Changedir (reverse mflow t-direction)

function M.changedir (elm_, m, lw_)                                          -- unchecked
  m:mdump(elm, 'changedir:0')

  m.edir = -m.edir
  m.tdir = -m.tdir

  m:mdump(elm, 'changedir:1')
end

-- Changenrj (change particles energy)

function M.changenrj (elm, m, lw_)  -- (option to reset pt?)                 -- unchecked
  local dnrj in elm
  if dnrj == 0 then return end

  m:mdump(elm, 'changenrj:0')

  local tdir, beam in m
  beam.energy = beam.energy + dnrj*tdir

  for i=1,m.npar do
    beam = m[i].beam
    if beam then
      beam.energy = beam.energy + dnrj*tdir
    end
  end

  m:mdump(elm, 'changenrj:1')
end

-- misalignments --------------------------------------------------------------o

local T  = vector(3) -- misalignment translation
local R  = matrix(3) -- misalignment rotation
local Tb = vector(3) -- misalignment translation at exit (Tbar)
local Rb = matrix(3) -- misalignment rotation    at exit (Rbar)

local misalignexi -- forward declaration

-- Misalign (lw_>0: entry, lw_<0: exit)

local misalignexi

function M.misalign (elm, m, lw_)                                            -- unchecked
  if (lw_ or 1) < 0 then return misalignexi(elm, m) end

  local dx  , dy  , ds   = elm.dx     or 0, elm.dy   or 0, elm.ds   or 0
  local dthe, dphi, dpsi = elm.dtheta or 0, elm.dphi or 0, elm.dpsi or 0

  local trn = abs(dx  )+abs(dy  )+abs(ds  ) >= minlen
  local rot = abs(dthe)+abs(dphi)+abs(dpsi) >= minang

  if not (trn or rot) then return end

  m:mdump(elm, 'misalign:0')

  local sdir, tdir in m

  -- misalignment at entry and local/global frames
  -- forward : x1' = R*x1+T
  -- backward: x1  = R^-1*(x1'-T)

  -- reuse patches without directions
  if sdir > 0 then
      translate({dx=dx*tdir,dy=dy*tdir,ds= ds}, m,  1)
    if rot then
      yrotation( dthe, m,  1)
      xrotation(-dphi, m,  1)
      srotation( dpsi, m,  1)
    end
  else
    if rot then
      srotation( dpsi, m, -1)
      xrotation(-dphi, m, -1)
      yrotation( dthe, m, -1)
    end
      translate({dx=dx*tdir,dy=dy*tdir,ds=-ds}, m, -1)
  end

  m:mdump(elm, 'misalign:1')
end

function misalignexi (elm, m, lw_)                                                -- unchecked
  local dx  , dy  , ds   = elm.dx     or 0, elm.dy   or 0, elm.ds   or 0
  local dthe, dphi, dpsi = elm.dtheta or 0, elm.dphi or 0, elm.dpsi or 0

  local trn = abs(dx  )+abs(dy  )+abs(ds  ) >= minlen
  local rot = abs(dthe)+abs(dphi)+abs(dpsi) >= minang

  if not (trn or rot) then return end

  m:mdump(elm, 'misalignexi:0')

  local el, eh, sdir, tdir in m
  local ang, tlt = elm.angle*tdir, elm.tilt*tdir

  -- translation
  if trn then T:fill{dx, dy, ds} else T:zeros() end

  -- rotation
  if rot then R:rotzxy(-dphi, dthe, dpsi) end

  -- compute Rbar, Tbar
  _C.mad_mat_rtbar(Rb.data, Tb.data, abs(el), ang, tlt, rot and R.data or nil, T.data)

  -- misalignment at exit and local/global frames
  -- forward : x2  = Rb^-1*(x2'-Tb)
  -- backward: x2' = Rb*x2+Tb

  -- reuse patches without directions
  if sdir > 0 then
    if rot then
      local ax, ay, az = Rb:torotzxy()
      srotation(az, m, -1)
      xrotation(ax, m, -1)
      yrotation(ay, m, -1)
    end
      translate({dx=Tb[1]*tdir,dy=Tb[2]*tdir,ds= Tb[3]}, m, -1)
  else
      translate({dx=Tb[1]*tdir,dy=Tb[2]*tdir,ds=-Tb[3]}, m,  1)
    if rot then
      local ax, ay, az = Rb:torotzxy()
      yrotation(ay, m,  1)
      xrotation(ax, m,  1)
      srotation(az, m,  1)
    end
  end

  m:mdump(elm, 'misalignexi:1')
end

-- [INTER_STREX, INTER_TEAPOT, H3 adjustment] ---------------------------------o

local function drift_adj (elm, m, l) -- [KICKPATH] drift adjustment          -- checked

  m:mdump(elm, 'drift_adj:0')

  local T in m
  local beta = m.beam.beta

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local beta = beam and beam.beta or beta
    local l_pz = l/sqrt(1 + 2*pt/beta + pt^2 - px^2 - py^2)
    local   dt = l_pz*(1/beta+pt)

    m[i].x = x + px*(l_pz-l)
    m[i].y = y + py*(l_pz-l)
    m[i].t = t - dt + (1-T)*l/beta
  end

  m:mdump(elm, 'drift_adj:1')
end

-- DKD [INTER_STREX] ----------------------------------------------------------o

function M.strex_drift (elm, m, lw) -- [DRIFT]                               -- checked
  if abs(m.el*lw) < minlen then return end

  m:mdump(elm, 'strex_drift:0')

  local el, eld, T in m
  local l, ld = el*lw, (eld or el)*lw
  local beta = m.beam.beta

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local beta = beam and beam.beta or beta
    local l_pz = l/sqrt(1 + 2*pt/beta + pt^2 - px^2 - py^2)
    local   dt = l_pz*(1/beta+pt)

    m[i].x = x + px*l_pz
    m[i].y = y + py*l_pz
    m[i].t = t - dt + (1-T)*ld/beta
  end

  m:mdump(elm, 'strex_drift:1')
end

function M.strex_kick (elm, m, lw, no_k0l) -- [KICKEX]                       -- checked
  if m.nmul == 0 then return end

  m:mdump(elm, 'strex_kick:0')

  local tdir, nmul, knl, ksl, beam in m
  local wchg = lw*tdir*beam.charge
  local dby  = no_k0l == true and knl[1] or 0

  for i=1,m.npar do
    local x, px, y, py, beam in m[i]
    local  wchg = beam and lw*tdir*beam.charge or wchg
    local bx,by = bxby(nmul, knl, ksl, x, y)

    m[i].px = px - wchg*(by-dby)
    m[i].py = py + wchg* bx
  end

  m:mdump(elm, 'strex_kick:1')
end

function M.strex_kickh (elm, m, lw) -- [KICKT]                               -- checked
  if m.nmul == 0 then return end

  m:mdump(elm, 'strex_kickh:0')

  local el, tdir, nmul, knl, ksl, beam in m
  local  wchg = lw*tdir*beam.charge -- with lw == 1
  local _beta = 1/beam.beta

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local  wchg = beam and lw*tdir*beam.charge or wchg
    local _beta = beam and 1/beam.beta or _beta
    local    pz = sqrt(1 + (2*_beta)*pt + pt^2)
    local bx,by = bxby(nmul, knl, ksl, x, y)

    m[i].px = px - wchg*(by - knl[1]*pz)
    m[i].py = py + wchg*(bx - ksl[1]*pz)
    m[i].t  = t  - wchg*(knl[1]*x - ksl[1]*y)*(_beta+pt)/pz

    if el ~= 0 then
      m[i].px = m[i].px - (knl[1]^2/el)*x
      m[i].py = m[i].py - (ksl[1]^2/el)*y
    end
  end

  m:mdump(elm, 'strex_kickh:1')
end

-- DKD [INTER_TEAPOT] ---------------------------------------------------------o

function M.curex_drift (elm, m, lw) -- [SPROT]                               -- checked

  m:mdump(elm, 'curex_drift:0')

  local el, eld, eh, T in m
  local ld, ang, rho = (eld or el)*lw, eh*el*lw, 1/eh -- R=rho, A=ang
  local beta = m.beam.beta
  local sa, ca, ta, sa2 = sin(ang), cos(ang), tan(ang), sin(ang/2)

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local beta = beam and beam.beta or beta
    local   pz = sqrt(1 + 2*pt/beta + pt^2 - px^2 - py^2)
    local  _pz = 1/pz
    local  pxt = px*_pz
    local  ptt = ca - sa*pxt
    local _ptt = 1/ptt
    local  pst = (x+rho)*sa*_pz*_ptt
    local   dt = pst*(1/beta+pt)

    m[i].x  = (x + rho*(2*sa2^2 + sa*pxt))*_ptt
    m[i].px = ca*px + sa*pz
    m[i].y  = y + pst*py
    m[i].t  = t - dt + (1-T)*ld/beta
  end

  m:mdump(elm, 'curex_drift:1')
end

function M.curex_kick (elm, m, lw, no_k0l) -- [SKICK]                        -- checked

  m:mdump(elm, 'curex_kick:0')

  local el, eh, tdir, nmul, knl, ksl, beam in m
  local bdir = beam.charge*tdir
  local wchg = bdir*lw
  local dby  = no_k0l == true and knl[1] or eh*el*tdir-knl[1]

  for i=1,m.npar do
    local x, px, y, py, beam in m[i]
    local  wchg = beam and lw*tdir*beam.charge or wchg
    local bx,by = bxby(nmul, knl, ksl, x, y)
    local     r = 1+eh*x

    m[i].px = px - wchg*(by-dby)*r
    m[i].py = py + wchg* bx     *r
  end

  m:mdump(elm, 'curex_kick:1')
end

-- TKT [INTER_TEAPOT] ---------------------------------------------------------o

function M.sbend_thick (elm, m, lw) -- [SSEC]                                 -- checked

  m:mdump(elm, 'sbend_thick:0')

  local el, eld, eh, knl, beam, T in m
  local ld, ang, rho, k0 = (eld or el)*lw, eh*el*lw, 1/eh, knl[1]/abs(el)
  local beta, k0q = beam.beta, k0*beam.charge
  local sa, ca = sin(ang), cos(ang)

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local beta = beam and beam.beta or beta
    local  k0q = beam and k0*beam.charge or k0q
    local  pw2 = 1 + 2*pt/beta + pt^2 - py^2
    local   pz = sqrt(pw2 - px^2)                                      -- PZ
    local  pzx = pz - k0q*(rho+x)      -- could be numerically unstable
    local  npx =  ca*px + sa*pzx                                       -- XN(2)
    local  dpx = -sa*px + ca*pzx                                       -- DPX'
    local  pzs = sqrt(pw2 - npx^2)                                     -- PZS
    local  ptt = sqrt(pw2)                                             -- PT
    local _ptt = 1/ptt
    local  dxs = (ang + asin(px*_ptt) - asin(npx*_ptt))/k0q            -- XN(3)

!    printf("beta= %-.16e, k0q= %-.16e, rho=%-.16e, ang=%-.16e\n", beta, k0q, rho, ang)
!    m:xdump(elm, "pzs=", pzs)
!    m:xdump(elm, "dpx=", dpx/k0q)

    -- eq. 126 in Forest06
    m[i].x  = pzs/k0q - dpx/k0q - rho  -- could be numerically unstable -- XN(1)
    m[i].px = npx                                                       -- XN(2)
    m[i].y  = y + dxs*py                                                -- XN(3)
    m[i].t  = t - dxs*(1/beta+pt) + (1-T)*ld/beta                       -- XN(6)
  end

  m:mdump(elm, 'sbend_thick:1')
end

M.sbend_kick = \el,m,lw -> M.curex_kick(el,m,lw,true) ;                      -- checked

-- TKT [INTER_STREX] ----------------------------------------------------------o

function M.rbend_thick (elm, m, lw) -- [SPAR]                                -- checked

  m:mdump(elm, 'rbend_thick:0')

  local el, eld, knl, beam, T in m
  local ld, k0 = (eld or el)*lw, knl[1]/abs(el)
  local beta, k0q, k0lq = beam.beta, k0*beam.charge, knl[1]*lw*beam.charge

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local beta = beam and beam.beta or beta
    local k0q  = beam and k0*beam.charge or k0q
    local k0lq = beam and knl[1]*lw*beam.charge or k0lq

    local  pw2 = 1 + 2*pt/beta + pt^2 - py^2
    local   pz = sqrt(pw2 - px^2)
    local  npx = px - k0lq
    local  pzs = sqrt(pw2 - npx^2)
    local  ptt = sqrt(pw2)
    local _ptt = 1/ptt
    local  dxs = (asin(px*_ptt) - asin(npx*_ptt))/k0q

    -- eq. 129 in Forest06
    m[i].x  = x + pzs/k0q - pz/k0q
    m[i].px = npx
    m[i].y  = y + dxs*py
    m[i].t  = t - dxs*(1/beta+pt) + (1-T)*ld/beta
  end

  m:mdump(elm, 'rbend_thick:1')
end

M.rbend_kick = \el,m,lw -> M.strex_kick(el,m,lw,true)                        -- checked

-- TKT [INTER_TKTF] -----------------------------------------------------------o

function M.quad_thick (elm, m, lw) -- [PUSHTKT7]                             -- checked

  m:mdump(elm, 'quad_thick:0')

  local el, edir, tdir, k1, beam in m
  local l = el*lw
  local chg = beam.charge

  -- [GETMAT7]
  local ws = k1*edir < 0 and -1 or 1
  local cx, sx, mx1, mx2
  local cy, sy, my1, my2

  if abs(k1) >= minstr then
    local w  = sqrt(abs(k1))*tdir*ws
    cx, sx = cos (w*l), sin (w*l)
    cy, sy = cosh(w*l), sinh(w*l)
    mx1, mx2 = sx/w, -sx*w
    my1, my2 = sy/w,  sy*w
  else
    cx, sx, mx1, mx2 = 1, 0, l, 0
    cy, sy, my1, my2 = 1, 0, l, 0
  end

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local chg = beam and beam.charge or chg

    if ws ~= chg then -- swap x <-> y
      ws, cx, cy, mx1, mx2, my1, my2 =
     -ws, cy, cx, my1, my2, mx1, mx2
    end

    local nx  = x*cx  + px*mx1
    local npx = x*mx2 + px*cx
    local ny  = y*cy  + py*my1
    local npy = y*my2 + py*cy

    m[i].x  = nx
    m[i].px = npx
    m[i].y  = ny
    m[i].py = npy
  end

  m:mdump(elm, 'quad_thick:1')
end

function M.quad_kick (elm, m, lw, ii) -- [KICKTKT7]                          -- checked
  local l = m.el*lw

  if ii >= 0 then drift_adj(elm, m, ii == 0 and l/2 or l) end

  if m.nmul > 0 then
    m:mdump(elm, 'quad_kick:0')

    local tdir, nmul, knl, ksl, beam in m
    local wchg = lw*tdir*beam.charge

    for i=1,m.npar do
      local x, px, y, py, beam in m[i]
      local  wchg = beam and lw*tdir*beam.charge or wchg
      local bx,by = bxby(nmul, knl, ksl, x, y)

      m[i].px = px - wchg*(by - knl[2]*x)
      m[i].py = py + wchg*(bx - knl[2]*y)
    end

    m:mdump(elm, 'quad_kick:1')
  end

  if ii <= 0 then drift_adj(elm, m, ii == 0 and l/2 or l) end
end

-- skew (tilted by k1s)

function M.quad_thicks (elm, m, lw) -- [PUSHTKT7]                            -- checked

  m:mdump(elm, 'quad_thicks:0')

  local el, edir, tdir, k1, ca, sa, beam in m
  local l = el*lw
  local chg = beam.charge

  -- [GETMAT7]
  local ws = k1*edir < 0 and -1 or 1
  local w  = sqrt(abs(k1))*tdir*ws
  local cx, sx = cos (w*l), sin (w*l)
  local cy, sy = cosh(w*l), sinh(w*l)
  local mx1, mx2 = sx/w, -sx*w
  local my1, my2 = sy/w,  sy*w

--  printf("k1l=%g, a=%g, ws=%g, w=%g, cx=%g, sx=%g, cy=%g, sy=%g, mx1=%g, mx2=%g, my1=%g, my2=%g\n",
--          k1l, a, ws, w, cx, sx, cy, sy, mx1, mx2, my1, my2)

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local chg = beam and beam.charge or chg

    if ws ~= chg then -- swap x <-> y
       ws, cx, cy, mx1, mx2, my1, my2 =
      -ws, cy, cx, my1, my2, mx1, mx2
    end

    -- srotation
    local nx  = ca*x  + sa*y
    local npx = ca*px + sa*py
    local ny  = ca*y  - sa*x
    local npy = ca*py - sa*px

    x  = nx*cx  + npx*mx1
    px = nx*mx2 + npx*cx
    y  = ny*cy  + npy*my1
    py = ny*my2 + npy*cy

    -- srotation^-1
    m[i].x  = ca*x  - sa*y
    m[i].px = ca*px - sa*py
    m[i].y  = ca*y  + sa*x
    m[i].py = ca*py + sa*px
  end

  m:mdump(elm, 'quad_thicks:1')
end

function M.quad_kicks (elm, m, lw, ii) -- [KICKTKT7]                         -- checked
  local l = m.el*lw

  if ii >= 0 then drift_adj(elm, m, ii == 0 and l/2 or l) end

  if m.nmul > 0 then
    m:mdump(elm, 'quad_kicks:0')

    local tdir, nmul, knl, ksl, beam in m
    local wchg = lw*tdir*beam.charge

    for i=1,m.npar do
      local x, px, y, py, beam in m[i]
      local  wchg = beam and lw*tdir*beam.charge or wchg
      local bx,by = bxby(nmul, knl, ksl, x, y)

      m[i].px = px - wchg*(by - knl[2]*x + ksl[2]*y)
      m[i].py = py + wchg*(bx - knl[2]*y - ksl[2]*x)
    end

    m:mdump(elm, 'quad_kicks:1')
  end

  if ii <= 0 then drift_adj(elm, m, ii == 0 and l/2 or l) end
end

-- curved (k0 and eh)

function M.quad_thickh (elm, m, lw) -- [PUSHTKT7]                            -- checked (for eh=0)

  m:mdump(elm, 'quad_thickh:0')

  local el, eh, edir, tdir, knl, beam in m
  local l = el*lw
  local chg = beam.charge
  local beta = beam.beta

  -- [GETMAT7, w ~= 0]
  local kx  = (knl[2]+eh*knl[1])/el*edir
  local ky  = -knl[2]/el*edir
  local wxs = kx*edir < 0 and -1 or 1
  local wys = ky*edir < 0 and -1 or 1
  local wx, cx, sx, wy, cy, sy
  local mx11, mx12, mx13, mx21, mx22, mx23, mx31, mx32, mx33
  local my11, my12,       my21, my22

  if abs(kx) >= minstr then
    wx = sqrt(abs(kx))*wxs*tdir
  else
    wx = 0
    mx11, mx12, mx13 = 1   , l   , eh*l^2/2
    mx21, mx22, mx23 = 0   , 1   , eh*l
    mx31, mx32, mx33 = mx23, mx13, mx13*mx23/3
  end

  if abs(ky) >= minstr then
    wy = sqrt(abs(ky))*wys*tdir
  else
    wy = 0
    my11, my12 = 1, l
    my21, my22 = 0, 1
  end

  local dox, doy = true, true
  wx, wy = -wx, -wy -- no need to reverse wxs and wys

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local  chg = beam and beam.charge or chg
    local beta = beam and beam.beta or beta

    if wx ~= 0 and wxs ~= chg or dox then -- [GETMAT7]
      wx, wxs, dox = -wx, -wxs, nil
      local cx, sx
      if wx > 0
      then cx, sx = cos (wx*l), sin (wx*l)
      else cx, sx = cosh(wx*l), sinh(wx*l)
      end
      mx11, mx12, mx13 = cx       , sx/wx,  eh*    (cx-1)*wxs/wx^2
      mx21, mx22, mx23 = wxs*wx*sx, cx   ,  eh*     mx12
      mx31, mx32, mx33 = mx23     , mx13 , -eh^2*(l-mx12)*wxs/wx^2
    end

    if wy ~= 0 and wys ~= chg or doy then -- [GETMAT7]
      wy, wys, doy = -wy, -wys, nil
      local cy, sy
      if wy > 0
      then cy, sy = cos (wy*l), sin (wy*l)
      else cy, sy = cosh(wy*l), sinh(wy*l)
      end
      my11, my12 = cy       , sy/wy
      my21, my22 = wys*wy*sy, cy
    end

--[[ PTC matrix form
    { cx      , sx/wx          ,  h*(cx-1)/wx2*ws     ,
      sx*wx*ws, cx             ,  h*sx/wx             ,
      h*sx/wx , h*(cx-1)/wx2*ws, -h^2*(l-sx/wx)/wx2*ws }
    { cy      , sy/wy          ,  0                   ,
      sy*wy*ws, cy             ,  0                    }
--]]

    -- print("mx11=", mx11) print("mx12=", mx12) print("mx13=", mx13)
    -- print("mx21=", mx21) print("mx22=", mx22) print("mx23=", mx23)
    -- print("my11=", my11) print("my12=", my12)
    -- print("my21=", my21) print("my22=", my22)

    local nx  = x*mx11 + px*mx12 + pt*(mx13*beta)
    local npx = x*mx21 + px*mx22 + pt*(mx23*beta)
    local ny  = y*my11 + py*my12
    local npy = y*my21 + py*my22
    local dt  = x*(mx31*beta) + px*(mx32*beta) + pt*mx33

    m[i].x   = nx
    m[i].y   = ny
    m[i].px  = npx
    m[i].py  = npy
    m[i].t   = t - dt
  end

  m:mdump(elm, 'quad_thickh:1')
end

function M.quad_kickh (elm, m, lw, ii) -- [KICKTKT7]                         -- checked (for eh=0)
  local l = m.el*lw

  if ii >= 0 then drift_adj(elm, m, ii == 0 and l/2 or l) end

  if m.nmul > 0 then
    m:mdump(elm, 'quad_kickh:0')

    local eh, tdir, nmul, knl, ksl, beam in m
    local _beta = 1/beam.beta
    local  wchg = lw*tdir*beam.charge

    for i=1,m.npar do
      local x, px, y, py, t, pt, beam in m[i]
      local _beam = beam and 1/beam.beta or _beta
      local  wchg = beam and lw*tdir*beam.charge or wchg
      local    pz = sqrt(1 + (2*_beta)*pt + pt^2)
      local    dt = (l*eh)*((_beta+pt)/pz - _beta)*x
      local bx,by = bxby(nmul, knl, ksl, x, y)

      m[i].px = px - wchg*(by - knl[2]*x - eh*(pz-_beta*pt))
      m[i].py = py + wchg*(bx - knl[2]*y)
      m[i].t  =  t - dt
    end

    m:mdump(elm, 'quad_kickh:1')
  end

  if ii <= 0 then drift_adj(elm, m, ii == 0 and l/2 or l) end
end

-- DKD, TKT [INTER_SOL5] ------------------------------------------------------o

function M.solen_thick (elm, m, lw) -- [KICK_SOL]                            -- checked

  m:mdump(elm, 'solen_thick:0')

  local el, ks, beam, T in m
  local l = el*lw
  local bsol = 0.5*ks*beam.charge
  local beta = beam.beta

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local beta = beam and beam.beta or beta
    local bsol = beam and 0.5*ks*beam.charge or bsol
    local   xp = px + bsol*y
    local   yp = py - bsol*x
    local l_pz = l/sqrt(1 + 2*pt/beta + pt^2 - xp^2 - yp^2)
    local  ang = l_pz*bsol
    local   dt = l_pz*(1/beta+pt)

    local ca, sa, sc = cos(ang), sin(ang), sinc(ang)

    local lsc = l_pz*sc
    local xt  = ca*x  + lsc*px
    local pxt = ca*px - lsc*x *bsol^2
    local yt  = ca*y  + lsc*py
    local pyt = ca*py - lsc*y *bsol^2

    m[i].x  = ca*xt  + sa*yt
    m[i].px = ca*pxt + sa*pyt
    m[i].y  = ca*yt  - sa*xt
    m[i].py = ca*pyt - sa*pxt
    m[i].t  = t - dt + (1-T)*l/beta
  end

  m:mdump(elm, 'solen_thick:1')
end

-- DKD, TKT [SEPTTRACK] -------------------------------------------------------o

function M.esept_thick (elm, m, lw) -- [SEP]                                  -- checked

  m:mdump(elm, 'elsep_thick:0')

  local el, ca, sa, volt, tdir, beam, T in m
  local   k1 = tdir*volt*beam.charge/beam.pc
  local    l = el*lw
  local beta = beam.beta
  local _bg2 = 1/beam.betgam2

--printf('@@ gammai=% -.16e, beta=% -.16e, p0c=% -.16e\n', 1/beam.gamma, beam.beta, beam.pc)
--printf('@@ volt=% -.16e, k1=% -.16e, ca=% -.16e, sa=% -.16e\n', volt*1e3, k1, ca, sa)

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local beta = beam and beam.beta or beta
    local _bg2 = beam and 1/beam.betgam2 or _bg2
    local   k1 = beam and tdir*volt*beam.charge/beam.pc or k1
    local   e1 = 1/beta+pt

    -- srotation
    local   nx  = ca*x  + sa*y
    local   npx = ca*px + sa*py
    local   ny  = ca*y  - sa*x
    local   npy = ca*py - sa*px

    local l_pz  = l/sqrt((e1+k1*ny)^2 - _bg2 - npx^2 - npy^2)
    local   arg = k1*l_pz
    local   shx = sinhc(arg)*l_pz
    local ch,sh = cosh(arg), sinh(arg)
    local   chm = sinh(0.5*arg)^2*(2/k1) -- was sinhc(0.5*arg)*sinh(0.5*arg)/l_pz
    local    dt = chm*npy + sh *ny  + e1*shx
    local    yt = ch *ny  + shx*npy + e1*chm
    local   pyt = ch *npy + sh*(e1+k1*ny)

    nx = nx + npx*l_pz
    ny, npy = yt, pyt

    -- srotation^-1
    m[i].x  = ca*nx  - sa*ny
    m[i].px = ca*npx - sa*npy
    m[i].y  = ca*ny  + sa*nx
    m[i].py = ca*npy + sa*npx
    m[i].t  = t - dt + (1-T)*l/beta
  end

  m:mdump(elm, 'elsep_thick:1')
end

-- DKD, TKT [INTER_CAV4] ------------------------------------------------------o

function M.rfcav_kick (elm, m, lw) -- [KICKCAV, FEVAL_CAVR?]                 -- checked

  m:mdump(elm, 'rfcav_kick:0')

  local volt, freq, lag, tdir, beam in m
  local omega = freq*twopi_clight
  local phase = lag
  local    vl = lw*tdir*volt*beam.charge/beam.pc

  -- printf('@@ vl=% -.16e, omega=% -.16e, phase=% -.16e, p0c=% -.16e, yl=% -.16e\n',
  --         vl, omega, phase, beam.pc, m.el*lw)

  for i=1,m.npar do
    local t, pt, beam in m[i]
    local  vl = beam and vl*chg*beam.charge/beam.pc or vl
    local dpt = vl*sin(phase - omega*t)

    -- energy kick
    m[i].pt = pt + dpt
  end

  m:mdump(elm, 'rfcav_kick:1')
end

function M.rfcav_kickn (elm, m, lw) -- [KICKCAV, nmul ~= 0 or nbsl ~= 0]     -- checked

  m:mdump(elm, 'rfcav_kickn:0')

  local volt, freq, lag, tdir, nbsl, nmul, knl, ksl, beam in m
  local omega = freq*twopi_clight
  local phase = lag
  local _pc   = 1/beam.pc
  local chg   = beam.charge
  local bdir  = lw*chg*tdir
  local vl    = bdir*volt

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local ph = phase - omega*t
    local sa, ca = sin(ph), cos(ph)
    local _pc, vl, bdir = _pc, vl, bdir
    local f = 1

    if beam then
      _pc, vl, bdir = 1/beam.pc, vl*chg*beam.charge, bdir*chg*beam.charge
    end

    -- bessel modes (single mode ko=1)
    if nbsl > 0 then
      local df, r2 = 0, 1

      for i=1,nbsl do
        r2 = -r2*omega^2/(4*(i+1)^2)
        df =  df + 2*r2*i
        r2 =  r2*(x^2+y^2)
        f  =  f + r2
      end

      local c1 = df*vl*_pc*ca/omega
      px = px + x*c1
      py = py + y*c1
    end

    -- energy kick
    pt = pt + f*vl*_pc*sa

    if nmul > 0 then
      local bx, by, byt = bxby(nmul, knl, ksl, x, y)
      px = px + (bdir*_pc)*by*ca
      py = py - (bdir*_pc)*bx*ca

      by = -knl[nmul]/nmul
      bx = -ksl[nmul]/nmul
      for i=nmul-1,1,-1 do
        byt = x*by - y*bx - knl[i]/i
        bx  = y*by + x*bx - ksl[i]/i
        by  = byt
      end
      byt = x*by - y*bx -- extra terms?
      bx  = y*by + x*bx
      by  = byt

      pt = pt + (bdir*_pc)*omega*by*sa
    end

    m[i].px = px
    m[i].py = py
    m[i].pt = pt
  end

  m:mdump(elm, 'rfcav_kickn:1')
end

local V6 = vector(6)

function M.gene_thick (elm, m, lw)                                            -- unchecked
  m:mdump(elm, 'gene_thick:0')

  local damap in m
  local up = damap.update

  for i=1,m.npar do
    if up then up(elm, m, lw, i) end -- update (?) the damap for the current m[i]

    local m = m[i]
    if is_damap(m) then
      damap:compose(m, m)
    else
      v[1], v[2], v[3], v[4], v[5], v[6] = m.x, m.px, m.y, m.py, m.t, m.pt
      damap:eval(v, v)
      m.x, m.px, m.y, m.py, m.t, m.pt = v[1], v[2], v[3], v[4], v[5], v[6]
    end
  end

  m:mdump(elm, 'gene_thick:1')
end

-- fringes --------------------------------------------------------------------o

local frng_none = tobit(0) -- all bits zero
local frng_mult = tobit(0) -- bit id for mult
local frng_bend = tobit(1) -- bit id for bend
local frng_quad = tobit(2) -- bit id for quad
local frng_cav  = tobit(0) -- bit id for cav (same as mult!)

--[[
Policy in MAD-NG:
=================
fringe field level: rbend=2, sbend=2, others=0.
m.fringe: command fringe fields level (nil/false=0, true=1)
e.fringe: element fringe fields level (nil/false=0, true=1)
fringe = bor(m.fringe, e.fringe)

bitwise:                              (ptc_setswitch,fringe=true <-> m.fringe=1)
fringe=0 -> no fringe field
fringe=1 -> activate mult_fringe                             (elm.fringe=1 or 3)
fringe=2 -> activate bend_fringe                          (elm.bend_fringe=true)
fringe=3 -> activate bend_fringe+mult_fringe
fringe=4 -> activate quad_fringe                             (elm.fringe=2 or 3)
fringe=5 -> activate mult_fringe+quad_fringe
fringe=6 -> activate bend_fringe+quad_fringe
fringe=7 -> activate bend_fringe+mult_fringe+quad_fringe
--]]

--[[
Policy in MAD-X PTC:
====================
k%fringe                T/F        ptc_setswitch equivalent to permfringe=1
el%likemad              T/F        special flag for true rbend
el%thin                 T/F        disable fringe for cavity
el%permfringe           0,1,2,3    0:none, 1:mult_fringe, 2:quad_fringe, 3:1+2
el%bend_fringe          T/F        bend_fringe (and mult_fringe-bend_fringe)
el%highest_fringe       N (N=2)    limit of mult_fringe
el%kill_ent_fringe      T/F        disable fringe on entry
el%kill_exi_fringe      T/F        disable fringe on exit

FRINGE_STRAIGHT: (TRACK_FRINGE)
  EDGE, MULTIPOLE_FRINGE, FRINGE2QUAD

FRINGE_STREX[LIKEMAD=TRUE]:
  ROT_XZ, FACE, FRINGE_DIPOLE, MULTIPOLE_FRINGE, FRINGE2QUAD, WEDGE
FRINGE_STREX:
  EDGE_TRUE_PARALLEL, MULTIPOLE_FRINGE, FRINGE2QUAD

FRINGE_TEAPOT[EDGE/=0]:
  ROT_XZ, FACE, FRINGE_DIPOLE, MULTIPOLE_FRINGE, FRINGE2QUAD, MAD8WEDGE, WEDGE
FRINGE_TEAPOT:
  FACE, FRINGE_DIPOLE, MULTIPOLE_FRINGE, FRINGE2QUAD

FRINGE_DIPOLE[BEND_FRINGE=TRUE]
FRINGE2QUAD[PERMFRINGE=2]
MULTIPOLE_FRINGE[PERMFRINGE=1.or.3]

NEWFACE[EXACT] / FACE[.not.EXACT]
EDGE
EDGE_TRUE_PARALLEL

FRINGECAV[PERMFRINGE/=0,THIN/=T,NOCAVITY/=T,N_BESSEL/=-1]
--]]

 -- forward declarations
local mad8_wedge, bend_wedge, bend_face
local bend_fringe, quad_fringe, mult_fringe, cav_fringe

function M.strex_fringe (elm, m, lw_)  -- [FRINGE_STREX]                     -- checked
  if m.nmul == 0 then return end -- switched off

  m:mdump(elm, 'strex_fringe:0')

  local lw = lw_ or 1
  local sdir, tdir in m
  local frng = bor(m.fringe, elm.fringe)

--  print("frng=", frng, "frng_mult=", btst(frng, frng_mult),
--                       "frng_bend=", btst(frng, frng_bend),
--                       "frng_quad=", btst(frng, frng_quad))

  if sdir*lw == 1 then
-- print(lw == 1 and 'forward entry' or 'backward exit')
    local e, h = elm.e1*tdir, elm.h1*tdir
    local a = 0.5*m.eh*(m.eld or m.el) - e
    yrotation ( e, m, 1)
    bend_face ( h, m, 1)
    if frng ~= frng_none and not elm.kill_ent_fringe then
      m.frng = frng
      if btst(frng, frng_bend) then bend_fringe(elm, m, 1) end
      if btst(frng, frng_mult) then mult_fringe(elm, m, 1) end
      if btst(frng, frng_quad) then quad_fringe(elm, m, 1) end
    end
    bend_wedge( a, m, 1)

  else
-- print(lw == -1 and 'forward exit' or 'backward entry')
    local e, h = elm.e2*tdir, elm.h2*tdir
    local a = 0.5*m.eh*(m.eld or m.el) - e
    bend_wedge( a, m, -1)
    if frng ~= frng_none and not elm.kill_exi_fringe then
      m.frng = frng
      if btst(frng, frng_quad) then quad_fringe(elm, m, -1) end
      if btst(frng, frng_mult) then mult_fringe(elm, m, -1) end
      if btst(frng, frng_bend) then bend_fringe(elm, m, -1) end
    end
    bend_face ( h, m, -1)
    yrotation (-e, m, -1)
  end

  m:mdump(elm, 'strex_fringe:1')
end

function M.curex_fringe (elm, m, lw_) -- [FRINGE_TEAPOT]                     -- checked
  if m.nmul == 0 then return end -- switched off

  m:mdump(elm, 'curex_fringe:0')

  local lw = lw_ or 1
  local sdir, tdir in m
  local frng = bor(m.fringe, elm.fringe)

--  print("frng=", frng, "frng_mult=", btst(frng, frng_mult),
--                       "frng_bend=", btst(frng, frng_bend),
--                       "frng_quad=", btst(frng, frng_quad))

  if sdir*lw == 1 then
-- print(lw == 1 and 'forward entry' or 'backward exit')
    local c, e, h = 0, (m.e1 or elm.e1)*tdir, elm.h1*tdir
    yrotation ( e, m, 1)
    bend_face ( h, m, 1)
    if frng ~= frng_none and not elm.kill_ent_fringe then
      m.frng, c = frng, 0.25
      if btst(frng, frng_bend) then bend_fringe(elm, m, 1) end
      if btst(frng, frng_mult) then mult_fringe(elm, m, 1) end
      if btst(frng, frng_quad) then quad_fringe(elm, m, 1) end
    end
    mad8_wedge( e, m, 1, c)
    bend_wedge(-e, m, 1)
  else
-- print(lw == -1 and 'forward exit' or 'backward entry')
    local c, e, h = 0, (m.e2 or elm.e2)*tdir, elm.h2*tdir
    bend_wedge(-e, m, -1)
    if frng ~= frng_none and not elm.kill_exi_fringe then
      m.frng, c = frng, 0.25
      mad8_wedge( e, m, -1, c)
      if btst(frng, frng_quad) then quad_fringe(elm, m, -1) end
      if btst(frng, frng_mult) then mult_fringe(elm, m, -1) end
      if btst(frng, frng_bend) then bend_fringe(elm, m, -1) end
    else
      mad8_wedge( e, m, -1, c)
    end
    bend_face ( h, m, -1)
    yrotation (-e, m, -1)
  end

  m:mdump(elm, 'curex_fringe:1')
end

function M.rfcav_fringe (elm, m, lw_) -- [ADJUST_TIME_CAV4, FRINGECAV]       -- checked
  m:mdump(elm, 'rfcav_fringe:0')

  local lw = lw_ or 1
  local sdir, beam in m
  local frng = bor(m.fringe, elm.fringe)

  if sdir*lw == 1 then
-- print(lw == 1 and 'forward entry' or 'backward exit')
    assert(m.Tbak == nil, "inconsistent totalpath when entering rfcavity")
    m.Tbak, m.T = m.T, 0
    if not elm.no_cavity_totalpath then
      m.T, m.lag = 1, m.lag - m.freq*m.el*pi_clight/beam.beta -- t=0 => accel=0
    end
      if btst(frng, frng_cav) and not elm.kill_ent_fringe then
        cav_fringe(elm, m,  1)
      end
  elseif btst(frng, frng_cav) and not elm.kill_exi_fringe then
-- print(lw == -1 and 'forward exit' or 'backward entry')
      cav_fringe(elm, m, -1)
  end

  if lw == -1 and m.Tbak ~= m.T then
-- on exit restore t if needed
    local Tl = (m.T-m.Tbak)*m.el
    local beta = beam.beta
    for i=1,m.npar do
      local t, beam in m[i]
      local beta = beam and beam.beta or beta
      m[i].t = t + Tl/beta
    end
  end

  if sdir*lw == -1 then
-- print(lw == -1 and 'forward exit' or 'backward entry')
    m.T, m.Tbak = m.Tbak, nil
  end

  m:mdump(elm, 'rfcav_fringe:1')
end

-- fringes helpers ------------------------------------------------------------o

function bend_face (h, m, lw) -- [NEWFACE]                                   -- checked
  local el, knl in m
  if abs(el) < minlen or abs(h)*abs(knl[1]) < minstr then return end

  m:mdump(h, 'bend_face:0')

  local tdir, beam in m
  local   k0h = knl[1]/el*h/2*tdir
  local   chg = beam.charge
  local _beta = 1/beam.beta

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beta = beam and 1/beam.beta or _beta
    local chg   = beam and beam.charge or chg

    if lw == 1 then -- to insure reversal symmetry ; horizontal wedge (only dir)
      px = px + chg*k0h*x^2
    end

    local dpp      =  1 + 2*pt*_beta + pt^2
    local _pt2     =  1/(dpp - px^2)
    local xi       =  2*k0h*lw*sqrt(dpp)*_pt2
    local dxi_px   =  2*px*xi           *_pt2
    local dxi_ddel = -2   *xi*(1+pt)    *_pt2

    x  = x / (1-dxi_px*y^2)
    px = px - xi*y^2
    py = py - 2*xi*x*y
    t  = t  - dxi_ddel*x*y^2

    if lw == -1 then -- to insure reversal symmetry; horizontal wedge (only dir)
      px = px - chg*k0h*x^2
    end

    m[i].x  = x
    m[i].px = px
    m[i].py = py
    m[i].t  = t
  end

  m:mdump(h, 'bend_face:1')
end

function mad8_wedge (e, m, lw, wc) -- [FRINGE_TEAPOT:MAD8_WEDGE]             -- checked
  if abs(e)+abs(m.knl[2]) < minstr then return end

  m:mdump(e, 'mad8_wedge:0')

  local el, tdir, knl, beam in m
  local  k1e = knl[2]/el*e*tdir
  local   c1 = (1+wc)*k1e
  local   c2 = (1-wc)*k1e
  local  chg = beam.charge

  for i=1,m.npar do
    local x, px, y, py, beam in m[i]
    local chg = beam and beam.charge or chg
    m[i].px = px + (chg*c1  )*x^2 - (chg*c2)*y^2
    m[i].py = py - (chg*c2*2)*x*y
  end

  m:mdump(e, 'mad8_wedge:1')
end

function bend_wedge (e, m, lw) -- [WEDGE] see also [sr]bend_thick            -- checked
  if abs(e)        < minang then return end
  if abs(m.knl[1]) < minstr then return yrotation(e,m,lw) end

  m:mdump(e, 'bend_wedge:0')

  local el, tdir, knl, beam in m
  local    k0 = knl[1]/el*tdir
  local    b1 = k0*beam.charge
  local _beta = 1/beam.beta
  local sa, ca, s2a = sin(e), cos(e), sin(2*e)

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beta = beam and 1/beam.beta or _beta
    local    b1 = beam and k0*beam.charge or b1

    local pzy = 1 + (2*_beta)*pt + pt^2 - py^2
    local _pt = 1/sqrt(pzy)
    local  pz = sqrt(pzy - px^2)
    local pzx = pz - b1*x
    local npx = px*ca + pzx*sa
    local pzs = sqrt(pzy - npx^2)
    local dxs = (e + asin(px*_pt) - asin(npx*_pt))/b1

    m[i].x  = x*(ca + (px*s2a + sa^2*(pz+pzx))/(pzs + pz*ca - px*sa))
    m[i].px = npx
    m[i].y  = y + dxs*py
    m[i].t  = t - dxs*(_beta+pt)
  end

  m:mdump(e, 'bend_wedge:1')
end

function bend_fringe (elm, m, lw) -- [FRINGE_DIPOLE]                         -- checked
  local fh = elm.hgap*(lw == -1 and elm.fintx or elm.fint)

  if abs(fh)+abs(m.knl[1]) < minang then return end

  m:mdump(elm, 'bend_fringe:0')

  local el, sdir, tdir, knl, beam in m
  local    k0 = knl[1]/el*tdir
  local  fsad = abs(fh) ~= 0 and sdir/(2*36*fh) or 0
  local  b0   = k0*lw*beam.charge
  local _beta = 1/beam.beta

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beta = beam and 1/beam.beta or _beta
    local    b0 = beam and k0*lw*beam.charge or b0

    local   dpp = 1 + 2*_beta*pt + pt^2
    local    pz = sqrt(dpp - px^2 - py^2)
    local   _pz = 1/pz
    local  relp = 1/sqrt(dpp)
    local  tfac = -(_beta + pt)

    local    c2 = b0*fh*2
    local    c3 = b0^2*fsad*relp

    local xp,  yp  = px/pz, py/pz
    local xyp, yp2 = xp*yp, 1+yp^2
    local xp2,_yp2 = xp^2 , 1/yp2

    local fi0 = atan((xp*_yp2)) - c2*(1 + xp2*(1+yp2))*pz
    local co2 = b0/cos(fi0)^2
    local co1 = co2/(1 + (xp*_yp2)^2)*_yp2
    local co3 = co2*c2

    local fi1 =    co1          - co3*2*xp*(1+yp2)*pz
    local fi2 = -2*co1*xyp*_yp2 - co3*2*xp*xyp    *pz
    local fi3 =                 - co3*(1 + xp2*(1+yp2))

    local kx = fi1*(1+xp2)*_pz   + fi2*xyp*_pz       - fi3*xp
    local ky = fi1*xyp*_pz       + fi2*yp2*_pz       - fi3*yp
    local kz = fi1*tfac*xp*_pz^2 + fi2*tfac*yp*_pz^2 - fi3*tfac*_pz

    y = 2*y / (1 + sqrt(1-2*ky*y))
    x = x + 0.5*kx*y^2
    t = t + 0.5*kz*y^2
    py = py - b0*tan(fi0)*y

    -- soft edge (negligible?)
    py = py - 4*c3*y^3
    t  = t  +   c3*y^4*relp^2*tfac

    m[i].x  = x
    m[i].y  = y
    m[i].py = py
    m[i].t  = t
  end

  m:mdump(elm, 'bend_fringe:1')
end

function quad_fringe (elm, m, lw) -- [FRINGE2QUAD]                           -- unchecked
  if abs(m.knl[2])+abs(m.ksl[2]) < minstr then return end
  local f1, f2 in elm
  if abs(f1)+abs(f2) < minstr then return end

  m:mdump(elm, 'quad_fringe:0')

  local el, tdir, k1, ca, sa, beam in m
  local _beta = 1/beam.beta
  local  wchg = beam.charge*tdir*lw
  local    b2 = k1

  if not b2 then
    local edir, knl, ksl in m
    local a = -0.5*atan2(ksl[2], knl[2])*tdir
    b2, ca, sa = sqrt(knl[2]^2 + ksl[2]^2)/el*edir, cos(a), sin(a)
  end

  f1 = -abs(f1)*f1*b2/24
  f2 =          f2*b2

  -- Lee-Whiting formula, E. Forest ch 13.2.3, eq 13.33
  for i=1,m.npar do
  	local x, px, y, py, t, pt, beam in m[i]
    local _beta = beam and 1/beam.beta or _beta
    local  wchg = beam and beam.charge*tdir*lw or wchg
    local   _pz = 1/sqrt(1 + 2*_beta*pt + pt^2)
    local    dt = (_beta+pt)*_pz

    local f1 = (wchg*f1)*_pz
    local f2 =       f2 *_pz

    local nx  = ca*x  + sa*y
    local npx = ca*px + sa*py
    local ny  = ca*y  - sa*x
    local npy = ca*py - sa*px

    m[i].t  = t - dt*((f1*nx + (1+f1/2)*exp(-f1)*f2*npx*_pz)*npx -
                      (f1*ny + (1-f1/2)*exp( f1)*f2*npy*_pz)*npy)*_pz

    x  =  nx*exp( f1) + f2*npx*_pz
    y  =  ny*exp(-f1) - f2*npy*_pz
    px = npx*exp(-f1)
    py = npy*exp( f1)

    m[i].x  = ca*x  - sa*y
    m[i].px = ca*px - sa*py
    m[i].y  = ca*y  + sa*x
    m[i].py = ca*py + sa*px
  end

  m:mdump(elm, 'quad_fringe:1')
end

function mult_fringe (elm, m, lw) -- [MULTIPOLE_FRINGE]                       -- checked

  m:mdump(elm, 'mult_fringe:0')

  local el, tdir, nmul, knl, ksl, beam in m
  local _beta = 1/beam.beta
  local  wchg = beam.charge*tdir*lw
  local no_k1 = btst(m.frng, frng_bend) -- bend_fringe done
  local    _l = el ~= 0 and 1/abs(el) or 1 -- to review...
  local  fmax = elm.fringemax

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beta = beam and 1/beam.beta or _beta
    local  wchg = beam and beam.charge*tdir*lw or wchg
    local   _pz = 1/sqrt(1 + (2*_beta)*pt + pt^2)

    local rx, ix = 1, 0
    local fx, fxx, fxy = 0, 0, 0
    local fy, fyx, fyy = 0, 0, 0

    for j=1,min(nmul,fmax) do
      local drx, dix = rx, ix
      rx = drx*x - dix*y
      ix = drx*y + dix*x

      local nj, nf = -wchg/(4*(j+1)), (j+2)/j
      local knj, ksj = knl[j]*_l, ksl[j]*_l
      local u, v, du, dv

      if j == 1 and no_k1 then
        u  = nj*(        - ksj*ix )
        v  = nj*(        + ksj*rx )
        du = nj*(        - ksj*dix)
        dv = nj*(        + ksj*drx)
      else
        u  = nj*(knj*rx  - ksj*ix )
        v  = nj*(knj*ix  + ksj*rx )
        du = nj*(knj*drx - ksj*dix)
        dv = nj*(knj*dix + ksj*drx)
      end

      local dux, dvx =  j*du, j*dv
      local duy, dvy = -j*dv, j*du

      fx  = fx  +   u*x + nf*   v*y
      fy  = fy  +   u*y - nf*   v*x
      fxx = fxx + dux*x + nf* dvx*y + u
      fyy = fyy + duy*y - nf* dvy*x + u
      fxy = fxy + duy*x + nf*(dvy*y + v)
      fyx = fyx + dux*y - nf*(dvx*x + v)
    end

    local    a = 1 - fxx*_pz
    local    b =   - fyx*_pz
    local    c =   - fxy*_pz
    local    d = 1 - fyy*_pz
    local _det = 1/(a*d - b*c)
    local  npx = (d*px - b*py)*_det

    m[i].x  = x - fx*_pz
    m[i].y  = y - fy*_pz
    m[i].py = (a*py - c*px)*_det
    m[i].px = npx
    m[i].t  = t + (_beta+pt)*(m[i].px*fx + m[i].py*fy)*_pz^3
  end

  m:mdump(elm, 'mult_fringe:1')
end

function cav_fringe (elm, m, lw) -- [FRINGECAV]                               -- checked
  m:mdump(elm, 'cav_fringe:0')

  local el, volt, freq, lag, nbsl, tdir, beam in m
  local omega = freq*twopi_clight
  local phase = lag
  local    vl = lw/el*volt*beam.charge/beam.pc
--local     z = 0.5*(1-lw)*el

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local  vl = beam and lw/el*volt*beam.charge/beam.pc or vl
    local  s1 = sin(phase - omega*t)
    local  c1 = cos(phase - omega*t)

--    print("vl=", vl, "o=", omega, "ph=", phase)
--    m:xdump(elm, "s1=", -s1)
--    m:xdump(elm, "c1=", -c1)

    m[i].px = px - (0.5 *vl      )*s1*x
    m[i].py = py - (0.5 *vl      )*s1*y
    m[i].pt = pt + (0.25*vl*omega)*c1*(x^2 + y^2)
  end

  m:mdump(elm, 'cav_fringe:1')
end

-- extra fringe (not used) ----------------------------------------------------o

function M.dipeg_fringe (elm, m, lw_) -- [MADX dipedge]                      -- unchecked
  if m.nmul == 0 or abs(m.knl[1]) < minstr then return end -- switched off
  local lw = lw_ or 1

  local el, edir, sdir, tdir, knl, beam in m
  local k0 = knl[1]/el*tdir
  local corr, e = 0

  if sdir*lw == 1 then
    e = elm.e1*tdir
    if not elm.kill_ent_fringe then
      corr = k0^2*elm.hgap*elm.fint
    end
  else
    e = elm.e2*tdir
    if not elm.kill_exi_fringe then
      corr = k0^2*elm.hgap*(elm.fintx or elm.fint)
    end
  end

  if e == 0 and corr == 0 then return end

  m:mdump(elm, 'dipeg_fringe:0')

  local chg = beam.charge
--  local k0  = k0*edir
  local r21 = k0*tan(e)
  local r43 = corr == 0 and -r21 or -k0 * tan(e - corr/cos(e)*(1+sin(e)^2))

  for i=1,m.npar do
    local x, px, y, py, beam in m[i]
    local chg = beam and beam.charge or chg

    m[i].px = px + chg*r21*x
    m[i].py = py + chg*r43*y
  end

  m:mdump(elm, 'dipeg_fringe:1')
end

-- end ------------------------------------------------------------------------o
return { dynmap = M }
