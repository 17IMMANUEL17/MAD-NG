--[=[
 o-----------------------------------------------------------------------------o
 |
 | Dynamic 6D maps
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: I. Shreyber, irina.tecker at cern.ch
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide a catalog of dynamical 6D maps (i.e. track)
    maps must have the following calling convention:
      dynmap(elm, map, length_weight)
    (see the symplectic integrators)
  - TODO: list the expected fields for elm and map

 o-----------------------------------------------------------------------------o
]=]

local M = {}

-- PTC variables:
-- L     thick weighted length
-- LD    thick weighted arc length
-- YL    kick  weighted length
-- B     relativistic beta0
-- B0    curvature = angle/LD
-- BN(1) k0
-- BN(2) k1
-- DIR   tracking direction

-- Note:
-- Is (_beta+pt) in t eq. shouldn't be sqrt((_beta+pt)^2 - (_beta*_gamma)^2) ??
-- is it a 1st order approximation?

-- locals ---------------------------------------------------------------------o

local vector, matrix                                             in MAD
local is_nil, is_number                                          in MAD.typeid
local minlen, minang, clight, twopi                              in MAD.constant

local fnone                                                      in MAD.gfunc
local abs, sqrt, max, sin, cos, tan, asin, acos, atan, atan2,
      sinh, cosh, sinc, fact                                     in MAD.gmath

local drift = MAD.element.drift {}

-- constants
local volt_c = 1e-3

 -- forward declarations
local sbend_face, sbend_wedge, sbend_fringe, mult_fringe, straight_fringe

-- debug ----------------------------------------------------------------------o

local nodump = true

local function mdump(str, m, l_)
  if nodump then return end
  assert(m.npar >= 1)
  print(str, l_ and l_ or '', m[1].x, m[1].px, m[1].y, m[1].py, m[1].t, m[1].pt)
end

-- field mutipoles ------------------------------------------------------------o

local function bxby (nmul, knl, ksl, x, y)
  local bx, by, byt = 0, 0

  for i=nmul,1,-1 do
    byt = by*x - bx*y + knl[i]
    bx  = by*y + bx*x + ksl[i]
    by  = byt
  end

  return bx, by
end

-- TODO: cur_bxby (nmul, knl, ksl, h, x, y) using TPSA (?)

-- patches (lw_ == 0 disable the patches) -------------------------------------o

-- X-rotation

local function xrotation (elm, m, lw_)  -- Rx(ax) [ROT_YZ]
  if lw_ == 0 then return end

  local ax = is_number(elm) and elm or elm.angle*m.tdir
  if abs(ax) < minang then return end

  local ax = ax*(lw_ or 1)
  local sa, ca, ta = sin(ax), cos(ax), tan(ax)
  local _beta = 1/beam.beta

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beta = beam and 1/beam.beta or _beta
    local    pz = sqrt(1 + (2*_beta)*pt + pt^2 - px^2 - py^2)
    local   _pz = 1/pz
    local   ptt = 1 - ta*py*_pz
    local  _ptt = y/ptt
    local  _pzt = ta*_pz*_ptt

    -- eq. 127 in Forest06
    m[i].y  = _ptt/ca
    m[i].py = ca*py + sa*pz
    m[i].x  = x + _pzt*px
    m[i].t  = t - _pzt*(_beta+pt)
  end
end

M.xrotation = xrotation

-- Y-rotation

local function yrotation (elm, m, lw_)  -- Ry(ay) [ROT_XZ]
  if lw_ == 0 then return end

  local ay = is_number(elm) and elm or elm.angle*m.tdir
  if abs(ay) < minang then return end

  local ay = ay*(lw_ or 1)
  local sa, ca, ta = sin(ay), cos(ay), tan(ay)
  local _beta = 1/beam.beta

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beta = beam and 1/beam.beta or _beta
    local    pz = sqrt(1 + (2*_beta)*pt + pt^2 - px^2 - py^2)
    local   _pz = 1/pz
    local   ptt = 1 - ta*px*_pz
    local  _ptt = x/ptt
    local  _pzt = ta*_pz*_ptt

    -- eq. 127 in Forest06
    m[i].x  = _ptt/ca
    m[i].px = ca*px + sa*pz
    m[i].y  = y + _pzt*py
    m[i].t  = t - _pzt*(_beta+pt)
  end
end

M.yrotation = yrotation

-- S-rotation

local function srotation (elm, m, lw_)  -- Rz(az) [ROT_XY]
  if lw_ == 0 then return end

  local az = is_number(elm) and elm or elm.angle*m.tdir
  if abs(az) < minang then return end

  local az = az*(lw_ or 1)
  local sa, ca = sin(az), cos(az)

--  mdump('srotation-0:', m, az)

  for i=1,m.npar do
    local x, px, y, py in m[i]
    local nx  = ca*x  + sa*y
    local npx = ca*px + sa*py

    m[i].y    = ca*y  - sa*x
    m[i].py   = ca*py - sa*px
    m[i].x    = nx
    m[i].px   = npx
  end

--  mdump('srotation-1:', m)
end

M.srotation = srotation

-- Translation

local function translate (elm, m, lw_) -- [TRANS]
  if lw_ == 0 then return end

  local dx, dy, ds = elm.dx or 0, elm.dy or 0, elm.ds or 0
  if abs(dx)+abs(dy)+abs(ds) < minlen then return end

  local tdir in m
  local lw = lw_ or 1
  local dx, dy = dx*lw*tdir, dy*lw*tdir

  if abs(ds) < minlen then
    for i=1,m.npar do
      local x, y in m[i]
      m[i].x = x - dx
      m[i].y = y - dy
    end
    return
  end

  -- ds is treated as a drift without correction for the time of flight
  local l = ds*lw*m.sdir

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beta = 1/(beam or m.beam).beta
    local l_pz = l/sqrt(1 + (2*_beta)*pt + pt^2 - px^2 - py^2)

    m[i].x = x + l_pz*px - dx
    m[i].y = y + l_pz*py - dy
    m[i].t = t - l_pz*(_beta+pt)
  end
end

M.translate = translate

-- Changeref (generic patch, lw_>0: RT, lw_<0: TR)

function M.changeref (elm, m, lw_)
  if lw_ == 0 then return end
  local lw = lw_ or 1

  local dx  , dy  , ds   = elm.dx     or 0, elm.dy   or 0, elm.ds   or 0
  local dthe, dphi, dpsi = elm.dtheta or 0, elm.dphi or 0, elm.dpsi or 0

  local trn = abs(dx  )+abs(dy  )+abs(ds  ) >= minlen
  local rot = abs(dthe)+abs(dphi)+abs(dpsi) >= minang

  if not (trn or rot) then return end

  -- forward : x1' = R*x1+T
  -- backward: x1  = R^-1*(x1'-T)

  if lw > 0 then
      translate({dx=dx,dy=dy,ds=ds}, m, 1)
    if rot then
      yrotation({angle= dthe}, m, 1)
      xrotation({angle=-dphi}, m, 1)
      srotation({angle= dpsi}, m, 1)
    end
  else
    if rot then
      srotation({angle= dpsi}, m, -1)
      xrotation({angle=-dphi}, m, -1)
      yrotation({angle= dthe}, m, -1)
    end
      translate({dx=dx,dy=dy,ds=ds}, m, -1)
  end
end

-- Changedir (reverse mflow t-direction)

function M.changedir (elm_, m, lw_)
  if lw_ == 0 then return end

  m.edir = -m.edir
  m.tdir = -m.tdir
end

-- Changenrj (change particles energy)

function M.changenrj (elm, m, lw_)  -- (option to reset pt?)
  if lw_ == 0 then return end

  local dnrj in elm
  if dnrj == 0 then return end

  local tdir, beam in m
  beam.energy = beam.energy + dnrj*tdir

  for i=1,m.npar do
    beam = m[i].beam
    if beam then
      beam.energy = beam.energy + dnrj*tdir
    end
  end
end

-- misalignments (lw_ == 0 disable the misalignments) -------------------------o

local T  = vector(3) -- misalignment translation
local R  = matrix(3) -- misalignment rotation
local Tb = vector(3) -- misalignment translation at exit (Tbar)
local Rb = matrix(3) -- misalignment rotation    at exit (Rbar)

local misalignexi -- forward declaration

-- Misalign (lw_>0: entry, lw_<0: exit)

local misalignexi

function M.misalign (elm, m, lw_)
  if lw_ == 0 then return end
  if (lw_ or 1) < 0 then return misalignexi(elm, m) end

  local dx  , dy  , ds   = elm.dx     or 0, elm.dy   or 0, elm.ds   or 0
  local dthe, dphi, dpsi = elm.dtheta or 0, elm.dphi or 0, elm.dpsi or 0

  local trn = abs(dx  )+abs(dy  )+abs(ds  ) >= minlen
  local rot = abs(dthe)+abs(dphi)+abs(dpsi) >= minang

  if not (trn or rot) then return end

  local sdir, tdir in m

  -- misalignment at entry and local/global frames
  -- forward : x1' = R*x1+T
  -- backward: x1  = R^-1*(x1'-T)

  -- reuse patches without directions
  if sdir > 0 then
      translate({dx=dx*tdir,dy=dy*tdir,ds= ds}, m,  1)
    if rot then
      yrotation( dthe, m,  1)
      xrotation(-dphi, m,  1)
      srotation( dpsi, m,  1)
    end
  else
    if rot then
      srotation( dpsi, m, -1)
      xrotation(-dphi, m, -1)
      yrotation( dthe, m, -1)
    end
      translate({dx=dx*tdir,dy=dy*tdir,ds=-ds}, m, -1)
  end
end

function misalignexi (elm, m)
  local dx  , dy  , ds   = elm.dx     or 0, elm.dy   or 0, elm.ds   or 0
  local dthe, dphi, dpsi = elm.dtheta or 0, elm.dphi or 0, elm.dpsi or 0

  local trn = abs(dx  )+abs(dy  )+abs(ds  ) >= minlen
  local rot = abs(dthe)+abs(dphi)+abs(dpsi) >= minang


  if not (trn or rot) then return end

  local el, ang, tlt, sdir, tdir in m

  -- translation
  if trn then T:fill{dx, dy, ds} else T:zeros() end

  -- rotation
  if rot then R:rotzxy(-dphi, dthe, dpsi) end

  -- compute Rbar, Tbar
  _C.mad_mat_rtbar(Rb.data, Tb.data, abs(el), ang, tlt, rot and R.data or nil, T.data)

  -- misalignment at exit and local/global frames
  -- forward : x2  = Rb^-1*(x2'-Tb)
  -- backward: x2' = Rb*x2+Tb

  -- reuse patches without directions
  if sdir > 0 then
    if rot then
      local ax, ay, az = Rb:torotzxy()
      srotation(az, m, -1)
      xrotation(ax, m, -1)
      yrotation(ay, m, -1)
    end
      translate({dx=Tb[1]*tdir,dy=Tb[2]*tdir,ds= Tb[3]}, m, -1)
  else
      translate({dx=Tb[1]*tdir,dy=Tb[2]*tdir,ds=-Tb[3]}, m,  1)
    if rot then
      local ax, ay, az = Rb:torotzxy()
      yrotation(ay, m,  1)
      xrotation(ax, m,  1)
      srotation(az, m,  1)
    end
  end
end

-- THIN -----------------------------------------------------------------------o

function M.thin_kick (elm, m, lw) -- [KICKT]                                    unchecked
  if m.nmul == 0 then return end

  local el, tdir, beam, nmul, knl, ksl in m
  local wchg = lw*tdir*beam.charge
  local _beta = 1/beam.beta

--  mdump('thin_kick-0:', m, el*sdir*lw)

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local  wchg = beam and lw*tdir*beam.charge or wchg
    local _beta = beam and 1/beam.beta or _beta
    local bx,by = bxby(nmul, knl, ksl, x, y)

    m[i].px = px - wchg*(by - knl[1])
    m[i].py = py + wchg*(bx - ksl[1])

    -- dipole focusing and delta_p, TODO: consider angle vs knl[1]
    local dpp1 = sqrt(1 + (2*_beta)*pt + pt^2)
    if el ~= 0 then
      local dp = dpp1 - 1
      m[i].px = m[i].px - (knl[1]^2/el)*x + (wchg*knl[1])*dp
      m[i].py = m[i].py - (ksl[1]^2/el)*y + (wchg*ksl[1])*dp
    end
      m[i].t  = t - wchg*(knl[1]*x - ksl[1]*y) * (_beta+pt)/dpp1
  end

--  mdump('thin_kick-1:', m)
end

-- DKD [INTER_STREX] ----------------------------------------------------------o

function M.strex_drift (elm, m, lw) -- [DRIFT]                                  checked
  if abs(m.el) < minlen then return end

  local el, eld, beam, T in m
  local l, ld = el*lw, (eld or el)*lw
  local _beta = 1/beam.beta

--  mdump('strex_drift-0:', m, l)

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beta = beam and 1/beam.beta or _beta
    local  l_pz = l/sqrt(1 + (2*_beta)*pt + pt^2 - px^2 - py^2)

    m[i].x = x + px*l_pz
    m[i].y = y + py*l_pz
    m[i].t = t - (_beta+pt)*l_pz + (1-T)*ld*_beta
  end

--  mdump('strex_drift-1:', m)
end

function M.strex_kick (elm, m, lw, no_k0l) -- [KICKEX]                          checked
  if m.nmul == 0 then return end

  local tdir, beam, nmul, knl, ksl in m
  local wchg = lw*tdir*beam.charge
  local dby  = no_k0l and -knl[1] or 0

--  mdump('strex_kick-0:', m)

  for i=1,m.npar do
    local x, px, y, py, beam in m[i]
    local wchg = beam and lw*tdir*beam.charge or wchg
    local bx,by = bxby(nmul, knl, ksl, x, y)

    m[i].px = px - wchg*(by+dby)
    m[i].py = py + wchg* bx
  end

--  mdump('strex_kick-1:', m)
end

M.strex_fringe = fnone -- TODO: see below

-- DKD [INTER_TEAPOT, l ~= 0, angle ~= 0] -------------------------------------o

function M.curex_drift (elm, m, lw) -- [SPROT]                                  checked
  local el, eld, eh, ang, beam, T in m
  local ld, ang = (eld or el)*lw, ang*lw   -- A = ang
  local rho, _beta = 1/eh, 1/beam.beta     -- R = rho

  local sa, ca, ta, sa2 = sin(ang), cos(ang), tan(ang), sin(ang/2)

--  mdump('curex_drift-0:', m, ld)

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beta = beam and 1/beam.beta or _beta
    local    pz = sqrt(1 + 2*_beta*pt + pt^2 - px^2 - py^2)
    local   _pz = 1/pz
    local   pxt = px*_pz
    local   ptt = (1 - ta*pxt)*ca
    local  _ptt = 1/ptt
    local   pst = (x+rho)*sa*_pz*_ptt

    m[i].x  = (x + rho*(2*sa2^2 + sa*pxt))*_ptt
    m[i].px = ca*px + sa*pz
    m[i].y  = y + pst*py
    m[i].t  = t - pst*(_beta+pt) + (1-T)*ld*_beta
  end

--  mdump('curex_drift-1:', m)
end

function M.curex_kick (elm, m, lw, no_k0l) -- [SKICK]                           checked
  local eh, ang, tdir, beam, nmul, knl, ksl in m
  local bdir = beam.charge*tdir
  local wchg = bdir*lw
  local dby  = no_k0l and -knl[1] or knl[1]-ang*bdir

--  mdump('curex_kick-0:', m, m.eld*m.sdir*lw)

  for i=1,m.npar do
    local x, px, y, py, beam in m[i]
    local wchg = beam and beam.charge*lw*tdir or wchg
    local bx, by = bxby(nmul, knl, ksl, x, y)

    -- TODO: should use TPSA in cur_bxby
    m[i].px = px - ((1+eh*x)*wchg)*(by+dby)
    m[i].py = py +           wchg * bx
  end

--  mdump('curex_kick-1:', m)
end

M.curex_fringe = fnone -- TODO: see fringe below

-- TKT [INTER_TEAPOT, angle ~= 0] ---------------------------------------------o

function M.sbend_thick (elm, m, lw) -- [SSEC]                                   checked
  local el, eld, eh, ang, k0, beam, T in m
  local ld, ang, k0 = (eld or el)*lw, ang*lw, k0*m.edir      -- A = ang
  local rho, _beta, k0q = 1/eh, 1/beam.beta, k0*beam.charge  -- R = rho

  local sa, ca = sin(ang), cos(ang)

--  mdump('sbend_thick-0:', m, ld)

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beta = beam and 1/beam.beta or _beta
    local   k0q = beam and k0*beam.charge or k0q
    local  pw2 = 1 + 2*_beta*pt + pt^2 - py^2
    local   pz = sqrt(pw2 - px^2)
    local  pzx = pz - (x+rho)*k0q
    local  npx =  ca*px + sa*pzx
    local  dpx = -sa*px + ca*pzx
    local   ps = sqrt(pw2 - npx^2)
    local  ptt = sqrt(pw2)
    local _ptt = 1/ptt
    local  dxs = (ang + asin(px*_ptt) - asin(npx*_ptt))/k0q

    -- eq. 126 in Forest06
    m[i].x  = (ps-dpx)/k0q - rho
    m[i].px = npx
    m[i].y  = y + dxs*py
    m[i].t  = t - dxs*(_beta+pt) + (1-T)*ld*_beta
  end

--  mdump('sbend_thick-1:', m)
end

M.sbend_kick   = \e,m,lw => M.curex_kick(e,m,lw,true) end
M.sbend_fringe = M.curex_fringe

-- TKT [INTER_STREX] ----------------------------------------------------------o

function M.rbend_thick (elm, m, lw) -- [SPAR]                                   checked
  local el, eld, k0, knl, beam, T in m
  local l, ld, k0 = el*lw, eld*lw, k0*m.edir
  local _beta, _k0q, k0lq = 1/beam.beta, 1/k0*beam.charge, knl[1]*beam.charge

--  mdump('rbend_thick-0:', m, l)

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beta = beam and 1/beam.beta or _beta
    local _k0q  = beam and 1/(k0*beam.charge) or _k0q
    local  k0lq = beam and knl[1]*beam.charge or k0lq

    local  pw2 = 1 + 2*_beta*pt + pt^2 - py^2
    local   pz = sqrt(pw2 - px^2)
    local  ptt = sqrt(pw2)
    local _ptt = 1/ptt
    local  npx = px - k0lq
    local  pzs = sqrt(pw2 - npx^2)
    local   nx = x + (pzs-pz)*_k0q
    local  pzt = (asin(px*_ptt) - asin(npx*_ptt))*_k0q

    -- eq. 129 in Forest06
    m[i].x  = nx
    m[i].px = npx
    m[i].y  = y + pzt*py
    m[i].t  = t - pzt*(_beta+pt) + (1-T)*ld*_beta
  end

--  mdump('rbend_thick-1:', m)
end

M.rbend_kick   = \el,m,lw => M.strex_kick(el,m,lw,true) end
M.rbend_fringe = M.strex_fringe

-- TKT [INTER_TKTF] -----------------------------------------------------------o

local function drift_adj (l, m) -- [KICKPATH] drift adjustment                  checked
  local ca, sa, beam, T in m
  local _beta = 1/beam.beta

--  mdump('drift_adj-0:', m, l)

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beta = beam and 1/beam.beta or _beta
    local l_pz = l/sqrt(1 + (2*_beta)*pt + pt^2 - px^2 - py^2)

    m[i].x = x + px*(l_pz-l)
    m[i].y = y + py*(l_pz-l)
    m[i].t = t - (_beta+pt)*l_pz + (1-T)*l*_beta
  end

--  mdump('drift_adj-1:', m)
end

function M.quad_thick (elm, m, lw) -- [PUSHTKT7]                                checked
  local el, k1, ca, sa, edir, tdir, beam in m
  local l = el*lw
  local chg = beam.charge

  -- [GETMAT7, h == 0]
  local ws = k1*edir < 0 and -1 or 1
  local w  = sqrt(abs(k1))*tdir*ws
  local cx, sx = cos (w*l), sin (w*l)
  local cy, sy = cosh(w*l), sinh(w*l)
  local mx1, mx2 = sx/w, -sx*w
  local my1, my2 = sy/w,  sy*w
-- [GETMAT7]

  -- mdump('quad_thick-0:', m, l)

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local chg = beam and beam.charge or chg

    if ws ~= chg then -- swap x <-> y
      ws, cx, cy, mx1, mx2, my1, my2 = -ws, cy, cx, my1, my2, mx1, mx2
    end

    local nx  = x*cx  + px*mx1
    local npx = x*mx2 + px*cx
    local ny  = y*cy  + py*my1
    local npy = y*my2 + py*cy

    m[i].x  = nx
    m[i].px = npx
    m[i].y  = ny
    m[i].py = npy
  end

  -- mdump('quad_thick-1:', m)
end

function M.quad_tthick (elm, m, lw) -- [PUSHTKT7]                               checked
  local el, k1, ca, sa, edir, tdir, beam in m
  local l = el*lw
  local chg = beam.charge

  -- [GETMAT7, h == 0]
  local ws = k1*edir < 0 and -1 or 1
  local w  = sqrt(abs(k1))*tdir*ws
  local cx, sx = cos (w*l), sin (w*l)
  local cy, sy = cosh(w*l), sinh(w*l)
  local mx1, mx2 = sx/w, -sx*w
  local my1, my2 = sy/w,  sy*w
-- [GETMAT7]

  -- mdump('quad_tthick-0:', m, l)

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local chg = beam and beam.charge or chg

    if ws ~= chg then -- swap x <-> y
      ws, cx, cy, mx1, mx2, my1, my2 = -ws, cy, cx, my1, my2, mx1, mx2
    end

    local nx  = ca*x  + sa*y
    local npx = ca*px + sa*py
    local ny  = ca*y  - sa*x
    local npy = ca*py - sa*px

    x  = nx*cx  + npx*mx1
    px = nx*mx2 + npx*cx
    y  = ny*cy  + npy*my1
    py = ny*my2 + npy*cy

    m[i].x  = ca*x  - sa*y
    m[i].px = ca*px - sa*py
    m[i].y  = ca*y  + sa*x
    m[i].py = ca*py + sa*px
  end

  -- mdump('quad_tthick-1:', m)
end

function M.quad_kick (elm, m, lw) -- [KICKTKT7]                                 checked
  local el, tdir, beam, nmul, knl, ksl in m
  local l = el*lw
  local  bdir = beam.charge*tdir
  local _beta = 1/beam.beta

  drift_adj(l/2, m)

  -- mdump('quad_kick-0:', m, l)

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local  bdir = beam and beam.charge*tdir or bdir
    local _beta = beam and 1/beam.beta or _beta
    local    pz = sqrt(1 + (2*_beta)*pt + pt^2) - 1
    local bx,by = bxby(nmul, knl, ksl, x, y)

    m[i].px = px - l*bdir*(by - knl[2]*x)
    m[i].py = py + l*bdir*(bx - knl[2]*y)
  end

  -- mdump('quad_kick-1:', m)

  drift_adj(l/2, m)
end

function M.quad_tkick (elm, m, lw) -- [KICKTKT7]                                checked
  local el, tdir, beam, nmul, knl, ksl in m
  local l = el*lw
  local  bdir = beam.charge*tdir
  local _beta = 1/beam.beta

  drift_adj(l/2, m)

  -- mdump('quad_kick-0:', m, l)

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local  bdir = beam and beam.charge*tdir or bdir
    local _beta = beam and 1/beam.beta or _beta
    local    pz = sqrt(1 + (2*_beta)*pt + pt^2) - 1
    local bx,by = bxby(nmul, knl, ksl, x, y)

    m[i].px = px - l*bdir*(by - (knl[2]*x - ksl[2]*y))
    m[i].py = py + l*bdir*(bx - (knl[2]*y + ksl[2]*x))
  end

  -- mdump('quad_kick-1:', m)

  drift_adj(l/2, m)
end

M.quad_fringe = M.strex_fringe

-- TKT [INTER_SOL5] -----------------------------------------------------------o

function M.solen_thick (elm, m, lw) -- [KICK_SOLR]                              checked
  local el, ks, beam, T in m
  local l = el*lw
  local bsol = 0.5*ks*beam.charge
  local _beta = 1/beam.beta

--  mdump('solen_thick-0:', m, l)

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beta = beam and 1/beam.beta or _beta
    local  bsol = beam and 0.5*ks*beam.charge or bsol
    local    xp = px + bsol*y
    local    yp = py - bsol*x
    local  l_pz = l/sqrt(1 + 2*_beta*pt + pt^2 - xp^2 - yp^2)
    local   ang = l_pz*bsol

    local ca, sa, sc = cos(ang), sin(ang), sinc(ang)

    local xt  = ca*x  + l_pz*sc*px
    local pxt = ca*px - l_pz*sc*x *bsol^2
    local yt  = ca*y  + l_pz*sc*py
    local pyt = ca*py - l_pz*sc*y *bsol^2

    m[i].x  = ca*xt  + sa*yt
    m[i].px = ca*pxt + sa*pyt
    m[i].y  = ca*yt  - sa*xt
    m[i].py = ca*pyt - sa*pxt
    m[i].t  = t - (_beta+pt)*l_pz + (1-T)*l*_beta
  end

--  mdump('solen_thick-1:', m)
end

M.solen_kick   = M.strex_kick
M.solen_fringe = fnone -- TODO

-- rfcavity -------------------------------------------------------------------o

M.rfcav_thick = M.strex_drift

function M.rfcav_kick (elm, m, lw) -- [??]
  error("NYI")

-- missing input: tt, phase, phase0, ff, ph, a, r, nbessel, freq, volt, lag

--  local x, px, y, py, t, pt, bdir, nmul, knl, ksl in m
--  local volt, freq, lag, nbessel in elm
--
--  if freq == 0 then
--    error("Frequency number has to be defined for RF Cavity (i.e. harmon NYI) "
--          .. elm.name)
--  end
--
--  local pc = m.beam.pc
--  local omega = twopi*freq / clight
--  local vl    = bdir*l*volt*volt_c/pc
--  local df, f, r2 = 0, 1, 1
--
--  do i=1,nbessel
--    r2  = -r2*(ko*omega)^2/(4*(i+1)^2)
--    dr2 =  r2*i
--    df  =  df + 2*dr2
--    r2  =  r2*(x^2+y^2)
--    f   =  f + r2
--  end
--
--  local ff, ph = elm.f or {}, elm.ph or {}
--  local a , r  = elm.a or  0, elm.r or 0
--  local arg = omega*(t + tt) + phasе + ph + phase0
--
--  if nbessel > 0 then
--    m.px = px-x*ff[ko]* df * vl * cos(arg)/(omega)
--    m.py = py-y*ff[ko]* df * vl * cos(arg)/(omega)
--  end
--
--  m.pt = m.pt -ff*f*vl*sin(arg)
--
--  local lw = elm.l>0 and l/elm.l or 1
--  local bx, by = bxby(nmul, knl, ksl, x, y, lw)
--
--  m.px = m.px - ff[ko]*           bdir*by/pc*(a + r*cos(arg))
--  m.py = m.py + ff[ko]*           bdir*bx/pc*(a + r*cos(arg))
--  m.pt = m.pt + ff[ko]*(ko*omega)*bdir*by/pc*     r*sin(arg)

--[[ useful???
  by = -lw*knl[nmul] / fact(nmul-1) / nmul
  bx = -lw*ksl[nmul] / fact(nmul-1) / nmul

  for i=nmul-1,1,-1 do
    byt = x*by - y*bx - lw*knl[i] / fact(i-1) / i
    bx  = y*by + x*bx - lw*ksl[i] / fact(i-1) / i
    by  = byt
  end

  byt = x*by - y*bx
  bx  = y*by + x*bx
  by  = byt
]]
end

M.rfcav_fringe = fnone -- TODO

-------------------------------------------------------------------------------o
-------------------------------------------------------------------------------o

-- combined function magnets --------------------------------------------------o

-- TKT [INTER_TEAPOT] ---------------------------------------------------------o

function M.combi_thick (elm, m, l) -- [??]
 error("NYI")
  local k0, k1, l, angle in elm
  l, angle = l*lw, angle*lw
  if abs(k0*l-angle) < minang and abs(k1*l) < minang then
    return M.sbend_thick(elm, m, lw)
  end

  local _el   = 1/elm.l
  local _beta = 1/m.beam.beta
  local l_bet2_gam2 = l/(m.beam.gamma^2-1)

  local angle = elm.angle
  local lw    = l*_el
  local h     = lw*angle
  local hbar  = h*_beta

  local knl, bdir in m
  local k0, k1 = bdir*knl[1]*_el, bdir*knl[2]*_el
  local hk0pk1 = h*k0+k1
  local wx2, wy2 = abs(hk0pk1), abs(k1)
  local wx , wy  = sqrt(wx2), sqrt(wy2)

  local cx, sx, cy, sy
  if hk0pk1 < 0
  then cx, sx = cosh(wx*l), sinh(wx*l)/wx -- check wx == 0
  else cx, sx = cos (wx*l), sin (wx*l)/wx -- check wx == 0
  end
  if k1 < 0
  then cy, sy = cosh(wy*l), sinh(wy*l)/wy -- check wy == 0
  else cy, sy = cos (wy*l), sin (wy*l)/wy -- check wy == 0
  end

--  local npos in m
--  M.drift_adj(npos == 'last' and l or l/2, m)

  local x, px, y, py, t, pt in m
  local m16, m56 = (1-cx)/wx2, hbar^2*(l-sx)/wx2

  m.x  =      cx*x + sx*px + hbar*m16*pt + (h-k0)*m16
  m.px = -wx2*sx*x + cx*px + hbar*sx*pt  + (h-k0)*sx
  m.y  =      cy*y + sy*py
  m.py =  wy2*sy*y + cy*py
  m.t  = t - hbar*(sx*x+m16*px) + (l_bet2_gam2-m56)*pt

--  M.drift_adj(npos == 'first' and l or l/2, m)
end

function M.combi_kick (elm, m, l) -- [??]
  error("NYI")
end

M.combi_fringe = fnone

-- quadrupole with k0 and k1

function M.quad_hthick (elm, m, lw) -- [PUSHTKT7]                               unchecked
  error("NYI")
  local el, eld, eh, k0, k1, edir, sdir, tdir, npar, beam in m
  local chg, cx, cy, sx, sy, mx12, mx21, mx13, my12, my21, mx33

  local l = el*lw*sdir
  local h = eh*edir

--  mdump('quad_hthick-0:', m, l)

  for i=1,npar do
    local x, px, y, py, t, pt in m[i]
    local beam = m[i].beam or beam
    local h_b = h/beam.beta

    if chg ~= beam.charge then -- [GETMAT7]
      chg = beam.charge
      local bdir = tdir*chg
      local kx, ky = k1+h*k0, k1
      local wx = sqrt(abs(kx))*bdir
      local wy = sqrt(abs(ky))*bdir
      local wsx, wsy

      if kx*bdir*sdir < 0
      then cx, sx, wsx = cosh(wx*l), sinh(wx*l), -1
      else cx, sx, wsx = cos (wx*l), sin (wx*l),  1
      end
      if ky*bdir*sdir < 0
      then cy, sy, wsy = cos (wy*l), sin (wy*l), -1
      else cy, sy, wsy = cosh(wy*l), sinh(wy*l),  1
      end

      mx12, mx21, mx13 = sx/wx, -sx*wx*wsx, (1-cx  )/wx^2*wsx
      my12, my21, mx33 = sy/wy,  sy*wy*wsy, (l-mx21)/wx^2*wsx
    end

--[[ MATRIX REPRESENTATION FROM PTC [GETMAT7]
    { cx            , sx/wx                , h*(1-cx)/wx2*ws*_beta     ,
     -sx*wx*ws      , cx                   , h*sx/wx                   ,
      h*sx/wx*_beta , h*(1-cx)/wx2*ws*_beta, h^2*(l-sx/wx)/wx2*ws*_beta }
    { cy      , sy/wy, 0,
      sy*wy*ws, cy   , 0}
--]]

    local nx  = x*cx       + px*mx12     + pt*mx13*h_b
    local npx = x*mx21     + px*cx       + pt*mx12*h_b
    local ny  = y*cy       + py*my12
    local npy = y*my21     + py*cy
    local nt  = x*mx12*h_b + px*mx13*h_b + pt*mx33*h^2

    m[i].x   = nx
    m[i].y   = ny
    m[i].px  = npx
    m[i].py  = npy
    m[i].t   = t - nt
  end

--  mdump('quad_hthick-1:', m)
end

function M.quad_hkick (elm, m, lw) -- [KICKTKT7]                                unchecked
  error("NYI")
  local el, eh, edir, sdir, tdir, npar, nmul, knl, ksl in m
  local l = el*lw*sdir
  local h = eh*edir

  drift_adj(l/2, m)

--  mdump('quad_hkick-0:', m, l)

  for i=1,npar do
    local x, px, y, py, t, pt in m[i]
    local  beam = m[i].beam or m.beam
    local  bdir = beam.charge*tdir
    local _beta = 1/beam.beta
    local    pz = sqrt(1 + (2*_beta)*pt + pt^2) - 1
    local bx,by = bxby(nmul, knl, ksl, x, y)

    m[i].px = px + l*bdir*(h*(pz-pt*_beta) - (by - knl[1] - knl[2]*x))
    m[i].py = py + l*bdir*(                  (bx          - knl[2]*y))
    m[i].t  =  t - l*h*((pt+_beta)/(1+pz) - _beta)*x
  end

--  mdump('quad_hkick-1:', m)

  drift_adj(l/2, m)
end

-- fringes --------------------------------------------------------------------o

local function strex_fringe (elm, m, lw)  -- [??]  -- should be M.strex_fringe
  error("NYI")
--  mdump('strex_fringe-0:', m, m.eld*m.sdir*lw)

  local nmul, sdir in m
  if nmul == 0 then return end

  if pos == 'entry' then
    local e, h = elm.e1 or 0, elm.h1 or 0
    if sdir == 1 then
      yrotation    (elm, m, e)
      sbend_face   (elm, m, h)
      sbend_fringe (elm, m, 'entry')
    else
      sbend_fringe (elm, m, 'entry')
      sbend_face   (elm, m, h)
      yrotation    (elm, m, e)
    end
    mult_fringe    (elm, m, 'entry')
    straight_fringe(elm, m, 'entry')
    return
  end

  if pos == 'exit' then
    local e, h = elm.e2 or 0, elm.h2 or 0
    straight_fringe(elm, m, 'exit')
    mult_fringe    (elm, m, 'exit')
    if sdir == 1 then
      sbend_fringe (elm, m, 'exit')
      sbend_face   (elm, m, h)
      yrotation    (elm, m, e)
    else
      yrotation    (elm, m, e)
      sbend_face   (elm, m, h)
      sbend_fringe (elm, m, 'exit')
    end
    return
  end

  mdump('strex_fringe-1:', m)
end

local function curex_fringe (elm, m, lw) -- [??]  -- should be M.curex_fringe
  error("NYI")
--  mdump('curex_fringe-0:', m, m.eld*m.sdir*lw)

  if pos == 'entry' and not elm.kill_ent_fringe then
    local e, h = elm.e1 or 0, elm.h1 or 0
    if abs(e) < minang then
      sbend_face  (elm, m,  h)
      sbend_fringe(elm, m, 'entry')
    else
      yrotation   (elm, m,  e)
      sbend_face  (elm, m,  h)
      sbend_fringe(elm, m, 'entry')
      sbend_wedge (elm, m, -e)
    end
    return
  end

  if pos == 'exit' and not elm.kill_exi_fringe then
    local e, h = elm.e2 or 0, elm.h2 or 0
    if abs(e) < minang then
      sbend_fringe(elm, m, 'exit')
      sbend_face  (elm, m,  h)
    else
      sbend_wedge (elm, m, -e)
      sbend_fringe(elm, m, 'exit')
      sbend_face  (elm, m,  h)
      yrotation   (elm, m,  e)
    end
    return
  end

--  mdump('curex_fringe-1:', m)
end

function sbend_face (elm, m, h) -- [??]
  local x, px, y, py, t, pt, bdir in m
  local k0 = elm.k0 or 0
  local _beta = 1/m.beam.beta

  if bdir == 1 then -- to insure reversal symmetry ; horizontal wedge (only dir)
    px = px +(bdir*k0*h/2)*x^2
  end

  local ptt =        sqrt(1 + 2*pt*_beta + pt^2 - px^2)
  local xi  = bdir*sqrt(1 + 2*pt*_beta + pt^2)*k0*h/ptt^2
  local dxi_px   =  2*px*xi/ptt^2
  local dxi_ddel = -2*xi*(1 + pt)/ptt^2

  x  = x / (1-dxi_px*y^2)
  px = px - xi*y^2
  py = py - 2*xi*x*y
  t  = t  - dxi_ddel*x*y^2

  if(bdir == -1) then -- to insure reversal symmetry; horizontal wedge (only dir)
    px = px +(bdir*k0*h/2)*x^2
  end

  m.x  = x
  m.px = px
  m.py = py
  m.t  = t
end

function sbend_wedge (elm, m, e) -- [??]
  local x, px, y, py, t, pt, T, bdir in m
  local k0 = elm.k0 or 0
  local _beta = 1/m.beam.beta
  local b1 = bdir*k0
  local sa, ca, sa2 = sin(e), cos(e), sin(2*e)

  if b1 == 0 then
    yrot_track (elm, m, e) return
  end

  local pz  = sqrt(1 + 2*_beta*pt + pt^2 - px^2 - py^2)
  local ptt = sqrt(1 + 2*_beta*pt + pt^2        - py^2)
  local pxt = px*ca + (pz - b1*x)*sa
  local pzs = sqrt(1 + 2*_beta*pt + pt^2 - py^2 - pxt^2)
  local yt  = (e + asin(px/ptt) - asin(pxt/ptt)) / b1

  m.x  = x*ca + (x*px*sa2 + sa^2*(2*x*pz-b1*x^2)) / (pzs+pz*ca-px*sa)
  m.px = pxt
  m.y  = y + py * yt
  m.t  = t - yt*(_beta + pt)
end

function sbend_fringe (elm, m, pos) -- [??]
--  TODO: FINT and FINTX to have different FINT at entrance /exit
  local x, px, y, py, t, pt, T in m
  local k0   = elm.k0 or 0
  local _beta = 1/m.beam.beta
-- soft edge
  local fint = elm.fint or 0  -- fringe field integral at entrance and exit of the bend
  local hgap = elm.hgap or 0  -- half gap of the magnet
  local fsad = 0

  if fint*hgap ~= 0.0 then  -- soft edge
      fsad = 1/(fint*hgap*2)/36
  end

  local b = m.beam.charge*k0
  if pos == 'exit' then
     b = -b
  end

  local pz = sqrt(1 + 2*_beta*pt + pt^2 - px^2 - py^2)
  local time_fac = _beta + pt
  local rel_p    = sqrt(1 + 2*_beta*pt + pt^2)

  local c3=b^2*fsad/rel_p

  local xp, yp = px/pz or 0, py/pz or 0
  local d = matrix { -- to remove!
    { (1+xp^2) / pz, xp*yp    / pz, -time_fac*xp /pz^2 },
    {  xp*yp   / pz, (1+yp^2) / pz, -time_fac*yp /pz^2 },
    { -xp          ,   -yp        ,  time_fac    /pz   },
  }

  local fi0 = atan((xp/(1 + yp^2)))-2*b*fint*hgap*(1 + xp^2*(2 + yp^2))*pz
  local co2 = b/cos(fi0)^2
  local co1 = co2/(1 + (xp/(1 + yp^2))^2)

  local fi = {0, 0, 0}
  fi[1] =    co1 /       (1 + yp^2) - 2*co2*b*fint*hgap* (2*xp*(2 + yp^2)*pz)
  fi[2] =-2*co1*xp*yp/(1 + yp^2)^2  - 2*co2*b*fint*hgap* (2*xp^2*yp)*pz
  fi[3] =                           - 2*co2*b*fint*hgap* (1 + xp^2*(2 + yp^2))

  fi0=b*tan(fi0)

  b=0
  for i=1,3 do -- y column
    b=fi[i]*d:get(i,2) + b
  end
  m.y  = 2*m.y/(1 + sqrt(1 - 2*b*m.y))
  m.py = py - fi0*m.y

  b=0
  for i=1,3 do -- x column
    b=fi[i]*d:get(i,1) + b
  end
  m.x = m.x+0.5*b*m.y^2

  b=0
  for i=1,3 do -- z column
    b=fi[i]*d:get(i,3) + b
  end
  m.t = t + 0.5*b*m.y^2

  -- soft edge
  m.py = m.py - 4*c3*m.y^3
  m.t  = m.t  +   c3*m.y^4/rel_p^2*time_fac
end

function mult_fringe (elm, m) -- [??]
  local x, px, y, py, bdir, nmul, knl, ksl in m
  local _beta = 1/m.beam.beta
  local _l = 1/elm.l

  local rx, ix, fx, fy, fxx, fxy, fyx, fyy = 1, 0, 0, 0, 0, 0, 0, 0

	for i=1, nmul do
	  local drx, dix = rx, ix
    rx  = drx*x - dix*y
    ix  = drx*y + dix*x

    local ni, nf = -bdir/(4*(i+1)), i+2/i
    local lkn, lks = knl[i]*_l, ksl[i]*_l

    local u   =  ni*(lkn*rx  - lks*ix )
    local v   =  ni*(lkn*ix  + lks*rx )
    local du  =  ni*(lkn*drx - lks*dix)
    local dv  =  ni*(lkn*dix + lks*drx)
	  local dux =   i*du
    local dvx =   i*dv
    local duy =  -i*dv
    local dvy =   i*du

    fx  = fx  +   u*x + nf*       v*y
    fy  = fy  +   u*y - nf*       v*x
    fxx = fxx + dux*x + nf*     dvx*y + u
    fyy = fyy + duy*y - nf*     dvy*x + u
    fxy = fxy + duy*x + nf*(v + dvy*y)
    fyx = fyx + dux*y - nf*(v - dvx*x)
	end

  local _pz = 1/sqrt(1 + 2*pt*_beta + pt^2)
  local a = 1 - fxx*_pz
  local d = 1 - fyy*_pz
  local b =   - fyx*_pz
  local c =   - fxy*_pz
  local _det = 1/(a*d - b*c)

  m.x  = x - fx*_pz
  m.y  = y - fy*_pz
  m.px = (d*px - b*py)*_det
  m.py = (a*py - c*px)*_det
  m.t  = t + (_beta+pt)*(m.px*fx + m.py*fy)*_pz^3
end

function straight_fringe (elm, m) -- [??]
-- Lee-Whiting formula, E. Forest ch 13.2.3, eq 13.33
	local x, px, y, py, t, pt, T, bdir in m
  local k0   = elm.k0 or 0
  local _beta = 1/m.beam.beta
-- soft edge
  local fint = elm.fint or 0  -- fringe field integral at entrance and exit of the bend
  local hgap = elm.hgap or 0  -- half gap of the magnet

  local _pz  = 1/sqrt(1 + 2*_beta*pt + pt^2 )
  local time_fac = (_beta + pt)*_pz

  local a2, b2 = elm.ksl[2]/elm.l or 0, elm.knl[2]/elm.l or 0
  local b  = sqrt(b2^2 + a2^2)

  local f1 = -bdir*fint*abs(fint)*b*_pz/24.0
  local f2 =  hgap*b*_pz

  local ang=-atan2(a2,b2)/2

  srotation(-ang or 0, m)

  m.t = t - time_fac*(f1*x + f2*(1+f1/2)*px*_pz*exp(-f1))*px*_pz
          + time_fac*(f1*y + f2*(1-f1/2)*py*_pz*exp( f1))*py*_pz

  m.x = x*exp( f1) + px*f2*_pz
  m.y = y*exp(-f1) - py*f2*_pz

  m.px = px*exp(-f1)
  m.py = py*exp( f1)

  srotation(-ang or 0, m)
end

-- end ------------------------------------------------------------------------o
return { dynmap = M }
