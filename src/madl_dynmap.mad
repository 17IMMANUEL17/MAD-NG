--[=[
 o-----------------------------------------------------------------------------o
 |
 | Dynamic 6D maps
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: I. Shreyber, irina.tecker at cern.ch
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide a catalog of dynamical 6D maps (i.e. track)
    maps must have the following calling convention:
      dynmap(elm, map, length_weight)
    (see the symplectic integrators)
  - TODO: list the expected fields for elm and map

 o-----------------------------------------------------------------------------o
]=]

local M = {}

-- PTC variables:
-- L     thick weighted length
-- LD    thick weighted arc length
-- YL    kick  weighted length
-- B     relativistic beta0
-- B0    curvature = angle/LD
-- BN(1) k0
-- BN(2) k1
-- DIR   tracking direction

-- Note:
-- Is (_beta+pt) in t eq. shouldn't be sqrt((_beta+pt)^2 - (_beta*_gamma)^2) ??
-- is it a 1st order approximation?

-- locals ---------------------------------------------------------------------o

local vector, matrix                                             in MAD
local is_nil, is_number, is_damap                                in MAD.typeid
local minlen, minang, clight, twopi                              in MAD.constant
local printf                                                     in MAD.utility

local fnone                                                      in MAD.gfunc
local abs, sqrt, max, sin, cos, tan, asin, acos, atan, atan2,
      sinh, cosh, sinc                                           in MAD.gmath

-- debug ----------------------------------------------------------------------o

local shtfmt = "% -.6e % -.6e % -.6e % -.6e % -.6e % -.6e "
local lngfmt = "% -.16e % -.16e % -.16e % -.16e % -.16e % -.16e "
local mapfmt = lngfmt -- shtfmt

local function mdump (str, elm, m)
--  if false then return end

  local name = is_number(elm) and '"number"' or elm.name
  printf("%-15s %-15s ", name, str)
  if is_number(elm) then printf("% -.16e\n", elm) return end
  if m.npar == 0    then printf("no particle found\n") return end

  local X, R = m[1]

  if is_damap(X) then
    X, R = X:get0(), X:get1()
    printf(mapfmt, X[1], X[2], X[3], X[4], X[5], X[6])
  else
    printf(mapfmt, X.x, X.px, X.y, X.py, X.t, X.pt)
  end

  if R then
    for i=1,R.nrow do
      printf(mapfmt, R:get(i,1), R:get(i,2), R:get(i,3),
                     R:get(i,4), R:get(i,5), R:get(i,6))
    end
  end
  printf('\n')
end

-- field mutipoles ------------------------------------------------------------o

local function bxby (nmul, knl, ksl, x, y)
  local bx, by, byt = 0, 0

  for i=nmul,1,-1 do
    byt = by*x - bx*y + knl[i]
    bx  = by*y + bx*x + ksl[i]
    by  = byt
  end

  return bx, by
end

-- TODO: cur_bxby (nmul, knl, ksl, h, x, y) using TPSA (?)

-- patches (lw_ == 0 disable the patches) -------------------------------------o

-- X-rotation

local function xrotation (elm, m, lw_)  -- Rx(ax) [ROT_YZ]
  if lw_ == 0 then return end

  local ax = is_number(elm) and elm or elm.angle*m.tdir
  if abs(ax) < minang then return end

  local ax = ax*(lw_ or 1)
  local sa, ca, ta = sin(ax), cos(ax), tan(ax)
  local _beta = 1/m.beam.beta

  mdump('xrotation:0', elm, m)

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beta = beam and 1/beam.beta or _beta
    local    pz = sqrt(1 + (2*_beta)*pt + pt^2 - px^2 - py^2)
    local   _pz = 1/pz
    local   ptt = 1 - ta*py*_pz
    local  _ptt = y/ptt
    local  _pzt = ta*_pz*_ptt

    -- eq. 127 in Forest06
    m[i].y  = _ptt/ca
    m[i].py = ca*py + sa*pz
    m[i].x  = x + _pzt*px
    m[i].t  = t - _pzt*(_beta+pt)
  end

  mdump('xrotation:1', elm, m)
end

M.xrotation = xrotation

-- Y-rotation

local function yrotation (elm, m, lw_)  -- Ry(ay) [ROT_XZ]
  if lw_ == 0 then return end

  local ay = is_number(elm) and elm or elm.angle*m.tdir
  if abs(ay) < minang then return end

  local ay = ay*(lw_ or 1)
  local sa, ca, ta = sin(ay), cos(ay), tan(ay)
  local _beta = 1/m.beam.beta

  mdump('yrotation:0', elm, m)

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beta = beam and 1/beam.beta or _beta
    local    pz = sqrt(1 + (2*_beta)*pt + pt^2 - px^2 - py^2)
    local   _pz = 1/pz
    local   ptt = 1 - ta*px*_pz
    local  _ptt = x/ptt
    local  _pzt = ta*_pz*_ptt

    -- eq. 127 in Forest06
    m[i].x  = _ptt/ca
    m[i].px = ca*px + sa*pz
    m[i].y  = y + _pzt*py
    m[i].t  = t - _pzt*(_beta+pt)
  end

  mdump('yrotation:1', elm, m)
end

M.yrotation = yrotation

-- S-rotation

local function srotation (elm, m, lw_)  -- Rz(az) [ROT_XY]
  if lw_ == 0 then return end

  local az = is_number(elm) and elm or elm.angle*m.tdir
  if abs(az) < minang then return end

  local az = az*(lw_ or 1)
  local sa, ca = sin(az), cos(az)

  mdump('srotation:0', elm, m)

  for i=1,m.npar do
    local x, px, y, py in m[i]
    local nx  = ca*x  + sa*y
    local npx = ca*px + sa*py

    m[i].y    = ca*y  - sa*x
    m[i].py   = ca*py - sa*px
    m[i].x    = nx
    m[i].px   = npx
  end

  mdump('srotation:1', elm, m)
end

M.srotation = srotation

-- Translation

local function translate (elm, m, lw_) -- [TRANS]
  if lw_ == 0 then return end

  local dx, dy, ds = elm.dx or 0, elm.dy or 0, elm.ds or 0
  if abs(dx)+abs(dy)+abs(ds) < minlen then return end

  local tdir in m
  local lw = lw_ or 1
  local dx, dy = dx*lw*tdir, dy*lw*tdir

  mdump('translate:0', elm, m)

  if abs(ds) < minlen then
    for i=1,m.npar do
      local x, y in m[i]
      m[i].x = x - dx
      m[i].y = y - dy
    end
    return
  end

  -- ds is treated as a drift without correction for the time of flight
  local l = ds*lw*m.sdir
  local _beta = m.beam.beta
  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beta = beam and 1/beam.beta or _beta
    local l_pz = l/sqrt(1 + (2*_beta)*pt + pt^2 - px^2 - py^2)

    m[i].x = x - l_pz*px - dx
    m[i].y = y - l_pz*py - dy
    m[i].t = t + l_pz*(_beta+pt)
  end

  mdump('translate:1', elm, m)
end

M.translate = translate

-- Changeref (generic patch, lw_>0: RT, lw_<0: TR)

function M.changeref (elm, m, lw_)
  if lw_ == 0 then return end
  local lw = lw_ or 1

  local dx  , dy  , ds   = elm.dx     or 0, elm.dy   or 0, elm.ds   or 0
  local dthe, dphi, dpsi = elm.dtheta or 0, elm.dphi or 0, elm.dpsi or 0

  local trn = abs(dx  )+abs(dy  )+abs(ds  ) >= minlen
  local rot = abs(dthe)+abs(dphi)+abs(dpsi) >= minang

  if not (trn or rot) then return end

  mdump('changeref:0', elm, m)

  -- forward : x1' = R*x1+T
  -- backward: x1  = R^-1*(x1'-T)

  if lw > 0 then
      translate({dx=dx,dy=dy,ds=ds}, m, 1)
    if rot then
      yrotation({angle= dthe}, m, 1)
      xrotation({angle=-dphi}, m, 1)
      srotation({angle= dpsi}, m, 1)
    end
  else
    if rot then
      srotation({angle= dpsi}, m, -1)
      xrotation({angle=-dphi}, m, -1)
      yrotation({angle= dthe}, m, -1)
    end
      translate({dx=dx,dy=dy,ds=ds}, m, -1)
  end

  mdump('changeref:1', elm, m)
end

-- Changedir (reverse mflow t-direction)

function M.changedir (elm_, m, lw_)
  if lw_ == 0 then return end

  mdump('changedir:0', elm, m)

  m.edir = -m.edir
  m.tdir = -m.tdir

  mdump('changedir:1', elm, m)
end

-- Changenrj (change particles energy)

function M.changenrj (elm, m, lw_)  -- (option to reset pt?)
  if lw_ == 0 then return end

  local dnrj in elm
  if dnrj == 0 then return end

  local tdir, beam in m
  beam.energy = beam.energy + dnrj*tdir

  mdump('changenrj:0', elm, m)

  for i=1,m.npar do
    beam = m[i].beam
    if beam then
      beam.energy = beam.energy + dnrj*tdir
    end
  end

  mdump('changenrj:1', elm, m)
end

-- misalignments (lw_ == 0 disable the misalignments) -------------------------o

local T  = vector(3) -- misalignment translation
local R  = matrix(3) -- misalignment rotation
local Tb = vector(3) -- misalignment translation at exit (Tbar)
local Rb = matrix(3) -- misalignment rotation    at exit (Rbar)

local misalignexi -- forward declaration

-- Misalign (lw_>0: entry, lw_<0: exit)

local misalignexi

function M.misalign (elm, m, lw_)
  if lw_ == 0 then return end
  if (lw_ or 1) < 0 then return misalignexi(elm, m) end

  local dx  , dy  , ds   = elm.dx     or 0, elm.dy   or 0, elm.ds   or 0
  local dthe, dphi, dpsi = elm.dtheta or 0, elm.dphi or 0, elm.dpsi or 0

  local trn = abs(dx  )+abs(dy  )+abs(ds  ) >= minlen
  local rot = abs(dthe)+abs(dphi)+abs(dpsi) >= minang

  if not (trn or rot) then return end

  mdump('misalign:0', elm, m)

  local sdir, tdir in m

  -- misalignment at entry and local/global frames
  -- forward : x1' = R*x1+T
  -- backward: x1  = R^-1*(x1'-T)

  -- reuse patches without directions
  if sdir > 0 then
      translate({dx=dx*tdir,dy=dy*tdir,ds= ds}, m,  1)
    if rot then
      yrotation( dthe, m,  1)
      xrotation(-dphi, m,  1)
      srotation( dpsi, m,  1)
    end
  else
    if rot then
      srotation( dpsi, m, -1)
      xrotation(-dphi, m, -1)
      yrotation( dthe, m, -1)
    end
      translate({dx=dx*tdir,dy=dy*tdir,ds=-ds}, m, -1)
  end

  mdump('misalign:1', elm, m)
end

function misalignexi (elm, m)
  local dx  , dy  , ds   = elm.dx     or 0, elm.dy   or 0, elm.ds   or 0
  local dthe, dphi, dpsi = elm.dtheta or 0, elm.dphi or 0, elm.dpsi or 0

  local trn = abs(dx  )+abs(dy  )+abs(ds  ) >= minlen
  local rot = abs(dthe)+abs(dphi)+abs(dpsi) >= minang

  if not (trn or rot) then return end

  mdump('misalignexi:0', elm, m)

  local el, ang, tlt, sdir, tdir in m

  -- translation
  if trn then T:fill{dx, dy, ds} else T:zeros() end

  -- rotation
  if rot then R:rotzxy(-dphi, dthe, dpsi) end

  -- compute Rbar, Tbar
  _C.mad_mat_rtbar(Rb.data, Tb.data, abs(el), ang, tlt, rot and R.data or nil, T.data)

  -- misalignment at exit and local/global frames
  -- forward : x2  = Rb^-1*(x2'-Tb)
  -- backward: x2' = Rb*x2+Tb

  -- reuse patches without directions
  if sdir > 0 then
    if rot then
      local ax, ay, az = Rb:torotzxy()
      srotation(az, m, -1)
      xrotation(ax, m, -1)
      yrotation(ay, m, -1)
    end
      translate({dx=Tb[1]*tdir,dy=Tb[2]*tdir,ds= Tb[3]}, m, -1)
  else
      translate({dx=Tb[1]*tdir,dy=Tb[2]*tdir,ds=-Tb[3]}, m,  1)
    if rot then
      local ax, ay, az = Rb:torotzxy()
      yrotation(ay, m,  1)
      xrotation(ax, m,  1)
      srotation(az, m,  1)
    end
  end

  mdump('misalignexi:1', elm, m)
end

-- THIN -----------------------------------------------------------------------o

function M.thin_kick (elm, m, lw) -- [KICKT]                                    checked
  if m.nmul == 0 then return end

  local el, tdir, beam, nmul, knl, ksl in m
  local wchg  = lw*tdir*beam.charge
  local _beta = 1/beam.beta

  mdump('thin_kick:0', elm, m)

  local bend  = abs(knl[1])+abs(ksl[1]) >= minang

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local  wchg = beam and lw*tdir*beam.charge or wchg
    local _beta = beam and 1/beam.beta or _beta
    local bx,by = bxby(nmul, knl, ksl, x, y)

    m[i].px = px - wchg*(by - knl[1])
    m[i].py = py + wchg*(bx - ksl[1])

    -- dipole focusing and delta_p
    if bend then
      local dp = sqrt(1 + (2*_beta)*pt + pt^2) - 1
      m[i].px = m[i].px + (wchg*knl[1])*dp
      m[i].py = m[i].py + (wchg*ksl[1])*dp
      m[i].t  = t - wchg*(knl[1]*x - ksl[1]*y) * (_beta+pt)/(1+dp)

      if el ~= 0 then
        m[i].px = m[i].px - (knl[1]^2/el)*x
        m[i].py = m[i].py - (ksl[1]^2/el)*y
      end
    end
  end

  mdump('thin_kick:1', elm, m)
end

-- DKD [INTER_STREX] ----------------------------------------------------------o

function M.strex_drift (elm, m, lw) -- [DRIFT]                                  checked
  if abs(m.el) < minlen then return end

  local el, eld, beam, T in m
  local l, ld = el*lw, (eld or el)*lw
  local _beta = 1/beam.beta

  mdump('strex_drift:0', elm, m)

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beta = beam and 1/beam.beta or _beta
    local  l_pz = l/sqrt(1 + (2*_beta)*pt + pt^2 - px^2 - py^2)

    m[i].x = x + px*l_pz
    m[i].y = y + py*l_pz
    m[i].t = t - (_beta+pt)*l_pz + (1-T)*ld*_beta
  end

  mdump('strex_drift:1', elm, m)
end

function M.strex_kick (elm, m, lw, no_k0l) -- [KICKEX]                          checked
  if m.nmul == 0 then return end

  local tdir, beam, nmul, knl, ksl in m
  local wchg = lw*tdir*beam.charge
  local dby  = no_k0l == true and -knl[1] or 0

  mdump('strex_kick:0', elm, m)

  for i=1,m.npar do
    local x, px, y, py, beam in m[i]
    local wchg = beam and lw*tdir*beam.charge or wchg
    local bx,by = bxby(nmul, knl, ksl, x, y)

    m[i].px = px - wchg*(by+dby)
    m[i].py = py + wchg* bx
  end

  mdump('strex_kick:1', elm, m)
end

M.strex_fringe = fnone -- TODO: see below

-- DKD [KICKERS] --------------------------------------------------------------o

M.kicker_thick  = M.strex_drift
M.kicker_fringe = fnone

function M.kicker_kick (elm, m, lw)
  local hk, vk, tdir, beam in m
  local wchg = lw*tdir*beam.charge

  mdump('kicker_kick:0', elm, m)

  for i=1,m.npar do
    local px, py, beam in m[i]
    local wchg = beam and lw*tdir*beam.charge or wchg

    m[i].px = px + wchg*hk
    m[i].py = py + wchg*vk
  end

  mdump('kicker_kick:1', elm, m)
end

-- DKD [INTER_TEAPOT, l ~= 0, angle ~= 0] -------------------------------------o

function M.curex_drift (elm, m, lw) -- [SPROT]                                  checked
  local el, eld, eh, ang, beam, T in m
  local ld, ang = (eld or el)*lw, ang*lw   -- A = ang
  local rho, _beta = 1/eh, 1/beam.beta     -- R = rho

  mdump('curex_drift:0', elm, m)

  local sa, ca, ta, sa2 = sin(ang), cos(ang), tan(ang), sin(ang/2)

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beta = beam and 1/beam.beta or _beta
    local    pz = sqrt(1 + 2*_beta*pt + pt^2 - px^2 - py^2)
    local   _pz = 1/pz
    local   pxt = px*_pz
    local   ptt = (1 - ta*pxt)*ca
    local  _ptt = 1/ptt
    local   pst = (x+rho)*sa*_pz*_ptt

    m[i].x  = (x + rho*(2*sa2^2 + sa*pxt))*_ptt
    m[i].px = ca*px + sa*pz
    m[i].y  = y + pst*py
    m[i].t  = t - pst*(_beta+pt) + (1-T)*ld*_beta
  end

  mdump('curex_drift:1', elm, m)
end

function M.curex_kick (elm, m, lw, no_k0l) -- [SKICK]                           checked
  local eh, ang, tdir, beam, nmul, knl, ksl in m
  local bdir = beam.charge*tdir
  local wchg = bdir*lw
  local dby  = no_k0l == true and -knl[1] or knl[1]-ang*bdir

  mdump('curex_kick:0', elm, m)

  for i=1,m.npar do
    local x, px, y, py, beam in m[i]
    local wchg = beam and beam.charge*lw*tdir or wchg
    local bx, by = bxby(nmul, knl, ksl, x, y)

    -- TODO: should use TPSA in cur_bxby
    m[i].px = px - ((1+eh*x)*wchg)*(by+dby)
    m[i].py = py +           wchg * bx
  end

  mdump('curex_kick:1', elm, m)
end

-- TKT [INTER_TEAPOT, angle ~= 0] ---------------------------------------------o

function M.sbend_thick (elm, m, lw) -- [SSEC] A=ang, R=rho, BN(1)=k0            checked
  local el, eld, eh, ang, k0, beam, T in m
  local ld, ang, k0 = (eld or el)*lw, ang*lw, k0*m.edir
  local rho, _beta, k0q = 1/eh, 1/beam.beta, k0*beam.charge

  mdump('sbend_thick:0', elm, m)

  local sa, ca = sin(ang), cos(ang)

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beta = beam and 1/beam.beta or _beta
    local   k0q = beam and k0*beam.charge or k0q
    local  pw2 = 1 + 2*_beta*pt + pt^2 - py^2
    local   pz = sqrt(pw2 - px^2)                                      -- PZ
    local  pzx = pz - k0q*(rho+x)
    local  npx =  ca*px + sa*pzx                                       -- XN(2)
    local  dpx = -sa*px + ca*pzx                                       -- DPX'
    local  pzs = sqrt(pw2 - npx^2)                                     -- PZS
    local  ptt = sqrt(pw2)                                             -- PT
    local _ptt = 1/ptt
    local  dxs = (ang + asin(px*_ptt) - asin(npx*_ptt))/k0q            -- XN(3)

    -- eq. 126 in Forest06
    m[i].x  = (pzs-dpx)/k0q - rho                                      -- XN(1)
    m[i].px = npx                                                      -- XN(2)
    m[i].y  = y + dxs*py                                               -- XN(3)
    m[i].t  = t - dxs*(_beta+pt) + (1-T)*ld*_beta                      -- XN(6)
  end

  mdump('sbend_thick:1', elm, m)
end

M.sbend_kick   = \el,m,lw -> M.curex_kick  (el,m,lw,true)
M.sbend_fringe = \el,m,lw -> M.curex_fringe(el,m,lw)

-- TKT [INTER_STREX] ----------------------------------------------------------o

function M.rbend_thick (elm, m, lw) -- [SPAR]                                   checked
  local el, eld, k0, knl, beam, T in m
  local l, ld, k0 = el*lw, eld*lw, k0*m.edir
  local _beta, _k0q, k0lq = 1/beam.beta, 1/k0*beam.charge, knl[1]*beam.charge

  mdump('rbend_thick:0', elm, m)

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beta = beam and 1/beam.beta or _beta
    local _k0q  = beam and 1/(k0*beam.charge) or _k0q
    local  k0lq = beam and knl[1]*beam.charge or k0lq

    local  pw2 = 1 + 2*_beta*pt + pt^2 - py^2
    local   pz = sqrt(pw2 - px^2)
    local  ptt = sqrt(pw2)
    local _ptt = 1/ptt
    local  npx = px - k0lq
    local  pzs = sqrt(pw2 - npx^2)
    local   nx = x + (pzs-pz)*_k0q
    local  pzt = (asin(px*_ptt) - asin(npx*_ptt))*_k0q

    -- eq. 129 in Forest06
    m[i].x  = nx
    m[i].px = npx
    m[i].y  = y + pzt*py
    m[i].t  = t - pzt*(_beta+pt) + (1-T)*ld*_beta
  end

  mdump('rbend_thick:1', elm, m)
end

M.rbend_kick   = \el,m,lw -> M.strex_kick  (el,m,lw,true)
M.rbend_fringe = \el,m,lw -> M.strex_fringe(el,m,lw)

-- TKT [INTER_TKTF] -----------------------------------------------------------o

local function drift_adj (elm, m, l) -- [KICKPATH] drift adjustment                  checked
  local ca, sa, beam, T in m
  local _beta = 1/beam.beta

  mdump('drift_adj:0', elm, m)

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beta = beam and 1/beam.beta or _beta
    local l_pz = l/sqrt(1 + (2*_beta)*pt + pt^2 - px^2 - py^2)

    m[i].x = x + px*(l_pz-l)
    m[i].y = y + py*(l_pz-l)
    m[i].t = t - (_beta+pt)*l_pz + (1-T)*l*_beta
  end

  mdump('drift_adj:1', elm, m)
end

function M.quad_thick (elm, m, lw) -- [PUSHTKT7]                                checked
  local el, k1, ca, sa, edir, tdir, beam in m
  local l = el*lw
  local chg = beam.charge

  mdump('quad_thick:0', elm, m)

  -- [GETMAT7, h == 0]
  local ws = k1*edir < 0 and -1 or 1
  local w  = sqrt(abs(k1))*tdir*ws
  local cx, sx = cos (w*l), sin (w*l)
  local cy, sy = cosh(w*l), sinh(w*l)
  local mx1, mx2 = sx/w, -sx*w
  local my1, my2 = sy/w,  sy*w
-- [GETMAT7]

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local chg = beam and beam.charge or chg

    if ws ~= chg then -- swap x <-> y
      ws, cx, cy, mx1, mx2, my1, my2 = -ws, cy, cx, my1, my2, mx1, mx2
    end

    local nx  = x*cx  + px*mx1
    local npx = x*mx2 + px*cx
    local ny  = y*cy  + py*my1
    local npy = y*my2 + py*cy

    m[i].x  = nx
    m[i].px = npx
    m[i].y  = ny
    m[i].py = npy
  end

  mdump('quad_thick:1', elm, m)
end

function M.quad_tthick (elm, m, lw) -- [PUSHTKT7]                               checked
  local el, k1, ca, sa, edir, tdir, beam in m
  local l = el*lw
  local chg = beam.charge

  mdump('quad_tthick:0', elm, m)

  -- [GETMAT7, h == 0]
  local ws = k1*edir < 0 and -1 or 1
  local w  = sqrt(abs(k1))*tdir*ws
  local cx, sx = cos (w*l), sin (w*l)
  local cy, sy = cosh(w*l), sinh(w*l)
  local mx1, mx2 = sx/w, -sx*w
  local my1, my2 = sy/w,  sy*w
-- [GETMAT7]

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local chg = beam and beam.charge or chg

    if ws ~= chg then -- swap x <-> y
      ws, cx, cy, mx1, mx2, my1, my2 = -ws, cy, cx, my1, my2, mx1, mx2
    end

    local nx  = ca*x  + sa*y
    local npx = ca*px + sa*py
    local ny  = ca*y  - sa*x
    local npy = ca*py - sa*px

    x  = nx*cx  + npx*mx1
    px = nx*mx2 + npx*cx
    y  = ny*cy  + npy*my1
    py = ny*my2 + npy*cy

    m[i].x  = ca*x  - sa*y
    m[i].px = ca*px - sa*py
    m[i].y  = ca*y  + sa*x
    m[i].py = ca*py + sa*px
  end

  mdump('quad_tthick:1', elm, m)
end

function M.quad_kick (elm, m, lw, ii) -- [KICKTKT7]                             checked
  local el, tdir, beam, nmul, knl, ksl in m
  local l = el*lw
  local  bdir = beam.charge*tdir
  local _beta = 1/beam.beta

--  drift_adj(elm, m, l/2)
  if ii >= 0 then drift_adj(elm, m, ii == 0 and l/2 or l) end

  mdump('quad_kick:0', elm, m)

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local  bdir = beam and beam.charge*tdir or bdir
    local _beta = beam and 1/beam.beta or _beta
    local    pz = sqrt(1 + (2*_beta)*pt + pt^2) - 1
    local bx,by = bxby(nmul, knl, ksl, x, y)

    m[i].px = px - l*bdir*(by - knl[2]*x)
    m[i].py = py + l*bdir*(bx - knl[2]*y)
  end

  mdump('quad_kick:1', elm, m)

  -- drift_adj(elm, m, l/2)
  if ii <= 0 then drift_adj(elm, m, ii == 0 and l/2 or l) end
end

function M.quad_tkick (elm, m, lw, ii) -- [KICKTKT7]                            checked
  local el, tdir, beam, nmul, knl, ksl in m
  local l = el*lw
  local  bdir = beam.charge*tdir
  local _beta = 1/beam.beta

--  drift_adj(elm, m, l/2)
  if ii >= 0 then drift_adj(elm, m, ii == 0 and l/2 or l) end

  mdump('quad_tkick:0', elm, m)

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local  bdir = beam and beam.charge*tdir or bdir
    local _beta = beam and 1/beam.beta or _beta
    local    pz = sqrt(1 + (2*_beta)*pt + pt^2) - 1
    local bx,by = bxby(nmul, knl, ksl, x, y)

    m[i].px = px - l*bdir*(by - (knl[2]*x - ksl[2]*y))
    m[i].py = py + l*bdir*(bx - (knl[2]*y + ksl[2]*x))
  end

  mdump('quad_tkick:1', elm, m)

  -- drift_adj(elm, m, l/2)
  if ii <= 0 then drift_adj(elm, m, ii == 0 and l/2 or l) end
end

M.quad_fringe = \el,m,lw -> M.strex_fringe(el,m,lw)

-- TKT [INTER_SOL5] -----------------------------------------------------------o

function M.solen_thick (elm, m, lw) -- [KICK_SOLR]                              checked
  local el, ks, beam, T in m
  local l = el*lw
  local bsol = 0.5*ks*beam.charge
  local _beta = 1/beam.beta

  mdump('solen_thick:0', elm, m)

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beta = beam and 1/beam.beta or _beta
    local  bsol = beam and 0.5*ks*beam.charge or bsol
    local    xp = px + bsol*y
    local    yp = py - bsol*x
    local  l_pz = l/sqrt(1 + 2*_beta*pt + pt^2 - xp^2 - yp^2)
    local   ang = l_pz*bsol

    local ca, sa, sc = cos(ang), sin(ang), sinc(ang)

    local lsc = l_pz*sc
    local xt  = ca*x  + lsc*px
    local pxt = ca*px - lsc*x *bsol^2
    local yt  = ca*y  + lsc*py
    local pyt = ca*py - lsc*y *bsol^2

    m[i].x  = ca*xt  + sa*yt
    m[i].px = ca*pxt + sa*pyt
    m[i].y  = ca*yt  - sa*xt
    m[i].py = ca*pyt - sa*pxt
    m[i].t  = t - (_beta+pt)*l_pz + (1-T)*l*_beta
  end

  mdump('solen_thick:1', elm, m)
end

M.solen_kick   = M.strex_kick
M.solen_fringe = fnone -- TODO

-- rfcavity [INTER_CAV4] ------------------------------------------------------o

M.rfcav_thick = M.strex_drift

function M.rfcav_kick (elm, m, lw) -- [KICKCAVR, FEVAL_CAVR?]
  local volt, freq, lag, tdir, beam in m
  local omega = freq*(twopi*1e6/clight)
  local phase = lag * twopi
  local _pc   = 1/beam.pc
  local chg   = beam.charge
  local vl    = lw*chg*tdir*volt*1e-3

--  print('vl=', vl*_pc, 'omega=', omega, 'phase=', phase, 'p0c=', beam.pc, 'yl=', el*lw)

  mdump('rfcav_kick:0', elm, m)

  for i=1,m.npar do
    local t, pt, beam in m[i]
    local _pc = beam and 1/beam.charge      or _pc
    local  vl = beam and vl*chg*beam.charge or  vl
    local dpt = vl*_pc*sin(phase - omega*t)

--    print('pt=', m[i].pt, 'dpt=', dpt)

    m[i].pt = pt + dpt
  end

  mdump('rfcav_kick:1', elm, m)
end

function M.rfcav_kickn (elm, m, lw) -- [KICKCAVR]
  local volt, freq, lag, tdir, nbsl, nmul, knl, ksl, beam in m
  local omega = freq*(twopi/clight*1e6)
  local phase = lag * twopi
  local _pc   = 1/beam.pc
  local chg   = beam.charge
  local bdir  = lw*chg*tdir
  local vl    = bdir*volt*1e-3

  mdump('rfcav_kickn:0', elm, m)

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local ph = phase - omega*t
    local sa, ca = sin(ph), cos(ph)

    local _pc, vl, bdir = _pc, vl, bdir
    if beam then
      _pc, vl, bdir = 1/beam.pc, vl*chg*beam.charge, bdir*chg*beam.charge
    end

    -- single mode (ko=1)
    local df, f, r2 = 0, 1, 1

    -- bessel modes
    if nbsl > 0 then
      for i=1,nbsl do
        r2 = -r2*omega^2/(4*(i+1)^2)
        df =  df + 2*r2*i
        r2 =  r2*(x^2+y^2)
        f  =  f + r2
      end

      local c1 = df*vl*_pc*ca/omega

      px = px - x*c1
      py = py - y*c1
    end

    -- kick
    pt = pt + f*vl*_pc*sa

    if nmul > 0 then
      local bx,by,byt = bxby(nmul, knl, ksl, x, y)

      px = px - bdir* by*_pc *ca
      py = py + bdir* bx*_pc *ca

      by = -knl[nmul]/nmul
      bx = -ksl[nmul]/nmul

      for i=nmul-1,1,-1 do
        byt = x*by - y*bx - knl[i]/i
        bx  = y*by + x*bx - ksl[i]/i
        by  = byt
      end
      byt = x*by - y*bx -- extra terms?
      bx  = y*by + x*bx
      by  = byt

      pt = pt + omega*bdir* by*_pc *sa
    end

    m[i].px = px
    m[i].py = py
    m[i].pt = pt
  end

  mdump('rfcav_kickn:1', elm, m)
end

function M.rfcav_fringe (elm, m, lw_) -- [ADJUST_TIME_CAV4 only, no FRINGECAV]
  if lw_ == 0 then return end
  local lw = lw_ or 1

  local sdir in m

  mdump('rfcav_fringe:0', elm, m)

  if sdir*lw == 1 then
-- print(lw == 1 and 'forward entry' or 'backward exit')  -- mdump('+0:', m)
    -- TODO: FRINGECAV
    assert(m.Tbak == nil, "inconsistent totalpath when entering rfcavity")
    m.Tbak, m.T = m.T, 1
  end

  if lw == -1 and m.Tbak ~= m.T then
    local dt = (m.T-m.Tbak)*m.el / m.beam.beta
    for i=1,m.npar do
      m[i].t = m[i].t + dt
    end
--    print('rfcav-1: total path compensated')
  end

  if sdir*lw == -1 then
-- print(lw == -1 and 'forward exit' or 'backward entry')  -- mdump('+0:', m)
    m.T, m.Tbak = m.Tbak, nil
    -- TODO: FRINGECAV
  end

  mdump('rfcav_fringe:1', elm, m)
end

-------------------------------------------------------------------------------o
-------------------------------------------------------------------------------o

-- combined function magnets --------------------------------------------------o

-- TKT [INTER_TEAPOT] ---------------------------------------------------------o

function M.combi_thick (elm, m, l) -- [??]
 error("NYI")
  local k0, k1, l, angle in elm
  l, angle = l*lw, angle*lw
  if abs(k0*l-angle) < minang and abs(k1*l) < minang then
    return M.sbend_thick(elm, m, lw)
  end

  mdump('combi_thick:0', elm, m)

  local _el   = 1/elm.l
  local _beta = 1/m.beam.beta
  local l_bet2_gam2 = l/(m.beam.gamma^2-1)

  local angle = elm.angle
  local lw    = l*_el
  local h     = lw*angle
  local hbar  = h*_beta

  local knl, bdir in m
  local k0, k1 = bdir*knl[1]*_el, bdir*knl[2]*_el
  local hk0pk1 = h*k0+k1
  local wx2, wy2 = abs(hk0pk1), abs(k1)
  local wx , wy  = sqrt(wx2), sqrt(wy2)

  local cx, sx, cy, sy
  if hk0pk1 < 0
  then cx, sx = cosh(wx*l), sinh(wx*l)/wx -- check wx == 0
  else cx, sx = cos (wx*l), sin (wx*l)/wx -- check wx == 0
  end
  if k1 < 0
  then cy, sy = cosh(wy*l), sinh(wy*l)/wy -- check wy == 0
  else cy, sy = cos (wy*l), sin (wy*l)/wy -- check wy == 0
  end

--  local npos in m
--  drift_adj(elm, m, l/2)

  local x, px, y, py, t, pt in m
  local m16, m56 = (1-cx)/wx2, hbar^2*(l-sx)/wx2

  m.x  =      cx*x + sx*px + hbar*m16*pt + (h-k0)*m16
  m.px = -wx2*sx*x + cx*px + hbar*sx*pt  + (h-k0)*sx
  m.y  =      cy*y + sy*py
  m.py =  wy2*sy*y + cy*py
  m.t  = t - hbar*(sx*x+m16*px) + (l_bet2_gam2-m56)*pt

--  drift_adj(elm, m, l/2)

  mdump('combi_thick:1', elm, m)
end

function M.combi_kick (elm, m, l) -- [??]
  error("NYI")
  mdump('combi_kick:0', elm, m)
  mdump('combi_kick:1', elm, m)
end

M.combi_fringe = fnone

-- quadrupole with k0 and k1

function M.quad_hthick (elm, m, lw) -- [PUSHTKT7]                               unchecked
  error("NYI")
  local el, eld, eh, k0, k1, edir, sdir, tdir, npar, beam in m
  local chg, cx, cy, sx, sy, mx12, mx21, mx13, my12, my21, mx33

  local l = el*lw*sdir
  local h = eh*edir

  mdump('quad_hthick:0', elm, m)

  for i=1,npar do
    local x, px, y, py, t, pt in m[i]
    local beam = m[i].beam or beam
    local h_b = h/beam.beta

    if chg ~= beam.charge then -- [GETMAT7]
      chg = beam.charge
      local bdir = tdir*chg
      local kx, ky = k1+h*k0, k1
      local wx = sqrt(abs(kx))*bdir
      local wy = sqrt(abs(ky))*bdir
      local wsx, wsy

      if kx*bdir*sdir < 0
      then cx, sx, wsx = cosh(wx*l), sinh(wx*l), -1
      else cx, sx, wsx = cos (wx*l), sin (wx*l),  1
      end
      if ky*bdir*sdir < 0
      then cy, sy, wsy = cos (wy*l), sin (wy*l), -1
      else cy, sy, wsy = cosh(wy*l), sinh(wy*l),  1
      end

      mx12, mx21, mx13 = sx/wx, -sx*wx*wsx, (1-cx  )/wx^2*wsx
      my12, my21, mx33 = sy/wy,  sy*wy*wsy, (l-mx21)/wx^2*wsx
    end

--[[ MATRIX REPRESENTATION FROM PTC [GETMAT7]
    { cx            , sx/wx                , h*(1-cx)/wx2*ws*_beta     ,
     -sx*wx*ws      , cx                   , h*sx/wx                   ,
      h*sx/wx*_beta , h*(1-cx)/wx2*ws*_beta, h^2*(l-sx/wx)/wx2*ws*_beta }
    { cy      , sy/wy, 0,
      sy*wy*ws, cy   , 0}
--]]

    local nx  = x*cx       + px*mx12     + pt*mx13*h_b
    local npx = x*mx21     + px*cx       + pt*mx12*h_b
    local ny  = y*cy       + py*my12
    local npy = y*my21     + py*cy
    local nt  = x*mx12*h_b + px*mx13*h_b + pt*mx33*h^2

    m[i].x   = nx
    m[i].y   = ny
    m[i].px  = npx
    m[i].py  = npy
    m[i].t   = t - nt
  end

  mdump('quad_hthick:1', elm, m)
end

function M.quad_hkick (elm, m, lw) -- [KICKTKT7]                                unchecked
  error("NYI")
  local el, eh, edir, sdir, tdir, nmul, knl, ksl in m
  local l = el*lw*sdir
  local h = eh*edir

  drift_adj(elm, m, l/2)

  mdump('quad_hkick:0', elm, m)

  for i=1,m.npar do
    local x, px, y, py, t, pt in m[i]
    local  beam = m[i].beam or m.beam
    local  bdir = beam.charge*tdir
    local _beta = 1/beam.beta
    local    pz = sqrt(1 + (2*_beta)*pt + pt^2) - 1
    local bx,by = bxby(nmul, knl, ksl, x, y)

    m[i].px = px + l*bdir*(h*(pz-pt*_beta) - (by - knl[1] - knl[2]*x))
    m[i].py = py + l*bdir*(                  (bx          - knl[2]*y))
    m[i].t  =  t - l*h*((pt+_beta)/(1+pz) - _beta)*x
  end

  mdump('quad_hkick:1', elm, m)

  drift_adj(elm, m, l/2)
end

-- fringes --------------------------------------------------------------------o

 -- forward declarations
local sbend_face, sbend_wedge, sbend_fringe, mad8_wedge, mult_fringe, stra_fringe

local function strex_fringe (elm, m, lw)  -- [FRINGE_STREX]
  if lw_ == 0 then return end
  local lw = lw_ or 1

  if m.nmul == 0 then return end

  mdump('strex_fringe:0', elm, m)

  if lw == 1 then
    local e1, h1 = elm.e1 or 0, elm.h1 or 0
    yrotation   ( e1, m,  1)
    sbend_face  ( h1, m,  1)
    sbend_fringe(elm, m,  1)
    mult_fringe (elm, m,  1)
    stra_fringe (elm, m,  1)
  else
    local e2, h2 = elm.e2 or 0, elm.h2 or 0
    stra_fringe (elm, m, -1)
    mult_fringe (elm, m, -1)
    sbend_fringe(elm, m, -1)
    sbend_face  ( h2, m, -1)
    yrotation   ( e2, m, -1)
  end

  mdump('strex_fringe:1', elm, m)
end

function M.curex_fringe (elm, m, lw_) -- [FRINGE_TEAPOT]
  if lw_ == 0 then return end
  local lw = lw_ or 1

  if m.nmul == 0 then return end -- switched off

  mdump('curex_fringe:0', elm, m)

  local sdir, tdir in m

  local frngfld, fh, h, e = fnone
  if lw == 1 then
--print('e1, h1, fint')
    e, h = m.e1, (elm.h1 or 0)*tdir
    if not elm.kill_ent_fringe then
      fh, frngfld = (elm.hgap or 0)*(elm.fint or 0.5)*sdir, sbend_fringe
    end
  else
--print('e2, h2, fintx')
    e, h = m.e2, (elm.h2 or 0)*tdir
    if not elm.kill_exi_fringe then
      fh, frngfld = (elm.hgap or 0)*(elm.fintx or elm.fint or 0.5)*sdir, sbend_fringe
    end
  end

  if sdir*lw == 1 then
-- print(lw == 1 and 'forward entry' or 'backward exit')  -- mdump('+0:', m)
    yrotation  ( e, m,  1)                                -- mdump('+1:', m)
    sbend_face ( h, m,  1)                                -- mdump('+2:', m)
    frngfld    (fh, m,  1)                                -- mdump('+3:', m)
    mad8_wedge ( e, m,  1)                                -- mdump('+4:', m)
    sbend_wedge(-e, m,  1)                                -- mdump('+5:', m)
  else
-- print(lw == -1 and 'forward exit' or 'backward entry') -- mdump(':0', m)
    sbend_wedge(-e, m, -1)                                -- mdump(':1', m)
    mad8_wedge ( e, m, -1)                                -- mdump('-2:', m)
    frngfld    (fh, m, -1)                                -- mdump('-3:', m)
    sbend_face ( h, m, -1)                                -- mdump('-4:', m)
    yrotation  (-e, m, -1)                                -- mdump('-5:', m)
  end

  mdump('curex_fringe:1', elm, m)
end

function M.dipeg_fringe (elm, m, lw_) -- [MADX dipedge]                         unchecked
  if lw_ == 0  or abs(m.k0) < minang then return end
  local lw = lw_ or 1

  mdump('dipeg_fringe:0', elm, m)

  local k0, edir, tdir, beam in m
  local fh, e = 0 -- fringe field integral, pole face angle

  if lw == 1 then
    e = m.e1
    if not elm.kill_ent_fringe then
      fh = (elm.hgap or 0)*(elm.fint or 0.5)
    end
  else
    e = m.e2
    if not elm.kill_exi_fringe then
      fh = (elm.hgap or 0)*(elm.fintx or elm.fint or 0.5)
    end
  end

  local corr = k0^2*fh

  if abs(e)+abs(corr) < minang then return end

  local chg  = beam.charge
  local k0   = k0*edir
  local psip = e - corr/cos(e)*(1+sin(e)^2)
  local r21  =  k0 * tan(e)
  local r43  = -k0 * tan(psip)

  for i=1,m.npar do
    local x, px, y, py, beam in m[i]
    local chg = beam and beam.charge or chg

    m[i].px = px + chg*r21*x
    m[i].py = py + chg*r43*y
  end

  mdump('dipeg_fringe:1', elm, m)
end

-- fringes helpers ------------------------------------------------------------o

function sbend_face (h, m, lw) -- [NEWFACE]
  local k0, edir, beam in m
  local k0 = k0*h/2*edir

  if abs(k0) < minang then return end

  mdump('sbend_face:0', h, m)

  local _beta = 1/beam.beta
  local chg = beam.charge

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beta = beam and 1/beam.beta or _beta
    local chg   = beam and beam.charge or chg

    if lw == 1 then -- to insure reversal symmetry ; horizontal wedge (only dir)
      px = px + chg*k0*x^2
    end

    local dpp      =  1 + 2*pt*_beta + pt^2
    local _pt2     =  1/(dpp - px^2)
    local xi       =  2*k0*lw*sqrt(dpp)*_pt2
    local dxi_px   =  2*px*xi          *_pt2
    local dxi_ddel = -2   *xi*(1+pt)   *_pt2

    x  = x / (1-dxi_px*y^2)
    px = px - xi*y^2
    py = py - 2*xi*x*y
    t  = t  - dxi_ddel*x*y^2

    if lw == -1 then -- to insure reversal symmetry; horizontal wedge (only dir)
      px = px - chg*k0*x^2
    end

    m[i].x  = x
    m[i].px = px
    m[i].py = py
    m[i].t  = t
  end

  mdump('sbend_face:1', h, m)
end

function mad8_wedge (e, m, lw) -- [FRINGE_TEAPOT]
  local k1, edir, beam in m
  if abs(k1*e) < minang then return end

  mdump('mad8_wedge:0', e, m)

  local k1e = k1*e * edir*beam.charge
  for i=1,m.npar do
    local x, px, y, py in m[i]
    m[i].px = px + k1e*(x^2-y^2)
    m[i].py = py - k1e*(2*x*y)
  end

  mdump('mad8_wedge:1', e, m)
end

function sbend_wedge (e, m, lw) -- [WEDGE]
  if abs(e) < minang then return end

  local k0, edir, beam in m
  if abs(k0) < minang then
    return yrotation(e, m, lw)
  end

  mdump('sbend_wedge:0', e, m)

  local _beta = 1/beam.beta
  local b1 = k0*edir*beam.charge
  local sa, ca, sa2 = sin(e), cos(e), sin(2*e)

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beta = beam and 1/beam.beta or _beta

    local pzy = 1 + 2*_beta*pt + pt^2 - py^2
    local pz  = sqrt(pzy - px^2)
    local pxt = px*ca + (pz - b1*x)*sa
    local pzs = sqrt(pzy - pxt^2)
    local _zy = 1/sqrt(pzy)
    local yt  = (e + asin(px*_zy) - asin(pxt*_zy)) / b1

    m[i].x  = x*ca + x*(px*sa2 + sa^2*(2*pz - b1*x)) / (pzs + pz*ca - px*sa)
    m[i].px = pxt
    m[i].y  = y + py * yt
    m[i].t  = t - yt*(_beta + pt)
  end

  mdump('sbend_wedge:1', e, m)
end

function sbend_fringe (fh, m, lw) -- [FRINGE_DIPOLE]
  local k0, edir, beam in m
  if abs(fh)+abs(k0) < minang then return end

  local  fsad = abs(fh) ~= 0 and 1/(2*36*fh) or 0
  local  b0   = edir*beam.charge*k0*lw
  local _beta = 1/beam.beta

  mdump('sbend_fringe:0', fh, m)

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beta = beam and 1/beam.beta or _beta
    local b0 = beam and edir*beam.charge*k0*lw or b0

    local dpp = 1 + 2*_beta*pt + pt^2
    local  pz = sqrt(dpp - px^2 - py^2)
    local _pz = 1/pz
    local relp = 1/sqrt(dpp)
    local tfac = -(_beta + pt)

    local c2 = b0*fh*2
    local c3 = b0^2*fsad*relp

    local xp,  yp  = px/pz, py/pz
    local xyp, yp2 = xp*yp, 1+yp^2
    local xp2,_yp2 = xp^2 , 1/yp2

    -- many of the terms below are very small, i.e. have negligible effect...

    local fi0 = atan((xp*_yp2)) - c2*(1 + xp2*(1+yp2))*pz
    local co2 = b0/cos(fi0)^2
    local co1 = co2/(1 + (xp*_yp2)^2)*_yp2
    local co3 = co2*c2

    local fi1 =    co1          - co3*2*xp*(1+yp2)*pz
    local fi2 = -2*co1*xyp*_yp2 - co3*2*xp*xyp    *pz
    local fi3 =                 - co3*(1 + xp2*(1+yp2))

    local kx = fi1*(1+xp2)*_pz   + fi2*xyp*_pz       - fi3*xp
    local ky = fi1*xyp*_pz       + fi2*yp2*_pz       - fi3*yp
    local kz = fi1*tfac*xp*_pz^2 + fi2*tfac*yp*_pz^2 - fi3*tfac*_pz

    y = 2*y / (1 + sqrt(1-2*ky*y))
    x = x + 0.5*kx*y^2
    t = t + 0.5*kz*y^2
    py = py - b0*tan(fi0)*y

    -- soft edge (negligible?)
    py = py - 4*c3*y^3
    t  = t  +   c3*y^4*relp^2*tfac

    m[i].x  = x
    m[i].y  = y
    m[i].py = py
    m[i].t  = t
  end

  mdump('sbend_fringe:1', fh, m)
end

!! --- TODO -------------------------------------------------------------------o

function mult_fringe (elm, m) -- [??]
  local x, px, y, py, bdir, nmul, knl, ksl in m
  local _beta = 1/m.beam.beta
  local _l = 1/elm.l

  mdump('mult_fringe:0', elm, m)

  local rx, ix, fx, fy, fxx, fxy, fyx, fyy = 1, 0, 0, 0, 0, 0, 0, 0

	for i=1, nmul do
	  local drx, dix = rx, ix
    rx  = drx*x - dix*y
    ix  = drx*y + dix*x

    local ni, nf = -bdir/(4*(i+1)), i+2/i
    local lkn, lks = knl[i]*_l, ksl[i]*_l

    local u   =  ni*(lkn*rx  - lks*ix )
    local v   =  ni*(lkn*ix  + lks*rx )
    local du  =  ni*(lkn*drx - lks*dix)
    local dv  =  ni*(lkn*dix + lks*drx)
	  local dux =   i*du
    local dvx =   i*dv
    local duy =  -i*dv
    local dvy =   i*du

    fx  = fx  +   u*x + nf*       v*y
    fy  = fy  +   u*y - nf*       v*x
    fxx = fxx + dux*x + nf*     dvx*y + u
    fyy = fyy + duy*y - nf*     dvy*x + u
    fxy = fxy + duy*x + nf*(v + dvy*y)
    fyx = fyx + dux*y - nf*(v - dvx*x)
	end

  local _pz = 1/sqrt(1 + 2*pt*_beta + pt^2)
  local a = 1 - fxx*_pz
  local d = 1 - fyy*_pz
  local b =   - fyx*_pz
  local c =   - fxy*_pz
  local _det = 1/(a*d - b*c)

  m.x  = x - fx*_pz
  m.y  = y - fy*_pz
  m.px = (d*px - b*py)*_det
  m.py = (a*py - c*px)*_det
  m.t  = t + (_beta+pt)*(m.px*fx + m.py*fy)*_pz^3

  mdump('mult_fringe:1', elm, m)
end

function stra_fringe (elm, m) -- [??]
-- Lee-Whiting formula, E. Forest ch 13.2.3, eq 13.33
	local x, px, y, py, t, pt, T, bdir in m
  local k0   = elm.k0 or 0
  local _beta = 1/m.beam.beta

  mdump('stra_fringe:0', elm, m)

-- soft edge
  local fint = elm.fint or 0  -- fringe field integral at entrance and exit of the bend
  local hgap = elm.hgap or 0  -- half gap of the magnet

  local _pz  = 1/sqrt(1 + 2*_beta*pt + pt^2 )
  local time_fac = (_beta + pt)*_pz

  local a2, b2 = elm.ksl[2]/elm.l or 0, elm.knl[2]/elm.l or 0
  local b  = sqrt(b2^2 + a2^2)

  local f1 = -bdir*fint*abs(fint)*b*_pz/24.0
  local f2 =  hgap*b*_pz

  local ang=-atan2(a2,b2)/2

  srotation(-ang or 0, m)

  m.t = t - time_fac*(f1*x + f2*(1+f1/2)*px*_pz*exp(-f1))*px*_pz
          + time_fac*(f1*y + f2*(1-f1/2)*py*_pz*exp( f1))*py*_pz

  m.x = x*exp( f1) + px*f2*_pz
  m.y = y*exp(-f1) - py*f2*_pz

  m.px = px*exp(-f1)
  m.py = py*exp( f1)

  srotation(-ang or 0, m)

  mdump('stra_fringe:1', elm, m)
end

-- end ------------------------------------------------------------------------o
return { dynmap = M }
