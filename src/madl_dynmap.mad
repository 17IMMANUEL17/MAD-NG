--[=[
 o-----------------------------------------------------------------------------o
 |
 | Dynamic 6D maps
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: I. Shreyber, irina.tecker at cern.ch
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide a catalog of dynamical 6D maps (i.e. track)
    maps must have the following calling convention:
      dynmap(elm, map, len_weight)
    (see the symplectic integrators)
  - TODO: list the expected fields for elm and map

 o-----------------------------------------------------------------------------o
]=]

local M = {}

 -- Note:
 -- Is (_beta+pt) in t shouldn't be sqrt((_beta+pt)^2 - (_beta*_gamma)^2) ??
 -- is it a 1st order approximation?

-- locals ---------------------------------------------------------------------o

local matrix                                                     in MAD
local is_nil, is_number                                          in MAD.typeid
local minlen, minang, clight, twopi                              in MAD.constant

local abs, sqrt, max, sin, cos, tan, asin, acos, atan, atan2,
      sinh, cosh, sinc, fact                                     in MAD.gmath

local minvolt, volt_c = 1e-6, 1e-3

-- debug ----------------------------------------------------------------------o

local nodump = false

local function mdump(str, l, m)
  if nodump then return end
  assert(m.npar >= 1)
  print(str, l, m[1].x, m[1].px, m[1].y, m[1].py, m[1].t, m[1].pt)
end

-- field mutipoles ------------------------------------------------------------o

local function bxby (nmul, knl, ksl, x, y)
  local bx, by, byt = 0, 0

  for i=nmul,1,-1 do
    byt = by*x - bx*y + knl[i] -- /fact(i-1) -- done when copied to mflw
    bx  = by*y + bx*x + ksl[i] -- /fact(i-1) -- done when copied to mflw
    by  = byt
  end
  return bx, by
end

-- TODO: polar_bxby (nmul, knl, ksl, h, x, y) using TPSA (?)

-- patches (lw_ == 0 disable the patches) -------------------------------------o

-- X-rotation (pitch)

function M.xrotation (elm, m, lw_)  -- Rx(phi) [ROT_YZ]
  if lw_ == 0 then return end

  local phi = is_number(elm) and elm or (elm.phi or 0) + (elm.dphi or 0)
  if abs(phi) < minang then return end

  local tdir, npar in m
  phi = phi*tdir
  local sa, ca, ta = sin(phi), cos(phi), tan(phi)

  for i=1,npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beta = 1/(beam or m.beam).beta
    local    pz = sqrt(1 + (2*_beta)*pt + pt^2 - px^2 - py^2)
    local   _pz = 1/pz
    local   ptt = 1 - ta*py*_pz
    local  _ptt = y/ptt
    local  _pzt = ta*_pz*_ptt

    m[i].y  = _ptt/ca
    m[i].py = ca*py + sa*pz
    m[i].x  = x + _pzt*px
    m[i].t  = t - _pzt*(_beta+pt)
  end
end

-- Y-rotation (yaw)

function M.yrotation (elm, m, lw_)  -- Ry(theta) [ROT_XZ]
  if lw_ == 0 then return end

  local the = is_number(elm) and elm or (elm.theta or 0) + (elm.dtheta or 0)
  if abs(the) < minang then return end

  local tdir, npar in m
  the = the*tdir
  local sa, ca, ta = sin(the), cos(the), tan(the)

  for i=1,npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beta = 1/(beam or m.beam).beta
    local    pz = sqrt(1 + (2*_beta)*pt + pt^2 - px^2 - py^2)
    local   _pz = 1/pz
    local   ptt = 1 - ta*px*_pz
    local  _ptt = x/ptt
    local  _pzt = ta*_pz*_ptt

    -- eq. 127 in Forest06
    m[i].x  = _ptt/ca
    m[i].px = ca*px + sa*pz
    m[i].y  = y + _pzt*py
    m[i].t  = t - _pzt*(_beta+pt)
  end
end

-- S-rotation (roll, tilt)

function M.srotation (elm, m, lw_)  -- Rz(psi) [ROT_XY]
  if lw_ == 0 then return end

  local psi = is_number(elm) and elm or (elm.psi or 0) + (elm.dpsi or 0)
  if abs(psi) < minang then return end

  local tdir, npar in m
  psi = psi*tdir
  local sa, ca = sin(psi), cos(psi)

  for i=1,npar do
    local x, px, y, py in m[i]
    local nx  = ca*x  + sa*y
    local npx = ca*px + sa*py
    m[i].y    = ca*y  - sa*x
    m[i].py   = ca*py - sa*px
    m[i].x    = nx
    m[i].px   = npx
  end
end

-- Translation (dx, dy, dz)

function M.translate (elm, m, lw_) -- [TRANS]
  if lw_ == 0 then return end

  local dx = (elm.dx or 0) + (elm.ddx or 0)
  local dy = (elm.dy or 0) + (elm.ddy or 0)
  local dz = (elm.dz or 0) + (elm.ddz or 0)

  if abs(dx)+abs(dy)+abs(dz) < 3*minlen then return end

  local tdir, npar in m
  dx = dx*tdir

  if abs(dz) < minlen then
    for i=1,npar do
      local x, y in m[i]
      m[i].x = x - dx
      m[i].y = y - dy
    end
    return
  end

  -- dz is treated as a drift without correction for the time of flight
  local T, sdir in m
  dz = dz*sdir

  for i=1,npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beta = 1/(beam or m.beam).beta
    local l_pz = l/sqrt(1 + (2*_beta)*pt + pt^2 - px^2 - py^2)

    m[i].x = x + l_pz*px - dx
    m[i].y = y + l_pz*py - dy
    m[i].t = t - l_pz*(_beta+pt)
  end
end

-- Changeref (generic patch, dir>0: xyzt, dir<0: tzyx)

function M.changeref (elm, m, lw_)
  if lw_ == 0 then return end

  local dir = lw_ or 1

  if dir > 0 then
    M.xrotation(elm, m, lw_)
    M.yrotation(elm, m, lw_)
    M.srotation(elm, m, lw_)
    M.translate(elm, m, lw_)
  else
    M.translate(elm, m, lw_)
    M.srotation(elm, m, lw_)
    M.yrotation(elm, m, lw_)
    M.xrotation(elm, m, lw_)
  end
end

-- Changedir (reverse mflow t-direction)

function M.changedir (elm_, m, lw_)
  if lw_ == 0 then return end

  m.tdir = -m.tdir
end

-- Changenrj (change particles energy)

function M.changenrj (elm, m, lw_)  -- (to review)
  if lw_ == 0 then return end

  local dnrj = elm.dnrj
  if dnrj == 0 then return end

  local sdir, npar, beam in m
  beam.energy = beam.energy + dnrj*sdir

  for i=1,npar do
    beam = m[i].beam
    if beam then
      beam.energy = beam.energy + dnrj*sdir
    end
  end
end

-- angle=0, k0=0, k1=0 --------------------------------------------------------o

function M.drift (elm, m, lw) -- [DRIFT]                                        checked vs PTC code
  local l = is_number(elm) and elm or m.el*lw
  if abs(l) < minlen then return end

  local sdir, npar, beam, T in m
  l = l*sdir

  mdump('drift-0:', l, m)

  for i=1,npar do
    local x, px, y, py, t, pt in m[i]
    local _beta = 1/(m[i].beam or beam).beta
    local  l_pz = l/sqrt(1 + (2*_beta)*pt + pt^2 - px^2 - py^2)

    m[i].x = x + px*l_pz
    m[i].y = y + py*l_pz
    m[i].t = t - (_beta+pt)*l_pz + (1-T)*l*_beta
  end

  mdump('drift-1:', l, m)
end

function M.kick (elm, m, lw) -- [KICKEX(DKD)]                                   checked vs PTC code
  if m.nmul == 0 then return end

  local el, sdir, tdir, npar, beam, nmul, knl, ksl in m
  local l = el*sdir
  mdump('kick-0:', l, m)

  for i=1,npar do
    local x, px, y, py in m[i]
    local chg = (m[i].beam or beam).charge
    local bx, by = bxby(nmul, knl, ksl, x, y)

    m[i].px = px - (chg*tdir*lw)*by
    m[i].py = py + (chg*tdir*lw)*bx
  end

  mdump('kick-1:', l, m)
end

-- angle=0, k0~=0, k1=0 [INTER_STREX] -----------------------------------------o

function M.rbend_drift (elm, m, lw) -- [SPAR(STREX)]
  local k0, l in elm
  l = l*lw
  if abs(k0*l) < minang then return M.drift(l, m) end

  local T, sdir, tdir, npar in m
  l, k0 = l*sdir, k0*tdir

  for i=1,npar do
    local x, px, y, py, t, pt in m[i]
    local  beam = m[i].beam or m.beam
    local   k0q = k0*beam.charge
    local _beta = 1/beam.beta

    local  pw2 = 1 + 2*_beta*pt + pt^2 - py^2
    local   pz = sqrt(pw2 - px^2)
    local  npx = px - l*k0q
    local   ps = sqrt(pw2 - npx^2)
    local  ptt = sqrt(pw2)
    local _ptt = 1/ptt
    local  pzt = (asin(px*_ptt) - asin(npx*_ptt))/k0q

    -- eq. 129 in Forest06
    m[i].x  = x + (ps-pz)/k0q
    m[i].px = npx
    m[i].y  = y + pzt*py
    m[i].t  = t - pzt*(_beta+pt) + (1-T)*_beta*l
  end
end

function M.rbend_kick (elm, m, lw) -- [KICKEX(STREX)]
  local k0, l in elm
  l = l*lw
  if abs(k0*l) < minang then return M.kick(elm, m, lw) end

  local nmul in m
  if nmul == 0 then return end

  local knl, ksl, sdir, tdir, npar in m
  l, lw, k0 = l*sdir, lw*tdir, k0*tdir

  for i=1,npar do
    local x, px, y, py in m[i]
    local bx, by = bxby(nmul, knl, ksl, x, y)

    m[i].px = px - by*lw + k0*l
    m[i].py = py + bx*lw
  end
end

-- angle=0, k0~=0, k1~=0 [INTER_TKTF] -----------------------------------------o

local function drift_adj (l, m) -- drift adjustment [KICKPATH(TKTF)]            checked vs PTC
  local beam, npar, T in m

  mdump('drift_adj-0:', l, m)

  for i=1,npar do
    local x, px, y, py, t, pt in m[i]
    local _beta = 1/(m[i].beam or beam).beta
    local l_pz = l/sqrt(1 + (2*_beta)*pt + pt^2 - px^2 - py^2)

    m[i].x = x + px*(l_pz-l)
    m[i].y = y + py*(l_pz-l)
    m[i].t = t - (_beta+pt)*l_pz + (1-T)*l*_beta
  end

  mdump('drift_adj-1:', l, m)
end

function M.quad_drift (elm, m, lw) -- [PUSHTKT7(TKTF)]                          checked vs PTC
  local el, k0, k1, sdir, tdir, npar, T in m
  local l  = el*sdir*lw
  local w2 = abs(k1)               -- [GETMAT7(TKTF)]
  local w  = sqrt(w2)
  local wl = w*l
  local cw, sw = cos (wl), sin (wl)/w
  local ch, sh = cosh(wl), sinh(wl)/w

  if k1 < 0 then
    cw, sw, ch, sh = ch, sh, cw, sw
  end
  local m16 = (1-cw)/w2

  mdump('quad_drift-0:', l, m)

  for i=1,npar do
    local x, px, y, py, t, pt in m[i]
    local  beam = m[i].beam or m.beam
--    local  bdir = tdir*beam.charge -- not used...
    local l_bg2 = l/(beam.gamma^2-1)

    local nx = sw*px + cw*x -k0*m16
    local ny = sh*py + ch*y

    m[i].px  = -w*sw*x + cw*px -k0*sw
    m[i].py  =  w*sh*y + ch*py
    m[i].t   = t + l_bg2*pt
    m[i].x   = nx
    m[i].y   = ny
  end

  mdump('quad_drift-1:', l, m)
end

function M.quad_kick (elm, m, lw) -- [KICKTKT7(TKTF)]                           checked vs PTC
  local el, k0, sdir, tdir, npar, nmul, knl, ksl in m
  local l = el*sdir*lw

  drift_adj(l/2, m)               -- [KICKPATH(TKTF)]

  mdump('quad_kick-0:', l, m)

  for i=1,npar do
    local x, px, y, py, t, pt in m[i]
    local  beam = m[i].beam or m.beam
    local  bdir = tdir*beam.charge
    local _beta = 1/beam.beta
    local    pz = sqrt(1 + (2*_beta)*pt + pt^2) - 1
    local bx,by = bxby(nmul, knl, ksl, x, y)

    m[i].px = px + l*bdir*(k0*(pz-pt*_beta) - (by - knl[1] - knl[2]*x))
    m[i].py = py + l*bdir*(                   (bx          - knl[2]*y))
    m[i].t  =  t - l*k0*((pt+_beta)/(1+pz) - _beta)*x
  end

  mdump('quad_kick-1:', l, m)

  drift_adj(l/2, m)               -- [KICKPATH(TKTF)]
end

-- extra maps for SABAC integrators -------------------------------------------o

function M.drift_sabac (elm, m, lw)
  local el, sdir, npar, beam, T in m
  local l = el*sdir*lw

  mdump('drift_sabac-0:', l, m)

  for i=1,npar do
    local x, px, y, py, t, pt in m[i]
    local _beta = 1/(m[i].beam or beam).beta
    local l_dp = l/(1 + (2*_beta)*pt + pt^2)

    m[i].x = x + px*l_dp
    m[i].y = y + py*l_dp
    m[i].t = t - 0.5*(px^2+py^2)*l_dp^2/l
  end

  mdump('drift_sabac-1:', l, m)
end

function M.quad_corr_sabac (elm, m, lw, w)
  local el, sdir, tdir, npar, k1 in m
  local l, k1w2 = el*sdir*lw, k1^2*tdir*w

  mdump('quad_corr_sabac-0:', l, m)

  for i=1,npar do
    local x, px, y, py, t, pt in m[i]
    local  beam = m[i].beam or m.beam
    local  bdir = tdir*beam.charge
    local _beta = 1/beam.beta
    local  l_dp = l/(1 + (2*_beta)*pt + pt^2)

    m[i].px = px + l^2*k1w2*x*l_dp
    m[i].py = py + l^2*k1w2*y*l_dp
    m[i].t  = t  + l  *k1w2*0.5*(x^2+y^2)*l_dp^2
  end

  mdump('quad_corr_sabac-1:', l, m)
end

-- angle~=0, k0=0, k1=0 -------------------------------------------------------o

function M.polar_drift (elm, m, lw) -- [SPROT(TEAPOT)]
  local l, angle in elm
  l, angle = l*lw, angle*lw
  if abs(angle) < minang then return M.drift(l,m) end

  local T, sdir, tdir, npar in m
  l, angle = l*sdir, angle*tdir

  local rho = l/angle
  local sa, ca, ta, sa2 = sin(angle), cos(angle), tan(angle), sin(angle/2)

  for i=1,npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beta = 1/(beam or m.beam).beta

    local   pz = sqrt(1 + 2*_beta*pt + pt^2 - px^2 - py^2)
    local  _pz = 1/pz
    local  pxt = px*_pz
    local  ptt = (1 - ta*pxt)*ca
    local _ptt = 1/ptt
    local  pst = (x+rho)*sa*_pz*_ptt

    m[i].x  = (x + rho*(2*sa2^2 + sa*pxt))*_ptt
    m[i].px = ca*px + sa*pz
    m[i].y  = y + pst*py
    m[i].t  = t - pst*(_beta+pt) + (1-T)*_beta*l
  end
end

function M.polar_kick (elm, m, lw) -- [SKICK(TEAPOT)]
  local nmul in m
  if nmul == 0 then return end

  local angle in elm
  angle = angle*lw
  if abs(angle) < minang then return M.kick(elm,m,lw) end

  local knl, ksl, tdir, npar in m
  lw, angle = lw*tdir, angle*tdir
  local h = angle

  for i=1,npar do
    local x, px, y, py in m[i]
    local bx, by = bxby(nmul, knl, ksl, x, y, lw)

    m[i].px = px - by*(1 + h*x) -- TODO: h at all orders...
    m[i].py = py + bx*(1 + h*x)
  end
end

-- angle~=0, k0=~0, k1=0 ------------------------------------------------------o

function M.sbend_drift (elm, m, lw) -- [SSEC(TEAPOT)]
  local k0, l, angle in elm
  l, angle = l*lw, angle*lw
  if abs(k0*l ) < minang then return M.polar_drift(elm, m, lw) end
  if abs(angle) < minang then return M.rbend_drift(elm, m, lw) end

  local T, sdir, tdir, npar in m
  l, k0, angle = l*sdir, k0*tdir, angle*tdir

  local rho = l/angle
  local sa, ca = sin(angle), cos(angle)

  for i=1,npar do
    local x, px, y, py, t, pt in m[i]
    local  beam = m[i].beam or m.beam
    local   k0q = k0*beam.charge
    local _beta = 1/beam.beta

    local  pw2 = 1 + 2*_beta*pt + pt^2 - py^2
    local   pz = sqrt(pw2 - px^2)
    local  pzx = pz - (rho+x)*k0q
    local  npx =  ca*px + sa*pzx
    local  dpx = -sa*px + ca*pzx
    local   ps = sqrt(pw2 - npx^2)
    local  ptt = sqrt(pw2)
    local _ptt = 1/ptt
    local  dxs = (angle + asin(px*_ptt) - asin(npx*_ptt))/k0q

    -- eq. 126 in Forest06
    m[i].x  = (ps-dpx)/k0q - rho   -- x + ... ??
    m[i].px = npx
    m[i].y  = y + dxs*py
    m[i].t  = t - dxs*(_beta+pt) + (1-T)*_beta*l
  end
end

function M.sbend_kick (elm, m, lw) -- [??]
end

-- angle~=0, k0=~0, k1~=0 -----------------------------------------------------o

function M.combi_drift (elm, m, l) --
  local k0, k1, l, angle in elm
  l, angle = l*lw, angle*lw
  if abs(k0*l-angle) < minang and abs(k1*l) < minang then
    return M.sbend_drift(elm, m, lw)
  end

  local _el   = 1/elm.l
  local _beta = 1/m.beam.beta
  local l_bet2_gam2 = l/(m.beam.gamma^2-1)

  local angle = elm.angle
  local lw    = l*_el
  local h     = lw*angle
  local hbar  = h*_beta

  local knl, bdir in m
  local k0, k1 = bdir*knl[1]*_el, bdir*knl[2]*_el
  local hk0pk1 = h*k0+k1
  local wx2, wy2 = abs(hk0pk1), abs(k1)
  local wx , wy  = sqrt(wx2), sqrt(wy2)

  local cx, sx, cy, sy
  if hk0pk1 < 0
  then cx, sx = cosh(wx*l), sinh(wx*l)/wx -- check wx == 0
  else cx, sx = cos (wx*l), sin (wx*l)/wx -- check wx == 0
  end
  if k1 < 0
  then cy, sy = cosh(wy*l), sinh(wy*l)/wy -- check wy == 0
  else cy, sy = cos (wy*l), sin (wy*l)/wy -- check wy == 0
  end

--  local npos in m
--  M.drift_adj(npos == 'last' and l or l/2, m)

  local x, px, y, py, t, pt in m
  local m16, m56 = (1-cx)/wx2, hbar^2*(l-sx)/wx2

  m.x  =      cx*x + sx*px + hbar*m16*pt + (h-k0)*m16
  m.px = -wx2*sx*x + cx*px + hbar*sx*pt  + (h-k0)*sx
  m.y  =      cy*y + sy*py
  m.py =  wy2*sy*y + cy*py
  m.t  = t - hbar*(sx*x+m16*px) + (l_bet2_gam2-m56)*pt

--  M.drift_adj(npos == 'first' and l or l/2, m)
end

-- solenoid -------------------------------------------------------------------o

function M.solenoid_drift (elm, m, l) -- ks~=0, ksi~=0, (to review)
  local ksi in elm
  if abs(ksi) < minang then
    return M.rbend_drift(elm,m,l)
  end

  local x, px, y, py, t, pt, T, bdir in m
  local _beta = 1/m.beam.beta
  local _el = 1/elm.l

  local bsol = ksi*bdir*_el/2
  local xp = px + bsol*y
  local yp = py - bsol*x

  local l_pz  = l/sqrt(1 + 2*_beta*pt + pt^2 - xp^2 - yp^2)
  local angle = l_pz*bsol

  local ca, sa, sc = cos(angle), sin(angle), sinc(angle)

  local xt  = ca*x  + l_pz*sc*px
  local pxt = ca*px - l_pz*sc*x *bsol^2
  local yt  = ca*y  + l_pz*sc*py
  local pyt = ca*py - l_pz*sc*y *bsol^2

  m.x  = ca*xt  + sa*yt
  m.px = ca*pxt + sa*pyt
  m.y  = ca*yt  - sa*xt
  m.py = ca*pyt - sa*pxt

  m.t  = t - (_beta+pt)*l_pz + (1-T)*l*_beta
end

-- kicks ----------------------------------------------------------------------o

-- Special case TO BE REVIEWED !!!
function M.thick_kick (elm, m, _)
  local nmul in m
  if nmul == 0 then return end

  local x, px, y, py, bdir, knl, ksl in m
  local bx, by = bxby(nmul, knl, ksl, x, y, 1)

  m.px = px - bdir*(by + knl[1])
  m.py = py + bdir*(bx - ksl[1])

  if knl1 ~= 0 or ksl1 ~= 0 then
    local t, pt in m
    local _beta = 1/m.beam.beta
    local pz = sqrt(1 + 2*_beta*pt + pt^2)

    local l = elm.lrad or 0 -- TODO: check if lrad or l?
    if l ~= 0 then -- dipole focusing and deltap
      m.px = m.px - knl[1]^2*x/l + bdir*knl[1]*(pz-1)
      m.py = m.py - ksl[1]^2*y/l + bdir*ksl[1]*(pz-1)
    end
    m.t = t - bdir*(knl[1]*x - ksl[1]*y) * (_beta+pt)/pz
  end
end

function M.combi_kick (elm, m, l) -- angle, k0, k1 (tunes)
--  local knl in m
--  if abs(knl[2]) < minang then
    return M.polar_kick(elm,m,l)
--  end
  -- error("NYI") -- TODO
end

-- cavity ---------------------------------------------------------------------o

function M.rfcavity_kick (elm, m, l) --RF CAV, CRAB, RFMULT with l>0 kick (kickcavr)
  --local vrf in m
  --if abs(vrf) < minvolt then
    return M.straight_kick(elm,m,l) -- WARNING: NYI
  --end

-- missing input: tt, phase, phase0, ff, ph, a, r, nbessel, freq, volt, lag

--  local x, px, y, py, t, pt, bdir, nmul, knl, ksl in m
--  local volt, freq, lag, nbessel in elm
--
--  if freq == 0 then
--    error("Frequency number has to be defined for RF Cavity (i.e. harmon NYI) "
--          .. elm.name)
--  end
--
--  local pc = m.beam.pc
--  local omega = twopi*freq / clight
--  local vl    = bdir*l*volt*volt_c/pc
--  local df, f, r2 = 0, 1, 1
--
--  do i=1,nbessel
--    r2  = -r2*(ko*omega)^2/(4*(i+1)^2)
--    dr2 =  r2*i
--    df  =  df + 2*dr2
--    r2  =  r2*(x^2+y^2)
--    f   =  f + r2
--  end
--
--  local ff, ph = elm.f or {}, elm.ph or {}
--  local a , r  = elm.a or  0, elm.r or 0
--  local arg = omega*(t + tt) + phasе + ph + phase0
--
--  if nbessel > 0 then
--    m.px = px-x*ff[ko]* df * vl * cos(arg)/(omega)
--    m.py = py-y*ff[ko]* df * vl * cos(arg)/(omega)
--  end
--
--  m.pt = m.pt -ff*f*vl*sin(arg)
--
--  local lw = elm.l>0 and l/elm.l or 1
--  local bx, by = bxby(nmul, knl, ksl, x, y, lw)
--
--  m.px = m.px - ff[ko]*           bdir*by/pc*(a + r*cos(arg))
--  m.py = m.py + ff[ko]*           bdir*bx/pc*(a + r*cos(arg))
--  m.pt = m.pt + ff[ko]*(ko*omega)*bdir*by/pc*     r*sin(arg)

--[[ useful???
  by = -lw*knl[nmul] / fact(nmul-1) / nmul
  bx = -lw*ksl[nmul] / fact(nmul-1) / nmul

  for i=nmul-1,1,-1 do
    byt = x*by - y*bx - lw*knl[i] / fact(i-1) / i
    bx  = y*by + x*bx - lw*ksl[i] / fact(i-1) / i
    by  = byt
  end

  byt = x*by - y*bx
  bx  = y*by + x*bx
  by  = byt
]]
end

-- fringes --------------------------------------------------------------------o

local function sbend_face (elm, m, h)
  local x, px, y, py, t, pt, bdir in m
  local k0 = elm.k0 or 0
  local _beta = 1/m.beam.beta

  if bdir == 1 then -- to insure reversal symmetry ; horizontal wedge (only dir)
    px = px +(bdir*k0*h/2)*x^2
  end

  local ptt =        sqrt(1 + 2*pt*_beta + pt^2 - px^2)
  local xi  = bdir*sqrt(1 + 2*pt*_beta + pt^2)*k0*h/ptt^2
  local dxi_px   =  2*px*xi/ptt^2
  local dxi_ddel = -2*xi*(1 + pt)/ptt^2

  x  = x / (1-dxi_px*y^2)
  px = px - xi*y^2
  py = py - 2*xi*x*y
  t  = t  - dxi_ddel*x*y^2

  if(bdir == -1) then -- to insure reversal symmetry; horizontal wedge (only dir)
    px = px +(bdir*k0*h/2)*x^2
  end

  m.x  = x
  m.px = px
  m.py = py
  m.t  = t
end

local function sbend_wedge (elm, m, e)
  local x, px, y, py, t, pt, T, bdir in m
  local k0 = elm.k0 or 0
  local _beta = 1/m.beam.beta
  local b1 = bdir*k0
  local sa, ca, sa2 = sin(e), cos(e), sin(2*e)

  if b1 == 0 then
    yrot_track (elm, m, e) return
  end

  local pz  = sqrt(1 + 2*_beta*pt + pt^2 - px^2 - py^2)
  local ptt = sqrt(1 + 2*_beta*pt + pt^2        - py^2)
  local pxt = px*ca + (pz - b1*x)*sa
  local pzs = sqrt(1 + 2*_beta*pt + pt^2 - py^2 - pxt^2)
  local yt  = (e + asin(px/ptt) - asin(pxt/ptt)) / b1

  m.x  = x*ca + (x*px*sa2 + sa^2*(2*x*pz-b1*x^2)) / (pzs+pz*ca-px*sa)
  m.px = pxt
  m.y  = y + py * yt
  m.t  = t - yt*(_beta + pt)
end

local function sbend_fringe_field (elm, m, pos)
--  TODO: FINT and FINTX to have different FINT at entrance /exit
  local x, px, y, py, t, pt, T in m
  local k0   = elm.k0 or 0
  local _beta = 1/m.beam.beta
-- soft edge
  local fint = elm.fint or 0  -- fringe field integral at entrance and exit of the bend
  local hgap = elm.hgap or 0  -- half gap of the magnet
  local fsad = 0

  if fint*hgap ~= 0.0 then  -- soft edge
      fsad = 1/(fint*hgap*2)/36
  end

  local b = m.beam.charge*k0
  if pos == 'exit' then
     b = -b
  end

  local pz = sqrt(1 + 2*_beta*pt + pt^2 - px^2 - py^2)
  local time_fac = _beta + pt
  local rel_p    = sqrt(1 + 2*_beta*pt + pt^2)

  local c3=b^2*fsad/rel_p

  local xp, yp = px/pz or 0, py/pz or 0
  local d = matrix { -- to remove!
    { (1+xp^2) / pz, xp*yp    / pz, -time_fac*xp /pz^2 },
    {  xp*yp   / pz, (1+yp^2) / pz, -time_fac*yp /pz^2 },
    { -xp          ,   -yp        ,  time_fac    /pz   },
  }

  local fi0 = atan((xp/(1 + yp^2)))-2*b*fint*hgap*(1 + xp^2*(2 + yp^2))*pz
  local co2 = b/cos(fi0)^2
  local co1 = co2/(1 + (xp/(1 + yp^2))^2)

  local fi = {0, 0, 0}
  fi[1] =    co1 /       (1 + yp^2) - 2*co2*b*fint*hgap* (2*xp*(2 + yp^2)*pz)
  fi[2] =-2*co1*xp*yp/(1 + yp^2)^2  - 2*co2*b*fint*hgap* (2*xp^2*yp)*pz
  fi[3] =                           - 2*co2*b*fint*hgap* (1 + xp^2*(2 + yp^2))

  fi0=b*tan(fi0)

  b=0
  for i=1,3 do -- y column
    b=fi[i]*d:get(i,2) + b
  end
  m.y  = 2*m.y/(1 + sqrt(1 - 2*b*m.y))
  m.py = py - fi0*m.y

  b=0
  for i=1,3 do -- x column
    b=fi[i]*d:get(i,1) + b
  end
  m.x = m.x+0.5*b*m.y^2

  b=0
  for i=1,3 do -- z column
    b=fi[i]*d:get(i,3) + b
  end
  m.t = t + 0.5*b*m.y^2

  -- soft edge
  m.py = m.py - 4*c3*m.y^3
  m.t  = m.t  +   c3*m.y^4/rel_p^2*time_fac
end

local function mult_fringe_field (elm, m)
  local x, px, y, py, bdir, nmul, knl, ksl in m
  local _beta = 1/m.beam.beta
  local _l = 1/elm.l

  local rx, ix, fx, fy, fxx, fxy, fyx, fyy = 1, 0, 0, 0, 0, 0, 0, 0

	for i=1, nmul do
	  local drx, dix = rx, ix
    rx  = drx*x - dix*y
    ix  = drx*y + dix*x

    local ni, nf = -bdir/(4*(i+1)), i+2/i
    local lkn, lks = knl[i]*_l, ksl[i]*_l

    local u   =  ni*(lkn*rx  - lks*ix )
    local v   =  ni*(lkn*ix  + lks*rx )
    local du  =  ni*(lkn*drx - lks*dix)
    local dv  =  ni*(lkn*dix + lks*drx)
	  local dux =   i*du
    local dvx =   i*dv
    local duy =  -i*dv
    local dvy =   i*du

    fx  = fx  +   u*x + nf*       v*y
    fy  = fy  +   u*y - nf*       v*x
    fxx = fxx + dux*x + nf*     dvx*y + u
    fyy = fyy + duy*y - nf*     dvy*x + u
    fxy = fxy + duy*x + nf*(v + dvy*y)
    fyx = fyx + dux*y - nf*(v - dvx*x)
	end

  local _pz = 1/sqrt(1 + 2*pt*_beta + pt^2)
  local a = 1 - fxx*_pz
  local d = 1 - fyy*_pz
  local b =   - fyx*_pz
  local c =   - fxy*_pz
  local _det = 1/(a*d - b*c)

  m.x  = x - fx*_pz
  m.y  = y - fy*_pz
  m.px = (d*px - b*py)*_det
  m.py = (a*py - c*px)*_det
  m.t  = t + (_beta+pt)*(m.px*fx + m.py*fy)*_pz^3
end

local function straight_fringe_field (elm, m)
-- Lee-Whiting formula, E. Forest ch 13.2.3, eq 13.33
	local x, px, y, py, t, pt, T, bdir in m
  local k0   = elm.k0 or 0
  local _beta = 1/m.beam.beta
-- soft edge
  local fint = elm.fint or 0  -- fringe field integral at entrance and exit of the bend
  local hgap = elm.hgap or 0  -- half gap of the magnet

  local _pz  = 1/sqrt(1 + 2*_beta*pt + pt^2 )
  local time_fac = (_beta + pt)*_pz

  local a2, b2 = elm.ksl[2]/elm.l or 0, elm.knl[2]/elm.l or 0
  local b  = sqrt(b2^2 + a2^2)

  local f1 = -bdir*fint*abs(fint)*b*_pz/24.0
  local f2 =  hgap*b*_pz

  local ang=-atan2(a2,b2)/2

  tilt(-ang or 0, m)

  m.t = t - time_fac*(f1*x + f2*(1+f1/2)*px*_pz*exp(-f1))*px*_pz
          + time_fac*(f1*y + f2*(1-f1/2)*py*_pz*exp( f1))*py*_pz

  m.x = x*exp( f1) + px*f2*_pz
  m.y = y*exp(-f1) - py*f2*_pz

  m.px = px*exp(-f1)
  m.py = py*exp( f1)

  tilt(-ang or 0, m)
end

function M.sbend_fringe_ptc (elm, m, pos)
  if pos == 'entry' and not elm.kill_ent_fringe then
    local e, h = elm.e1 or 0, elm.h1 or 0
    if abs(e) < minang then
      sbend_face         (elm, m,  h)
      sbend_fringe_field (elm, m,  'entry')
    else
      yrotation          (elm, m,  e)
      sbend_face         (elm, m,  h)
      sbend_fringe_field (elm, m,  'entry')
      sbend_wedge        (elm, m, -e)
    end
    return
  end

  if pos == 'exit' and not elm.kill_exi_fringe then
    local e, h = elm.e2 or 0, elm.h2 or 0
    if abs(e) < minang then
      sbend_fringe_field (elm, m, 'exit')
      sbend_face         (elm, m,  h)
    else
      sbend_wedge        (elm, m, -e)
      sbend_fringe_field (elm, m, 'exit')
      sbend_face         (elm, m,  h)
      yrotation          (elm, m,  e)
    end
    return
  end
end

function M.straight_fringe (elm, m, l)
  local nmul, sdir in m
  if nmul == 0 then return end

  if pos == 'entry' then
	  local e, h = elm.e1 or 0, elm.h1 or 0
    if sdir == 1 then
    	M.yrotation         (elm, m, e)
    	M.sbend_face        (elm, m, h)
    	M.sbend_fringe_field(elm, m, 'entry')
	  else
      M.sbend_fringe_field(elm, m, 'entry')
      M.sbend_face        (elm, m, h)
      M.yrotation         (elm, m, e)
    end
    mult_fringe_field     (elm, m, 'entry')
    straight_fringe_field (elm, m, 'entry')
    return
  end

  if pos == 'exit' then
    local e, h = elm.e2 or 0, elm.h2 or 0
    straight_fringe_field (elm, m, 'exit')
    mult_fringe_field     (elm, m, 'exit')
  	if sdir == 1 then
      M.sbend_fringe_field(elm, m, 'exit')
      M.sbend_face        (elm, m, h)
      M.yrotation         (elm, m, e)
	  else
  	  M.yrotation         (elm, m, e)
  	  M.sbend_face        (elm, m, h)
  	  M.sbend_fringe_field(elm, m, 'exit')
    end
    return
  end
end

function M.solenoid_fringe (elm, mflw, lw)
--  local ksi in m
--  if abs(ksi) < minang then -- should never occur due to precedences
    return M.straight_fringe(elm,m,l)
--  end
  -- error("NYI") -- TODO
end

local rfcavity_fringe_ptc -- forward

function M.rfcavity_fringe (elm, mflw, lw)
--  local v in m
--  if abs(v) < minvolt then -- should never occur due to precedences
    return M.straight_fringe(elm,m,l)
--  end
  -- rfcavity_fringe_ptc(elm, m, l) -- TODO
end

local sbend_fringe_ptc -- forward

function M.sbend_fringe (elm, mflw, lw)
  local angle in elm
  if abs(angle) < minang then -- should never occur due to precedences
    return straight_fringe(elm,m,l)
  end
  sbend_fringe_ptc(elm, m, l)
end

-- end ------------------------------------------------------------------------o
return { dynmap = M }


-- cavities -------------------------------------------------------------------o

--[=[
local function rfcavity_kick (elm, m, l) -- RF CAV, CRAB, RFMULT with l>0 kick (kickcavr)
  local x, px, y, py, t, pt, nmul, bdir in m
  local tt, phase, phase0 = elm.tt or 0, elm.phase or 0, elm.phase0 or 0
  local ff, ph = elm.f or {}, elm.ph or {}
  local a, r = elm.a or  0, elm.r or 0

  -- nocavity.and.(.not.always_on)  return
  if 'nocavity' and (not 'always_on') then return end -- non-sense!!!

  local pc = m.beam.pc
  local volt_c = 1.0e-3
  local freq, harm, volt, lag = elm.freq or 0, elm.harm or 0, elm.volt or 0, elm.lag or 0
  local nbessel, nf = elm.nbessel or  0, elm.nf or 1
  if freq == 0 and harm == 0 then
    error("either frequency or harmonic number has to be defined for RF Cavity "
          .. elm.name)
  end

  local omega = twopi*freq / clight
  local vl    = m.bdir*l*volt*volt_c/pc
  local df, f, r2 = 0, 1, 1

  for ko=1,nf do -- over modes
    for i=1,nbessel do
      r2  = -r2*(ko*omega)^2/(4*(i+1)^2)
      dr2 =  r2*i
      df  =  df + 2*dr2
      r2  =  r2*(x^2+y^2)
      f   =  f + r2
    end

    if nbessel > 0 then
      m.px = px-x*ff[ko]* df * vl * cos(arg)/(ko*omega)
      m.py = py-y*ff[ko]* df * vl * cos(arg)/(ko*omega)
    end

    local arg = ko*omega*(t + tt) + phas + ph[ko] + phase0
    m.pt = m.pt -ff[ko]*f*vl*sin(arg)

    local lw, byt = elm.l>0 and l/elm.l or 1
    local by = lw*knl[nmul] / fact(nmul-1)
    local bx = lw*ksl[nmul] / fact(nmul-1)

    for i=nmul-1,1,-1 do
      byt = x*by - y*bx + lw*knl[i] / fact(i-1)
      bx  = y*by + x*bx + lw*ksl[i] / fact(i-1)
      by  = byt
    end

    m.px = m.px - ff[ko]*bdir*by/pc*(a + r*cos(arg))
    m.py = m.py + ff[ko]*bdir*bx/pc*(a + r*cos(arg))

    by = -lw*knl[nmul] / fact(nmul-1) / nmul
    bx = -lw*ksl[nmul] / fact(nmul-1) / nmul

    for i=nmul-1,1,-1 do
      byt = x*by - y*bx - lw*knl[i] / fact(i-1) / i
      bx  = y*by + x*bx - lw*ksl[i] / fact(i-1) / i
      by  = byt
    end

    byt = x*by - y*bx
    bx  = y*by + x*bx
    by  = byt

    m.pt = m.pt + ff[ko]*(ko*omega)*bdir*by/pc * r *sin(arg)
  end --over modes
end

local function rfcavity_thin_kick (elm, m, l) -- for tracking thin rf mult
  local x, px, y, py, t, pt, nmul, bdir in m
  local tt, phase, phase0 = elm.tt or 0, elm.phase or 0, elm.phase0 or 0
  local ff, ph = elm.f or {}, elm.ph or {}
  local a, r = elm.a or  0, elm.r or 0
  -- nocavity.and.(.not.always_on)  return
  if 'nocavity' and (not 'always_on') then return end -- non-sense!!!

  local pc = beam.pc
  local volt =elm.volt
  local volt_c = 1.0e-3
  local omega = twopi*freq / clight

  for ko=1,nf do -- over modes
    local arg = ko*omega*(t + tt) + phas + ph[ko] + phase0
    m.pt = m.pt - bdir*volt_c*ff[ko]*volt*sin(arg)/pc

    -- BUG: knl, ksl never retrieved
    local lw, byt = elm.l>0 and l/elm.l or 1
    local by = lw*knl[nmul] / fact(nmul-1)
    local bx = lw*ksl[nmul] / fact(nmul-1)

    for i=nmul-1,1,-1 do
      byt = x*by - y*bx + lw*knl[i] / fact(i-1)
      bx  = y*by + x*bx + lw*ksl[i] / fact(i-1)
      by  = byt
    end

    m.px = m.px - ff[ko]*bdir*by/pc*(a + r*cos(arg))
    m.py = m.py + ff[ko]*bdir*bx/pc*(a + r*cos(arg))

    by = -lw*knl[nmul] / fact(nmul-1) / nmul
    bx = -lw*ksl[nmul] / fact(nmul-1) / nmul

    for i=nmul,2,-1 do
      byt = x*by - y*bx - lw*knl[i-i] / fact(i-2) / (i-1)
      bx  = y*by + x*bx - lw*ksl[i-i] / fact(i-2) / (i-1)
      by  = byt
    end

    byt = x*by - y*bx
    bx  = y*by + x*bx
    by  = byt

    m.t = t - ff[ko]*(ko*omega)*bdir*by/pc * r *sin(arg)
  end --over modes
end

local function adjust_time_cav(elm, m, pos)
  local x, px, y, py, t, pt, T, dir in m
  local _beta = 1/m.beam.beta

  local delta_e = elm.delta_e or 0
  if pos == 'entry' then
    delta_e = pt
    if 'nocavity' and (not 'always_on') then return end -- non-sense!!!

    if elm.l < minlen then
      rfcavity_thin_kick(elm, m)
      delta_e=(m.pt - delta_e)*m.beam.pc -- side effects?
    end
  else
    if elm.l < minlen then return end
    t = t - elm.l*_beta -- TO CHECK      -- side effects?
    delta_e = (pt - delta_e)*m.beam.pc   -- side effects?
  end
end

local function rfcavity_fringe_ptc (elm, m, pos)
  local x, px, y, py, t, pt, T, dir in m

  if ('nocavity' and (not 'always_on')) then return end -- non-sense!!!

  if elm.kill_fringe     == 1                     or
     elm.kill_ent_fringe == 1 and pos ==  'entry' or
     elm.kill_ext_fringe == 1 and pos ==  'exit' then return end

  adjust_time_cav(elm, m, 'entry')

  if not ('fringe' or elm.nbessel == -1) then return end
  if elm.l < minlen then return end

  local kbmad = 0
  if elm.nbessel == -1 then kbmad = 1 end

  local z = 0
  if pos == 'entry' then z = elm.l end
  local freq, volt = elm.freg or 0, elm.volt or 0
  local volt_c = 1.0e-3
  local pc = m.beam.pc
  local omega = twopi*freq / clight
  local vl = m.bdir*volt*volt_c/pc
  if pos == 'exit' then vl = -vl end

  local tt, phase, phase0 = elm.tt or 0, elm.phase or 0, elm.phase0 or 0
  local ph = elm.f or {}, elm.ph or {}
  local nf = elm.nf or 1

  for ko=1,nf do   -- over modes
   s1 = cos(kbmad*ko*omega*z)*sin(ko*omega*(t+tt) + phas + phase0 + ph[ko])
   c1 = cos(kbmad*ko*omega*z)*cos(ko*omega*(t+tt) + phas + phase0 + ph[ko])
   m.px = m.px + 0.5*vl*s1*m.x
   m.py = m.py + 0.5*vl*s1*m.y
   m.pt = m.pt - 0.25*(m.x^2 + m.y^2)*vl*c1*omega*ko
  end

  adjust_time_cav(elm, m, 'exit')
end
--]=]

--[===[

Original code from track before splitting....

-- strengths and phases -------------------------------------------------------o

-- Load element phases in mflow

local function get_phas (elm, m, nmul) -- l=0 (or ignored)
  local pnl, dpnl = elm.pnl or {}, elm.dpnl or {}
  local psl, dpsl = elm.psl or {}, elm.dpsl or {}
  for i=1,nmul do
    m.pnl[i] = (pnl[i] or 0) + (dpnl[i] or 0)
    m.psl[i] = (psl[i] or 0) + (dpsl[i] or 0)
  end
end

-- Load element multipoles and volts in mflow

local function get_mult (elm, m) -- l=0 (or ignored)
  local knl, dknl = elm.knl or {}, elm.dknl or {}
  local ksl, dksl = elm.ksl or {}, elm.dksl or {}
  local nmul = max(#knl, #ksl, #dknl, #dksl)

  m.ksi = (elm.ksi  or 0) + (elm.dksi or 0) -- solenoid
  m.krf = (elm.krf  or 0) + (elm.dkrf or 0) -- rf cavity (krf*z = omega_rf*t)
  m.vrf = (elm.volt or 0) + (elm.dvrf or 0) -- rf volts

  m.has_k = m.ksi ~= 0 or m.krf ~= 0 or m.vrf ~= 0

  if nmul >= 1 then
    for i=1,nmul do
      m.knl[i] = (knl[i] or 0) + (dknl[i] or 0)
      m.ksl[i] = (ksl[i] or 0) + (dksl[i] or 0)
      m.has_k  = m.has_k or m.knl[i] ~= 0 or m.ksl[i] ~= 0
    end
    if abs(m.krf) >= minang then
      get_phas(elm, m, nmul)
    end
    m.nmul = nmul
  else
    m.nmul, m.knl[1], m.ksl[1], m.knl[2] = 0, 0, 0, 0
  end
end

-- Load element strengths, multipoles and volts in mflow

local function get_kmult (elm, m) -- l~=0
  local l in elm
  if abs(l) < minlen then return get_mult(elm, m) end

  local k0 , k1 , k2 , k3 , k4  in elm
  local k0s, k1s, k2s, k3s, k4s in elm
  local nkn = k4  and 5 or k3  and 4 or k2  and 3 or k1  and 2 or k0  and 1 or 0
  local nks = k4s and 5 or k3s and 4 or k2s and 3 or k1s and 2 or k0s and 1 or 0
  local knl, dknl = elm.knl or {}, elm.dknl or {}
  local ksl, dksl = elm.ksl or {}, elm.dksl or {}
  local nmul = max(#knl, #ksl, #dknl, #dksl, nkn, nks)

  m.ksi  = (elm.ks or 0)*l + (elm.ksi  or 0) + (elm.dksi or 0)
  m.krf  =                   (elm.krf  or 0) + (elm.dkrf or 0)
  m.vrf  =                   (elm.volt or 0) + (elm.dvrf or 0)
  m.has_k = m.ksi ~= 0 or m.krf ~= 0 or m.vrf ~= 0

  if nmul >= 1 then
    local kn = { k0 , k1 , k2 , k3 , k4  }
    local ks = { k0s, k1s, k2s, k3s, k4s }
    for i=1,nmul do
      m.knl[i] = (kn[i] or 0)*l + (knl[i] or 0) + (dknl[i] or 0)
      m.ksl[i] = (ks[i] or 0)*l + (ksl[i] or 0) + (dksl[i] or 0)
      m.has_k = m.has_k or m.knl[i] ~= 0 or m.ksl[i] ~= 0
    end
    if abs(m.krf) >= minang then
      get_phas(elm, m, nmul)
    end
    m.nmul = nmul
  else
    m.nmul, m.knl[1], m.ksl[1], m.knl[2] = 0, 0, 0, 0
  end
end

-- Compute weighted multipoles

local function get_bxby (nmul, knl, ksl, x, y, lw)
  if nmul == 0 then return 0, 0 end

  local by = lw*knl[nmul] / fact(nmul-1)
  local bx = lw*ksl[nmul] / fact(nmul-1)
  local byt

  for i=nmul-1,1,-1 do
    byt = x*by - y*bx + lw*knl[i] / fact(i-1)
    bx  = y*by + x*bx + lw*ksl[i] / fact(i-1)
    by  = byt
  end
  return bx, by
end

-- drifts ---------------------------------------------------------------------o

function straight_drift (_, m, l) -- exact, l~=0
  if abs(l) < minlen then return end

  local x, px, y, py, t, pt, T in m
  local _beta = 1/m.beam.beta
  local l_pz = l/sqrt(1 + 2*_beta*pt + pt^2 - px^2 - py^2)

  m.x = x + px*l_pz
  m.y = y + py*l_pz
  m.t = t - (_beta+pt)*l_pz + (1-T)*l*_beta
end

function rbend_drift (elm, m, l) -- exact, l~=0
  local knl in m
  if abs(knl[1]) < minang then
    return straight_drift(nil,m,l)
  end

  local x, px, y, py, t, pt, bdir, T in m
  local _beta = 1/m.beam.beta
  local lw = l/elm.l
  local k0 = bdir*lw*knl[1]

  local pz = sqrt(1 + 2*_beta*pt + pt^2 - px^2 - py^2)
  local pt = sqrt(1 + 2*_beta*pt + pt^2 - py^2)
  local xp = px - k0
  local ps = sqrt(1 + 2*_beta*pt + pt^2 - xp^2 - py^2)
  local xs = (asin(px/pt) - asin(xp/pt))/k0

  m.x  = x + (ps-pz)/k0
  m.px = xp
  m.y  = y + py*xs
  m.t  = t - (_beta+pt)*xs + (1-T)*l*_beta
end

function solenoid_drift (elm, m, l) -- exact, l~=0          TO BE REVIEWED
  if abs(m.ksi) < minang then
    return rbend_drift(elm,m,l)
  end

  local x, px, y, py, t, pt, T, bdir in m
  local _beta = 1/m.beam.beta
  local _el = 1/elm.l

  local bsol = m.ksi*bdir*_el/2
  local xp = px + bsol*y
  local yp = py - bsol*x

  local l_pz  = l/sqrt(1 + 2*_beta*pt + pt^2 - xp^2 - yp^2)
  local angle = l_pz*bsol

  local ca, sa, sc = cos(angle), sin(angle), sinc(angle)

  local xt  = ca*x  + l_pz*sc*px
  local pxt = ca*px - l_pz*sc*x *bsol^2
  local yt  = ca*y  + l_pz*sc*py
  local pyt = ca*py - l_pz*sc*y *bsol^2

  m.x  = ca*xt  + sa*yt
  m.px = ca*pxt + sa*pyt
  m.y  = ca*yt  - sa*xt
  m.py = ca*pyt - sa*pxt

  m.t  = t - (_beta+pt)*l_pz + (1-T)*l*_beta
end

local function combadj_drift (_, m, l) -- l~=0, adjust combined_drift
  local x, px, y, py, t, pt, T in m
  local _beta = 1/m.beam.beta

  local l_pz = l/sqrt(1 + 2*_beta*pt + pt^2 - px^2 - py^2)
  m.x  = x + px*(l_pz-l)
  m.y  = y + py*(l_pz-l)
  m.t  = t - (_beta+pt)*l_pz + (1-T)*l*_beta
end

function quadrupole_drift (elm, m, l) -- comb_drift with angle == 0
  local _el   = 1/elm.l
  local _beta = 1/m.beam.beta
  local l_bet2_gam2 = l/(m.beam.gamma^2-1)

  local knl, bdir in m
  local k0, k1 = bdir*knl[1]*_el, bdir*knl[2]*_el
  local w2 = abs(k1)
  local w  = sqrt(w2)

  -- TODO: case w=0...
  local cw, sw = cos (w*l), sin (w*l)/w
  local ch, sh = cosh(w*l), sinh(w*l)/w

  if k1 < 0 then
    cw, sw, ch, sh = ch, sh, cw, sw
  end

  local npos in m
  if is_nil(npos) or npos == 'last' then
    local dl = is_nil(pos) and l/2 or l
    combadj_drift(_, m, dl)
  end

  local x, px, y, py, t, pt in m
  local m16 = (1-cw)/w2

  m.x  =    cw*x + sw*px -k0*m16
  m.px = -w*sw*x + cw*px -k0*sw
  m.y  =    ch*y + sh*py
  m.py =  w*sh*y + ch*py
  m.t  = t + l_bet2_gam2*pt

  if is_nil(npos) or npos == 'first' then
    local dl = is_nil(pos) and l/2 or l
    combadj_drift(_, m, l)
  end
  m.npos = nil
end

function combined_drift (elm, m, l)
  local _el   = 1/elm.l
  local _beta = 1/m.beam.beta
  local l_bet2_gam2 = l/(m.beam.gamma^2-1)

  local angle = elm.angle
  local lw    = l*_el
  local h     = lw*angle
  local hbar  = h*_beta

  local knl, bdir in m
  local k0, k1 = bdir*knl[1]*_el, bdir*knl[2]*_el
  local hk0pk1 = h*k0+k1
  local wx2, wy2 = abs(hk0pk1), abs(k1)
  local wx , wy  = sqrt(wx2), sqrt(wy2)

  local cx, sx, cy, sy
  if hk0pk1 < 0
  then cx, sx = cosh(wx*l), sinh(wx*l)/wx -- check wx == 0
  else cx, sx = cos (wx*l), sin (wx*l)/wx -- check wx == 0
  end
  if k1 < 0
  then cy, sy = cosh(wy*l), sinh(wy*l)/wy -- check wy == 0
  else cy, sy = cos (wy*l), sin (wy*l)/wy -- check wy == 0
  end

  local npos in m
  if is_nil(npos) or npos == 'last' then
    local dl = is_nil(pos) and l/2 or l
    combadj_drift(_, m, dl)
  end

  local x, px, y, py, t, pt in m
  local m16, m56 = (1-cx)/wx2, hbar^2*(l-sx)/wx2

  m.x  =      cx*x + sx*px + hbar*m16*pt + (h-k0)*m16
  m.px = -wx2*sx*x + cx*px + hbar*sx*pt  + (h-k0)*sx
  m.y  =      cy*y + sy*py
  m.py =  wy2*sy*y + cy*py
  m.t  = t - hbar*(sx*x+m16*px) + (l_bet2_gam2-m56)*pt

  if is_nil(npos) or npos == 'first' then
    local dl = is_nil(pos) and l/2 or l
    combadj_drift(_, m, l)
  end
  m.npos = nil
end

function polar_drift (elm, m, l) -- exact, l~=0, k0=angle
  local rho = elm.l/(elm.angle*m.sdir)
  local ang = l/rho
  local sa, ca, ta, sa2 = sin(ang), cos(ang), tan(ang), sin(ang/2)

  local x, px, y, py, t, pt, T in m
  local _beta = 1/m.beam.beta
  local pz  = sqrt(1 + 2*_beta*pt + pt^2 - px^2 - py^2)
  local _pz = 1/pz
  local ptt = 1 - ta*px*_pz
  local xr  = (x+rho)*ta*_pz

  m.x  = (x + rho*(2*sa2^2 + sa*px*_pz))/(ca*ptt)
  m.px = ca*px + sa*pz
  m.y  = y + xr*py/ptt
  m.t  = t - xr*(_beta+pt)/ptt + (1-T)*l*_beta
end

function sbend_drift (elm, m, l) -- exact, l~=0, k0~=angle
  local angle in elm
  local knl in m
  if abs(angle - knl[1]) < minang then
    return polar_drift(elm,m,l)
  end
  error("NYI")
end

-- PRECEDENCE SHOULD BE OUTSIDE INTEGRATORS
--local function combined_drift (elm, m, l) -- angle, k0, k1 (tunes)
--  if abs(m.knl[2]) < minang then -- Put these checks outside the integrator
--    if abs(angle) < minang then
--      return rbend_drift(elm,m,l)
--    else
--      return sbend_drift(elm,m,l)
--    end
--  else
--    if abs(angle) < minang then
--      return quadrupole_drift(elm,m,l)
--    else
--      return combined_drift  (elm,m,l)
--    end
--  end
--end

-- kicks ----------------------------------------------------------------------o

-- Special case TO BE REVIEWED !!!
function thin_kick (elm, m) -- l=0 (ignored)
  local nmul in m
  if nmul == 0 then return end

--  local knlt, kslt = elm.knl or {}, elm.ksl or {} -- BUG: not retrieved by getmul
--  local knl1, ksl1 = (knlt[1] or 0), (kslt[1] or 0)

  local x, px, y, py, bdir, knl, ksl in m
  local bx, by = get_bxby(nmul, knl, ksl, x, y, 1)

  m.px = px - bdir*(by + knl[1])
  m.py = py + bdir*(bx - ksl[1])

  if knl1 ~= 0 or ksl1 ~= 0 then
    local t, pt in m
    local _beta = 1/m.beam.beta
    local pz = sqrt(1 + 2*_beta*pt + pt^2)

    local l = elm.lrad or 0 -- TODO: check if lrad or l?
    if l ~= 0 then -- dipole focusing and deltap
      m.px = m.px - knl[1]^2*x/l + bdir*knl[1]*(pz-1)
      m.py = m.py - ksl[1]^2*y/l + bdir*ksl[1]*(pz-1)
    end
--    m.t = t + bdir*(knl1*x - ksl1*y) * (_beta+pt)/pz
    m.t = t - bdir*(knl[1]*x - ksl[1]*y) * (_beta+pt)/pz
  end
end

function straight_kick (elm, m, l) -- l~=0
  local nmul in m
  if nmul == 0 then return end

  local x, px, y, py, knl, ksl, bdir in m
  local lw = abs(elm.l)>minlen and l/elm.l or 1
  local bx, by = get_bxby(nmul, knl, ksl, x, y, lw)

  m.px = px - bdir*by
  m.py = py + bdir*bx
end

function quadrupole_kick (elm, m, l)
  if abs(m.knl[2]) < minang then -- should never occur due to precedences
    return rfcavity_kick(elm,m,l)
  end

  local x, px, y, py, t, pt, bdir, T, nmul, knl, ksl in m
  local _beta = 1/m.beam.beta
  local pz = sqrt(1 + 2*_beta*pt + pt^2) - 1

  local lw = l/elm.l
  local bx, by = get_bxby(nmul, knl, ksl, x, y, lw)

   m.px = px + lw*knl[1]*(pz-pt)*_beta
   m.t  = t  - lw*knl[1]*((pt+_beta)/(1+pz) - _beta)*x

   m.px = m.px - bdir*(by - lw*(knl[1] - knl[2]*x))
   m.py = m.py + bdir*(bx - lw*          knl[2]*y )
end

function polar_kick (elm, m, l) -- [PTC] SKICK
  local angle in elm
  if abs(angle) < minang then -- should never occur due to precedences
    return straight_kick(elm,m,l)
  end

  local x, px, y, py, nmul, knl, ksl, bdir in m
  local lw = l/elm.l
  local bx, by = get_bxby(nmul, knl, ksl, x, y, lw) -- TODO: GETELECTRIC

  local h = lw*angle
  m.px = px - bdir*by*(1 + h*x)
  m.py = py + bdir*bx*(1 + h*x)
end

function combined_kick (elm, m, l) -- angle, k0, k1 (tunes)
--  local knl in m
--  if abs(knl[2]) < minang then
    return polar_kick(elm,m,l)
--  end
  -- error("NYI") -- TODO
end

function rfcavity_kick (elm, m, l) --RF CAV, CRAB, RFMULT with l>0 kick (kickcavr)
  --local vrf in m
  --if abs(vrf) < minvolt then
    return straight_kick(elm,m,l)
  --end

-- missing input: tt, phase, phase0, ff, ph, a, r, nbessel, freq, volt, lag

--  local x, px, y, py, t, pt, bdir, nmul, knl, ksl in m
--  local volt, freq, lag, nbessel in elm
--
--  if freq == 0 then
--    error("Frequency number has to be defined for RF Cavity (i.e. harmon NYI) "
--          .. elm.name)
--  end
--
--  local pc = m.beam.pc
--  local omega = twopi*freq / clight
--  local vl    = bdir*l*volt*volt_c/pc
--  local df, f, r2 = 0, 1, 1
--
--  do i=1,nbessel
--    r2  = -r2*(ko*omega)^2/(4*(i+1)^2)
--    dr2 =  r2*i
--    df  =  df + 2*dr2
--    r2  =  r2*(x^2+y^2)
--    f   =  f + r2
--  end
--
--  local ff, ph = elm.f or {}, elm.ph or {}
--  local a , r  = elm.a or  0, elm.r or 0
--  local arg = omega*(t + tt) + phasе + ph + phase0
--
--  if nbessel > 0 then
--    m.px = px-x*ff[ko]* df * vl * cos(arg)/(omega)
--    m.py = py-y*ff[ko]* df * vl * cos(arg)/(omega)
--  end
--
--  m.pt = m.pt -ff*f*vl*sin(arg)
--
--  local lw = elm.l>0 and l/elm.l or 1
--  local bx, by = get_bxby(nmul, knl, ksl, x, y, lw)
--
--  m.px = m.px - ff[ko]*           bdir*by/pc*(a + r*cos(arg))
--  m.py = m.py + ff[ko]*           bdir*bx/pc*(a + r*cos(arg))
--  m.pt = m.pt + ff[ko]*(ko*omega)*bdir*by/pc*     r*sin(arg)

--[[ useful???
  by = -lw*knl[nmul] / fact(nmul-1) / nmul
  bx = -lw*ksl[nmul] / fact(nmul-1) / nmul

  for i=nmul-1,1,-1 do
    byt = x*by - y*bx - lw*knl[i] / fact(i-1) / i
    bx  = y*by + x*bx - lw*ksl[i] / fact(i-1) / i
    by  = byt
  end

  byt = x*by - y*bx
  bx  = y*by + x*bx
  by  = byt
]]
end

-- fringes --------------------------------------------------------------------o

local function mult_fringe_field (elm, m, pos)
  if elm.kill_fringe                        or
     elm.kill_ent_fringe and pos == 'entry' or
     elm.kill_exi_fringe and pos == 'exit'  then return end

  local x, px, y, py, bdir, nmul, knl, ksl in m
  local _beta = 1/m.beam.beta
  local _l = 1/elm.l

  local rx, ix, fx, fy, fxx, fxy, fyx, fyy = 1, 0, 0, 0, 0, 0, 0, 0

  for i=1, nmul do
    local drx, dix = rx, ix
    rx  = drx*x - dix*y
    ix  = drx*y + dix*x

    local ni, nf = -bdir/(4*(i+1)), i+2/i
    local lkn, lks = knl[i]*_l, ksl[i]*_l

    local u   =  ni*(lkn*rx  - lks*ix )
    local v   =  ni*(lkn*ix  + lks*rx )
    local du  =  ni*(lkn*drx - lks*dix)
    local dv  =  ni*(lkn*dix + lks*drx)
    local dux =   i*du
    local dvx =   i*dv
    local duy =  -i*dv
    local dvy =   i*du

    fx  = fx  +   u*x + nf*       v*y
    fy  = fy  +   u*y - nf*       v*x
    fxx = fxx + dux*x + nf*     dvx*y + u
    fyy = fyy + duy*y - nf*     dvy*x + u
    fxy = fxy + duy*x + nf*(v + dvy*y)
    fyx = fyx + dux*y - nf*(v - dvx*x)
  end

  local _pz = 1/sqrt(1 + 2*pt*_beta + pt^2)
  local a = 1 - fxx*_pz
  local d = 1 - fyy*_pz
  local b =   - fyx*_pz
  local c =   - fxy*_pz
  local _det = 1/(a*d - b*c)

  m.x  = x - fx*_pz
  m.y  = y - fy*_pz
  m.px = (d*px - b*py)*_det
  m.py = (a*py - c*px)*_det
  m.t  = t + (_beta+pt)*(m.px*fx + m.py*fy)*_pz^3
end

local function straight_fringe_field (elm, m, pos)
  if elm.kill_fringe                        or
     elm.kill_ent_fringe and pos == 'entry' or
     elm.kill_exi_fringe and pos == 'exit'  then return end

-- Lee-Whiting formula, E. Forest ch 13.2.3, eq 13.33
  local x, px, y, py, t, pt, T, bdir in m
  local k0   = elm.k0 or 0
  local _beta = 1/m.beam.beta
-- soft edge
  local fint = elm.fint or 0  -- fringe field integral at entrance and exit of the bend
  local hgap = elm.hgap or 0  -- half gap of the magnet

  local _pz  = 1/sqrt(1 + 2*_beta*pt + pt^2 )
  local time_fac = (_beta + pt)*_pz

  local a2, b2 = elm.ksl[2]/elm.l or 0, elm.knl[2]/elm.l or 0
  local b  = sqrt(b2^2 + a2^2)

  local f1 = -bdir*fint*abs(fint)*b*_pz/24.0
  local f2 =  hgap*b*_pz

  local ang=-atan2(a2,b2)/2

  srotation(nil, m, -ang or 0)

  m.t = t - time_fac*(f1*x + f2*(1+f1/2)*px*_pz*exp(-f1))*px*_pz
          + time_fac*(f1*y + f2*(1-f1/2)*py*_pz*exp( f1))*py*_pz

  m.x = x*exp( f1) + px*f2*_pz
  m.y = y*exp(-f1) - py*f2*_pz

  m.px = px*exp(-f1)
  m.py = py*exp( f1)

  srotation(nil, m, -ang or 0)
end

function straight_fringe (elm, m, l) -- ADD DIRECTION
  local nmul, sdir in m
  if nmul == 0 then return end

  if pos == 'entry'  then
    local e, h = elm.e1 or 0, elm.h1 or 0
    if sdir == 1 then
      yrotation          (elm, m,  e)
      sbend_face         (elm, m,  h)
      sbend_fringe_field (elm, m,  'entry')
    else
      sbend_fringe_field (elm, m,  'entry')
      sbend_face         (elm, m,  h)
      yrotation          (elm, m,  e)
    end
    mult_fringe_field    (elm, m,  'entry')
    straight_fringe_field(elm, m,  'entry')
    return
  end

  if pos == 'exit'  then
    local e, h = elm.e2 or 0, elm.h2 or 0
    straight_fringe_field(elm, m,  'exit')
    mult_fringe_field    (elm, m,  'exit')
    if sdir == 1 then
      sbend_fringe_field (elm, m,  'exit')
      sbend_face         (elm, m,  h)
      yrotation          (elm, m,  e)
    else
      yrotation          (elm, m,  e)
      sbend_face         (elm, m,  h)
      sbend_fringe_field (elm, m,  'exit')
    end
    return
  end
end

function solenoid_fringe (elm, m, l)
--  local ksi in m
--  if abs(ksi) < minang then -- should never occur due to precedences
    return straight_fringe(elm,m,l)
--  end
  -- error("NYI") -- TODO
end

local rfcavity_fringe_ptc -- forward

function rfcavity_fringe (elm, m, l)
--  local v in m
--  if abs(v) < minvolt then -- should never occur due to precedences
    return straight_fringe(elm,m,l)
--  end
  -- rfcavity_fringe_ptc(elm, m, l) -- TODO
end

local sbend_fringe_ptc -- forward

function sbend_fringe (elm, m, l)
  local angle in elm
  if abs(angle) < minang then -- should never occur due to precedences
    return straight_fringe(elm,m,l)
  end
  sbend_fringe_ptc(elm, m, l)
end

-- sbend ----------------------------------------------------------------------o

local function sbend_face (elm, m, h)
  local x, px, y, py, t, pt, bdir in m
  local k0 = elm.k0 or 0
  local _beta = 1/m.beam.beta

  if bdir == 1 then -- to insure reversal symmetry ; horizontal wedge (only dir)
    px = px +(bdir*k0*h/2)*x^2
  end

  local ptt =        sqrt(1 + 2*pt*_beta + pt^2 - px^2)
  local xi  = bdir*sqrt(1 + 2*pt*_beta + pt^2)*k0*h/ptt^2
  local dxi_px   =  2*px*xi/ptt^2
  local dxi_ddel = -2*xi*(1 + pt)/ptt^2

  x  = x / (1-dxi_px*y^2)
  px = px - xi*y^2
  py = py - 2*xi*x*y
  t  = t  - dxi_ddel*x*y^2

  if(bdir == -1) then -- to insure reversal symmetry; horizontal wedge (only dir)
    px = px +(bdir*k0*h/2)*x^2
  end

  m.x  = x
  m.px = px
  m.py = py
  m.t  = t
end

local function sbend_wedge (elm, m, e)
  local x, px, y, py, t, pt, T, bdir in m
  local k0 = elm.k0 or 0
  local _beta = 1/m.beam.beta
  local b1 = bdir*k0
  local sa, ca, sa2 = sin(e), cos(e), sin(2*e)

  if b1 == 0 then
    yrot_track (elm, m, e) return
  end

  local pz  = sqrt(1 + 2*_beta*pt + pt^2 - px^2 - py^2)
  local ptt = sqrt(1 + 2*_beta*pt + pt^2        - py^2)
  local pxt = px*ca + (pz - b1*x)*sa
  local pzs = sqrt(1 + 2*_beta*pt + pt^2 - py^2 - pxt^2)
  local yt  = (e + asin(px/ptt) - asin(pxt/ptt)) / b1

  m.x  = x*ca + (x*px*sa2 + sa^2*(2*x*pz-b1*x^2)) / (pzs+pz*ca-px*sa)
  m.px = pxt
  m.y  = y + py * yt
  m.t  = t - yt*(_beta + pt)
end

local function sbend_fringe_field (elm, m, pos)
--  TODO: FINT and FINTX to have different FINT at entrance /exit
  local x, px, y, py, t, pt, T in m
  local k0   = elm.k0 or 0
  local _beta = 1/m.beam.beta
-- soft edge
  local fint = elm.fint or 0  -- fringe field integral at entrance and exit of the bend
  local hgap = elm.hgap or 0  -- half gap of the magnet
  local fsad = 0

  if fint*hgap ~= 0.0 then  -- soft edge
      fsad = 1/(fint*hgap*2)/36
  end

  local b = m.beam.charge*k0
  if pos == 'exit' then
     b = -b
  end

  local pz = sqrt(1 + 2*_beta*pt + pt^2 - px^2 - py^2)
  local time_fac = _beta + pt
  local rel_p    = sqrt(1 + 2*_beta*pt + pt^2)

  local c3=b^2*fsad/rel_p

  local xp, yp = px/pz or 0, py/pz or 0
  local d  = matrix {
    { (1+xp^2) / pz, xp*yp    / pz, -time_fac*xp /pz^2 },
    {  xp*yp   / pz, (1+yp^2) / pz, -time_fac*yp /pz^2 },
    { -xp          ,   -yp        ,  time_fac    /pz   },
  }

  local fi0 = atan((xp/(1 + yp^2)))-2*b*fint*hgap*(1 + xp^2*(2 + yp^2))*pz
  local co2 = b/cos(fi0)^2
  local co1 = co2/(1 + (xp/(1 + yp^2))^2)

  local fi = {0, 0, 0}
  fi[1] =    co1 /       (1 + yp^2) - 2*co2*b*fint*hgap* (2*xp*(2 + yp^2)*pz)
  fi[2] =-2*co1*xp*yp/(1 + yp^2)^2  - 2*co2*b*fint*hgap* (2*xp^2*yp)*pz
  fi[3] =                           - 2*co2*b*fint*hgap* (1 + xp^2*(2 + yp^2))

  fi0=b*tan(fi0)

  b=0
  for i=1,3 do -- y column
    b=fi[i]*d:get(i,2) + b
  end
  m.y  = 2*m.y/(1 + sqrt(1 - 2*b*m.y))
  m.py = py - fi0*m.y

  b=0
  for i=1,3 do -- x column
    b=fi[i]*d:get(i,1) + b
  end
  m.x = m.x+0.5*b*m.y^2

  b=0
  for i=1,3 do -- z column
    b=fi[i]*d:get(i,3) + b
  end
  m.t = t + 0.5*b*m.y^2

  -- soft edge
  m.py = m.py - 4*c3*m.y^3
  m.t  = m.t  +   c3*m.y^4/rel_p^2*time_fac
end

function sbend_fringe_ptc (elm, m, pos) -- has forward decl
  if elm.kill_fringe then return end

  if pos == 'entry' and not elm.kill_ent_fringe then
    local e, h = elm.e1 or 0, elm.h1 or 0
    if abs(e) < minang then
      sbend_face         (elm, m,  h)
      sbend_fringe_field (elm, m,  'entry')
    else
      yrotation          (elm, m,  e)
      sbend_face         (elm, m,  h)
      sbend_fringe_field (elm, m,  'entry')
      sbend_wedge        (elm, m, -e)
    end
    return
  end

  if pos == 'exit' and not elm.kill_exi_fringe then
    local e, h = elm.e2 or 0, elm.h2 or 0
    if abs(e) < minang then
      sbend_fringe_field (elm, m, 'exit')
      sbend_face         (elm, m,  h)
    else
      sbend_wedge        (elm, m, -e)
      sbend_fringe_field (elm, m, 'exit')
      sbend_face         (elm, m,  h)
      yrotation          (elm, m,  e)
    end
    return
  end
end

-- cavities -------------------------------------------------------------------o

--[=[
local function rfcavity_kick (elm, m, l) -- RF CAV, CRAB, RFMULT with l>0 kick (kickcavr)
  local x, px, y, py, t, pt, nmul, bdir in m
  local tt, phase, phase0 = elm.tt or 0, elm.phase or 0, elm.phase0 or 0
  local ff, ph = elm.f or {}, elm.ph or {}
  local a, r = elm.a or  0, elm.r or 0

  -- nocavity.and.(.not.always_on)  return
  if 'nocavity' and (not 'always_on') then return end -- non-sense!!!

  local pc = m.beam.pc
  local volt_c = 1.0e-3
  local freq, harm, volt, lag = elm.freq or 0, elm.harm or 0, elm.volt or 0, elm.lag or 0
  local nbessel, nf = elm.nbessel or  0, elm.nf or 1
  if freq == 0 and harm == 0 then
    error("either frequency or harmonic number has to be defined for RF Cavity "
          .. elm.name)
  end

  local omega = twopi*freq / clight
  local vl    = m.bdir*l*volt*volt_c/pc
  local df, f, r2 = 0, 1, 1

  for ko=1,nf do -- over modes
    for i=1,nbessel do
      r2  = -r2*(ko*omega)^2/(4*(i+1)^2)
      dr2 =  r2*i
      df  =  df + 2*dr2
      r2  =  r2*(x^2+y^2)
      f   =  f + r2
    end

    if nbessel > 0 then
      m.px = px-x*ff[ko]* df * vl * cos(arg)/(ko*omega)
      m.py = py-y*ff[ko]* df * vl * cos(arg)/(ko*omega)
    end

    local arg = ko*omega*(t + tt) + phas + ph[ko] + phase0
    m.pt = m.pt -ff[ko]*f*vl*sin(arg)

    local lw, byt = elm.l>0 and l/elm.l or 1
    local by = lw*knl[nmul] / fact(nmul-1)
    local bx = lw*ksl[nmul] / fact(nmul-1)

    for i=nmul-1,1,-1 do
      byt = x*by - y*bx + lw*knl[i] / fact(i-1)
      bx  = y*by + x*bx + lw*ksl[i] / fact(i-1)
      by  = byt
    end

    m.px = m.px - ff[ko]*bdir*by/pc*(a + r*cos(arg))
    m.py = m.py + ff[ko]*bdir*bx/pc*(a + r*cos(arg))

    by = -lw*knl[nmul] / fact(nmul-1) / nmul
    bx = -lw*ksl[nmul] / fact(nmul-1) / nmul

    for i=nmul-1,1,-1 do
      byt = x*by - y*bx - lw*knl[i] / fact(i-1) / i
      bx  = y*by + x*bx - lw*ksl[i] / fact(i-1) / i
      by  = byt
    end

    byt = x*by - y*bx
    bx  = y*by + x*bx
    by  = byt

    m.pt = m.pt + ff[ko]*(ko*omega)*bdir*by/pc * r *sin(arg)
  end --over modes
end

local function rfcavity_thin_kick (elm, m, l) -- for tracking thin rf mult
  local x, px, y, py, t, pt, nmul, bdir in m
  local tt, phase, phase0 = elm.tt or 0, elm.phase or 0, elm.phase0 or 0
  local ff, ph = elm.f or {}, elm.ph or {}
  local a, r = elm.a or  0, elm.r or 0
  -- nocavity.and.(.not.always_on)  return
  if 'nocavity' and (not 'always_on') then return end -- non-sense!!!

  local pc = beam.pc
  local volt =elm.volt
  local volt_c = 1.0e-3
  local omega = twopi*freq / clight

  for ko=1,nf do -- over modes
    local arg = ko*omega*(t + tt) + phas + ph[ko] + phase0
    m.pt = m.pt - bdir*volt_c*ff[ko]*volt*sin(arg)/pc

    -- BUG: knl, ksl never retrieved
    local lw, byt = elm.l>0 and l/elm.l or 1
    local by = lw*knl[nmul] / fact(nmul-1)
    local bx = lw*ksl[nmul] / fact(nmul-1)

    for i=nmul-1,1,-1 do
      byt = x*by - y*bx + lw*knl[i] / fact(i-1)
      bx  = y*by + x*bx + lw*ksl[i] / fact(i-1)
      by  = byt
    end

    m.px = m.px - ff[ko]*bdir*by/pc*(a + r*cos(arg))
    m.py = m.py + ff[ko]*bdir*bx/pc*(a + r*cos(arg))

    by = -lw*knl[nmul] / fact(nmul-1) / nmul
    bx = -lw*ksl[nmul] / fact(nmul-1) / nmul

    for i=nmul,2,-1 do
      byt = x*by - y*bx - lw*knl[i-i] / fact(i-2) / (i-1)
      bx  = y*by + x*bx - lw*ksl[i-i] / fact(i-2) / (i-1)
      by  = byt
    end

    byt = x*by - y*bx
    bx  = y*by + x*bx
    by  = byt

    m.t = t - ff[ko]*(ko*omega)*bdir*by/pc * r *sin(arg)
  end --over modes
end

local function adjust_time_cav(elm, m, pos)
  local x, px, y, py, t, pt, T, dir in m
  local _beta = 1/m.beam.beta

  local delta_e = elm.delta_e or 0
  if pos == 'entry' then
    delta_e = pt
    if 'nocavity' and (not 'always_on') then return end -- non-sense!!!

    if elm.l < minlen then
      rfcavity_thin_kick(elm, m)
      delta_e=(m.pt - delta_e)*m.beam.pc -- side effects?
    end
  else
    if elm.l < minlen then return end
    t = t - elm.l*_beta -- TO CHECK      -- side effects?
    delta_e = (pt - delta_e)*m.beam.pc   -- side effects?
  end
end

local function rfcavity_fringe_ptc (elm, m, pos)
  local x, px, y, py, t, pt, T, dir in m

  if ('nocavity' and (not 'always_on')) then return end -- non-sense!!!

  if elm.kill_fringe     == 1                     or
     elm.kill_ent_fringe == 1 and pos ==  'entry' or
     elm.kill_ext_fringe == 1 and pos ==  'exit' then return end

  adjust_time_cav(elm, m, 'entry')

  if not ('fringe' or elm.nbessel == -1) then return end
  if elm.l < minlen then return end

  local kbmad = 0
  if elm.nbessel == -1 then kbmad = 1 end

  local z = 0
  if pos == 'entry' then z = elm.l end
  local freq, volt = elm.freg or 0, elm.volt or 0
  local volt_c = 1.0e-3
  local pc = m.beam.pc
  local omega = twopi*freq / clight
  local vl = m.bdir*volt*volt_c/pc
  if pos == 'exit' then vl = -vl end

  local tt, phase, phase0 = elm.tt or 0, elm.phase or 0, elm.phase0 or 0
  local ph = elm.f or {}, elm.ph or {}
  local nf = elm.nf or 1

  for ko=1,nf do   -- over modes
   s1 = cos(kbmad*ko*omega*z)*sin(ko*omega*(t+tt) + phas + phase0 + ph[ko])
   c1 = cos(kbmad*ko*omega*z)*cos(ko*omega*(t+tt) + phas + phase0 + ph[ko])
   m.px = m.px + 0.5*vl*s1*m.x
   m.py = m.py + 0.5*vl*s1*m.y
   m.pt = m.pt - 0.25*(m.x^2 + m.y^2)*vl*c1*omega*ko
  end

  adjust_time_cav(elm, m, 'exit')
end
--]=]

--]===]
