#ifndef TPSA_TRACK_TEMPLATE
#define TPSA_TRACK_TEMPLATE

#define T struct tpsa

// #define TRACE

void
mad_tpsa_drift(T * restrict m[], num_t L, num_t B_, num_t E)
{
#ifdef TRACE
  printf("tpsa_drift\n");
#endif

  T *x = m[0], *px = m[1];
  T *y = m[2], *py = m[3];
  T *s = m[4], *ps = m[5];

  static T *t1, *t2, *t3;

  if (!t1) {
    t1 = mad_tpsa_new(x->desc, 0);
    t2 = mad_tpsa_new(x->desc, 0);
    t3 = mad_tpsa_new(x->desc, 0);
  }

//  l_pz = e.L/sqrt(1 + (2*B_)*m.ps + m.ps^2 - m.px^2 - m.py^2)
//  m.x = m.x + m.px*l_pz
//  m.y = m.y + m.py*l_pz
//  m.s = m.s + (B_ + m.ps)*l_pz - E*B_

//  assert(x); assert(px);
//  assert(y); assert(py);
//  assert(s); assert(ps);
//  assert(t1); assert(t2); assert(t3);

  mad_tpsa_ax2pby2pcz2(1,ps,-1,px,-1,py,t1);   // ps^2 - px^2 - py^2
  mad_tpsa_axpbypc(2*B_,ps, 1,t1, 1, t1);      // 1 + 2/e.b*m.ps + ps^2 - px^2 - py^2
  mad_tpsa_invsqrt(t1,t2);                     // 1/sqrt(1 + 2/e.b*m.ps + ps^2 - px^2 - py^2) = pz_
  mad_tpsa_scl(t2,L,t1);                       // L/sqrt(1 + 2/e.b*m.ps + ps^2 - px^2 - py^2) = pz_

  T *pz_ = t1;

  mad_tpsa_mul(px,pz_,t2);                      // px*pz_
  mad_tpsa_axpbypc(1,t2, 1,x, 0, x);            // x + px*pz_ -> x
  mad_tpsa_mul(py,pz_,t2);
  mad_tpsa_axpbypc(1,t2, 1,y, 0, y);            // y + py*pz_ -> t

  mad_tpsa_copy(ps,t2);                         // ps
  mad_tpsa_seti(t2,0,B_+t2->coef[0]);           // 1/e.b + ps
  mad_tpsa_mul(t2,pz_,t3);                      // (1/e.b + ps)*pz_
  mad_tpsa_axpbypc(1,t3, 1,s, E, s);            // ps + (1/e.b + ps)*pz_ - (1-e.T)*e.LD/e.b
}

#undef T
#endif
