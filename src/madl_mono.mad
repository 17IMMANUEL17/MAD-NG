--[=[
 o-----------------------------------------------------------------------------o
 |
 | Monomial module
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provides full set of functions and operations on monomials.
  - Support monomials with knobs and inhomogeneous orders.

 o-----------------------------------------------------------------------------o
]=]

local M = {}

-- locals ---------------------------------------------------------------------o

local ffi = require 'ffi'
local istype in ffi
local min, max in math

local _C in MAD

local is_nil, is_integer, is_string, is_iterable, is_lengthable in MAD.typeid

local ord_sz = ffi.sizeof 'ord_t'

-- types ----------------------------------------------------------------------o

--[=[
TODO:
- compressed representation, maximum order is 31
- order encoding: ord = data[i] & 0xFF, idx = data[i] >> 8
- sizeof(mono_t) == 128 byte (i.e. sink opt)

ffi.cdef[[
typedef struct { const ssz_t n; uint32_t data[31]; } mono_t;
]]
]=]

-- for now...
ffi.cdef[[
struct mono { const ssz_t n; ord_t data[?]; };
]]

local mono_ctor = ffi.typeof 'struct mono'
-- local mono_cref = ffi.typeof 'struct mono&'
-- local mono_ccst = ffi.typeof 'struct mono_ccast&'

local is_mono = \x -> istype(mono_ctor, x)

-- ctors ----------------------------------------------------------------------o

-- mono(len)
-- mono(len, num)
-- mono(len, str or itr)
-- mono(str or itr)

local code_0 = string.byte("0")

local function mono (len, ord)
  if is_nil(ord) and is_lengthable(len) then
    len, ord = #len, len -- right shift
  end
  assert(is_integer(len), "invalid monomial length (integer expected)")

  local r = mono_ctor(len, len)
  if is_integer(ord) then
    assert(ord >= 1 and ord <= 31, "invalid monomial order range")
    ffi.fill(r.data, ord_sz * r.n, ord)
  elseif is_string(ord) then
    for i=1,len do r.data[i-1] = string.byte(ord,i) - code_0 end
  elseif is_iterable(ord) then
    for i=1,len do r.data[i-1] = ord[i] end
  else
    error("invalid argument #1 or #2 (integer, string or iterable expected)")
  end
  return r
end

-- size, same, copy -----------------------------------------------------------o

function M.size (a)
  return a.n
end

function M.__same (a, n_)
  return mono_alloc(n_ or a.n)
end

function M.__copy (a, b_)
  local n
  if is_nil(b_) then
    n, a, b_ = a.n, mono_alloc(a.n), a
  else
    assert(is_mono(b_), "invalid argument #1 (monomial expected)")
    n = min(a.n, b_.n)
  end
  ffi.copy(a.data, b_.data, ord_sz*n)
  return a
end

-- implementation -------------------------------------------------------------o

function M.fill (a, v_)
  ffi.fill(a.data, ord_sz * a.n, v_)
  return a
end

function M.min (a)
  return _C.mad_mono_min(a.n, a.data)
end

function M.max (a)
  return _C.mad_mono_max(a.n, a.data)
end

function M.ord (a)
  return _C.mad_mono_ord(a.n, a.data)
end

function M.__len (a)
  return a.n
end

--  io.write("== : a='", tostring(a), "', b='", tostring(b), "'\n")

function M.__eq (a, b)
  assert(is_mono(a), "invalid argument #1 (monomial expected)")
  assert(is_mono(b), "invalid argument #2 (monomial expected)")
  if a.n == b.n then
    return _C.mad_mono_eq(a.n, a.data, b.data) == 1
  end
  if a.n > b.n then a, b = b, a end -- swap to make b longer than a
  return _C.mad_mono_eq (a.n, a.data, b.data) == 1 and
         _C.mad_mono_ord(b.n-a.n, b.data+a.n) == 0
end

function M.__lt (a, b)
  assert(is_mono(a), "invalid argument #1 (monomial expected)")
  assert(is_mono(b), "invalid argument #2 (monomial expected)")
  if a.n == b.n then
    return _C.mad_mono_lt(a.n, a.data, b.data) == 1
  elseif a.n > b.n then
    return false
  else
    return _C.mad_mono_lt(a.n, a.data, b.data) == 1 and
           _C.mad_mono_min(b.n-a.n, b.data+a.n) > 0
  end
end

function M.__le (a, b)
  assert(is_mono(a), "invalid argument #1 (monomial expected)")
  assert(is_mono(b), "invalid argument #2 (monomial expected)")
  if a.n == b.n then
    return _C.mad_mono_le(a.n, a.data, b.data) == 1
  elseif a.n > b.n then
    return _C.mad_mono_le (b.n, a.data, b.data) == 1 and
           _C.mad_mono_ord(a.n-b.n, a.data+b.n) == 0
  else
    return _C.mad_mono_le(a.n, a.data, b.data) == 1
  end
end

function M.__add (a, b, r_)
  assert(is_mono(a), "invalid argument #1 (monomial expected)")
  assert(is_mono(b), "invalid argument #2 (monomial expected)")
  local n = max(a.n,b.n)
  local r = r_ or mono_alloc(n)
  assert(r.n == n, "incompatible monomial sizes")
  if a.n == b.n then
    _C.mad_mono_add(n, a.data, b.data, r.data)
  elseif a.n > b.n then
    _C.mad_mono_add(b.n, a.data, b.data, r.data)
    ffi.copy(r.data+b.n, a.data+b.n, ord_sz*(a.n-b.n))
  else
    _C.mad_mono_add(a.n, a.data, b.data, r.data)
    ffi.copy(r.data+a.n, b.data+a.n, ord_sz*(b.n-a.n))
  end
  return r
end

function M.__sub (a, b, r_)
  assert(is_mono(a), "invalid argument #1 (monomial expected)")
  assert(is_mono(b), "invalid argument #2 (monomial expected)")
  local n = max(a.n,b.n)
  local r = r_ or mono_alloc(n)
  assert(r.n == n, "incompatible monomial sizes")
  if a.n == b.n then
    _C.mad_mono_sub(a.n, a.data, b.data, r.data)
  elseif a.n > b.n then
    _C.mad_mono_sub(b.n, a.data, b.data, r.data)
    ffi.copy(r.data+b.n, a.data+b.n, ord_sz*(a.n-b.n))
  else
    ffi.copy(r.data, a.data, ord_sz*a.n)
    _C.mad_mono_sub(b.n, r.data, b.data, r.data)
  end
  return r
end

function M.__concat (a, b, r_)
  assert(is_mono(a), "invalid argument #1 (monomial expected)")
  assert(is_mono(b), "invalid argument #2 (monomial expected)")
  local r = r_ or mono_alloc(a.n+b.n)
  assert(r.n == a.n+b.n, "incompatible monomial sizes")
  _C.mad_mono_concat(a.n, a.data, b.n, b.data, r.data)
  return r
end

function M.__totable (a)
  local r = table.new(a.n,0)
  for i=1,a.n do r[i] = a.data[i-1] end
  return r
end

function M.__tostring (a, sep_)
  local r = table.new(a.n,0)
  for i=1,a.n do r[i] = tostring(a.data[i-1]) end
  return table.concat(r, sep_ or ' ')
end

-- metamethods ----------------------------------------------------------------o

M.  add, M.  sub, M.length, M.  concat, M.  same, M.  copy =
M.__add, M.__sub, M.__len , M.__concat, M.__same, M.__copy

local function iter (a, i)
  if i < a.n then return i+1, a.data[i] end
end

M.__ipairs = \s -> (iter, s, 0)
M.__pairs  = \s -> (iter, s, 0)

function M.__index (a, i)
  if type(i) == 'number'
  then return i >= 1 and i <= a.n and a.data[i-1] or nil
  else return M[i]
  end
end

function M.__newindex (a, i, o)
  if type(i) == 'number' then
    assert(i >= 1 and i <= a.n, "1-index out of bounds")
    a.data[i-1] = o
  else
    error("invalid monomial member '"..tostring(i).."'")
  end
end

-- env ------------------------------------------------------------------------o

MAD.typeid.is_monomial = is_mono

-- metatable ------------------------------------------------------------------o

M.__metatable = M

ffi.metatype(mono_ctor, M)

-- end ------------------------------------------------------------------------o
return {
   monomial = mono,
  __help = require 'madh_mono',
}
