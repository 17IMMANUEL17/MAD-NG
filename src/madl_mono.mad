--[=[
 o-----------------------------------------------------------------------------o
 |
 | Monomial module
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provides full set of functions and operations on monomials.
  - Support monomials with knobs and inhomogeneous orders.

 o-----------------------------------------------------------------------------o
]=]

local M = {}

-- locals ---------------------------------------------------------------------o

local ffi = require 'ffi'
local istype in ffi
local min in math

local _C in MAD

local is_nil, is_number, is_iterable in MAD.typeid

local ord_sz = ffi.sizeof 'ord_t'

-- types ----------------------------------------------------------------------o

--[=[
TODO:
- compressed representation, maximum order is 31
- order encoding: ord = data[i] & 0xFF, idx = data[i] >> 8
- sizeof(mono_t) == 128 byte (i.e. sink opt)

ffi.cdef[[
typedef struct { ssz_t n; ssz_t data[31]; } mono_t;
]]
]=]

-- for now...
ffi.cdef[[
typedef struct { ssz_t n; ord_t data[?]; } mono_t;
]]

local mono_ctor = ffi.typeof 'mono_t'

local is_mono = \x -> istype(mono_ctor, x)

-- allocators -----------------------------------------------------------------o

local function mono_alloc(n)
  local r = mono_ctor(n)
  r.n = n
  return r
end

-- ctors ----------------------------------------------------------------------o

-- mono(len, val_)
-- mono(tbl)

local function mono (n, val_)
  if is_number(n) then
    local r, v = mono_alloc(n), val_ or 0
    assert(is_number(v), "invalid argument #2 (number expected)")
    for i=0,n-1 do r.data[i] = v end
    return r
  elseif is_iterable(n) then
    local len, tbl = #n, n
    local r = mono_alloc(len)
    for i=1,len do r.data[i-1] = tbl[i] end
    return r
  end
  error("invalid argument #1 (number or table expected)")
end

-- checkers -------------------------------------------------------------------o

local function chksiz (r, a, b) -- add, sub
  assert((is_nil(r) or (r.n == a.n)) and
         (is_nil(b) or (b.n == a.n)), "incompatible monomial sizes")
  return r
end

local function chksizc (r, a, b) -- concat
  assert(is_nil(r) or r.n == a.n+b.n, "incompatible monomial sizes")
  return r
end

-- implementation -------------------------------------------------------------o

function M.size (a)
  return a.n
end

function M.fill (a, v_)
  ffi.fill(a.data, ord_sz * a.n, v_)
  return a
end

function M.copy (a, b_)
  local n
  if is_nil(b_) then
    n, a, b_ = a.n, mono(a.n), a
  else
    assert(is_mono(b_), "invalid argument #1 (monomial expected)")
    n = min(a.n, b_.n)
  end
  ffi.copy(a.data, b_.data, ord_sz*n)
  return a
end

function M.max (a)
  return _C.mad_mono_max(a.n, a.data)
end

function M.ord (a)
  return _C.mad_mono_ord(a.n, a.data)
end

function M.equ (a, b)
  return a.n == b.n and _C.mad_mono_equ(a.n, a.data, b.data)
end

function M.leq (a, b)
  -- TODO...
  assert(a.n == b.n, "incompatible monomial sizes")
  return _C.mad_mono_leq(a.n, a.data, b.data)
end

function M.add (a, b, r_)
  local r = chksiz(r_,a,b) or mono_alloc(a.n)
  _C.mad_mono_add(a.n, a.data, b.data, r.data)
  return r
end

function M.sub (a, b, r_)
  local r = chksiz(r_,a,b) or mono_alloc(a.n)
  _C.mad_mono_sub(a.n, a.data, b.data, r.data)
  return r
end

function M.concat (a, b, r_)
  local r = chksizc(r_,a,b) or mono_alloc(a.n+b.n)
  _C.mad_mono_concat(a.n, a.data, b.n, b.data, r.data)
  return r
end

function M.tostring (a, sep_)
  local r = tbl_new(a.n,0)
  for i=1,a.n do r[i] = tostring(a.data[i-1]) end
  return table.concat(r, sep_ or ' ')
end

M.__eq       = M.equ
M.__le       = M.leq
M.__add      = M.add
M.__sub      = M.sub
M.__len      = M.size
M.__concat   = M.concat
M.__tostring = M.tostring
M.__copy     = M.copy

-- TODO: implement lt not le

M.__lt = function (a, b) return a <= b and a ~= b end

-- monomial-as-array behavior

function M.__index (a, i)
  return type(i) == 'number' and i >= 0 and i < a.n and a.data[i] or M[i]
end

function M.__newindex (a, i, v)
  assert(type(i) == 'number' and i >= 0 and i < a.n, "invalid monomial index")
  a.data[idx] = v
end

-- env ------------------------------------------------------------------------o

MAD.typeid.is_monomial = is_mono

-- metatable ------------------------------------------------------------------o

ffi.metatype(mono_ctor, M)

-- end ------------------------------------------------------------------------o
return {
   monomial =  mono,
  __help = require 'madh_mono',
}
