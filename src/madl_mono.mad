--[=[
 o-----------------------------------------------------------------------------o
 |
 | Monomial module
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provides full set of functions and operations on monomials.
  - Support monomials with knobs and inhomogeneous orders.

 o-----------------------------------------------------------------------------o
]=]

local M = {}

-- locals ---------------------------------------------------------------------o

local ffi = require 'ffi'
local istype in ffi

local _C in MAD

local is_number, is_table in MAD.typeid

-- types ----------------------------------------------------------------------o

--[=[
TODO:
- compressed representation, maximum order is 31
- order encoding: ord = val & 0xFF, idx = val >> 8
- sizeof(mono_t) == 128 byte (i.e. sink opt)

ffi.cdef[[
typedef struct { ssz_t n; ssz_t ord[31]; } mono_t;
]]
]=] 

-- for now...
ffi.cdef[[
typedef struct { ssz_t n; ord_t ord[?]; } mono_t;
]]

local mono_ctor = ffi.typeof 'mono_t'

local is_mono = \x -> istype(mono_ctor, x)

-- allocators -----------------------------------------------------------------o

local function mono_alloc(n)
  local r = mono_ctor(n)
  r.n = n
  return r
end

-- ctors ----------------------------------------------------------------------o

-- mono(len, val_)
-- mono(tbl)

local function mono (n, val_)
  -- local n = is_table(m) and #m or n_ or m
  local mono
  if is_table(n) then
    for i=1,n do r.ord[i-1] = m[i] end
  elseif is_number(m) then
    r = mono_alloc(n)
    for i=0,n-1 do r.ord[i-1] = m    end
  end
  return r
end

-- implementation -------------------------------------------------------------o

function M.size (a)
  return a.n
end

function M.fill (r, v)
  _C.mad_mono_fill(r.n, r.ord, v)
  return r
end

function M.copy (a, r_)
  local r = r_ or mono_alloc(a.n)
  assert(a.n == r.n, "incompatible monomials")
  _C.mad_mono_copy(a.n, a.ord, r.ord)
  return r
end

function M.max (a)
  return _C.mad_mono_max(a.n, a.ord)
end

function M.ord (a)
  return _C.mad_mono_ord(a.n, a.ord)
end

function M.equ (a, b)
  assert(a.n == b.n, "incompatible monomials")
  return _C.mad_mono_equ(a.n, a.ord, b.ord)
end

function M.leq (a, b)
  assert(a.n == b.n, "incompatible monomials")
  return _C.mad_mono_leq(a.n, a.ord, b.ord)
end

function M.add (a, b, r_)
  local r = r_ or mono_alloc(a.n)
  assert(a.n == b.n and a.n == r.n, "incompatible monomials")
  _C.mad_mono_add(a.n, a.ord, b.ord, r.ord)
  return r
end

function M.sub (a, b, r_)
  local r = r_ or mono_alloc(a.n)
  assert(a.n == b.n and a.n == r.n, "incompatible monomials")
  _C.mad_mono_sub(a.n, a.ord, b.ord, r.ord)
  return r
end

function M.concat (a, b, r_)
  local r = r_ or mono_alloc(a.n+b.n)
  assert(a.n+b.n == r.n, "incompatible monomials")
  _C.mad_mono_concat(a.n, a.ord, b.n, b.ord, r.ord)
  return r
end

function M.tostring (a, sep_)
  local n = a:size()
  local r = tbl_new(n,0)
  for i=1,n do r[i] = tostring(a.ord[i-1]) end
  return table.concat(r, sep_ or ' ')
end

M.__eq       = M.equ
M.__le       = M.leq
M.__add      = M.add
M.__sub      = M.sub
M.__len      = M.size
M.__concat   = M.concat
M.__tostring = M.tostring

M.__lt = function (a, b) return a <= b and a ~= b end

-- monomial-as-array behavior
M.__index = function (a, idx)
  return isnum(idx) and idx >= 0 and idx < a.n and a.ord[idx] or M[idx]
end
M.__newindex = function (a, idx, val)
  assert(isnum(idx) and idx >= 0 and idx < a.n, "invalid index")
  a.ord[idx] = val
end

-- env ------------------------------------------------------------------------o

MAD.typeid.is_monomial = is_mono

-- metatable ------------------------------------------------------------------o

ffi.metatype(mono_ctor, M)

-- end ------------------------------------------------------------------------o
return {
   monomial =  mono,
  __help = require 'madh_mono',
}
