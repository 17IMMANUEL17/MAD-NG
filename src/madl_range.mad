--[=[
 o-----------------------------------------------------------------------------o
 |
 | Range module
 |
 | Methodical Accelerator Design - Copyright CERN 2015+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 |          A.Z. Teska, aleksandra.teska at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provides full set of functions and operations on ranges and logranges.

 o-----------------------------------------------------------------------------o
]=]

local M    = { __help = {} }
local Mlog = { __help = M.__help }

-- help -----------------------------------------------------------------------o

M.__help.self = [=[
NAME
  range, logrange -- range and logarithmic range

SYNOPSIS
  r1 = start..stop[..step]  -- raw range
  r2 = range    (start [, stop [, step]])
  r3 = nrange   (start [, stop [, size]])
  r4 = logrange (start [, stop [, step]])
  r5 = nlogrange(start [, stop [, size]])

DESCRIPTION
  Ranges are defined by their start, stop (included) and step arguments. The
  defaults for stop, step and size are respectively start, 1 and 100. A range
  can define various entities using specific values for step:
  - an empty sequence                      (e.g. sign(step) ~= sign(stop-start))
  - a  singleton, a single point  sequence (e.g. step > stop-start for step > 0)
  - an interval , a two    points sequence             (e.g. step == stop-start)
  - a  finite sequence of points           (e.g. step < stop-start for step > 0)
  - an infinite constant sequence   (e.g. step == 0 or 1 for range and logrange)

  Ranges can be used as stateless iterators in generic for loops (i.e. ipairs),
  and provide better numerical stability for non-exact floating point numbers.
  The index (i.e. []), iterators (i.e. ipairs) and get methods return nil
  outside the boundaries (segment interpolation), while the value method does
  not check for boundaries (line interpolation).

RETURN VALUES
  The constructors for range and logrange (argument #3 is step), the
  constructors for nrange and nlogrange (argument #3 is size), their respective
  stateless iterators for generic for loops, and the functions is_range and
  is_logrange to identify the ranges object.

ERRORS
  Constructors trig an error if any of the argument #1, #2 and #3 (if provided)
  are not finite numbers for range and nrange or not strictly positive finite
  numbers for logrange and nlogrange or if size is not a positive number.

REMARK
  The raw range are built by concatenating numbers that create range objects
  storing the user values unmodified, while other constructors adjust the step
  field to fulfil the following properties given r = range(start, stop, step)
  and nr = nrange(start, stop, size):
    0 <= stop - r :value(r :size()-1) < eps
    0 <= stop - nr:value(nr:size()-1) < eps
    nr:size() == size

EXAMPLES
  do
    local range in MAD
    r01 = range(1)
    r02 = range(1,10)
    r03 = range(1,10,2)
    r04 = range(0,1.5,0.1)
    r05 = range(0,-1.5,-0.1)
    r12 = 1..10
    r13 = 1..10..2
    r14 = 0..1.5..0.1
    r15 = 0..-1.5..-.1
    r19 = 0..1.5.. .1
    print(r05.start, r15.stop, r15.step)  -- print 0 -1.5 0.1
  end

SEE ALSO
  None.
]=]

-- locals ---------------------------------------------------------------------o

local new, cdef, istype, typeof, metatype in require 'ffi'
local is_nil, is_nan, is_number, defhelp  in require 'madl_utils'
local eps, huge, inf, sign                in require 'madl_gmath'
local abs, ceil, floor, log, exp          in math

local exp_1 = exp(1)

-- ctypes are xrange and logxrange
cdef [[
  typedef const struct logxrange {
    double logstart, logstop, logstep;
  } logxrange;
]]

-- constructors ---------------------------------------------------------------o

local range    = typeof    'xrange'
local logrange = typeof 'logxrange'

local is_range    = \a -> istype(   'xrange', a)
local is_logrange = \a -> istype('logxrange', a)

-- implementation -------------------------------------------------------------o

--[[
  Motivation to forbid ±inf in constructors:
  - value returns NaN if
      step  == 0    and x     == ±inf  (valid)
      step  == ±inf and x     == 0     (forbid)
    x*step  == ±inf and start == ∓inf  (forbid)
  - size return NaN if
      step  == 0    and stop  == start (guard)
      start == ±inf and stop  == start (forbid)
  - step return NaN if
      size  == 1    and stop  == start (guard)
      start == ±inf and stop  == start (forbid)
]]--

local function value (start, step, x)
  return start + step*x
end

local function size (start, stop, step)
  local diff = stop-start
  if step == 0 then return huge * sign(diff) end
  local size = floor( diff / step ) + 1
  return size < 0 and 0 or size
end

local function step (start, stop, size)
  local diff = stop-start
  if size >  1 then return diff / (size-1) end
  if size == 1 then return huge * sign(diff) end
  return -huge * sign(diff)
end

local function stepeq (step1, step2)
  return step1 == step2 or abs(step1/step2 - 1) < 2*eps
end

--[[
  Motivation to adjust step in constructors:
    The following properties should hold even for rational numbers:
    - size  (start, stop , step_  ) == size_
    - step  (start, stop , size_  ) == step_
    - value (start, step_, size_-1) == stop
    The maximum adjustment is step = step * (1-eps)^2, beyond this value it is
    the user reponsibility to provide better inputs.
]]--

local function adjust (start, stop, step_, size_)
  if size_ ~= nil then
    step_ = step(start, stop, size_)
    if size_ > 1 and size_ > size(start, stop, step_) then
      step_ = step_ - step_*eps
    end
  elseif abs(step_) < huge then
    size_ = size(start, stop, step_)
    if abs(step_) > abs(step(start, stop, size_)) then
      step_ = step_ - step_*eps
    end
  end
  if abs(step_) < huge then
    local last = value(start, step_, size_-1)
    if step_ > 0 and last > stop or step_ < 0 and last < stop then
        step_ = step_ - step_*eps
    end
  end
  return start, stop, step_
end

local function is_empty (start, stop, step)
  return not (step >= 0 and start <= stop or
              step <= 0 and start >= stop or false)
end

local function bounds (start, stop, step)
  if not is_empty(start, stop, step) then
    local last = value(start, step, size(start, stop, step)-1)
    if step > 0 and last <= stop then return start, last end
    if step < 0 and last >= stop then return last, start end
    return start, start
  end
end

local function get (r, x)
  local v = value(r.start, r.step, x)
  if x >= 0 and not is_empty(v, r.stop, r.step) then
    return v
  end
end

local function getlog (r, x)
  local v = value(r.logstart, r.logstep, x)
  if x >= 0 and not is_empty(v, r.logstop, r.logstep) then
    return exp(v)
  end
end

local function iterincr (r, i)
  local v = value(r.start, r.step, i)
  if v <= r.stop then return i+1, v end
end

local function iterdecr (r, i)
  local v = value(r.start, r.step, i)
  if v >= r.stop then return i+1, v end
end

local function iterincrlog (r, i)
  local v = value(r.logstart, r.logstep, i)
  if v <= r.logstop then return i+1, exp(v) end
end

local function iterdecrlog (r, i)
  local v = value(r.logstart, r.logstep, i)
  if v >= r.logstop then return i+1, exp(v) end
end

M   .get      = get
Mlog.get      = getlog

M   .value    = \r,x ->     value(r.   start, r.   step, x)
Mlog.value    = \r,x -> exp(value(r.logstart, r.logstep, x))

M   .size     = \r -> size(r.   start, r.   stop, r.   step)
Mlog.size     = \r -> size(r.logstart, r.logstop, r.logstep)

M   .is_empty = \r -> is_empty(r.   start, r.   stop, r.   step)
Mlog.is_empty = \r -> is_empty(r.logstart, r.logstop, r.logstep)

M   .range    = \r -> (    r.start    ,     r.stop    ,     r.step    )
Mlog.range    = \r -> (exp(r.logstart), exp(r.logstop), exp(r.logstep))

M   .reverse  = \r -> range   (    r.   stop ,     r.   start ,     -r.   step )
Mlog.reverse  = \r -> logrange(exp(r.logstop), exp(r.logstart), exp(-r.logstep))

-- alternate constructors with size = #points specified

local function nrange (start, stop, size)
  size = size or 100
  assert(is_number(size) and size >= 0,
         "invalid argument #3 (positive number expected)" )
  return range(start, stop, nil, ceil(size))
end

local function nlogrange (start, stop, size)
  size = size or 100
  assert(is_number(size) and size >= 0,
         "invalid argument #3 (positive number expected)" )
  return logrange(start, stop, nil, ceil(size))
end

-- metamethods

function M.__new (ct, start, stop, step_, size_)
  assert(is_number(start) and abs(start) < inf,
         "invalid argument #1 (finite number expected)")
  if stop == nil then stop = start end
  assert(is_number(stop ) and abs(stop ) < inf,
         "invalid argument #2 (finite number expected)")
  if step_ == nil then step_ = 1 end -- hardcoded in xrange, do not change!
  assert(is_number(step_) and abs(step_) < inf,
         "invalid argument #3 (finite number expected)")
  return new(ct, adjust(start, stop, step_, size_))
end

function Mlog.__new (ct, start, stop, step_, size_)
  assert(is_number(start) and start > 0 and start < inf,
         "invalid argument #1 (positive finite number expected)")
  if stop == nil then stop = start end
  assert(is_number(stop ) and stop  > 0 and stop  < inf,
         "invalid argument #2 (positive finite number expected)")
  if step_ == nil then step_ = exp_1 end
  assert(is_number(step_) and step_ > 0 and step_ < inf,
         "invalid argument #3 (positive finite number expected)")
  return new(ct, adjust(log(start), log(stop), log(step_), size_))
end

function M.__index (r, a)
  if is_number(a) then return get(r, a-1) else return M[a] end
end

function Mlog.__index (r, a)
  if is_number(a) then return getlog(r, a-1) else return Mlog[a] end
end

function M.__ipairs (r)
  if r.step >= 0
  then return iterincr, r, 0
  else return iterdecr, r, 0 end
end

function Mlog.__ipairs (r)
  if r.logstep >= 0
  then return iterincrlog, r, 0
  else return iterdecrlog, r, 0 end
end

function M.__eq (r1, r2)
  return is_range(r1) and is_range(r2) and r1.start == r2.start and
         r1.stop == r2.stop and stepeq(r1.step, r2.step)
end

function Mlog.__eq (r1, r2)
  return is_logrange(r1) and is_logrange(r2) and r1.logstart == r2.logstart and
         r1.logstop == r2.logstop and stepeq(r1.logstep, r2.logstep)
end

M   .__len = M   .size
Mlog.__len = Mlog.size

M   .__unm = M   .reverse
Mlog.__unm = Mlog.reverse

-- iterators

local irange     = \start, stop, step -> ipairs(    range(start, stop, step))
local inrange    = \start, stop, size -> ipairs(   nrange(start, stop, size))
local ilogrange  = \start, stop, step -> ipairs( logrange(start, stop, step))
local inlogrange = \start, stop, size -> ipairs(lognrange(start, stop, size))

-- bounds

function M.bounds (r)
  return bounds(r.start, r.stop, r.step)
end

function Mlog.bounds (r)
  local start, stop = bounds(r.logstart, r.logstop, r.logstep)
  if start ~= nil then return exp(start), exp(stop) end
end

function M.overlap (r, s)
  local rl, rh = bounds(r.start, r.stop, r.step)
  local sl, sh = bounds(s.start, s.stop, s.step)
  return not (rl == nil or sl == nil or rh < sl or rl > sh)
end

function Mlog.overlap (r, s)
  local rl, rh = bounds(r.logstart, r.logstop, r.logstep)
  local sl, sh = bounds(s.logstart, s.logstop, s.logstep)
  return not (rl == nil or sl == nil or rh < sl or rl > sh)
end

M.__help.value = [=[
NAME
  value, get, [] (index)  -- range interpolation

SYNOPSIS
  rng:value(x)
  rng:get(x)
  rng[x]

DESCRIPTION
  Methods used for interpolating ranges. Value and get methods are iterated from
  0, and indexing starts from 1. Index and get are used for segment
  interpolation, they return nil outside the boundaries, while value is used for
  line interpolation and never fails.

RETURN VALUES
  These methods return the interpolated value for given a data point in the
  range.

EXAMPLES
  do
    local range in MAD
    local rng = range(1,10,1)
    print( rng:value(0)  )                      -- 1
    print( rng:value(9)  )                      -- 10
    print( rng:value(10) )                      -- 11
    print( rng:value(-1) )                      -- 0
    print( rng:value(-10))                      -- -9

    print( rng:get(0)  )                        -- 1
    print( rng:get(9)  )                        -- 10
    print( rng:get(10) )                        -- nil
    print( rng:get(-1) )                        -- nil

    print( rng[0]  )                            -- nil
    print( rng[1]  )                            -- 1
    print( rng[10]  )                           -- 10
    print( rng[11]  )                           -- nil
  end

SEE ALSO
  None.
]=]
M.__help.get     = M.__help.value
M.__help.index   = M.__help.value
M.__help.__index = M.__help.value

M.__help.is_range = [=[
NAME
  is_range, is_logrange, is_empty     -- range identification

SYNOPSIS
  is_range(rng)
  is_logrange(rng)
  rng:is_empty()

DESCRIPTION
  Functions used to identify ranges type and kind.

RETURN VALUES
  is_range and is_logrange return true if their argument is a range of
  respective types. is_empty returns true for empty ranges (i.e. empty segment).

EXAMPLES
  do
    local is_range, is_logrange, logrange, range in MAD
    print( is_range 'yes' )                     -- false
    print( is_range(0..1) )                     -- true
    print( is_logrange(logrange(1,10)) )        -- true

    print( range(1,10,-1):is_empty )            -- true
    print( range(10,1,1) :is_empty )            -- true
    print( range(1,10,1) :is_empty )            -- false
    print(     (1..10..0):is_empty )            -- false
  end

SEE ALSO
  None.
]=]
M.__help.is_empty = M.__help.is_range

M.__help.irange = [=[
NAME
  irange, ilogrange               -- ranges stateless iterators
  inrange, inlogrange             -- ranges stateless iterators

SYNOPSIS
  irange    (start [, stop [, step]])
  ilogrange (start [, stop [, step]])
  inrange   (start [, stop [, size]])
  inlogrange(start [, stop [, size]])

DESCRIPTION
  irange and ilogrange are equivalent to compose ipairs with range and logrange
  respectively. inrange and inlogrange are equivalent to compose ipairs with
  nrange and nlogrange respectively.

RETURN VALUES
  irange, ilogrange, inrange and inlogrange return stateless iterators for
  direct use in for loops.

EXAMPLES
  do
    for i,v in irange(1,10,2)        do print(i,v) end
    for i,v in ilogrange(1,1e6,10)   do print(i,v) end
    for i,v in inrange(1,10,10)      do print(i,v) end
    for i,v in inlogrange(1,1e6,1e6) do print(i,v) end
  end

SEE ALSO
  ipairs
]=]

M.__help.range = [=[
NAME
  range, bounds, overlap

SYNOPSIS
  rng:range()
  lrng:range()
  rng:bounds()
  lrng:bounds()
  rng1:overlap(rng2)
  lrng1:overlap(lrng2)

DESCRIPTION

RETURN VALUES
  range returns the values of start, stop and step of a given range. bounds
  returns the start and stop values that restrain the range, their order is
  dependand on the lead of range. overlap returns true if two ranges have at
  least one common point

EXAMPLES
  do
    local range, nrange, logrange in MAD
    print( (1..10)             :range()  )          -- 1,10,1
    print( logrange(1,10^6,10) :range()  )          -- 1,10^6,10
    print( range(1,10,1)       :bounds() )          -- 1,10
    print( range(10,1,-1)      :bounds() )          -- 1,10
    print( logrange(10^5,10,10):bounds() )          -- 10^5, 10
    print( (1..9)     :overlap(9..1..-1) )          -- true
    print( (-9..-1)   :overlap(0..9)     )          -- false
  end

SEE ALSO
  None.
]=]
M.__help.bounds = M.__help.range

M.__help.equal = [=[
NAME
  ==, size, reverse, (unary) -

SYNOPSIS
  rng1 == rng2
  rng:size()
  lrng:size()
  rng:reverse()
  lrng:reverse()

DESCRIPTION

RETURN VALUES
  size returns the number of points contained in a given range. reverse returns
  range with reversed from original start-stop lead and step with opposite sign.
  Function equal returns true only ifcompared ranges have same start, stop and
  step values.

EXAMPLES
  do
    local logrange, range, nrange in MAD
    print( range(1,20)          ==  1..20..1 )        -- true
    print( nrange(1,20,20)      ==  1..20    )        -- true

    print( range(1,10)         :size() )              -- 10
    print( range(1,-10)        :size() )              -- 0

    print( (1..10..0.1)         :reverse() )          -- (10..1..-0.1)
    print( range(2,20,2)        :reverse() )          -- range(20,2,-2)
    print( logrange(1,10^6,10)  :reverse() )          -- logrange(10^6,1,0.1)
    print( logrange(10^7,10,0.1):reverse() )          -- logrange(10,10^7,10)
  end

SEE ALSO
  None.
]=]
M.__help.size    = M.__help.empty
M.__help.reverse = M.__help.empty

--[=[
-- convertion

local function convert (r, ctor)
  local size = r:size()
  local t = ctor(size,0)
  for i=1,size do
    t[i] = r.start+(i-1)*r.step
  end
  return t
end

function M.totable (r)
  return convert(r, tnew)
end

function M.tostring (r)
  if r.step == 1 then
    return string.format("%g..%g", r.start, r.stop)
  else
    return string.format("%g..%g..%g", r.start, r.stop, r.step)
  end
end

--function M.tovector (r)
--  return convert(r, vector)
--end
]=]

metatype(   'xrange', defhelp(M   )) -- , 'range'   ))
metatype('logxrange', defhelp(Mlog)) -- , 'logrange'))

-------------------------------------------------------------------------------o
return {
  -- constructors
  range       = range,
  logrange    = logrange,
  nrange      = nrange,
  nlogrange   = nlogrange,

  -- iterators
  irange      = irange,
  ilogrange   = ilogrange,
  inrange     = inrange,
  inlogrange  = inlogrange,

  -- type identification
  is_range    = is_range,
  is_logrange = is_logrange,

--  linspace  = nrange,      -- TODO: compose with :tovector()
--  logspace  = nlogrange,   -- TODO: compose with :tovector()

  __help      = M.__help,    -- shared with Mlog
}
