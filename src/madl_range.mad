--[=[
 o-----------------------------------------------------------------------------o
 |
 | Range module
 |
 | Methodical Accelerator Design - Copyright CERN 2015+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 |          A.Z. Teska, aleksandra.teska at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provides full set of functions and operations on ranges and logranges.

 o-----------------------------------------------------------------------------o
]=]

local M, Mlog = {}, {}

-- locals ---------------------------------------------------------------------o

local new, cdef, istype, typeof, metatype in require 'ffi'
local is_nil, is_nan, is_number, defhelp  in require 'madl_utils'
local eps, huge, inf, sign                in require 'madl_gmath'
local abs, ceil, floor, log, exp          in math

local exp_1 = exp(1)

-- ctypes are xrange and logxrange
cdef [[
  typedef const struct logxrange {
    double logstart, logstop, logstep;
  } logxrange;
]]

-- constructors ---------------------------------------------------------------o

local range    = typeof    'xrange'
local logrange = typeof 'logxrange'

local is_range    = \a -> istype(   'xrange', a)
local is_logrange = \a -> istype('logxrange', a)

-- implementation -------------------------------------------------------------o

--[[
  Motivation to forbid ±inf in constructors:
  - value returns NaN if
      step  == 0    and x     == ±inf  (valid)
      step  == ±inf and x     == 0     (forbid)
    x*step  == ±inf and start == ∓inf  (forbid)
  - size return NaN if
      step  == 0    and stop  == start (guard)
      start == ±inf and stop  == start (forbid)
  - step return NaN if
      size  == 1    and stop  == start (guard)
      start == ±inf and stop  == start (forbid)
]]--

local function value (start, step, x)
  return start + step*x
end

local function size (start, stop, step)
  local diff = stop-start
  if step == 0 then return huge * sign(diff) end
  local size = floor( diff / step ) + 1
  return size < 0 and 0 or size
end

local function step (start, stop, size)
  local diff = stop-start
  if size >  1 then return diff / (size-1) end
  if size == 1 then return huge * sign(diff) end
  return -huge * sign(diff)
end

local function stepeq (step1, step2)
  return step1 == step2 or abs(step1/step2 - 1) < 2*eps
end

--[[
  Motivation to adjust step in constructors:
    The following properties should hold even for rational numbers:
    - size  (start, stop , step_  ) == size_
    - step  (start, stop , size_  ) == step_
    - value (start, step_, size_-1) == stop
    The maximum adjustment is step = step * (1-eps)^2, beyond this value it is
    the user reponsibility to provide better inputs.
]]--

local function adjust (start, stop, step_, size_)
  if size_ ~= nil then
    step_ = step(start, stop, size_)
    if size_ > 1 and size_ > size(start, stop, step_) then
      step_ = step_ - step_*eps
    end
  elseif abs(step_) < huge then
    size_ = size(start, stop, step_)
    if abs(step_) > abs(step(start, stop, size_)) then
      step_ = step_ - step_*eps
    end
  end
  if abs(step_) < huge then
    local last = value(start, step_, size_-1)
    if step_ > 0 and last > stop or step_ < 0 and last < stop then
        step_ = step_ - step_*eps
    end
  end
  return start, stop, step_
end

local function is_empty (start, stop, step)
  return not (step >= 0 and start <= stop or
              step <= 0 and start >= stop or false)
end

local function bounds (start, stop, step)
  if not is_empty(start, stop, step) then
    local last = value(start, step, size(start, stop, step)-1)
    if step > 0 and last <= stop then return start, last end
    if step < 0 and last >= stop then return last, start end
    return start, start
  end
end

local function get (r, x)
  local v = value(r.start, r.step, x)
  if x >= 0 and not is_empty(v, r.stop, r.step) then
    return v
  end
end

local function getlog (r, x)
  local v = value(r.logstart, r.logstep, x)
  if x >= 0 and not is_empty(v, r.logstop, r.logstep) then
    return exp(v)
  end
end

local function iterincr (r, i)
  local v = value(r.start, r.step, i)
  if v <= r.stop then return i+1, v end
end

local function iterdecr (r, i)
  local v = value(r.start, r.step, i)
  if v >= r.stop then return i+1, v end
end

local function iterincrlog (r, i)
  local v = value(r.logstart, r.logstep, i)
  if v <= r.logstop then return i+1, exp(v) end
end

local function iterdecrlog (r, i)
  local v = value(r.logstart, r.logstep, i)
  if v >= r.logstop then return i+1, exp(v) end
end

M   .get      = get
Mlog.get      = getlog

M   .value    = \r,x ->     value(r.   start, r.   step, x)
Mlog.value    = \r,x -> exp(value(r.logstart, r.logstep, x))

M   .size     = \r -> size(r.   start, r.   stop, r.   step)
Mlog.size     = \r -> size(r.logstart, r.logstop, r.logstep)

M   .is_empty = \r -> is_empty(r.   start, r.   stop, r.   step)
Mlog.is_empty = \r -> is_empty(r.logstart, r.logstop, r.logstep)

M   .range    = \r -> (    r.start    ,     r.stop    ,     r.step    )
Mlog.range    = \r -> (exp(r.logstart), exp(r.logstop), exp(r.logstep))

M   .reverse  = \r -> range   (    r.   stop ,     r.   start ,     -r.   step )
Mlog.reverse  = \r -> logrange(exp(r.logstop), exp(r.logstart), exp(-r.logstep))

-- alternate constructors with size = #points

local function nrange (start, stop, size)
  size = size or 100
  assert(is_number(size) and size >= 0,
         "invalid argument #3 (positive number expected)" )
  return range(start, stop, nil, ceil(size))
end

local function nlogrange (start, stop, size)
  size = size or 100
  assert(is_number(size) and size >= 0,
         "invalid argument #3 (positive number expected)" )
  return logrange(start, stop, nil, ceil(size))
end

-- metamethods

function M.__new (ct, start, stop, step_, size_)
  assert(is_number(start) and abs(start) < inf,
         "invalid argument #1 (finite number expected)")
  if stop == nil then stop = start end
  assert(is_number(stop ) and abs(stop ) < inf,
         "invalid argument #2 (finite number expected)")
  if step_ == nil then step_ = 1 end -- hardcoded in xrange, do not change!
  assert(is_number(step_) and abs(step_) < inf,
         "invalid argument #3 (finite number expected)")
  return new(ct, adjust(start, stop, step_, size_))
end

function Mlog.__new (ct, start, stop, step_, size_)
  assert(is_number(start) and start > 0 and start < inf,
         "invalid argument #1 (positive finite number expected)")
  if stop == nil then stop = start end
  assert(is_number(stop ) and stop  > 0 and stop  < inf,
         "invalid argument #2 (positive finite number expected)")
  if step_ == nil then step_ = exp_1 end
  assert(is_number(step_) and step_ > 0 and step_ < inf,
         "invalid argument #3 (positive finite number expected)")
  return new(ct, adjust(log(start), log(stop), log(step_), size_))
end

function M.__index (r, a)
  if is_number(a) then return get(r, a-1) else return M[a] end
end

function Mlog.__index (r, a)
  if is_number(a) then return getlog(r, a-1) else return Mlog[a] end
end

function M.__ipairs (r)
  if r.step >= 0
  then return iterincr, r, 0
  else return iterdecr, r, 0 end
end

function Mlog.__ipairs (r)
  if r.logstep >= 0
  then return iterincrlog, r, 0
  else return iterdecrlog, r, 0 end
end

function M.__eq (r1, r2)
  return is_range(r1) and is_range(r2) and r1.start == r2.start and
         r1.stop == r2.stop and stepeq(r1.step, r2.step)
end

function Mlog.__eq (r1, r2)
  return is_logrange(r1) and is_logrange(r2) and r1.logstart == r2.logstart and
         r1.logstop == r2.logstop and stepeq(r1.logstep, r2.logstep)
end

M   .__len = M   .size
Mlog.__len = Mlog.size

M   .__unm = M   .reverse
Mlog.__unm = Mlog.reverse

-- iterators

local irange     = \start, stop, step -> ipairs(    range(start, stop, step))
local inrange    = \start, stop, size -> ipairs(   nrange(start, stop, size))
local ilogrange  = \start, stop, step -> ipairs( logrange(start, stop, step))
local inlogrange = \start, stop, size -> ipairs(lognrange(start, stop, size))

-- bounds

function M.bounds (r)
  return bounds(r.start, r.stop, r.step)
end

function Mlog.bounds (r)
  local start, stop = bounds(r.logstart, r.logstop, r.logstep)
  if start ~= nil then return exp(start), exp(stop) end
end

function M.overlap (r, s)
  local rl, rh = bounds(r.start, r.stop, r.step)
  local sl, sh = bounds(s.start, s.stop, s.step)
  return not (rl == nil or sl == nil or rh < sl or rl > sh)
end

function Mlog.overlap (r, s)
  local rl, rh = bounds(r.logstart, r.logstop, r.logstep)
  local sl, sh = bounds(s.logstart, s.logstop, s.logstep)
  return not (rl == nil or sl == nil or rh < sl or rl > sh)
end

--[=[
-- convertion

local function convert (r, ctor)
  local size = r:size()
  local t = ctor(size,0)
  for i=1,size do
    t[i] = r.start+(i-1)*r.step
  end
  return t
end

function M.totable (r)
  return convert(r, tnew)
end

function M.tostring (r)
  if r.step == 1 then
    return string.format("%g..%g", r.start, r.stop)
  else
    return string.format("%g..%g..%g", r.start, r.stop, r.step)
  end
end

--function M.tovector (r)
--  return convert(r, vector)
--end
]=]

-- help
M   .__help = require 'madh_range'     defhelp(M   , 'range'   )
Mlog.__help = require 'madh_range'     defhelp(Mlog, 'logrange')

-- metatable
metatype(   'xrange', M   )
metatype('logxrange', Mlog)

-------------------------------------------------------------------------------o
return {
  -- constructors
  range       = range,
  logrange    = logrange,
  nrange      = nrange,
  nlogrange   = nlogrange,

  -- iterators
  irange      = irange,
  ilogrange   = ilogrange,
  inrange     = inrange,
  inlogrange  = inlogrange,

  -- type identification
  is_range    = is_range,
  is_logrange = is_logrange,

--  linspace  = nrange,      -- TODO: compose with :tovector()
--  logspace  = nlogrange,   -- TODO: compose with :tovector()

  __help      = M.__help,    -- shared with Mlog
}
