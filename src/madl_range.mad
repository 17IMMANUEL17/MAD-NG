--[=[
 o-----------------------------------------------------------------------------o
 |
 | Range module
 |
 | Methodical Accelerator Design - Copyright CERN 2015+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provides full set of functions and operations on ranges and logranges.

 o-----------------------------------------------------------------------------o
]=]

local M, Mlog = { __help = {} }, { __help = {} }

-- help -----------------------------------------------------------------------o

M.__help.self = [=[
NAME
  range, logrange         -- range and logarithmic ranges

SYNOPSIS
  r1 = range(start [, stop [, step]])
  r2 = nrange(start [, stop [, npoints]])
  r3 = start..stop[..step]

  l1 = logrange(lstart [, lstop [, lstep]])
  r2 = nlogrange(lstart [, lstop [, npoints]])
  l2 = log(lstart..lstop[..lstep])

DESCRIPTION
  Ranges are defined by their start, stop (included) and step arguments. A step
  of value zero or a step with opposite sign to stop-start lead to an empty
  range. The ranges can be used as stateless iterators in for loops (i.e.
  ipairs), and provide better numerical stability for 'true' floating point
  numbers. Some methods like index (i.e. []), iterators (i.e. ipairs) and get
  (segment interpolation) return nil outside the boundaries, and some others
  like value (line interpolation) don't check for boundaries.

RETURN VALUES
  The table constaining the constructors for range and logrange (argument #3 is
  step), the constructors for nrange and nlogrange (argument #3 is npoints), the
  iterators irange and ilogrange for direct use in for loops, and the functions
  is_range and is_logrange to identify the ranges object.

ERROR
  Range and logrange constructors trig an error if the argument #1 is not a
  a number. Nrange and nlogrange constructor triggs an error if any of the input
  arguments is not a number.

EXAMPLES
  r1 = range(start [,stop [,step]])
  r2 = start..stop[..step]
  print(r1.start, r1.stop, r1.step)
  local l1 = range(start [,stop [,step]])

SEE ALSO
  None.
]=]
Mlog.__help.self = M.__help.self

-- locals ---------------------------------------------------------------------o

local new, cdef, istype, typeof, metatype in require 'ffi'
local is_number, is_nil                   in require 'madl_utils'
local abs, ceil, floor, log, max          in math

-- ctypes are xrange and logxrange
cdef [[
  typedef struct logxrange { const double start, stop, step; } logxrange;
]]

-- constructors ---------------------------------------------------------------o

local range    = typeof 'xrange'
local logrange = typeof 'logxrange'

-- implementation -------------------------------------------------------------o

local function is_range (a)
  return istype('xrange', a)
end

local function is_logrange (a)
  return istype('logxrange', a)
end

local function is_empty(start, stop, step)
  return not (step >= 0 and start <= stop or
              step <  0 and start >  stop or false)
end

local function is_emptylog(start, stop, step)
  step = abs(step)
  return not (step >= 1 and (start >= 0 and start <= stop  or
                             start <  0 and start >  stop) or
              step <  1 and (start >= 0 and start >= stop  or
                             start <  0 and start <  stop) or false)
end

--[[local function bounds(start, stop, step)
  if step >= 0 and start <= stop then
    return start, stop
  elseif step < 0 and start > stop then
    return stop, start
  end
end

local function boundslog(start, stop, step)
  step = abs(step)
  if (step >= 1 and start >= 0 and start <= stop) or
     (step <  1 and start <= 0 and start <= stop) then
    return start, stop
  elseif (step >= 1 and start <= 0 and start >= stop) or
         (step <  1 and start >= 0 and start >= stop) then
    return stop, start
  end
end]]

local round = \x -> is_number(x) and (x<0 and floor(x+0.5) or ceil(x-0.5))

local function size (start, stop, step)
  if step > 1 then
    return max(0, round( (stop-start+1)/step +0.5) )
  elseif step < -1 then
    return max(0, round( (stop-start-1)/step +0.5) )
  elseif step ~= 0 then
    return max(0, round( (stop-start  )/step + 1) )
  else
    return 0
  end
end

local function sizelog (start, stop, step)
  return size(log(abs(start)), log(abs(stop)), log(abs(step)))
end

local function n_step (start, stop, nstep)
  if is_range(start) then
    start, stop, nstep = start.start, start.stop, stop -- shift args
  end
  return nstep >= 1 and (stop-start)/abs(ceil(nstep)-1) or 0
end

local function n_steplog (start, stop, nstep)
  if is_range(start) or is_logrange(start) then
    start, stop, nstep = start.start, start.stop, stop -- shift args
  end
  return nstep >= 1 and (stop/start)^(1/abs(ceil(nstep)-1)) or 1
end

local function value (r, x)
  return r.start + r.step*x -- N points => step = (stop-start)/(N-1)
end

local function valuelog (r, x)
  return r.start * r.step^x -- N points => step = (stop/start)^(1/(N-1))
end

local function iterincr (r, i)
  local v = value(r, i)
  if v <= r.stop then return i+1, v end
end

local function iterincrlog (r, i)
  local v = valuelog(r, i)
  if v <= r.stop then return i+1, v end
end

local function iterdecr (r, i)
  local v = value(r, i)
  if v >= r.stop then return i+1, v end
end

local function iterdecrlog (r, i)
  local v = valuelog(r, i)
  if v >= r.stop then return i+1, v end
end

local function get (r, x)
  local v = value(r, x)
  if x >= 0 and ((r.step > 0 and v <= r.stop)  or
                 (r.step < 0 and v >= r.stop)) then
    return v
  end
end

local function getlog (r, x)
  local v = valuelog(r, x)
  local s = abs(r.step)
  if x >= 0 and
    ((s > 1 and r.start > 0 or s < 1 and r.start < 0) and v <= r.stop) or
    ((s > 1 and r.start < 0 or s < 1 and r.start > 0) and v >= r.stop)
  then return v
  end
end

--[[local function canonize(start, stop, step)
  if not is_empty(start, stop, step) then
    return start, stop, step
  end
  return start, stop, 0
end]]

-- alternate constructors with #steps specified

local function nrange (start, stop, nstep)
  if is_nil(nstep) then return range(start, stop) end
  assert(is_number(start) and is_number(stop) and is_number(nstep),
         "invalid argument #1, #2 or #3 (number expected)")
  return range(start, stop, n_step(start, stop, nstep))
end

local function nlogrange (start, stop, nstep)
  if is_nil(nstep) then return range(start, stop) end
  assert(is_number(start) and is_number(stop) and is_number(nstep),
         "invalid argument #1, #2 or #3 (number expected)")
  return logrange(start, stop, n_steplog(start, stop, nstep))
end

-- iterators

local function irange (start, stop, step)
  return ipairs(range(start, stop, step))
end

local function ilogrange (start, stop, step)
  return ipairs(logrange(start, stop, step))
end

-- metamethods

function M.__new (ct, start, stop, step)
  assert(is_number(start), "invalid argument #1 (expect number)")
  if stop == nil then stop = start end   -- default
  if step == nil then step = 1 end       -- default
  return new(ct, start, stop, step)
end

function Mlog.__new (ct, start, stop, step)
  assert(is_number(start), "invalid argument #1 (expect number)")
  if stop == nil then stop = start end   -- default
  if step == nil then step = 2 end       -- default
  return new(ct, start, stop, step)
end

function M.log (a)
  return logrange(a.start, a.stop, a.step)
end

function M.__index (r, a)
  if is_number(a) then return get(r, a-1) else return M[a] end
end

function Mlog.__index (r, a)
  if is_number(a) then return getlog(r, a-1) else return Mlog[a] end
end

function M.__ipairs (r)
  if r.step > 0 then
    return iterincr, r, 0
  elseif r.step < 0 then
    return iterdecr, r, 0
  end
end

function Mlog.__ipairs (r)
  local s = abs(r.step)
  if s > 1 and r.start > 0 or s < 1 and r.start < 0 then
    return iterincrlog, r, 0
  elseif s > 1 and r.start < 0 or s < 1 and r.start > 0 then
    return iterdecrlog, r, 0
  end
end

function M.__eq (r1, r2)
  return is_range(r1) and is_range(r2) and
         r1.start == r2.start and r1.step == r2.step and r1.stop == r2.stop
end

function Mlog.__eq (r1, r2)
  return is_logrange(r1) and is_logrange(r2) and
         r1.start == r2.start and r1.step == r2.step and r1.stop == r2.stop
end

M.__help.is_range = [=[

NAME
  is_range, is_logrange, is_empty     -- identify ranges

SYNOPSIS
  is_range(rng)
  is_logrange(lrng)
  is_empty(start [, stop [, step]])

DESCRIPTION
  Functions used for identifing type of range.

RETURN VALUES
  is_range and is_logrange return true if their argument is a range of
  respective types. is_empty returns true for ranges with step equal to zero or
  step with opposite sign to stop-start lead of range.

EXAMPLES
  local is_range, is_logrange, log in MAD
  local is_empty in range
  print( is_range 'yes' )                     -- false
  print( is_range(0..1) )                     -- true
  print( is_range(log(0..1)) )                -- false

  print( is_logrange 'yes' )                  -- false
  print( is_logrange(0..1) )                  -- false
  print( is_logrange(log(0..1)) )             -- true

  print( is_empty(1,10,-1) )                  -- true
  print( is_empty(10,1,1)  )                  -- true
  print( is_empty(1,10,1)  )                  -- false
  print( is_empty(1,10,0)  )                  -- false

SEE ALSO
  None.
]=]
M.__help.is_logrange = M.__help.is_range
M.__help.is_empty    = M.__help.is_range

M.__help.irange = [=[

NAME
  irange, ilogrange               -- ranges interators

SYNOPSIS
  irange(start [, stop [, step]])
  ilogrange(start [, stop [, step]])

DESCRIPTION
  Functions are an equivalent of ipairs for ranges and logranges.

RETURN VALUES
  irange and ilogrange return the appropriate arguments for stateless iterators
  build from given type of range, that is the iterator function, the object and
  the pre-initial key.

EXAMPLES
  local irange, ilogrange, is_function, is_range in MAD
  local ir = {irange(1,10,1)}
  print( is_function(ir[1]) )                  -- true
  print( is_range(ir[2])    )                  -- true
  print( ir[3] == 0         )                  -- true

  for i,v in irange(1,10,2)       do print(i,v) end
  for i,v in ilogrange(1,10^6,10) do print(i,v) end

SEE ALSO
  ipairs
]=]
M.__help.ilogrange = M.__help.irange

function M.range (r)
  return r.start, r.stop, r.step
end

function Mlog.range (r)
  return r.start, r.stop, r.step
end

function M.size (r)
  return size(r:range())
end

function Mlog.size (r)
  return sizelog(r:range())
end

M.get         = get
M.value       = value
M.nstep       = n_step
M.is_empty    = is_empty
M.__len       = M.size

Mlog.get      = getlog
Mlog.value    = valuelog
Mlog.nstep    = n_steplog
Mlog.is_empty = is_emptylog
Mlog.__len    = Mlog.size

function M.reverse (r)
  return range(r.stop, r.start, -r.step)
end

function Mlog.reverse (r, a)
  return logrange(r.stop, r.start, 1/r.step)
end

function M.bounds (r)
  if r.step > 0 then
    return r.start, r.stop
  elseif r.step < 0 then
    return r.stop, r.start
  end
end

function Mlog.bounds (r)
  if r.step > 1 then
    return r.start, r.stop
  elseif r.step < 1 then
    return r.stop, r.start
  end
end

M.__help.value = [=[

NAME
  value, get, index                   -- range interpolation

SYNOPSIS
  rng:value(x)
  rng:get(x)
  rng[x]

DESCRIPTION
  Functions used for interpolation of ranges.Points from value and get functions
  are iterated from 0, indexing elements starts from 1. Index and get are
  functions used for segment interpolation, they return nil outside the
  boundaries, value is used for line interpolation.

RETURN VALUES
  Function return values of given data points in range.

EXAMPLES
  local range, value, get in MAD
  local rng = range(1,10,1)
  print( rng:value(0)  )                      -- 1
  print( rng:value(9)  )                      -- 10
  print( rng:value(10) )                      -- 11
  print( rng:value(-1) )                      -- 0

  print( rng:get(0)  )                        -- 1
  print( rng:get(9)  )                        -- 10
  print( rng:get(10) )                        -- nil
  print( rng:get(-1) )                        -- nil

  print( rng[1]  )                            -- 1
  print( rng[10] )                            -- 10
  print( rng[11] )                            -- nil
  print( rng[0]  )                            -- nil

SEE ALSO
  None.
]=]
M.__help.get   = M.__help.value
M.__help.index = M.__help.value

M.__help.range = [=[

NAME
  range, bounds

SYNOPSIS
  rng:range()
  lrng:range()
  rng:bounds()
  lrng:bounds()

DESCRIPTION

RETURN VALUES
  range returns the values of start, stop and step of a given range. bounds
  returns the start and stop values that restrain the range, their order is
  dependand on the lead of range.

EXAMPLES
  local range, nrange, logrange in MAD
  print( range(1,10,1)       :range()  )          -- 1,10,1
  print( (1..10)             :range()  )          -- 1,10,1
  print( nrange(1,10,10)     :range()  )          -- 1,10,1
  print( logrange(1,10^6,10) :range()  )          -- 1,10^6,10
  print( nlogrange(1,10,1)   :range()  )          -- 1,10,inf
  print( range(1,10,0)       :bounds() )          -- nil,nil
  print( range(1,10,1)       :bounds() )          -- 1,10
  print( range(10,1,-1)      :bounds() )          -- 1,10
  print( logrange(10^5,10,1) :bounds() )          -- nil, nil
  print( logrange(10^5,10,10):bounds() )          -- 10^5, 10
  print( range(1,10,-1)      :bounds() )          -- 10,1

SEE ALSO
  None.
]=]

M.__help.bounds = M.__help.range

M.__help.equal = [=[

NAME
  equal, size, reversed

SYNOPSIS
  rng1 == rng2
  rng:size()
  lrng:size()
  rng:reverse()
  lrng:reverse()

DESCRIPTION

RETURN VALUES
  size returns the number of possible steps in a given range. reverse returns
  range with reversed from original start-stop lead and step with opposite sign
  for ranges and 1/step for logranges. Function equal returns true only if
  compared ranges have same start, stop and step values.

EXAMPLES
  local logrange, range, nrange in MAD
  print( logrange(1,10^6,10)  == log(1..10^6..10))  -- true
  print( range(1,20)          ==  1..20          )  -- true
  print( range(-1,-20,-1)     == -1..-20..-1     )  -- true
  print( nrange(1,20,20)      ==  1..20          )  -- true

  print( range(1)            :size() )              -- 1
  print( range(1,10)         :size() )              -- 10
  print( range(1,-10)        :size() )              -- 0
  print( logrange(10^7,0,0.1):size() )              -- inf
  print( logrange(1,10^6,1)  :size() )              -- 0
  print( logrange(1,10^6,10) :size() )              -- 7

  print( (1..10..0.1)         :reverse() )          -- (10..1..-0.1)
  print( range(2,20,2)        :reverse() )          -- range(20,2,-2)
  print( nrange(1,2,2)        :reverse() )          -- nrange(2,1,2)
  print( logrange(1,10^6,10)  :reverse() )          -- logrange(10^6,1,0.1)
  print( logrange(10^7,10,0.1):reverse() )          -- logrange(10,10^7,10)

SEE ALSO
  None.
]=]
M.__help.size     = M.__help.empty
M.__help.reversed = M.__help.empty
--[=[

function M.overlap (r, s)
  if r:size() == 0 or s:size() == 0 then
    return false
  end

  local rl, rh = r:bounds()
  local sl, sh = s:bounds()
  return not (rl < sl and rh < sl or rl > sh)
end

-- convertion

local function convert (r, ctor)
  local size = r:size()
  local t = ctor(size,0)
  for i=1,size do
    t[i] = r.start+(i-1)*r.step
  end
  return t
end

function M.totable (r)
  return convert(r, tnew)
end

function M.tostring (r)
  if r.step == 1 then
    return string.format("%g:%g", r.start, r.stop)
  else
    return string.format("%g:%g:%g", r.start, r.stop, r.step)
  end
end

--function M.tovector (r)
--  return convert(r, vector)
--end
]=]

metatype('xrange'   , M   )
metatype('logxrange', Mlog)

-------------------------------------------------------------------------------o
return {
  range       = range,
  logrange    = logrange,
  nrange      = nrange,      -- constructor with N steps
  nlogrange   = nlogrange,   -- constructor with N steps
  irange      = irange,      -- iterator
  ilogrange   = ilogrange,   -- iterator
  is_range    = is_range,
  is_logrange = is_logrange,

  __help      = M.__help,
}
