--[=[
 o-----------------------------------------------------------------------------o
 |
 | Beam module
 |
 | Methodical Accelerator Design - Copyright CERN 2015+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide beam command

 o-----------------------------------------------------------------------------o
]=]

local M = { __help = {} }

-- help -----------------------------------------------------------------------o

M.__help.self = [[
NAME
  beam

SYNOPSIS
  b = beam 'cmd' {}

DESCRIPTION
  The module beam provides...

RETURN VALUES
  The beam object

SEE ALSO
  Object
]]

--[[
Example from J. Jowett for proton-ion beams
Beam1: BEAM, SEQUENCE=LHCB1, ENERGY=6500, PARTICLE=PROTON,
       KBUNCH=588, NPART=3E10,
       EX=5.413107769764368E-10, EY=5.413107769764368E-10, ET=8.5275E-6,
       SIGE=0.0001137, SIGT=0.075;

Beam2: BEAM, SEQUENCE=LHCB2, ENERGY=533000, PARTICLE=ION,
       MASS=193.68715, CHARGE=82,
       KBUNCH=702, NPART=1.5E8,
       EX=5.413107769764368E-10, EY=5.413107769764368E-10, ET=8.5275E-6,
       SIGE=0.0001137, SIGT=0.075;
--]]

--[[
Electromagnetic radius (computation from MAD-X to MAD-NG)
E0 = m0[Kg] c^2[m/s] = m0[eV] qelect[C]
=> m0[Kg] = m0[GeV].1e9.qelect[C] / c^2[m/s] = mass.1e9.qelect/c^2
r = 1/(4.pi.epsilon0) q^2/m0.c^2 (definition)
r = 1/(4.pi/(4.pi.1e-7.c^2)) (charge.qelect)^2 / ((mass.1e9.qelect/c^2).c^2)
r = 1e-7.c^2.charge^2.qelect / (mass.1e9)
r = 1e-16.qelect.c^2 charge^2/mass
where 1e-16 = mu0/(4pi).1e-9 (i.e. GeV)
=> emass.eradius = mu0/(4.pi) qelect.c^2 = 1e-7 qelect.c^2

Lorentz factor:
gamma      = 1/sqrt(1-beta^2)  = E/m
beta       = sqrt(1-1/gamma^2) = v/c
beta.gamma = sqrt(gamma^2-1)
--]]

--[[
attributes that should not be in beam:
  circ    -- total path in m
  freq0   -- revolution frequency in Hz
  dtbyds  -- phase slip factor (eta)
  deltap  -- momentum deviation
  alfac   -- momentum compaction factor (MADX: 1/gamma^2, -dtbyds is missing)
  u0      -- radiation loss in GeV
  qs      -- synchrotron tune
  pdamp   -- damping partition number
  n1min   -- min available aperture
--]]

-- locals ---------------------------------------------------------------------o

local abs, sqrt in math
local Object, tostring in MAD
local is_nil, is_string, is_table, is_number, is_positive, is_integer in MAD
local qelect, eradius, emass, pmass, mumass, clight in MAD.constant

local GeV_c = 1e9/clight

local particledb = {
  'electron', 'positron', 'proton', 'antiproton', 'muon', 'antimuon',
  electron   = { mass=emass , charge=-1, spin=1/2 },
  positron   = { mass=emass , charge= 1, spin=1/2 },
  proton     = { mass=pmass , charge= 1, spin=1/2 },
  antiproton = { mass=pmass , charge=-1, spin=1/2 },
  muon       = { mass=mumass, charge=-1, spin=1/2 },
  antimuon   = { mass=mumass, charge= 1, spin=1/2 },
}

local show_order = {
  'name', 'particle', 'mass', 'charge', 'spin', 'radius',
  'energy', 'pc', 'beta', 'gamma', 'brho',
  'ex', 'ey', 'et', 'exn', 'eyn', 'etn',
  'nbunch', 'nparticle', 'sigx', 'sigy', 'sigt', 'sige',
  'bunched', 'radiate',
}
for _,v in ipairs(show_order) do show_order[v]=v end -- build keys

-- implementation -------------------------------------------------------------o

local beam = Object 'beam' {
  -- particle
  particle  = 'electron',                              --                   [RW]
  mass      = particledb.electron.mass,                -- GeV (m.c^2)       [RO]
  charge    = particledb.electron.charge,              -- ±n qelect         [RO]
  spin      = particledb.electron.spin,                -- ±n/2              [RO]
  radius    = \s -> emass*eradius * s.charge^2/s.mass, -- m                 [RO]
  -- energy
  energy    = 1,                                       -- GeV               [RW]
  pc        = \s -> sqrt(s.energy^2 - s.mass^2),       -- GeV               [RU]
  beta      = \s -> sqrt(1 - (s.mass/s.energy)^2),     --                   [RO]
  gamma     = \s -> s.energy/s.mass,                   --                   [RO]
  brho      = \s -> s.pc*GeV_c/abs(s.charge),          -- T.m               [RO]
  -- emittance
  ex        = 1,                                       -- rad.m             [RW]
  ey        = 1,                                       -- rad.m             [RW]
  et        = 0.001,                                   -- rad.m             [RW]
  exn       = \s -> sqrt(s.gamma^2 - 1)*s.ex,          -- rad.m             [RU]
  eyn       = \s -> sqrt(s.gamma^2 - 1)*s.ey,          -- rad.m             [RU]
  etn       = \s -> sqrt(s.gamma^2 - 1)*s.et,          -- rad.m             [RU]
  -- bunch
  nbunch    = 1,                                       --                   [RW]
  nparticle = 1,                                       -- per bunch         [RW]
  sigx      = 1,                                       -- m                 [RW]
  sigy      = 1,                                       -- m                 [RW]
  sigt      = 1,                                       -- m                 [RW]
  sige      = 0.001,                                   -- GeV               [RW]
  -- flags
  bunched   = true,                                    --                   [RW]
  radiate   = false,                                   --                   [RW]
}

local newidx = rawget(getmetatable(beam),'__newindex')  -- forward to parent
local index  = \s,k,v => newidx(s,k,v) end              -- default forward
local update = setmetatable({
  -- particle
particle = \s,_,v => assert(is_string(v) and particledb[v], "invalid particle")
                     newidx(s, 'particle', v)
                     newidx(s, 'mass'    , particledb[v].mass  )
                     newidx(s, 'charge'  , particledb[v].charge)
                     newidx(s, 'spin'    , particledb[v].spin  ) end,
  mass   = \_,k,_ -> error(k.." is readonly, define a new particle"),
  charge = \_,k,_ -> error(k.." is readonly, define a new particle"),
  spin   = \_,k,_ -> error(k.." is readonly, define a new particle"),
  radius = \_,k,_ -> error(k.." is readonly"),
  -- energy
  energy = \s,_,v => assert(v > s.mass, "invalid energy <= mass")
                     newidx(s, 'energy', v) end,
  pc     = \s,_,v => newidx(s, 'energy', sqrt(v^2 + s.mass^2)) end,
  beta   = \_,k,_ -> error(k.." is readonly, update energy or mass"),
  gamma  = \_,k,_ -> error(k.." is readonly, update energy or mass"),
  brho   = \_,k,_ -> error(k.." is readonly, update energy, mass or charge"),
  -- emittance
  exn    = \s,_,v => newidx(s, 'ex', v/sqrt(s.gamma^2 - 1)) end,
  eyn    = \s,_,v => newidx(s, 'ey', v/sqrt(s.gamma^2 - 1)) end,
  etn    = \s,_,v => newidx(s, 'et', v/sqrt(s.gamma^2 - 1)) end,
},-- default update
{ __index := index })

local function newindex (self, key, val)
  update[key](self,key,val)
end

local function init (self)
  for k,v in pairs(self) do
    newindex(self,k,v)
  end
  return self
end

local function set (self, tbl)
  for k,v in pairs(tbl) do
    newindex(self,k,v)
  end
  return self
end

local function new (self, tbl)
  assert(is_table(tbl), "invalid argument #2 (table expected)")
  local particle, mass, charge, spin in tbl
  assert(is_string(particle), "invalid particle (string expected)")
  assert(is_positive(mass)  , "invalid mass (positive value expected)")
  assert(is_integer(charge) , "invalid charge (integer value expected)")
  assert(is_nil(particledb[particle]), "particle already defined")
  particledb[#particledb+1] = particle
  particledb[particle] = { mass=mass, charge=charge, spin=spin or 1/2 }
  tbl.mass, tbl.charge, tbl.spin = nil, nil, nil
  return set(self, tbl)
end

local function show (self, file)
  file = file or io.stdout
  for i,k in ipairs(show_order) do
    file:write(string.format("%-25s  %-25s\n", k, tostring(self[k])))
  end
  for _,k in ipairs(self:get_varkey()) do
    if is_nil(show_order[k]) then
      file:write(string.format("%-25s  %-25s\n", k, tostring(self[k])))
    end
  end
  return self
end

local function showdb (self, file)
  file = file or io.stdout
  for _,k in ipairs(particledb) do
    local mass, charge, spin in particledb[k]
    file:write(string.format("%-12s: { mass=%-17s, charge=% -2d, spin=% -.1f }\n",
               k, tostring(mass), tostring(charge), tostring(spin)))
  end
  return self
end

beam :set_function {
  set=set, set_variable=set,
  new=new, new_particle=new,
  show=show, showdb=showdb,
}

beam :set_metamethod({ __init=init, __newindex=newindex }, true)
     :set_readonly()

MAD.utility.defhelp(M) -- todo: per function help -> 'beam'

-- end ------------------------------------------------------------------------o
return {
  beam = beam,

  __help = M.__help,
}
