--[=[
 o-----------------------------------------------------------------------------o
 |
 | Generic physics module
 |
 | Methodical Accelerator Design - Copyright (c) 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide useful function for physics computation.
  - For now expect 4D, 5D or 6D systems.

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local vector, cvector, matrix, monomial, damap, cdamap,
      trace, warn, option, typeid                                in MAD
local assertf, errorf, printf, num2str, setkeys, tblcat          in MAD.utility
local lbool                                                      in MAD.operator
local twopi                                                      in MAD.constant
local min, max, abs, sqrt, exp, log, sin, cos, tan, atan2,
      sinh, cosh, real, imag, cplx, fact, rangle                 in MAD.gmath

local is_nil, is_boolean, is_number, is_positive, is_nonzero, is_integer,
      is_natural, is_even, is_odd, is_matrix, is_vector, is_cvector,
      is_damap, is_cdamap, is_table, is_mappable, wrestrict      in MAD.typeid

local assert, table, type =
      assert, table, type

local r4  = 1..4
local I4  = matrix(4):eye()
local I6  = matrix(6):eye()
local I56 = matrix(6):set(5,5,1):set(6,6,1)
local S4  = matrix(4):symp() -- [4x4] symplectic matrix S
local S6  = matrix(6):symp() -- [6x6] symplectic matrix S

              -- i,j,k,l, i,j,k,l, i,j,k,l, i,j,k,l,
local blkidx = { 3,1,1,3, 3,3,1,1 } --, 5,1,1,5, 5,3,3,5 } -- keep order!

-- implementation -------------------------------------------------------------o

local gphys = {
  -- tolerances
  tol = {
    dpt_tol  = 1e-12,
    pha_tol  = 1e-12,
    eig_tol  = 1e-12,
    nrm_tol  = 1e-12,
    symp_tol = 1e-12,
    cplg_tol = 1e-14,
    ofun_tol = 1e-14,
    stab_tol = 1e-16, -- below eps!
  },

  -- optical functions names (index -> name)
  ofname = {
    'alfa11', 'beta11', 'gama11', 'mu1', 'dx', 'dpx', 'Dx', 'Dpx',
    'alfa22', 'beta22', 'gama22', 'mu2', 'dy', 'dpy', 'Dy', 'Dpy',
    'alfa33', 'beta33', 'gama33', 'mu3',
  },

  -- optical functions names with coupling (index -> name)
  ofcname = {
    'alfa11', 'beta11', 'gama11', 'alfa12', 'beta12', 'gama12', 'alfa13', 'beta13', 'gama13', 'mu1', 'dx', 'dpx', 'Dx', 'Dpx',
    'alfa21', 'beta21', 'gama21', 'alfa22', 'beta22', 'gama22', 'alfa23', 'beta23', 'gama23', 'mu2', 'dy', 'dpy', 'Dy', 'Dpy',
    'alfa31', 'beta31', 'gama31', 'alfa32', 'beta32', 'gama32', 'alfa33', 'beta33', 'gama33', 'mu3',
  },

  -- optical functions names with chromatic functions (index -> name)
  ofhname = {
    'alfa11', 'beta11', 'gama11', 'mu1', 'dmu1', 'dx', 'dpx', 'Dx', 'Dpx', 'ddx', 'ddpx', 'wx', 'phix',
    'alfa22', 'beta22', 'gama22', 'mu2', 'dmu2', 'dy', 'dpy', 'Dy', 'Dpy', 'ddy', 'ddpy', 'wy', 'phiy',
    'alfa33', 'beta33', 'gama33', 'mu3', 'dmu3',
  },

  -- optical functions names with coupling and chromatic functions (index -> name)
  ofchname = {
    'alfa11', 'beta11', 'gama11', 'alfa12', 'beta12', 'gama12', 'alfa13', 'beta13', 'gama13', 'mu1', 'dmu1', 'dx', 'dpx', 'Dx', 'Dpx', 'ddx', 'ddpx', 'wx', 'phix',
    'alfa21', 'beta21', 'gama21', 'alfa22', 'beta22', 'gama22', 'alfa23', 'beta23', 'gama23', 'mu2', 'dmu2', 'dy', 'dpy', 'Dy', 'Dpy', 'ddy', 'ddpy', 'wy', 'phiy',
    'alfa31', 'beta31', 'gama31', 'alfa32', 'beta32', 'gama32', 'alfa33', 'beta33', 'gama33', 'mu3', 'dmu3',
  },

  -- optical functions names converter (e.g. from MAD-X), see also beta0
  ofcvtname = {
    -- MAD-X names
    alfx='alfa11', betx='beta11', mux='mu1', dmux='dmu1',
    alfy='alfa22', bety='beta22', muy='mu2', dmuy='dmu2',
    alfz='alfa33', betz='beta33', muz='mu3', dmuz='dmu3', -- not MAD-X

    -- other shortcut
    alfa1='alfa11', beta1='beta11',
    alfa2='alfa22', beta2='beta22',
    alfa3='alfa33', beta3='beta33',

    -- tunes, chromas
    qx='q1', dqx='dq1',
    qy='q2', dqy='dq2',
    qz='q3', dqz='dq3',
  },
}

local phystol = gphys.tol

-- particles ------------------------------------------------------------------o

local val = \a -> is_number(a) and a or nil

function gphys.par2vec (X, V_)
  local V = V_ or vector(6)
  if is_number(X) then return V:fill(X) end
  V[1], V[2] = val(X.x) or X[1] or 0, val(X.px) or X[2] or 0
  V[3], V[4] = val(X.y) or X[3] or 0, val(X.py) or X[4] or 0
  V[5], V[6] = val(X.t) or X[5] or 0, val(X.pt) or X[6] or 0
  return V
end

function gphys.vec2par (V, X_)
  local X = X_ or table.new(0,8)
  X.x, X.px = V[1], V[2]
  X.y, X.py = V[3], V[4]
  X.t, X.pt = V[5], V[6]
  return X
end

-- mtables --------------------------------------------------------------------o

 -- TODO: move to mtable or track or (new) lost

function gphys.mchklost (mtbl)
  assert(typeid.is_mtable(mtbl), "invalid argument #1 (mtable expected)")
  return mtbl.lost == 0 and mtbl or nil
end

local kil = { ksl  =-1,
              k0l  = 1, k1l  = 2, k2l  = 3, k3l = 4, k4l = 5, k5l = 6, k6l = 7,
              k0sl = 1, k1sl = 2, k2sl = 3, k3sl= 4, k4sl= 5, k5sl= 6, k6sl= 7 }

 -- TODO: move to mtable or sequence

function gphys.melmcol (mtbl, cols)
  assert(typeid.is_mtable(mtbl), "invalid argument #1 (mtable expected)")
  assert(is_mappable(cols)     , "invalid argument #2 (mappable expected)")
  assert(typeid.is_sequence(mtbl.__seq), "no attached sequence found")
  assert(not is_nil (mtbl.eidx ), "no elements index column 'eidx' found")
  assert(is_table(mtbl.eidx ) or is_vector(mtbl.eidx),
                "invalid index column 'eidx', (table or vector expected)")

  for k, v in pairs(cols) do
    if is_integer(k) then k = v end
    if not kil[v] then -- standard attribute
      mtbl:addcol(k, \ir =>
        local idx = mtbl.eidx[ir]
        return is_integer(idx) and mtbl.__seq[idx][v] or 0 end)

    elseif kil[v] > 0 then -- add local and integrated strengths
      local knol, kidx = string.sub(v,1,-2), kil[v]
      local knsl = string.sub(knol, -1) ~= 's' and 'knl' or 'ksl'
      mtbl:addcol(k, \ir =>
        local idx = mtbl.eidx[ir]
        if not is_integer(idx) then return 0 end -- implicit drift
        local elm = mtbl.__seq[idx]
        return (elm[knol] or 0) * elm.l + ((elm[knsl] or {})[kidx] or 0) end)
    elseif kil[v] < 0 then -- add special strengths (e.g. solenoid)
      mtbl:addcol(k, \ir =>
        local idx = mtbl.eidx[ir]
        if not is_integer(idx) then return 0 end -- implicit drift
        local elm = mtbl.__seq[idx]
        return (elm.ks or 0) * elm.l + (elm.ksi or 0) end)
    else errorf("unkown element to column generator for '%s'", tostring(v))
    end
  end

  return mtbl
end

-- mflows ---------------------------------------------------------------------o

 -- TODO: move to track

-- particles/damaps status rank: Xset/Mset/Aset/stable/unstable/singular/lost
local mrnk = {Xset=1, Mset=1, Aset=1, stable=1, unstable=2, singular=3, lost=4}
gphys.mrnk = mrnk

-- compare particles/damaps by rank then id
function gphys.mcmp (ma, mb)
  local ra, rb = mrnk[ma.status], mrnk[ma.status]
  assert(ra and rb, "unknown status detected")
  return ra == rb and ma.id < mb.id or ra < rb
end

-- sort particles/damaps, adjust npar
function gphys.msort (mflw, cmp_)
  assert(typeid.is_dynmflow(mflw),"invalid argument #1 (dynamic mflow expected)")

  mflw.npar = #mflw
  if mflw.npar > 1 then table.sort(mflw, cmp_ or gphys.mcmp) end

  -- adjust npar to the number of trackable particles
  for i=mflw.npar,1,-1 do
    if mrnk[mflw[i].status] <= mrnk.stable then mflw.npar=i break end
  end
  return mflw
end

-- checkers -------------------------------------------------------------------o

local function chkeigsiz (V, W)
  assert(is_matrix(V), "invalid argument #1 (matrix expected)")

  local nr, nc = V:sizes()
  assert(nr == 6 and nc == 6 or
         nr == 4 and nc == 4, "invalid sizes (4D/6D matrix expected)")

  if W then
    assert(is_cvector(W) , "invalid argument #2 (cvector expected)")
    assert(W.nrow == nr, "invalid eigenvalues (4D/6D cvector expected)")
  end
end

-- check if system is eigen using eigtol tolerance
-- check R*Vi = Wi*Vi

local eig_tol in phystol

function gphys.is_eigsys (V, W, R, eigtol_)
  local tol = eigtol_ or eig_tol
  chkeigsiz(V, W) ; chkeigsiz(R, W)
  assert(is_positive(tol), "invalid argument #4 (positive number expected)")
  local getc = R.getcol

  for i=1,#W-1,2 do
    local dW = W[i]-W[i+1]:conj()
    if not dW:eq(0, tol) then
      warn("invalid eigenvalues #%d (conjugate pair deviates by %s)",
           i, num2str(dW:abs()))
      return false
    end

    local Vi = cplx(getc(V,i), getc(V,i+1))
    local Vc = Vi:conj()
    local dV1, dV2 = R*Vi-W[i]*Vi, R*Vc-W[i+1]*Vc
    if not (dV1:eq(0, tol) and dV2:eq(0, tol)) then
      warn("invalid eigensystem #%d (R*V%d deviates from W%d*V%d by %s)",
           i, i ,i, i, num2str(max(dV1:norm(),dV2:norm())))
      return false
    end
  end

  return true
end

-- check for delta pt in one-turn map using dptol tolerance

local dpt_tol in phystol

local function has_dpt (m, dptol_)
  local tol = dptol_ or dpt_tol
  assert(is_positive(tol), "invalid argument #2 (positive number expected)")

  if is_matrix(m) then
    if min(6, m:sizes()) < 6 then return false end
    local i = 1
    if abs(m:get(6,6) - 1) <= tol then
      while i <= 5 and abs(m:get(6,i)) <= tol do i = i+1 end
    end
    return i ~= 6

  elseif is_damap(m) then
    if min(6, #m) < 6 then return false end
    local i, pt = 2, m.pt
    if abs(pt:get(7) - 1) <= tol then
      while i <= 6 and abs(pt:get(i)) <= tol do i = i+1 end
    end
    return i ~= 7
  end

  error("invalid argument #1 (matrix or damap expected)")
end

gphys.has_dpt = has_dpt

-- check for coupling blocks in one-turn map using cplg_tol

local cplg_tol in phystol

local function has_cpl (R, cpltol_)
  local tol = cpltol_ or cplg_tol
  assert(is_matrix(R)    , "invalid argument #1 (matrix expected)")
  assert(is_positive(tol), "invalid argument #2 (positive number expected)")

  -- check only transverse coupling
  if blkidx[1] > R.nrow then return false end
  local i,j,k,l = blkidx[1], blkidx[2], blkidx[3], blkidx[4]
  local v = max(abs(R:get(i  ,j)), abs(R:get(i  ,j+1)),
                abs(R:get(i+1,j)), abs(R:get(i+1,j+1)),
                abs(R:get(k  ,l)), abs(R:get(k  ,l+1)),
                abs(R:get(k+1,l)), abs(R:get(k+1,l+1)))
  return v >= tol
end

gphys.has_cpl = has_cpl

-- helpers --------------------------------------------------------------------o

-- conversion between energy deviation and momentum or beta
-- dp = (P-P0)/P0, pt = (E-E0)/P0c
-- (1+dp)^2 = 1 + 2pt/beta + pt^2

function gphys.dp2pt (dp, beta0)
  local _beta0 = 1/beta0
  return dp ~= 0 and sqrt((1+dp)^2 + (_beta0^2-1)) - _beta0 or 0
end

function gphys.pt2dp (pt, beta0)
  return pt ~= 0 and sqrt(1 + 2*pt/beta0 + pt^2) - 1 or 0
end

function gphys.pt2beta (pt, beta0)
  local _beta0 = 1/beta0
  return pt ~= 0 and (1 + (2*_beta0)*pt + pt^2) / (_beta0 + pt) or 0
end

-- compute Poisson bracket from pairs of conjugate column vectors

function gphys.get_pb (V, q_col)
  chkeigsiz(V)
  assert(q_col>0 and q_col<V.ncol and is_odd(q_col), "invalid q-column index")

  local get, pb = V.get, 0

  for i=1,V.nrow-1,2 do
    pb = pb + get(V,i,q_col  ) * get(V,i+1,q_col+1)
            - get(V,i,q_col+1) * get(V,i+1,q_col  )
  end

  return pb
end

-- eigensystem ----------------------------------------------------------------o

-- retrieve eigenvalues from pairs of eigenvectors

function gphys.get_eigval (V, R, W)
  chkeigsiz(V) ; chkeigsiz(R)

  local getc, n = V.getcol, V.nrow

  W = W or cvector(n)

  -- get eigenvalues Wi from eigenvectors Vi: R*Vi = Wi*Vi
  for i=1,V.nrow-1,2 do
    local v = cplx(getc(V,i), getc(V,i+1))
    W[i  ] = get(R,i,i) + get(R,i,i+1)*get(v,i+1,i)/get(v,i,i)
    W[i+1] = W[i]:conj()
  end

  if option.debug >= 2 then
    io.write("**Eigensystem:\n")
    R:print('Vectors ')
    V:print('Eigenvectors ')
    W:print('Eigenvalues ')
  end

  return W
end

-- stability ------------------------------------------------------------------o

-- check stability, enforce orthogonality of planes if needed

local stab_tol in phystol

local function make_stable (R)
  chkeigsiz(R)
  local get, set, nrow in R

  -- check trace stability
  for i=2,nrow,2 do
    local tr = abs(get(R,i-1,i-1)+get(R,i,i))
    if tr > 2 then warn("Tr(R)>2 for plane %d, unstable motion!", i/2) end
  end

  if option.dontstab then return end

  -- stabilize the one-turn-map to avoid unstable eigenvectors in case of
  -- perfectly equal transverse tunes and no coupling. stab_tol is lower than
  -- eps, hence it will remove only numerical noise as the one-turn-map is
  -- supposed to be around the identity where eps represents both a relative
  -- and an absolute numerical error.
  for idx=1,#blkidx,4 do
    if blkidx[idx] > nrow then break end
    local i,j,k,l = blkidx[idx], blkidx[idx+1], blkidx[idx+2], blkidx[idx+3]
    local mx = max(abs(get(R,i  ,j)), abs(get(R,i  ,j+1)),
                   abs(get(R,i+1,j)), abs(get(R,i+1,j+1)),
                   abs(get(R,k  ,l)), abs(get(R,k  ,l+1)),
                   abs(get(R,k+1,l)), abs(get(R,k+1,l+1)))
    if mx < stab_tol then
      set(R,i  ,j,0) ; set(R,i  ,j+1,0)
      set(R,i+1,j,0) ; set(R,i+1,j+1,0)
      set(R,k  ,l,0) ; set(R,k  ,l+1,0)
      set(R,k+1,l,0) ; set(R,k+1,l+1,0)
      break
    end
  end
end

gphys.make_stable = make_stable

-- symplectification ----------------------------------------------------------o

-- symplectifiy one-turn map R if needed
-- Algorithm described in the doctoral thesis of Liam Healey.

local symp_tol in phystol

local function make_symp (R)
  chkeigsiz(R)

  local serr = R:symperr()
  if serr <= symp_tol then return end

  trace(0, "symplectic deviation: %s", num2str(serr))

  if option.dontsymp then return end

  local n, rnk, err = max(R:sizes())
  local I, A, V = R:same():eye()

  V, rnk = (I-R):div(I+R)
  if rnk == n then
    A = (V:bar()-V)/2
    V, rnk = (I+A):div(I-A)
    if rnk == n then V:copy(R) end
  end

  if rnk < n then
    warn("symplectification failed (singular matrix, left unchanged).")
  else
    trace(0, "symplectified deviation: %s", num2str(R:symperr()))
  end
end

gphys.make_symp = make_symp

-- closed form, eigen systems -------------------------------------------------o

-- close dispersion of A from R

local function close_disp (A, R)
  chkeigsiz(A) ; chkeigsiz(R)

  local nr, nc = R:sizes()

  if nr == 4 and nc == 4 then return end

  assert(nr >= 6 and nc >= 6, "invalid one-turn map (6D+ matrix expected)")

  -- close dispersion as a function of pt (multiply by beta for function of dp)
  local D4 = R:getsub(r4, 6)
  local R4 = R:getsub(r4,r4)
  local C4, rnk = (I4-R4):solve(D4)
  -- TODO: make [t,pt] symplectic ?
  A:setsub(r4,6,C4)

  if option.debug >= 2 then
    io.write("**Closed dispersion:\n")
    C4:print('Dispersion ')
  end
end

-- normalize in place eigenvectors such that [x,px]=1, [y,py]=1 and [t,pt]=1

local function norm_eigen (V, W)
  chkeigsiz(V, W)

  local get, set, n = V.get, V.set, V.nrow

  for j=2,n,2 do      -- loop over columns
    local pb = 0      -- poisson bracket (columns pair)
    for i=2,n,2 do
      pb = pb + get(V,i-1,j-1) * get(V,i,j) - get(V,i-1,j) * get(V,i,j-1)
    end
    local spb = sqrt(abs(pb))
    assert(spb > 0, "invalid eigenvectors (unexpected [v,w]=0)")
    if pb < 0 then    -- conjugate of eigenvalues (columns)
       W[j-1], W[j] = W[j-1]:conj(), W[j]:conj()
    end
    for i=1,n do      -- normalize plane (columns)
      set(V,i,j-1,  get(V,i,j-1) /  spb      )
      set(V,i,j  ,  get(V,i,j  ) * (spb / pb))
    end
  end

  if option.debug >= 2 then
    io.write("**Normalized eigensystem:\n")
    W:print('Eigenvalues ')
    V:print('Eigenvectors ') ; io.write("symperr=", num2str(V:symperr()), "\n")
  end
end

-- rephase in place the eigenvectors to obtain the Courant-Snyder form
-- i.e. V(1,2)=0 and mu1>0, V(3,4)=0 and mu2>0, V(5,6)=0 and mu3>0

local function phase_eigen (V)
  chkeigsiz(V)

  local get, set, n = V.get, V.set, V.nrow
  local P = matrix(V.nrow):eye()

  for i=2,n,2 do
    local d = sqrt(get(V,i-1,i-1)^2 + get(V,i-1,i)^2)
    assert(d > 0, "invalid eigenvectors (unexpected denom=0)")
    set(P,i-1,i-1,  get(V,i-1,i-1) / d )
    set(P,i  ,i-1,  get(V,i-1,i  ) / d )
    set(P,i-1,i  , -get(P,i  ,i-1)     )
    set(P,i  ,i  ,  get(P,i-1,i-1)     )
  end

  V:mul(P,V) -- V = P*V

  if option.debug >= 2 then
    io.write("**Rephased eigenvectors:\n")
    V:print('Eigenvectors ') ; io.write("symperr=", num2str(V:symperr()), "\n")
  end
end

-- order in place eigenvectors and eigenvvalues by planes (x,px), (y,py) and
-- (t,pt), detect by horizontal, vertical, longitudinal order

local function order_eigen (V, W)  -- default
  chkeigsiz(V, W)

  local get, n = V.get, V.nrow

  for i=1,n-3,2 do
    local mv, k = 0

    for j=i,n-1,2 do
      local pv = get(V,i,j  )^2 + get(V,i+1,j  )^2 + -- real part
                 get(V,i,j+1)^2 + get(V,i+1,j+1)^2   -- imag part
      if pv > mv then mv, k = pv, j end
    end

    if i ~= k then
      -- swap eigenvectors pairs (i,i+1) with (k,k+1)
      local col = {1,2,3,4}
      col[i], col[i+1] = k, k+1
      V:swpcol(col)
      -- swap eigenvalues pairs (i,i+1) with (k,k+1)
      W[i], W[i+1], W[k], W[k+1] = W[k], W[k+1], W[i], W[i+1]
    end
  end

  if option.debug >= 2 then
    io.write("**Ordered eigensystem:\n")
    W:print('Eigenvalues ')
    V:print('Eigenvectors ')
  end
end

-- order in place eigenvectors and eigenvvalues by planes (x,px), (y,py) and
-- (t,pt), detect by vertical, horizontal, longitudinal order (MAD-X order)

local idx_p = {3,1,5} -- vertical, horizontal, longitudinal
local idx_l = {[1]=3,[3]=1,[4]=5,[6]=3,[8]=1}

local function order_eigen_madx (V, W)  -- for comparison
  chkeigsiz(V, W)

  local get, set, n, idx, sel = V.get, V.set, min(V.nrow,6), {0,0}, {}

  -- collect columns with largest components for each plane
  for k=1,n/2-1 do
    local i, mv = idx_p[k], 0
    for j=1,n-1,2 do
      if not sel[j] then -- not yet selected
        local pv = get(V,i,j  )^2 + get(V,i+1,j  )^2 + -- real part
                   get(V,i,j+1)^2 + get(V,i+1,j+1)^2   -- imag part
        if pv > mv then mv, idx[k], sel[j] = pv, j, true end
      end
    end
  end
  -- last plane: remaining index
  idx[n/2] = idx_l[idx[1]+idx[2]]
  -- swap indexes: vertical, horizontal => horizontal, vertical
  idx[1], idx[2] = idx[2], idx[1]

  -- reorder eigenvectors and eigenvalues
  local Vc, Wc = V:copy(), W:copy()
  for kk,j in ipairs(idx) do
    local k = 2*kk-1
    if k ~= j then
      for i=1,n do
        set(V,i,k  , get(Vc,i,j  ))
        set(V,i,k+1, get(Vc,i,j+1))
      end
      W[k], W[k+1] = Wc[j], Wc[j+1]
    end
  end

  if option.debug >= 2 then
    io.write("**Ordered eigensystem:")
    for kk,j in ipairs(idx) do io.write(' ',j,'->',2*kk-1) end
    io.write('\n')
    W:print('Eigenvalues ')
    V:print('Eigenvectors ')
  end
end

-- phasors ----------------------------

local c_val = {[1]={0.5, 0.5; -0.5i, 0.5i}, [-1]={1, 1i; 1, -1i}}
local c_pbv = {[1]=-2i,                     [-1]=0.5i}

local function phasor (c, inv_)
  local v, r = c_val[inv_ or 1], c_pbv[inv_ or 1]

  assert(is_cdamap(c), "invalid argument #1 (cdamap expected)" )
  assert(is_table (v), "invalid argument #2 (-1 or 1 expected)")

  for i=2,#c,2 do -- 2,4,6,..
    c[i-1]:clear():set(i, 0, v[1]):set(i+1, 0, v[2]) -- c[1]
    c[i  ]:clear():set(i, 0, v[3]):set(i+1, 0, v[4]) -- c[2]
  end

  return c, r
end

gphys.phasor = phasor

-- linear normal form ---------------------------------------------------------o

-- check one-turn map linear normalisation
-- check that N = (A^-1 * R * A) [= Abar * R * A] contains only rotations

local nrm_tol in phystol

function gphys.is_normal1 (A, R, nrmtol_)
  local tol = nrmtol_ or nrm_tol
  local get, set, n = A.get, A.set, A.nrow

  -- use inverse in case of strong symplectic deviation
  local N = A:inv() * R * A

  for i = 1,n-1,2 do
    local a1 = atan2( get(N,i,i+1), get(N,i  ,i  ))
    local a2 = atan2(-get(N,i+1,i), get(N,i+1,i+1))
    if abs(a1-a2) > tol then
      warn("invalid linear normal form #%d (deviates from a pure rotation by %s)",
           i, num2str(a1-a2))
      R:print('R') ; N:print('N')
      return false
    end
    N:setsub(i..i+1, i..i+1, 0)
  end
  if not N:eq(0, tol) then
    warn("invalid linear normal form N (contains coupling terms)")
    R:print('R') ; N:print('N')
    return false
  end

  return true
end

-- linear normal form in matrix A from one-turn-map R in place ----------------o

function gphys.normal1 (R, nocheck_) -- matrix combining normal_a0 and normal_a1
  assert(is_matrix(R), "invalid argument #1 (matrix expected)")

  local fmt
  if option.debug >= 2 then
    io.write("-> Linear normal form\n")
    fmt, option.numfmt = option.numfmt, "% .5e"
  end

  local nr, nc = R:sizes()

  -- one-turn map R
  chkeigsiz(R)
  if option.debug >= 2 then
    io.write("One-turn map (input):\n")
    R:print('R ') ; io.write("symperr=", num2str(R:symperr()), "\n")
  end

  -- detect rank of the system
  local dim = min(nr,nc)
  local rnk = dim >= 6 and has_dpt(R) and 6 or 4
  local R6

  -- switch to 4D
  if rnk == 4 and dim > 4 then R6, R = R, R:getsub(r4,r4) end

  -- stabilise R if needed
  make_stable(R)

  -- symplectifiy R if needed
  make_symp(R)

  -- get eigenvalues (W) and eigenvectors (Vl, Vr) of R
  local W, _, A, info = R:eigen()

  -- initial conditions for normal form calculation
  if option.debug >= 2 then
    io.write("**Eigensystem:\n")
    R:print('Input vectors ')
    W:print('Eigenvalues ')
    A:print('Eigenvectors ')
  end

  -- check that system is eigen
  if not nocheck_ then gphys.is_eigsys(A, W, R) end

  -- normalize eigen system
  norm_eigen(A, W)

  -- order eigenvalues and eigenvectors by planes
  order_eigen(A, W)

  -- rephase eigen vectors to Courant-Snyder form
  phase_eigen(A)

  -- check that system is a linear normal form
  if not nocheck_ then gphys.is_normal1(A, R) end

  -- back to 6D, close dispersion (5D)
  if rnk == 4 and dim > 4 then
    A, R = I6:copy():setsub(r4,r4,A), R6
    close_disp(A, R)
  end

  if option.debug >= 2 then
    io.write("Linear normalising map (output):\n")
    A:print('A ') ;
    option.numfmt = fmt
    io.write("<- Linear normal form\n")
  end

  return A, rnk, info
end

-- linear and non-linear normal form ------------------------------------------o

local nf_id = {}
local is_nf = \a -> a.__id == nf_id

-- normal form init -------------------------------------------------

local function normal_init (m)
  assert(is_damap(m), "invalid argument #1 (damap expected)")

  local siz = m.__td.nn
  local dim = m.__td.nv
  local rnk = has_dpt(m) and dim or min(5,#m)
  local m_n = m:copy()                     -- make a copy

  return {
   __id = nf_id,                           -- is_nf
    siz = siz,                             -- #(variables + parameters)
    dim = dim,                             -- #(variables)
    rnk = rnk,                             -- #(effective variables)
    m   = m,                               -- link to damap
    m_n = m_n:set0(0),                     -- ongoing processed map
  }
end

-- closed form (fix point) = a0^-1 * m * a0 -------------------------

local function normal_a0 (nf)
  assert(is_nf(nf), "invalid argument #1 (normal form expected)")

  local m_n, rnk, dim, siz in nf
  if is_even(rnk) then                     -- true 2D, 4D or 6D (no parameter)
    nf.a0 = m_n:same():eye()
    return nf.a0                           -- identity damap or matrix
  end

  local v, x = m_n:copy(), m_n:same()      -- case 2nD+1, e.g. case 5D
  for i=1,rnk-1 do v[i]:set(i+1,1,-1) end  -- sub identity to variables
  for i=rnk,siz do x[i]:setvar(0,i) end    -- set parameters to identity

  v:cutord(2, v)                           -- keep 1st order only

  local a0 = v^-1 * x                      -- close the 2nD+1 form

  v      :write"fort/fort_n.1011" ;
  (v^-1) :write"fort/fort_n.1012" ;
  x      :write"fort/fort_n.1013" ;
  a0     :write"fort/fort_n.1014" ;
  a0     :write"fort/fort_n.1015" ;

  for i=1,rnk-1 do a0[i]:set(i+1,1,1) end  -- add identity to variables

  nf.m_n = a0^-1 * m_n * a0                -- fix point
  nf.a0  = a0
  nf.rnk = rnk-1                           -- now we are parameter independant
  return a0
end

-- linear normal form = a1^-1 * (a0^-1 * m * a0) * a1 ---------------o

local function normal_a1 (nf)
  assert(is_nf(nf), "invalid argument #1 (normal form expected)")

  local m_n, rnk, dim, siz in nf
  local R, Rg = m_n:get1()  -- retrieve one-turn map

  -- remove parameters
  if rnk < dim then Rg, R = R, R:getsub(1..rnk,1..rnk) end

  make_stable(R)    -- stabilise    R if needed
  make_symp  (R)    -- symplectifiy R if needed

  -- take transpose?
  local W, _, A, info = R:eigen() -- eigenvalues (W) and right eigenvectors (A)

   norm_eigen(A, W) -- normalize eigen system
  order_eigen(A, W) -- order eigenvalues and eigenvectors by planes
  phase_eigen(A)    -- rephase eigen vectors to Courant-Snyder form

  -- set parameters to identity
  if rnk < dim then R = Rg:eye():setsub(1..rnk,1..rnk,A) end

  local a1 = m_n:same():set1(R)
  a1.x, a1.px = -a1.x, -a1.px              -- TO CHECK!!!

  nf.m_n = a1^-1 * m_n * a1                -- linear normal form
  nf.a1  = a1
  return a1
end

-- phasor basis = c^-1 * (a1^-1 * (a0^-1 * m * a0) * a1) * c --------o

local function normal_c (nf)
  assert(is_nf(nf), "invalid argument #1 (normal form expected)")

  local m_n in nf

  local c, cr = phasor(m_n:same(0i):eye(), 1) -- get phasor

  nf.m_n = c^-1 * m_n * c                     -- go to phasor basis
  nf.c, nf.cr = c, cr
  return c, cr
end

-- full normal form -------------------

local function cmpfort(lst)
  local dum = damap()
  local openfile in MAD.utility

  for i, v in ipairs(lst) do
    local f_p = assert(openfile("fort/fort."  ..v))
    local f_n = openfile("fort/fort_n."..v, '.dat')
    if f_n then
      io.stderr:write("processing files ", v, "\n")
      f_n:read() ; f_p:read() ; f_p:read()
      local m_n = dum:read(f_n)                                        ; m_n:print(1e-13)
      local m_p = dum:read(f_p,"C"):fromptc():write("fort/fort_p."..v) ; m_p:print(1e-13)
      local m_d = m_n:dif(m_p):write("fort/fort_d."..v)                ; m_d:print(1e-13)
      f_n:close()
    end
    f_p:close()
  end
end

function gphys.normal_new (m, nocheck_)
  assert(is_damap(m), "invalid argument #1 (damap expected)")

  -- already a normalizing form
  if m.status == 'Aset' then return end

  -- linear normal form -------------------------

  io.stderr:write("linear normal form\n")

  local nf = normal_init(m)  ; print("nf.rnk=", nf.rnk)           ; nf.m_n:write("fort/fort_n.1010", 'm_n') -- one-turn map
  local a0 = normal_a0  (nf) ; a0:write("fort/fort_n.1020", 'a0') ; nf.m_n:write("fort/fort_n.1030", 'm_n') -- closed form (fix point)
  local a1 = normal_a1  (nf) ; a1:write("fort/fort_n.1040", 'a1') ; nf.m_n:write("fort/fort_n.1050", 'm_n') -- linear normal form
  local m  = nf.m_n
  m.status = 'Aset'

   -- stop here for order 1
  if min(m:maxord(), m:gtrunc()) == 1 then
    return m, nf
  end

  -- phasor basis -------------------------------

  io.stderr:write("phasor basis\n")

  local c, cr = normal_c(nf) ; c:write("fort/fort_n.1060", 'c') ; nf.m_n:write("fort/fort_n.1070",'m_n') -- resonance basis

  cmpfort{"1010","1011","1012","1013","1014","1015","1016","1017","1018","1019",
          "1020","1030","1040","1050","1060","1070"}

  -- non-linear normal form ---------------------

  io.stderr:write("non-linear normal form\n")

--[[
  -- prepare factored Lie representation of A and N
  local m_n, rnk in nf
  local nv, mo, np, po in m_n.__td
  local tc = cdamap{nv=rnk, mo=mo+1, np=np+nv-rnk, po=po, vn=m.__vn}   -- tmp for conv.
  local f_op, t_op, id = {m_n:same()}, {m_n:same()}, m_n:same():eye()
  local ham, gnf, anh = {}, {}, {}
  local mono = monomial(#m_n)

  -- non-linear normal form iteration -----------
                                                                                -- print('LD: Linearizing Map A1') ; a1:print(1e-13)
  -- retrieve the tunes
  local mu = cvector(#m_n/2)
  for i=2,#m_n,2 do mu[i/2] = log( m_n[i-1]:get(i) ) end                        -- print('Tunes(mu)=') ; (mu/twopi):print(1e-13)

  -- linear map (only) in phasors basis
  local r1i = m_n:same():set1(m_n:get1():t()) -- transpose for map inverse      -- print("LD: R1I") ; r1i:print(1e-13)

  -- nonlinear iterations
  for n=2,m_n:maxord() do                                                       -- print('LD: ORDER=', n) ; io.stderr:write("LD: ORDER=", n, '\n')
    -- project remaining orders on resonance basis
    local n_n = (m_n * r1i):lieexppb(t_op, -1)                                  -- print('LD: exp_inv(N_n)=') ; n_n:print(1e-13)
    -- compute the pseudo hamiltonian from the vector field
    local g_n = n_n:getord(n):convert(tc):fld2vec() / cr                        -- print('LD: K_n=') ; k_n:print(1e-13)
    local f_pb, t_pb = g_n:same(), g_n:same()
    local i, v = 0

    -- select/reject resonances
    while true do
      i, v = g_n:cycle(i, mono)
      if i == 0 then break; end

      local s = 0
      for j=2,#mono,2 do s = s + (mono[j]-mono[j-1]) * mu[j/2] end

      -- local fp = mono:ford()        -- "denormalized" by the factorials?
      local ms = mono:tostring()
      ham[#ham+1], ham[ms] = ms, v               -- ham terms

      if s ~= 0 then
        v = v / (1 - exp(s))
        f_pb:set(mono, 0, v)
        gnf[#gnf+1], gnf[ms] = ms, v             -- gnf terms
      else
        t_pb:set(mono, 0, v)
        anh[#anh+1], anh[ms] = ms, -v/twopi      -- anh terms
      end
    end

    -- compute vector fields
    local f_n = tc:vec2fld(f_pb):convert(m_n:same()) * cr                       -- print('LD: F_n=') ; f_n:print(1e-13)
    local t_n = tc:vec2fld(t_pb):convert(m_n:same()) * cr                       -- print('LD: T_n=') ; t_n:print(1e-13)
    f_op[n], t_op[n] = f_n, t_n
    if n == m_n:maxord() then break end
                                                                                -- print('LD: M_N= (before), order=', n) m_n:print(1e-13) ; io.stderr:write("LD: M_N= (before), order=", n, "\n")
    -- kill resonances in the map
    m_n = f_n:exppb((-f_n):exppb(id) * m_n)                                     -- print('LD: M_N= (after), order=', n) m_n:print(1e-13) ; io.stderr:write("LD: M_N= (after), order=", n, "\n")
  end
  -- the normalizing map A
  local a = a1 * c * id:lieexppb(f_op) * c^-1                                   -- print('Normalizing map A=') ; a:print(1e-13)

  -- convert A back to M, i.e. real damap with full rank
  m = a:copy(tr):convert(m_)

  -- return m, RDTs, a (= complex rank-reduced m), f and t Lie operators
  return m, {ham=ham, gnf=gnf, anh=anh}, a, f_op, t_op

--]]
end

-- full normal form -------------------

function gphys.normal (m, nocheck_)
  assert(is_damap(m), "invalid argument #1 (damap expected)")

  -- already a normalizing form
  if m.status == 'Aset' then return end

  -- linear normal form -------------------------

  local A, rnk, info = gphys.normal1(m:get1(), nocheck_)
  if info ~= 0 then return nil, rnk, info end
  m.status = 'Aset'

   -- stop here for order 1
  if min(m:maxord(), m:gtrunc()) == 1 then
    return m:clear():set1(A)
  end

  -- local version (no orbit)
  local a1 = m:same():set1(A)
!  a1.x = -a1.x ; a1.px = -a1.px -- adjust sign related to phase branch?

  -- non-linear normal form ---------------------

  -- create damaps rnk number of variables (for now)
  local nv, mo, np, po in m.__td
  local tr = damap{nv=rnk, mo=mo, np=np, po=po, vn=m.__vn}      -- tmp for conv.

  -- convert to complex damap for normal form
  local mc = m :convert(tr):copy(tr:same(0i)) -- clear orbit
  local ac = a1:convert(tr):copy(tr:same(0i))

  -- rename cdamaps for convenience
  local m_, a1_ = m, a1 ; m, a1 = mc, ac

  -- create phasors c, ci=1/c and their normalization factor cr and cri = 1/cr
  local c , cr  = phasor(m:same(),  1)
  local ci, cir = phasor(m:same(), -1) -- c^-1

  -- prepare factored Lie representation of A and N
  local tc = cdamap{nv=rnk, mo=mo+1, np=np, po=po, vn=m.__vn}   -- tmp for conv.
  local f_op, t_op, id = {m:same()}, {m:same()}, m:same():eye() -- identity map
  local ham, gnf, anh = {}, {}, {}
  local mono = monomial(#m)

  -- non-linear normal form iteration -----------
                                                                                -- print('LD: Linearizing Map A1') ; a1:print(1e-13)
  -- first iteration, linear normal form in phasor basis
  local m_n = ci * a1^-1 * m * a1 * c                                           -- print("LD: M1 = C^-1 * A1^-1 * M * A1 * C") ; m_n:print(1e-13)

  -- retrieve the tunes
  local mu = cvector(#m_n/2)
  for i=2,#m_n,2 do mu[i/2] = log( m_n[i-1]:get(i) ) end                        -- print('Tunes(mu)=') ; (mu/twopi):print(1e-13)

  -- linear map (only) in phasors basis
  local r1i = m:same():set1(m_n:get1():t()) -- transpose for map inverse        -- print("LD: R1I") ; r1i:print(1e-13)

  -- nonlinear iterations
  for n=2,m:maxord() do                                                         -- print('LD: ORDER=', n) ; io.stderr:write("LD: ORDER=", n, '\n')
    -- project remaining orders on resonance basis
    local n_n = (m_n * r1i):lieexppb(t_op, -1)                                  -- print('LD: exp_inv(N_n)=') ; n_n:print(1e-13)
    -- compute the pseudo hamiltonian from the vector field
    print('LD: before convert ord=', n) ; n_n:getord(n):print(1e-13)
    print('LD: after  convert ord=', n) ; n_n:getord(n):convert(tc):print(1e-13)

    local g_n = n_n:getord(n):convert(tc):fld2vec() * cir --[[ /-2i --]]        print('LD: G_n=') ; (g_n*cr):print(1e-13)
    local f_pb, t_pb = g_n:same(), g_n:same()
    local i, v = 0

    -- select/reject resonances
    while true do
      i, v = g_n:cycle(i, mono)
      if i == 0 then break; end

      local s = 0
      for j=2,#mono,2 do s = s + (mono[j]-mono[j-1]) * mu[j/2] end

      local ms = mono:tostring()
      ham[#ham+1], ham[ms] = ms, v                -- ham terms

      if s ~= 0 then
        v = v / (1 - exp(s))
        f_pb:set(mono, 0, v)
        gnf[#gnf+1], gnf[ms] = ms, v              -- gnf terms
      else
        t_pb:set(mono, 0, v)
        local p = 1
        for j=2,#mono,2 do p = p * fact(mono[j-1]) end
        anh[#anh+1], anh[ms] = ms, p*v/twopi      -- anh terms
      end
    end

    -- compute vector fields
    local f_n = tc:vec2fld(f_pb):convert(m:same()) * cr --[[ *-2i --]]          -- print('LD: F_n=') ; f_n:print(1e-13)
    local t_n = tc:vec2fld(t_pb):convert(m:same()) * cr --[[ *-2i --]]          -- print('LD: T_n=') ; t_n:print(1e-13)
    f_op[n], t_op[n] = f_n, t_n
    if n == m:maxord() then break end
                                                                                -- print('LD: M_N= (before), order=', n) m_n:print(1e-13) ; io.stderr:write("LD: M_N= (before), order=", n, "\n")
    -- kill resonances in the map
    m_n = f_n:exppb((-f_n):exppb(id) * m_n)                                     -- print('LD: M_N= (after), order=', n) m_n:print(1e-13) ; io.stderr:write("LD: M_N= (after), order=", n, "\n")
  end
  -- the normalizing map A
  local a = a1 * c * id:lieexppb(f_op) * ci                                     -- print('Normalizing map A=') ; a:print(1e-13)

  -- convert A back to M, i.e. real damap with full rank
  m = a:copy(tr):convert(m_)

  -- return m, RDTs, a (= complex rank-reduced m), f and t Lie operators
  return m, {ham=ham, gnf=gnf, anh=anh}, a, f_op, t_op
end

-- beta0 block conversion -----------------------------------------------------o

local ofun_tol in phystol

local function oval (x)
  return abs(x) < ofun_tol and 0 or x
end

-- convert beta0 block (optical functions) to A (normalising form)

function gphys.bet2map (bb0, map, sav_) -- TODO: move to beta0
  assert(typeid.is_beta0(bb0), "invalid argument #1 (beta0 block expected)")
  assert(       is_damap(map), "invalid argument #2 (damap expected)")

  local rnk = bb0.rank or 4
  local cpl = bb0.cplg or nil
  local dir = bb0.sdir or 1
  local X   = (bb0.X or vector(6)):zeros()
  local A   = (bb0.A or matrix(6)):eye()

  -- normalization matrix A of the one-turn map R: N = A^-1 R A

  local get, set = A.get, A.set

  -- set orbit
  if bb0.x  then set(X,1,1, bb0.x ) end
  if bb0.px then set(X,2,1, bb0.px) end
  if bb0.y  then set(X,3,1, bb0.y ) end
  if bb0.py then set(X,4,1, bb0.py) end
  if bb0.t  then set(X,5,1, bb0.t ) end
  if bb0.pt then set(X,6,1, bb0.pt) end

  -- x plane

  local beta11 = bb0.beta11 or bb0.beta1 or bb0.betx or 1
  local alfa11 = bb0.alfa11 or bb0.alfa1 or bb0.alfx or 0
  local gama11 = bb0.gama11 or (1+alfa11^2)/beta11

  assertf(beta11 > 0, "invalid beta11=%.3fm (>0 expected)", beta11)

  local A11 = sqrt(beta11)
  local A21 = -alfa11/A11
  local A22 = sqrt(gama11 - A21^2) -- 1/A11

  set(A,1,1, A11) ; set(A,1,2,  0 ) -- Courant-Snyder form
  set(A,2,1, A21) ; set(A,2,2, A22)

  -- y plane

  local beta22 = bb0.beta22 or bb0.beta2 or bb0.bety or 1
  local alfa22 = bb0.alfa22 or bb0.alfa2 or bb0.alfy or 0
  local gama22 = bb0.gama22 or (1+alfa22^2)/beta22

  assertf(beta22 > 0, "invalid beta22=%.3fm (>0 expected)", beta22)

  local A33 = sqrt(beta22)
  local A43 = -alfa22/A33
  local A44 = sqrt(gama22 - A43^2) -- 1/A33

  set(A,3,3, A33) ; set(A,3,4,  0 ) -- Courant-Snyder form
  set(A,4,3, A43) ; set(A,4,4, A44)

  -- t plane

  local beta33 = bb0.beta33 or bb0.beta3 or bb0.betz or 0

  if beta33 ~= 0 then
    local alfa33 = bb0.alfa33 or bb0.alfa3 or bb0.alfz or 0
    local gama33 = bb0.gama33 or (1+alfa33^2)/beta33

    assertf(beta33 > 0, "invalid beta33=%.3fm (>0 expected)", beta33)

    local A55 = sqrt(beta33)
    local A65 = -alfa33/A55
    local A66 = sqrt(gama33 - A65^2) -- 1/A55

    set(A,5,5, A55) ; set(A,5,6,  0 ) -- Courant-Snyder form
    set(A,6,5, A65) ; set(A,6,6, A66)

    if rnk == 4 then rnk = 6 end
  end

  -- set dispersion

  if bb0.dx  then set(A,1,6, bb0.dx ) end
  if bb0.dpx then set(A,2,6, bb0.dpx) end
  if bb0.dy  then set(A,3,6, bb0.dy ) end
  if bb0.dpy then set(A,4,6, bb0.dpy) end

  -- backup rank and coupling

  if sav_ then bb0.rank, bb0.cplg, bb0.sdir = rnk, cpl, dir end

  -- sanity checks

  local serr, merr = (rnk >= 6 and A or A:getsub(r4,r4)):symperr(matrix(rnk))
  if serr > symp_tol then
    io.flush()
    warn("normalizing form A[%dx%d] built from beta0 block #%d is not symplectic, \z
          symperr=%.5e", rnk, rnk, bb0.id or 0, serr)
    A:print('A') ; merr:print('A_symperr')
    io.flush()
  end

  bb0.X, bb0.A, map.status = X, A, 'Aset'

  return map:setvar(X):set1(A)
end

-- fill beta0 block (optical functions) from A (normalising form) and W (tunes)

local pha_tol in phystol

function gphys.map2bet (map, rnk_, cpl_, dir_) -- TODO: move to beta0
  assert(is_damap(map), "invalid argument #1 (damap expected)")

  local bb0, ini
  if is_table(rnk_) then -- rnk_ is bb0
    ini = false
    bb0 = rnk_
    assert(typeid.is_beta0(bb0), "invalid beta0 block (not created from damap)")
  else
    ini = true
    bb0 = MAD.beta0 {rank = rnk_, cplg = cpl_, sdir = dir_ or 1}
  end

  bb0.X = map:get0(bb0.X)
  bb0.A = map:get1(bb0.A)
  local X, A in bb0
  assert(A.nrow >= 6 and A.ncol >= 6, "invalid damap size (6D+ expected)")

  local get = A.get
  local rnk = bb0.rank or has_dpt(A) and 6 or 4

  -- update rank
  bb0.rank = rnk

  -- orbits

  bb0.x  = get(X,1,1)
  bb0.px = get(X,2,1)
  bb0.y  = get(X,3,1)
  bb0.py = get(X,4,1)
  bb0.t  = get(X,5,1)
  bb0.pt = get(X,6,1)

  -- diagonal terms

  bb0.alfa11 = oval( -(get(A,1,1) * get(A,2,1) + get(A,1,2) * get(A,2,2)) )
  bb0.beta11 = oval(   get(A,1,1)^2            + get(A,1,2)^2             )
  bb0.gama11 = oval(   get(A,2,1)^2            + get(A,2,2)^2             )

  bb0.alfa22 = oval( -(get(A,3,3) * get(A,4,3) + get(A,3,4) * get(A,4,4)) )
  bb0.beta22 = oval(   get(A,3,3)^2            + get(A,3,4)^2             )
  bb0.gama22 = oval(   get(A,4,3)^2            + get(A,4,4)^2             )


  if rnk >= 6 then
    bb0.alfa33 = oval( -(get(A,5,5) * get(A,6,5) + get(A,5,6) * get(A,6,6)) )
    bb0.beta33 = oval(   get(A,5,5)^2            + get(A,5,6)^2             )
    bb0.gama33 = oval(   get(A,6,5)^2            + get(A,6,6)^2             )
  else
    bb0.alfa33, bb0.beta33, bb0.gama33 = 0, 0, 0
  end

  -- coupling terms

  if bb0.cplg then
    bb0.alfa12 = oval( -(get(A,1,3) * get(A,2,3) + get(A,1,4) * get(A,2,4)) )
    bb0.beta12 = oval(   get(A,1,3)^2            + get(A,1,4)^2             )
    bb0.gama12 = oval(   get(A,2,3)^2            + get(A,2,4)^2             )

    bb0.alfa21 = oval( -(get(A,3,1) * get(A,4,1) + get(A,3,2) * get(A,4,2)) )
    bb0.beta21 = oval(   get(A,3,1)^2            + get(A,3,2)^2             )
    bb0.gama21 = oval(   get(A,4,1)^2            + get(A,4,2)^2             )

    if rnk >= 6 then
      bb0.alfa13 = oval( -(get(A,1,5) * get(A,2,5) + get(A,1,6) * get(A,2,6)) )
      bb0.beta13 = oval(   get(A,1,5)^2            + get(A,1,6)^2             )
      bb0.gama13 = oval(   get(A,2,5)^2            + get(A,2,6)^2             )

      bb0.alfa31 = oval( -(get(A,5,1) * get(A,6,1) + get(A,5,2) * get(A,6,2)) )
      bb0.beta31 = oval(   get(A,5,1)^2            + get(A,5,2)^2             )
      bb0.gama31 = oval(   get(A,6,1)^2            + get(A,6,2)^2             )

      bb0.alfa23 = oval( -(get(A,3,5) * get(A,4,5) + get(A,3,6) * get(A,4,6)) )
      bb0.beta23 = oval(   get(A,3,5)^2            + get(A,3,6)^2             )
      bb0.gama23 = oval(   get(A,4,5)^2            + get(A,4,6)^2             )

      bb0.alfa32 = oval( -(get(A,5,3) * get(A,6,3) + get(A,5,4) * get(A,6,4)) )
      bb0.beta32 = oval(   get(A,5,3)^2            + get(A,5,4)^2             )
      bb0.gama32 = oval(   get(A,6,3)^2            + get(A,6,4)^2             )
    else
      bb0.alfa13, bb0.beta13, bb0.gama13 = 0, 0, 0
      bb0.alfa31, bb0.beta31, bb0.gama31 = 0, 0, 0
      bb0.alfa23, bb0.beta23, bb0.gama23 = 0, 0, 0
      bb0.alfa32, bb0.beta32, bb0.gama32 = 0, 0, 0
    end
  end

  -- dispersions

  if rnk >= 6 then
    local H = A*I56*A:sympconj()
    local _h66 = 1/get(H,6,6)

    bb0.dx, bb0.dpx = oval( get(H,1,6)*_h66 ), oval( get(H,2,6)*_h66 )
    bb0.dy, bb0.dpy = oval( get(H,3,6)*_h66 ), oval( get(H,4,6)*_h66 )
  else
    bb0.dx, bb0.dpx = oval( get(A,1,6) ), oval( get(A,2,6) )
    bb0.dy, bb0.dpy = oval( get(A,3,6) ), oval( get(A,4,6) )
  end

  -- ongoing (cumulated calculation)

  if ini then
    bb0.mu1, bb0.mu1_, bb0.dmu1, bb0.dmu1_ = 0, 0, 0, 0
    bb0.mu2, bb0.mu2_, bb0.dmu2, bb0.dmu2_ = 0, 0, 0, 0
    bb0.mu3, bb0.mu3_, bb0.dmu3, bb0.dmu3_ = 0, 0, 0, 0
  else
    local sdir in bb0

    -- phase advances (local)
    local mu1_ =              oval( atan2(get(A,1,2), get(A,1,1)) / twopi )
    local mu2_ =              oval( atan2(get(A,3,4), get(A,3,3)) / twopi )
    local mu3_ = rnk >= 6 and oval( atan2(get(A,5,6), get(A,5,5)) / twopi ) or 0

    if sdir*mu1_ < 0 and abs(mu1_) > pha_tol then mu1_ = sdir+mu1_ end
    if sdir*mu2_ < 0 and abs(mu2_) > pha_tol then mu2_ = sdir+mu2_ end
    if sdir*mu3_ < 0 and abs(mu3_) > pha_tol then mu3_ =     -mu3_ end

    local dmu1_, dmu2_, dmu3_ = mu1_-bb0.mu1_, mu2_-bb0.mu2_, mu3_-bb0.mu3_

    if sdir*dmu1_ < 0 and abs(dmu1_) > pha_tol then dmu1_ = sdir+dmu1_ end
    if sdir*dmu2_ < 0 and abs(dmu2_) > pha_tol then dmu2_ = sdir+dmu2_ end
    if sdir*dmu3_ < 0 and abs(dmu3_) > pha_tol then dmu3_ =     -dmu3_ end

    -- phase advances (cumulated, backup local)
    bb0.mu1, bb0.mu1_, bb0.dmu1_  = bb0.mu1+dmu1_, mu1_, dmu1_
    bb0.mu2, bb0.mu2_, bb0.dmu2_  = bb0.mu2+dmu2_, mu2_, dmu2_
    bb0.mu3, bb0.mu3_, bb0.dmu3_  = bb0.mu3+dmu3_, mu3_, dmu3_
  end

  return bb0
end

function gphys.chr2bet (bb0, fdp, dpt) -- TODO: move to beta0?
  assert(typeid.is_beta0(bb0), "invalid argument #1 (beta0 block expected)")
  assert(typeid.is_beta0(fdp), "invalid argument #2 (beta0 block expected)")
  assert(     is_nonzero(dpt), "invalid argument #3 (number ~= 0 expected expected)")

  -- phase advances vs dpt

  local dmu1_ = (fdp.dmu1_ - bb0.dmu1_) / dpt
  local dmu2_ = (fdp.dmu2_ - bb0.dmu2_) / dpt
  local dmu3_ = (fdp.dmu3_ - bb0.dmu3_) / dpt

  bb0.dmu1 = bb0.dmu1 + dmu1_
  bb0.dmu2 = bb0.dmu2 + dmu2_
  bb0.dmu3 = bb0.dmu3 + dmu3_

  -- dispersions from orbit

  bb0.Dx  = (fdp.x  - bb0.x ) / dpt
  bb0.Dy  = (fdp.y  - bb0.y ) / dpt
  bb0.Dpx = (fdp.px - bb0.px) / dpt
  bb0.Dpy = (fdp.py - bb0.py) / dpt

  -- dispersions vs dpt

  bb0.ddx  = 0.5*(fdp.dx  - bb0.dx ) / dpt
  bb0.ddy  = 0.5*(fdp.dy  - bb0.dy ) / dpt
  bb0.ddpx = 0.5*(fdp.dpx - bb0.dpx) / dpt
  bb0.ddpy = 0.5*(fdp.dpy - bb0.dpy) / dpt

  -- chromatic functions

  if bb0.beta11 then
    assertf(bb0.beta11 > 0, "invalid beta11=%.3fm (>0 expected)", bb0.beta11)

    local dbetx = (fdp.beta11 - bb0.beta11) / dpt
    local dalfx = (fdp.alfa11 - bb0.alfa11) / dpt
    local bx = dbetx / bb0.beta11
    local ax = dalfx - bb0.alfa11*bx

    bb0.wx = sqrt(ax^2 + bx^2)
    if bb0.wx > 1e-12 then
      local phix = atan2(ax, bx)
      bb0.phix_  = rangle(phix, bb0.phix_ or phix)
      bb0.phix   = bb0.phix_ / twopi
    end
  end

  if bb0.beta22 then
    assertf(bb0.beta22 > 0, "invalid beta22=%.3fm (>0 expected)", bb0.beta22)

    local dbety = (fdp.beta22 - bb0.beta22) / dpt
    local dalfy = (fdp.alfa22 - bb0.alfa22) / dpt
    local by = dbety / bb0.beta22
    local ay = dalfy - bb0.alfa22*by

    bb0.wy = sqrt(ay^2 + by^2)
    if bb0.wy > 1e-12 then
      local phiy = atan2(ay, by)
      bb0.phiy_  = rangle(phiy, bb0.phiy_ or phiy)
      bb0.phiy   = bb0.phiy_ / twopi
    end
  end
end

-- Method is implemented from SLAC-Pub-1193 where integration is
-- done explicitly and includes effect of poleface rotations

function gphys.syn2bet(bb0, mflw, elm) -- TODO: move to beta0?
  assert(typeid.is_beta0(bb0), "invalid argument #1 (beta0 block expected)")
  local el, eh, e1, e2, nmul, knl, tdir, beam in mflw

  if el == 0 or (eh == 0 and (nmul < 2 or knl[2] == 0)) then return end

  local debug in mflw
  local synch_1, synch_2, synch_3, synch_4, synch_5, synch_6, synch_8 =
              0,       0,       0,       0,       0,       0,       0

  if bb0.synch_1 == nil then
    bb0.synch_1, bb0.synch_2, bb0.synch_3, bb0.synch_4,
    bb0.synch_5, bb0.synch_6, bb0.synch_8 = 0, 0, 0, 0, 0, 0, 0
  end

  local k1   = knl[2]/el*tdir
  local te1  = tan(e1 or 0)
  local beta = beam.beta
  local dx   = bb0.dx *beta
  local dpx  = bb0.dpx*beta + dx*eh*te1

  -- global gradient combining weak focusing and dipole gradient
  -- k2 can be positive or negative and k can be real or imaginary

  if debug > 0 then
    print('Synchrotron integrals at exit of element ', elm.name, elm.kind)
    print('Input:  eh = ', eh, 'k1 = ', k1, 'e1 =', e1, 'e2 = ', e2, 'blen = ', el)
    print('        betxi = ', bb0.beta11, 'alfxi = ', bb0.alfa11, 'dxi = ', dx, 'dpxi = ', dpx)
  end

  -- propagation of dispersion at exit
  if eh ~= 0 then -- bend contribution
    local betx = bb0.beta11
    local alfx = bb0.alfa11 - betx*eh*te1
    local gamx = (1 + alfx^2) / betx

    local k2 = eh^2 + 2*k1
    local k  = sqrt(k2+0i)
    local kl = k*el
    local ckl, skl = cos(kl), sin(kl)
    local eh2, eh3 = eh^2, eh^3
    local kl2, kl3 = kl^2, kl^3
    local dx2      = real(dx*ckl + dpx*skl/k + eh*(1-ckl)/k2)
    local dispavg  = real(dx*skl/kl + dpx*(1-ckl)/(k*kl) + eh*(kl-skl)/(k2*kl))
    local curlyavg = real( gamx*dx^2 + 2*alfx*dx*dpx + betx*dpx^2
              + 2*eh*el*(-(gamx*dx + alfx*dpx)*(kl-skl)/(kl2*k)
                         +(alfx*dx + betx*dpx)*(1 -ckl)/(kl2))
            + (eh*el)^2*(  gamx*(3*kl - 4*skl + skl*ckl)/(2*k2*kl3)
                         - alfx*(1 -ckl)^2  /(k*kl3)
                         + betx*(kl-ckl*skl)/(2*kl3)) )

    synch_1 = dispavg*eh*el
    synch_2 = eh2*el
    synch_3 = abs(eh3)*el
    synch_4 = dispavg*eh*(eh2 + 2*k1)*el - eh2*(dx*te1 + dx2*tan(e2 or 0))
    synch_5 = curlyavg*abs(eh3)*el

    bb0.synch_1 = bb0.synch_1 + synch_1
    bb0.synch_2 = bb0.synch_2 + synch_2
    bb0.synch_3 = bb0.synch_3 + synch_3
    bb0.synch_4 = bb0.synch_4 + synch_4
    bb0.synch_5 = bb0.synch_5 + synch_5

    if debug > 1 then
      print(' --> ')
      print('        k2 = ', k2, '  k = ', k, 'k*l = ', kl)
      print('        alfx = ', alfx, 'dpx = ', dpx, 'gamx = ', gamx, 'dx2 = ', dx2)
      print('        dispaverage = ', dispavg, 'curlyhaverage = ', curlyavg)
    end

  elseif k1 ~= 0 then -- quad contribution (exclusive)
    local sk1 = sqrt(k1+0i)
    local u0x = real((1+sin(2*sk1*el)/(2*sk1*el))/ 2)
    local u2x = real((1-sin(2*sk1*el)/(2*sk1*el))/(2*k1))
    local u1x = real(sin(sk1*el)^2)/(k1*el)
    local dx2 = real(cos(sk1*el)*dx + dpx/sk1*sin(sk1*el))
    local dispavg = (dx+dx2)/2
    local betxavg = bb0.beta11*u0x - bb0.alfa11*u1x + bb0.gama11*u2x

    synch_6 =  k1^2*betxavg   *el
    synch_8 = (k1  *dispavg)^2*el

    bb0.synch_6 = bb0.synch_6 + synch_6
    bb0.synch_8 = bb0.synch_8 + synch_8

    if debug > 1 then
      print(' --> ')
      print('        u0x = ', u0x, 'u1x = ', u1x, 'u2x = ', u2x, 'dx2 = ', dx2)
      print('        dispaverage = ', dispavg, 'betxavg = ', betxavg)
    end
  end

  if debug > 0 then
    print('Contributions to Radiation Integrals:',
           synch_1, synch_2, synch_3, synch_4, synch_5, synch_6, synch_8)
    print('')
  end
end

-- env ------------------------------------------------------------------------o

gphys = wrestrict(setmetatable(gphys, {__tostring := "MAD.gphys"}))

-- end ------------------------------------------------------------------------o
return { gphys = gphys }
