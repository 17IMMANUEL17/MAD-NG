--[=[
 o-----------------------------------------------------------------------------o
 |
 | Generic physics module
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide useful function for physics computation.

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local matrix, cvector, trace, warn                               in MAD
local is_nil, is_positive, is_matrix, is_cvector, wrestrict      in MAD.typeid
local assertf, errorf, num2str                                   in MAD.utility
local twopi, minang                                              in MAD.constant
local max, abs, sqrt, atan2 in math

local dp_tol   = 1e-12
local eig_tol  = 1e-12
local nrm_tol  = 1e-12
local symp_tol = 1e-12

-- helpers --------------------------------------------------------------------o

local function chkeigsiz (V, W)
  assert(is_matrix(V), "invalid argument #1 (matrix expected)")

  local nr, nc = V:sizes()
  assert(nr == 6 and nc == 6 or
         nr == 4 and nc == 4, "invalid eigenvectors (4D/6D matrix expected)")

  if W then
    assert(is_cvector(W) , "invalid argument #2 (cvector expected)")
    assert(W:nrow() == nr, "invalid eigenvalues (4D/6D cvector expected)")
  end
end

-- implementation -------------------------------------------------------------o

local gphys = {

  -- canonical variables names (index -> name)
  cvname = {'x', 'px', 'y', 'py', 't', 'pt'},

  -- canonical variables indexes (name -> index)
  cvindex = {x=1, px=2, y=3, py=4, t=5, pt=6,
             X=1, PX=2, Y=3, PY=4, T=5, PT=6},

  -- optical functions names (index -> name)
  ofname = {
    'beta11', 'alfa11', 'beta12', 'alfa12', 'beta13', 'alfa13',
    'beta21', 'alfa21', 'beta22', 'alfa22', 'beta23', 'alfa23',
    'beta31', 'alfa31', 'beta32', 'alfa32', 'beta33', 'alfa33',
  },
}

-- checkers -------------------------------------------------------------------o

-- check if system is eigen using eigtol tolerance
-- check R*Vi = Wi*Vi

function gphys.is_eigsys (V, W, R, eigtol_)
  local tol = eigtol_ or eig_tol
  chkeigsiz(V, W) ; chkeigsiz(R, W)
  assert(is_positive(tol), "invalid argument #4 (positive number expected)")
  local cvec, getc = R.complex, R.getcol

--  print("checking eigen system")
--  R:print('R'); W:print('W'); V:print('V')

  for i=1,#W-1,2 do
    local dW = W[i]-W[i+1]:conj()
    if not dW:eq(0, tol) then
      errorf("invalid eigenvalues %d (conjugate pairs deviates by %s)",
             i, num2str(dW:norm()))
    end

    local Vi = cvec(getc(V,i), getc(V,i+1))
    local Vc = Vi:conj()
    local dV1, dV2 = R*Vi-W[i]*Vi, R*Vc-W[i+1]*Vc
    if not (dV1:eq(0, tol) and dV2:eq(0, tol)) then
      errorf("invalid eigen system %d (R*V%d deviates from W%d*V%d by %s)",
             i, i ,i, i, num2str(max(dV1:norm(),dV2:norm())))
    end
  end

  return true
end

-- check one-turn map normalisation
-- check that N = (1/A * R * A) = Abar * R * A contains only rotations

function gphys.is_normal (A, R, nrmtol_)
  local tol = nrmtol_ or nrm_tol
  local get, set = A.get, A.set

  local N = (A:bar() * R * A) -- :print("N = Abar R A ")

  for i = 1,N:nrow()-1,2 do
    local mu1 = atan2( get(N,i,i+1), get(N,i  ,i  ))
    local mu2 = atan2(-get(N,i+1,i), get(N,i+1,i+1))
    if abs(mu1-mu2) > tol then
      errorf("invalid normal form N[%d] (deviates from a pure rotation by %s)",
             i, num2str(mu1-mu2))
    end
    N:setsub(i..i+1, i..i+1, 0)
  end
  if not N:eq(0, tol) then
    error("invalid normal form N (contains coupling terms)")
  end

  return true
end

-- check for delta_p in one-turn map using dptol tolerance

function gphys.has_dp (R, dptol_)
  local tol = dptol_ or dp_tol
  assert(is_matrix(R)    , "invalid argument #1 (matrix expected)")
  assert(is_positive(tol), "invalid argument #2 (positive number expected)")

  local nr, nc = R:sizes()
  assert(nr >= 6 and nc >= 6, "invalid one-turn map (6D+ matrix expected)")

  local get = R.get
  local nodp = abs(get(R,6,6) - 1) <= tol

  for i=1,5 do
    nodp = nodp and abs(get(R,6,i)) <= tol
  end

  return not nodp
end

-- helpers --------------------------------------------------------------------o

-- retrieve eigenvalues from pairs of eigenvectors

function gphys.get_eigval (V, R, W)
  local nr = V:nrow()

  W = W or cvector(nr)

  local cvec, getc = A.complex, A.getcol
  local v1 = cvec(getc(A,1), getc(A,2))
  local v2 = cvec(getc(A,3), getc(A,4))

    -- get eigenvalue Wi from R*Vi = Wi*Vi
  W[1] = get(R,1,1) + get(R,1,2)*get(v1,2,1)/get(v1,1,1)
  W[2] = W[1]:conj()
  W[3] = get(R,3,3) + get(R,3,4)*get(v2,4,1)/get(v2,3,1)
  W[4] = W[3]:conj()

  if nr >= 6 then
    local v3 = cvec(getc(A,5), getc(A,6))
    W[5] = get(R,5,5) + get(R,5,6)*get(v3,6,1)/get(v3,5,1)
    W[6] = W[5]:conj()
  end
  -- W:print('W')

  return W
end

-- symplectification ----------------------------------------------------------o

-- get symplectified one-turn map R
-- Algorithm described in the doctoral thesis by Liam Healey.

function gphys.makesymp (R)
  chkeigsiz(R)

  local n, rnk, err = max(R:sizes())
  local I, A, V = R:same():eye()

  V, rnk = (I-R)/(I+R)
  if rnk == n then
    A = (V:bar()-V)/2
    V, rnk = (I+A)/(I-A)
    if rnk == n then R:copy(V) end
  end

  if rnk < n then
    warn("singular matrix detected during symplectification of R (left unchanged).")
  else
    trace(0, "symplectification deviation: %s", num2str(R:symperr()))
  end

  return R
end

-- normalization --------------------------------------------------------------o

-- order in place eigenvectors and eigenvvalues by planes (x,px), (y,py) and
-- (t,pt)

function gphys.order_eigen (V, W)
  chkeigsiz(V, W)

  local get, n = V.get, V:nrow()

  for i=1,n-3,2 do
    local mv, k = 0

    for j=i,n-1,2 do
      local pv = get(V,i,j  )^2 + get(V,i+1,j  )^2 + -- real part
                 get(V,i,j+1)^2 + get(V,i+1,j+1)^2   -- imag part
      if pv > mv then mv, k = pv, j end
    end

    if i ~= k then
      -- swap eigenvectors pairs (i,i+1) with (k,k+1)
      local col = {1,2,3,4}
      col[i], col[i+1] = k, k+1
      V:swpcol(col)
      -- swap eigenvalues pairs (i,i+1) with (k,k+1)
      W[i], W[i+1], W[k], W[k+1] = W[k], W[k+1], W[i], W[i+1]
    end
  end

--  print("ordered eigen system")
--  W:print('W')
--  V:print('V')
  return V
end

-- normalize in place eigenvectors such that [x,px]=1, [y,py]=1 and [t,pt]=1

function gphys.norm_eigen (V, W)
  chkeigsiz(V, W)

  local get, n = V.get, V:nrow()

  for i=1,n-1,2 do
    local pb = 0 -- poisson bracket
    for j = 1,n-1,2 do
      pb = pb + get(V,i,j) * get(V,i+1,j+1) - get(V,i,j+1) * get(V,i+1,j)
    end
    local spb = sqrt(abs(pb))
    if pb < 0 then -- swap eigenvalues
       W[i], W[i+1] = W[i+1], W[i]
    end
    for j=1,n do -- normalize plane
      V:set(i  ,j,  get(V,i  ,j) /  spb      )
      V:set(i+1,j,  get(V,i+1,j) * (spb / pb))
    end
  end

--  print("normalized eigen system")
--  W:print('W')
--  V:print('V')
  return V
end

-- rephase in place the eigenvectors such that V(1,2)=0 and mux>0, V(3,4)=0 and
-- muy>0 (and V(5,6)=0 and mut>0)

function gphys.phas_eigen (V)
  chkeigsiz(V)

  local get, set, nr = V.get, V.set, V:nrow()
  local P = matrix(nr):eye()

  local dx = sqrt(get(V,1,1)^2 + get(V,1,2)^2)
  set(P,1,1,  get(V,1,1) / dx )
  set(P,2,1,  get(V,1,2) / dx )
  set(P,1,2, -get(P,2,1) )
  set(P,2,2,  get(P,1,1) )

  local dy = sqrt(get(V,3,3)^2 + get(V,3,4)^2)
  set(P,3,3,  get(V,3,3) / dy )
  set(P,4,3,  get(V,3,4) / dy )
  set(P,3,4, -get(P,4,3) )
  set(P,4,4,  get(P,3,3) )

  if nr == 6 then
    local dp = sqrt(get(V,5,5)^2 + get(V,5,6)^2)
    set(P,5,5,  get(V,5,5) / dp )
    set(P,6,5,  get(V,5,6) / dp )
    set(P,5,6, -get(P,6,5) )
    set(P,6,6,  get(P,5,5) )
  end

  V:mul(P,V) -- V = P*V

--  print("rephased eigen vectors")
--  V:print('V')
  return V
end

-- get linear normal form A of one-turn map R

function gphys.normal (R)
  chkeigsiz(R)

  local serr = R:symperr()
  if serr > symp_tol then
    trace(0, "symplectic deviation: %s", num2str(serr))
    gphys.makesymp(R)
  end

  -- get eigenvalues (W) and (right) eigenvectors (V) of R
  local W, _, V, info = R:eigen()

  -- check that system is eigen
  gphys.is_eigsys(V, W, R)

  -- reuse matrix returned for left eigenvectors
  local A = V:copy()

  -- order eigenvalues and eigenvectors by planes
  gphys.order_eigen(A, W)

  -- normalize eigen system
  gphys.norm_eigen(A, W)

  -- rephase eigen vectors
  gphys.phas_eigen(A)

  -- check that system is a normal form
  gphys.is_normal(A, R)

  return A, V, W, info
end

-- get linear optical functions from normal form

function gphys.optfun (A, R, W_)
  chkeigsiz(R); chkeigsiz(A)
  local get, nr, N = A.get, A:nrow()

  -- compute normal form N (rotations) if W (eigenvalues) is not provided
  if is_nil(W_) then N = A:bar()*R*A end

  local optfun = {
    rank = nr,
    cosmu1 = (W_ and W_[1]:carg() or atan2(get(N,1,2), get(N,1,1))) / twopi,
    cosmu2 = (W_ and W_[3]:carg() or atan2(get(N,3,4), get(N,3,3))) / twopi,
    cosmu3 = 0,
    beta11 =   get(A,1,1)^2            + get(A,1,2)^2            ,
    alfa11 = -(get(A,1,1) * get(A,2,1) + get(A,1,2) * get(A,2,2)),
    beta12 =   get(A,1,3)^2            + get(A,1,4)^2            ,
    alfa12 = -(get(A,1,3) * get(A,2,3) + get(A,1,4) * get(A,2,4)),
    beta13 = 0,
    alfa13 = 0,
    beta21 =   get(A,3,1)^2            + get(A,3,2)^2            ,
    alfa21 = -(get(A,3,1) * get(A,4,1) + get(A,3,2) * get(A,4,2)),
    beta22 =   get(A,3,3)^2            + get(A,3,4)^2            ,
    alfa22 = -(get(A,3,3) * get(A,4,3) + get(A,3,4) * get(A,4,4)),
    beta23 = 0,
    alfa23 = 0,
    beta31 = 0, beta32 = 0, beta33 = 0,
    alfa31 = 0, alfa32 = 0, alfa33 = 0,
  }

  if nr >= 6 then
    optfun.cosmu3 = (W_ and W_[5]:carg() or atan2(get(N,5,6), get(N,5,5))) / twopi
    optfun.beta13 =   get(A,1,5)^2            + get(A,1,6)^2
    optfun.alfa13 = -(get(A,1,5) * get(A,2,5) + get(A,1,6) * get(A,2,6))
    optfun.beta23 =   get(A,3,5)^2            + get(A,3,6)^2
    optfun.alfa23 = -(get(A,3,5) * get(A,4,5) + get(A,3,6) * get(A,4,6))
    optfun.beta31 =   get(A,5,1)^2            + get(A,5,2)^2
    optfun.alfa31 = -(get(A,5,1) * get(A,6,1) + get(A,5,2) * get(A,6,2))
    optfun.beta32 =   get(A,5,3)^2            + get(A,5,4)^2
    optfun.alfa32 = -(get(A,5,3) * get(A,6,3) + get(A,5,4) * get(A,6,4))
    optfun.beta33 =   get(A,5,5)^2            + get(A,5,6)^2
    optfun.alfa33 = -(get(A,5,5) * get(A,6,5) + get(A,5,6) * get(A,6,6))
  end

  if optfun.cosmu1 < 0 then optfun.cosmu1 = 1+optfun.cosmu1 end
  if optfun.cosmu2 < 0 then optfun.cosmu2 = 1+optfun.cosmu2 end
  if optfun.cosmu3 < 0 then optfun.cosmu3 =  -optfun.cosmu3 end

  -- print debug information
--  io.write('rank=', nr,'\n')
--  for i=1,3 do io.write('q'..i,':\t', num2str(optfun['q'..i]),'\n') end
--  for _,v in ipairs(gphys.ofname) do io.write(v,':\t', num2str(optfun[v]),'\n') end

  return optfun
end

-- env ------------------------------------------------------------------------o

gphys = wrestrict(setmetatable(gphys, {__tostring := "MAD.gphys"}))

-- end ------------------------------------------------------------------------o
return { gphys = gphys }
