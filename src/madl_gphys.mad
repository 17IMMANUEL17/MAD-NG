--[=[
 o-----------------------------------------------------------------------------o
 |
 | Generic physics module
 |
 | Methodical Accelerator Design - Copyright (c) 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide useful function for physics computation.

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local matrix, cvector, trace, warn, option, typeid               in MAD
local is_nil, is_positive, is_odd, is_table, is_matrix,
      is_cvector, wrestrict                                      in MAD.typeid
local assertf, errorf, printf, num2str                           in MAD.utility
local lbool                                                      in MAD.operator
local twopi                                                      in MAD.constant
local min, max, abs, sqrt, sin, cos, atan2 in math

local assert, table =
      assert, table

local r4 = 1..4
local I4 = matrix(4):eye()
local I6 = matrix(6):eye()
local S4 = matrix(4):symp() -- [4x4] symplectic matrix S
local S6 = matrix(6):symp() -- [6x6] symplectic matrix S

-- helpers --------------------------------------------------------------------o

local function chkeigsiz (V, W)
  assert(is_matrix(V), "invalid argument #1 (matrix expected)")

  local nr, nc = V:sizes()
  assert(nr == 6 and nc == 6 or
         nr == 4 and nc == 4, "invalid eigenvectors (4D/6D matrix expected)")

  if W then
    assert(is_cvector(W) , "invalid argument #2 (cvector expected)")
    assert(W.nrow == nr, "invalid eigenvalues (4D/6D cvector expected)")
  end
end

-- implementation -------------------------------------------------------------o

local gphys = {

  -- tolerances
  var = {
    dpt_tol  = 1e-12,
    eig_tol  = 1e-12,
    nrm_tol  = 1e-12,
    symp_tol = 1e-12,
    ofun_tol = 1e-12,
  },

  -- default variable names (and indexes)
  vname = {
    {'x'                            , x=1                            , __n=1},
    {'x', 'y'                       , x=1,       y=2                 , __n=2},
    {'x', 'y' , 'z'                 , x=1,       y=2,       z=3      , __n=3},
    {'x', 'px', 'y', 'py'           , x=1, px=2, y=3, py=4           , __n=4},
    {'x', 'px', 'y', 'py', 'pt'     , x=1, px=2, y=3, py=4,      pt=5, __n=5},
    {'x', 'px', 'y', 'py', 't', 'pt', x=1, px=2, y=3, py=4, t=5, pt=6, __n=6},
  },

  -- dispersion (index -> name)
  dpname = {
    'dx', 'dpx',
    'dy', 'dpy',
  },

  -- optical functions names (index -> name)
  ofname = {
    'alfa11', 'beta11', 'gama11', 'mu1',
    'alfa22', 'beta22', 'gama22', 'mu2',
    'alfa33', 'beta33', 'gama33', 'mu3',
  },

  -- optical functions names with coupling (index -> name)
  ocfname = {
    'alfa11', 'beta11', 'gama11', 'alfa12', 'beta12', 'gama12', 'alfa13', 'beta13', 'gama13', 'mu1',
    'alfa21', 'beta21', 'gama21', 'alfa22', 'beta22', 'gama22', 'alfa23', 'beta23', 'gama23', 'mu2',
    'alfa31', 'beta31', 'gama31', 'alfa32', 'beta32', 'gama32', 'alfa33', 'beta33', 'gama33', 'mu3',
  },
}

-- variables ------------------------------------------------------------------o

function gphys.vname_dup (vn)
  local n = #vn
  local cvn = table.new(n, n+1)
  for i=1,n do cvn[i], cvn[vn[i]] = vn[i], i end
  cvn.__n = n
  return cvn
end

function gphys.vname_setki (vn)
  local n = #vn
  for i=1,n do vn[vn[i]] = i end
  vn.__n = n
  return vn
end

-- mflows ---------------------------------------------------------------------o

-- particles/damaps status rank: Xset/Mset/stable/unstable/singular/lost
local mrnk = {Xset=1, Mset=1, stable=1, unstable=2, singular=3, lost=4}
gphys.mrnk = mrnk

-- compare particles/damaps by rank then id
function gphys.mcmp (ma, mb)
  local ra, rb = mrnk[ma.status], mrnk[ma.status]
  assert(ra and rb, "unknown status detected")
  return ra == rb and ma.id < mb.id or ra < rb
end

-- sort particles/damaps, adjust npar
function gphys.msort (mflw, cmp_)
  assert(typeid.is_dynmflow(mflw),"invalid argument #1 (dynamic mflow expected)")

  table.sort(mflw, cmp_ or gphys.mcmp)

  mflw.npar = #mflw
  for i=1,mflw.npar do
    if mrnk[mflw[i].status] > mrnk.stable then mflw.npar=i-1 break end
  end
  return mflw
end

-- checkers -------------------------------------------------------------------o

-- check if system is eigen using eigtol tolerance
-- check R*Vi = Wi*Vi

function gphys.is_eigsys (V, W, R, eigtol_)
  local tol = eigtol_ or gphys.var.eig_tol
  chkeigsiz(V, W) ; chkeigsiz(R, W)
  assert(is_positive(tol), "invalid argument #4 (positive number expected)")
  local cvec, getc = R.complex, R.getcol

  for i=1,#W-1,2 do
    local dW = W[i]-W[i+1]:conj()
    if not dW:eq(0, tol) then
      warn("invalid eigenvalues #%d (conjugate pair deviates by %s)",
           i, num2str(dW:abs()))
      return false
    end

    local Vi = cvec(getc(V,i), getc(V,i+1))
    local Vc = Vi:conj()
    local dV1, dV2 = R*Vi-W[i]*Vi, R*Vc-W[i+1]*Vc
    if not (dV1:eq(0, tol) and dV2:eq(0, tol)) then
      warn("invalid eigensystem #%d (R*V%d deviates from W%d*V%d by %s)",
           i, i ,i, i, num2str(max(dV1:norm(),dV2:norm())))
      return false
    end
  end

  return true
end

-- check one-turn map normalisation
-- check that N = (1/A * R * A) [= Abar * R * A] contains only rotations

function gphys.is_normal (A, R, nrmtol_)
  local tol = nrmtol_ or gphys.var.nrm_tol
  local get, set, n = A.get, A.set, A.nrow

  local N = A:inv() * R * A

  if option.debug >= 2 then
     N:print("N = A^-1 R A ") ; (A:bar() * R * A) :print("Abar R A ")
  end

  for i = 1,n-1,2 do
    local a1 = atan2( get(N,i,i+1), get(N,i  ,i  ))
    local a2 = atan2(-get(N,i+1,i), get(N,i+1,i+1))
    if abs(a1-a2) > tol then
      warn("invalid normal form #%d (deviates from a pure rotation by %s)",
           i, num2str(a1-a2))
      R:print('R') ; N:print('N')
      return false
    end
    N:setsub(i..i+1, i..i+1, 0)
  end
  if not N:eq(0, tol) then
    warn("invalid normal form N (contains coupling terms)")
    R:print('R') ; N:print('N')
    return false
  end

  return true
end

-- check for delta pt in one-turn map using dptol tolerance

function gphys.has_dpt (R, dptol_)
  local tol = dptol_ or gphys.var.dpt_tol
  assert(is_matrix(R)    , "invalid argument #1 (matrix expected)")
  assert(is_positive(tol), "invalid argument #2 (positive number expected)")

  local nr, nc = R:sizes()
  assert(nr >= 6 and nc >= 6, "invalid one-turn map (6D+ matrix expected)")

  local get = R.get
  local nodpt = abs(get(R,6,6) - 1) <= tol

  for i=1,5 do
    nodpt = nodpt and abs(get(R,6,i)) <= tol
  end

  return not nodpt
end

-- helpers --------------------------------------------------------------------o

-- conversion between momentum and energy deviation
-- dp = (P-P0)/P0, pt = (E-E0)/P0c
-- (1+dp)^2 = 1 + 2pt/beta + pt^2

function gphys.dp2pt (dp, beta)
  local _beta = 1/beta
  return dp ~= 0 and sqrt((1+dp)^2 + (_beta^2-1)) - _beta or 0
end

function gphys.pt2dp (pt, beta)
  return pt ~= 0 and sqrt(1 + 2*pt/beta + pt^2) - 1 or 0
end

-- compute Poisson bracket from pairs of conjugate column vectors

function gphys.get_pb (V, q_col)
  chkeigsiz(V)
  assert(q_col>0 and q_col<V.ncol and is_odd(q_col), "invalid q-column index")

  local get, pb = V.get, 0

  for i=1,V.nrow-1,2 do
    pb = pb + get(V,i,q_col  ) * get(V,i+1,q_col+1)
            - get(V,i,q_col+1) * get(V,i+1,q_col  )
  end

  return pb
end

-- eigensystem ----------------------------------------------------------------o

-- retrieve eigenvalues from pairs of eigenvectors

function gphys.get_eigval (V, R, W)
  chkeigsiz(V) ; chkeigsiz(R)

  local cvec, getc, n = V.complex, V.getcol, V.nrow

  W = W or cvector(n)

  -- get eigenvalues Wi from eigenvectors Vi: R*Vi = Wi*Vi
  for i=1,V.nrow-1,2 do
    local v = cvec(getc(V,i), getc(V,i+1))
    W[i  ] = get(R,i,i) + get(R,i,i+1)*get(v,i+1,i)/get(v,i,i)
    W[i+1] = W[i]:conj()
  end

  if option.debug >= 2 then
    io.write("**Eigensystem:\n")
    R:print('Vectors ')
    V:print('Eigenvectors ')
    W:print('Eigenvalues ')
  end

  return W
end

-- symplectification ----------------------------------------------------------o

-- symplectifiy one-turn map R if needed
-- Algorithm described in the doctoral thesis of Liam Healey.

function gphys.make_symp (R)
  chkeigsiz(R)

  local serr = R:symperr()
  if serr <= gphys.var.symp_tol then return end

  trace(0, "symplectic deviation: %s", num2str(serr))

  local n, rnk, err = max(R:sizes())
  local I, A, V = R:same():eye()

  V, rnk = (I-R):div(I+R)
  if rnk == n then
    A = (V:bar()-V)/2
    V, rnk = (I+A):div(I-A)
    if rnk == n then V:copy(R) end
  end

  if rnk < n then
    warn("symplectification failed (singular matrix, left unchanged).")
  else
    trace(0, "symplectified deviation: %s", num2str(R:symperr()))
  end

  return R
end

-- closed form ----------------------------------------------------------------o

-- close dispersion of A from R

function gphys.close_disp (A, R)
  chkeigsiz(A) ; chkeigsiz(R)

  -- close dispersion (as a function of pt, multiply by beta for dp)
  local D4 = R:getsub(r4, 6)
  local R4 = R:getsub(r4,r4)
  local C4, rnk = (I4-R4):solve(D4)
  -- TODO: make [t,pt] symplectic ?
  A:setsub(r4,6,C4)

  if option.debug >= 2 then
    io.write("**Closed dispersion:\n")
    C4:print('Dispersion ')
  end
end

-- normalize in place eigenvectors such that [x,px]=1, [y,py]=1 and [t,pt]=1

function gphys.norm_eigen (V, W)
  chkeigsiz(V, W)

  local get, set, n = V.get, V.set, V.nrow

  for j=1,n-1,2 do    -- loop over columns
    local pb = 0      -- poisson bracket (columns pair)
    for i=1,n-1,2 do
      pb = pb + get(V,i,j) * get(V,i+1,j+1) - get(V,i,j+1) * get(V,i+1,j)
    end
    local spb = sqrt(abs(pb))
    assert(spb > 0, "invalid eigenvectors (unexpected [v,w]=0)")
    if pb < 0 then    -- conjugate of eigenvalues (columns)
       W[j], W[j+1] = W[j]:conj(), W[j+1]:conj()
    end
    for i=1,n do      -- normalize plane (columns)
      set(V,i,j  ,  get(V,i,j)   /  spb      )
      set(V,i,j+1,  get(V,i,j+1) * (spb / pb))
    end
  end

  if option.debug >= 2 then
    io.write("**Normalized eigensystem:\n")
    W:print('Eigenvalues ')
    V:print('Eigenvectors ')
    io.write("symperr=", V:symperr(), "\n")
  end
end

-- rephase in place the eigenvectors to obtain the Courant-Snyder form
-- i.e. V(1,2)=0 and mu1>0, V(3,4)=0 and mu2>0, V(5,6)=0 and mu3>0

function gphys.phas_eigen (V)
  chkeigsiz(V)

  local get, set, n = V.get, V.set, V.nrow
  local P = matrix(V.nrow):eye()

  for i=1,n-1,2 do
    local d = sqrt(get(V,i,i)^2 + get(V,i,i+1)^2)
    assert(d > 0, "invalid eigenvectors (unexpected denom=0)")
    set(P,i  ,i  ,  get(V,i  ,i  ) / d )
    set(P,i+1,i  ,  get(V,i  ,i+1) / d )
    set(P,i  ,i+1, -get(P,i+1,i  )     )
    set(P,i+1,i+1,  get(P,i  ,i  )     )
  end

  V:mul(P,V) -- V = P*V

  if option.debug >= 2 then
    io.write("**Rephased eigenvectors:\n")
    V:print('Eigenvectors ')
    io.write("symperr=", V:symperr(), "\n")
  end
end

-- order in place eigenvectors and eigenvvalues by planes (x,px), (y,py) and
-- (t,pt), detect by horizontal, vertical, longitudinal order

function gphys.order_eigen (V, W)
  chkeigsiz(V, W)

  local get, n = V.get, V.nrow

  for i=1,n-3,2 do
    local mv, k = 0

    for j=i,n-1,2 do
      local pv = get(V,i,j  )^2 + get(V,i+1,j  )^2 + -- real part
                 get(V,i,j+1)^2 + get(V,i+1,j+1)^2   -- imag part
      if pv > mv then mv, k = pv, j end
    end

    if i ~= k then
      -- swap eigenvectors pairs (i,i+1) with (k,k+1)
      local col = {1,2,3,4}
      col[i], col[i+1] = k, k+1
      V:swpcol(col)
      -- swap eigenvalues pairs (i,i+1) with (k,k+1)
      W[i], W[i+1], W[k], W[k+1] = W[k], W[k+1], W[i], W[i+1]
    end
  end

  if option.debug >= 2 then
    io.write("**Ordered eigensystem:\n")
    W:print('Eigenvalues ')
    V:print('Eigenvectors ')
  end
end

-- order in place eigenvectors and eigenvvalues by planes (x,px), (y,py) and
-- (t,pt), detect by vertical, horizontal, longitudinal order (MAD-X like)

local idx_p = {3,1,5} -- vertical, horizontal, longitudinal
local idx_l = {[1]=3,[3]=1,[4]=5,[6]=3,[8]=1}

function gphys.order_eigen_madx (V, W)
  chkeigsiz(V, W)

  local get, set, n, idx, sel = V.get, V.set, min(V.nrow,6), {0,0}, {}

  -- collect columns with largest components for each plane
  for k=1,n/2-1 do
    local i, mv = idx_p[k], 0
    for j=1,n-1,2 do
      if not sel[j] then -- not yet selected
        local pv = get(V,i,j  )^2 + get(V,i+1,j  )^2 + -- real part
                   get(V,i,j+1)^2 + get(V,i+1,j+1)^2   -- imag part
        if pv > mv then mv, idx[k], sel[j] = pv, j, true end
      end
    end
  end
  -- last plane: remaining index
  idx[n/2] = idx_l[idx[1]+idx[2]]
  -- swap indexes: vertical, horizontal => horizontal, vertical
  idx[1], idx[2] = idx[2], idx[1]

  -- reorder eigenvectors and eigenvalues
  local Vc, Wc = V:copy(), W:copy()
  for kk,j in ipairs(idx) do
    local k = 2*kk-1
    if k ~= j then
      for i=1,n do
        set(V,i,k  , get(Vc,i,j  ))
        set(V,i,k+1, get(Vc,i,j+1))
      end
      W[k], W[k+1] = Wc[j], Wc[j+1]
    end
  end

  if option.debug >= 2 then
    io.write("**Ordered eigensystem:")
    for kk,j in ipairs(idx) do io.write(' ',j,'->',2*kk-1) end
    io.write('\n')
    W:print('Eigenvalues ')
    V:print('Eigenvectors ')
  end
end

-- get linear normal form A of one-turn map R

function gphys.normal (R, rnk_, nocheck_)
  local fmt
  if option.debug >= 2 then
    io.write("-> Normal form\n")
    fmt, option.format = option.format, "% .5e"
  end

  -- one-turn map R
  chkeigsiz(R)
  if option.debug >= 2 then
    io.write("Input one-turn map:\n")
    R:print('R ')
    io.write("symperr=", R:symperr(), "\n")
  end

  -- detect rank of the system
  local rnk = rnk_ or has_dpt(R) and 6 or 4
  local R6

  -- switch to 4D
  if rnk == 4 then R6, R = R, R:getsub(r4,r4) end

  -- symplectifiy R if needed
  gphys.make_symp(R)

  -- get eigenvalues (W) and eigenvectors (Vl, Vr) of R
  local W, _, A, info = R:eigen()

  -- initial conditions for normal form calculation
  if option.debug >= 2 then
    io.write("**Eigensystem:\n")
    R:print('Input vectors ')
    W:print('Eigenvalues ')
    A:print('Eigenvectors ')
  end

  -- check that system is eigen
  if not nocheck_ then gphys.is_eigsys(A, W, R) end

  -- normalize eigen system
  gphys.norm_eigen(A, W)

  -- order eigenvalues and eigenvectors by planes
  gphys.order_eigen(A, W)

  -- rephase eigen vectors
  gphys.phas_eigen(A)

  -- check that system is a normal form
  if not nocheck_ then gphys.is_normal(A, R) end

  -- back to 6D, close dispersion (5D)
  if rnk == 4 then
    A, R = I6:copy():setsub(r4,r4,A), R6
    gphys.close_disp(A, R)
  end

  if option.debug >= 2 then
    io.write("Output normalising map:\n")
    A:print('A ')
    io.write("symperr=", A:symperr(), "\n")
    option.format = fmt
    io.write("<- Normal form\n")
  end

  return A, W, info
end

-- lattice functions ----------------------------------------------------------o

local function oval (x, tol)
  return abs(x) < tol and 0 or x
end

-- fill betablock (optical functions) from A (normalising form) and W (tunes)

function gphys.optfun (A, optfun_, cpl_, W_)
  assert(is_matrix(A) and A.nrow >= 6 and A.ncol >= 6,
         "invalid argument #1 (6D+ matrix expected)")

  local get = A.get
  local cpl = lbool(cpl_)
  local fun = optfun_ or table.new(0, cpl and 40 or 20)
  local tol = gphys.var.ofun_tol
  local rnk = fun.rank or has_dpt(A) and 6 or 4

  fun.rank = rnk
  fun.cplg = cpl

  -- diagonal terms

  fun.alfa11 = oval( -(get(A,1,1) * get(A,2,1) + get(A,1,2) * get(A,2,2)), tol)
  fun.beta11 = oval(   get(A,1,1)^2            + get(A,1,2)^2            , tol)
  fun.gama11 = oval(   get(A,2,1)^2            + get(A,2,2)^2            , tol)

  fun.alfa22 = oval( -(get(A,3,3) * get(A,4,3) + get(A,3,4) * get(A,4,4)), tol)
  fun.beta22 = oval(   get(A,3,3)^2            + get(A,3,4)^2            , tol)
  fun.gama22 = oval(   get(A,4,3)^2            + get(A,4,4)^2            , tol)

  fun.alfa33, fun.beta33, fun.gama33 = 0, 0, 0

  if rnk >= 6 then
    fun.alfa33 = oval( -(get(A,5,5) * get(A,6,5) + get(A,5,6) * get(A,6,6)), tol)
    fun.beta33 = oval(   get(A,5,5)^2            + get(A,5,6)^2            , tol)
    fun.gama33 = oval(   get(A,6,5)^2            + get(A,6,6)^2            , tol)
  end

  -- coupling terms

  if fun.cplg then
    fun.alfa12 = oval( -(get(A,1,3) * get(A,2,3) + get(A,1,4) * get(A,2,4)), tol)
    fun.beta12 = oval(   get(A,1,3)^2            + get(A,1,4)^2            , tol)
    fun.gama12 = oval(   get(A,2,3)^2            + get(A,2,4)^2            , tol)

    fun.alfa21 = oval( -(get(A,3,1) * get(A,4,1) + get(A,3,2) * get(A,4,2)), tol)
    fun.beta21 = oval(   get(A,3,1)^2            + get(A,3,2)^2            , tol)
    fun.gama21 = oval(   get(A,4,1)^2            + get(A,4,2)^2            , tol)

    if rnk >= 6 then
      fun.alfa13 = oval( -(get(A,1,5) * get(A,2,5) + get(A,1,6) * get(A,2,6)), tol)
      fun.beta13 = oval(   get(A,1,5)^2            + get(A,1,6)^2            , tol)
      fun.gama13 = oval(   get(A,2,5)^2            + get(A,2,6)^2            , tol)

      fun.alfa31 = oval( -(get(A,5,1) * get(A,6,1) + get(A,5,2) * get(A,6,2)), tol)
      fun.beta31 = oval(   get(A,5,1)^2            + get(A,5,2)^2            , tol)
      fun.gama31 = oval(   get(A,6,1)^2            + get(A,6,2)^2            , tol)

      fun.alfa23 = oval( -(get(A,3,5) * get(A,4,5) + get(A,3,6) * get(A,4,6)), tol)
      fun.beta23 = oval(   get(A,3,5)^2            + get(A,3,6)^2            , tol)
      fun.gama23 = oval(   get(A,4,5)^2            + get(A,4,6)^2            , tol)

      fun.alfa32 = oval( -(get(A,5,3) * get(A,6,3) + get(A,5,4) * get(A,6,4)), tol)
      fun.beta32 = oval(   get(A,5,3)^2            + get(A,5,4)^2            , tol)
      fun.gama32 = oval(   get(A,6,3)^2            + get(A,6,4)^2            , tol)
    end
  end

  -- dispersion

  if rnk >= 6 then
    -- TODO: true 6D using Chao's method or Etienne's method
    warn("6D dispersion NYI")
    fun.dx, fun.dpx = oval( get(A,1,6), tol), oval( get(A,2,6), tol)
    fun.dy, fun.dpy = oval( get(A,3,6), tol), oval( get(A,4,6), tol)
  else
    fun.dx, fun.dpx = oval( get(A,1,6), tol), oval( get(A,2,6), tol)
    fun.dy, fun.dpy = oval( get(A,3,6), tol), oval( get(A,4,6), tol)
  end

  -- phase advance

  if W_ then
    assert(is_cvector(W_) and W_.nrow >= rnk,
           "invalid argument #2 (4D+ complex eigenvalues expected)")
    fun.mu1 =              oval( W_[1]:carg() / twopi, tol)
    fun.mu2 =              oval( W_[3]:carg() / twopi, tol)
    fun.mu3 = rnk >= 6 and oval( W_[5]:carg() / twopi, tol) or 0
  else
    fun.mu1 =              oval( atan2(get(A,1,2), get(A,1,1)) / twopi, tol)
    fun.mu2 =              oval( atan2(get(A,3,4), get(A,3,3)) / twopi, tol)
    fun.mu3 = rnk >= 6 and oval( atan2(get(A,5,6), get(A,5,5)) / twopi, tol) or 0
  end

  if fun.mu1 < 0 then fun.mu1 = 1+fun.mu1 end
  if fun.mu2 < 0 then fun.mu2 = 1+fun.mu2 end
  if fun.mu3 < 0 then fun.mu3 =  -fun.mu3 end

  -- backup A for coupling terms

  if fun.cplg then fun.A = A:copy(fun.A) end

  return fun
end

-- beta block -----------------------------------------------------------------o

function gphys.betablk (optfun)
  assert(type(optfun) == "table", "invalid argument #1 (table expected)")
  local fun = optfun
  local rnk = fun.rank or fun.beta33 and 6 or 4
  local A   = fun.A and fun.A:copy() or matrix(6)

  -- normalization matrix A of the one-turn map R = A N A^-1

  -- diagonal terms

  local alfa11 = fun.alfa11 or 0
  local beta11 = fun.beta11 or 1
  local gama11 = fun.gama11 or (1+alfa11^2)/beta11

  assert(beta11 > 0, "invalid beta11 (>0 expected)")

  -- A[1:2,1:2]
  local A11, A12 = sqrt(beta11), 0     -- Courant-Snyder form
  local A21, A22 = -alfa11/A11 , 1/A11 -- sqrt(gama11 - A21^2)

  -- A[3:4,3:4]

  local alfa22 = fun.alfa22 or 0
  local beta22 = fun.beta22 or 1
  local gama22 = fun.gama22 or (1+alfa22^2)/beta22

  assert(beta22 > 0, "invalid beta22 (>0 expected)")

  local A33, A34 = sqrt(beta22), 0     -- Courant-Snyder form
  local A43, A44 = -alfa22/A33 , 1/A33 -- sqrt(gama22 - A43^2)

  -- A[5:6,5:6]

  local A55, A56, A65, A66 = 1, 0, 0, 1
  if rnk >= 6 then
    local alfa33 = fun.alfa33 or 0
    local beta33 = fun.beta33 or 1
    local gama33 = fun.gama33 or (1+alfa33^2)/beta33

    assert(beta33 > 0, "invalid beta33 (>0 expected)")

    A55, A56 = sqrt(beta33), 0     -- Courant-Snyder form
    A65, A66 = -alfa33/A55 , 1/A55 -- sqrt(gama33 - A65^2)
  end

  -- coupling terms (off diagonal)

  -- A[1:2,3:4]

  local A13, A14, A23, A24 = 0, 0, 0, 0
  if fun.beta12 then
    local alfa12 = fun.alfa12 or 0
    local beta12 = fun.beta12
    local gama12 = fun.gama12 or (1+alfa12^2)/beta12

    assert(beta12 > 0, "invalid beta12 (>0 expected)")

    A13, A14 = sqrt(beta12), 0     -- Courant-Snyder form
    A23, A24 = -alfa12/A13 , 1/A13 -- sqrt(gama12 - A23^2)
  end

  -- A[3:4,1:2]

  local A31, A32, A41, A42 = 0, 0, 0, 0
  if fun.beta21 then
    local alfa21 = fun.alfa21 or 0
    local beta21 = fun.beta21
    local gama21 = fun.gama21 or (1+alfa21^2)/beta21

    assert(beta21 > 0, "invalid beta21 (>0 expected)")

    A31, A32 = sqrt(beta21), 0     -- Courant-Snyder form
    A41, A42 = -alfa21/A31 , 1/A31 -- sqrt(gama21 - A41^2)
  end

  local A15, A16, A25, A26 = 0, 0, 0, 0
  local A35, A36, A45, A46 = 0, 0, 0, 0
  local A51, A52, A61, A62 = 0, 0, 0, 0
  local A53, A54, A63, A64 = 0, 0, 0, 0

  if rnk >= 6 then

    -- A[1:2,5:6]

    if fun.beta13 then
      local alfa13 = fun.alfa13 or 0
      local beta13 = fun.beta13
      local gama13 = fun.gama13 or (1+alfa13^2)/beta13

      assert(beta13 > 0, "invalid beta13 (>0 expected)")

      A15, A16 = sqrt(beta13), 0     -- Courant-Snyder form
      A25, A26 = -alfa13/A15 , 1/A15 -- sqrt(gama13 - A25^2)
    end

    -- A[3:4,5:6]

    if fun.beta23 then
      local alfa23 = fun.alfa23 or 0
      local beta23 = fun.beta23
      local gama23 = fun.gama23 or (1+alfa23^2)/beta23

      assert(beta23 > 0, "invalid beta23 (>0 expected)")

      A35, A36 = sqrt(beta23), 0     -- Courant-Snyder form
      A45, A46 = -alfa23/A35 , 1/A35 -- sqrt(gama23 - A45^2)
    end

    -- A[5:6,1:2]

    if fun.beta31 then
      local alfa31 = fun.alfa31 or 0
      local beta31 = fun.beta31
      local gama31 = fun.gama31 or (1+alfa31^2)/beta31

      assert(beta31 > 0, "invalid beta31 (>0 expected)")

      A51, A52 = sqrt(beta23), 0     -- Courant-Snyder form
      A61, A62 = -alfa23/A35 , 1/A35 -- sqrt(gama31 - A61^2)
    end

    -- A[5:6,3:4]

    if fun.beta32 then
      local alfa32 = fun.alfa32 or 0
      local beta32 = fun.beta32
      local gama32 = fun.gama32 or (1+alfa32^2)/beta32

      assert(beta32 > 0, "invalid beta32 (>0 expected)")

      A53, A54 = sqrt(beta23), 0     -- Courant-Snyder form
      A63, A64 = -alfa32/A53 , 1/A53 -- sqrt(gama32 - A63^2)
    end

  else
    -- A[1:4,6] dispersion

    A16, A26 = fun.dx, fun.dpx
    A36, A46 = fun.dy, fun.dpy
  end

  local A = matrix(6):fill {
      A11, A12, A13, A14, A15, A16,
      A21, A22, A23, A24, A25, A26,
      A31, A32, A33, A34, A35, A36,
      A41, A42, A43, A44, A45, A46,
      A51, A52, A53, A54, A55, A56,
      A61, A62, A63, A64, A65, A66,
    }

  local serr = (rnk >= 6 and A or A:getsub(r4,r4)):symperr()
  assert(serr < gphys.var.symp_tol, "invalid optfun (built A is not symplectic)")

  return A
end

-- env ------------------------------------------------------------------------o

gphys = wrestrict(setmetatable(gphys, {__tostring := "MAD.gphys"}))

-- end ------------------------------------------------------------------------o
return { gphys = gphys }
