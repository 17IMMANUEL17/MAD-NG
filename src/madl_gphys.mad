--[=[
 o-----------------------------------------------------------------------------o
 |
 | Generic physics module
 |
 | Methodical Accelerator Design - Copyright (c) 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide useful function for physics computation.

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local matrix, cvector, trace, warn, typeid                       in MAD
local is_nil, is_positive, is_table, is_matrix, is_cvector,
      wrestrict                                                  in MAD.typeid
local assertf, errorf, num2str                                   in MAD.utility
local lbool                                                      in MAD.operator
local twopi                                                      in MAD.constant
local max, abs, sqrt, sin, cos, atan2 in math

local assert, table =
      assert, table

local r4 = 1..4
local I4 = matrix(4):eye()
local I6 = matrix(6):eye()
local S4 = matrix(4):symp() -- [4x4] symplectic matrix S
local S6 = matrix(6):symp() -- [6x6] symplectic matrix S

-- helpers --------------------------------------------------------------------o

local function chkeigsiz (V, W)
  assert(is_matrix(V), "invalid argument #1 (matrix expected)")

  local nr, nc = V:sizes()
  assert(nr == 6 and nc == 6 or
         nr == 4 and nc == 4, "invalid eigenvectors (4D/6D matrix expected)")

  if W then
    assert(is_cvector(W) , "invalid argument #2 (cvector expected)")
    assert(W.nrow == nr, "invalid eigenvalues (4D/6D cvector expected)")
  end
end

-- implementation -------------------------------------------------------------o

local gphys = {

  -- tolerances
  var = {
    dpt_tol  = 1e-12,
    eig_tol  = 1e-12,
    nrm_tol  = 1e-12,
    symp_tol = 1e-12,
    ofun_tol = 1e-12,
  },

  -- default variable names (and indexes)
  vname = {
    {'x'                            , x=1                            , __n=1},
    {'x', 'y'                       , x=1,       y=2                 , __n=2},
    {'x', 'y' , 'z'                 , x=1,       y=2,       z=3      , __n=3},
    {'x', 'px', 'y', 'py'           , x=1, px=2, y=3, py=4           , __n=4},
    {'x', 'px', 'y', 'py', 'pt'     , x=1, px=2, y=3, py=4,      pt=5, __n=5},
    {'x', 'px', 'y', 'py', 't', 'pt', x=1, px=2, y=3, py=4, t=5, pt=6, __n=6},
  },

  -- dispersion (index -> name)
  dpname = {
    'dx', 'dpx',
    'dy', 'dpy',
  },

  -- optical functions names (index -> name)
  ofname = {
    'alfa11', 'beta11', 'gama11', 'mu1',
    'alfa22', 'beta22', 'gama22', 'mu2',
    'alfa33', 'beta33', 'gama33', 'mu3',
  },

  -- optical functions names with coupling (index -> name)
  ocfname = {
    'alfa11', 'beta11', 'gama11', 'alfa12', 'beta12', 'gama12', 'alfa13', 'beta13', 'gama13', 'mu1',
    'alfa21', 'beta21', 'gama21', 'alfa22', 'beta22', 'gama22', 'alfa23', 'beta23', 'gama23', 'mu2',
    'alfa31', 'beta31', 'gama31', 'alfa32', 'beta32', 'gama32', 'alfa33', 'beta33', 'gama33', 'mu3',
  },
}

-- variables ------------------------------------------------------------------o

function gphys.vname_dup (vn)
  local n = #vn
  local cvn = table.new(n, n+1)
  for i=1,n do cvn[i], cvn[vn[i]] = vn[i], i end
  cvn.__n = n
  return cvn
end

function gphys.vname_setki (vn)
  local n = #vn
  for i=1,n do vn[vn[i]] = i end
  vn.__n = n
  return vn
end

-- mflows ---------------------------------------------------------------------o

-- particles/damaps status rank: Xset/Mset/stable/unstable/singular/lost
local mrnk = {Xset=1, Mset=1, stable=1, unstable=2, singular=3, lost=4}
gphys.mrnk = mrnk

-- compare particles/damaps by rank then id
function gphys.mcmp (ma, mb)
  local ra, rb = mrnk[ma.status], mrnk[ma.status]
  assert(ra and rb, "unknown status detected")
  return ra == rb and ma.id < mb.id or ra < rb
end

-- sort particles/damaps, adjust npar
function gphys.msort (mflw, cmp_)
  assert(typeid.is_dynmflow(mflw), "invalid argument #1 (dynamic mflow expected)")

  table.sort(mflw, cmp_ or gphys.mcmp)

  mflw.npar = #mflw
  for i=1,mflw.npar do
    if mrnk[mflw[i].status] > mrnk.stable then mflw.npar=i-1 break end
  end
  return mflw
end

-- checkers -------------------------------------------------------------------o

-- check if system is eigen using eigtol tolerance
-- check R*Vi = Wi*Vi

function gphys.is_eigsys (V, W, R, eigtol_)
  local tol = eigtol_ or gphys.var.eig_tol
  chkeigsiz(V, W) ; chkeigsiz(R, W)
  assert(is_positive(tol), "invalid argument #4 (positive number expected)")
  local cvec, getc = R.complex, R.getcol

--  print("checking eigen system")
--  R:print('R'); W:print('W'); V:print('V')

  for i=1,#W-1,2 do
    local dW = W[i]-W[i+1]:conj()
    if not dW:eq(0, tol) then
      warn("invalid eigenvalues #%d (conjugate pair deviates by %s)",
           i, num2str(dW:abs()))
      return false
    end

    local Vi = cvec(getc(V,i), getc(V,i+1))
    local Vc = Vi:conj()
    local dV1, dV2 = R*Vi-W[i]*Vi, R*Vc-W[i+1]*Vc
    if not (dV1:eq(0, tol) and dV2:eq(0, tol)) then
      warn("invalid eigen system #%d (R*V%d deviates from W%d*V%d by %s)",
           i, i ,i, i, num2str(max(dV1:norm(),dV2:norm())))
      return false
    end
  end

  return true
end

-- check one-turn map normalisation
-- check that N = (1/A * R * A) = Abar * R * A contains only rotations

function gphys.is_normal (A, R, nrmtol_)
  local tol = nrmtol_ or gphys.var.nrm_tol
  local get, set = A.get, A.set

  local N = (A:bar() * R * A)  :print("N = Abar R A ")

  for i = 1,N.nrow-1,2 do
    local a1 = atan2( get(N,i,i+1), get(N,i  ,i  ))
    local a2 = atan2(-get(N,i+1,i), get(N,i+1,i+1))
    if abs(a1-a2) > tol then
      warn("invalid normal form #%d (deviates from a pure rotation by %s)",
           i, num2str(a1-a2))
      return false
    end
    N:setsub(i..i+1, i..i+1, 0)
  end
  if not N:eq(0, tol) then
    warn("invalid normal form N (contains coupling terms)")
    R:print('R') ; N:print('N')
    return false
  end

  return true
end

-- check for delta pt in one-turn map using dptol tolerance

function gphys.has_dpt (R, dptol_)
  local tol = dptol_ or gphys.var.dpt_tol
  assert(is_matrix(R)    , "invalid argument #1 (matrix expected)")
  assert(is_positive(tol), "invalid argument #2 (positive number expected)")

  local nr, nc = R:sizes()
  assert(nr >= 6 and nc >= 6, "invalid one-turn map (6D+ matrix expected)")

  local get = R.get
  local nodp = abs(get(R,6,6) - 1) <= tol

  for i=1,5 do
    nodp = nodp and abs(get(R,6,i)) <= tol
  end

  return not nodp
end

-- helpers --------------------------------------------------------------------o

-- conversion between momentum and energy deviation
-- dp = (P-P0)/P0, pt = (E-E0)/P0c
-- (1+dp)^2 = 1 + 2pt/beta + pt^2

function gphys.dp2pt (dp, beta)
  local _beta = 1/beta
  return dp ~= 0 and sqrt((1+dp)^2 + (_beta^2-1)) - _beta or 0
end

function gphys.pt2dp (pt, beta)
  return pt ~= 0 and sqrt(1 + 2*pt/beta + pt^2) - 1 or 0
end

-- retrieve eigenvalues from pairs of eigenvectors

function gphys.get_eigval (V, R, W)
  local nr = V.nrow

  W = W or cvector(nr)

  local cvec, getc = A.complex, A.getcol
  local v1 = cvec(getc(A,1), getc(A,2))
  local v2 = cvec(getc(A,3), getc(A,4))

    -- get eigenvalue Wi from R*Vi = Wi*Vi
  W[1] = get(R,1,1) + get(R,1,2)*get(v1,2,1)/get(v1,1,1)
  W[2] = W[1]:conj()
  W[3] = get(R,3,3) + get(R,3,4)*get(v2,4,1)/get(v2,3,1)
  W[4] = W[3]:conj()

  if nr >= 6 then
    local v3 = cvec(getc(A,5), getc(A,6))
    W[5] = get(R,5,5) + get(R,5,6)*get(v3,6,1)/get(v3,5,1)
    W[6] = W[5]:conj()
  end
  -- W:print('W')

  return W
end

-- symplectification ----------------------------------------------------------o

-- symplectifiy one-turn map R
-- Algorithm described in the doctoral thesis of Liam Healey.

function gphys.make_symp (R)
  chkeigsiz(R)

  local n, rnk, err = max(R:sizes())
  local I, A, V = R:same():eye()

  V, rnk = (I-R):div(I+R)
  if rnk == n then
    A = (V:bar()-V)/2
    V, rnk = (I+A):div(I-A)
    if rnk == n then V:copy(R) end
  end

  if rnk < n then
    warn("symplectification failed (singular matrix, left unchanged).")
  else
    trace(0, "symplectified deviation: %s", num2str(R:symperr()))
  end

  return R
end

-- closed form ----------------------------------------------------------------o

-- order in place eigenvectors and eigenvvalues by planes (x,px), (y,py) and
-- (t,pt)

function gphys.order_eigen (V, W)
  chkeigsiz(V, W)

  local get, n = V.get, V.nrow

  for i=1,n-3,2 do
    local mv, k = 0

    for j=i,n-1,2 do
      local pv = get(V,i,j  )^2 + get(V,i+1,j  )^2 + -- real part
                 get(V,i,j+1)^2 + get(V,i+1,j+1)^2   -- imag part
      if pv > mv then mv, k = pv, j end
    end

    if i ~= k then
      -- swap eigenvectors pairs (i,i+1) with (k,k+1)
      local col = {1,2,3,4}
      col[i], col[i+1] = k, k+1
      V:swpcol(col)
      -- swap eigenvalues pairs (i,i+1) with (k,k+1)
      W[i], W[i+1], W[k], W[k+1] = W[k], W[k+1], W[i], W[i+1]
    end
  end

--  print("ordered eigen system")
--  W:print('W')
--  V:print('V')
  return V
end

-- normalize in place eigenvectors such that [x,px]=1, [y,py]=1 and [t,pt]=1

function gphys.norm_eigen (V, W)
  chkeigsiz(V, W)

  local get, n = V.get, V.nrow

  for i=1,n-1,2 do
    local pb = 0 -- poisson bracket
    for j = 1,n-1,2 do
      pb = pb + get(V,i,j) * get(V,i+1,j+1) - get(V,i,j+1) * get(V,i+1,j)
    end
    local spb = sqrt(abs(pb))
    if pb < 0 then -- swap eigenvalues
       W[i], W[i+1] = W[i+1], W[i]
    end
    for j=1,n do -- normalize plane
      V:set(i  ,j,  get(V,i  ,j) /  spb      )
      V:set(i+1,j,  get(V,i+1,j) * (spb / pb))
    end
  end

--  print("normalized eigen system")
--  W:print('W')
--  V:print('V')
  return V
end

-- rephase in place the eigenvectors to obtain the Courant-Snyder form
-- i.e. V(1,2)=0 and mu1>0, V(3,4)=0 and mu2>0 (and V(5,6)=0 and mu3>0)

function gphys.phas_eigen (V)
  chkeigsiz(V)

  local get, set = V.get, V.set
  local P = matrix(V.nrow):eye()

  local dx = sqrt(get(V,1,1)^2 + get(V,1,2)^2)
  set(P,1,1,  get(V,1,1) / dx )
  set(P,2,1,  get(V,1,2) / dx )
  set(P,1,2, -get(P,2,1) )
  set(P,2,2,  get(P,1,1) )

  local dy = sqrt(get(V,3,3)^2 + get(V,3,4)^2)
  set(P,3,3,  get(V,3,3) / dy )
  set(P,4,3,  get(V,3,4) / dy )
  set(P,3,4, -get(P,4,3) )
  set(P,4,4,  get(P,3,3) )

  if V.nrow == 6 then
    local dp = sqrt(get(V,5,5)^2 + get(V,5,6)^2)
    set(P,5,5,  get(V,5,5) / dp )
    set(P,6,5,  get(V,5,6) / dp )
    set(P,5,6, -get(P,6,5) )
    set(P,6,6,  get(P,5,5) )
  end

  V:mul(P,V) -- V = P*V

--  print("rephased eigen vectors")
--  V:print('V')
  return V
end

-- get linear normal form A of one-turn map R

function gphys.normal (R, nocheck_)
  chkeigsiz(R)

  local serr, Rerr = R:symperr(R:same())
  if serr > gphys.var.symp_tol then
    trace(0, "symplectic deviation: %s", num2str(serr))
    R:print('R') ; Rerr:print("R'JR-J") ;
    gphys.make_symp(R)
    serr, Rerr = R:symperr(Rerr)
    R:print('R') ; Rerr:print("R'JR-J") ;
  end

  -- get eigenvalues (W) and (right) eigenvectors (V) of R
  local W, _, V, info = R:eigen()

  -- check that system is eigen
  assert(nocheck_ == true or gphys.is_eigsys(V, W, R))

  -- reuse matrix returned for left eigenvectors
  local A = V:copy()

  -- normalize eigen system
  gphys.norm_eigen(A, W)

  -- order eigenvalues and eigenvectors by planes
  gphys.order_eigen(A, W)

  -- rephase eigen vectors
  gphys.phas_eigen(A)

  -- check that system is a normal form
--assert(nocheck_ == true or gphys.is_normal(A, R))

  return A, V, W, info
end

-- get closed dispersion from one-turn map R

function gphys.closed_disp (R, dosymp_)
  -- close dispersion (as a function of pt, multiply by beta for dp)
  local D4 = R:getsub(r4, 6)
  local R4 = R:getsub(r4,r4)
  local D4, rnk = (I4-R4):solve(D4)
  print('rnk=', rnk)
  D4:print("D4")
  return D4
end

-- lattice functions ----------------------------------------------------------o

local function oval (x, tol)
  return abs(x) < tol and 0 or x
end

-- get dispersion from R

function gphys.dispersion (R, optfun_)
  assert(is_matrix(R) and R.nrow >= 6 and R.ncol >= 6,
         "invalid argument #1 (6D+ matrix expected)")

  local get = R.get
  local fun = optfun_ or table.new(0,50)
  local tol = gphys.var.ofun_tol
  local rnk = fun.rank or has_dpt(R) and 6 or 4

  fun.rank   = rnk

  if rnk >= 6 then
    -- TODO: true 6D using Chao's method or Etienne's method
    fun.dx, fun.dpx = oval( get(R,1,6), tol), oval( get(R,2,6), tol)
    fun.dy, fun.dpy = oval( get(R,3,6), tol), oval( get(R,4,6), tol)
  else
    fun.dx, fun.dpx = oval( get(R,1,6), tol), oval( get(R,2,6), tol)
    fun.dy, fun.dpy = oval( get(R,3,6), tol), oval( get(R,4,6), tol)
  end

  return fun
end

-- fill betablock (optical functions) from A (normalising form) and W (tunes)

function gphys.optfun (A, optfun_, cpl_, W_)
  assert(is_matrix(A) and A.nrow >= 6 and A.ncol >= 6,
         "invalid argument #1 (6D+ matrix expected)")

  local get = A.get
  local fun = optfun_ or table.new(0,50)
  local tol = gphys.var.ofun_tol
  local rnk = fun.rank or has_dpt(A) and 6 or 4

  fun.rank   = rnk
  fun.cplg   = lbool(cpl_)

  -- diagonal terms

  fun.alfa11 = oval( -(get(A,1,1) * get(A,2,1) + get(A,1,2) * get(A,2,2)), tol)
  fun.beta11 = oval(   get(A,1,1)^2            + get(A,1,2)^2            , tol)
  fun.gama11 = oval(   get(A,2,1)^2            + get(A,2,2)^2            , tol)

  fun.alfa22 = oval( -(get(A,3,3) * get(A,4,3) + get(A,3,4) * get(A,4,4)), tol)
  fun.beta22 = oval(   get(A,3,3)^2            + get(A,3,4)^2            , tol)
  fun.gama22 = oval(   get(A,4,3)^2            + get(A,4,4)^2            , tol)

  fun.alfa33, fun.beta33, fun.gama33 = 0, 0, 0

  if rnk >= 6 then
    fun.alfa33 = oval( -(get(A,5,5) * get(A,6,5) + get(A,5,6) * get(A,6,6)), tol)
    fun.beta33 = oval(   get(A,5,5)^2            + get(A,5,6)^2            , tol)
    fun.gama33 = oval(   get(A,6,5)^2            + get(A,6,6)^2            , tol)
  end

  -- coupling terms

  fun.alfa12, fun.beta12, fun.gama12 = 0, 0, 0
  fun.alfa21, fun.beta21, fun.gama21 = 0, 0, 0
  fun.alfa13, fun.beta13, fun.gama13 = 0, 0, 0
  fun.alfa31, fun.beta31, fun.gama31 = 0, 0, 0
  fun.alfa23, fun.beta23, fun.gama23 = 0, 0, 0
  fun.alfa32, fun.beta32, fun.gama32 = 0, 0, 0

  if fun.cplg then
    fun.alfa12 = oval( -(get(A,1,3) * get(A,2,3) + get(A,1,4) * get(A,2,4)), tol)
    fun.beta12 = oval(   get(A,1,3)^2            + get(A,1,4)^2            , tol)
    fun.gama12 = oval(   get(A,2,3)^2            + get(A,2,4)^2            , tol)

    fun.alfa21 = oval( -(get(A,3,1) * get(A,4,1) + get(A,3,2) * get(A,4,2)), tol)
    fun.beta21 = oval(   get(A,3,1)^2            + get(A,3,2)^2            , tol)
    fun.gama21 = oval(   get(A,4,1)^2            + get(A,4,2)^2            , tol)

    if rnk >= 6 then
      fun.alfa13 = oval( -(get(A,1,5) * get(A,2,5) + get(A,1,6) * get(A,2,6)), tol)
      fun.beta13 = oval(   get(A,1,5)^2            + get(A,1,6)^2            , tol)
      fun.gama13 = oval(   get(A,2,5)^2            + get(A,2,6)^2            , tol)

      fun.alfa31 = oval( -(get(A,5,1) * get(A,6,1) + get(A,5,2) * get(A,6,2)), tol)
      fun.beta31 = oval(   get(A,5,1)^2            + get(A,5,2)^2            , tol)
      fun.gama31 = oval(   get(A,6,1)^2            + get(A,6,2)^2            , tol)

      fun.alfa23 = oval( -(get(A,3,5) * get(A,4,5) + get(A,3,6) * get(A,4,6)), tol)
      fun.beta23 = oval(   get(A,3,5)^2            + get(A,3,6)^2            , tol)
      fun.gama23 = oval(   get(A,4,5)^2            + get(A,4,6)^2            , tol)

      fun.alfa32 = oval( -(get(A,5,3) * get(A,6,3) + get(A,5,4) * get(A,6,4)), tol)
      fun.beta32 = oval(   get(A,5,3)^2            + get(A,5,4)^2            , tol)
      fun.gama32 = oval(   get(A,6,3)^2            + get(A,6,4)^2            , tol)
    end
  end

  -- phase advance

  if W_ then
    assert(is_cvector(W_) and W_.nrow >= rnk,
           "invalid argument #2 (4D+ complex eigenvalues expected)")
    fun.mu1 =              oval( W_[1]:carg() / twopi, tol)
    fun.mu2 =              oval( W_[3]:carg() / twopi, tol)
    fun.mu3 = rnk >= 6 and oval( W_[5]:carg() / twopi, tol) or 0
  else
    fun.mu1 =              oval( atan2(get(A,1,2), get(A,1,1)) / twopi, tol)
    fun.mu2 =              oval( atan2(get(A,3,4), get(A,3,3)) / twopi, tol)
    fun.mu3 = rnk >= 6 and oval( atan2(get(A,5,6), get(A,5,5)) / twopi, tol) or 0
  end

  if fun.mu1 < 0 then fun.mu1 = 1+fun.mu1 end
  if fun.mu2 < 0 then fun.mu2 = 1+fun.mu2 end
  if fun.mu3 < 0 then fun.mu3 =  -fun.mu3 end

  -- dispersion

  fun.dx  = get(A,1,6)
  fun.dpx = get(A,2,6)
  fun.dy  = get(A,3,6)
  fun.dpy = get(A,4,6)

  -- backup A

  fun.A = A:copy(fun.A)

  return fun
end

-- beta block -----------------------------------------------------------------o

function gphys.betablk (optfun)
  assert(type(optfun) == "table", "invalid argument #1 (table expected)")
  local fun = optfun
  local rnk = fun.rank or fun.beta33 and 6 or 4
  local A   = fun.A and fun.A:copy() or matrix(6)

  -- normalization matrix A of the one-turn map R = A N A^-1

  -- diagonal terms

  local alfa11 = fun.alfa11 or 0
  local beta11 = fun.beta11 or 1
  local gama11 = fun.gama11 or (1+alfa11^2)/beta11

  assert(beta11 > 0, "invalid beta11 (>0 expected)")

  -- A[1:2,1:2]
  local A11, A12 = sqrt(beta11), 0     -- Courant-Snyder form
  local A21, A22 = -alfa11/A11 , 1/A11 -- sqrt(gama11 - A21^2)

  -- A[3:4,3:4]

  local alfa22 = fun.alfa22 or 0
  local beta22 = fun.beta22 or 1
  local gama22 = fun.gama22 or (1+alfa22^2)/beta22

  assert(beta22 > 0, "invalid beta22 (>0 expected)")

  local A33, A34 = sqrt(beta22), 0     -- Courant-Snyder form
  local A43, A44 = -alfa22/A33 , 1/A33 -- sqrt(gama22 - A43^2)

  -- A[5:6,5:6]

  local A55, A56, A65, A66 = 1, 0, 0, 1
  if rnk >= 6 then
    local alfa33 = fun.alfa33 or 0
    local beta33 = fun.beta33 or 1
    local gama33 = fun.gama33 or (1+alfa33^2)/beta33

    assert(beta33 > 0, "invalid beta33 (>0 expected)")

    A55, A56 = sqrt(beta33), 0     -- Courant-Snyder form
    A65, A66 = -alfa33/A55 , 1/A55 -- sqrt(gama33 - A65^2)
  end

  -- coupling terms (off diagonal)

  -- A[1:2,3:4]

  local A13, A14, A23, A24 = 0, 0, 0, 0
  if fun.beta12 then
    local alfa12 = fun.alfa12 or 0
    local beta12 = fun.beta12
    local gama12 = fun.gama12 or (1+alfa12^2)/beta12

    assert(beta12 > 0, "invalid beta12 (>0 expected)")

    A13, A14 = sqrt(beta12), 0     -- Courant-Snyder form
    A23, A24 = -alfa12/A13 , 1/A13 -- sqrt(gama12 - A23^2)
  end

  -- A[3:4,1:2]

  local A31, A32, A41, A42 = 0, 0, 0, 0
  if fun.beta21 then
    local alfa21 = fun.alfa21 or 0
    local beta21 = fun.beta21
    local gama21 = fun.gama21 or (1+alfa21^2)/beta21

    assert(beta21 > 0, "invalid beta21 (>0 expected)")

    A31, A32 = sqrt(beta21), 0     -- Courant-Snyder form
    A41, A42 = -alfa21/A31 , 1/A31 -- sqrt(gama21 - A41^2)
  end

  local A15, A16, A25, A26 = 0, 0, 0, 0
  local A35, A36, A45, A46 = 0, 0, 0, 0
  local A51, A52, A61, A62 = 0, 0, 0, 0
  local A53, A54, A63, A64 = 0, 0, 0, 0

  if rnk >= 6 then

    -- A[1:2,5:6]

    if fun.beta13 then
      local alfa13 = fun.alfa13 or 0
      local beta13 = fun.beta13
      local gama13 = fun.gama13 or (1+alfa13^2)/beta13

      assert(beta13 > 0, "invalid beta13 (>0 expected)")

      A15, A16 = sqrt(beta13), 0     -- Courant-Snyder form
      A25, A26 = -alfa13/A15 , 1/A15 -- sqrt(gama13 - A25^2)
    end

    -- A[3:4,5:6]

    if fun.beta23 then
      local alfa23 = fun.alfa23 or 0
      local beta23 = fun.beta23
      local gama23 = fun.gama23 or (1+alfa23^2)/beta23

      assert(beta23 > 0, "invalid beta23 (>0 expected)")

      A35, A36 = sqrt(beta23), 0     -- Courant-Snyder form
      A45, A46 = -alfa23/A35 , 1/A35 -- sqrt(gama23 - A45^2)
    end

    -- A[5:6,1:2]

    if fun.beta31 then
      local alfa31 = fun.alfa31 or 0
      local beta31 = fun.beta31
      local gama31 = fun.gama31 or (1+alfa31^2)/beta31

      assert(beta31 > 0, "invalid beta31 (>0 expected)")

      A51, A52 = sqrt(beta23), 0     -- Courant-Snyder form
      A61, A62 = -alfa23/A35 , 1/A35 -- sqrt(gama31 - A61^2)
    end

    -- A[5:6,3:4]

    if fun.beta32 then
      local alfa32 = fun.alfa32 or 0
      local beta32 = fun.beta32
      local gama32 = fun.gama32 or (1+alfa32^2)/beta32

      assert(beta32 > 0, "invalid beta32 (>0 expected)")

      A53, A54 = sqrt(beta23), 0     -- Courant-Snyder form
      A63, A64 = -alfa32/A53 , 1/A53 -- sqrt(gama32 - A63^2)
    end

  else
    -- A[1:4,6] dispersion

    A16, A26 = fun.dx, fun.dpx
    A36, A46 = fun.dy, fun.dpy
  end

  local A = matrix(6):fill {
      A11, A12, A13, A14, A15, A16,
      A21, A22, A23, A24, A25, A26,
      A31, A32, A33, A34, A35, A36,
      A41, A42, A43, A44, A45, A46,
      A51, A52, A53, A54, A55, A56,
      A61, A62, A63, A64, A65, A66,
    }

  E = (rnk >= 6 and A or A:getsub(r4,r4)):symperr()
  assert(E < gphys.var.symp_tol, "invalid optfun (built A is not symplectic)")

  return A

!  -- rotation matrix N of the one-turn map R = A N A^-1
!
!  local N11, N12, N21, N22 = 1, 0, 0, 1
!  local N33, N34, N43, N44 = 1, 0, 0, 1
!  local N55, N56, N65, N66 = 1, 0, 0, 1
!
!  if fun.mu1 then
!    N11, N12 = cos(fun.mu1*twopi), sin(fun.mu1*twopi)
!    N21, N22 = -N12, N11
!  end
!
!  if fun.mu2 then
!    N33, N34 = cos(fun.mu2*twopi), sin(fun.mu2*twopi)
!    N43, N44 = -N34, N33
!  end
!
!  if fun.mu3 then
!    N55, N56 = cos(fun.mu3*twopi), sin(fun.mu3*twopi)
!    N65, N66 = -N56, N55
!  end
!
!  local N = matrix(6):fill {
!    N11, N12,   0,   0,   0,   0,
!    N21, N22,   0,   0,   0,   0,
!      0,   0, N33, N34,   0,   0,
!      0,   0, N43, N44,   0,   0,
!      0,   0,   0,   0, N55, N56,
!      0,   0,   0,   0, N65, N66,
!  }
!
!  return A, N
end

-- env ------------------------------------------------------------------------o

gphys = wrestrict(setmetatable(gphys, {__tostring := "MAD.gphys"}))

-- end ------------------------------------------------------------------------o
return { gphys = gphys }
