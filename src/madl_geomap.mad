--[=[
 o-----------------------------------------------------------------------------o
 |
 | Geometric 3D maps
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide a catalog of geometric 3D maps (i.e. survey)
    maps have the following calling convention:
      geomap(elm, map, len_weight)
    where the expected fields are:

    map -> { sdir, V, W }
    elm -> { l, angle, tilt ; dtheta, dphi, dpsi, dx, dy, ds}

    (fields after ';' are optionnal)

 o-----------------------------------------------------------------------------o
]=]

local M = {}

-- locals ---------------------------------------------------------------------o

local _C, vector, matrix    in MAD
local minlen, minang        in MAD.constant

local abs, sin, cos         in math

-- temporaries ----------------------------------------------------------------o

local Ve = vector(3) -- displacement vector of element
local We = matrix(3) -- orientation  matrix of element

local T  = vector(3) -- misalignment translation
local R  = matrix(3) -- misalignment rotation
local Tb = vector(3) -- misalignment translation at exit (Tbar)
local Rb = matrix(3) -- misalignment rotation    at exit (Rbar)
local Rz = matrix(3) -- tilt rotation

local U  = vector(3) -- extra vector for calculation (avoid copy)
local Q  = matrix(3) -- extra matrix for calculation (avoid copy)

-- patches (lw_ == 0 disable the patch) ---------------------------------------o

-- X-rotation (pitch)

function M.xrotation (elm, m, lw_) -- Rx(-phi)
  if lw_ == 0 then return end
  local phi = elm.angle

  if abs(phi) >= minang then
    local tdir, W in m
    local lw = lw_ or 1
    We:rotx(-phi*lw*tdir)
    W:mul(We, W)            -- W = W*We
  end
end

-- Y-rotation (yaw)

function M.yrotation (elm, m, lw_) -- Ry(-theta)
  if lw_ == 0 then return end
  local the = elm.angle

  if abs(the) >= minang then
    local tdir, W in m
    local lw = lw_ or 1
    We:roty(-the*lw*tdir)
    W:mul(We, W)            -- W = W*We
  end
end

-- S-rotation (roll, tilt)

function M.srotation (elm, m, lw_) -- Rz(psi)
  if lw_ == 0 then return end
  local psi = elm.angle

  if abs(psi) >= minang then
    local tdir, W in m
    local lw = lw_ or 1
    We:rotz(psi*lw*tdir)
    W:mul(We, W)            -- W = W*We
  end
end

-- Translation

function M.translate (elm, m, lw_)
  if lw_ == 0 then return end
  local dx, dy, dz = elm.dx or 0, elm.dy or 0, elm.dz or 0

  if abs(dx)+abs(dy)+abs(dz) >= minlen then
    local tdir, V, W in m
    local lw = lw_ or 1
    Ve:fill{dx*lw*tdir, dy*lw*tdir, dz*lw*tdir}
    V:add(W:mul(Ve, U), V)  -- V = W*Ve+V
  end
end

-- Changeref (generic patch, lw_>0: TR, lw_<0: RT)

function M.changeref (elm, m, lw_)
  if lw_ == 0 then return end

  local dx  , dy  , dz   = elm.dx     or 0, elm.dy   or 0, elm.dz   or 0
  local dthe, dphi, dpsi = elm.dtheta or 0, elm.dphi or 0, elm.dpsi or 0

  local trn = abs(dx  )+abs(dy  )+abs(dz  ) >= minlen
  local rot = abs(dthe)+abs(dphi)+abs(dpsi) >= minang

  if not (trn or rot) then return end

  local tdir, V, W in m
  local lw = lw_ or 1

  -- translate
  if trn and lw < 0 then
    Ve:fill{-dx*tdir, -dy*tdir, -dz*tdir}
    V:add(W:mul(Ve, U), V)  -- V = W*Ve+V
  end

  -- rotate
  if rot then
    We:rotyxz(-dphi*lw*tdir, dthe*lw*tdir, dpsi*lw*tdir, lw<0)
    W:mul(We, W)            -- W = W*We
  end

  -- translate
  if trn and lw > 0 then
    Ve:fill{dx*tdir, dy*tdir, dz*tdir}
    V:add(W:mul(Ve, U), V)  -- V = W*Ve+V
  end
end

-- Changedir (reverse t-direction)

function M.changedir (elm_, m, lw_)
  if lw_ == 0 then return end

  m.edir = -m.edir
  m.tdir = -m.tdir
end

-- Changenrj (change energy)

function M.changenrj (elm_, m_, lw_)
  -- N/A for survey
end

-- Misalign (lw_>0: entry, lw_<0: exit)

local misalignexit

function M.misalign (elm, m, lw_)
  if lw_ == 0 then return end
  if (lw_ or 1) < 0 then return misalignexit(elm, m) end

  local dx  , dy  , dz   = elm.dx     or 0, elm.dy   or 0, elm.dz   or 0
  local dthe, dphi, dpsi = elm.dtheta or 0, elm.dphi or 0, elm.dpsi or 0

  local trn = abs(dx  )+abs(dy  )+abs(dz  ) >= minlen
  local rot = abs(dthe)+abs(dphi)+abs(dpsi) >= minang

  if not (trn or rot) then return end

  local sdir, V, W in m

  -- translate
  if trn then
    T:fill{dx*sdir, dy*sdir, dz*sdir}
    V:add(W:mul(T, U), V)  -- V = W*T+V
  end

  -- rotate
  if rot then
    R:rotyxz(-dphi*sdir, dthe*sdir, dpsi*sdir)
    W:mul(R, W)            -- W = W*R
  end
end

function misalignexit (elm, m)
  local dx  , dy  , dz   = elm.dx     or 0, elm.dy   or 0, elm.dz   or 0
  local dthe, dphi, dpsi = elm.dtheta or 0, elm.dphi or 0, elm.dpsi or 0

  local trn = abs(dx  )+abs(dy  )+abs(dz  ) >= minlen
  local rot = abs(dthe)+abs(dphi)+abs(dpsi) >= minang

  if not (trn or rot) then return end

  local el, ang, etlt, sdir, tdir, V, W in m
  local l, ang, tlt = el*sdir, ang*tdir, etlt*tdir

  -- translation
  if trn then
    T:fill{dx*sdir, dy*sdir, dz*sdir}
  else
    T:zeros()
  end

  -- rotation
  if rot then
    R:rotyxz(-dphi*sdir, dthe*sdir, dpsi*sdir)
  end

!  -- straight
!  if abs(ang) < minang then
!    if rot then
!      Ve:fill{0, 0, l}                        -- We = I
!      R:mul(Ve, U):sub(Ve, Tb):add(T, Tb)     -- Tb = R*Ve + T - Ve
!      Rb:copy(R)                              -- Rb = R
!    else -- R = I
!      Tb:copy(T)                              -- Tb = T
!      Rb:eye()                                -- Rb = I
!    end
!
!  -- curved
!  else
!    local rho = l/ang
!    Ve:fill{rho*(cos(ang)-1), 0, rho*sin(ang)}
!    We:roty(-ang)
!
!    -- tilt
!    if abs(tlt) >= minang then
!      Rz:rotz(tlt)
!      Rz:mul(Ve, Ve)                          -- Ve = Rz*Ve
!      Rz:mul(We, Q):mult(Rz, We)              -- We = Rz*We*Rz:t()
!    end
!
!    -- transform
!    if rot then
!      We:tmul(R:mul(Ve, U)
!        :sub(Ve, Tb):add(T, U), Tb)           -- Tb = We:t()*(R*Ve + T - Ve)
!      We:tmul(R, Q):mul(We, Rb)               -- Rb = We:t()*R*We
!    else -- R = I
!      We:tmul(T,Tb)                           -- Tb = We:t()*T
!      Rb:eye()                                -- Rb = I
!    end
!  end

  _C.mad_mat_rtbar(Rb.data, Tb.data, l, ang, tlt, rot and R.data or nil, T.data)

  W:mult(Rb, W)                               -- W = W*Rb:t()            (global)
  V:sub(W:mul(Tb, U), V)                      -- V = V - W*Tb            (global)
end

-- TestSurvey.testSBendMisalign3 ...
-- Rb[3x3] =
--    1   0   0
--    0   0.8660254038  -0.5
--    0   0.5   0.8660254038
-- Tb[3x1] =
--    0
--   -0.3774648293
--   -0.2279363154
-- Ok

-- kinds ----------------------------------------------------------------------o

function M.str_drift (elm, m, lw)
  local el in m
  if abs(el) < minlen then return end

  local sdir, V, W in m
  local l = el*lw*sdir

  Ve:fill{0, 0, l}
  V:add(W:mul(Ve, U), V)         -- V = W*Ve+V
end

function M.cur_thin (elm, m, lw_)
  local ang in m
  if abs(ang) < minang then return end

  local tdir, W in m

  We:roty(-ang*tdir)
  W:mul(We, W)                   -- W = W*We
end

function M.cur_thick (elm, m, lw)
  local el, ang in m
  if abs(ang) < minang then return M.str_drift(elm, m, lw) end
  if abs(el)  < minlen then return M.cur_thin (elm, m, lw) end

  local sdir, tdir, V, W in m
  local l, ang = el*sdir*lw, ang*tdir*lw
  local rho = l/ang

  Ve:fill{rho*(cos(ang)-1), 0, rho*sin(ang)}
  We:roty(-ang)
  V:add(W:mul(Ve, U), V)         -- V = W*Ve+V
  W:mul(We, W)                   -- W = W*We
end

-- end ------------------------------------------------------------------------o
return { geomap = M }
