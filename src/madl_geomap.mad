--[=[
 o-----------------------------------------------------------------------------o
 |
 | Geometric 3D maps
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide a catalog of geometric 3D maps (i.e. survey)
    maps have the following calling convention:
      geomap(elm, map)
    where the expected fields are:

    map -> { dir, V, W ; R, S, T, U }
    elm -> { l, angle ; phi, theta, psi, dx, dy, dz}

    (fields beyond ; are optionnal or internal)

 o-----------------------------------------------------------------------------o
]=]

local M = {}

-- locals ---------------------------------------------------------------------o

local abs, sin, cos  in math
local minlen, minang in MAD.constant
local errorf         in MAD.utility

-- patches --------------------------------------------------------------------o

-- X-rotation (pitch)

function M.xrotation (elm, m) -- Rx(-phi)
  local phi = elm.phi or 0
  if abs(phi) < minang then return end

  m.S :rotx(-phi*m.dir)
  m.W :mul(m.S, m.W) -- W = W*S
end

-- Y-rotation (yaw)

function M.yrotation (elm, m) -- Ry(-theta)
  local th = elm.theta or 0
  if abs(th) < minang then return end

  m.S :roty(-th*m.dir)
  m.W :mul(m.S, m.W) -- W = W*S
end

-- S-rotation (roll, tilt)

function M.srotation (elm, m) -- Rz(psi)
  local psi = elm.psi or 0
  if abs(psi) < minang then return end

  m.S :rotz(psi*m.dir)
  m.W :mul(m.S, m.W) -- W = W*S
end

-- Translation

function M.translate (elm, m)
  local dx, dy, dz = elm.dx or 0, elm.dy or 0, elm.dz or 0
  if abs(dx)+abs(dy)+abs(dz) < 3*minlen then return end

  local dir in m
  m.R :fill {dx*dir, dy*dir, dz*dir}
  m.V :add(m.W :mul(m.R,m.U), m.V) -- V = W*R+V
end

-- MAD patch

function M.madpatch (elm, m)
  local th, phi, psi = elm.theta or 0, elm.phi or 0, elm.psi or 0
  if abs(th)+abs(phi)+abs(psi) < 3*minang then return end

  local dir in m
  m.S :rotmad(th*dir, phi*dir, psi*dir)
  m.W :mul(m.S, m.W) -- W = W*S

  M.translate(elm, m)
end

-- Forward patch

function M.xystpatch (elm, m)
  local th, phi, psi = elm.theta or 0, elm.phi or 0, elm.psi or 0
  if abs(th)+abs(phi)+abs(psi) < 3*minang then return end

  local dir in m                           -- phi  : Elevation angle.
  m.S :rotxyz(phi*dir, th*dir, psi*dir)    -- theta: Azimuthal angle.
  m.W :mul(m.S, m.W) -- W = W*S            -- psi  : Roll      angle.

  M.translate(elm, m)
end

-- Backward patch

function M.tsyxpatch (elm, m)
  M.translate(elm, m)

  local th, phi, psi = elm.theta or 0, elm.phi or 0, elm.psi or 0
  if abs(th)+abs(phi)+abs(psi) < 3*minang then return end

  local dir in m                           -- psi  : Roll      angle.
  m.S :rotzyx(phi*dir, th*dir, psi*dir)    -- theta: Azimuthal angle.
  m.W :mul(m.S, m.W) -- W = W*S            -- phi  : Elevation angle.
end

-- Changedir (reverse direction)

function M.changedir (_, m)
  m.dir = -m.dir
end

-- Changeref (generic patch)

function M.changeref (elm, m)
  local typ = elm.patch or 'xyst'

      if typ == 'xyst' then M.xystpatch(elm, m)
  elseif typ == 'tsyx' then M.tsyxpatch(elm, m)
  else errorf("invalid patch type '%s' ('xyst' or 'tsyx' expected)", typ)
  end
end

-- kinds ----------------------------------------------------------------------o

function M.drift (elm, m) -- e.g. drift, monitor, ...
  local l in elm
  if abs(l) < minlen then return end

  m.R :fill {0, 0, l}
  m.V :add(m.W :mul(m.R,m.U), m.V) -- V = W*R+V
end

function M.thin (elm, m) -- e.g. multipole
  local angle in elm
  if abs(angle) < minang then return end

  local dir in m
  m.S :roty(-angle*dir)

  local tilt in elm
  if abs(tilt) >= minang then
    m.T :rotz(tilt*dir)
    m.T :mul(m.S, m.S) :mult(m.T, m.S) -- S = T*S*T'
  end

  m.W :mul(m.S, m.W) -- W = W*S
end

function M.thick (elm, m) -- e.g. sbend, rbend, quadrupole, ...
  local l in elm
  if abs(l) < minlen then
    return M.thin(elm, m)
  end

  local angle in elm
  if abs(angle) < minang then
    return M.drift(elm, m)
  end

  local dir in m
  angle = angle*dir
  local rho = l/angle
  m.R :fill {rho*(cos(angle)-1), 0, rho*sin(angle)}
  m.S :roty(-angle)

  local tilt in elm
  if abs(tilt) >= minang then
    m.T :rotz(tilt*dir)
    m.T :mul(m.R, m.R)                 -- R = T*R
    m.T :mul(m.S, m.S) :mult(m.T, m.S) -- S = T*S*T'
  end

  m.V :add(m.W :mul(m.R,m.U), m.V)     -- V = W*R+V
  m.W :mul(m.S, m.W)                   -- W = W*S
end

-- end ------------------------------------------------------------------------o
return M
