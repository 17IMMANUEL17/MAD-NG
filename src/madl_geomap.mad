--[=[
 o-----------------------------------------------------------------------------o
 |
 | Geometric 3D maps
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide a catalog of geometric 3D maps (i.e. survey)
    maps have the following calling convention:
      geomap(elm, map, len_weight)
    where the expected fields are:
      map -> { sdir, tdir, ang, tlt, V, W }
      elm -> { angle, dtheta, dphi, dpsi, dx, dy, ds}

 o-----------------------------------------------------------------------------o
]=]

local M = {}

-- locals ---------------------------------------------------------------------o

local _C, vector, matrix    in MAD
local minlen, minang        in MAD.constant

local abs, sin, cos         in math

-- temporaries ----------------------------------------------------------------o

local Ve = vector(3) -- displacement vector of element
local We = matrix(3) -- orientation  matrix of element

local T  = vector(3) -- misalignment translation
local R  = matrix(3) -- misalignment rotation
local Tb = vector(3) -- misalignment translation at exit (Tbar)
local Rb = matrix(3) -- misalignment rotation    at exit (Rbar)

local U  = vector(3) -- extra vector for calculation (avoid copy)
local S  = matrix(3) -- extra matrix for calculation (avoid copy)

-- patches (lw_ == 0 disable the patch) ---------------------------------------o

-- X-rotation

function M.xrotation (elm, m, lw_) -- Rx(ax)
  if lw_ == 0 then return end

  local ax = elm.angle

  if abs(ax) >= minang then
    local tdir, W in m
    local lw = lw_ or 1
    We:rotx(ax*lw*tdir)
    W:mul(We, W)            -- W = W*We
  end
end

-- Y-rotation

function M.yrotation (elm, m, lw_) -- Ry(ay)
  if lw_ == 0 then return end

  local ay = elm.angle

  if abs(ay) >= minang then
    local tdir, W in m
    local lw = lw_ or 1
    We:roty(ay*lw*tdir)
    W:mul(We, W)            -- W = W*We
  end
end

-- S-rotation

function M.srotation (elm, m, lw_) -- Rz(az)
  if lw_ == 0 then return end

  local az = elm.angle

  if abs(az) >= minang then
    local tdir, W in m
    local lw = lw_ or 1
    We:rotz(az*lw*tdir)
    W:mul(We, W)            -- W = W*We
  end
end

-- Translation

function M.translate (elm, m, lw_)
  if lw_ == 0 then return end

  local dx, dy, dz = elm.dx or 0, elm.dy or 0, elm.dz or 0

  if abs(dx)+abs(dy)+abs(dz) >= minlen then
    local tdir, V, W in m
    local lw = lw_ or 1
    Ve:fill{dx*lw*tdir, dy*lw*tdir, dz*lw*tdir}
    V:add(W:mul(Ve, U), V)  -- V = W*Ve+V
  end
end

-- Changeref (generic patch, lw_>0: TR, lw_<0: RT)

function M.changeref (elm, m, lw_)
  if lw_ == 0 then return end

  local dx  , dy  , dz   = elm.dx     or 0, elm.dy   or 0, elm.dz   or 0
  local dthe, dphi, dpsi = elm.dtheta or 0, elm.dphi or 0, elm.dpsi or 0

  local trn = abs(dx  )+abs(dy  )+abs(dz  ) >= minlen
  local rot = abs(dthe)+abs(dphi)+abs(dpsi) >= minang

  if not (trn or rot) then return end

  local tdir, V, W in m
  local lw = lw_ or 1

  -- translate
  if trn and lw > 0 then
    Ve:fill{dx*tdir, dy*tdir, dz*tdir}
    V:add(W:mul(Ve, U), V)  -- V = V+W*Ve
  end

  -- rotate
  if rot then
    We:rotzxy(-dphi*tdir, dthe*tdir, dpsi*tdir, lw<0)
    W:mul(We, W)            -- W = W*We
  end

  -- translate
  if trn and lw < 0 then
    Ve:fill{dx*tdir, dy*tdir, dz*tdir}
    V:sub(W:mul(Ve, U), V)  -- V = V-W*Ve
  end
end

-- Changedir (reverse t-direction)

function M.changedir (elm_, m, lw_)
  if lw_ == 0 then return end

  m.edir = -m.edir
  m.tdir = -m.tdir
end

-- Changenrj (change energy)

function M.changenrj (elm_, m_, lw_)
  -- N/A for survey
end

-- Misalign (misalignment, lw_>0: entry, lw_<0: exit)

local misalignexi

function M.misalign (elm, m, lw_)
  if lw_ == 0 then return end
  if (lw_ or 1) < 0 then return misalignexi(elm, m) end

  local dx  , dy  , dz   = elm.dx     or 0, elm.dy   or 0, elm.dz   or 0
  local dthe, dphi, dpsi = elm.dtheta or 0, elm.dphi or 0, elm.dpsi or 0

  local trn = abs(dx  )+abs(dy  )+abs(dz  ) >= minlen
  local rot = abs(dthe)+abs(dphi)+abs(dpsi) >= minang

  if not (trn or rot) then return end

  local sdir, edir, V, W in m

  -- misalignment at entry and global frame
  -- forward : x1' = R*x1+T      => V = V+W*T   ; W = W*R
  -- backward: x1  = R^t*(x1'-T) => W = W*R:t() ; V = V-W*T

  -- translate
  if trn and sdir > 0 then
    T:fill{dx*edir, dy*edir, dz*edir}
    V:add(W:mul(T, U), V)  -- V = V+W*T
  end

  -- rotate
  if rot then
    R:rotzxy(-dphi*edir, dthe*edir, dpsi*edir, sdir<0)
    W:mul(R, W)            -- W = W*R or W*R:t()
  end

  -- translate
  if trn and sdir < 0 then
    T:fill{dx*edir, dy*edir, dz*edir}
    V:sub(W:mul(T, U), V)  -- V = V-W*T
  end
end

function misalignexi (elm, m)
  local dx  , dy  , dz   = elm.dx     or 0, elm.dy   or 0, elm.dz   or 0
  local dthe, dphi, dpsi = elm.dtheta or 0, elm.dphi or 0, elm.dpsi or 0

  local trn = abs(dx  )+abs(dy  )+abs(dz  ) >= minlen
  local rot = abs(dthe)+abs(dphi)+abs(dpsi) >= minang

  if not (trn or rot) then return end

  local ds, ang, tlt, sdir, edir, V, W in m

  -- translation
  if trn then T:fill{dx*edir, dy*edir, dz*edir} else T:zeros() end

  -- rotation
  if rot then R:rotzxy(-dphi*edir, dthe*edir, dpsi*edir) end

  -- compute Rbar, Tbar
  _C.mad_mat_rtbar(Rb.data, Tb.data, abs(ds), ang, tlt, rot and R.data or nil, T.data)

  -- misalignment at exit and global frame
  -- forward : x2  = Rb^t*(x2'-Tb) => W = W*Rb:t() ; V = V-W*Tb
  -- backward: x2' = Rb*x2+Tb      => V = V+W*Tb   ; W = W*Rb

  if sdir > 0 then
    W:mult(Rb, W)          -- W = W*Rb:t()
    V:sub(W:mul(Tb, U), V) -- V = V - W*Tb
  else
    V:add(W:mul(Tb, U), V) -- V = V + W*Tb
    W:mul(Rb, W)           -- W = W*Rb
  end
end

-- kinds ----------------------------------------------------------------------o

function M.str_drift (elm, m, lw)
  local ds in m
  if abs(ds) < minlen then return end

  local V, W in m

  Ve:fill{0, 0, ds*lw}
  V:add(W:mul(Ve, U), V)         -- V = W*Ve+V
end

function M.cur_thin (elm, m, lw_)
  local ang in m
  if abs(ang) < minang then return end

  local W in m

  We:roty(-ang)
  W:mul(We, W)                   -- W = W*We
end

function M.cur_thick (elm, m, lw)
  local ds, ang in m
  if abs(ang) < minang then return M.str_drift(elm, m, lw) end
  if abs(ds)  < minlen then return M.cur_thin (elm, m, lw) end

  local V, W in m
  local ang = ang*lw
  local rho = ds/ang*lw

  Ve:fill{rho*(cos(ang)-1), 0, rho*sin(ang)}
  We:roty(-ang)
  V:add(W:mul(Ve, U), V)         -- V = W*Ve+V
  W:mul(We, W)                   -- W = W*We
end

-- end ------------------------------------------------------------------------o
return { geomap = M }
