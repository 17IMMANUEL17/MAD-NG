--[=[
 o-----------------------------------------------------------------------------o
 |
 | Geometric 3D maps
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide a catalog of geometric 3D maps (i.e. survey)
    maps have the following calling convention:
      geomap(elm, map, len_weight)
    where the expected fields are:

    map -> { sdir, V, W ; R, S, U }
    elm -> { l, angle ; phi, theta, psi, dx, dy, dz}

    (fields beyond ; are optionnal or internal)

 o-----------------------------------------------------------------------------o
]=]

local M = {}

-- locals ---------------------------------------------------------------------o

local abs, sin, cos  in math
local minlen, minang in MAD.constant
local is_number      in MAD.typeid
local errorf         in MAD.utility

-- debug ----------------------------------------------------------------------o

local nodump = true

local function mdump(str, l, m)
  if nodump then return end
  local V, A in m
  print(str, l, V[1], V[2], V[3], A[1], A[2], A[3])
end

-- patches (lw_ == 0 disable the patch) ---------------------------------------o

-- X-rotation (pitch)

function M.xrotation (elm, m, lw_) -- Rx(-phi)
  if lw_ == 0 then return end
  local lw = lw_ or 1

  local ang = is_number(elm) and elm or elm.angle
  if abs(ang) < minang then return end

  local tdir, S, W in m
  S:rotx(-ang*lw*tdir)
  W:mul(S, W)              -- W = W*S
end

-- Y-rotation (yaw)

function M.yrotation (elm, m, lw_) -- Ry(-theta)
  if lw_ == 0 then return end
  local lw = lw_ or 1

  local ang = is_number(elm) and elm or elm.angle
  if abs(ang) < minang then return end

  local tdir, S, W in m
  S:roty(-ang*lw*tdir)
  W:mul(S, W)              -- W = W*S
end

-- S-rotation (roll, tilt)

function M.srotation (elm, m, lw_) -- Rz(psi)
  if lw_ == 0 then return end
  local lw = lw_ or 1

  local ang = is_number(elm) and elm or elm.angle
  if abs(ang) < minang then return end

  local tdir, S, W in m
  S:rotz(ang*lw*tdir)
  W:mul(S, W)              -- W = W*S
end

-- Translation

function M.translate (elm, m, lw_)
  if lw_ == 0 then return end
  local lw = lw_ or 1

  local miserr in m
  local dx = (elm.dx or 0) + (elm.ddx or 0)*miserr
  local dy = (elm.dy or 0) + (elm.ddy or 0)*miserr
  local dz = (elm.dz or 0) + (elm.ddz or 0)*miserr

  if abs(dx)+abs(dy)+abs(dz) < minlen then return end

  local tdir, R, U, V, W in m
  R:fill{dx*lw*tdir, dy*lw*tdir, dz*lw*tdir}
  V:add(W:mul(R, U), V)    -- V = W*R+V
end

-- Changeref (generic patch, dir>0: xyzt, dir<0: tzyx)

function M.changeref (elm, m, lw_)
  if lw_ == 0 then return end
  local lw = lw_ or 1

  if lw < 0 then M.translate(elm, m, lw) end

  local miserr in m
  local the = (elm.theta or 0) + (elm.dtheta or 0)*miserr
  local phi = (elm.phi   or 0) + (elm.dphi   or 0)*miserr
  local psi = (elm.psi   or 0) + (elm.dpsi   or 0)*miserr

  if abs(the)+abs(phi)+abs(psi) >= minang then
    local tdir, S, W in m
    if lw > 0
    then S:rotxyz(-phi*lw*tdir, -the*lw*tdir, psi*lw*tdir)
    else S:rotzyx(-phi*lw*tdir, -the*lw*tdir, psi*lw*tdir)
    end
    W:mul(S, W)            -- W = W*S
  end

  if lw > 0 then M.translate(elm, m, lw) end
end

-- Changedir (reverse t-direction)

function M.changedir (elm_, m, lw_)
  if lw_ == 0 then return end

  m.edir = -m.edir
  m.tdir = -m.tdir
end

-- Changenrj (change energy)

function M.changenrj (elm_, m_, lw_)
  -- N/A for survey
end

-- kinds ----------------------------------------------------------------------o

function M.str_drift (elm, m, lw)
  local el = is_number(elm) and elm or m.el
  if abs(el) < minlen then return end

  local sdir, R, U, V, W in m
  local l = el*lw*sdir

--  mdump('drift-0:', l, m)
  R:fill{0, 0, l}
  V:add(W:mul(R, U), V)     -- V = V+W*R
--  mdump('drift-1:', l, m)
end

function M.cur_thin (elm, m, lw_)
  local ang = is_number(elm) and elm or m.ang
  if abs(ang) < minang then return end

  local tdir, S, W in m

--  mdump('thin-0:', m.el*m.sdir, m)
  S:roty(-ang*tdir)
  W:mul(S, W)                   -- W = W*S
--  mdump('thin-1:', m.el*m.sdir, m)
end

function M.cur_thick (elm, m, lw)
  local el, ang in m
  if abs(ang) < minang then return M.str_drift(el, m, lw) end
  if abs(el)  < minlen then return M.cur_thin(ang, m, lw) end

  local sdir, tdir, R, S, U, V, W in m
  local l, ang = el*sdir*lw, ang*tdir*lw
  local rho = l/ang

--  mdump('thick-0:', l, m)
  R:fill{rho*(cos(ang)-1), 0, rho*sin(ang)}
  S:roty(-ang)
  V:add(W:mul(R, U), V)         -- V = W*R+V
  W:mul(S, W)                   -- W = W*S
--  mdump('thick-1:', l, m)
end

-- end ------------------------------------------------------------------------o
return { geomap = M }
