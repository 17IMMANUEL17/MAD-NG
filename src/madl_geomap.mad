--[=[
 o-----------------------------------------------------------------------------o
 |
 | Geometric 3D maps
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide a catalog of geometric 3D maps (i.e. survey)
    maps have the following calling convention:
      geomap(elm, map, len_weight)
    where the expected fields are:
      map -> { sdir, tdir, el, ang, etlt, V, W }
      elm -> { angle, dtheta, dphi, dpsi, dx, dy, ds}

 o-----------------------------------------------------------------------------o
]=]

local M = {}

-- locals ---------------------------------------------------------------------o

local _C, vector, matrix    in MAD
local minlen, minang        in MAD.constant

local abs, sin, cos         in math

-- temporaries ----------------------------------------------------------------o

local Ve = vector(3) -- displacement vector of element
local We = matrix(3) -- orientation  matrix of element

local T  = vector(3) -- misalignment translation
local R  = matrix(3) -- misalignment rotation
local Tb = vector(3) -- misalignment translation at exit (Tbar)
local Rb = matrix(3) -- misalignment rotation    at exit (Rbar)

local U  = vector(3) -- extra vector for calculation (avoid copy)
local S  = matrix(3) -- extra matrix for calculation (avoid copy)

-- patches (lw_ == 0 disable the patch) ---------------------------------------o

-- X-rotation

function M.xrotation (elm, m, lw_) -- Rx(ax)
  if lw_ == 0 then return end

  local ax = elm.angle

  if abs(ax) >= minang then
    local tdir, W in m
    local lw = lw_ or 1
    We:rotx(ax*lw*tdir)
    W:mul(We, W)            -- W = W*We
  end
end

-- Y-rotation

function M.yrotation (elm, m, lw_) -- Ry(ay)
  if lw_ == 0 then return end

  local ay = elm.angle

  if abs(ay) >= minang then
    local tdir, W in m
    local lw = lw_ or 1
    We:roty(ay*lw*tdir)
    W:mul(We, W)            -- W = W*We
  end
end

-- S-rotation

function M.srotation (elm, m, lw_) -- Rz(az)
  if lw_ == 0 then return end

  local az = elm.angle

  if abs(az) >= minang then
    local tdir, W in m
    local lw = lw_ or 1
    We:rotz(az*lw*tdir)
    W:mul(We, W)            -- W = W*We
  end
end

-- Translation

function M.translate (elm, m, lw_)
  if lw_ == 0 then return end

  local dx, dy, dz = elm.dx or 0, elm.dy or 0, elm.dz or 0

  if abs(dx)+abs(dy)+abs(dz) >= minlen then
    local tdir, V, W in m
    local lw = lw_ or 1
    Ve:fill{dx*lw*tdir, dy*lw*tdir, dz*lw*tdir}
    V:add(W:mul(Ve, U), V)  -- V = W*Ve+V
  end
end

-- Changeref (generic patch, lw_>0: TR, lw_<0: RT)

function M.changeref (elm, m, lw_)
  if lw_ == 0 then return end

  local dx  , dy  , dz   = elm.dx     or 0, elm.dy   or 0, elm.dz   or 0
  local dthe, dphi, dpsi = elm.dtheta or 0, elm.dphi or 0, elm.dpsi or 0

  local trn = abs(dx  )+abs(dy  )+abs(dz  ) >= minlen
  local rot = abs(dthe)+abs(dphi)+abs(dpsi) >= minang

  if not (trn or rot) then return end

  local tdir, V, W in m
  local lw = lw_ or 1

  -- translate
  if trn and lw < 0 then
    Ve:fill{-dx*tdir, -dy*tdir, -dz*tdir}
    V:add(W:mul(Ve, U), V)  -- V = W*Ve+V
  end

  -- rotate
  if rot then
    We:rotzxy(-dphi*lw*tdir, dthe*lw*tdir, dpsi*lw*tdir, lw<0)
    W:mul(We, W)            -- W = W*We
  end

  -- translate
  if trn and lw > 0 then
    Ve:fill{dx*tdir, dy*tdir, dz*tdir}
    V:add(W:mul(Ve, U), V)  -- V = W*Ve+V
  end
end

-- Changedir (reverse t-direction)

function M.changedir (elm_, m, lw_)
  if lw_ == 0 then return end

  m.edir = -m.edir
  m.tdir = -m.tdir
end

-- Changenrj (change energy)

function M.changenrj (elm_, m_, lw_)
  -- N/A for survey
end

-- Misalign (lw_>0: entry, lw_<0: exit)

function M.misalign (elm, m, lw_)
  if lw_ == 0 then return end
  if (lw_ or 1) < 0 then return M.misalignexit(elm, m, lw_) end

  local dx  , dy  , dz   = elm.dx     or 0, elm.dy   or 0, elm.dz   or 0
  local dthe, dphi, dpsi = elm.dtheta or 0, elm.dphi or 0, elm.dpsi or 0

  local trn = abs(dx  )+abs(dy  )+abs(dz  ) >= minlen
  local rot = abs(dthe)+abs(dphi)+abs(dpsi) >= minang

  if not (trn or rot) then return end

  local tdir, V, W in m

  -- translate
  if trn then
    T:fill{dx*tdir, dy*tdir, dz*tdir}
    V:add(W:mul(T, U), V)  -- V = W*T+V
  end

  -- rotate
  if rot then
    R:rotzxy(-dphi*tdir, dthe*tdir, dpsi*tdir)
    W:mul(R, W)            -- W = W*R
  end
end

function M.misalignexit (elm, m, lw_)
  local dx  , dy  , dz   = elm.dx     or 0, elm.dy   or 0, elm.dz   or 0
  local dthe, dphi, dpsi = elm.dtheta or 0, elm.dphi or 0, elm.dpsi or 0

  local trn = abs(dx  )+abs(dy  )+abs(dz  ) >= minlen
  local rot = abs(dthe)+abs(dphi)+abs(dpsi) >= minang

  if not (trn or rot) then return end

  local el, ang, etlt, sdir, tdir, V, W in m
  local l, ang, tlt = el*sdir, ang*tdir, etlt*tdir

  -- translation
  if trn then
    T:fill{dx*tdir, dy*tdir, dz*tdir}
  else
    T:zeros()
  end

  -- rotation
  if rot then
    R:rotzxy(-dphi*tdir, dthe*tdir, dpsi*tdir)
  end

  -- compute Rbar, Tbar
  _C.mad_mat_rtbar(Rb.data, Tb.data, l, ang, tlt, rot and R.data or nil, T.data)

  -- apply inverse misalignment to global frame
  W:mult(Rb, W)                -- W = W*Rb:t()
  V:sub(W:mul(Tb, U), V)       -- V = V - W*Tb
end

-- kinds ----------------------------------------------------------------------o

function M.str_drift (elm, m, lw)
  local el in m
  if abs(el) < minlen then return end

  local sdir, V, W in m
  local l = el*lw*sdir

  Ve:fill{0, 0, l}
  V:add(W:mul(Ve, U), V)         -- V = W*Ve+V
end

function M.cur_thin (elm, m, lw_)
  local ang in m
  if abs(ang) < minang then return end

  local tdir, W in m

  We:roty(-ang*tdir)
  W:mul(We, W)                   -- W = W*We
end

function M.cur_thick (elm, m, lw)
  local el, ang in m
  if abs(ang) < minang then return M.str_drift(elm, m, lw) end
  if abs(el)  < minlen then return M.cur_thin (elm, m, lw) end

  local sdir, tdir, V, W in m
  local l, ang = el*sdir*lw, ang*tdir*lw
  local rho = l/ang

  Ve:fill{rho*(cos(ang)-1), 0, rho*sin(ang)}
  We:roty(-ang)
  V:add(W:mul(Ve, U), V)         -- V = W*Ve+V
  W:mul(We, W)                   -- W = W*We
end

-- end ------------------------------------------------------------------------o
return { geomap = M }
