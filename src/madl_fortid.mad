--[=[
 o-----------------------------------------------------------------------------o
 |
 | Debug Fortran files module
 |
 | Methodical Accelerator Design - Copyright (c) 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Utility routines for comparing damaps or other information dumped into
    fortran files, e.g. damap vs PTC

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local damap                        in MAD
local is_nil, is_number, is_string in MAD.typeid
local openfile                     in MAD.utility

-- implementation -------------------------------------------------------------o

local dum = damap() -- get a dummy damap object

-- args: tbl|str, tbl|nil, num|nil, str|nil
local function cmpdaf(lst, pfx_, eps_, knd_)
  if is_number(pfx_) and is_nil(knd_) then
    knd_, eps_, pfx_ = eps_, pfx_ -- right shift
  end
  if is_string(eps_) and is_nil(knd_) then
    knd_, eps_ = eps_             -- right shift
  end
  local eps = eps_ or 1e-14
  local knd = knd_ or "4C"
  local pfx = pfx_ or {}
  local dir = pfx.dir or "fort/fort"
  local ptc = pfx.ptc or "_p"
  local mad = pfx.mad or "_n"
  local dif = pfx.dif or "_d"

  if is_string(lst) then lst = {lst} end

  local m_p, m_n, m_d, nam

  for _, v in ipairs(lst) do
    io.stderr:write("processing files ", v)

    local f_p = openfile(dir.."."..v)
    if f_p then
      io.stderr:write(", ", v, ptc)
      f_p:read() ; f_p:read() ; f_p:read()
      m_p = dum:read(f_p, knd):fromptc():write(dir..ptc.."."..v)
      f_p:close()
    end

    local f_n = openfile(dir..mad.."."..v, '.dat')
    if f_n then
      io.stderr:write(", ", v, mad)
--      local nam = (f_n:read() or ""):sub(6,-3)
      m_n, nam = dum:read(f_n)
      f_n:close()
    end

    if m_p and m_n then
      io.stderr:write(", ", v, dif)
      m_d = m_p:dif(m_n):write(dir..dif.."."..v, nam, eps)
    end

    io.stderr:write("\n")
  end
  return m_p, m_n, m_d
end

local function cmpdafN(lst_i, lst_n, pfx_, eps_)
  if is_number(pfx_) and is_nil(eps_) then eps_, pfx_ = pfx_, nil end
  local eps = eps_ or 1e-14
  local pfx = pfx_ or {}
  local dir = pfx.dir or "fort/fort"
  local ptc = pfx.ptc or "_p"
  local mad = pfx.mad or "_n"
  local dif = pfx.dif or "_d"
  local nul = pfx.nul or false

  if is_string(lst_i) then lst_i, lst_n = {lst_i}, {lst_n} end

  for i, v in ipairs(lst_i) do
    io.stderr:write("processing files ", v)
    local f_i = assert(openfile(dir.."."..v)) ; f_i:read()
    local f_p = assert(openfile(dir..ptc.."."..v..".dat", "w"))
    local f_n =        openfile(dir..mad.."."..v..".dat")
    local f_d = nil

    for k=1,lst_n[i] or 1 do
      local x = dum.x:read(f_i,"C")
      if nul or not x:isnul() then
        x:convert(x, {1,2,3,4,6,5}, 1):write(f_p)
        if f_n then
          if not f_d then -- create on need
            f_d = assert(openfile(dir..dif.."."..v..".dat", "w"))
          end

          local y = x:read(f_n)
          if y then
            if (x-y):nrm() > (-x-y):nrm() then x = -x end -- try to detect time
            x:dif(y):write(f_d, y:nam(), eps)
          end
        end
      end
    end

    io.stderr:write(", ", v, ptc)
    f_p:close() ; f_i:close()

    if f_n then
      io.stderr:write(", ", v, "_n")
      io.stderr:write(", ", v, "_d")
      f_n:close() ; f_d:close()
    end
    io.stderr:write("\n")
  end
end

-- end ------------------------------------------------------------------------o
return {
  cmpdaf  = cmpdaf,
  cmpdafN = cmpdafN,
}
