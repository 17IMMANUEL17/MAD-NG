--[=[
 o-----------------------------------------------------------------------------o
 |
 | Closed Orbit module
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: I. Shreyber, irina.tecker at cern.ch
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - TODO

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local warn, vector, matrix, command, track        in MAD
local is_positive                                 in MAD.typeid
local errorf, assertf                             in MAD.utility
local abs                                         in math

local vnam = {'x', 'px', 'y', 'py', 't', 'pt'}

local I  = matrix(6):eye()
local I4 = matrix(4):eye()

-- helpers --------------------------------------------------------------------o

local function has_dp (R, dptol)
  local nr, nc = R:sizes()
  assert(nr == 6 and nc == 6, "invalid one-turn map (6D matrix expected)")

  local nodp = abs(R:get(6,6) - 1) <= dptol

  for i=1,5 do
    nodp = nodp and abs(R:get(6,i)) <= dptol
  end

  return not nodp
end

-- cofind algorithms ----------------------------------------------------------o

local method = {}

function method.newton (X0, X, R, tol, dptol)
  local dX, rnk

  -- check for 4D or 6D
  if has_dp(R, dptol) then    -- 6D case
    dX, rnk = (R-I):solve(X-X0)

    if rnk < 6 then
      warn("singular matrix occurred during 6D closed orbit search.")
      return nil, rnk
    end

    -- adjust orbit
    X0:sub(dX,X0)

  else                        -- 4D case
    X = X:getrow(1..4) - X0:getrow(1..4)
    R = R:getsub(1..4, 1..4) - I4
    dX, rnk = R:solve(X)

    if rnk < 4 then
      warn("singular matrix occurred during 4D closed orbit search.")
      return nil, rnk
    end

    -- adjust orbit
    X = X0:getrow(1..4) - dX
    X0:zeros():copy(X)
  end

  -- return X0 if correction is below tolerance
  if dX:maxabs() < tol then return X0 end

  -- not found, continue iteration
  return -1
end

-- cofind using jacobian ------------------------------------------------------o

local function cofind_jacob (self, track)
  local cotol, coiter, codiff, codptol, optimize in self
  local cofind = method[optimize]

  -- build 6D initial orbit
  local X0 = vector(6):fill(self.X0)

  -- track 6+1 particles to compute jacobian by finite differences
  local Xs = { 0,0,0,0,0,0,X0 }
  for j=1,6 do Xs[j] = X0:same() end

  -- search for fix point
  for iter=1,coiter do

    -- init dx_j
    for j=1,6 do
      Xs[j]:copy(X0):seti(j, X0[j]+codiff)
    end

    -- track 6D x 7 particles
    local _, mflw = track { X0=Xs }

    -- retrieve 6D orbit and one-turn map
    local X, R = vector(6), matrix(6)

    for i=1,6 do
      X[i] = mflw[7][vnam[i]]
      for j=1,6 do -- compute jacobian df(x_i)/dx_j
        R:set(i,j, (mflw[j][vnam[i]] - X[i])/codiff)
      end
    end

    -- update X0 = X0-dX, where dX solves (R-I)dX = X-X0
    local res, rnk = cofind(X0, X, R, cotol, codptol)
    if res ~= -1 then return res, rnk or iter end -- solution or sub-rank
  end

  errorf("closed orbit did not converge in %d iterations", coiter)
end

-- cofind using map -----------------------------------------------------------o

local function cofind_map (self, track)
  local cotol, coiter, codptol, optimize in self
  local cofind = method[optimize]

  -- build 6D initial orbit
  local X0 = vector(6):fill(self.X0)

  -- search for fix point
  for iter=1,coiter do

    -- track 6D x 1 mapflow
    local _, mflw = track { X0=X0 }

    -- retrieve 6D orbit and one-turn map
    local X = mflw[1]:get0()
    local R = mflw[1]:get1()

    -- update X0 = X0-dX, where dX solves (R-I)dX = X-X0
    local res, rnk = cofind(X0, X, R, cotol, codptol)
    if res ~= -1 then return res, rnk or iter end -- solution or sub-rank
  end

  errorf("closed orbit did not converge in %d iterations", coiter)
end

-- cofind command -------------------------------------------------------------o

local function exec (self)
  local usemap, cotol, coiter, codiff, codptol, optimize in self
  assertf(is_positive(cotol ), "invalid cotol %.15g (positive number expected)" , cotol )
  assertf(is_positive(coiter), "invalid coiter %d (positive number expected)"   , coiter)
  assertf(is_positive(codiff), "invalid codiff %.15g (positive number expected)", codiff)
  assertf(is_positive(codptol),"invalid codptol %.15g (positive number expected)",codptol)
  assertf(method[optimize]   , "invalid optimize method '%s' (unsupported)", optimize)

  -- prepare the track template
  local trck0 = track 'cofind' {

    -- forwarded options
    beam      = self.beam,
    sequence  = self.sequence,
    range     = self.range,
    sdir      = self.sdir,

    s0        = self.s0,
    X0        = self.X0,

    mapdef    = self.usemap and {xy=1} or nil,
    nturn     = self.nturn,
    nslice    = self.nslice,
    method    = self.method,

    -- overridden options
    save      = false,
    exec      = false,
  }

  -- search closed orbit using Newton algorithm
  if usemap
  then return cofind_map   (self, trck0) -- use one-turn map
  else return cofind_jacob (self, trck0) -- use computed jacobian
  end
end

local cofind = command 'COFind' {
  beam=nil,          -- beam (required)                                   (trck)
  sequence=nil,      -- sequence (required)                               (trck)
  range=nil,         -- range of tracking                                 (trck)
  sdir=1,            -- s-direction of tracking (1 or -1)                 (trck)

  s0=0,              -- initial s                                         (trck)
  X0={0,0,0,0,0,0},  -- initial coordinates for orbit search              (trck)

  usemap=true,       -- use DA to compute the jacobian                    (cofn)

  nturn=1,           -- number of turns                                   (trck)
  nslice=1,          -- number of slice for each element                  (trck)
  method='simple',   -- default integrator                                (trck)

  optimize='newton', -- default optimizer                                 (cofn)

  cotol=1e-8,        -- closed orbit tolerance                            (cofn)
  coiter=20,         -- maximum number of iteration                       (cofn)
  codiff=1e-10,      -- finite differences steps                          (cofn)
  codptol=1e-12,     -- static vs dynamic tolerance                       (cofn)

  exec=exec,      -- command to execute upon children creation
} :set_readonly() -- reference cofind command is readonly

-- end ------------------------------------------------------------------------o
return { cofind = cofind }
