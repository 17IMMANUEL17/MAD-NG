--[=[
 o-----------------------------------------------------------------------------o
 |
 | Closed Orbit module
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - TODO

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local warn, option, vector, matrix, command, track                in MAD
local fnone                                                       in MAD.gfunc
local has_dp, vname                                               in MAD.gphys
local tblcat, tblorder, errorf, assertf                           in MAD.utility
local is_number, is_positive, is_boolean, is_true, is_iterable,
      is_mappable                                                 in MAD.typeid

local abs in math

local vn = vname[6]

-- helpers --------------------------------------------------------------------o

local function parcpy (X, Y_) -- see track init
  local Y = Y_ or table.new(0,10)
  Y.x, Y.px = X.x, X.px
  Y.y, Y.py = X.y, X.py
  Y.t, Y.pt = X.t, X.pt
  return Y
end

local function par2vec (X, V_)
  local V = V_ or vector(6)
  if is_number(X) then return V:fill(X) end
  V[1], V[2] = X.x, X.px
  V[3], V[4] = X.y, X.py
  V[5], V[6] = X.t, X.pt
  return V
end

local function vec2par (V, X_)
  local X = X_ or table.new(0,10)
  X.x, X.px = V[1], V[2]
  X.y, X.py = V[3], V[4]
  X.t, X.pt = V[5], V[6]
  return X
end

-- cofind algorithms ----------------------------------------------------------o

local method = {}

local I  = matrix(6):eye()
local I4 = matrix(4):eye()
local X4 = vector(4)
local R4 = matrix(4)
local r4 = 1..4

function method.newton (X0, X, R, T, tol, dptol)
  local dX, rnk

  if not T and has_dp(R, dptol) then
    -- 6D case
    dX, rnk = (R-I):solve(X-X0)

    if rnk < 6 then
      return rnk, "singular"
    elseif dX:maxabs() <= tol then
      return rnk, "stable", dX
    end

    -- adjust orbit
    X0:sub(dX,X0)

  else
    -- 4D case
    X0:getrow(r4, X4) ; R:getsub(r4,r4, R4)
    dX, rnk = (R4-I4):solve(X:getrow(r4)-X4)

    if rnk < 4 then
      return rnk, "singular"
    elseif dX:maxabs() <= tol then
      return rnk, "stable", dX
    end

    -- adjust orbit
    X0:copy(X4-dX)
  end

  return rnk
end

-- cofind using jacobian ------------------------------------------------------o

-- functor to avoid overrides
local fun = \m,_,k,v => if m[k] == nil then m[k] = v end end

local function cofind_jacob (self, track)
  local cotol, coiter, codiff, codptol, comethod in self
  local costep, T = method[comethod], self.totalpath

  -- error handling
  local errf = self.cowarn and warn or errorf

  -- save final translation, finite differences, coordinates scales, temporaries
  local X1 = par2vec(self.X1)
  local dH = par2vec(codiff)
  local dS = par2vec(1)
  local X, R = vector(6), matrix(6)

  -- let's track build particles (e.g. handle deltap and check attributes)
  local mtbl, mflw = track { nstep=0 }

  -- save current orbits, extend n particles to n*(1+6) particles
  local n, X0 = mflw.npar, table.new(mflw.npar,0)
  for i=n,1,-1 do
    local m, ii = mflw[i], 7*(i-1)+1
    local mt = {__index=m, __newindex=bind1st(fun,m)}
    for j=6,1,-1 do
      local mc = parcpy(m)
      mflw[ii+j], mc.id, mc.nosave = mc, ii+j, true
      setmetatable(mc,mt) -- connect side particles to main particle
    end
    mflw[ii], m.id, m.coid = m, ii, m.id
    X0[i] = par2vec(m)   -- save current orbit
    X:add(X0[i]:abs(),X) -- accumulate absolute values of orbits
  end
  X:div(n,X) -- average accumulated orbits
  mflw.npar, mflw.tpar, n = 7*n, 7*n, 7*n

  -- set dS by q/p
  if is_number(codiff) then
    for i=1,5,2 do
      if X[i+1] > 1e-12 then dS[i] = max(min(X[i]/X[i+1],1e4),1e-4) end
    end
  end

  -- search for fix points
  for itr=1,coiter do
    -- sanity check
    assert(n%7 == 0, "unexpected corrupted set of particles blocks")

    -- set finite differences for jacobian (side particles)
    for i=1,n,7 do
      local id = mflw[i].coid
      for j=1,6 do
        m = mflw[i+j]
        m[vn[j]] = X0[id][j] + dH[j]*dS[j]
        assert(m.coid == id, "unexpected corrupted particles block")
      end
    end

    -- track blocks of 7 particles
    track { mflow=mflw }

    -- lost particles (if any)
    if n ~= mflw.npar then
      warn("cofind: lost %d particles at iteration %d", n-mflw.npar, itr)
      -- save information (spos, turn and status set by lostpar)
      for i=mflw.npar+1,n do mflw[i].coiter = itr end
      n = mflw.npar

      -- filter out particles with at least one lost particle in their block
      local i = 1
      while i <= n do
        if m.status == "lost" then
          mflw[i], mflw[n] = mflw[n], mflw[i] -- swap with last
          n = n - 1
        else
          i = i + 1
        end
      end

      -- reorder remaining tracked particles
      tblorder(mflw, n)
      -- update number of tracked particles
      mflw.npar = n
      -- sanity check (again)
      assert(n%7 == 0, "unexpected corrupted set of particles blocks")
    end

    -- update orbits
    local i = 1
    while i <= n do
      local m = mflw[i]

      -- retrieve previous orbit, current orbit and jacobian
      local X0 = X0[m.coid] ; par2vec(m, X)
      for j=1,6 do ; for k=1,6 do -- compute jacobian R_jk = df(x_j)/dx_k
        R:set(j,k, (mflw[i+k][vn[j]] - X[j])/(dH[k]*dS[k]))
      end end

      -- update X0 = X0-dX if |dX| > cotol, where dX solves (R-I)dX = (X-X1)-X0
      local rnk, typ, dX = costep(X0, X-X1, R, T, cotol, codptol)

      if typ then -- "stable/singular"
        if typ == "singular" then
          warn("cofind: singular matrix (rnk=%d) at iteration %d \z
                for particle %d.", rnk, itr, m.coid)
        elseif option.debug > 2 then
          dX:print(string.format("cofind: (id=%d,itr=%d) dX", m.coid, itr))
        end
        -- save information in stable/singular main particle
        m.rank, m.status, m.coiter = rnk, typ, itr
        -- swap with last tracked block
        for j=0,6 do mflw[i+j], mflw[n-6+j] = mflw[n-6+j], mflw[i+j] end
        n = n - 7
      else
        -- set new orbit to main particle
        vec2par(X0, m)
        i = i + 7
      end
    end

    -- update the number of tracked particles
    mflw.npar = n

    -- all damaps have been processed
    if n == 0 then break end

    -- reset sequence iterator
    mflw:ireset()
  end

  if n ~= 0 then
    errf("cofind: closed orbit(s) did not converge in %d iterations", coiter)
    for i=1,n do
      mflw[i].coiter, mflw[i].status = coiter, "unstable"
    end
  end

  -- remove side particles, restore initial ids
  local j = 1
  for i=1,mflw.tpar do
    local m = mflw[i]
    if getmetatable(m) == nil then
      mflw[j], m.id, j, m.coid = m, m.coid, j+1, nil
    end
  end
  j = j - 1
  assert(7*j == mflw.tpar, "unexpected corrupted set of particles")

  -- reorder entire mflw
  mflw.npar, mflw.tpar = j, j
  tblorder(mflw, mflw.npar)

  return mtbl, mflw, X0
end

-- cofind using map -----------------------------------------------------------o

local function cofind_map (self, track)
  local cotol, coiter, codptol, comethod in self
  local costep, T = method[comethod], self.totalpath

  -- error handling
  local errf = self.cowarn and warn or errorf

  -- save final translation, temporaries
  local X1 = par2vec(self.X1)
  local X, R = vector(6), matrix(6)

  -- let's track build damaps (e.g. handle deltap and check attributes)
  local mtbl, mflw = track { nstep=0 }

  -- save current orbits, cleanup damaps
  local n, X0 = mflw.npar, table.new(mflw.npar,0)
  for i=1,n do X0[i] = mflw[i]:get0() end  -- save current orbit

  -- search for fix points
  for itr=1,coiter do
    -- track damaps
    track { mflow=mflw }

    -- lost damaps (if any)
    if n ~= mflw.npar then
      warn("cofind: lost %d particles at iteration %d", n-mflw.npar, itr)
      -- save information (spos, turn and status set by lostpar)
      for i=mflw.npar+1,n do mflw[i].coiter = itr end
      n = mflw.npar
    end

    -- update orbits
    local i = 1
    while i <= n do
      local m = mflw[i]

      -- retrieve previous orbit, current orbit and jacobian
      local X0 = X0[m.id]
      m:get0(X) ; m:get1(R)

      -- update X0 = X0-dX if |dX| > cotol, where dX solves (R-I)dX = (X-X1)-X0
      local rnk, typ, dX = costep(X0, X-X1, R, T, cotol, codptol)

      if typ then -- "stable/singular"
        if typ == "singular" then
          warn("cofind: singular matrix (rnk=%d) at iteration %d \z
                for damap %d.", rnk, itr, m.id)
        elseif option.debug > 2 then
          dX:print(string.format("cofind: (id=%d,itr=%d) dX", m.id, itr))
        end
        -- save information in stable/singular damap
        m.rank, m.status, m.coiter = rnk, typ, itr
        -- swap with last tracked damap
        mflw[i], mflw[n] = mflw[n], mflw[i]
        n = n - 1
      else
        -- set new orbit, order 1 to I, higher orders to 0
        m:setv(X0)
        i = i + 1
      end
    end

    -- update the number of tracked damap
    mflw.npar = n

    -- all damaps have been processed
    if n == 0 then break end

    -- reset sequence iterator
    mflw:ireset()
  end

  if n ~= 0 then
    errf("cofind: closed orbit(s) did not converge in %d iterations", coiter)
    for i=1,n do
      mflw[i].coiter, mflw[i].status = coiter, "unstable"
    end
  end

  -- reorder entire mflw
  mflw.npar = mflw.tpar
  tblorder(mflw, mflw.npar)

  return mtbl, mflw, X0
end

-- cofind command -------------------------------------------------------------o

-- input  status: Xset, Rset, Mset (from track)
-- output status: stable, unstable, singular, lost.

local function exec (self)
  local mapdef, cotol, coiter, codiff, codptol, comethod, cowarn in self
  assertf(is_positive(cotol ), "invalid cotol %.15g (positive number expected)" , cotol )
  assertf(is_positive(coiter), "invalid coiter %d (positive number expected)"   , coiter)
  assertf(is_positive(codiff), "invalid codiff %.15g (positive number expected)", codiff)
  assertf(is_positive(codptol),"invalid codptol %.15g (positive number expected)",codptol)
  assertf(   method[comethod], "invalid comethod '%s' (unsupported method)"     ,comethod)
  assert (is_boolean(cowarn) , "invalid cowarn (boolean expected)")

  -- prepare track template
  local cotrack = track 'cotrack' { exec=false } :copy_variables(self)

  -- setup map order
  cotrack.mapdef = is_true(mapdef) and {xy=1} or mapdef

  -- search closed orbit
  if mapdef
  then return cofind_map  (self, cotrack) -- use damap
  else return cofind_jacob(self, cotrack) -- use jacobian
  end
end

-- attributes set to nil will use the default from track by inheritance

local cofind = command 'cofind' {
  beam=nil,          -- beam (required or sequence.beam)                  (trck)
  sequence=nil,      -- sequence (required)                               (trck)
  range=nil,         -- range of tracking                                 (trck)
  dir=nil,           -- s-direction of tracking (1 or -1)                 (trck)

  s0=nil,            -- initial s (offset)                                (trck)
  X0=nil,            -- initial X coordinates (or damap, or list of)      (trck)
  O0=nil,            -- initial orbit translation to apply to all X0      (trck)
  R0=nil,            -- initial R matrix (companion of X0 for damap)      (trck)
  beta0=nil,         -- initial beta0 block to build R0                   (trck)
  deltap=nil,        -- initial deltap(s)                                 (trck)

  mapdef=true,       -- setup for damap (true => {xy=1})                  (trck)
  mapsave=nil,       -- save damap in the mtable                          (trck)
  mapdump=nil,       -- dump X and R after each element                   (trck)

  nturn=nil,         -- number of turns                                   (trck)
  nstep=nil,         -- number of elements to track                       (trck)
  npart=nil,         -- number of particles/damaps (or #X0)               (trck)
  nslice=nil,        -- number of slice for each element                  (trck)
  model=nil,         -- model for integration ('DKD' or 'TKT')            (trck)
  method=nil,        -- method or order for integration (1 to 8)          (trck)
  implicit=nil,      -- slice implicit elements too                       (trck)
  radiate=nil,       -- radiate at slices (NYI)                           (trck)
  misalign=nil,      -- consider misalignment                             (trck)
  totalpath=nil,     -- 't' is the totalpath                              (trck)

  save=false,        -- create mtable and save results of last turn       (trck)
  title=nil,         -- title of mtable (default seq.name)                (trck)
  observe=nil,       -- save only in observed elements (every n turns)    (trck)
  savesel=nil,       -- save selector (predicate)                         (trck)

  atentry=nil,       -- action called when entering an element            (trck)
  atslice=nil,       -- action called after each element slices           (trck)
  atexit=nil,        -- action called when exiting an element             (trck)
  ataper=nil,        -- action called after checking for aperture         (trck)
  atsave=nil,        -- action called after saving in mtable              (trck)

  cotol=1e-8,        -- closed orbit tolerance                            (cofn)
  coiter=20,         -- maximum number of iteration                       (cofn)
  codiff=1e-10,      -- finite differences step for jacobian              (cofn)
  codptol=1e-12,     -- 4D vs 6D dp tolerance                             (cofn)
  comethod='newton', -- default algorithm                                 (cofn)
  cowarn=false,      -- commute errors into warnings                      (cofn)
  X1=0,              -- optional final coordinates translation            (cofn)

  usrdef=nil,        -- user defined data attached to the mflow           (trck)

  mflow=nil,         -- mflow, exclusive with other attributes except nstep
  exec=exec,         -- command to execute upon children creation

  __attr = tblcat(   -- list of all setup attributes
    {'cotol', 'coiter', 'codiff', 'codptol', 'comethod', 'cowarn', 'X1'},
    track.__attr,
    {noeval=track.__attr.noeval}
  )
} :set_readonly()    -- reference cofind command is readonly

-- end ------------------------------------------------------------------------o
return { cofind = cofind }
