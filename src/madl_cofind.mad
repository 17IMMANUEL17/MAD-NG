--[=[
 o-----------------------------------------------------------------------------o
 |
 | Closed Orbit module
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - TODO

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local warn, vector, matrix, command, track                        in MAD
local fnone                                                       in MAD.gfunc
local cvname, has_dp                                              in MAD.gphys
local errorf, assertf                                             in MAD.utility
local is_number, is_positive, is_boolean, is_true, is_iterable    in MAD.typeid
local abs                                                         in math

local I  = matrix(6):eye()
local I4 = matrix(4):eye()

-- cofind algorithms ----------------------------------------------------------o

local method = {}

function method.newton (X0, X, R, T, tol, dptol)
  local dX, rnk

  if not T and has_dp(R, dptol) then
    -- 6D case
    dX, rnk = (R-I):solve(X-X0)

    if rnk < 6 then
      warn("singular matrix occurred during 6D closed orbit search.")
      return rnk, "Singular"
    end

    -- adjust orbit
    X0:sub(dX,X0)

  else
    -- 4D case
    local X4 = X:getrow(1..4) - X0:getrow(1..4)
    local R4 = R:getsub(1..4, 1..4) - I4
    dX, rnk = R4:solve(X4)

    if rnk < 4 then
      warn("singular matrix occurred during 4D closed orbit search.")
      return rnk, "Singular"
    end

    -- adjust orbit
    X4 = X0:getrow(1..4) - dX
    X0:zeros():copy(X4)
  end

  -- return if last applied correction is below tolerance
  if dX:maxabs() < tol then
    return rnk, rnk == 4 and "4D" or "6D"
  end
end

-- cofind using jacobian ------------------------------------------------------o

local function cofind_jacob (self, track)
  local cotol, coiter, codiff, codptol, comethod in self
  local costep = method[comethod]
  local T = self.totalpath

  assert(is_number(track.X0[1]),"cofind works only with single particles")

  -- error handling
  local errf = self.cowarn and warn or errorf

  -- build 6D initial orbit
  local X0 = vector(6):fill(track.X0)   -- initial coordinates
  local X1 = vector(6):fill(self .X1)   -- final translation
  local dX = vector(6):fill(codiff)     -- finite differences

  -- track 6+1 particles to compute jacobian by finite differences
  local Xs = { 0,0,0,0,0,0,X0 }
  for j=1,6 do Xs[j] = X0:same() end

  -- scale positions vs momentum (empirical...)
  if is_number(codiff) then
    dX[1], dX[3] = codiff*100, codiff*100
  end

  -- search for fix point
  local X, R, rnk, typ

  for itr=1,coiter do

    -- init dx_j
    for j=1,6 do
      Xs[j]:copy(X0):seti(j, X0[j]+dX[j])
    end

    -- track 6D x 7 particles
    local _, mflw = track { X0=Xs }

    -- check for all particles lost
    if mflw.npar ~= 7 then
      errf("cofind lost %d particles after %d iterations", 7-mflw.npar, itr)
      return X0, R, rnk, typ, itr
    end

    -- retrieve 6D orbit and one-turn map
    X, R = vector(6), matrix(6)

    for i=1,6 do
      local cvn = cvname[i]
      X[i] = mflw[7][cvn]
      for j=1,6 do -- compute jacobian R_ij = df(x_i)/dx_j
        R:set(i,j, (mflw[j][cvn] - X[i])/dX[j])
      end
    end

    -- update X0 = X0-dX if |dX| >= cotol, where dX solves (R-I)dX = (X-X1)-X0
    rnk, typ = costep(X0, X-X1, R, T, cotol, codptol)

    -- orbit X, one-turn map R, rank of R, "4D"|"6D"|"Singular"|"Lost", itr
    if typ then return X0, R, rnk, typ, itr end
  end

  errf("closed orbit did not converge in %d iterations", coiter)
  return X0, R, rnk, typ, coiter
end

-- cofind using map -----------------------------------------------------------o

--[[                 npar           tpar                              npart
   +-----------------+--------------+      +--------------------------+
X0 | Active          | Lost         | => X | Found/Lost-by-id         |
   +-----------------+--------------+      +--------------------------+
--]]

local function cofind_map (self, track)
  local cotol, coiter, codptol, comethod in self
  local costep = method[comethod]
  local T = self.totalpath

  -- error handling
  local errf = self.cowarn and warn or errorf

  -- let's track build initial damaps (e.g. handle deltap)
  local _, mflw = track { nstep=0, save=false }
  local npar = mflw.npar

  -- build 6D initial orbit
  local X0  = table.new(npar,0)   -- initial coordinates [damaps  ]
  local X1  = table.new(npar,0)   -- final translations  [vectors ]
  local X   = table.new(npar,0)   -- final coodinates    [vectors ]
  local R   = table.new(npar,0)   -- final one-turn maps [matrices]
  local rnk = table.new(npar,0)   -- ranks
  local typ = table.new(npar,0)   -- types for ending
  local itr = table.new(npar,0)   -- iterations
  local X1i = self.X1

  -- prepare initial damaps/final vectors
  for i=1,npar do
    X0[i] = mflw[i]
    X1[i] = vector(6):fill(is_iterable(X1i[i]) and X1i[i] or X1i)
  end

  -- search for fix point(s)
  for it=1,coiter do
    -- track damaps
    local _, mflw = track { X0=X0, npart=npar, deltap=0 }
    npar = mflw.npar

    local i = 1
    while i <= npar do
      -- retrieve 6D orbit and one-turn map
      local j    = X0  [i].id
      local X0i  = X0  [i]:get0()
      local Xi   = mflw[i]:get0()
            Ri   = mflw[i]:get1()

      -- update X0 = X0-dX if |dX| >= cotol, where dX solves (R-I)dX = (X-X1)-X0
      local rnki, typi = costep(X0i, Xi-X1[i], Ri, T, cotol, codptol)
      -- print('it=', it, 'i=', i, 'typi=', typi, 'err=', (X0i-Xi):norm())

      -- save or update results
      if typi then
        X[j], R[j], rnk[j], typ[j], itr[j] = X0i, Ri, rnki, typi, it
        X0[i], X0[npar] = X0[npar], nil
        npar = npar - 1
      else
        X0[i]:setv(X0i)
        i = i + 1
      end
    end

    -- handle lost particles (if any)
    for i=mflw.npar+1,mflw.tpar do
      X[j], R[j], rnk[j], typ[j], itr[j] = mflw[i]:get0(), nil, 0, "Lost", it
    end

    -- all damaps have been processed
    if npar == 0 then
      if itr[2] == nil then
        X, R, rnk, typ, itr = X[1], R[1], rnk[1], typ[1], itr[1]
      end
      -- orbit X, one-turn map R, rank of R, "4D"|"6D"|"Singular"|"Lost", it
      return X, R, rnk, typ, itr
    end
  end

  -- return X and R as-is for debug and analysis (if errf=warn!)
  errf("closed orbit did not converge in %d iterations", coiter)
  return X, R, rnk, typ, coiter
end

-- cofind command -------------------------------------------------------------o

local function exec (self)
  local mapdef, cotol, coiter, codiff, codptol, comethod, cowarn in self
  assertf(is_positive(cotol ), "invalid cotol %.15g (positive number expected)" , cotol )
  assertf(is_positive(coiter), "invalid coiter %d (positive number expected)"   , coiter)
  assertf(is_positive(codiff), "invalid codiff %.15g (positive number expected)", codiff)
  assertf(is_positive(codptol),"invalid codptol %.15g (positive number expected)",codptol)
  assertf(   method[comethod], "invalid comethod '%s' (unsupported method)"     ,comethod)
  assert (is_boolean(cowarn) , "invalid cowarn (boolean expected)")

  -- prepare the track template
  local trck0 = track 'cotrack' {

    -- forwarded options
    beam      = self.beam,
    sequence  = self.sequence,
    range     = self.range,
    dir       = self.dir,

    s0        = self.s0,
    X0        = self.X0,
    R0        = self.R0,
    beta0     = self.beta0,
    deltap    = self.deltap,

    mapdef    = is_true(mapdef) and {xy=1} or mapdef,
    mapsave   = self.mapsave,
    mapdump   = self.mapdump,

    nturn     = self.nturn,
    nstep     = self.nstep,
    npart     = self.npart,
    nslice    = self.nslice,
    model     = self.model,
    method    = self.method,
    totalpath = self.totalpath,
    radiate   = self.radiate,
    misalign  = self.misalign,

    save      = self.save,
    title     = self.title,
    savesel   = self:var_raw 'savesel', -- prevent evaluation
    implicit  = self.implicit,
    relative  = self.relative,
    observe   = self.observe,

    atentry   = self:var_raw 'atentry', -- prevent evaluation
    atslice   = self:var_raw 'atslice',
    atexit    = self:var_raw 'atexit',
    ataper    = self:var_raw 'ataper',
    atsave    = self:var_raw 'atsave',

    usrdef    = self.usrdef, -- user defined data

    -- overridden options
    exec      = false, -- setup only, do not run
  }

  -- search closed orbit using Newton algorithm
  if mapdef
  then return cofind_map  (self, trck0) -- use damap
  else return cofind_jacob(self, trck0) -- use jacobian
  end
end

local _na, _nyi -- not applicable, not yet implemented

local cofind = command 'cofind' {
  -- attributes (not required) set to nil will use the default from track
  beam=nil,          -- beam (required or sequence.beam)                  (trck)
  sequence=nil,      -- sequence (required)                               (trck)
  range=nil,         -- range of tracking                                 (trck)
  dir=nil,           -- s-direction of tracking (1 or -1)                 (trck)

  s0=nil,            -- initial s                                         (trck)
  X0=nil,            -- initial X coordinates for orbit search            (trck)
  R0=nil,            -- initial R matrix (compagnion of X0 for damap)     (trck)
  beta0=nil,         -- initial beta0 block to build uncoupled R0         (trck)
  deltap=nil,        -- initial deltap                                    (trck)

  mapdef=nil,        -- setup for damap (true => {xy=1})                  (trck)
  mapsave=nil,       -- never save data                                   (trck)
  mapdump=nil,       -- dump X and R after each element                   (trck)

  nturn=nil,         -- number of turns                                   (trck)
  nstep=nil,         -- number of elements to track                       (trck)
  npart=nil,         -- number of particles (or #X0)                      (trck)
  nslice=nil,        -- number of slice for each element                  (trck)
  implicit=nil,      -- slice implicit elements too                       (trck)
  model=nil,         -- model for integration                             (trck)
  method=nil,        -- method or order for integration                   (trck)
  totalpath=nil,     -- 't' is the totalpath                              (trck)
  radiate=_nyi,      -- radiate at slices                                 (trck)
  misalign=nil,      -- 0 none, 1 main, 2 +error                          (trck)

  save=false,        -- create mtable and save results                    (mtbl)
  title=nil,         -- title of mtable (default seq.name)                (mtbl)
  savesel=nil,       -- save selector                                     (mtbl)
  relative=nil,      -- save length of slices instead from element start  (mtbl)
  observe=nil,       -- save only in observed elements (every n turns)    (mtbl)

  atentry=nil,       -- action called when entering an element            (trck)
  atslice=nil,       -- action called after each element slices           (trck)
  atexit=nil,        -- action called when exiting an element             (trck)
  ataper=nil,        -- action called after checking for aperture         (trck)
  atsave=nil,        -- action called after saving in mtable              (trck)

  usrdef=nil,        -- user defined data attached to the mflow           (trck)

  cotol=1e-8,        -- closed orbit tolerance                            (cofn)
  coiter=20,         -- maximum number of iteration                       (cofn)
  codiff=1e-10,      -- finite differences step for jacobian              (cofn)
  codptol=1e-12,     -- 4D vs 6D dp tolerance                             (cofn)
  comethod='newton', -- default optimizer                                 (cofn)
  cowarn=false,      -- commute errors into warnings                      (cofn)
  X1={0,0,0,0,0,0},  -- optional final coordinates translation            (cofn)

  mflow=nil,         -- mflow, exclusive with other attributes except nstep
  exec=exec,         -- command to execute upon children creation
} :set_readonly()    -- reference cofind command is readonly

-- end ------------------------------------------------------------------------o
return { cofind = cofind }
