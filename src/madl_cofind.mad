--[=[
 o-----------------------------------------------------------------------------o
 |
 | Closed Orbit module
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: I. Shreyber, irina.tecker at cern.ch
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - TODO

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local warn, vector, matrix, command, track        in MAD
local is_positive                                 in MAD.typeid
local errorf, assertf, tblcpy                     in MAD.utility
local abs                                         in math

local vnam = {'x', 'px', 'y', 'py', 't', 'pt'}

local I  = matrix(6):eye()
local I4 = matrix(4):eye()

-- helpers --------------------------------------------------------------------o

local function has_dp (R, dptol)
  local nr, nc = R:sizes()
  assert(nr == 6 and nc == 6, "invalid one-turn map (6D matrix expected)")

  local nodp = abs(R:get(6,6) - 1) <= dptol

  for i=1,5 do
    nodp = nodp and abs(R:get(6,i)) <= dptol
  end

  return not nodp
end

-- cofind using jacobian ------------------------------------------------------o

local function cofind_jacob (self, mflw)
  error("NYI")
  local cotol, coiter, codiff in self

  local nvar = #mflw[1]
  local B, X = vector(nvar), vector(nvar)
  local A, I = matrix(nvar), matrix(nvar):eye()

  -- track nvar+1 particles to compute jacobian
  mflw.npar = 1+nvar
  for v=1,nvar do
    mflw[1+v] = tblcpy(mflw[1])
    mflw[1+v][vnam[v] or v] = mflw[1+v][vnam[v] or v] + codiff
    end

  for iter=1,coiter do
    track { mflow=mflw }

    -- retrieve orbit and one-turn map
    for r=1,nvar do
      B:seti(r, mflw[1][vnam[r] or r])
      for v=1,nvar do
        A:set(r,v, (mflw[1+r][vnam[v] or v] - B[v])/codiff)
      end
    end

    local dp = has_dp(A)

    A:sub(I, A)
    B:sub(X, B)

    local X1, rnk = A:solve(B)

    if rnk < nvar then
      warn("singular matrix occurred during closed orbit search.")
    end

    X:sub(X1,X)

    print('iter=', iter)
    A:print('A')
    B:print('B')
    X:print('X')

    if (dp and B:maxabs() or B:getv(1..4):maxabs()) < cotol then
      return X
    end

    for v=1,nvar do
      mflw[1][vnam[v] or v] = X[v]
    end
    for v=1,nvar do
      tblcpy(mflw[1], mflw[1+v])
      mflw[1+v][vnam[v] or v] = mflw[1+v][vnam[v] or v] + codiff
    end
  end

  errorf("closed orbit did not converge in %d iterations", coiter)
end

-- cofind using map -----------------------------------------------------------o

local function cofind_map (self, track)
  local X0, cotol, coiter, codptol in self

  -- build 6D initial orbit
  X0 = vector(6):fill(X0)

  -- search for fix point
  for iter=1,coiter do                                      --X0:print('X0',eps)

    -- track 6D map
    local _, mflw = track { X0=X0 }

    -- retrieve 6D orbit and one-turn map
    local X = mflw[1]:get0()                                   --:print('X',eps)
    local R = mflw[1]:get1()                                   --:print('R',eps)
    local dX, rnk

    if has_dp(R, codptol) then -- 6D case
      dX, rnk = (R-I):solve(X-X0)

      if rnk < 6 then
        warn("singular matrix occurred during 6D closed orbit search.")
        return nil, rnk
      end

      -- adjust orbit
      X0:sub(dX,X0)

    else -- 4D case
      X = X:getrow(1..4) - X0:getrow(1..4)
      R = R:getsub(1..4, 1..4) - I4

      dX, rnk = R:solve(X)

      if rnk < 4 then
        warn("singular matrix occurred during 4D closed orbit search.")
        return nil, rnk
      end

      -- adjust orbit
      X = X0:getrow(1..4) - dX
      X0:zeros():copy(X)
    end

    -- return if correction is below tolerance
    if dX:maxabs() < cotol then
      return X0, iter
    end
  end

  errorf("closed orbit did not converge in %d iterations", coiter)
end

-- cofind command -------------------------------------------------------------o

local function exec (self)
  local usemap, cotol, coiter, codiff in self
  assertf(is_positive(cotol ), "invalid cotol %.15g (positive number expected)" , cotol )
  assertf(is_positive(coiter), "invalid coiter %d (positive number expected)"   , coiter)
  assertf(is_positive(codiff), "invalid codiff %.15g (positive number expected)", codiff)

  -- prepare the track template
  local trck0 = track 'cofind' {

    -- forwarded options
    beam      = self.beam,
    sequence  = self.sequence,
    range     = self.range,
    sdir      = self.sdir,

    s0        = self.s0,
    X0        = self.X0,

    mapdef    = self.usemap and {xy=1} or nil,
    nturn     = self.nturn,
    nslice    = self.nslice,
    method    = self.method,

    -- overridden options
    save      = false,
    exec      = false,
  }

  -- search closed orbit using Newton algorithm
  if usemap
  then return cofind_map   (self, trck0) -- use one-turn map
  else return cofind_jacob (self, trck0) -- use computed jacobian
  end
end

local cofind = command 'COFind' {
  beam=nil,         -- beam (required)                                    (trck)
  sequence=nil,     -- sequence (required)                                (trck)
  range=nil,        -- range of tracking                                  (trck)
  sdir=1,           -- s-direction of tracking (1 or -1)                  (trck)

  s0=0,             -- initial s                                          (trck)
  X0={0,0,0,0,0,0}, -- initial coordinates for orbit search               (trck)

  usemap=true,      -- use DA to compute the jacobian                     (cofn)

  nturn=1,          -- number of turns                                    (trck)
  nslice=1,         -- number of slice for each element                   (trck)
  method='simple',  -- default integrator                                 (trck)

  cotol=1e-8,       -- closed orbit tolerance                             (cofn)
  coiter=20,        -- maximum number of iteration                        (cofn)
  codiff=1e-10,     -- finite differences steps                           (cofn)
  codptol=1e-12,    -- static vs dynamic tolerance                        (cofn)

  exec=exec,      -- command to execute upon children creation
} :set_readonly() -- reference cofind command is readonly

-- end ------------------------------------------------------------------------o
return { cofind = cofind }
