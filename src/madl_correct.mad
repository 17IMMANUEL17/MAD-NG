--[=[
 o-----------------------------------------------------------------------------o
 |
 | Orbit Correction module
 |
 | Methodical Accelerator Design - Copyright (c) 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - TODO

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

-- to check!
local warn, option, vector, matrix, command, element            in MAD
local bind1st                                                   in MAD.gfunc
local has_dpt, vname, msort                                     in MAD.gphys
local rep, assertf, printf                                      in MAD.utility
local eps                                                       in MAD.constant
local is_number, is_positive, is_boolean, is_true, is_iterable,
      is_mappable, is_mtable, is_sequence                       in MAD.typeid
local enabled                                                   in element.flags

local abs, min, max in math

local assert, error, getmetatable, setmetatable, table =
      assert, error, getmetatable, setmetatable, table

-- MAD-X EALIGN slots in p_node->p_al_err->a
-- {"dx","dy","ds","dphi","dtheta","dpsi","mrex","mrey","mredx","mredy","arex","arey","mscalx","mscaly"}
--   0    1    2    3      4        5      6      7      8       9       10     11     12       13

-- planes ---------------------------------------------------------------------o

local planes = { x = {'x'}, y = {'y'}, xy = {'x', 'y'} }

-- reference orbit ------------------------------------------------------------o

local target0 = {{ x=rep(0), px=rep(0), y=rep(0), py=rep(0) },
                 { x=rep(0), px=rep(0), y=rep(0), py=rep(0) }}

-- response matrix ------------------------------------------------------------o

-- TODO: add dispersion correction

local aij_fct = {
  line = function (beti, betj, phai, phaj)
    return phai < phaj and sqrt(beti*betj) * sin(abs(phai-phaj)) or 0
  end,

  ring = function (beti, betj, phai, phaj, Q)
    return sqrt(beti*betj) * cos(abs(phai-phaj) - pi*Q) / (2*sin(pi*Q))
  end,
}

-- correct command ------------------------------------------------------------o

local function exec (self)
  local model, orbit, target, kind, plane in self
  local sequ = self.sequence
  local E = element

  if is_sequence(sequ) then sequ, range = {sequ}, {range} end
  if is_mtable(model)  then model  = {model}  end
  orbit, target = orbit or model, target or target0
  if is_mtable(orbit)  then orbit  = {orbit}  end
  if is_mtable(target) then target = {target} end

  local grp = { nseq=#sequ, nxcor=0, nxmon=0, nycor=0, nymon=0 }

  for k=1,grp.nseq do -- loop over sequences
    assert(is_sequence(sequ [k]), "invalid sequence (sequence expected)")
    assert(is_mtable  (model[k]) and model[k].type == 'twiss',
                                  "invalid model mtable (twiss mtable expected)")
    assert(is_mtable  (orbit[k]), "invalid orbit mtable (mtable expected)")

    grp[k] = { seq=sequ[k], rng=range[k], tbl=model[k],
               xmon={n=0}, xcor={n=0}, xshr={n=0},
               ymon={n=0}, ycor={n=0}, yshr={n=0} }

    local seq, rng, tbl, xmon, ymon, xcor, ycor in grp[k]

    -- collect enabled correctors and monitors of beamline(s)
    for i, e in seq:iter(rng) do
      if e:test_flag(enabled) then
        local knd = e.kind
        if E[knd].is_kicker or E[knd].is_monitor then
              if kind == 'hmonitor' then
            xmon[xmon.n+1], xmon.n = i, xmon.n+1
          elseif kind == 'vmonitor' then
            ymon[ymon.n+1], ymon.n = i, ymon.n+1
          elseif kind == 'hkicker' or kind == 'kicker' then
            xcor[xcor.n+1], xcor.n = i, xcor.n+1
          elseif kind == 'vkicker' or kind == 'kicker' then
            ycor[ycor.n+1], ycor.n = i, ycor.n+1
          end
      end
    end

    grp.nxmon = grp.nxmon + xmon.n
    grp.nymon = grp.nymon + ymon.n
    grp.nxcor = grp.nxcor + xcor.n
    grp.nycor = grp.nycor + ycor.n

    -- find shared correctors between consecutive beamlines (if any)
    if k > 1 then
      local pseq = grp[k-1].seq

      if plane == 'x' or plane == 'xy' then
        local pshr = grp[k-1].xshr
        for i=1,xcor.n do
          local nam = seq[xcor[i]].name
          local j = pseq:index_of(nam)
          if j then
            asserf(not pshr[j], "shared corrector %s appears multiple times", nam)
            pshr[j], pshr.n = xcor[i], pshr.n+1
          end
        end
        grp.nxcor = grp.nxcor - pshr.n
      end

      if plane == 'y' or plane == 'xy' then
        local pshr = grp[k-1].yshr
        for i=1,ycor.n do
          local nam = seq[ycor[i]].name
          local j = pseq:index_of(nam)
          if j then
            asserf(not pshr[j], "shared corrector %s appears multiple times", nam)
            pshr[j], pshr.n = ycor[i], pshr.n+1
          end
        end
        grp.nycor = grp.nycor - pshr.n
      end
    end -- shared sequences
  end -- loop over sequences

  -- build matrix for each plane
  for i,p in ipairs(planes[plane]) do
    local A = matrix()
    -- TODO
  end

  -- for each planes:
  --   build response matrix for ring or line for one or two tables
  --   solve the least squared minimum.
  --   reassign the strength to the kickers in the sequences (if provided)
  -- return the table of strengths and readings for planes
end

local correct = command 'correct' {
  sequence=nil,      -- sequence(s) (required)                            (corr)
  range=nil,         -- sequence(s) range(s)                              (corr)

  model=nil,         -- mtable(s) with twiss functions (required)         (corr)
  orbit=nil,         -- mtable(s) with measured orbit(s), or use model    (corr)
  target=nil,        -- mtable(s) with target orbit(s), or zero orbit     (corr)

  kind='ring',       -- 'line' or 'ring'                                  (corr)
  plane='xy',        -- 'x', 'y' or 'xy'                                  (corr)
  method='micado',   -- 'LSQ', 'SVD' or 'MICADO'                          (corr)
  tol=1e-5,          -- rms tolerance on the orbit                        (corr)

  cond=nil,          -- nil, 'svdcnd' or 'pcacnd'                         (corr)
  ncorr=0,           -- number of correctors to consider by MICADO, 0=all (corr)
  scut=0,            -- value to theshold singular values in precond      (corr)
  stol=0,            -- value to theshold correctors in svdcnd            (corr)
  cadd=0,            -- 0=set/1=add correction strength to sequ. kickers  (corr)
  monon=1,           -- fraction (0<?<=1) of randomly available monitors  (corr)
  monseed=nil,       -- random seed for monon selection                   (corr)
  monerror=0,        -- 1: use mrex and mrey alignment errors of monitors (corr)
                     -- 2: add msex and msey scaling errors of monitors   (corr)

  exec=exec,         -- command to execute upon children creation

  __attr = {
    'model', 'orbit', 'target', 'range', 'sequence',
    'kind', 'plane', 'method', 'tol', 'units',
    'cond', 'ncorr', 'scut', 'stol', 'cadd', 'monon', 'monseed', 'monerror', }
} :set_readonly()    -- reference correct command is readonly

-- end ------------------------------------------------------------------------o
return { correct = correct }
