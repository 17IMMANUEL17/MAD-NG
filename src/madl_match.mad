--[=[
 o-----------------------------------------------------------------------------o
 |
 | Match module
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - TODO

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local ffi = require 'ffi'

local _C, command, vector in MAD

-- types ----------------------------------------------------------------------o

ffi.cdef [[
// NLopt supported algorithms (see nlopt.h)
// see https://nlopt.readthedocs.io/en/latest/NLopt_Algorithms/ for details

enum {
/* Naming conventions:
  NLOPT_{G/L}{D/N}_* = global/local derivative/no-derivative optimization
  *_RAND algorithms involve some randomization.
  *_NOSCAL algorithms are *not* scaled to a unit hypercube
           (i.e. they are sensitive to the units of x)
*/
  NLOPT_GN_DIRECT = 0,
  NLOPT_GN_DIRECT_L,
  NLOPT_GN_DIRECT_L_RAND,
  NLOPT_GN_DIRECT_NOSCAL,
  NLOPT_GN_DIRECT_L_NOSCAL,
  NLOPT_GN_DIRECT_L_RAND_NOSCAL,

  NLOPT_GN_ORIG_DIRECT,
  NLOPT_GN_ORIG_DIRECT_L,

  NLOPT_GD_STOGO,
  NLOPT_GD_STOGO_RAND,

  NLOPT_LD_LBFGS_NOCEDAL,

  NLOPT_LD_LBFGS,

  NLOPT_LN_PRAXIS,

  NLOPT_LD_VAR1,
  NLOPT_LD_VAR2,

  NLOPT_LD_TNEWTON,
  NLOPT_LD_TNEWTON_RESTART,
  NLOPT_LD_TNEWTON_PRECOND,
  NLOPT_LD_TNEWTON_PRECOND_RESTART,

  NLOPT_GN_CRS2_LM,

  NLOPT_GN_MLSL,
  NLOPT_GD_MLSL,
  NLOPT_GN_MLSL_LDS,
  NLOPT_GD_MLSL_LDS,

  NLOPT_LD_MMA,

  NLOPT_LN_COBYLA,

  NLOPT_LN_NEWUOA,
  NLOPT_LN_NEWUOA_BOUND,

  NLOPT_LN_NELDERMEAD,
  NLOPT_LN_SBPLX,

  NLOPT_LN_AUGLAG,
  NLOPT_LD_AUGLAG,
  NLOPT_LN_AUGLAG_EQ,
  NLOPT_LD_AUGLAG_EQ,

  NLOPT_LN_BOBYQA,

  NLOPT_GN_ISRES,

/* new variants that require local_optimizer to be set */
  NLOPT_AUGLAG,
  NLOPT_AUGLAG_EQ,
  NLOPT_G_MLSL,
  NLOPT_G_MLSL_LDS,

  NLOPT_LD_SLSQP,

  NLOPT_LD_CCSAQ,

  NLOPT_GN_ESCH,

  NLOPT_NUM_ALGORITHMS /* not an algorithm, just the number of them */
};
]]

ffi.cdef[[
// NLopt return codes (see nlopt.h)

enum {
  NLOPT_FAILURE = -1, /* generic failure code */
  NLOPT_INVALID_ARGS = -2,
  NLOPT_OUT_OF_MEMORY = -3,
  NLOPT_ROUNDOFF_LIMITED = -4,
  NLOPT_FORCED_STOP = -5,

  NLOPT_SUCCESS = 1, /* generic success code */
  NLOPT_STOPVAL_REACHED = 2,
  NLOPT_FTOL_REACHED = 3,
  NLOPT_XTOL_REACHED = 4,
  NLOPT_MAXEVAL_REACHED = 5,
  NLOPT_MAXTIME_REACHED = 6
};
]]

ffi.cdef[[
// NLopt MAD C interface (see mad_nlopt.h)

typedef num_t (objective_t) (u32_t n, const num_t *x, num_t *grad, void *data);
typedef void  (constraint_t)(u32_t m, num_t *res,
                             u32_t n, const num_t* x, num_t* grad, void* data);

struct nlopt_args {
  // algorithm
  int             algorithm;

  // variables [n] (required)
  num_t          *x;
  const num_t    *xtol_rel;
  const num_t    *xtol_abs;
  const num_t    *xstep;

  // objective function [n] (required)
  ssz_t           n;
  objective_t    *f;
  void           *fdat;
  const num_t    *ftol_rel;
  const num_t    *ftol_abs;

  // equality constraints [p] (optional)
  ssz_t           p;
  constraint_t   *c_eq;
  void           *cdat_eq;
  const num_t    *ctol_eq;

  // inequality constraints [q] (optional)
  ssz_t           q;
  constraint_t   *c_le;
  void           *cdat_le;
  const num_t    *ctol_le;

  // bounds constraint [n] (optional)
  const num_t    *xmin;
  const num_t    *xmax;

  // stop criteria
  const int      *maxcall;
  const num_t    *maxtime;

  // returned values
  num_t           fmin;
  int             status;
};
]]

-- callback example -----------------------------------------------------------o

--[=[
local sqrt, huge in math

local my_count, my_ccount = 0, 0

local function my_objective(n, x, grad, data)
  assert(n == 2)

  my_count = my_count + 1

  if grad then
    grad[0] = 0
    grad[1] = 1 / ( 2*sqrt(x[1]) )
  end

  return sqrt(x[1])
end

local function my_contraints(m, res, n, x, grad, data)
  assert(m == 2 and n == 2)

  my_ccount = my_ccount + 1

  if grad then
    local a, b = 2, 0
    grad[0] = 3 * a * (a*x[0] + b) * (a*x[0] + b);
    grad[1] = -1.0;

    local a, b = -1, 1
    grad[2] = 3 * a * (a*x[0] + b) * (a*x[0] + b);
    grad[3] = -1.0;
  end

  local a, b = 2, 0
  res[0] = ((a*x[0] + b) * (a*x[0] + b) * (a*x[0] + b) - x[1])

  local a, b = -1, 1
  res[1] = ((a*x[0] + b) * (a*x[0] + b) * (a*x[0] + b) - x[1])
end

local printf in MAD.utility

local function exec (self)
  local f    = ffi.cast('objective_t*' , my_objective )
  local c    = ffi.cast('constraint_t*', my_contraints)
  local x    = vector{1.234, 5.678}
  local xmin = vector{-huge, 0}
  local xtol = vector{1e-4, 1e-4}
  local ctol = vector{1e-8, 1e-8}

  local arg = ffi.new 'nlopt_args_t[1]'

  arg[0].algorithm = _C.NLOPT_LD_MMA

  arg[0].x         = x.data
  arg[0].xmin      = xmin.data
  arg[0].xtol_rel  = xtol.data

  arg[0].n         = 2
  arg[0].f         = f

  arg[0].q         = 2
  arg[0].c_le      = c
  arg[0].ctol_le   = ctol.data

  _C.mad_nlopt(arg)

  printf('solution (%d, %d): (%g,%g), f=%g, status=%d\n',
      my_count, my_ccount, arg[0].x[0], arg[0].x[1], arg[0].fmin, arg[0].status)

  f:free()
  c:free()
end
--]=]

-- FODO example ---------------------------------------------------------------o

local beam, sequence              in MAD
local marker, drift, thin_element in MAD.element

local k1_qf =  0.5 --  0.3037241107
local k1_qd = -0.5 -- -0.3037241107

local function thinFODO ()
  local nsl = 1 -- 10 -- for madx row by row compatibility
  local nth = 10
  local dl  = 1/nth
  local mk1 = marker       'mk1' {}
  local mk2 = marker       'mk2' {}
  local df1 = drift        'df1' { l=4, nslice=nsl }
  local df2 = drift        'df2' { l=4, nslice=nsl }
  local mq1 = thin_element 'mq1' { knl := {0, k1_qf/nth} }
  local mq2 = thin_element 'mq2' { knl := {0, k1_qd/nth} }
  local seq = sequence     'seq' { l=10, refer='entry', -- dir=-1,
                mq1 {at=0+dl/2              },
      (nth/2-1)*mq1 {at=dl    , from='prev' },
                mk1 {at=0+dl/2, from='prev' },
                mq1 {at=0+dl/2, from='prev' },
      (nth/2-1)*mq1 {at=dl    , from='prev' },
--                df1 {at=1}, -- for madx row by row compatibility

                mq2 {at=5+dl/2              },
      (nth/2-1)*mq2 {at=dl    , from='prev' },
                mk2 {at=0+dl/2, from='prev' },
                mq2 {at=0+dl/2, from='prev' },
      (nth/2-1)*mq2 {at=dl    , from='prev' },
--                df2 {at=6}, -- for madx row by row compatibility
  }
  seq.beam = beam

--  seq:dumpseq()

  return seq
end

-----

local twiss      in MAD
local printf     in MAD.utility
local sqrt, huge in math

local my_count, my_ccount = 0, 0

local fodo = thinFODO()
local mtbl

local function my_objective(n, x, grad, data)
  k1_qf, k1_qd = x[0], x[1]

  my_count = my_count + 1

  print(k1_qf, k1_qd)

  mtbl = twiss { sequence=fodo, observe=true }
  print('mu1=', mtbl[-1].mu1, 'mu2=', mtbl[-1].mu2)
  mtbl:write('match.out')

  if grad then
    grad[0], grad[1] = 1, 1
  end

  local err = sqrt( (mtbl[-1].mu1 - 0.25)^2 + (mtbl[-1].mu2 - 0.25)^2 )

  print('err=', err)
  return err
end

-- match command --------------------------------------------------------------o

local function exec (self)
  -- TODO!!!

  local f    = ffi.cast('objective_t*' , my_objective)
--  local c    = ffi.cast('constraint_t*', my_contraints)
  local x    = vector{k1_qf, k1_qd}
  local xmin = vector{0, -huge}
  local xmax = vector{huge,  0}
  local xtol = vector{1e-4, 1e-4}
--  local ctol = vector{1e-8, 1e-8}

  local arg = ffi.new 'nlopt_args_t[1]'
  local num = ffi.new 'num_t[1]'
  num[0] = 1e-4

  arg[0].algorithm = _C.NLOPT_GD_STOGO -- NLOPT_GN_DIRECT -- _C.NLOPT_LD_MMA

  arg[0].x         = x.data
  arg[0].xmin      = xmin.data
  arg[0].xmax      = xmax.data
  arg[0].xtol_rel  = xtol.data

  arg[0].n         = 2
  arg[0].f         = f
  arg[0].ftol_rel  = num

--  arg[0].q         = 2
--  arg[0].c_le      = c
--  arg[0].ctol_le   = ctol.data

  _C.mad_nlopt(arg)

  print('status=', arg[0].status)

  printf('solution (%d): (%g,%g), f=%g\n',
         my_count, arg[0].x[0], arg[0].x[1], arg[0].fmin)

  my_count = 0
  f:free()
--  c:free()
end

local match = command 'match' {
  -- TODO!!!

  exec=exec,      -- command to execute upon children creation
} :set_readonly() -- reference match command is readonly

-- end ------------------------------------------------------------------------o
return { match = match }
