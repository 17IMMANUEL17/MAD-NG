--[=[
 o-----------------------------------------------------------------------------o
 |
 | Match module
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - TODO

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local ffi = require 'ffi'

local _C, command, vector, warn                                  in MAD
local fnone                                                      in MAD.gfunc
local assertf, errorf, printf, strsplit                          in MAD.utility
local is_nil, is_string, is_iterable, is_mappable, is_callable   in MAD.typeid
local eps, inf                                                   in MAD.constant

local strfmt = string.format

-- types ----------------------------------------------------------------------o

ffi.cdef [[
// NLopt supported algorithms (see nlopt.h)
// see https://nlopt.readthedocs.io/en/latest/NLopt_Algorithms/ for details

enum {
/* Naming conventions:
  NLOPT_{G/L}{D/N}_* = global/local derivative/no-derivative optimization
  *_RAND algorithms involve some randomization.
  *_NOSCAL algorithms are *not* scaled to a unit hypercube
           (i.e. they are sensitive to the units of x)
*/
  NLOPT_GN_DIRECT = 0,
  NLOPT_GN_DIRECT_L,
  NLOPT_GN_DIRECT_L_RAND,
  NLOPT_GN_DIRECT_NOSCAL,
  NLOPT_GN_DIRECT_L_NOSCAL,
  NLOPT_GN_DIRECT_L_RAND_NOSCAL,

  NLOPT_GN_ORIG_DIRECT,
  NLOPT_GN_ORIG_DIRECT_L,

  NLOPT_GD_STOGO,
  NLOPT_GD_STOGO_RAND,

  NLOPT_LD_LBFGS_NOCEDAL,

  NLOPT_LD_LBFGS,

  NLOPT_LN_PRAXIS,

  NLOPT_LD_VAR1,
  NLOPT_LD_VAR2,

  NLOPT_LD_TNEWTON,
  NLOPT_LD_TNEWTON_RESTART,
  NLOPT_LD_TNEWTON_PRECOND,
  NLOPT_LD_TNEWTON_PRECOND_RESTART,

  NLOPT_GN_CRS2_LM,

  NLOPT_GN_MLSL,
  NLOPT_GD_MLSL,
  NLOPT_GN_MLSL_LDS,
  NLOPT_GD_MLSL_LDS,

  NLOPT_LD_MMA,

  NLOPT_LN_COBYLA,

  NLOPT_LN_NEWUOA,
  NLOPT_LN_NEWUOA_BOUND,

  NLOPT_LN_NELDERMEAD,
  NLOPT_LN_SBPLX,

  NLOPT_LN_AUGLAG,
  NLOPT_LD_AUGLAG,
  NLOPT_LN_AUGLAG_EQ,
  NLOPT_LD_AUGLAG_EQ,

  NLOPT_LN_BOBYQA,

  NLOPT_GN_ISRES,

/* new variants that require local_optimizer to be set */
  NLOPT_AUGLAG,
  NLOPT_AUGLAG_EQ,
  NLOPT_G_MLSL,
  NLOPT_G_MLSL_LDS,

  NLOPT_LD_SLSQP,

  NLOPT_LD_CCSAQ,

  NLOPT_GN_ESCH,

  NLOPT_NUM_ALGORITHMS /* not an algorithm, just the number of them */
};
]]

ffi.cdef[[
// NLopt return codes (see nlopt.h)

enum {
  NLOPT_FAILURE = -1, /* generic failure code */
  NLOPT_INVALID_ARGS = -2,
  NLOPT_OUT_OF_MEMORY = -3,
  NLOPT_ROUNDOFF_LIMITED = -4,
  NLOPT_FORCED_STOP = -5,

  NLOPT_SUCCESS = 1, /* generic success code */
  NLOPT_STOPVAL_REACHED = 2,
  NLOPT_FTOL_REACHED = 3,
  NLOPT_XTOL_REACHED = 4,
  NLOPT_MAXEVAL_REACHED = 5,
  NLOPT_MAXTIME_REACHED = 6
};
]]

ffi.cdef[[
// NLopt MAD C interface (see mad_nlopt.h)

typedef num_t (nlopt_obj_t)(u32_t n, const num_t *x, num_t *grad, void *data);
typedef void  (nlopt_cts_t)(u32_t m, num_t *res,
                            u32_t n, const num_t* x, num_t* grad, void* data);

struct nlopt_args {
  // algorithm
  int            algo;

  // objective function (required)
  nlopt_obj_t   *fn;
  int            fdir; // 1: maximize, -1: minimize (default)
  num_t          ftol;
  num_t          fstop;

  // state variables [n] (required)
  ssz_t          n;
  num_t         *x;
  const num_t   *xstp;
  const num_t   *xtol;
  num_t          rtol;

  // bound constraints [n] (optional)
  const num_t   *xmin;
  const num_t   *xmax;

  // equality constraints [p] (optional)
  ssz_t          p;
  nlopt_cts_t   *eq;
  const num_t   *etol;

  // inequality constraints [q] (optional)
  ssz_t          q;
  nlopt_cts_t   *le;
  const num_t   *ltol;

  // stop criteria (if >0)
  int            maxcall;
  num_t          maxtime;

  // returned values
  int            status;
  int            ncall;
  num_t          fval;
};
]]

--[[
NLopt algorithm specs
  bd = support bounds constraints (f = require finite bounds)
  eq = support equality constraints (result == 0)
  le = support inequality constraints (result <= 0)
  lo = require local optimiser specification
  gr = require explicit computation of gradient
  lg = require augmented lagrangian
]]
local nlopt_algo = {
  -- global optimisers without derivatives
  NLOPT_GN_CRS2_LM                 = { bd='y', eq='n', le='n', lo='n', gr='n' },
  NLOPT_GN_DIRECT                  = { bd='f', eq='n', le='n', lo='n', gr='n' },
  NLOPT_GN_DIRECT_L                = { bd='f', eq='n', le='n', lo='n', gr='n' },
  NLOPT_GN_DIRECT_L_NOSCAL         = { bd='f', eq='n', le='n', lo='n', gr='n' },
  NLOPT_GN_DIRECT_L_RAND           = { bd='f', eq='n', le='n', lo='n', gr='n' },
  NLOPT_GN_DIRECT_L_RAND_NOSCAL    = { bd='f', eq='n', le='n', lo='n', gr='n' },
  NLOPT_GN_DIRECT_NOSCAL           = { bd='f', eq='n', le='n', lo='n', gr='n' },
  NLOPT_GN_ESCH                    = { bd='y', eq='n', le='n', lo='n', gr='n' },
  NLOPT_GN_ISRES                   = { bd='y', eq='y', le='y', lo='n', gr='n' },
  NLOPT_GN_MLSL                    = { bd='y', eq='n', le='n', lo='y', gr='n' },
  NLOPT_GN_MLSL_LDS                = { bd='y', eq='n', le='n', lo='y', gr='n' },
  NLOPT_GN_ORIG_DIRECT             = { bd='f', eq='y', le='y', lo='n', gr='n' },
  NLOPT_GN_ORIG_DIRECT_L           = { bd='f', eq='y', le='y', lo='n', gr='n' },
  -- local optimisers without derivatives
  NLOPT_LN_AUGLAG                  = { bd=nil, eq=nil, le=nil, lo='n', gr='n' },
  NLOPT_LN_AUGLAG_EQ               = { bd=nil, eq=nil, le=nil, lo='n', gr='n' },
  NLOPT_LN_BOBYQA                  = { bd=nil, eq=nil, le=nil, lo='n', gr='n' },
  NLOPT_LN_COBYLA                  = { bd=nil, eq=nil, le=nil, lo='n', gr='n' },
  NLOPT_LN_NELDERMEAD              = { bd=nil, eq=nil, le=nil, lo='n', gr='n' },
  NLOPT_LN_NEWUOA                  = { bd=nil, eq=nil, le=nil, lo='n', gr='n' },
  NLOPT_LN_NEWUOA_BOUND            = { bd=nil, eq=nil, le=nil, lo='n', gr='n' },
  NLOPT_LN_PRAXIS                  = { bd=nil, eq=nil, le=nil, lo='n', gr='n' },
  NLOPT_LN_SBPLX                   = { bd=nil, eq=nil, le=nil, lo='n', gr='n' },
  -- global optimisers with derivatives (TODO)
  NLOPT_GD_MLSL                    = { bd=nil, eq=nil, le=nil, lo=nil, gr='y' },
  NLOPT_GD_MLSL_LDS                = { bd=nil, eq=nil, le=nil, lo=nil, gr='y' },
  NLOPT_GD_STOGO                   = { bd=nil, eq=nil, le=nil, lo=nil, gr='y' },
  NLOPT_GD_STOGO_RAND              = { bd=nil, eq=nil, le=nil, lo=nil, gr='y' },
  -- local optimisers with derivatives (TODO)
  NLOPT_LD_AUGLAG                  = { bd=nil, eq=nil, le=nil, lo='n', gr='y' },
  NLOPT_LD_AUGLAG_EQ               = { bd=nil, eq=nil, le=nil, lo='n', gr='y' },
  NLOPT_LD_CCSAQ                   = { bd=nil, eq=nil, le=nil, lo='n', gr='y' },
  NLOPT_LD_LBFGS                   = { bd=nil, eq=nil, le=nil, lo='n', gr='y' },
  NLOPT_LD_LBFGS_NOCEDAL           = { bd=nil, eq=nil, le=nil, lo='n', gr='y' },
  NLOPT_LD_MMA                     = { bd=nil, eq=nil, le=nil, lo='n', gr='y' },
  NLOPT_LD_SLSQP                   = { bd=nil, eq=nil, le=nil, lo='n', gr='y' },
  NLOPT_LD_TNEWTON                 = { bd=nil, eq=nil, le=nil, lo='n', gr='y' },
  NLOPT_LD_TNEWTON_PRECOND         = { bd=nil, eq=nil, le=nil, lo='n', gr='y' },
  NLOPT_LD_TNEWTON_PRECOND_RESTART = { bd=nil, eq=nil, le=nil, lo='n', gr='y' },
  NLOPT_LD_TNEWTON_RESTART         = { bd=nil, eq=nil, le=nil, lo='n', gr='y' },
  NLOPT_LD_VAR1                    = { bd=nil, eq=nil, le=nil, lo='n', gr='y' },
  NLOPT_LD_VAR2                    = { bd=nil, eq=nil, le=nil, lo='n', gr='y' },
  -- other cases (TODO)
  NLOPT_AUGLAG                     = { bd=nil, eq=nil, le=nil, lo=nil, gr='y' },
  NLOPT_AUGLAG_EQ                  = { bd=nil, eq=nil, le=nil, lo=nil, gr='y' },
  NLOPT_G_MLSL                     = { bd=nil, eq=nil, le=nil, lo=nil, gr='y' },
  NLOPT_G_MLSL_LDS                 = { bd=nil, eq=nil, le=nil, lo=nil, gr='y' },
}

-- NLopt return code strings
local retstr = {
  -- generic failure code
  [_C['NLOPT_FAILURE'         ]] = 'NLOPT_FAILURE',
  [_C['NLOPT_INVALID_ARGS'    ]] = 'NLOPT_INVALID_ARGS',
  [_C['NLOPT_OUT_OF_MEMORY'   ]] = 'NLOPT_OUT_OF_MEMORY',
  [_C['NLOPT_ROUNDOFF_LIMITED']] = 'NLOPT_ROUNDOFF_LIMITED',
  [_C['NLOPT_FORCED_STOP'     ]] = 'NLOPT_FORCED_STOP',
  -- generic success code
  [_C['NLOPT_SUCCESS'         ]] = 'NLOPT_SUCCESS',
  [_C['NLOPT_STOPVAL_REACHED' ]] = 'NLOPT_STOPVAL_REACHED',
  [_C['NLOPT_FTOL_REACHED'    ]] = 'NLOPT_FTOL_REACHED',
  [_C['NLOPT_XTOL_REACHED'    ]] = 'NLOPT_XTOL_REACHED',
  [_C['NLOPT_MAXEVAL_REACHED' ]] = 'NLOPT_MAXEVAL_REACHED',
  [_C['NLOPT_MAXTIME_REACHED' ]] = 'NLOPT_MAXTIME_REACHED',
}

-- variables default weights --------------------------------------------------o

local var_weights = { -- default weight = 1
  x  = 10, px  = 100, y  = 10, py  = 100, t = 10, pt = 100,
  dx = 10, dpx = 100, dy = 10, dpy = 100,

  q1  = 10, q2  = 10,
  mu1 = 10, mu2 = 10,
  alfa11 = 10, alfa22 = 10, alfa33 = 10,
}

--- callbacks -----------------------------------------------------------------o

local function nlopt_functions (env)
  local command, variables, objective, equalities, inequalities, weights in env

  assert(is_nil(objective.exec) or is_callable(objective.exec),
         "invalid objective (callable expected)")
  assert(is_nil(equalities.exec) or is_callable(equalities.exec),
         "invalid equality constraints (callable expected)")
  assert(is_nil(inequalities.exec) or is_callable(inequalities.exec),
         "invalid inequality constraints (callable expected)")

  local update in variables
  assert(is_nil(update) or is_callable(update),
         "invalid variables update (callable expected)")

  local n, p, q   in env.__arg[0]
  local x, eq, le in env.__res

  -- nlopt objective function
  return objective.exec or \n_, x_, grad, data =>
    -- printf("objective(%d)\n", env.__arg[0].ncall+1)
    if n_ ~= n then
      error("unexpected difference in number of variables")
    end
    if x_ == x.data then
      error("unexpected equality in variables pointers (useless copy?)")
    end
    if grad ~= nil then
      warn("unsupported request for jacobian in objective function (ignored)")
    end
    if data ~= nil then
      error("unexpected user data in objective function (corrupted callback?)")
    end

    local es, ws = 0, 0

    -- iteration number
    env.__arg[0].ncall = env.__arg[0].ncall + 1

    -- update state variables
    if update then
      for i=1,n do x[i]=x_[i-1] end
      update(x, env)
    else
      env.__res.flush = nil
      for i=1,n do variables[i].set(x_[i-1], env) end
      if env.__res.flush then jit.flush() end
    end

    -- call user command
    local res = command(env)

    -- collect equalities
    for i=1,p do
      local name, expr in equalities[i]
      local w = weights[name] or var_weights[name] or 1
      eq[i] = expr(res, env) or 0
      es = es + (w*eq[i])^2 ; ws = ws + w^2
    end

    -- collect inequalities
    for i=1,q do
      local name, expr in inequalities[i]
      local w = weights[name] or var_weights[name] or 1
      le[i] = expr(res, env) or 0
      if le[i] > 0 then
        es = es + (w*le[i])^2 ; ws = ws + w^2
      end
    end

    -- return weighted mean of squares 1/2 \sum_i (w_i f_i(x))^2 / \sum_i w_i^2
    return 0.5 * es / ws
  end,

  -- nlopt equality function
  equalities.exec or (p>0 and \p_, r =>
                                -- printf("equalities(%d)\n", env.__arg[0].ncall)
                                for i=1,p do r[i-1] = eq[i] end end
                          or nil),

  -- nlopt inequality function
  inequalities.exec or (q>0 and \q_, r =>
                                -- printf("inequalities(%d)\n", env.__arg[0].ncall)
                                for i=1,q do r[i-1] = le[i] end end
                            or nil)
end

-- getters/setters ------------------------------------------------------------o

local locfmt =
  "return \\f,res => local l = 2 \z
        return \\ => local info = debug.getinfo(l, 'f') \z
                     if not (info and info.func == f) then \z
                       l = nil \z
                       for i=2,1e6 do \z
                         info = debug.getinfo(i, 'f') \z
                         if not info then break end \z
                         if info.func == f then l=i ; break end \z
                       end ; assert(l, 'local variable not found') \z
                     end \z
                     local k, v = debug.getlocal(l, %d) \z
                     assert(k == '%s', 'invalid local variable getter') \z
                     return v end, \z
              \\x => local info = debug.getinfo(l, 'f') \z
                     if not (info and info.func == f) then \z
                       l = nil \z
                       for i=2,1e6 do \z
                         info = debug.getinfo(i, 'f') \z
                         if not info then break end \z
                         if info.func == f then l=i ; break end \z
                       end ; assert(l, 'local variable not found') \z
                     end \z
                     local k = debug.setlocal(l, %d, x) \z
                     assert(k == '%s', 'invalid local variable setter') \z
                     res.flush = true end end"
local upvfmt =
  "return \\f,res (\\ => local k, v = debug.getupvalue(f, %d) \z
                         assert(k == '%s', 'invalid upvalue getter') \z
                         return v end, \z
                  \\x => local k = debug.setupvalue(f, %d, x) \z
                         assert(k == '%s', 'invalid upvalue setter') \z
                         res.flush = true end)"

local function variables_accessor (variables, res)
  local loc, upv, ctx = {}, {}, getfenv(3)
  local fun = debug.getinfo(3, 'f').func
  local n = #variables

  assert(ctx and fun, "unexpected invalid stack level")

  for i=1,1e6 do -- scan local variables
    local k,v = debug.getlocal(3, i)
    if not k then break end
    loc[k], loc[i] = i, v -- override (required!)
  end
  for i=1,1e6 do -- scan non-local variables (upvalues)
    local k,v = debug.getupvalue(fun, i)
    if not k then break end
    upv[k], upv[i] = i, v -- cannot override
  end

  -- build variables getter/setter
  local wrn
  for i=1,n do
    local var = variables[i].var
    assertf(is_string(var), "invalid 'var' for variables %d (string expected)", i)
    local str, isep = strsplit(var, '.[')
    local fmt, get, set
    if loc[str] then
      if isep > 0 then -- local variable with indirection (safe, use obj)
        fmt = strfmt("return \\%s (\\ %s, \\__x => %s=__x end)", str, var, var)
        get, set = assert(loadstring(fmt))()(loc[loc[str]])
      else -- local variable with direct access (need stack level and jit flush!)
        if not (wrn or update or variables[i].set) then
          wrn = true -- jit.flush is a killer, ask for another method
          warn("update of local variables is very slow, use set/update/indirect")
        end
        fmt = strfmt(locfmt, loc[str], str, loc[str], str)
        get, set = assert(loadstring(fmt))()(fun, res)
      end
    elseif upv[str] then
      if isep > 0 then -- upvalue variable with indirection (safe, use obj)
        fmt = strfmt("return \\%s (\\ %s, \\__x => %s=__x end)", str, var, var)
        get, set = assert(loadstring(fmt))()(upv[upv[str]])
      else -- upvalue variable with direct access (safe, use fun)
        if not (wrn or update or variables[i].set) then
          wrn = true -- jit.flush is a killer, ask for another method
          warn("update of upvalues is very slow, use set/update/indirect")
        end
        fmt = strfmt(upvfmt, upv[str], str, upv[str], str)
        get, set = assert(loadstring(fmt))()(fun, res)
      end
    elseif not is_nil(ctx[str]) then -- caller environment (safe, use ctx)
      fmt = strfmt("return \\__ctx (\\ __ctx.%s, \\__x => __ctx.%s=__x end)", var, var)
      get, set = assert(loadstring(fmt))()(ctx)
    else
      errorf("unable to build getter and setter (variable '%s' not found)", var)
    end
    variables[i].get = variables[i].get or get
    variables[i].set = variables[i].set or set
    variables[i].ini = variables[i].ini or variables[i].get()
  end
end

-- match command --------------------------------------------------------------o

local function exec (self)
  local variables, objective, equalities, inequalities, weights in self
  local command = self:var_raw 'command' -- prevent evaluation

  -- check inputs
  assert(is_callable(command)     , "invalid match 'command' (callable expected)")
  assert(is_iterable(variables)   , "invalid match 'variables' (iterable expected)")
  assert(is_iterable(equalities)  , "invalid match 'equalities' (iterable expected)")
  assert(is_iterable(inequalities), "invalid match 'inequalities' (iterable expected)")
  assert(is_mappable(objective)   , "invalid match 'objective' (mappable expected)")
  assert(is_mappable(weights)     , "invalid match 'weights' (mappable expected)")

  -- check selected method
  local method = objective.method or 'NLOPT_GN_DIRECT_L'
  local mopt = nlopt_algo[method]
  assert(is_string(method), "invalid optimisation method (string expected)")
  assertf(_C[method] and mopt, "unkown optimisation method '%s'", method)
  if is_nil(objective.exec) then
    assertf(mopt.gr == 'n', "unsupported optimisation gradient method '%s'", method)
  end

  -- local sizes
  local n, p, q = #variables, #equalities, #inequalities

  -- check sizes compatiblity
  assert(n > 0, "invalid objective (variables expected)")

  -- matching environment
  local env = {
    command      = command,
    objective    = objective,
    variables    = variables,
    equalities   = equalities,
    inequalities = inequalities,
    weights      = weights,
    usrdef       = self.usrdef,

    -- hidden variables
    __res = { x  =         vector(n),
              eq = p>0 and vector(p) or nil,
              le = q>0 and vector(q) or nil},
    __arg = ffi.new 'nlopt_args_t[1]',
  }

  local arg, res = env.__arg, env.__res

  -- setup variables getter/setters
  if n > 0 and is_nil(objective.exec) and
              (is_nil(variables.init) or is_nil(variables.update)) then
    variables_accessor(variables, res)
  end

  -- problem sizes
  arg[0].n = n
  arg[0].p = p
  arg[0].q = q

  -- nlopt callbacks
  local fn, eq, le = nlopt_functions (env)
  if fn then fn = ffi.cast('nlopt_obj_t*', fn) end
  if eq then eq = ffi.cast('nlopt_cts_t*', eq) end
  if le then le = ffi.cast('nlopt_cts_t*', le) end

  if eq and mopt.eq == 'n' then eq:free() ; eq = nil end
  if le and mopt.le == 'n' then le:free() ; le = nil end

  -- algorithm id
  arg[0].algo = _C[method]

  -- objective function (required)
  arg[0].fn    = fn
  arg[0].fdir  = objective.kind == 'max' and 1 or -1
  arg[0].ftol  = objective.tol or 0
  arg[0].fstop = objective.stopval or arg[0].fdir*inf

  -- allocate and anchor vectors
  local x, xtol, xstp, xmin, xmax, etol, ltol

  x    = res.x     ; arg[0].x    = x.data
  xtol = vector(n) ; arg[0].xtol = xtol.data
  xstp = vector(n) ; arg[0].xstp = xstp.data
  xmin = vector(n) ; arg[0].xmin = mopt.bd ~= 'n' and xmin.data or nil
  xmax = vector(n) ; arg[0].xmax = mopt.bd ~= 'n' and xmax.data or nil

  -- state variables [n]
  local bd = mopt.bd ~= 'f' and inf or nil

  arg[0].rtol = variables.tol or 0
  for i=1,n do
    local v = variables[i]
    x   [i] = v.ini  or 0
    xtol[i] = v.tol  or 0
    xstp[i] = v.step or 1e-3
    xmin[i] = v.min  or -assert(bd, "invalid bound (finite value expected)")
    xmax[i] = v.max  or  assert(bd, "invalid bound (finite value expected)")
    if xmin[i] > xmax[i] then xmin[i], xmax[i] = xmax[i], xmin[i] end
  end

  -- equality constraints [p] (optional)
  if eq then
    etol = vector(p)
    for i=1,p do etol[i] = equalities[i].tol or eps end

    arg[0].eq   = eq
    arg[0].etol = etol.data
  end

  -- inequality constraints [q] (optional)
  if le then
    ltol = vector(q)
    for i=1,q do ltol[i] = inequalities[i].tol or 0 end

    arg[0].le   = le
    arg[0].ltol = ltol.data
  end

  -- stop criteria
  arg[0].maxcall = objective.maxcall or 0
  arg[0].maxtime = objective.maxtime or 0

  -- initial values
  local init in variables
  if is_nil(init) then
    for i=1,n do
      assertf(not is_nil(variables[i].ini), "missing initial value for variable %d", i)
    end
  elseif is_callable(init) then
    init(x)
  elseif is_iterable(init) then
    for i=1,n do x[i] = init[i] end
  else
    error("unsupported variables initialisation (callable or iterable expected)")
  end

  -- check bounds
  for i=1,n do
    assertf(x[i]>=xmin[i] and x[i]<=xmax[i], "invalid initial value %d (out of bound)", i)
  end

  -- optimize (protected call)
  local status, errmsg = pcall(_C.mad_nlopt, arg)

  -- release callback (note: callbacks are never collected)
  if fn then fn:free() end
  if eq then eq:free() end
  if le then le:free() end

  if status == false then
    warn("error '%s' occured during matching", errmsg)
    return retstr[arg[0].status], arg[0].status
  else
    return retstr[arg[0].status], arg[0].fval, arg[0].ncall
  end
end

local match = command 'match' {
  command      = fnone, -- command to execute at each iteration
  variables    = {},    -- state variables
  objective    = {},    -- objective to minimize or maximize
  equalities   = {},    -- equalities constraints
  inequalities = {},    -- inqualities constraints
  weights      = {},    -- variables and constraints weights

  usrdef=nil,           -- user defined data attached to matching environment

  exec=exec,            -- command to execute upon children creation
} :set_readonly()       -- reference match command is readonly

-- end ------------------------------------------------------------------------o
return { match = match }
