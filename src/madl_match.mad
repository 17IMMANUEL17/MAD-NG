--[=[
 o-----------------------------------------------------------------------------o
 |
 | Match module
 |
 | Methodical Accelerator Design - Copyright (c) 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - TODO

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local ffi = require 'ffi'

local _C, command, vector, matrix, warn, option                  in MAD
local fnil                                                       in MAD.gfunc
local assertf, errorf, printf, strsplit, log2num                 in MAD.utility
local is_nil, is_string, is_iterable, is_mappable, is_callable   in MAD.typeid
local eps, inf                                                   in MAD.constant

local abs, sqrt, min, max in math

local strfmt = string.format

local mintol = 1e-8

-- load nlopt lib wrapper -----------------------------------------------------o

local nloptrun = require 'madl_nlopt' -- must be first
local lsoptrun = require 'madl_lsopt' -- must be second (extend)

-- extend lib enums -----------------------------------------------------------o

ffi.cdef [[
enum {
  /* extra status/return code from MAD */
  NLOPT_RUNNING = 0,
}
]]

-- NLopt return code strings (see madl_nlopt) ---------------------------------o

local retstr = {
  -- generic failure code
  [_C.NLOPT_FAILURE         ] = 'FAILURE',
  [_C.NLOPT_INVALID_ARGS    ] = 'INVALID_ARGS',
  [_C.NLOPT_OUT_OF_MEMORY   ] = 'OUT_OF_MEMORY',
  [_C.NLOPT_ROUNDOFF_LIMITED] = 'ROUNDOFF_LIMITED',
  [_C.NLOPT_FORCED_STOP     ] = 'FORCED_STOP',
  -- generic success code
  [_C.NLOPT_SUCCESS         ] = 'SUCCESS',
  [_C.NLOPT_STOPVAL_REACHED ] = 'FMIN_REACHED',    -- MODIFIED
  [_C.NLOPT_FTOL_REACHED    ] = 'FTOL_REACHED',
  [_C.NLOPT_XTOL_REACHED    ] = 'XTOL_REACHED',
  [_C.NLOPT_MAXEVAL_REACHED ] = 'MAXCALL_REACHED', -- MODIFIED
  [_C.NLOPT_MAXTIME_REACHED ] = 'MAXTIME_REACHED',
  -- extra codes (check value with enum of nlopt return code!)
  [_C.NLOPT_RUNNING         ] = 'RUNNING',         -- ADDED
}

-- Optimiser supported algorithms (see madl_nlopt and madl_lsopt) -------------o

--[[
Algorithm specs:
  id = C enum
  bd = support bounds constraints (f = require finite bounds)
  eq = support equality constraints (result == 0)
  le = support inequality constraints (result <= 0)
  gr = require explicit computation of gradient
  lo = require local optimiser specification
  lg = augmented lagrangian method

Algorithm names:
  {G/L}{D/N}_* = global/local derivative/no-derivative optimization
  *_RAND algorithms involve some randomization.
  *_NOSCAL algorithms are *not* scaled to a unit hypercube
           (i.e. they are sensitive to the units of x)
--]]

local optalgo_default = 'LN_COBYLA'
local optalgo = {
  -- MAD NLOpt algorithms
  -- global optimisers without derivatives
  GN_CRS2_LM                 = { bd='f', eq='n', le='n', gr='n', lo='n', lg='n' },
  GN_DIRECT                  = { bd='f', eq='n', le='n', gr='n', lo='n', lg='n' },
  GN_DIRECT_L                = { bd='f', eq='n', le='n', gr='n', lo='n', lg='n' },
  GN_DIRECT_L_NOSCAL         = { bd='f', eq='n', le='n', gr='n', lo='n', lg='n' },
  GN_DIRECT_L_RAND           = { bd='f', eq='n', le='n', gr='n', lo='n', lg='n' },
  GN_DIRECT_L_RAND_NOSCAL    = { bd='f', eq='n', le='n', gr='n', lo='n', lg='n' },
  GN_DIRECT_NOSCAL           = { bd='f', eq='n', le='n', gr='n', lo='n', lg='n' },
  GN_ESCH                    = { bd='f', eq='n', le='n', gr='n', lo='n', lg='n' },
  GN_ISRES                   = { bd='f', eq='y', le='y', gr='n', lo='n', lg='n' },
  GN_MLSL                    = { bd='f', eq='n', le='n', gr='n', lo='n', lg='n' },
  GN_MLSL_LDS                = { bd='f', eq='n', le='n', gr='n', lo='n', lg='n' },
  GN_ORIG_DIRECT             = { bd='f', eq='y', le='y', gr='n', lo='n', lg='n' },
  GN_ORIG_DIRECT_L           = { bd='f', eq='y', le='y', gr='n', lo='n', lg='n' },
  -- global optimisers with derivatives
  GD_MLSL                    = { bd='f', eq='n', le='n', gr='y', lo='n', lg='n' },
  GD_MLSL_LDS                = { bd='f', eq='n', le='n', gr='y', lo='n', lg='n' },
  GD_STOGO                   = { bd='f', eq='n', le='n', gr='y', lo='n', lg='n' },
  GD_STOGO_RAND              = { bd='f', eq='n', le='n', gr='y', lo='n', lg='n' },
  -- local optimisers without derivatives
  LN_AUGLAG                  = { bd='y', eq='y', le='y', gr='n', lo='n', lg='y' },
  LN_AUGLAG_EQ               = { bd='y', eq='y', le='y', gr='n', lo='n', lg='y' },
  LN_BOBYQA                  = { bd='y', eq='n', le='n', gr='n', lo='n', lg='n' },
  LN_COBYLA                  = { bd='y', eq='y', le='y', gr='n', lo='n', lg='n' }, -- default
  LN_NELDERMEAD              = { bd='y', eq='n', le='n', gr='n', lo='n', lg='n' },
  LN_NEWUOA                  = { bd='y', eq='n', le='n', gr='n', lo='n', lg='n' },
  LN_NEWUOA_BOUND            = { bd='y', eq='n', le='n', gr='n', lo='n', lg='n' },
  LN_PRAXIS                  = { bd='y', eq='n', le='n', gr='n', lo='n', lg='n' },
  LN_SBPLX                   = { bd='y', eq='n', le='n', gr='n', lo='n', lg='n' },
  -- local optimisers with derivatives
  LD_AUGLAG                  = { bd='y', eq='y', le='y', gr='y', lo='n', lg='y' },
  LD_AUGLAG_EQ               = { bd='y', eq='y', le='y', gr='y', lo='n', lg='y' },
  LD_CCSAQ                   = { bd='y', eq='n', le='y', gr='y', lo='n', lg='n' },
  LD_LBFGS                   = { bd='y', eq='n', le='n', gr='y', lo='n', lg='n' },
  LD_LBFGS_NOCEDAL           = { bd='y', eq='n', le='n', gr='y', lo='n', lg='n' },
  LD_MMA                     = { bd='y', eq='n', le='y', gr='y', lo='n', lg='n' },
  LD_SLSQP                   = { bd='y', eq='y', le='y', gr='y', lo='n', lg='n' },
  LD_TNEWTON                 = { bd='y', eq='n', le='n', gr='y', lo='n', lg='n' },
  LD_TNEWTON_PRECOND         = { bd='y', eq='n', le='n', gr='y', lo='n', lg='n' },
  LD_TNEWTON_PRECOND_RESTART = { bd='y', eq='n', le='n', gr='y', lo='n', lg='n' },
  LD_TNEWTON_RESTART         = { bd='y', eq='n', le='n', gr='y', lo='n', lg='n' },
  LD_VAR1                    = { bd='y', eq='n', le='n', gr='y', lo='n', lg='n' },
  LD_VAR2                    = { bd='y', eq='n', le='n', gr='y', lo='n', lg='n' },
  -- surrounding optimisers (require local optimizer)
  AUGLAG                     = { bd='y', eq='y', le='y', gr='?', lo='y', lg='y' },
  AUGLAG_EQ                  = { bd='y', eq='y', le='y', gr='?', lo='y', lg='y' },
  G_MLSL                     = { bd='y', eq='n', le='n', gr='?', lo='y', lg='n' },
  G_MLSL_LDS                 = { bd='y', eq='n', le='n', gr='?', lo='y', lg='n' },

  -- MAD LSOpt algorithms
  -- pseudo-global optimisers without derivatives
  LN_LMDIF                   = { bd='y', eq='y', le='y', gr='n', lo='n', lg='n' },
  LN_JACOBIAN                = { bd='y', eq='y', le='y', gr='n', lo='n', lg='n' },
  -- pseudo-global optimisers with derivatives
  LD_LMDIF                   = { bd='y', eq='y', le='y', gr='y', lo='n', lg='n' },
  LD_JACOBIAN                = { bd='y', eq='y', le='y', gr='y', lo='n', lg='n' },
}

-- load nlopt lib wrapper -----------------------------------------------------o

do -- check integrity between optalgo and NLOPT enums (from madl_nlopt)
  local ntot = _C.NLOPT_NUM_ALGOS
  local n, t = 0, table.new(ntot,0)
  for s,a in pairs(optalgo) do
    a.id = assert(_C['NLOPT_'..s]) -- extend optalgo rows with id attribute
    n = n+1 ; t[n] = a
  end
  assert(n == ntot, "unexpected missing NLOPT algorithm")
  -- fill array part with rows by id, starting at enum 0, i.e. len+1
  for i=1,n do optalgo[t[i].id] = t[i] end
  assert(n == #optalgo+1, "unexpected corrupted list of NLOPT algorithm")
end

-- expression default weights by kind -----------------------------------------o

local expr_weights = { -- default weight = 1
  x   = 10, px  = 100, y    = 10, py  = 100, t = 10, pt = 100,
  dx  = 10, dpx = 100, dy   = 10, dpy = 100,
  mux = 10, muy = 10 , alfx = 10, alfy = 10, -- MAD-X compatiblity

  q1  = 10, q2  = 10, q3  = 10,
  mu1 = 10, mu2 = 10, mu3 = 10,
  alfa11 = 10, alfa22 = 10, alfa33 = 10,
}

-- summary --------------------------------------------------------------------o

local function disp_summ (env)
  local variables, equalities, inequalities, weights in env
  local var = env.__var
  local n, p, q, eval, ewgt, lval, lwgt in var

  if p+q > 0 then
    io.write"\n Constraints                Type        Kind        Weight     Penalty Value\n"
    io.write"-----------------------------------------------------------------------------\n"

    for i=1,p do
      local e = equalities[i] or {}
      printf("%2d: % -23s % -11s % -10s % -10.5g % -.7e\n",
                i, e.name or '', 'equality', e.kind or ' .', ewgt[i], eval[i]/ewgt[i])
    end

    for i=1,q do
      local e = inequalities[i] or {}
      printf("%2d: % -23s % -11s % -10s % -10.5g % -.5e\n",
                i+p, e.name or '', 'inequality', e.kind or ' .', lwgt[i], lval[i]/lwgt[i])
    end
  end

  local s1, s2, v1, v2
  if var.status == _C.NLOPT_RUNNING
  then s1, s2, v1, v2 = 'Curr. Value', 'Curr. Step ', var.x, var.dx
  else s1, s2, v1, v2 = 'Final Value', 'Init. Value', var.x, var.x0 end

  printf("\n Variables                  %s  %s  Lower Limit  Upper Limit\n", s1, s2)
  io.write"-------------------------------------------------------------------------------\n"

  for i=1,n do
    local xmin = var.xmin[i] > -1e100 and strfmt("% -.5e",var.xmin[i]) or '  .'
    local xmax = var.xmax[i] <  1e100 and strfmt("% -.5e",var.xmax[i]) or '  .'
    printf(" % -25s % -.5e % -.5e % -12s % -12s\n",
           variables[i].var, v1[i], v2[i], xmin, xmax)
  end

  local fmt = "\n ncall=%2d,  fval=% -.7e,  fstp=% -.5e,  status=%s\n\n"
  printf(fmt, env.ncall, var.fval, var.fstp, retstr[var.status])
end

-- getters/setters ------------------------------------------------------------o

local locfmt = [[
  return \f,env => local vnam, vidx, lget, lset = '%s', %d
        return \ => local k, v = debug.getlocal(lget or 3, vidx)
                    if not lget or k ~= vnam then
                      for i=3,1e6 do
                        local info = debug.getinfo(i, 'f')
                        if not info then break end
                        if info.func == f then lget=i ; break end
                      end ; assert(lget, 'local variable not found in getter')
                      k, v = debug.getlocal(lget, vidx)
                    end
                    -- print('lget=', lget)
                    assert(k == vnam, 'invalid local variable in getter')
                    return v
                  end,
              \x => local k = debug.setlocal(lset or 7, vidx, x)
                    if not lset or k ~= vnam then
                      for i=7,1e6 do
                        local info = debug.getinfo(i, 'f')
                        if not info then break end
                        if info.func == f then lset=i ; break end
                      end ; assert(lset, 'local variable not found in setter')
                      k = debug.setlocal(lset, vidx, x)
                    end
                    -- print('lset=', lset)
                    assert(k == vnam, 'invalid local variable in setter')
                    env.__var.flush = env.__var.fjit
                  end
                end ]]

local upvfmt = [[
  return \f,env => local vnam, vidx = '%s', %d
        return \ => local k, v = debug.getupvalue(f, vidx)
                    assert(k == vnam, 'invalid upvalue in getter')
                    return v
                  end,
              \x => local k = debug.setupvalue(f, vidx, x)
                    assert(k == vnam, 'invalid upvalue in setter')
                    env.__var.flush = env.__var.fjit
                  end
                end ]]

local wmsg =
  "write access to %s is very slow; use set, update or indirect (table) access"

local function accessors (env)
  local loc, upv, ctx = {}, {}, getfenv(3)
  local fun = debug.getinfo(3, 'f').func

  assert(ctx and fun, "unexpected invalid stack level")

  -- scan local variables of the caller
  for i=1,1e6 do
    local k,v = debug.getlocal(3, i)
    if not k then break end
    loc[k], loc[i] = i, v -- top/bottom override (required!)
  end
  -- scan upvalues of the caller
  for i=1,1e6 do
    local k,v = debug.getupvalue(fun, i)
    if not k then break end
    upv[k], upv[i] = i, v -- never override (unique!)
  end

--print("LOC") for k,v in pairs(loc) do if is_string(k) then print(k,loc[v]) end end
--print("UPV") for k,v in pairs(upv) do if is_string(k) then print(k,upv[v]) end end

  -- build variables getter/setter
  local variables in env
  local wrn = not (variables.nowarn or variables.update)
  local n in env.__var

  for i=1,n do
    local v = variables[i]
    if v.get and v.set then goto next end

    local var, fmt, get, set = v.var
    assertf(is_string(var), "invalid 'var' for variable #%d (string expected)", i)
    local nam, isep = strsplit(var, '.[')

    if loc[nam] then     -- local variable
      if isep > 0 then   -- local variable with indirect access
        fmt = strfmt("return \\%s (\\ %s, \\__x => %s=__x end)", nam, var, var)
        get, set = assert(loadstring(fmt))()(loc[loc[nam]])

      else               -- local variable with direct access (need jit.flush!)
        if wrn and not v.set then warn(wmsg, "local variables") ; wrn=false end
        fmt = strfmt(locfmt, nam, loc[nam])
        get, set = assert(loadstring(fmt))()(fun, env)
      end

    elseif upv[nam] then -- upvalue
      if isep > 0 then   -- upvalue with indirect access
        fmt = strfmt("return \\%s (\\ %s, \\__x => %s=__x end)", nam, var, var)
        get, set = assert(loadstring(fmt))()(upv[upv[nam]])

      else               -- upvalue with direct access (need jit.flush!)
        if wrn and not v.set then warn(wmsg, "upvalues") ; wrn=false end
        fmt = strfmt(upvfmt, nam, upv[nam])
        get, set = assert(loadstring(fmt))()(fun, env)
      end

    elseif ctx[nam] then -- caller context
      fmt = strfmt("return \\__ctx (\\ __ctx.%s, \\__x => __ctx.%s=__x end)", var, var)
      get, set = assert(loadstring(fmt))()(ctx)

    else
      errorf("unable to build '%s' getter and setter (variable not found)", var)
    end

    v.get = v.get or assert(get)
    v.set = v.set or assert(set)

  ::next::
  end
end

-- optimizer functions --------------------------------------------------------o

-- print matrix (debug helper)
local function dspmat(mat, nam)
  if mat ~= nil then
    local fmt = option.numfmt;
    option.numfmt = "% -.16e" ; mat:print(nam) ; option.numfmt = fmt
  end
end

-- invalid variable domain (helper)
local function invalid_dom (env)
  local var = env.__var

  var.fval, var.fstp = inf, inf
  if var.eval ~= nil then var.eval:ones(inf) end
  if var.lval ~= nil then var.lval:ones(inf) end
end

-- update variables (helper)
local function update_vars (env)
  local variables in env
  local var = env.__var
  local x in var

  if variables.update ~= nil then
    variables.update(x, env)
  else
    var.flush = nil
    for i=1,x.nrow do variables[i].set(x[i], env) end
    if var.flush then jit.flush() end -- TODO: avoid jit flush
  end
end

-- compute objective function(s)
local function compute_fval (env)
  local command, objective, equalities, inequalities in env

  local var = env.__var
  local p, q, x, fgrd, eval, ejac, ewgt, lval, ljac, lwgt, valf in var
  local fval, res = 0, nil

  env.ncall = env.ncall + 1

  update_vars(env)                                -- update user variables

  if command ~= nil then
    res = command(env)                            -- call user defined command
    if is_nil(res) then return end                -- invalid domain, return nil
  end

  if objective.exec ~= nil then
    fval = objective.exec(x, fgrd)                -- call user defined function
  end

  if equalities.exec ~= nil
  then equalities.exec(x, eval, ejac)             -- call user defined function
  else for i=1,p do eval[i] = ewgt[i]*equalities[i].expr(res, env) end
  end

  if inequalities.exec ~= nil
  then inequalities.exec(x, lval, ljac)           -- call user defined function
  else for i=1,q do lval[i] = lwgt[i]*inequalities[i].expr(res, env) end
  end

  if not valf then return fval end

  -- augment fval with squared constraints penalties
  local ltol, fwgt in var

  for i=1,p do fval = fval + eval[i]^2 end
  for i=1,q do if lval[i] > ltol[i] then fval = fval + lval[i]^2 end end

  return sqrt(fval) / fwgt -- sqrt(\sum_i (w_i c_i(x))^2) / (\sum_i w_i)
end

-- compute objective function gradient and (in)equalities jacobians
local function compute_fgrd (env)
  local var = env.__var
  local n, p, q, x, dx, xtmp, fgrd, eval, etmp, ejac, lval, ltmp, ljac in var

  -- cleanup
  fgrd:zeros()
  if ejac ~= nil then ejac:zeros() end
  if ljac ~= nil then ljac:zeros() end

  -- reference evaluation
  local fval = compute_fval(env)
  if fval == nil then return end

  -- backup variables
  var.xtmp, var.x    = var.x   , var.xtmp
  var.etmp, var.eval = var.eval, var.etmp
  var.ltmp, var.lval = var.lval, var.ltmp
  x:copy(xtmp)

  -- estimate jacobian step (2^-7 ~= 1% exact)
  local dh = 0.0078125*dx:minabs() -- to review (dh[i] vs dx[i] ?)
  if dh == 0 then dh = 1e-10 end

  if env.debug >= 2 then
    printf("nlopt: computing gradient and jacobian(s) with dh=%-.6e\n", dh)
  end

  -- compute jacobian
  for iv=1,n do
    xtmp[iv] = x[iv]+dh

    local dfval = compute_fval(env)
    if dfval == nil then fval = nil ; break end

    fgrd[iv] = (dfval-fval)/dh
    for i=1,p do ejac:set(i,iv, (etmp[i]-eval[i])/dh) end
    for i=1,q do ljac:set(i,iv, (ltmp[i]-lval[i])/dh) end

    xtmp[iv] = x[iv]
  end

  -- restore variables
  var.xtmp, var.x    = xtmp, x
  var.etmp, var.eval = etmp, eval
  var.ltmp, var.lval = ltmp, lval
  update_vars(env, x)

  return fval
end

-- functions factory
local function nlopt_functions (env)
  local var = env.__var
  local x, p, q, fgrd, grdf, ejac, ljac, method, grdmthd in var

  -- objective function
  local fun = function ()
    -- compute objective function and (in)equalities constraints
    local fval
    if grdf
    then fval = compute_fgrd(env)
    else fval = compute_fval(env)
    end

    -- check returned value (and backup)
    if fval ~= nil then
      var.fval, var.fstp = fval, fval-var.fval
      if env.debug >= 2 then
        dspmat(x   , "X"          )
        dspmat(fgrd, "GRAD-F"     )
        dspmat(ejac, "JACOBIAN-EQ")
        dspmat(ljac, "JACOBIAN-LE")
      end
    else invalid_dom(env)
    end

    -- display intermediate summary
    if var.sumdisp > 0 then disp_summ(env) end

    -- return objective function value
    return var.fval
  end

  -- (in)equality functions (nothing to do)
  local efun = method.eq == 'y' and p>0 and \ () or nil
  local lfun = method.le == 'y' and q>0 and \ () or nil

  return fun, efun, lfun -- objective, equalities and inequalities functions
end

-- match command --------------------------------------------------------------o

local function exec (self)
  local variables, equalities, inequalities, weights, objective in self
  local command = self:var_raw 'command' -- prevent evaluation
  local cmdexec = command           or fnil
  local objexec = objective.exec    or fnil
  local equexec = equalities.exec   or fnil
  local inqexec = inequalities.exec or fnil

  -- check inputs
  assert(is_mappable(variables)   , "invalid match 'variables' (mappable expected)")
  assert(is_mappable(equalities)  , "invalid match 'equalities' (mappable expected)")
  assert(is_mappable(inequalities), "invalid match 'inequalities' (mappable expected)")
  assert(is_mappable(weights)     , "invalid match 'weights' (mappable expected)")
  assert(is_mappable(objective)   , "invalid match 'objective' (mappable expected)")
  assert(is_callable(cmdexec)     , "invalid match 'command' (callable expected)")
  assert(is_callable(objexec)     , "invalid objective function (callable expected)")
  assert(is_callable(equexec)     , "invalid equality function (callable expected)")
  assert(is_callable(inqexec)     , "invalid inequality function (callable expected)")

  -- check selected method (and submethod)
  local mthd = objective.method or optalgo_default
  local mopt = assertf(optalgo[mthd], "unknown optimisation method '%s'", mthd)
  local sopt = nil

  if mopt.lo == 'y' then
    local smthd = objective.submethod
    assertf(smthd, "optimisation method '%s' requires a submethod", mthd)
    sopt = assertf(optalgo[smthd], "unknown optimisation submethod '%s'", smthd)
  end

  -- check summary level
  local summ = objective.summary or false
  local ndsp = assertf(log2num(summ), "invalid summary '%s'", tostring(summ))

  -- check debug level
  local dbug = objective.debug or false
  local ndbg = assertf(log2num(dbug), "invalid debug '%s'", tostring(dbug))

  -- objective function computation (explicitly) needed
  local valf = objective.exec == nil and mopt.lg == 'n'

  -- gradient (and jacobians) computation (explicitly) needed
  local grdm = mopt.gr == 'y' or mopt.gr == '?' and sopt.gr == 'y'
  local grdf = grdm and not (objective.exec and objective.grad ~= false)

  -- local sizes
  local n =    variables.nvar or #variables
  local p =   equalities.nequ or #equalities
  local q = inequalities.nequ or #inequalities

  -- check sizes compatiblity
  assert(n > 0, "invalid objective (variables expected)")

  -- matching environment
  local env = {
    ncall        = 0,
    debug        = ndbg,        -- debug level, can be changed during iterations
    command      = command,
    objective    = objective,
    variables    = variables,
    equalities   = equalities,
    inequalities = inequalities,
    weights      = weights,
    usrdef       = self.usrdef,

    __var  = { -- hidden variables
      n    = n,                            -- number of variables
      x    = vector(n),                    -- variables values
      dx   = vector(n),                    -- variables steps
      x0   = vector(n),                    -- variables initial values
      xstp = vector(n),                    -- variables initial steps
      xmin = vector(n),                    -- variables minimum bounds
      xmax = vector(n),                    -- variables maximum bounds
      xwgt = vector(n),                    -- variables weights
      xtol = vector(n),                    -- variables tolerances
      xtmp = grdf and vector(n) or nil,    -- variables temporary
      xrtol= variables.rtol or 0,          -- variables relative tolerance

      p    = p,                            -- number of equalities
      efun = nil,                          -- equalities function (see above)
      eval = p>0 and vector(p) or nil,     -- equalities values
      ewgt = p>0 and vector(p) or nil,     -- equalities weights
      etol = p>0 and vector(p) or nil,     -- equalities tolerances
      ejac = p>0 and grdm and matrix(p,n) or nil, -- equalities jacobian
      etmp = p>0 and grdf and vector(p)   or nil, -- equalities temporary

      q    = q,                            -- number of inequalities
      lfun = nil,                          -- inequalities function (see above)
      lval = q>0 and vector(q)   or nil,   -- inequalities values
      lwgt = q>0 and vector(q)   or nil,   -- inequalities weights
      ltol = q>0 and vector(q)   or nil,   -- inequalities tolerances
      ljac = q>0 and grdm and matrix(q,n) or nil, -- inequalities jacobian
      ltmp = q>0 and grdf and vector(q)   or nil, -- inequalities temporary

      fun  = nil,                          -- objective func (see above)
      valf = valf,                         -- objective func value flag
      grdf = grdf,                         -- objective func gradient flag
      fval = inf,                          -- objective func value (dummy init)
      fstp = 0,                            -- objective func current step
      fwgt = 0,                            -- objective func weights sum
      fgrd = grdm and vector(n) or nil,    -- objective func gradient
      fmin = objective.fmin or -inf,       -- objective func minimum (target)
      ftol = objective.tol  or 0,          -- objective func tolerance (target)
      frtol= objective.rtol or 0,          -- objective func relative tolerance (target)

      method   = mopt,                     -- algorithm method (optalgo row)
      submthd  = sopt,                     -- algorithm submethod (optalgo row)
      grdmthd  = grdm,                     -- algorithm gradient flag
      sumdisp  = ndsp,                     -- algorithm summary level
      maxcall  = objective.maxcall or 0,   -- algorithm call limit
      maxtime  = objective.maxtime or 0,   -- algorithm time limit
      finalize = fnil,                     -- algorithm finalizer
      status   = _C.NLOPT_RUNNING,         -- algorithm status
      errmsg   = nil,                      -- algorithm error message
      fjit     = false,                    -- JIT must be flushed (C API)
    },
  }

  local var = env.__var

  -- create variables getter/setters (if needed)
  if is_nil(variables.init) and is_nil(variables.update) then
    accessors(env)
  else
    assert(is_callable(variables.init) and is_callable(variables.update),
           "invalid variables init and/or update (callables expected)")
    variables.init(var.x0)
  end

  -- state variables
  for i=1,n do
    local v = variables[i] or {}
    if v.get then var.x0[i] = v.get() end
    var.x   [i] = var.x0[i]
    var.xstp[i] = v.step   or variables.step or 0
    var.xtol[i] = v.tol    or variables.tol  or 0
    var.xwgt[i] = v.weight or variables.wgt  or 1
    var.xmin[i] = v.min    or variables.min  or -inf
    var.xmax[i] = v.max    or variables.max  or  inf

    if var.xmin[i] > var.xmax[i] then
      var.xmin[i], var.xmax[i] = var.xmax[i], var.xmin[i]
    end
    if v.sign or variables.sign then
          if var.x[i] > 0 and var.xmin[i] < 0 then var.xmin[i] = 0
      elseif var.x[i] < 0 and var.xmax[i] > 0 then var.xmax[i] = 0 end
    end
    if var.x[i] < var.xmin[i] or var.x[i] > var.xmax[i] then
      warn("invalid initial value %d (out of bounds)", i)
    end
  end

  -- equality constraints
  local emintol = valf and inf or mintol
  for i=1,p do
    local e = equalities[i] or {}
    var.ewgt[i] = abs(e.weight or weights[e.kind] or expr_weights[e.kind] or 1)
    var.etol[i] = abs(e.tol or equalities.tol or emintol) * var.ewgt[i]
    var.fwgt    = var.fwgt + var.ewgt[i]
  end

  -- inequality constraints
  for i=1,q do
    local e = inequalities[i] or {}
    var.lwgt[i] = abs(e.weight or weights[e.kind] or expr_weights[e.kind] or 1)
    var.ltol[i] = (e.tol or inequalities.tol or eps) * var.lwgt[i]
    var.fwgt    = var.fwgt + var.lwgt[i]
  end

  -- adjust weights (e.g. p+q=0)
  if var.fwgt == 0 then var.fwgt = 1 end

  -- build optimizer functions
  var.fun, var.efun, var.lfun = nlopt_functions(env)

  -- call optimiser
  local status, errmsg
  if var.method.id < _C.NLOPT_NUM_ALGORITHMS
  then status, errmsg = nloptrun(env)
  else status, errmsg = lsoptrun(env)
  end

  -- display error or final summary
  if status == false then
    warn("error '%s' occured during matching", errmsg)
  elseif var.sumdisp > 0 then disp_summ(env) end

  -- return status, fmin, ncall
  return retstr[var.status], var.fval, env.ncall
end

local match = command 'match' {
  -- command to execute at each iteration (i.e. res = command(env))
  command = nil,
  -- state variables
  variables = {
  ! { var=nil, step=nil, min=nil, max=nil, sign=nil, tol=nil, get=nil, set=nil },
     nvar=nil, step=nil, min=nil, max=nil, sign=nil, tol=nil, rtol=nil,
     init=nil, update=nil,
  },
  -- equalities constraints (i.e. equ = expr(res, env))
  equalities = {
  ! {expr=nil, name=nil, kind=nil, weight=nil, tol=nil},
     nequ=nil, exec=nil,                       tol=nil,
  },
  -- inequalities constraints (i.e. inequ = expr(res, env))
  inequalities = {
  ! {expr=nil, name=nil, kind=nil, weight=nil, tol=nil},
     nequ=nil, exec=nil,                       tol=nil,
  },
  -- constraints weights (i.e. weights[kind])
  weights = {},
  -- objective to minimize or maximize
  objective = {
    method=nil, submethod=nil, fmin=nil, tol=nil, rtol=nil,
    exec=nil, grad=nil, maxtime=nil, maxcall=nil, summary=nil, debug=nil,
  },

  usrdef=nil,           -- user defined data attached to matching environment

  exec=exec,            -- command to execute upon children creation
} :set_readonly()       -- reference match command is readonly

-- end ------------------------------------------------------------------------o
return { match = match }
