--[=[
 o-----------------------------------------------------------------------------o
 |
 | Match module
 |
 | Methodical Accelerator Design - Copyright (c) 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - TODO

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local ffi = require 'ffi'

local _C, command, vector, matrix, warn, option                  in MAD
local fnil                                                       in MAD.gfunc
local assertf, errorf, printf, strsplit, log2num                 in MAD.utility
local is_nil, is_string, is_iterable, is_mappable, is_callable   in MAD.typeid
local eps, inf                                                   in MAD.constant

local abs, min, max in math

local strfmt = string.format

-- types ----------------------------------------------------------------------o

ffi.cdef [[
// NLopt supported algorithms (see nlopt.h)
// see https://nlopt.readthedocs.io/en/latest/NLopt_Algorithms/ for details

typedef enum {
/* Naming conventions:
  NLOPT_{G/L}{D/N}_* = global/local derivative/no-derivative optimization
  *_RAND algorithms involve some randomization.
  *_NOSCAL algorithms are *not* scaled to a unit hypercube
           (i.e. they are sensitive to the units of x)
*/
  NLOPT_GN_DIRECT = 0,
  NLOPT_GN_DIRECT_L,
  NLOPT_GN_DIRECT_L_RAND,
  NLOPT_GN_DIRECT_NOSCAL,
  NLOPT_GN_DIRECT_L_NOSCAL,
  NLOPT_GN_DIRECT_L_RAND_NOSCAL,

  NLOPT_GN_ORIG_DIRECT,
  NLOPT_GN_ORIG_DIRECT_L,

  NLOPT_GD_STOGO,
  NLOPT_GD_STOGO_RAND,

  NLOPT_LD_LBFGS_NOCEDAL,

  NLOPT_LD_LBFGS,

  NLOPT_LN_PRAXIS,

  NLOPT_LD_VAR1,
  NLOPT_LD_VAR2,

  NLOPT_LD_TNEWTON,
  NLOPT_LD_TNEWTON_RESTART,
  NLOPT_LD_TNEWTON_PRECOND,
  NLOPT_LD_TNEWTON_PRECOND_RESTART,

  NLOPT_GN_CRS2_LM,

  NLOPT_GN_MLSL,
  NLOPT_GD_MLSL,
  NLOPT_GN_MLSL_LDS,
  NLOPT_GD_MLSL_LDS,

  NLOPT_LD_MMA,

  NLOPT_LN_COBYLA,

  NLOPT_LN_NEWUOA,
  NLOPT_LN_NEWUOA_BOUND,

  NLOPT_LN_NELDERMEAD,
  NLOPT_LN_SBPLX,

  NLOPT_LN_AUGLAG,
  NLOPT_LD_AUGLAG,
  NLOPT_LN_AUGLAG_EQ,
  NLOPT_LD_AUGLAG_EQ,

  NLOPT_LN_BOBYQA,

  NLOPT_GN_ISRES,

/* new variants that require local_optimizer to be set */
  NLOPT_AUGLAG,
  NLOPT_AUGLAG_EQ,
  NLOPT_G_MLSL,
  NLOPT_G_MLSL_LDS,

  NLOPT_LD_SLSQP,

  NLOPT_LD_CCSAQ,

  NLOPT_GN_ESCH,

  NLOPT_NUM_ALGORITHMS /* not an algorithm, just the number of them */
} nlopt_algorithm;

// NLopt return codes (see nlopt.h)

typedef enum {
  NLOPT_FAILURE = -1, /* generic failure code */
  NLOPT_INVALID_ARGS = -2,
  NLOPT_OUT_OF_MEMORY = -3,
  NLOPT_ROUNDOFF_LIMITED = -4,
  NLOPT_FORCED_STOP = -5,

  NLOPT_SUCCESS = 1, /* generic success code */
  NLOPT_STOPVAL_REACHED = 2,
  NLOPT_FTOL_REACHED = 3,
  NLOPT_XTOL_REACHED = 4,
  NLOPT_MAXEVAL_REACHED = 5,
  NLOPT_MAXTIME_REACHED = 6,

  NLOPT_RUNNING = 0 /* extra code for MAD */
} nlopt_result;

  /* API - to check after nlopt upgrade */
  typedef struct nlopt_opt_s *nlopt_opt; /* internal opaque structure */
  nlopt_result nlopt_force_stop(nlopt_opt, int val);
]]

ffi.cdef[[
// NLopt MAD C interface (see mad_nlopt.h)

typedef num_t (nlopt_obj_t)(u32_t n, const num_t *x, num_t *grad, void *data);
typedef void  (nlopt_cts_t)(u32_t m, num_t *res,
                            u32_t n, const num_t* x, num_t* grad, void* data);

struct nlopt_args {
  // algorithm
        int    algo;
        str_t  algonam;

  // objective function (required)
  nlopt_obj_t *fun;
        num_t  fval;  // current minimum value
        num_t  fmin;  // minimum value required (target)
        num_t  ftol;  // minimum value change required (target)
        num_t  frtol; // minimum relative value change required (target)

  // state variables [n] (required)
        ssz_t  n;
        num_t *x;
  const num_t *dx;
  const num_t *xmin;
  const num_t *xmax;
  const num_t *xtol;
        num_t  xrtol;

  // equality constraints [p]
        ssz_t  p;
  nlopt_cts_t *efun;
  const num_t *etol;

  // inequality constraints [q]
        ssz_t  q;
  nlopt_cts_t *lfun;
  const num_t *ltol;

  // stop criteria (if >0)
        int    maxcall;
        num_t  maxtime;

  // debug level
        int    debug;

  // returned values
        int    status;

  // pointer to nlop opaque structure
  nlopt_opt    opt;
};
]]

-- NLopt supported algorithms (see nlopt.h) -----------------------------------o

--[[
Algorithm specs:
  id = C enum
  bd = support bounds constraints (f = require finite bounds)
  eq = support equality constraints (result == 0)
  le = support inequality constraints (result <= 0)
  gr = require explicit computation of gradient
  lo = require local optimiser specification (NYI)
  lg = require augmented lagrangian (NYI)
--]]

local nlopt_algo = {
  -- global optimisers without derivatives
  NLOPT_GN_CRS2_LM                 = { bd='f', eq='n', le='n', gr='n', lo='n' },
  NLOPT_GN_DIRECT                  = { bd='f', eq='n', le='n', gr='n', lo='n' },
  NLOPT_GN_DIRECT_L                = { bd='f', eq='n', le='n', gr='n', lo='n' },
  NLOPT_GN_DIRECT_L_NOSCAL         = { bd='f', eq='n', le='n', gr='n', lo='n' },
  NLOPT_GN_DIRECT_L_RAND           = { bd='f', eq='n', le='n', gr='n', lo='n' },
  NLOPT_GN_DIRECT_L_RAND_NOSCAL    = { bd='f', eq='n', le='n', gr='n', lo='n' },
  NLOPT_GN_DIRECT_NOSCAL           = { bd='f', eq='n', le='n', gr='n', lo='n' },
  NLOPT_GN_ESCH                    = { bd='f', eq='n', le='n', gr='n', lo='n' },
  NLOPT_GN_ISRES                   = { bd='f', eq='y', le='y', gr='n', lo='n' },
  NLOPT_GN_MLSL                    = { bd='f', eq='n', le='n', gr='n', lo='n' },
  NLOPT_GN_MLSL_LDS                = { bd='f', eq='n', le='n', gr='n', lo='n' },
  NLOPT_GN_ORIG_DIRECT             = { bd='f', eq='y', le='y', gr='n', lo='n' },
  NLOPT_GN_ORIG_DIRECT_L           = { bd='f', eq='y', le='y', gr='n', lo='n' },
  -- global optimisers with derivatives
  NLOPT_GD_MLSL                    = { bd='f', eq='n', le='n', gr='y', lo='n' },
  NLOPT_GD_MLSL_LDS                = { bd='f', eq='n', le='n', gr='y', lo='n' },
  NLOPT_GD_STOGO                   = { bd='f', eq='n', le='n', gr='y', lo='n' },
  NLOPT_GD_STOGO_RAND              = { bd='f', eq='n', le='n', gr='y', lo='n' },
  -- local optimisers without derivatives
  NLOPT_LN_AUGLAG                  = { bd='y', eq='y', le='y', gr='n', lo='n' },
  NLOPT_LN_AUGLAG_EQ               = { bd='y', eq='y', le='y', gr='n', lo='n' },
  NLOPT_LN_BOBYQA                  = { bd='y', eq='n', le='n', gr='n', lo='n' },
  NLOPT_LN_COBYLA                  = { bd='y', eq='y', le='y', gr='n', lo='n' }, -- default
  NLOPT_LN_NELDERMEAD              = { bd='y', eq='n', le='n', gr='n', lo='n' },
  NLOPT_LN_NEWUOA                  = { bd='y', eq='n', le='n', gr='n', lo='n' },
  NLOPT_LN_NEWUOA_BOUND            = { bd='y', eq='n', le='n', gr='n', lo='n' },
  NLOPT_LN_PRAXIS                  = { bd='y', eq='n', le='n', gr='n', lo='n' },
  NLOPT_LN_SBPLX                   = { bd='y', eq='n', le='n', gr='n', lo='n' },
  -- local optimisers with derivatives
  NLOPT_LD_AUGLAG                  = { bd='y', eq='y', le='y', gr='y', lo='n' },
  NLOPT_LD_AUGLAG_EQ               = { bd='y', eq='y', le='y', gr='y', lo='n' },
  NLOPT_LD_CCSAQ                   = { bd='y', eq='n', le='y', gr='y', lo='n' },
  NLOPT_LD_LBFGS                   = { bd='y', eq='n', le='n', gr='y', lo='n' },
  NLOPT_LD_LBFGS_NOCEDAL           = { bd='y', eq='n', le='n', gr='y', lo='n' },
  NLOPT_LD_MMA                     = { bd='y', eq='n', le='y', gr='y', lo='n' },
  NLOPT_LD_SLSQP                   = { bd='y', eq='y', le='y', gr='y', lo='n' },
  NLOPT_LD_TNEWTON                 = { bd='y', eq='n', le='n', gr='y', lo='n' },
  NLOPT_LD_TNEWTON_PRECOND         = { bd='y', eq='n', le='n', gr='y', lo='n' },
  NLOPT_LD_TNEWTON_PRECOND_RESTART = { bd='y', eq='n', le='n', gr='y', lo='n' },
  NLOPT_LD_TNEWTON_RESTART         = { bd='y', eq='n', le='n', gr='y', lo='n' },
  NLOPT_LD_VAR1                    = { bd='y', eq='n', le='n', gr='y', lo='n' },
  NLOPT_LD_VAR2                    = { bd='y', eq='n', le='n', gr='y', lo='n' },
  -- other cases
  NLOPT_AUGLAG                     = { bd='y', eq='y', le='y', gr='?', lo='y' },
  NLOPT_AUGLAG_EQ                  = { bd='y', eq='y', le='y', gr='?', lo='y' },
  NLOPT_G_MLSL                     = { bd='y', eq='n', le='n', gr='?', lo='y' },
  NLOPT_G_MLSL_LDS                 = { bd='y', eq='n', le='n', gr='?', lo='y' },
}
do
  local n, t = 0, table.new( _C.NLOPT_NUM_ALGORITHMS,0)
  for s,a in pairs(nlopt_algo) do
    a.id = assert(_C[s]) ; n = n+1 ; t[n] = a
  end
  assert(n == _C.NLOPT_NUM_ALGORITHMS, "unexpected missing NLOPT algorithm")

  for i=1,n do nlopt_algo[t[i].id] = t[i] end
  assert(n == #nlopt_algo+1, "unexpected corrupted list of NLOPT algorithm")
end

-- NLopt return code strings
local retstr = {
  -- generic failure code
  [_C.NLOPT_FAILURE         ] = 'NLOPT_FAILURE',
  [_C.NLOPT_INVALID_ARGS    ] = 'NLOPT_INVALID_ARGS',
  [_C.NLOPT_OUT_OF_MEMORY   ] = 'NLOPT_OUT_OF_MEMORY',
  [_C.NLOPT_ROUNDOFF_LIMITED] = 'NLOPT_ROUNDOFF_LIMITED',
  [_C.NLOPT_FORCED_STOP     ] = 'NLOPT_FORCED_STOP',
  -- generic success code
  [_C.NLOPT_SUCCESS         ] = 'NLOPT_SUCCESS',
  [_C.NLOPT_STOPVAL_REACHED ] = 'NLOPT_FMIN_REACHED',    -- MODIFIED
  [_C.NLOPT_FTOL_REACHED    ] = 'NLOPT_FTOL_REACHED',
  [_C.NLOPT_XTOL_REACHED    ] = 'NLOPT_XTOL_REACHED',
  [_C.NLOPT_MAXEVAL_REACHED ] = 'NLOPT_MAXCALL_REACHED', -- MODIFIED
  [_C.NLOPT_MAXTIME_REACHED ] = 'NLOPT_MAXTIME_REACHED',
  -- extra codes (check value with enum of nlopt return code!)
  [_C.NLOPT_RUNNING         ] = 'NLOPT_RUNNING',         -- ADDED
}

-- expression default weights by kind -----------------------------------------o

local expr_weights = { -- default weight = 1
  x   = 10, px  = 100, y    = 10, py  = 100, t = 10, pt = 100,
  dx  = 10, dpx = 100, dy   = 10, dpy = 100,
  mux = 10, muy = 10 , alfx = 10, alfy = 10, -- MAD-X compatiblity

  q1  = 10, q2  = 10, q3  = 10,
  mu1 = 10, mu2 = 10, mu3 = 10,
  alfa11 = 10, alfa22 = 10, alfa33 = 10,
}

-- summary --------------------------------------------------------------------o

local function disp_summ (env)
  local variables, equalities, inequalities, weights in env
  local var, arg = env.__var, env.__var.arg
  local n, p, q, status in arg[0]

  io.write"\n Constraints                Type        Kind        Weight     Penalty Value\n"
  io.write"-----------------------------------------------------------------------------\n"

  for i=1,p do
    local e = equalities[i]
    local w = e.weight or weights[e.kind] or expr_weights[e.kind] or 1
    printf("%2d: % -23s % -11s % -10s % -10.5g % -.7e\n",
              i, e.name or '', 'equality', e.kind or '.', w, var.eval[i])
  end

  for i=1,q do
    local e = inequalities[i]
    local w = e.weight or weights[e.kind] or expr_weights[e.kind] or 1
    printf("%2d: % -23s % -11s % -10s % -10.5g % -.5e\n",
              i+p, e.name or '', 'inequality', e.kind or '.', w, var.lval[i])
  end

  local s1, s2, v1, v2
  if status == _C.NLOPT_RUNNING
  then s1, s2, v1, v2 = 'Curr. Value', 'Curr. Step ', var.x, var.dx
  else s1, s2, v1, v2 = 'Final Value', 'Init. Value', var.x, var.x0 end

  printf("\n Variables                  %s  %s  Lower Limit  Upper Limit\n", s1, s2)
  io.write"-------------------------------------------------------------------------------\n"

  for i=1,n do
    printf(" % -25s % -.5e % -.5e % -.5e % -.5e\n",
            variables[i].var, v1[i], v2[i],
            max(var.xmin[i],-9.99999e99), min(var.xmax[i], 9.99999e99))
  end

  local fmt = "\n status=%s,  ncall=%2d\z
               \n fmin=% -.10e,  fval=% -.10e,  ftol=% -.10e\n\n"

  printf(fmt, retstr[arg[0].status], env.ncall, arg[0].fval, var.fval, var.ftol)
end

-- callbacks ------------------------------------------------------------------o

local function dspmat(mat, nam)
  local fmt = option.format
  option.format = "% -.5e"
  mat:print(nam)
  option.format = fmt
end

local function nlopt_functions (env, mthd, ndsp)
  local command, variables, objective, equalities, inequalities, weights in env

  assert(is_nil(objective.exec) or is_callable(objective.exec),
         "invalid objective (callable expected)")
  assert(is_nil(equalities.exec) or is_callable(equalities.exec),
         "invalid equality constraints (callable expected)")
  assert(is_nil(inequalities.exec) or is_callable(inequalities.exec),
         "invalid inequality constraints (callable expected)")

  local update in variables
  local var, arg = env.__var, env.__var.arg
  local n, p, q, x, dx, df, eval, ewgt, etol, lval, lwgt, ltol, egrd, lgrd,
        ndbg in var
  local disp = ndsp > 1 and disp_summ or fnil
  local grad = nlopt_algo[mthd].gr == 'y'
  local ncal = arg[0].maxcall > 0
  local fmin = arg[0].fmin > -inf
  local ftol = arg[0].ftol > 0
  local fscl = 0

  -- weights scaling
  if ewgt then fscl = fscl + ewgt:sum() end
  if lwgt then fscl = fscl + lwgt:sum() end
  fscl = fscl == 0 and 1 or 1/fscl

  -- nlopt objective function
  return objective.exec or
    function(n_, x_, df_)
      assert(n_ == n, "invalid number of variables (unexpected)")
      assert(x_     , "missing vector of variables (unexpected)")
      assert(df_ == nil or grad, "unexpected non-nil gradient argument")

      -- force to stop
      if var.status then
        if ndbg >= 1 then io.write("nlopt: forced to stop\n") end
        _C.nlopt_force_stop(arg[0].opt, var.status)
        return arg[0].fval
      end

      -- iteration number
      env.ncall = env.ncall + 1

      -- update state vector
      for i=1,n do
        x[i], dx[i] = x_[i-1], x_[i-1]-x[i]
        if dx[i] == 0 then
          dx[i] = x[i] ~= 0 and 0.015625*abs(x[i]) or 1e-4
        end
      end

      -- update state variables
      if update then
        update(x, env)
      else
        var.flush = nil
        for i=1,n do variables[i].set(x[i], env) end
        if var.flush then jit.flush() end -- TODO: avoid jit flush
      end

      -- call user command
      local res = command(env)

      -- objective function error
      local fval = 0

      -- collect equalities constraints
      for i=1,p do
        eval[i] = equalities[i].expr(res, env)
        if abs(eval[i]) > etol[i] then fval = fval + ewgt[i]*abs(eval[i]) end
      end

      -- collect inequalities constraints
      for i=1,q do
        lval[i] = inequalities[i].expr(res, env)
        if lval[i] > ltol[i] then fval = fval + lwgt[i]*abs(lval[i]) end
      end

      -- save objective function
      var.fval = fval*fscl
      var.ftol = abs(var.fval-arg[0].fval)

      -- gradient requested
      if df_ ~= nil then
        if egrd then egrd:zeros() end
        if lgrd then lgrd:zeros() end

        -- compute objective function gradient(s)
        for iv=1,n do
          env.ncall = env.ncall + 1
          if dx[iv] == 0 then df[iv]=0 ; goto next end

          for i=1,n do x[i] = x_[i-1] end ; x[iv] = x[iv]+dx[iv]

          if update then
            update(x, env)
          else
            var.flush = nil
            for i=1,n do variables[i].set(x[i], env) end
            if var.flush then jit.flush() end -- TODO: avoid jit flush
          end

          local res = command(env)

          local fval = 0
          for i=1,p do
            local ev = equalities[i].expr(res, env)
            egrd:set(iv,i, (ev-eval[i])/dx[iv])
            if abs(ev) > etol[i] then fval = fval + ewgt[i]*abs(ev) end
          end
          for i=1,q do
            local lv = inequalities[i].expr(res, env)
            lgrd:set(iv,i, (lv-lval[i])/dx[iv])
            if lv > ltol[i] then fval = fval + lwgt[i]*abs(lv) end
          end
          fval = fval*fscl
          df[iv] = (fval-var.fval)/dx[iv]

        ::next::
        end

        -- restore variables, copy gradient
        for i=1,n do x[i], df_[i-1] = x_[i-1], df[i] end
        if update then
          update(x, env)
        else
          var.flush = nil
          for i=1,n do variables[i].set(x[i], env) end
          if var.flush then jit.flush() end -- TODO: avoid jit flush
        end

        if ndbg >= 2 then dspmat(df,"GRAD-F") end
      end

      -- display intermediate summary
      disp(env)

      -- stop criteria (nlopt ignores fmin and ftol...?)
      if ncal and env.ncall >= arg[0].maxcall then
        var.status = _C.NLOPT_MAXEVAL_REACHED
      elseif fmin and var.fval <= arg[0].fmin then
        var.status = _C.NLOPT_STOPVAL_REACHED
      elseif ftol and (var.ftol <= arg[0].ftol or
                       var.ftol <= arg[0].frtol*abs(var.fval)) then
        var.status = _C.NLOPT_FTOL_REACHED
      end

      -- return weighted mean: \sum_i w_i |c_i(x)| / \sum_i w_i
      return var.fval
    end,

  -- nlopt equality function
  nlopt_algo[mthd].eq == 'y' and (equalities.exec or p>0 and
    function(p_, r_, n_, x_, de_)
      assert(p_ == p, "invalid number of equalities (unexpected)")
      assert(r_     , "missing vector of equalities (unexpected)")
      for i=1,p do r_[i-1] = eval[i] end
      if de_ ~= nil then
        for i=1,n*p do de_[i-1] = egrd[i] end
        if ndbg >= 2 then dspmat(egrd,"JACOBIAN-EQ") end
      end
    end or nil),

  -- nlopt inequality function
  nlopt_algo[mthd].le == 'y' and (inequalities.exec or q>0 and
    function(q_, r_, n_, x_, dl_)
      assert(q_ == q, "invalid number of inequalities (unexpected)")
      assert(r_     , "missing vector of inequalities (unexpected)")
      for i=1,q do r_[i-1] = lval[i] end
      if dl_ ~= nil then
        for i=1,n*q do dl_[i-1] = lgrd[i] end
        if ndbg >= 2 then dspmat(lgrd,"JACOBIAN-LE") end
      end
    end or nil)
end

-- getters/setters ------------------------------------------------------------o

local locfmt = [[
  return \f,env => local vnam, vidx, lget, lset = '%s', %d
        return \ => local k, v = debug.getlocal(lget or 3, vidx)
                    if not lget or k ~= vnam then
                      for i=3,1e6 do
                        local info = debug.getinfo(i, 'f')
                        if not info then break end
                        if info.func == f then lget=i ; break end
                      end ; assert(lget, 'local variable not found in getter')
                      k, v = debug.getlocal(lget, vidx)
                    end
                    -- print('lget=', lget)
                    assert(k == vnam, 'invalid local variable in getter')
                    return v
                  end,
              \x => local k = debug.setlocal(lset or 6, vidx, x)
                    if not lset or k ~= vnam then
                      for i=6,1e6 do
                        local info = debug.getinfo(i, 'f')
                        if not info then break end
                        if info.func == f then lset=i ; break end
                      end ; assert(lset, 'local variable not found in setter')
                      k = debug.setlocal(lset, vidx, x)
                    end
                    -- print('lset=', lset)
                    assert(k == vnam, 'invalid local variable in setter')
                    env.__var.flush = true
                  end
                end ]]

local upvfmt = [[
  return \f,env => local vnam, vidx = '%s', %d
        return \ => local k, v = debug.getupvalue(f, vidx)
                    assert(k == vnam, 'invalid upvalue in getter')
                    return v
                  end,
              \x => local k = debug.setupvalue(f, vidx, x)
                    assert(k == vnam, 'invalid upvalue in setter')
                    env.__var.flush = true
                  end
                end ]]

local wmsg =
  "write access to %s is very slow; use set, update or indirect (table) access"

local function accessors (variables, env)
  local loc, upv, ctx = {}, {}, getfenv(3)
  local fun = debug.getinfo(3, 'f').func
  local n in env.__var

  assert(ctx and fun, "unexpected invalid stack level")

  -- scan local variables of the caller
  for i=1,1e6 do
    local k,v = debug.getlocal(3, i)
    if not k then break end
    loc[k], loc[i] = i, v -- top/bottom override (required!)
  end
  -- scan upvalues of the caller
  for i=1,1e6 do
    local k,v = debug.getupvalue(fun, i)
    if not k then break end
    upv[k], upv[i] = i, v -- never override (unique!)
  end

--print("LOC") for k,v in pairs(loc) do if is_string(k) then print(k,loc[v]) end end
--print("UPV") for k,v in pairs(upv) do if is_string(k) then print(k,upv[v]) end end

  -- build variables getter/setter
  local wrn = not (variables.nowarn or variables.update)

  for i=1,n do
    local v = variables[i]
    if v.get and v.set then goto next end

    local var, fmt, get, set = v.var
    assertf(is_string(var), "invalid 'var' for variable #%d (string expected)", i)
    local nam, isep = strsplit(var, '.[')

    if loc[nam] then     -- local variable
      if isep > 0 then   -- local variable with indirect access
        fmt = strfmt("return \\%s (\\ %s, \\__x => %s=__x end)", nam, var, var)
        get, set = assert(loadstring(fmt))()(loc[loc[nam]])

      else               -- local variable with direct access (need jit.flush!)
        if wrn and not v.set then warn(wmsg, "local variables") ; wrn=false end
        fmt = strfmt(locfmt, nam, loc[nam])
        get, set = assert(loadstring(fmt))()(fun, env)
      end

    elseif upv[nam] then -- upvalue
      if isep > 0 then   -- upvalue with indirect access
        fmt = strfmt("return \\%s (\\ %s, \\__x => %s=__x end)", nam, var, var)
        get, set = assert(loadstring(fmt))()(upv[upv[nam]])

      else               -- upvalue with direct access (need jit.flush!)
        if wrn and not v.set then warn(wmsg, "upvalues") ; wrn=false end
        fmt = strfmt(upvfmt, nam, upv[nam])
        get, set = assert(loadstring(fmt))()(fun, env)
      end

    elseif ctx[nam] then -- caller context
      fmt = strfmt("return \\__ctx (\\ __ctx.%s, \\__x => __ctx.%s=__x end)", var, var)
      get, set = assert(loadstring(fmt))()(ctx)

    else
      errorf("unable to build '%s' getter and setter (variable not found)", var)
    end

    v.get = v.get or assert(get)
    v.set = v.set or assert(set)

  ::next::
  end
end

-- match command --------------------------------------------------------------o

local function exec (self)
  local variables, equalities, inequalities, weights, objective in self
  local command = self:var_raw 'command' or fnil -- prevent evaluation

  -- check inputs
  assert(is_callable(command)     , "invalid match 'command' (callable expected)")
  assert(is_mappable(variables)   , "invalid match 'variables' (iterable expected)")
  assert(is_mappable(equalities)  , "invalid match 'equalities' (iterable expected)")
  assert(is_mappable(inequalities), "invalid match 'inequalities' (iterable expected)")
  assert(is_mappable(weights)     , "invalid match 'weights' (mappable expected)")
  assert(is_mappable(objective)   , "invalid match 'objective' (mappable expected)")

  -- check selected method
  local mthd = objective.method or 'NLOPT_LN_COBYLA' -- 'NLOPT_GN_ORIG_DIRECT_L'
  local mopt = assertf(nlopt_algo[mthd], "unknown optimisation method '%s'", mthd)

  -- check summary level
  local summ = objective.summary or false
  local ndsp = assertf(log2num(summ), "invalid summary '%s'", tostring(summ))

  -- check debug level
  local dbug = objective.debug or false
  local ndbg = assertf(log2num(dbug), "invalid debug '%s'", tostring(dbug))

  -- local sizes
  local n = min(#variables, variables.nvar or 1e6)
  local p =     #equalities
  local q =     #inequalities

  -- check sizes compatiblity
  assert(n > 0, "invalid objective (variables expected)")

  -- matching environment
  local env = {
    ncall        = 0,
    command      = command,
    objective    = objective,
    variables    = variables,
    equalities   = equalities,
    inequalities = inequalities,
    weights      = weights,
    usrdef       = self.usrdef,
    __var  = { -- hidden variables
      n    = n,
      x0   = vector(n),
      x    = vector(n),
      dx   = vector(n),
      df   = vector(n),
      xtol = vector(n),
      xmin = vector(n),
      xmax = vector(n),
      p    = p,
      eval = p>0 and vector(p)   or nil,
      ewgt = p>0 and vector(p)   or nil,
      etol = p>0 and vector(p)   or nil,
      egrd = p>0 and matrix(n,p) or nil,
      q    = q,
      lval = q>0 and vector(q)   or nil,
      lwgt = q>0 and vector(q)   or nil,
      ltol = q>0 and vector(q)   or nil,
      lgrd = q>0 and matrix(n,q) or nil,
      ndbg = ndbg,
      arg  = ffi.new 'nlopt_args_t[1]'
    },
  }

  local var = env.__var

  -- create variables getter/setters (if needed)
  if is_nil(variables.init) and is_nil(variables.update) then
    accessors(variables, env)
  else
    assert(is_callable(variables.init) and is_callable(variables.update),
           "invalid variables init and/or update (callables expected)")
    variables.init(var.x0)
  end

  -- state variables
  for i=1,n do
    local v = variables[i]
    if v.get then var.x0[i] = v.get() end
    var.x   [i] = var.x0[i]
    var.dx  [i] = v.step or variables.step or 0
    var.xtol[i] = v.tol  or variables.tol  or 0
    var.xmin[i] = v.min  or variables.min  or -inf
    var.xmax[i] = v.max  or variables.max  or  inf

    if var.xmin[i] > var.xmax[i] then
      var.xmin[i], var.xmax[i] = var.xmax[i], var.xmin[i]
    end
    if v.sign or variables.sign then
          if var.x[i] > 0 and var.xmin[i] < 0 then var.xmin[i] = 0
      elseif var.x[i] < 0 and var.xmax[i] > 0 then var.xmax[i] = 0 end
    end
    if var.x[i] < var.xmin[i] or var.x[i] > var.xmax[i] then
      warn("invalid initial value %d (out of bounds)", i)
    end
    if var.dx[i] == 0 then
      var.dx[i] = var.x[i] ~= 0 and 0.015625*abs(var.x[i]) or 1e-4
    end
  end

  -- equality constraints
  for i=1,p do
    local e = equalities[i]
    var.etol[i] = e.tol or equalities.tol or 0
    var.ewgt[i] = e.weight or weights[e.kind] or expr_weights[e.kind] or 1
  end

  -- inequality constraints
  for i=1,q do
    local e = inequalities[i]
    var.ltol[i] = e.tol or inequalities.tol or 0
    var.lwgt[i] = e.weight or weights[e.kind] or expr_weights[e.kind] or 1
  end

  -- fill C struct
  local arg = env.__var.arg
  local x   = var.x:copy() -- use separate vector as nlopt seems to modify it

  arg[0].algo    = mopt.id

  arg[0].fun     = nil -- see below
  arg[0].fval    = inf -- dummy init
  arg[0].fmin    = objective.fmin or -inf
  arg[0].ftol    = objective.ftol or 0
  arg[0].frtol   = objective.rtol or 0

  arg[0].n       = n
  arg[0].x       = x.data
  arg[0].dx      = var.dx.data

  arg[0].xmin    = var.xmin.data
  arg[0].xmax    = var.xmax.data
  arg[0].xtol    = var.xtol.data
  arg[0].xrtol   = variables.rtol or 0

  arg[0].p       = p
  arg[0].efun    = nil -- see below
  arg[0].etol    = p>0 and var.etol.data or nil

  arg[0].q       = q
  arg[0].lfun    = nil -- see below
  arg[0].ltol    = q>0 and var.ltol.data or nil

  arg[0].maxcall = objective.maxcall or 0
  arg[0].maxtime = objective.maxtime or 0

  arg[0].debug   = ndbg
  arg[0].status  = _C.NLOPT_RUNNING

  if ndbg >= 2 then var.dx:print("STEP-X") end

  -- nlopt callbacks
  local fun, efun, lfun = nlopt_functions (env, mthd, ndsp)
  local fun_cb, efun_cb, lfun_cb
  if  fun then  fun_cb = ffi.cast('nlopt_obj_t*',  fun) ; arg[0]. fun =  fun_cb end
  if efun then efun_cb = ffi.cast('nlopt_cts_t*', efun) ; arg[0].efun = efun_cb end
  if lfun then lfun_cb = ffi.cast('nlopt_cts_t*', lfun) ; arg[0].lfun = lfun_cb end

  -- optimize (protected call)
  local status, errmsg = pcall(_C.mad_nlopt, arg)

  -- release callback (note: callbacks are never collected)
  if  fun then  fun_cb:free() end
  if efun then efun_cb:free() end
  if lfun then lfun_cb:free() end

  -- return status and status id
  if status == false then
    warn("error '%s' occured during matching", errmsg)
    return retstr[arg[0].status], arg[0].status
  end

  -- forced stop, do not copy state variables (next step)
  if arg[0].status == _C.NLOPT_FORCED_STOP then
    arg[0].status = var.status
  else -- do copy state variables (last step)
    x:copy(var.x)
  end

  -- display final summary and return status, fmin, ncall
  if ndsp > 0 then disp_summ(env) end
  return retstr[arg[0].status], arg[0].fval, env.ncall
end

local match = command 'match' {
  -- command to execute at each iteration (i.e. call command(env))
  command = nil,
  -- state variables
  variables = {
  ! { var=nil, step=nil, min=nil, max=nil, tol=nil, sign=nil, get =nil, set   =nil },
     nvar=nil, step=nil, min=nil, max=nil, tol=nil, sign=nil, init=nil, update=nil,
     rtol=nil, sign=nil,
  },
  -- equalities constraints
  equalities = {
  ! {expr=nil, name=nil, kind=nil, weight=nil, tol=nil},
     exec=nil,                                 tol=nil,
  },
  -- inqualities constraints
  inequalities = {
  ! {expr=nil, name=nil, kind=nil, weight=nil, tol=nil},
     exec=nil,                                 tol=nil,
  },
  -- constraints weights (i.e. weights[kind])
  weights = {},
  -- objective to minimize or maximize
  objective = {
    fmin=nil, ftol=nil, rtol=nil, maxtime=nil, maxcall=nil, method=nil, grad=nil,
    exec=nil, summary=nil, debug=nil,
  },

  usrdef=nil,           -- user defined data attached to matching environment

  exec=exec,            -- command to execute upon children creation
} :set_readonly()       -- reference match command is readonly

-- end ------------------------------------------------------------------------o
return { match = match }
