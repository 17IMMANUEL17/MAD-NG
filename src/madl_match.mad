--[=[
 o-----------------------------------------------------------------------------o
 |
 | Match module
 |
 | Methodical Accelerator Design - Copyright (c) 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - TODO

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local ffi = require 'ffi'

local _C, command, vector, warn                                  in MAD
local fnil                                                       in MAD.gfunc
local assertf, errorf, printf, strsplit                          in MAD.utility
local is_nil, is_string, is_iterable, is_mappable, is_callable   in MAD.typeid
local eps, inf                                                   in MAD.constant

local min    = math.min
local strfmt = string.format

-- types ----------------------------------------------------------------------o

ffi.cdef [[
// NLopt supported algorithms (see nlopt.h)
// see https://nlopt.readthedocs.io/en/latest/NLopt_Algorithms/ for details

enum {
/* Naming conventions:
  NLOPT_{G/L}{D/N}_* = global/local derivative/no-derivative optimization
  *_RAND algorithms involve some randomization.
  *_NOSCAL algorithms are *not* scaled to a unit hypercube
           (i.e. they are sensitive to the units of x)
*/
  NLOPT_GN_DIRECT = 0,
  NLOPT_GN_DIRECT_L,
  NLOPT_GN_DIRECT_L_RAND,
  NLOPT_GN_DIRECT_NOSCAL,
  NLOPT_GN_DIRECT_L_NOSCAL,
  NLOPT_GN_DIRECT_L_RAND_NOSCAL,

  NLOPT_GN_ORIG_DIRECT,
  NLOPT_GN_ORIG_DIRECT_L,

  NLOPT_GD_STOGO,
  NLOPT_GD_STOGO_RAND,

  NLOPT_LD_LBFGS_NOCEDAL,

  NLOPT_LD_LBFGS,

  NLOPT_LN_PRAXIS,

  NLOPT_LD_VAR1,
  NLOPT_LD_VAR2,

  NLOPT_LD_TNEWTON,
  NLOPT_LD_TNEWTON_RESTART,
  NLOPT_LD_TNEWTON_PRECOND,
  NLOPT_LD_TNEWTON_PRECOND_RESTART,

  NLOPT_GN_CRS2_LM,

  NLOPT_GN_MLSL,
  NLOPT_GD_MLSL,
  NLOPT_GN_MLSL_LDS,
  NLOPT_GD_MLSL_LDS,

  NLOPT_LD_MMA,

  NLOPT_LN_COBYLA,

  NLOPT_LN_NEWUOA,
  NLOPT_LN_NEWUOA_BOUND,

  NLOPT_LN_NELDERMEAD,
  NLOPT_LN_SBPLX,

  NLOPT_LN_AUGLAG,
  NLOPT_LD_AUGLAG,
  NLOPT_LN_AUGLAG_EQ,
  NLOPT_LD_AUGLAG_EQ,

  NLOPT_LN_BOBYQA,

  NLOPT_GN_ISRES,

/* new variants that require local_optimizer to be set */
  NLOPT_AUGLAG,
  NLOPT_AUGLAG_EQ,
  NLOPT_G_MLSL,
  NLOPT_G_MLSL_LDS,

  NLOPT_LD_SLSQP,

  NLOPT_LD_CCSAQ,

  NLOPT_GN_ESCH,

  NLOPT_NUM_ALGORITHMS /* not an algorithm, just the number of them */
};
]]

ffi.cdef[[
// NLopt return codes (see nlopt.h)

enum {
  NLOPT_FAILURE = -1, /* generic failure code */
  NLOPT_INVALID_ARGS = -2,
  NLOPT_OUT_OF_MEMORY = -3,
  NLOPT_ROUNDOFF_LIMITED = -4,
  NLOPT_FORCED_STOP = -5,

  NLOPT_SUCCESS = 1, /* generic success code */
  NLOPT_STOPVAL_REACHED = 2,
  NLOPT_FTOL_REACHED = 3,
  NLOPT_XTOL_REACHED = 4,
  NLOPT_MAXEVAL_REACHED = 5,
  NLOPT_MAXTIME_REACHED = 6
};
]]

ffi.cdef[[
// NLopt MAD C interface (see mad_nlopt.h)

typedef num_t (nlopt_obj_t)(u32_t n, const num_t *x, num_t *grad, void *data);
typedef void  (nlopt_cts_t)(u32_t m, num_t *res,
                            u32_t n, const num_t* x, num_t* grad, void* data);

struct nlopt_args {
  // algorithm
        int    algo;

  // objective function (required)
  nlopt_obj_t *fun;
        int    fdir; // 1: maximize, -1: minimize (default)
        num_t  fval;
        num_t  ftol;
        num_t  fstop;

  // state variables [n] (required)
        ssz_t  n;
        num_t *x;

  // initial value, step, tolerances and bounds [n] (optional)
  const num_t *x0;
  const num_t *xstp;
  const num_t *xtol;
        num_t  rtol;
  const num_t *xmin;
  const num_t *xmax;

  // equality constraints [p] (optional)
        ssz_t  p;
  nlopt_cts_t *efun;
        num_t *edat;
  const num_t *etol;

  // inequality constraints [q] (optional)
        ssz_t  q;
  nlopt_cts_t *lfun;
        num_t *ldat;
  const num_t *ltol;

  // stop criteria (if >0)
        int    maxcall;
        num_t  maxtime;

  // returned values
        int    status;
        int    ncall;
};
]]

-- NLopt supported algorithms (see nlopt.h) -----------------------------------o

--[[
Algorithm specs:
  id = C enum
  bd = support bounds constraints (f = require finite bounds)
  eq = support equality constraints (result == 0)
  le = support inequality constraints (result <= 0)
  gr = require explicit computation of gradient
  lo = require local optimiser specification (NYI)
  lg = require augmented lagrangian (NYI)
--]]

local nlopt_algo = {
  -- global optimisers without derivatives
  NLOPT_GN_CRS2_LM                 = { bd='f', eq='n', le='n', gr='n', lo='n' },
  NLOPT_GN_DIRECT                  = { bd='f', eq='n', le='n', gr='n', lo='n' },
  NLOPT_GN_DIRECT_L                = { bd='f', eq='n', le='n', gr='n', lo='n' },
  NLOPT_GN_DIRECT_L_NOSCAL         = { bd='f', eq='n', le='n', gr='n', lo='n' },
  NLOPT_GN_DIRECT_L_RAND           = { bd='f', eq='n', le='n', gr='n', lo='n' },
  NLOPT_GN_DIRECT_L_RAND_NOSCAL    = { bd='f', eq='n', le='n', gr='n', lo='n' },
  NLOPT_GN_DIRECT_NOSCAL           = { bd='f', eq='n', le='n', gr='n', lo='n' },
  NLOPT_GN_ESCH                    = { bd='f', eq='n', le='n', gr='n', lo='n' },
  NLOPT_GN_ISRES                   = { bd='f', eq='y', le='y', gr='n', lo='n' },
  NLOPT_GN_MLSL                    = { bd='f', eq='n', le='n', gr='n', lo='n' },
  NLOPT_GN_MLSL_LDS                = { bd='f', eq='n', le='n', gr='n', lo='n' },
  NLOPT_GN_ORIG_DIRECT             = { bd='f', eq='y', le='y', gr='n', lo='n' },
  NLOPT_GN_ORIG_DIRECT_L           = { bd='f', eq='y', le='y', gr='n', lo='n' },
  -- global optimisers with derivatives
  NLOPT_GD_MLSL                    = { bd='f', eq='n', le='n', gr='y', lo='n' },
  NLOPT_GD_MLSL_LDS                = { bd='f', eq='n', le='n', gr='y', lo='n' },
  NLOPT_GD_STOGO                   = { bd='f', eq='n', le='n', gr='y', lo='n' },
  NLOPT_GD_STOGO_RAND              = { bd='f', eq='n', le='n', gr='y', lo='n' },
  -- local optimisers without derivatives
  NLOPT_LN_AUGLAG                  = { bd='y', eq='y', le='y', gr='n', lo='n' },
  NLOPT_LN_AUGLAG_EQ               = { bd='y', eq='y', le='y', gr='n', lo='n' },
  NLOPT_LN_BOBYQA                  = { bd='y', eq='n', le='n', gr='n', lo='n' },
  NLOPT_LN_COBYLA                  = { bd='y', eq='y', le='y', gr='n', lo='n' }, -- default
  NLOPT_LN_NELDERMEAD              = { bd='y', eq='n', le='n', gr='n', lo='n' },
  NLOPT_LN_NEWUOA                  = { bd='y', eq='n', le='n', gr='n', lo='n' },
  NLOPT_LN_NEWUOA_BOUND            = { bd='y', eq='n', le='n', gr='n', lo='n' },
  NLOPT_LN_PRAXIS                  = { bd='y', eq='n', le='n', gr='n', lo='n' },
  NLOPT_LN_SBPLX                   = { bd='y', eq='n', le='n', gr='n', lo='n' },
  -- local optimisers with derivatives
  NLOPT_LD_AUGLAG                  = { bd='y', eq='y', le='y', gr='y', lo='n' },
  NLOPT_LD_AUGLAG_EQ               = { bd='y', eq='y', le='y', gr='y', lo='n' },
  NLOPT_LD_CCSAQ                   = { bd='y', eq='n', le='y', gr='y', lo='n' },
  NLOPT_LD_LBFGS                   = { bd='y', eq='n', le='n', gr='y', lo='n' },
  NLOPT_LD_LBFGS_NOCEDAL           = { bd='y', eq='n', le='n', gr='y', lo='n' },
  NLOPT_LD_MMA                     = { bd='y', eq='n', le='y', gr='y', lo='n' },
  NLOPT_LD_SLSQP                   = { bd='y', eq='y', le='y', gr='y', lo='n' },
  NLOPT_LD_TNEWTON                 = { bd='y', eq='n', le='n', gr='y', lo='n' },
  NLOPT_LD_TNEWTON_PRECOND         = { bd='y', eq='n', le='n', gr='y', lo='n' },
  NLOPT_LD_TNEWTON_PRECOND_RESTART = { bd='y', eq='n', le='n', gr='y', lo='n' },
  NLOPT_LD_TNEWTON_RESTART         = { bd='y', eq='n', le='n', gr='y', lo='n' },
  NLOPT_LD_VAR1                    = { bd='y', eq='n', le='n', gr='y', lo='n' },
  NLOPT_LD_VAR2                    = { bd='y', eq='n', le='n', gr='y', lo='n' },
  -- other cases
  NLOPT_AUGLAG                     = { bd='y', eq='y', le='y', gr='?', lo='y' },
  NLOPT_AUGLAG_EQ                  = { bd='y', eq='y', le='y', gr='?', lo='y' },
  NLOPT_G_MLSL                     = { bd='y', eq='n', le='n', gr='?', lo='y' },
  NLOPT_G_MLSL_LDS                 = { bd='y', eq='n', le='n', gr='?', lo='y' },
}
do
  local n=0
  for s,a in pairs(nlopt_algo) do a.id, n = assert(_C[s]), n+1 end
  assert(n == _C.NLOPT_NUM_ALGORITHMS, "unexpected missing NLOPT algorithm")
end

-- NLopt return code strings
local retstr = {
  -- generic failure code
  [_C.NLOPT_FAILURE         ] = 'NLOPT_FAILURE',
  [_C.NLOPT_INVALID_ARGS    ] = 'NLOPT_INVALID_ARGS',
  [_C.NLOPT_OUT_OF_MEMORY   ] = 'NLOPT_OUT_OF_MEMORY',
  [_C.NLOPT_ROUNDOFF_LIMITED] = 'NLOPT_ROUNDOFF_LIMITED',
  [_C.NLOPT_FORCED_STOP     ] = 'NLOPT_FORCED_STOP',
  -- generic success code
  [_C.NLOPT_SUCCESS         ] = 'NLOPT_SUCCESS',
  [_C.NLOPT_STOPVAL_REACHED ] = 'NLOPT_STOPVAL_REACHED',
  [_C.NLOPT_FTOL_REACHED    ] = 'NLOPT_FTOL_REACHED',
  [_C.NLOPT_XTOL_REACHED    ] = 'NLOPT_XTOL_REACHED',
  [_C.NLOPT_MAXEVAL_REACHED ] = 'NLOPT_MAXEVAL_REACHED',
  [_C.NLOPT_MAXTIME_REACHED ] = 'NLOPT_MAXTIME_REACHED',
}

-- expression default weights by kind -----------------------------------------o

local expr_weights = { -- default weight = 1
  x  = 10, px  = 100, y  = 10, py  = 100, t = 10, pt = 100,
  dx = 10, dpx = 100, dy = 10, dpy = 100,

  q1  = 10, q2  = 10, q3  = 10,
  mu1 = 10, mu2 = 10, mu3 = 10,
  alfa11 = 10, alfa22 = 10, alfa33 = 10,
}

-- summary --------------------------------------------------------------------o

local function disp_summ (env)
  local variables, equalities, inequalities, weights in env
  local var, arg = env.__var, env.__var.arg
  local n, p, q in arg[0]

  io.write"\nConstraints                Type        Kind        Weight     Penalty Value\n"
  io.write"-----------------------------------------------------------------------------\n"

  for i=1,p do
    local e = equalities[i]
    local w = weights[e.kind] or expr_weights[e.kind] or 1
    printf("%2d: % -22s % -11s % -10s % -10.5g % -.5e\n",
              i, e.name or 'unknown', 'equality', e.kind or '', w, var.edat[i])
  end

  for i=1,q do
    local e = inequalities[i]
    local w = weights[e.kind] or expr_weights[e.kind] or 1
    printf("%2d: % -22s % -11s % -10s % -10.5g % -.5e\n",
              i+p, e.name or 'unknown', 'inequality', e.kind or '', w, var.ldat[i])
  end

  io.write"\nVariables                  Final Value  Init. Value  Lower Limit  Upper Limit\n"
  io.write"-------------------------------------------------------------------------------\n"

  for i=1,n do
    local v = variables[i]
    printf("% -25s % -.5e % -.5e % -.5e % -.5e\n",
            v.var, var.x[i], var.x0[i], var.xmin[i], var.xmax[i])
  end

  printf("\nstatus=%s, fmin=% -.8e, ncall=%d\n\n",
            retstr[arg[0].status], arg[0].fval, arg[0].ncall)
end

-- callbacks ------------------------------------------------------------------o

local function nlopt_functions (env, mopt)
  local command, variables, objective, equalities, inequalities, weights in env

  assert(is_nil(objective.exec) or is_callable(objective.exec),
         "invalid objective (callable expected)")
  assert(is_nil(equalities.exec) or is_callable(equalities.exec),
         "invalid equality constraints (callable expected)")
  assert(is_nil(inequalities.exec) or is_callable(inequalities.exec),
         "invalid inequality constraints (callable expected)")

  local update = variables.update
  local var, arg = env.__var, env.__var.arg
  local x, edat, ldat in var
  local n, p, q in arg[0]

  -- nlopt objective function
  return objective.exec or \n_,x_,grad_ =>
    assert(n_ == n, "unexpected difference in number of variables")

    if grad_ ~= nil then -- TODO: add support for jacobian
      warn("unsupported request for jacobian in objective function (ignored)")
    end

    local es, ws = 0, 0

    -- iteration number
    arg[0].ncall = arg[0].ncall + 1

    -- update state variables
    if update then
      for i=1,n do x[i]=x_[i-1] end
      update(x, env)
    else
      var.flush = nil
      for i=1,n do variables[i].set(x_[i-1], env) end
      if var.flush then jit.flush() end
    end

    -- call user command
    local res = command(env)

    -- collect equalities
    for i=1,p do
      local expr, kind in equalities[i]
      local w = weights[kind] or expr_weights[kind] or 1
      edat[i] = expr(res, env)
      es = es + (w*edat[i])^2 ; ws = ws + w^2
    end

    -- collect inequalities
    for i=1,q do
      local expr, kind in inequalities[i]
      local w = weights[kind] or expr_weights[kind] or 1
      ldat[i] = expr(res, env)
      if ldat[i] > 0 then
        es = es + (w*ldat[i])^2 ; ws = ws + w^2
      end
    end

    -- return weighted mean of squares:
    -- 1/2 \sum_i (w_i cf_i(x))^2 / \sum_i w_i^2
    return 0.5 * es / ws
  end,

  -- nlopt equality function
  equalities.exec or
    (p>0 and mopt.eq == 'y' and \p_,r_ =>
        assert(p_ == p, "invalid number of equalities (unexpected)")
        for i=0,p-1 do r_[i] = edat.data[i] end
      end or nil),

  -- nlopt inequality function
  inequalities.exec or
    (q>0 and mopt.le == 'y' and \q_,r_ =>
        assert(q_ == q, "invalid number of inequalities (unexpected)")
        for i=0,q-1 do r_[i] = ldat.data[i] end
      end or nil)
end

-- getters/setters ------------------------------------------------------------o

local locfmt =
  "return \\f,env => local l = 2 \z
        return \\ => local info = debug.getinfo(l, 'f') \z
                     if not (info and info.func == f) then \z
                       l = nil \z
                       for i=2,1e6 do \z
                         info = debug.getinfo(i, 'f') \z
                         if not info then break end \z
                         if info.func == f then l=i ; break end \z
                       end ; assert(l, 'local variable not found') \z
                     end \z
                     local k, v = debug.getlocal(l, %d) \z
                     assert(k == '%s', 'invalid local variable getter') \z
                     return v end, \z
              \\x => local info = debug.getinfo(l, 'f') \z
                     if not (info and info.func == f) then \z
                       l = nil \z
                       for i=2,1e6 do \z
                         info = debug.getinfo(i, 'f') \z
                         if not info then break end \z
                         if info.func == f then l=i ; break end \z
                       end ; assert(l, 'local variable not found') \z
                     end \z
                     local k = debug.setlocal(l, %d, x) \z
                     assert(k == '%s', 'invalid local variable setter') \z
                     env.__var.flush = true end end"
local upvfmt =
  "return \\f,env (\\ => local k, v = debug.getupvalue(f, %d) \z
                         assert(k == '%s', 'invalid upvalue getter') \z
                         return v end, \z
                  \\x => local k = debug.setupvalue(f, %d, x) \z
                         assert(k == '%s', 'invalid upvalue setter') \z
                         env.__var.flush = true end)"

local wmsg =
  "write access to %s is very slow; use set, update or indirect (table) access"

local function accessors (variables, env)
  local loc, upv, ctx = {}, {}, getfenv(3)
  local fun = debug.getinfo(3, 'f').func
  local n = env.__var.x.nrow

  assert(ctx and fun, "unexpected invalid stack level")

  -- scan local variables (stack/registers)
  for i=1,1e6 do
    local k,v = debug.getlocal(3, i)
    if not k then break end
    loc[k], loc[i] = i, v -- top/bottom override (required!)
  end
  -- scan non-local variables (upvalues)
  for i=1,1e6 do
    local k,v = debug.getupvalue(fun, i)
    if not k then break end
    upv[k], upv[i] = i, v -- never override (unique!)
  end

--TODO: scan caller context only on need, i.e. on 1st use of loc or upv
--print("CTX") for k,v in pairs(ctx) do if is_string(k) then print(k,    v ) end end
--print("LOC") for k,v in pairs(loc) do if is_string(k) then print(k,loc[v]) end end
--print("UPV") for k,v in pairs(upv) do if is_string(k) then print(k,upv[v]) end end

  -- build variables getter/setter
  local wrn = not variables.update

  for i=1,n do
    local v = variables[i]
    if v.get and v.set then goto next end

    local var, fmt, get, set = v.var
    assertf(is_string(var), "invalid 'var' for variable #%d (string expected)", i)
    local obj, isep = strsplit(var, '.[')

    if loc[obj] then     -- local variable
      if isep > 0 then   -- local variable with indirection (safe, use obj)
        fmt = strfmt("return \\%s (\\ %s, \\__x => %s=__x end)", obj, var, var)
        get, set = assert(loadstring(fmt))()(loc[loc[obj]])

      else               -- local variable with direct access (need jit.flush!)
        if wrn and not v.set then warn(wmsg, "local variables") ; wrn=false end
        fmt = strfmt(locfmt, loc[obj], obj, loc[obj], obj)
        get, set = assert(loadstring(fmt))()(fun, env)
      end

    elseif upv[obj] then -- upvalue
      if isep > 0 then   -- upvalue variable with indirection (safe, use obj)
        fmt = strfmt("return \\%s (\\ %s, \\__x => %s=__x end)", obj, var, var)
        get, set = assert(loadstring(fmt))()(upv[upv[obj]])

      else               -- upvalue variable with direct access (need jit.flush!)
        if wrn and not v.set then warn(wmsg, "upvalues") ; wrn=false end
        fmt = strfmt(upvfmt, upv[obj], obj, upv[obj], obj)
        get, set = assert(loadstring(fmt))()(fun, env)
      end

    elseif ctx[obj] then -- caller context (safe, use ctx)
      fmt = strfmt("return \\__ctx (\\ __ctx.%s, \\__x => __ctx.%s=__x end)", var, var)
      get, set = assert(loadstring(fmt))()(ctx)

    else
      errorf("unable to build getter and setter (variable '%s' not found)", var)
    end

    v.get = v.get or get
    v.set = v.set or set

  ::next::
  end
end

-- match command --------------------------------------------------------------o

local function exec (self)
  local variables, objective, equalities, inequalities, weights in self
  local command = self:var_raw 'command' -- prevent evaluation

  -- check inputs
  assert(is_callable(command)     , "invalid match 'command' (callable expected)")
  assert(is_iterable(variables)   , "invalid match 'variables' (iterable expected)")
  assert(is_iterable(equalities)  , "invalid match 'equalities' (iterable expected)")
  assert(is_iterable(inequalities), "invalid match 'inequalities' (iterable expected)")
  assert(is_mappable(objective)   , "invalid match 'objective' (mappable expected)")
  assert(is_mappable(weights)     , "invalid match 'weights' (mappable expected)")

  -- check selected method
  local method = objective.method or 'NLOPT_LN_COBYLA' -- 'NLOPT_GN_ORIG_DIRECT_L'
  local mopt = assertf(nlopt_algo[method], "unknown optimisation method '%s'", method)

  -- local sizes
  local n = min(#variables, variables.nvar or 1e6)
  local p =     #equalities
  local q =     #inequalities

  -- check sizes compatiblity
  assert(n > 0, "invalid objective (variables expected)")

  -- matching environment
  local env = {
    command      = command,
    objective    = objective,
    variables    = variables,
    equalities   = equalities,
    inequalities = inequalities,
    weights      = weights,
    usrdef       = self.usrdef,
    __var  = { -- hidden variables
      x    = vector(n),
      x0   = vector(n),
      xstp = vector(n),
      xtol = vector(n),
      xmin = vector(n),
      xmax = vector(n),
      edat = p>0 and vector(p) or nil,
      etol = p>0 and vector(p) or nil,
      ldat = q>0 and vector(q) or nil,
      ltol = q>0 and vector(q) or nil,
      arg  = ffi.new 'nlopt_args_t[1]'
    },
  }

  -- create variables getter/setters (if needed)
  if is_nil(variables.init) and is_nil(variables.update) then
    accessors(variables, env)
  else
    assert(is_callable(variables.init) and is_callable(variables.update),
           "invalid pair init/update (callables expected)")
    variables.init(env.__var.x)
  end

  -- fill C struct
  local var, arg = env.__var, env.__var.arg

  arg[0].n       = n
  arg[0].p       = p
  arg[0].q       = q
  arg[0].algo    = mopt.id
  arg[0].fdir    = objective.dir or 1
  arg[0].ftol    = objective.tol or eps
  arg[0].fstop   = objective.stopval or -inf*arg[0].fdir
  arg[0].x       = var.x   .data
  arg[0].x0      = var.x0  .data
  arg[0].xstp    = var.xstp.data
  arg[0].xtol    = var.xtol.data
  arg[0].rtol    = variables.tol or eps
  arg[0].xmin    = var.xmin.data
  arg[0].xmax    = var.xmax.data
  arg[0].edat    = p>0 and var.edat.data or nil
  arg[0].etol    = p>0 and var.etol.data or nil
  arg[0].ldat    = q>0 and var.ldat.data or nil
  arg[0].ltol    = q>0 and var.ltol.data or nil
  arg[0].maxcall = objective.maxcall or 0
  arg[0].maxtime = objective.maxtime or 0

  -- state variables
  for i=1,n do
    local v = variables[i]
    var.x   [i] = v.get and v.get() or var.x[i]
    var.x0  [i] = var.x[i]
    var.xstp[i] = v.step or  0
    var.xtol[i] = v.tol  or  eps
    var.xmin[i] = v.min  or -inf
    var.xmax[i] = v.max  or  inf
    if var.xmin[i] > var.xmax[i] then
      var.xmin[i], var.xmax[i] = var.xmax[i], var.xmin[i]
    end
    if var.xmin[i] > var.x[i] then var.xmin[i] = var.x[i] end
    if var.xmax[i] < var.x[i] then var.xmax[i] = var.x[i] end
  end

  -- equality constraints
  for i=1,p do var.etol[i] = equalities[i].tol or eps end

  -- inequality constraints
  for i=1,q do var.ltol[i] = inequalities[i].tol or eps end

  -- nlopt callbacks
  local fun, efun, lfun = nlopt_functions (env, mopt)
  if  fun then  fun = ffi.cast('nlopt_obj_t*',  fun) ; arg[0]. fun =  fun end
  if efun then efun = ffi.cast('nlopt_cts_t*', efun) ; arg[0].efun = efun end
  if lfun then lfun = ffi.cast('nlopt_cts_t*', lfun) ; arg[0].lfun = lfun end

  -- optimize (protected call)
  local status, errmsg = pcall(_C.mad_nlopt, arg)

  -- release callback (note: callbacks are never collected)
  if  fun then  fun:free() end
  if efun then efun:free() end
  if lfun then lfun:free() end

  -- return status, fmin, ncall
  if status == false then
    warn("error '%s' occured during matching", errmsg)
    return retstr[arg[0].status], arg[0].status
  else
    if objective.summary then disp_summ(env) end
    return retstr[arg[0].status], arg[0].fval, arg[0].ncall
  end
end

local match = command 'match' {
  command      = fnil,  -- command to execute at each iteration
  variables    = {},    -- state variables
  objective    = {},    -- objective to minimize or maximize
  equalities   = {},    -- equalities constraints
  inequalities = {},    -- inqualities constraints
  weights      = {},    -- variables and constraints weights

  usrdef=nil,           -- user defined data attached to matching environment

  exec=exec,            -- command to execute upon children creation
} :set_readonly()       -- reference match command is readonly

-- end ------------------------------------------------------------------------o
return { match = match }
