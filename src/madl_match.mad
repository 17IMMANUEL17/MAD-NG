--[=[
 o-----------------------------------------------------------------------------o
 |
 | Match module
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - TODO

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local ffi = require 'ffi'

local _C, command, vector, warn in MAD
local is_rawtable               in MAD.typeid
local eps, inf                  in MAD.constant

-- types ----------------------------------------------------------------------o

ffi.cdef [[
// NLopt supported algorithms (see nlopt.h)
// see https://nlopt.readthedocs.io/en/latest/NLopt_Algorithms/ for details

enum {
/* Naming conventions:
  NLOPT_{G/L}{D/N}_* = global/local derivative/no-derivative optimization
  *_RAND algorithms involve some randomization.
  *_NOSCAL algorithms are *not* scaled to a unit hypercube
           (i.e. they are sensitive to the units of x)
*/
  NLOPT_GN_DIRECT = 0,
  NLOPT_GN_DIRECT_L,
  NLOPT_GN_DIRECT_L_RAND,
  NLOPT_GN_DIRECT_NOSCAL,
  NLOPT_GN_DIRECT_L_NOSCAL,
  NLOPT_GN_DIRECT_L_RAND_NOSCAL,

  NLOPT_GN_ORIG_DIRECT,
  NLOPT_GN_ORIG_DIRECT_L,

  NLOPT_GD_STOGO,
  NLOPT_GD_STOGO_RAND,

  NLOPT_LD_LBFGS_NOCEDAL,

  NLOPT_LD_LBFGS,

  NLOPT_LN_PRAXIS,

  NLOPT_LD_VAR1,
  NLOPT_LD_VAR2,

  NLOPT_LD_TNEWTON,
  NLOPT_LD_TNEWTON_RESTART,
  NLOPT_LD_TNEWTON_PRECOND,
  NLOPT_LD_TNEWTON_PRECOND_RESTART,

  NLOPT_GN_CRS2_LM,

  NLOPT_GN_MLSL,
  NLOPT_GD_MLSL,
  NLOPT_GN_MLSL_LDS,
  NLOPT_GD_MLSL_LDS,

  NLOPT_LD_MMA,

  NLOPT_LN_COBYLA,

  NLOPT_LN_NEWUOA,
  NLOPT_LN_NEWUOA_BOUND,

  NLOPT_LN_NELDERMEAD,
  NLOPT_LN_SBPLX,

  NLOPT_LN_AUGLAG,
  NLOPT_LD_AUGLAG,
  NLOPT_LN_AUGLAG_EQ,
  NLOPT_LD_AUGLAG_EQ,

  NLOPT_LN_BOBYQA,

  NLOPT_GN_ISRES,

/* new variants that require local_optimizer to be set */
  NLOPT_AUGLAG,
  NLOPT_AUGLAG_EQ,
  NLOPT_G_MLSL,
  NLOPT_G_MLSL_LDS,

  NLOPT_LD_SLSQP,

  NLOPT_LD_CCSAQ,

  NLOPT_GN_ESCH,

  NLOPT_NUM_ALGORITHMS /* not an algorithm, just the number of them */
};
]]

ffi.cdef[[
// NLopt return codes (see nlopt.h)

enum {
  NLOPT_FAILURE = -1, /* generic failure code */
  NLOPT_INVALID_ARGS = -2,
  NLOPT_OUT_OF_MEMORY = -3,
  NLOPT_ROUNDOFF_LIMITED = -4,
  NLOPT_FORCED_STOP = -5,

  NLOPT_SUCCESS = 1, /* generic success code */
  NLOPT_STOPVAL_REACHED = 2,
  NLOPT_FTOL_REACHED = 3,
  NLOPT_XTOL_REACHED = 4,
  NLOPT_MAXEVAL_REACHED = 5,
  NLOPT_MAXTIME_REACHED = 6
};
]]

ffi.cdef[[
// NLopt MAD C interface (see mad_nlopt.h)

typedef num_t (nlopt_obj_t)(u32_t n, const num_t *x, num_t *grad, void *data);
typedef void  (nlopt_cts_t)(u32_t m, num_t *res,
                            u32_t n, const num_t* x, num_t* grad, void* data);

struct nlopt_args {
  // algorithm
  int            algo;

  // objective function (required)
  nlopt_obj_t   *fn;
  int            fdir; // 1: maximize, -1: minimize (default)
  const num_t    ftol;
  const num_t    fstop;

  // state variables [n] (required)
  ssz_t          n;
  num_t         *x;
  const num_t   *xtol;
  const num_t   *xstp;

  // bound constraints [n] (optional)
  const num_t   *xmin;
  const num_t   *xmax;

  // equality constraints [p] (optional)
  ssz_t          p;
  nlopt_cts_t   *eq;
  const num_t   *etol;

  // inequality constraints [q] (optional)
  ssz_t          q;
  nlopt_cts_t   *le;
  const num_t   *ltol;

  // stop criteria (if >0)
  const int      maxcall;
  const num_t    maxtime;

  // returned values
  int            status;
  int            ncall;
  num_t          fval;
};
]]

-- variables default weights --------------------------------------------------o

local dft_weights = {
  x  = 10, px  = 100, y  = 10, py  = 100, t = 10, pt = 100,
  dx = 10, dpx = 100, dy = 10, dpy = 100,

  q1  = 10, q2  = 10,
  mu1 = 10, mu2 = 10,
  alfa11 = 10, alfa22 = 10, alfa33 = 10,
}

--- callbacks -----------------------------------------------------------------o

local function nlopt_callbacks (env)
  assert(is_rawtable(env), "unexpected missing environment")
  local command, variables, equalities, inequalities, weights in env
  local n, p, q in env.__arg
  local eq, le  in env.__res
  local nrm = 0.5/(n+p+q)

  -- nlopt objective function
  return \_, x, grad, data =>
    if grad ~= nil then
      warn("unsupported request for jacobian in objective function (ignored)")
    end

    if data ~= nil then
      error("unexpected user data in objective function (corrupted callback?)")
    end

    local err = 0

    -- iteration number
    env.__arg.ncall = env.__arg.ncall + 1

    -- update state variables
    for i=1,n do
      variables[i].set(x[i-1])
    end

    -- call user command
    local res = command(env)

    -- collect equalities
    for i=1,p do
      local name, expr in equalities[i]
      eq[i] = expr(res, env) or 0
      err = err + (eq[i] * (weights[name] or dft_weights[name] or 1))^2
    end

    -- collect inequalities
    for i=1,q do
      local name, expr in inequalities[i]
      le[i] = expr(res, env) or 0
      if le[i] > 0 then
        err = err + (le[i] * (weights[name] or dft_weights[name] or 1))^2
      end
    end

    -- return mean squares penalty 1/2 \sum_i f_i(x)^2
    return err * nrm
  end,

  -- nlopt equality function
  p > 0 and \_, res => for i=1,p do res[i-1] = eq[i] end end
        or  nil,

  -- nlopt inequality function
  q > 0 and \_, res => for i=1,q do res[i-1] = le[i] end end
        or  nil
end

-- match command --------------------------------------------------------------o

local function exec (self)
  local command, objective, variables, equalities, inequalities, weights in self

  -- TODO: checks!!!

  -- local sizes
  local n, p, q = #variables, #equalities, #inequalities

  -- matching environment
  local env = {
    command      = command,
    objective    = objective,
    variables    = variables,
    equalities   = equalities,
    inequalities = inequalities,
    weights      = weights,

    -- hidden variables
    __res = { x  =         vector(n),
              eq = p>0 and vector(p) or nil,
              le = q>0 and vector(q) or nil},
    __arg = ffi.new 'nlopt_args_t[1]',
  }

  local arg, res = env.__arg, env.__res

  -- problem sizes
  arg[0].n = n
  arg[0].p = p
  arg[0].q = q

  -- nlopt callbacks
  local fn, eq, le = nlopt_callbacks (env)
  if fn then fn = ffi.cast('nlopt_obj_t*', fn) end
  if eq then eq = ffi.cast('nlopt_cts_t*', eq) end
  if le then le = ffi.cast('nlopt_cts_t*', le) end

  -- algorithm
  arg[0].algo = _C[objective.method or 'NLOPT_GN_DIRECT_L']

  -- objective function (required)
  arg[0].fn    = fn
  arg[0].fdir  = objective.kind == 'max' and 1 or -1
  arg[0].ftol  = objective.tol or 0
  arg[0].fstop = objective.stopval or arg[0].fdir*inf

  -- vectors anchors
  local x, xtol, xmin, xmax, xstp, etol, ltol = res.x

  -- bound constraints and initial steps [n] (optional)
                     arg[0].x    = x.data
  xtol = vector(n) ; arg[0].xtol = xtol.data
  xmin = vector(n) ; arg[0].xmin = xmin.data
  xmax = vector(n) ; arg[0].xmax = xmax.data
  xstp = vector(n) ; arg[0].xstp = xstp.data

  for i=1,n do
    xtol[i] = variables[i].tol  or 0
    xmin[i] = variables[i].xmin or -inf
    xmax[i] = variables[i].xmax or  inf
    xstp[i] = variables[i].step or 1e-6
  end

  -- equality constraints [p] (optional)
  if p > 0 then
    etol = vector(p)
    for i=1,p do etol[i] = equalities[i].tol or eps end

    arg[0].eq   = eq
    arg[0].etol = etol.data
  end

  -- inequality constraints [q] (optional)
  if q > 0 then
    ltol = vector(q)
    for i=1,q do ltol[i] = inequalities[i].tol or 0 end

    arg[0].le   = le
    arg[0].ltol = ltol.data
  end

  -- stop criteria
  arg[0].maxcall = objective.maxcall or 0
  arg[0].maxtime = objective.maxtime or 0

  -- optimize (protected call)
  local status, errmsg = pcall(_C.mad_nlopt, arg)

  -- release callback (note: callbacks are never collected)
  if fn then fn:free() end
  if eq then eq:free() end
  if le then le:free() end

  if status then
    return status, errmsg
  end

  return arg[0].status, arg[0].fval, arg[0].ncall
end

local match = command 'match' {
  command      = nil, -- command to execute at each iteration (required)
  objective    = nil, -- objective to minimize or maximize (required)
  variables    = nil, -- state variables (required)
  equalities   = {},  -- equalities constraints (optional)
  inequalities = {},  -- inqualities constraints (optional)
  weights      = {},  -- variables and constraints weights (optional)

  exec=exec,          -- command to execute upon children creation
} :set_readonly()     -- reference match command is readonly

-- end ------------------------------------------------------------------------o
return { match = match }
