--[=[
 o-----------------------------------------------------------------------------o
 |
 | Match module
 |
 | Methodical Accelerator Design - Copyright (c) 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - TODO

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local ffi = require 'ffi'

local _C, command, vector, matrix, warn, option                  in MAD
local fnil                                                       in MAD.gfunc
local assertf, errorf, printf, strsplit, log2num                 in MAD.utility
local is_nil, is_string, is_iterable, is_mappable, is_callable   in MAD.typeid
local eps, inf                                                   in MAD.constant

local abs, sqrt, min, max in math

local strfmt = string.format

-- load nlopt lib wrapper -----------------------------------------------------o

local nlopt_librun = require 'madl_nlopt'

-- extend lib wrapper enums ---------------------------------------------------o

ffi.cdef [[
enum {
  /* extra status/return code from MAD */
  NLOPT_RUNNING = 0,
}
]]

ffi.cdef [[
enum {
 /* extra MAD algorithms */
  NLOPT_LN_LMDIF = NLOPT_NUM_ALGORITHMS, /* start where NLOPT stops */
  NLOPT_LD_LMDIF,

  NLOPT_LN_JACOBIAN,
  NLOPT_LD_JACOBIAN,

  NLOPT_NUM_ALGOS, /* not an algorithm, just the number of them */
}
]]

-- NLopt return code strings (see madl_nlopt) ---------------------------------o

local retstr = {
  -- generic failure code
  [_C.NLOPT_FAILURE         ] = 'FAILURE',
  [_C.NLOPT_INVALID_ARGS    ] = 'INVALID_ARGS',
  [_C.NLOPT_OUT_OF_MEMORY   ] = 'OUT_OF_MEMORY',
  [_C.NLOPT_ROUNDOFF_LIMITED] = 'ROUNDOFF_LIMITED',
  [_C.NLOPT_FORCED_STOP     ] = 'FORCED_STOP',
  -- generic success code
  [_C.NLOPT_SUCCESS         ] = 'SUCCESS',
  [_C.NLOPT_STOPVAL_REACHED ] = 'FMIN_REACHED',    -- MODIFIED
  [_C.NLOPT_FTOL_REACHED    ] = 'FTOL_REACHED',
  [_C.NLOPT_XTOL_REACHED    ] = 'XTOL_REACHED',
  [_C.NLOPT_MAXEVAL_REACHED ] = 'MAXCALL_REACHED', -- MODIFIED
  [_C.NLOPT_MAXTIME_REACHED ] = 'MAXTIME_REACHED',
  -- extra codes (check value with enum of nlopt return code!)
  [_C.NLOPT_RUNNING         ] = 'RUNNING',         -- ADDED
}

-- NLopt supported algorithms (see madl_nlopt) --------------------------------o

--[[
Algorithm specs:
  id = C enum
  bd = support bounds constraints (f = require finite bounds)
  eq = support equality constraints (result == 0)
  le = support inequality constraints (result <= 0)
  gr = require explicit computation of gradient
  lo = require local optimiser specification (NYI)
  lg = require augmented lagrangian (NYI)

Algorithm names:
  NLOPT_{G/L}{D/N}_* = global/local derivative/no-derivative optimization
  *_RAND algorithms involve some randomization.
  *_NOSCAL algorithms are *not* scaled to a unit hypercube
           (i.e. they are sensitive to the units of x)
--]]

local nlopt_algo = {
  -- global optimisers without derivatives
  GN_CRS2_LM                 = { bd='f', eq='n', le='n', gr='n', lo='n' },
  GN_DIRECT                  = { bd='f', eq='n', le='n', gr='n', lo='n' },
  GN_DIRECT_L                = { bd='f', eq='n', le='n', gr='n', lo='n' },
  GN_DIRECT_L_NOSCAL         = { bd='f', eq='n', le='n', gr='n', lo='n' },
  GN_DIRECT_L_RAND           = { bd='f', eq='n', le='n', gr='n', lo='n' },
  GN_DIRECT_L_RAND_NOSCAL    = { bd='f', eq='n', le='n', gr='n', lo='n' },
  GN_DIRECT_NOSCAL           = { bd='f', eq='n', le='n', gr='n', lo='n' },
  GN_ESCH                    = { bd='f', eq='n', le='n', gr='n', lo='n' },
  GN_ISRES                   = { bd='f', eq='y', le='y', gr='n', lo='n' },
  GN_MLSL                    = { bd='f', eq='n', le='n', gr='n', lo='n' },
  GN_MLSL_LDS                = { bd='f', eq='n', le='n', gr='n', lo='n' },
  GN_ORIG_DIRECT             = { bd='f', eq='y', le='y', gr='n', lo='n' },
  GN_ORIG_DIRECT_L           = { bd='f', eq='y', le='y', gr='n', lo='n' },
  -- global optimisers with derivatives
  GD_MLSL                    = { bd='f', eq='n', le='n', gr='y', lo='n' },
  GD_MLSL_LDS                = { bd='f', eq='n', le='n', gr='y', lo='n' },
  GD_STOGO                   = { bd='f', eq='n', le='n', gr='y', lo='n' },
  GD_STOGO_RAND              = { bd='f', eq='n', le='n', gr='y', lo='n' },
  -- local optimisers without derivatives
  LN_AUGLAG                  = { bd='y', eq='y', le='y', gr='n', lo='n' },
  LN_AUGLAG_EQ               = { bd='y', eq='y', le='y', gr='n', lo='n' },
  LN_BOBYQA                  = { bd='y', eq='n', le='n', gr='n', lo='n' },
  LN_COBYLA                  = { bd='y', eq='y', le='y', gr='n', lo='n' }, -- default
  LN_NELDERMEAD              = { bd='y', eq='n', le='n', gr='n', lo='n' },
  LN_NEWUOA                  = { bd='y', eq='n', le='n', gr='n', lo='n' },
  LN_NEWUOA_BOUND            = { bd='y', eq='n', le='n', gr='n', lo='n' },
  LN_PRAXIS                  = { bd='y', eq='n', le='n', gr='n', lo='n' },
  LN_SBPLX                   = { bd='y', eq='n', le='n', gr='n', lo='n' },
  -- local optimisers with derivatives
  LD_AUGLAG                  = { bd='y', eq='y', le='y', gr='y', lo='n' },
  LD_AUGLAG_EQ               = { bd='y', eq='y', le='y', gr='y', lo='n' },
  LD_CCSAQ                   = { bd='y', eq='n', le='y', gr='y', lo='n' },
  LD_LBFGS                   = { bd='y', eq='n', le='n', gr='y', lo='n' },
  LD_LBFGS_NOCEDAL           = { bd='y', eq='n', le='n', gr='y', lo='n' },
  LD_MMA                     = { bd='y', eq='n', le='y', gr='y', lo='n' },
  LD_SLSQP                   = { bd='y', eq='y', le='y', gr='y', lo='n' },
  LD_TNEWTON                 = { bd='y', eq='n', le='n', gr='y', lo='n' },
  LD_TNEWTON_PRECOND         = { bd='y', eq='n', le='n', gr='y', lo='n' },
  LD_TNEWTON_PRECOND_RESTART = { bd='y', eq='n', le='n', gr='y', lo='n' },
  LD_TNEWTON_RESTART         = { bd='y', eq='n', le='n', gr='y', lo='n' },
  LD_VAR1                    = { bd='y', eq='n', le='n', gr='y', lo='n' },
  LD_VAR2                    = { bd='y', eq='n', le='n', gr='y', lo='n' },
  -- other cases
  AUGLAG                     = { bd='y', eq='y', le='y', gr='?', lo='y' },
  AUGLAG_EQ                  = { bd='y', eq='y', le='y', gr='?', lo='y' },
  G_MLSL                     = { bd='y', eq='n', le='n', gr='?', lo='y' },
  G_MLSL_LDS                 = { bd='y', eq='n', le='n', gr='?', lo='y' },

  -- MAD algorithms
  LN_LMDIF                   = { bd='y', eq='y', le='y', gr='n', lo='n' },
  LD_LMDIF                   = { bd='y', eq='y', le='y', gr='y', lo='n' },
  LN_JACOBIAN                = { bd='y', eq='y', le='y', gr='n', lo='n' },
  LD_JACOBIAN                = { bd='y', eq='y', le='y', gr='y', lo='n' },
}

-- load nlopt lib wrapper -----------------------------------------------------o

do -- check integrity between nlopt_algo and NLOPT enums (from madl_nlopt)
  local ntot = _C.NLOPT_NUM_ALGOS
  local n, t = 0, table.new(ntot,0)
  for s,a in pairs(nlopt_algo) do
    a.id = assert(_C['NLOPT_'..s]) -- extend nlopt_algo rows with id attribute
    n = n+1 ; t[n] = a
  end
  assert(n == ntot, "unexpected missing NLOPT algorithm")
  -- fill array part with rows by id, starting at enum 0, i.e. len+1
  for i=1,n do nlopt_algo[t[i].id] = t[i] end
  assert(n == #nlopt_algo+1, "unexpected corrupted list of NLOPT algorithm")
end

-- expression default weights by kind -----------------------------------------o

local expr_weights = { -- default weight = 1
  x   = 10, px  = 100, y    = 10, py  = 100, t = 10, pt = 100,
  dx  = 10, dpx = 100, dy   = 10, dpy = 100,
  mux = 10, muy = 10 , alfx = 10, alfy = 10, -- MAD-X compatiblity

  q1  = 10, q2  = 10, q3  = 10,
  mu1 = 10, mu2 = 10, mu3 = 10,
  alfa11 = 10, alfa22 = 10, alfa33 = 10,
}

-- summary --------------------------------------------------------------------o

local function disp_summ (env)
  local variables, equalities, inequalities, weights in env
  local var = env.__var
  local n, p, q in var

  if p+q > 0 then
    io.write"\n Constraints                Type        Kind        Weight     Penalty Value\n"
    io.write"-----------------------------------------------------------------------------\n"

    for i=1,p do
      local e = equalities[i] or {}
      local w = e.weight or weights[e.kind] or expr_weights[e.kind] or 1
      printf("%2d: % -23s % -11s % -10s % -10.5g % -.7e\n",
                i, e.name or '', 'equality', e.kind or '.', w, var.eval[i])
    end

    for i=1,q do
      local e = inequalities[i] or {}
      local w = e.weight or weights[e.kind] or expr_weights[e.kind] or 1
      printf("%2d: % -23s % -11s % -10s % -10.5g % -.5e\n",
                i+p, e.name or '', 'inequality', e.kind or '.', w, var.lval[i])
    end
  end

  local s1, s2, v1, v2
  if var.status == _C.NLOPT_RUNNING
  then s1, s2, v1, v2 = 'Curr. Value', 'Curr. Step ', var.x, var.dx
  else s1, s2, v1, v2 = 'Final Value', 'Init. Value', var.x, var.x0 end

  printf("\n Variables                  %s  %s  Lower Limit  Upper Limit\n", s1, s2)
  io.write"-------------------------------------------------------------------------------\n"

  for i=1,n do
    printf(" % -25s % -.5e % -.5e % -.5e % -.5e\n",
            variables[i].var, v1[i], v2[i],
            max(var.xmin[i],-9.99999e99), min(var.xmax[i], 9.99999e99))
  end

  local fmt = "\n status=%s,  ncall=%2d,  fval=% -.7e,  fstp=% -.5e\n\n"
  printf(fmt, retstr[var.status], env.ncall, var.fval, var.fstp)
end

-- getters/setters ------------------------------------------------------------o

local locfmt = [[
  return \f,env => local vnam, vidx, lget, lset = '%s', %d
        return \ => local k, v = debug.getlocal(lget or 3, vidx)
                    if not lget or k ~= vnam then
                      for i=3,1e6 do
                        local info = debug.getinfo(i, 'f')
                        if not info then break end
                        if info.func == f then lget=i ; break end
                      end ; assert(lget, 'local variable not found in getter')
                      k, v = debug.getlocal(lget, vidx)
                    end
                    -- print('lget=', lget)
                    assert(k == vnam, 'invalid local variable in getter')
                    return v
                  end,
              \x => local k = debug.setlocal(lset or 7, vidx, x)
                    if not lset or k ~= vnam then
                      for i=7,1e6 do
                        local info = debug.getinfo(i, 'f')
                        if not info then break end
                        if info.func == f then lset=i ; break end
                      end ; assert(lset, 'local variable not found in setter')
                      k = debug.setlocal(lset, vidx, x)
                    end
                    -- print('lset=', lset)
                    assert(k == vnam, 'invalid local variable in setter')
                    env.__var.flush = env.__var.fjit
                  end
                end ]]

local upvfmt = [[
  return \f,env => local vnam, vidx = '%s', %d
        return \ => local k, v = debug.getupvalue(f, vidx)
                    assert(k == vnam, 'invalid upvalue in getter')
                    return v
                  end,
              \x => local k = debug.setupvalue(f, vidx, x)
                    assert(k == vnam, 'invalid upvalue in setter')
                    env.__var.flush = env.__var.fjit
                  end
                end ]]

local wmsg =
  "write access to %s is very slow; use set, update or indirect (table) access"

local function accessors (env)
  local loc, upv, ctx = {}, {}, getfenv(3)
  local fun = debug.getinfo(3, 'f').func

  assert(ctx and fun, "unexpected invalid stack level")

  -- scan local variables of the caller
  for i=1,1e6 do
    local k,v = debug.getlocal(3, i)
    if not k then break end
    loc[k], loc[i] = i, v -- top/bottom override (required!)
  end
  -- scan upvalues of the caller
  for i=1,1e6 do
    local k,v = debug.getupvalue(fun, i)
    if not k then break end
    upv[k], upv[i] = i, v -- never override (unique!)
  end

--print("LOC") for k,v in pairs(loc) do if is_string(k) then print(k,loc[v]) end end
--print("UPV") for k,v in pairs(upv) do if is_string(k) then print(k,upv[v]) end end

  -- build variables getter/setter
  local variables in env
  local wrn = not (variables.nowarn or variables.update)
  local n in env.__var

  for i=1,n do
    local v = variables[i]
    if v.get and v.set then goto next end

    local var, fmt, get, set = v.var
    assertf(is_string(var), "invalid 'var' for variable #%d (string expected)", i)
    local nam, isep = strsplit(var, '.[')

    if loc[nam] then     -- local variable
      if isep > 0 then   -- local variable with indirect access
        fmt = strfmt("return \\%s (\\ %s, \\__x => %s=__x end)", nam, var, var)
        get, set = assert(loadstring(fmt))()(loc[loc[nam]])

      else               -- local variable with direct access (need jit.flush!)
        if wrn and not v.set then warn(wmsg, "local variables") ; wrn=false end
        fmt = strfmt(locfmt, nam, loc[nam])
        get, set = assert(loadstring(fmt))()(fun, env)
      end

    elseif upv[nam] then -- upvalue
      if isep > 0 then   -- upvalue with indirect access
        fmt = strfmt("return \\%s (\\ %s, \\__x => %s=__x end)", nam, var, var)
        get, set = assert(loadstring(fmt))()(upv[upv[nam]])

      else               -- upvalue with direct access (need jit.flush!)
        if wrn and not v.set then warn(wmsg, "upvalues") ; wrn=false end
        fmt = strfmt(upvfmt, nam, upv[nam])
        get, set = assert(loadstring(fmt))()(fun, env)
      end

    elseif ctx[nam] then -- caller context
      fmt = strfmt("return \\__ctx (\\ __ctx.%s, \\__x => __ctx.%s=__x end)", var, var)
      get, set = assert(loadstring(fmt))()(ctx)

    else
      errorf("unable to build '%s' getter and setter (variable not found)", var)
    end

    v.get = v.get or assert(get)
    v.set = v.set or assert(set)

  ::next::
  end
end

-- optimizer functions --------------------------------------------------------o

-- print matrix (debug helper)
local function dspmat(mat, nam)
  local fmt = option.numfmt;
  option.numfmt = "% -.5e" ; mat:print(nam) ; option.numfmt = fmt
end

-- invalid variable domain (helper)
local function invalid_dom (env)
  local var = env.__var

  var.fval, var.fstp = inf, inf
  if var.p>0 then var.eval:ones(inf) end
  if var.q>0 then var.lval:ones(inf) end
end

-- update variables (helper)
local function update_vars (env)
  local variables in env
  local var = env.__var
  local x in var

  if variables.update then
    variables.update(x, env)
  else
    var.flush = nil
    for i=1,x.nrow do variables[i].set(x[i], env) end
    if var.flush then jit.flush() end -- TODO: avoid jit flush
  end
end

-- compute cost function value - sqrt(\sum_i w_i c_i(x)^2 / \sum_i w_i)
local function compute_fval (env)
  local command, equalities, inequalities in env

  local res = command(env) -- call user command (e.g. twiss)
  if is_nil(res) then return end

  local var = env.__var
  local eval, etol, ewgt, lval, ltol, lwgt in var

  local fval = 0
  for i=1,var.p do
    eval[i] = equalities[i].expr(res, env)
    if abs(eval[i]) > etol[i] then fval = fval + ewgt[i]*eval[i]^2 end
  end
  for i=1,var.q do
    lval[i] = inequalities[i].expr(res, env)
    if lval[i] > ltol[i] then fval = fval + lwgt[i]*lval[i]^2 end
  end

  return sqrt(fval / var.fwgt)
end

-- cost functions factory
local function nlopt_functions (env)
  local objective, equalities, inequalities in env

  assert(is_nil(objective.exec) or is_callable(objective.exec),
         "invalid objective (callable expected)")
  assert(is_nil(equalities.exec) or is_callable(equalities.exec),
         "invalid equality constraints (callable expected)")
  assert(is_nil(inequalities.exec) or is_callable(inequalities.exec),
         "invalid inequality constraints (callable expected)")

  local var = env.__var
  local n, p, q, x, fgrd, eval, ejac, lval, ljac, method in var
  local grad = method.gr == 'y'

  return -- objective, equalities and inequalities functions

  -- objective function
  function()
    -- update variables
    update_vars(env)

    -- reset gradient (and jac.)
    if grad then
      fgrd:zeros()
      if p>0 then ejac:zeros() end
      if q>0 then ljac:zeros() end
    end

    env.ncall = env.ncall + 1

    local fval
    if objective.exec
    then fval = objective.exec(x, fgrd)            -- call user defined function
    else fval = compute_fval(env)                  -- compute objective function
    end

    if fval == nil then invalid_dom(env) ; goto skip end

    -- backup values
    var.fval, var.fstp = fval, fval-var.fval

   if grad and env.debug >= 2 then dspmat(fgrd,"GRAD-F") end

 ::skip::

    -- display intermediate summary
    if var.sumdisp > 0 then disp_summ(env) end

    -- check for stopping
    if var.status ~= _C.NLOPT_RUNNING then
      if env.debug >= 1 then io.write("nlopt: forced to stop\n") end
      var.final(env)
    end

    -- return objective function value
    return var.fval
  end,

  -- equality function
  method.eq == 'y' and p>0 and
  function()
    if equalities.exec then
      equalities.exec(x, eval, ejac)               -- call user defined function
    end
    if grad and env.debug >= 2 then dspmat(ejac,"JACOBIAN-EQ") end
  end or nil,

  -- inequality function
  method.le == 'y' and q>0 and
  function()
    if inequalities.exec then
      inequalities.exec(x, lval, ljac)             -- call user defined function
    end
    if grad and env.debug >= 2 then dspmat(ljac,"JACOBIAN-LE") end
  end or nil
end

-- match command --------------------------------------------------------------o

local function exec (self)
  local variables, equalities, inequalities, weights, objective in self
  local command = self:var_raw 'command' or fnil -- prevent evaluation

  -- check inputs
  assert(is_callable(command)     , "invalid match 'command' (callable expected)")
  assert(is_mappable(variables)   , "invalid match 'variables' (iterable expected)")
  assert(is_mappable(equalities)  , "invalid match 'equalities' (iterable expected)")
  assert(is_mappable(inequalities), "invalid match 'inequalities' (iterable expected)")
  assert(is_mappable(weights)     , "invalid match 'weights' (mappable expected)")
  assert(is_mappable(objective)   , "invalid match 'objective' (mappable expected)")

  -- check selected method
  local mthd = objective.method or 'LN_COBYLA' -- 'GN_ORIG_DIRECT_L'
  local mopt = assertf(nlopt_algo[mthd], "unknown optimisation method '%s'", mthd)

  -- check summary level
  local summ = objective.summary or false
  local ndsp = assertf(log2num(summ), "invalid summary '%s'", tostring(summ))

  -- check debug level
  local dbug = objective.debug or false
  local ndbg = assertf(log2num(dbug), "invalid debug '%s'", tostring(dbug))

  -- local sizes
  local n =    variables.nvar or #variables
  local p =   equalities.nequ or #equalities
  local q = inequalities.nequ or #inequalities

  -- check sizes compatiblity
  assert(n > 0, "invalid objective (variables expected)")

  -- matching environment
  local env = {
    ncall        = 0,
    debug        = ndbg,        -- debug level, can be changed during iterations
    command      = command,
    objective    = objective,
    variables    = variables,
    equalities   = equalities,
    inequalities = inequalities,
    weights      = weights,
    usrdef       = self.usrdef,

    __var  = { -- hidden variables
      n    = n,                            -- number of variables
      x    = vector(n),                    -- variables values
      dx   = vector(n),                    -- variables steps
      x0   = vector(n),                    -- variables initial values
      xstp = vector(n),                    -- variables initial steps
      xmin = vector(n),                    -- variables minimum bounds
      xmax = vector(n),                    -- variables maximum bounds
      xwgt = vector(n),                    -- variables weights
      xtol = vector(n),                    -- variables tolerances
      xrtol= variables.rtol or 0,          -- variables relative tolerance

      p    = p,                            -- number of equalities
      efun = nil,                          -- equalities function (see above)
      eval = p>0 and vector(p)   or nil,   -- equalities values
      ewgt = p>0 and vector(p)   or nil,   -- equalities weights
      etol = p>0 and vector(p)   or nil,   -- equalities tolerances
!     etmp = p>0 and vector(p)   or nil,   -- equalities temporary values
      ejac = p>0 and matrix(n,p) or nil,   -- equalities jacobian

      q    = q,                            -- number of inequalities
      lfun = nil,                          -- inequalities function (see above)
      lval = q>0 and vector(q)   or nil,   -- inequalities values
      lwgt = q>0 and vector(q)   or nil,   -- inequalities weights
      ltol = q>0 and vector(q)   or nil,   -- inequalities tolerances
!     ltmp = q>0 and vector(q)   or nil,   -- inequalities temporary values
      ljac = q>0 and matrix(n,q) or nil,   -- inequalities jacobian

      fun  = nil,                          -- cost function (see above)
      fval = inf,                          -- cost function value (dummy init)
      fstp = 0,                            -- cost function current step
      fwgt = 0,                            -- cost function weights sum
      fgrd = vector(n),                    -- cost function gradient
      fmin = objective.fmin or -inf,       -- cost function minimum (target)
      ftol = objective.tol  or 0,          -- cost function tolerance (target)
      frtol= objective.rtol or 0,          -- cost function relative tolerance (target)

      method  = mopt,                      -- algorithm method (nlopt_algo row)
      sumdisp = ndsp,                      -- algorithm summary level
      maxcall = objective.maxcall or 1e9,  -- algorithm call limit
      maxtime = objective.maxtime or 0,    -- algorithm time limit
      final   = fnil,                      -- algorithm finalizer
      status  = _C.NLOPT_RUNNING,          -- algorithm status
      errmsg  = nil,                       -- algorithm error message
      fjit    = false,                     -- JIT must be flushed (C API)
    },
  }

  local var = env.__var

  -- create variables getter/setters (if needed)
  if is_nil(variables.init) and is_nil(variables.update) then
    accessors(env)
  else
    assert(is_callable(variables.init) and is_callable(variables.update),
           "invalid variables init and/or update (callables expected)")
    variables.init(var.x0)
  end

  -- state variables
  for i=1,n do
    local v = variables[i] or {}
    if v.get then var.x0[i] = v.get() end
    var.x   [i] = var.x0[i]
    var.xstp[i] = v.step   or variables.step or 0
    var.xtol[i] = v.tol    or variables.tol  or 0
    var.xwgt[i] = v.weight or variables.wgt  or 0
    var.xmin[i] = v.min    or variables.min  or -inf
    var.xmax[i] = v.max    or variables.max  or  inf

    if var.xmin[i] > var.xmax[i] then
      var.xmin[i], var.xmax[i] = var.xmax[i], var.xmin[i]
    end
    if v.sign or variables.sign then
          if var.x[i] > 0 and var.xmin[i] < 0 then var.xmin[i] = 0
      elseif var.x[i] < 0 and var.xmax[i] > 0 then var.xmax[i] = 0 end
    end
    if var.x[i] < var.xmin[i] or var.x[i] > var.xmax[i] then
      warn("invalid initial value %d (out of bounds)", i)
    end
!    if var.xstp[i] == 0 then -- to review
!      var.xstp[i] = var.x[i] ~= 0 and 0.015625*abs(var.x[i]) or 1e-6
!    end
  end

  if env.debug >= 2 then var.xstp:print("\nX-STEP0") end

  -- equality constraints
  for i=1,p do
    local e = equalities[i] or {}
    var.etol[i] = abs(e.tol or equalities.tol or 0)
    var.ewgt[i] = abs(e.weight or weights[e.kind] or expr_weights[e.kind] or 1)
    var.fwgt    = var.fwgt + var.ewgt[i]
  end

  -- inequality constraints
  for i=1,q do
    local e = inequalities[i] or {}
    var.ltol[i] = e.tol or inequalities.tol or 0
    var.lwgt[i] = abs(e.weight or weights[e.kind] or expr_weights[e.kind] or 1)
    var.fwgt    = var.fwgt + var.lwgt[i]
  end

  -- adjust weights
  if var.fwgt == 0 then var.fwgt = 1 end

  -- build optimizer functions
  var.fun, var.efun, var.lfun = nlopt_functions(env)

  -- call optimiser
  local status, errmsg = var.method.id < _C.NLOPT_NUM_ALGORITHMS and
                         nlopt_librun(env) or error("NYI")

  -- display error or final summary
  if status == false then
    warn("error '%s' occured during matching", errmsg)
  elseif var.sumdisp > 0 then disp_summ(env) end

  -- return status, fmin, ncall
  return retstr[var.status], var.fval, env.ncall
end

local match = command 'match' {
  -- command to execute at each iteration (i.e. call command(env))
  command = nil,
  -- state variables
  variables = {
  ! { var=nil, step=nil, min=nil, max=nil, sign=nil, tol=nil, get=nil, set=nil },
     nvar=nil, step=nil, min=nil, max=nil, sign=nil, tol=nil, rtol=nil,
     init=nil, update=nil,
  },
  -- equalities constraints
  equalities = {
  ! {expr=nil, name=nil, kind=nil, weight=nil, tol=nil},
     nequ=nil, exec=nil,                       tol=nil,
  },
  -- inequalities constraints
  inequalities = {
  ! {expr=nil, name=nil, kind=nil, weight=nil, tol=nil},
     nequ=nil, exec=nil,                       tol=nil,
  },
  -- constraints weights (i.e. weights[kind])
  weights = {},
  -- objective to minimize or maximize
  objective = {
    method=nil, fmin=nil, tol=nil, rtol=nil,
    exec=nil, maxtime=nil, maxcall=nil, summary=nil, debug=nil,
  },

  usrdef=nil,           -- user defined data attached to matching environment

  exec=exec,            -- command to execute upon children creation
} :set_readonly()       -- reference match command is readonly

-- end ------------------------------------------------------------------------o
return { match = match }
