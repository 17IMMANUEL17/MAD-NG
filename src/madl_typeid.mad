--[=[
 o-----------------------------------------------------------------------------o
 |
 | Generic type identification module
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide a set of function to identify types
  - Includes duck typing checks (i.e. concept checks)

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

-- Note: this module is used by MAD env, hence it cannot rely on MAD env.

local ffi = require 'ffi'
local bit = require 'bit'

local band, rol       in bit
local typeof, miscmap in ffi
local abs, huge       in math

local tostring, type, getmetatable = tostring, type, getmetatable

-- implementation -------------------------------------------------------------o

-- metatables & metamethods

assert(miscmap, "missing MAD extension (no cdata metatable access)")

local metaname = {
  -- list of metanames from lj_obj.h
  -- + copy + exec + init + kpairs + same + totable
  '__add', '__call', '__concat', '__copy', '__div', '__eq', '__exec', '__gc',
  '__index', '__init', '__ipairs', '__kpairs', '__le', '__len', '__lt',
  '__metatable', '__mod', '__mode', '__mul', '__new', '__newindex', '__pairs',
  '__pow', '__same', '__sub', '__tostring', '__totable', '__unm',
}
for _,v in ipairs(metaname) do metaname[v] = v end -- build dict of metaname

local function invalid_use (a)
  error("invalid use of object <"..tostring(a)..">", 2)
end

local function get_metatable (a)
  return type(a) == 'cdata' and miscmap[-tonumber(typeof(a))] or getmetatable(a)
end

local function has_metatable (a)
  return not not get_metatable(a)
end

local function get_metamethod (a, f)
  local mt = get_metatable(a)
  return mt and rawget(mt,f)
end

local function has_metamethod (a, f)
  local mt = get_metatable(a)
  local mm = mt and rawget(mt,f)
  return not not mm and mm ~= invalid_use
end

local function has_metamethod2 (a, f, f2)
  local mt = get_metatable(a)
  local mm = mt and (rawget(mt,f) or rawget(mt,f2))
  return not not mm and mm ~= invalid_use
end

--[[
Metaflags notes:
----------------
- not_indexable prevents to read at keys *not already defined*.
- not_scannable prevents all forms of scan (index and {i,k,}pairs).
- not_extendable prevents to write at keys *not already defined*.
- not_mutable set the metatable of the metable as not_extendable.
]]

local metaflags = {               --       1,     2,        4,        8,      16
  not_indexable  = 1,             -- __index,      ,         ,         ,
  not_iterable   = 2+4,           --        , __len, __ipairs,         ,
  not_keyrable   = 8+16,          --        ,      ,         , __kpairs, __pairs
  not_mappable   = 2+4+8+16,      --        , __len, __ipairs, __kpairs, __pairs
  not_scannable  = 1+2+4+8+16,    -- __index, __len, __ipairs, __kpairs, __pairs
  not_extendable = 2^5,           -- __newindex

  not_orderable    = 2^6+2^7,     -- __lt, __le
  not_comparable   = 2^6+2^7+2^8, -- __lt, __le, __eq
  not_callable     = 2^9,         -- __call
  not_concatenable = 2^10,        -- __concat
  not_copiable     = 2^11+2^12,   -- __copy, __same
  not_mutable      = 2^13,        -- __metatable
}

local metaflags_keys = {
  '__index', '__len', '__ipairs', '__kpairs', '__pairs', -- not_scannable
  '__newindex',                                          -- not_extendable
  '__lt', '__le', '__eq',                                -- not_comparable
   '__call',                                             -- not_callable
   '__concat',                                           -- not_concatable
  '__copy', '__same',                                    -- not_copiable
  '__metatable',                                         -- not_mutable
}
for _,v in ipairs(metaflags_keys) do
  metaflags_keys[v] = invalid_use
  if v == '__newindex' then break end -- nil is enough after __newindex
end

local not_extendable, not_mutable in metaflags

local function set_metamethod (mt, flags, strict_)
  local mt = mt or {}
  assert(mt.__metatable == nil, "invalid argument #1 (mutable metatable expected)")
  for i,v in ipairs(metaflags_keys) do
    if band(flags, rol(1, i-1)) ~= 0 and (mt[v] == nil or strict_ == false) then
--    print('flags=', v, metaflags_keys[v])
      mt[v] = metaflags_keys[v]
    end
  end
  if band(flags, not_mutable) ~= 0 then
    mt.__metatable = mt
    setmetatable(mt, {__newindex=invalid_use, __metatable=false})
  end
  return mt
end

setmetatable(metaflags, set_metamethod({}, not_extendable + not_mutable))

--[[
Classification of primitive types:
----------------------------------
- nil  : can be shared, cannot be modified (but may contain shared states).
- true : can be only copied.
- false: can be shared, can be modified.
]]

local typeclass = {
  -- false
  table = false,
  -- true
  ['nil'] = true,  boolean = true, number = true, string = true,
  -- nil
  ['function'] = nil, lightuserdata = nil, userdata = nil, thread = nil,
    cdata = nil,
}

local typeid = {
  -- classification of types

  typeclass = typeclass,

  -- classification of concepts

  metaflags = metaflags,

  is_metaname = \a -> metaname[a] == a,

  -- primitive types

  is_nil         = \a -> type(a) == 'nil',
  is_boolean     = \a -> type(a) == 'boolean',
  is_number      = \a -> type(a) == 'number',
  is_string      = \a -> type(a) == 'string',
  is_function    = \a -> type(a) == 'function',
  is_table       = \a -> type(a) == 'table',
  is_userdata    = \a -> type(a) == 'userdata',
  is_coroutine   = \a -> type(a) == 'thread',
  is_cdata       = \a -> type(a) == 'cdata',

  -- specialisations

  is_true        = \a -> rawequal(a, true ),
  is_false       = \a -> rawequal(a, false),

  is_nan         = \a -> type(a) == 'number' and a ~= a,
  is_finite      = \a -> type(a) == 'number' and abs(a) <  huge,
  is_infinite    = \a -> type(a) == 'number' and abs(a) == huge,
  is_positive    = \a -> type(a) == 'number' and a > 0,
  is_negative    = \a -> type(a) == 'number' and a < 0,
  is_integer     = \a -> type(a) == 'number' and a >= -2^52 and a <= 2^52 and (a%1) == 0,

  is_emptystring = \a -> type(a) == 'string' and a == '',

  is_rawtable    = \a -> type(a) == 'table'  and rawequal(getmetatable(a),nil),
  is_emptytable  = \a -> type(a) == 'table'  and rawequal(next        (a),nil),

  is_file        = \a -> io.type(a) ~= nil,
  is_emptyfile   = \a -> io.type(a) ~= nil   and a:seek('end') == 0,

  is_value       = \a -> typeclass[type(a)],

  -- metamethods

  get_metatable  = get_metatable,
  has_metatable  = has_metatable,
  get_metamethod = get_metamethod,
  has_metamethod = has_metamethod,
  set_metamethod = set_metamethod,

  -- concepts

  is_indexable    = \a -> has_metamethod(a,'__index' )   or type(a) == 'table',
  is_iterable     = \a -> has_metamethod(a,'__ipairs')   or type(a) == 'table',
  is_keyrable     = \a -> has_metamethod(a,'__kpairs')   or type(a) == 'table',
  is_mappable     = \a -> has_metamethod(a,'__pairs' )   or type(a) == 'table',
  is_extendable   = \a -> has_metamethod(a,'__newindex') or type(a) == 'table',
  is_lengthable   = \a ->                                   type(a) == 'string' or
                          has_metamethod(a,'__len'   )   or type(a) == 'table',

  is_orderable    = \a -> type(a) == 'number'   or
                          type(a) == 'string'   or has_metamethod2(a,'__le','__lt'),
  is_comparable   = \a -> type(a) == 'number'   or
                          type(a) == 'string'   or has_metamethod(a,'__eq'    ),
  is_callable     = \a -> type(a) == 'function' or has_metamethod(a,'__call'  ),
  is_concatenable = \a -> type(a) == 'string'   or has_metamethod(a,'__concat'),
  is_copiable     = \a ->                          has_metamethod(a,'__copy'  ),
  is_sameable     = \a ->                          has_metamethod(a,'__same'  ),
  is_mutable      = \a ->                          has_metamethod(a,'__metametable'),

  -- concepts for conversion

  is_tablable     = \a ->                          has_metamethod(a,'__totable' ),
  is_stringable   = \a ->                          has_metamethod(a,'__tostring'),

  -- concepts for numeric

  is_negatable    = \a -> type(a) == 'number'   or has_metamethod(a,'__unm'),
  is_addable      = \a -> type(a) == 'number'   or has_metamethod(a,'__add'),
  is_subtractable = \a -> type(a) == 'number'   or has_metamethod(a,'__sub'),
  is_multipliable = \a -> type(a) == 'number'   or has_metamethod(a,'__mul'),
  is_dividable    = \a -> type(a) == 'number'   or has_metamethod(a,'__div'),
  is_modulable    = \a -> type(a) == 'number'   or has_metamethod(a,'__mod'),
  is_powerable    = \a -> type(a) == 'number'   or has_metamethod(a,'__pow'),

  -- concepts for objects

  is_constructible = \a -> has_metamethod(a,'__new'),
  is_collectable   = \a -> has_metamethod(a,'__gc' ), -- not supported by LJ 2.1

  -- concepts for containers

  is_empty         = \a ->             has_metamethod(a,'__pairs') and
                              rawequal(get_metamethod(a,'__pairs')(a),nil)
                           or type(a) == 'table' and rawequal(next(a),nil),

  -- comparison of types
  is_same = \a,b -> type(a) == type(b) and get_metatable(a) == get_metatable(b),

  -- members

  has_member = \a,b -> ((has_metamethod(a,'__index') or type(a) == 'table') and
                                                        not rawequal(a[b], nil)),
  -- methods = callable members

  has_method = \a,b -> ((has_metamethod(a,'__index') or type(a) == 'table') and
                    (type(a[b]) == 'function' or has_metamethod(a[b],'__call'))),
}

-- end ------------------------------------------------------------------------o
return {
  typeid = typeid,
  __help = require 'madh_typeid',
}
