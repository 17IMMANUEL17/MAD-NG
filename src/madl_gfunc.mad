--[=[
 o-----------------------------------------------------------------------------o
 |
 | Generic functional module
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide a set of generic functions for functional programming.

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local is_nil, is_function, is_table, is_callable, wprotect,
      set_metamethod, concept                                      in MAD.typeid
local not_scannable, not_extendable, not_mutable                   in concept

local select = select

-- implementation -------------------------------------------------------------o

local gfunc = {

  ident   = \... -> ...,             -- identity
  narg    = \... -> select('#',...), -- number of arguments
  fnil    = \    -> nil,             -- functional nil
  ftrue   = \    -> true,            -- functional true
  ffalse  = \    -> false,           -- functional false
  forget  = \    -> (),              -- forget argument(s)
  first   = \a   -> a,               -- 1st argument only
  second  = \a,b -> b,               -- 2nd argument only
  swap    = \a,b -> (b,a),           -- swap #1 and #2 arguments, discard others
  swapv   = \a,b,... -> (b,a,...),   -- swap #1 and #2 arguments, keep others

}

-- functors

-- hidden keys
local _fun, _fun2, _arg, _arg2 = {}, {}, {}, {}

-- forward declarations
local fct_mt, fct_mtc, fct_mtb1, fct_mtb2, fct_mtb12

function gfunc.functor (f)
  assert(is_callable(f), "invalid argument #1 (callable expected)")
  return setmetatable({[_fun]=f}, fct_mt)
end

function gfunc.compose (f, g)
  assert(is_callable(f), "invalid argument #1 (callable expected)")
  assert(is_callable(g), "invalid argument #2 (callable expected)")
  return setmetatable({[_fun]=f, [_fun2]=g}, fct_mtc)
end

function gfunc.bind1st (f, a)
  assert(is_callable(f), "invalid argument #1 (callable expected)")
  return setmetatable({[_fun]=f, [_arg]=a}, fct_mtb1)
end

function gfunc.bind2nd (f, a)
  assert(is_callable(f), "invalid argument #1 (callable expected)")
  return setmetatable({[_fun]=f, [_arg]=a}, fct_mtb2)
end

function gfunc.bind2st (f, a, b)
  assert(is_callable(f), "invalid argument #1 (callable expected)")
  return setmetatable({[_fun]=f, [_arg]=a, [_arg2]=b}, fct_mtb12)
end

function gfunc.is_functor (a)
  return is_table(a) and rawget(a,_fun) ~= nil
end

local str = \s -> string.format("functor: %p", s)

fct_mt = set_metamethod({
  __pow       = gfunc.compose,
  __call      = \s,... -> rawget(s,_fun)(...),
  __index     = \s,k -> s(k),
  __tostring  = str,
}, not_scannable + not_extendable + not_mutable)

fct_mtc = set_metamethod({
  __pow       = gfunc.compose,
  __call      = \s,... -> rawget(s,_fun)(rawget(s,_fun2)(...)),
  __index     = \s,k -> s(k),
  __tostring  = str,
}, not_scannable + not_extendable + not_mutable)

fct_mtb1 = set_metamethod({
  __pow       = gfunc.compose,
  __call      = \s,... -> rawget(s,_fun)(rawget(s,_arg), ...),
  __index     = \s,k -> s(k),
  __tostring  = str,
}, not_scannable + not_extendable + not_mutable)

fct_mtb2 = set_metamethod({
  __pow       = gfunc.compose,
  __call      = \s,a,... -> rawget(s,_fun)(a, rawget(s,_arg), ...),
  __index     = \s,k -> s(k),
  __tostring  = str,
}, not_scannable + not_extendable + not_mutable)

fct_mtb12 = set_metamethod({
  __pow       = gfunc.compose,
  __call      = \s,... -> rawget(s,_fun)(rawget(s,_arg), rawget(s,_arg2), ...),
  __index     = \s,k -> s(k),
  __tostring  = str,
}, not_scannable + not_extendable + not_mutable)

-- bottom definition uses metatables (must be after)
gfunc.bottom = gfunc.functor(gfunc.ident)
gfunc._      = gfunc.bottom -- alias

-- env ------------------------------------------------------------------------o

MAD.typeid.is_functor = gfunc.is_functor

gfunc = wprotect(setmetatable(gfunc, {__tostring := "MAD.gfunc"}))

-- end ------------------------------------------------------------------------o
return {
  gfunc  = gfunc,
  __help = require 'madh_gfunc',
}
