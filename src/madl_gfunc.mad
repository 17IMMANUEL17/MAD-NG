--[=[
 o-----------------------------------------------------------------------------o
 |
 | Generic functional module
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide a set of generic functions for functional programming.

 o-----------------------------------------------------------------------------o
]=]

-- help -----------------------------------------------------------------------o

local __help = {}
__help.gfunc = [=[
NAME
  gfunc -- provide generic functions for functional programming

SYNOPSIS
  functor, is_functor,
  ident, first, second, swap, repeater, compose, compose_bottom,
  foreach, map, map2, map3, foldl, foldr, filter.

DESCRIPTION
  The gfunc module provides useful utility functions:
  - ident is the identity function.
  - first, second and swap return arguments #1, #2 and #2 #1 respectively
    (i.e. #1 #2 swapped).
  - gen TODO
  - rep returns a sequence holding the same element n-times (or inf).
  - compose composes two callable objects.
  - compose_bottom allows to compose (right to left) callable objects using ^.
  - TODO

RETURN VALUES
  These utility functions.

ERRORS
  Functors constructor trigs an error if the argument #1 is not a function.

SEE ALSO
  Object.
]=]

-- locals ---------------------------------------------------------------------o

local tostring = tostring

local is_nil, is_function, is_table in MAD.typeid
local is_callable                   in MAD.concept

-- implementation -------------------------------------------------------------o

local gfunc = {

  ident   = \... -> ...,
  forget  = \    -> (),
  first   = \a   -> (a),
  second  = \a,b -> (b),
  swap    = \a,b -> (b,a),

}

-- functors

local _key, _key2, _nk2, _arg, _idx = {}, {}, {}, {}, {} -- hidden keys
local fct_mt, fct_mt2, fct_mtb, fct_mb1, fct_mtb2        -- forward declarations

function gfunc.functor (f)
  assert(is_callable(f), "invalid argument #1 (callable expected)")
  return setmetatable({[_key]=f}, fct_mt)
end

function gfunc.compose (f, g)
  assert(is_callable(f), "invalid argument #1 (callable expected)")
  assert(is_callable(g), "invalid argument #2 (callable expected)")
  return setmetatable({[_key]=f, [_key2]=g}, fct_mt2)
end

function gfunc.bind (f, ...)
  assert(is_callable(f), "invalid argument #1 (callable expected)")
  local n = select('#',...)
  return setmetatable({[_key]=f, [_key2]={...}, [_arg]=table.new(n,0),
                       [_nk2]=n}, fct_mtb)
end
function gfunc.bind1st (f, a)
  assert(is_callable(f), "invalid argument #1 (callable expected)")
  return setmetatable({[_key]=f, [_key2]=a}, fct_mtb1)
end

function gfunc.bind2nd (f, a)
  assert(is_callable(f), "invalid argument #1 (callable expected)")
  return setmetatable({[_key]=f, [_key2]=a}, fct_mtb2)
end

function gfunc.is_functor (a)
  return is_table(a) and rawget(a,_key) ~= nil
end

function gfunc.is_placeholder (a)
  return is_table(a) and rawget(a,_idx) ~= nil
end

local str = \s -> string.format("<functor> %p", s)
local err = \  -> error "forbidden access to functor"

fct_mt = {
  __pow       = gfunc.compose,
  __call      = \s,... -> rawget(s,_key)(...),
  __tostring  = str,
  __len = err, __index = err, __newindex = err, __ipairs = err, __pairs = err,
}

fct_mt2 = {
  __pow       = gfunc.compose,
  __call      = \s,... -> rawget(s,_key)(rawget(s,_key2)(...)),
  __tostring  = str,
  __len = err, __index = err, __newindex = err, __ipairs = err, __pairs = err,
}

fct_mtb1 = {
  __pow       = gfunc.compose,
  __call      = \s,... -> rawget(s,_key)(rawget(s,_key2), ...),
  __tostring  = str,
  __len = err, __index = err, __newindex = err, __ipairs = err, __pairs = err,
}

fct_mtb2 = {
  __pow       = gfunc.compose,
  __call      = \s,a,... -> rawget(s,_key)(a, rawget(s,_key2), ...),
  __tostring  = str,
  __len = err, __index = err, __newindex = err, __ipairs = err, __pairs = err,
}

gfunc._1 = {[_idx]=1}
gfunc._2 = {[_idx]=2}
gfunc._3 = {[_idx]=3}
gfunc._4 = {[_idx]=4}
gfunc._5 = {[_idx]=5}
gfunc._6 = {[_idx]=6}
gfunc._7 = {[_idx]=7}
gfunc._8 = {[_idx]=8}
gfunc._9 = {[_idx]=9}

local is_placeholder in gfunc

local function bindcall(s, ...) -- slow (faster solution?)
  local nb , argb = rawget(s,_nk2), rawget(s,_key2)
  local arg, argc = rawget(s,_arg), {...}
  for i=1,nb do
    if is_placeholder(argb[i]) then
      arg[i] = argc[argb[i][_idx]]
    else
      arg[i] = argb[i]
    end
  end
  return rawget(s,_key)(unpack(arg))
end

fct_mtb = {
  __pow       = gfunc.compose,
  __call      = bindcall,
  __tostring  = str,
  __len = err, __index = err, __newindex = err, __ipairs = err, __pairs = err,
}

gfunc.bottom = gfunc.functor(gfunc.ident)
gfunc._      = gfunc.bottom

__help['gfunc.functor'] = [=[
NAME
  functor           -- encapsulate a callable into a functor
  compose           -- compose two callables into a functor
  bind              -- bind a callable non placeholder arguments into a functor
  bind1st           -- bind a callable 1st argument into a functor
  bind2nd           -- bind a callable 2nd argument into a functor
  bottom or _       -- functor that trigs chain of composition
  is_functor        -- check if the argument is a functor
  is_placeholder    -- check if the argument is a placeholder
  _1,_2,...,_9      -- placeholders

SYNOPSIS
  functor(fun)
  compose(fun1, fun2)
  bind(fun, arg|_N)
  bind1st(fun, arg)
  bind2nd(fun, arg)
  is_functor(val)
  is_placeholder(val)

DESCRIPTION
  The functor function is a constructor that encapsulates true functions into
  functors (i.e. some special readonly objects that behaves like functions). It
  is used by the object model (i.e. set_function) to avoid the default
  function-as-value semantic. The is_functor function checks if a value is a
  functor.

RETURN VALUES
  The functor function returns the functor object that encapsulates the function
  func. The is_functor function returns true if val is a functor, false
  otherwise.

ERRORS
  The functor function trigs an error if argument #1 is not a valid function.

EXAMPLES
  local obj = Object {}
    : set_variable { hello := print"hello" }
    : set_function { world := print"world" }
  print( is_functor(obj.hello) )               -- false (print "hello" too)
  print( is_functor(obj.world) )               -- true  (no extra print)
  a = obj.hello                                -- print "hello"
  obj.world()                                  -- print "world"
  obj.hello = functor \ print"hello"           -- set variable with a functor
  print( is_functor(obj.hello) )               -- true  (no extra print)
  obj.hello()                                  -- print "hello"

SEE ALSO
  Object.
]=]
__help['gfunc.compose']         = __help['gfunc.functor']
__help['gfunc.bind']            = __help['gfunc.functor']
__help['gfunc.bind1st']         = __help['gfunc.functor']
__help['gfunc.bind2nd']         = __help['gfunc.functor']
__help['gfunc.bottom']          = __help['gfunc.functor']
__help['gfunc.is_functor']      = __help['gfunc.functor']
__help['gfunc.is_placeholder']  = __help['gfunc.functor']
__help['typeid.is_functor']     = __help['gfunc.functor']
__help['typeid.is_placeholder'] = __help['gfunc.functor']
__help['gfunc._']               = __help['gfunc.functor']
__help['gfunc._1']              = __help['gfunc.functor']
__help['gfunc._2']              = __help['gfunc.functor']
__help['gfunc._3']              = __help['gfunc.functor']
__help['gfunc._4']              = __help['gfunc.functor']
__help['gfunc._5']              = __help['gfunc.functor']
__help['gfunc._6']              = __help['gfunc.functor']
__help['gfunc._7']              = __help['gfunc.functor']
__help['gfunc._8']              = __help['gfunc.functor']
__help['gfunc._9']              = __help['gfunc.functor']

-- env ------------------------------------------------------------------------o

MAD.typeid.is_functor     = gfunc.is_functor
MAD.typeid.is_placeholder = gfunc.is_placeholder

-- end ------------------------------------------------------------------------o
return {
  gfunc  = gfunc,
  __help = __help,
}

