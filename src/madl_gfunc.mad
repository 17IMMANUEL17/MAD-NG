--[=[
 o-----------------------------------------------------------------------------o
 |
 | Generic functional module
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide a set of generic functions for functional programming.

 o-----------------------------------------------------------------------------o
]=]

-- help -----------------------------------------------------------------------o

local __help = {}
__help.gfunc = [=[
NAME
  gfunc -- provide generic functions for functional programming

SYNOPSIS
  functor, is_functor,
  ident, forget, first, second, swap, swapv, compose, compose_bottom,
  bind1st, bind2nd, bind2st.

DESCRIPTION
  The gfunc module provides useful utility functions:
  - ffalse and ftrue return false and true respectively.
  - ident is the identity function.
  - forget drop its arguments.
  - first, second and swap return arguments #1, #2 and #2 #1 respectively
    (i.e. #1 #2 swapped). swapv is identical to swap but keep the extra
    arguments.
  - compose composes two callable objects.
  - compose_bottom allows to compose (right to left) callable objects using ^.
  - bind1st, bind2nd, bind2st allow to bind 1st, 2nd or both arguments to a
    callable. It is faster than creating a new closure with bounded upvalues.

ERRORS
  Functors constructor trigs an error if the argument #1 is not a callable.

SEE ALSO
  Object.
]=]

-- locals ---------------------------------------------------------------------o

local tostring = tostring

local is_nil, is_function, is_table in MAD.typeid
local is_callable                   in MAD.concept

-- implementation -------------------------------------------------------------o

local gfunc = {

  ffalse  = \        -> false,       -- functional false
  ftrue   = \        -> true,        -- functional true
  ident   = \...     -> ...,         -- identity
  forget  = \        -> (),          -- forget argument(s)
  first   = \a       -> (a),         -- 1st argument only
  second  = \a,b     -> (b),         -- 2nd argument only
  swap    = \a,b     -> (b,a),       -- swap #1 and #2 arguments, discard others
  swapv   = \a,b,... -> (b,a,...),   -- swap #1 and #2 arguments, keep others

}

-- functors

-- hidden keys
local _fun, _fun2, _arg, _arg2 = {}, {}, {}, {}
-- forward declarations
local fct_mt, fct_mtc, fct_mb1, fct_mtb2, fct_mtb12

function gfunc.functor (f)
  assert(is_callable(f), "invalid argument #1 (callable expected)")
  return setmetatable({[_fun]=f}, fct_mt)
end

function gfunc.compose (f, g)
  assert(is_callable(f), "invalid argument #1 (callable expected)")
  assert(is_callable(g), "invalid argument #2 (callable expected)")
  return setmetatable({[_fun]=f, [_fun2]=g}, fct_mtc)
end

function gfunc.bind1st (f, a)
  assert(is_callable(f), "invalid argument #1 (callable expected)")
  return setmetatable({[_fun]=f, [_arg]=a}, fct_mtb1)
end

function gfunc.bind2nd (f, a)
  assert(is_callable(f), "invalid argument #1 (callable expected)")
  return setmetatable({[_fun]=f, [_arg]=a}, fct_mtb2)
end

function gfunc.bind2st (f, a, b)
  assert(is_callable(f), "invalid argument #1 (callable expected)")
  return setmetatable({[_fun]=f, [_arg]=a, [_arg2]=b}, fct_mtb12)
end

function gfunc.is_functor (a)
  return is_table(a) and not is_nil(rawget(a,_fun))
end

local str = \s -> string.format("<functor> %p", s)
local err = \  -> error("forbidden access to functor", 2)

fct_mt = {
  __pow       = gfunc.compose,
  __call      = \s,... -> rawget(s,_fun)(...),
  __index     = \s,k -> s(k),
  __tostring  = str,
  __len = err, __newindex = err, __ipairs = err, __pairs = err,
}

fct_mtc = {
  __pow       = gfunc.compose,
  __call      = \s,... -> rawget(s,_fun)(rawget(s,_fun2)(...)),
  __index     = \s,k -> s(k),
  __tostring  = str,
  __len = err, __newindex = err, __ipairs = err, __pairs = err,
}

fct_mtb1 = {
  __pow       = gfunc.compose,
  __call      = \s,... -> rawget(s,_fun)(rawget(s,_arg), ...),
  __index     = \s,k -> s(k),
  __tostring  = str,
  __len = err, __newindex = err, __ipairs = err, __pairs = err,
}

fct_mtb2 = {
  __pow       = gfunc.compose,
  __call      = \s,a,... -> rawget(s,_fun)(a, rawget(s,_arg), ...),
  __index     = \s,k -> s(k),
  __tostring  = str,
  __len = err, __newindex = err, __ipairs = err, __pairs = err,
}

fct_mtb12 = {
  __pow       = gfunc.compose,
  __call      = \s,... -> rawget(s,_fun)(rawget(s,_arg), rawget(s,_arg2), ...),
  __index     = \s,k -> s(k),
  __tostring  = str,
  __len = err, __newindex = err, __ipairs = err, __pairs = err,
}

gfunc.bottom = gfunc.functor(gfunc.ident)
gfunc._      = gfunc.bottom -- alias

__help['gfunc.functor'] = [=[
NAME
  is_functor        -- check if the argument is a functor
  functor           -- encapsulate a callable into a functor
  compose           -- compose two callables into a functor
  bind1st           -- bind a callable first argument into a functor
  bind2nd           -- bind a callable second argument into a functor
  bind2st           -- bind a callable two first arguments into a functor
  bottom or _       -- functor that trigs chain of composition

SYNOPSIS
  is_functor(val)
  functor(fun)
  compose(fun1, fun2)
  bind1st(fun, arg)
  bind2nd(fun, arg)
  bind2st(fun, arg1, arg2)

DESCRIPTION
  The functor function is a constructor that encapsulates true functions into
  functors (i.e. some special readonly objects that behaves like functions). It
  is used by the object model (i.e. set_functions) to avoid the default
  function-as-value semantic of the object model. The is_functor function checks
  if a value is a functor.

RETURN VALUES
  The functor function returns the functor object that encapsulates the function
  func. The is_functor function returns true if val is a functor, false
  otherwise.

ERRORS
  The functor function trigs an error if argument #1 is not a valid function.

EXAMPLES
  local obj = Object {}
    : set_variables { hello := print"hello" }
    : set_functions { world := print"world" }
  print( is_functor(obj.hello) )               -- false (print "hello" too)
  print( is_functor(obj.world) )               -- true  (no extra print)
  a = obj.hello                                -- print "hello"
  obj.world()                                  -- print "world"
  obj.hello = functor \ print"hello"           -- set variable with a functor
  print( is_functor(obj.hello) )               -- true  (no extra print)
  obj.hello()                                  -- print "hello"

SEE ALSO
  Object.
]=]
__help['typeid.is_functor']     = __help['gfunc.functor']
__help['gfunc.is_functor']      = __help['gfunc.functor']
__help['gfunc.compose']         = __help['gfunc.functor']
__help['gfunc.bind1st']         = __help['gfunc.functor']
__help['gfunc.bind2nd']         = __help['gfunc.functor']
__help['gfunc.bind2st']         = __help['gfunc.functor']
__help['gfunc.bottom']          = __help['gfunc.functor']
__help['gfunc._']               = __help['gfunc.functor']

-- env ------------------------------------------------------------------------o

MAD.typeid.is_functor = gfunc.is_functor

-- end ------------------------------------------------------------------------o
return {
  gfunc  = gfunc,
  __help = __help,
}

