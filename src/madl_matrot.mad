--[=[
 o-----------------------------------------------------------------------------o
 |
 | Matrix rotation module
 |
 | Methodical Accelerator Design - Copyright CERN 2015+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Extends the matrix module with matrix of rotations.

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local abs, sin, cos in MAD

-- helpers --------------------------------------------------------------------o

local function chk2d(x)
  assert(x:nrow() == 2 and x:ncol() == 2,
         "invalid argument #1 (2D squared matrix expected)")
  return x
end

local function chk3d(x)
  assert(x:nrow() == 3 and x:ncol() == 3,
         "invalid argument #1 (3D squared matrix expected)")
  return x
end

-- rotations ------------------------------------------------------------------o

return {

-- 2D rotation

rot = function (x, a)
  local c, s = cos(a), sin(a)
  return chk2d(x):fill { c, -s,
                         s,  c }
end,

-- 3D rotations (one axis)

rotx = function (x, ax)
  local c, s = cos(ax), sin(ax)
  return chk3d(x):fill { 1, 0, 0,
                         0, c,-s,
                         0, s, c }
end,

roty = function (x, ay)
  local c, s = cos(ay), sin(ay)
  return chk3d(x):fill { c, 0, s,
                         0, 1, 0,
                        -s, 0, c }
end,

rotz = function (x, az)
  local c, s = cos(az), sin(az)
  return chk3d(x):fill { c,-s, 0,
                         s, c, 0,
                         0, 0, 1 }
end,

-- 3D rotations (two axis)

rotxy = function (x, ax, ay)
  local cx, sx = cos(ax), sin(ax)
  local cy, sy = cos(ay), sin(ay)
  return chk3d(x):fill { cy, sx*sy, cx*sy,
                          0,    cx,   -sx,
                        -sy, sx*cy, cx*cy }
end,

rotxz = function (x, ax, az)
  local cx, sx = cos(ax), sin(ax)
  local cz, sz = cos(az), sin(az)
  return chk3d(x):fill { cz,-cx*sz, sx*sz,
                         sz, cx*cz,-sx*cz,
                          0,    sx,    cx }
end,

rotyz = function (x, ay, az)
  local cy, sy = cos(ay), sin(ay)
  local cz, sz = cos(az), sin(az)
  return chk3d(x):fill { cy*cz,-sz, sy*cz,
                         cy*sz, cz, sy*sz,
                           -sy,  0,    cy }
end,

rotyx = function (x, ay, ax)
  local cx, sx = cos(ax), sin(ax)
  local cy, sy = cos(ay), sin(ay)
  return chk3d(x):fill {    cy,  0,    sy,
                         sx*sy, cx,-sx*cy,
                        -cx*sy, sx, cx*cy }
end,

rotzx = function (x, az, ax)
  local cx, sx = cos(ax), sin(ax)
  local cz, sz = cos(az), sin(az)
  return chk3d(x):fill {    cz,   -sz,  0,
                         cx*sz, cx*cz,-sx,
                         sx*sz, sx*cz, cx }
end,

rotzy = function (x, az, ay)
  local cy, sy = cos(ay), sin(ay)
  local cz, sz = cos(az), sin(az)
  return chk3d(x):fill { cy*cz,-cy*sz, sy,
                            sz,    cz,  0,
                        -sy*cz, sy*sz, cy }
end,

-- 3D rotations (three axis)

rotxyz = function (x, ax, ay, az)
  local cx, sx = cos(ax), sin(ax)
  local cy, sy = cos(ay), sin(ay)
  local cz, sz = cos(az), sin(az)
  return chk3d(x):fill {
    cy*cz, sx*sy*cz - cx*sz, cx*sy*cz + sx*sz,
    cy*sz, sx*sy*sz + cx*cz, cx*sy*sz - sx*cz,
      -sy,            sx*cy,            cx*cy }
end,

-- 3D rotations (vector)

rotv = function (x, uv, av)
  assert(uv:isa_vector() and uv:size() == 3 and abs(uv:norm()-1) < 1e-12,
         "invalid argument #2 (unit vector expected)")
  local ux, uy, uz = uv:_geti0(0), uv:_geti0(1), uv:_geti0(2)
  local xx, yy, zz = ux*ux, uy*uy, uz*uz
  local xy, xz, yz = ux*uy, ux*uz, uy*uz
  local c, s = cos(av), sin(av)
  local C    = 1-c
  return chk3d(x):fill {
    xx*C +    c, xy*C - uz*s, xz*C + uy*s,
    xy*C + uz*s, yy*C +    c, yz*C - ux*s,
    xz*C - uy*s, yz*C + ux*s, zz*C +    c }
end,

}
