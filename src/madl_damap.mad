--[=[
 o-----------------------------------------------------------------------------o
 |
 | DA Maps module
 |
 | Methodical Accelerator Design - Copyright (c) 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provides full set of functions and operations on damap and cdamap.
  - Support real and complex scalars and GTPSA as inhomogeneous variables.

 o-----------------------------------------------------------------------------o
]=]

local MR, MC = {}, {}

-- locals ---------------------------------------------------------------------o

local ffi = require 'ffi'

local abs, min, max, floor in math
local round                in MAD.gmath

local _C, option, warn                                               in MAD
local gtpsad, tpsa, ctpsa, vector, cvector, matrix, cmatrix, complex in MAD

local openfile                                                    in MAD.utility

local is_nil, is_boolean, is_number, is_integer, is_complex, is_scalar,
      is_table, is_string, is_indexable, is_iterable, is_mappable,
      is_vector, is_cvector, isa_vector, is_matrix, is_cmatrix,
      is_tpsa, is_ctpsa, wprotect                                 in MAD.typeid

local type, assert, getmetatable, setmetatable, rawequal, rawset, tostring =
      type, assert, getmetatable, setmetatable, rawequal, rawset, tostring

local string, table =
      string, table

-- types ----------------------------------------------------------------------o

local   int_arr = ffi.typeof           'int [?]'
local  tpsa_arr = ffi.typeof 'struct  tpsa* [?]'
local ctpsa_arr = ffi.typeof 'struct ctpsa* [?]'

-- names ----------------------------------------------------------------------o

-- default variable names (and indexes)
local cvname = {
  {'x'                            , x=1                            , __n=1},
  {'x', 'px'                      , x=1, px=2                      , __n=2},
  {'x', 'px', 'pt'                , x=1, px=2,                 pt=3, __n=3},
  {'x', 'px', 'y', 'py'           , x=1, px=2, y=3, py=4           , __n=4},
  {'x', 'px', 'y', 'py', 'pt'     , x=1, px=2, y=3, py=4,      pt=5, __n=5},
  {'x', 'px', 'y', 'py', 't', 'pt', x=1, px=2, y=3, py=4, t=5, pt=6, __n=6},
}

-- protected version exported
local wcvname = wprotect {
  wprotect( cvname[1] ),
  wprotect( cvname[2] ),
  wprotect( cvname[3] ),
  wprotect( cvname[4] ),
  wprotect( cvname[5] ),
  wprotect( cvname[6] ),
}

-- variables ------------------------------------------------------------------o

local function cvname_dup (vn)
  local n = #vn
  local cvn = table.new(n, n+1)
  for i=1,n do cvn[i], cvn[vn[i]] = vn[i], i end
  cvn.__n = n
  return cvn
end

-- identity -------------------------------------------------------------------o

local _idr, _idc = {}, {} -- identity

MR.__obj = _idr
MC.__obj = _idc

local function is_damap (a)
  local mt = getmetatable(a)
  return mt ~= nil and mt.__obj == _idr
end

local function is_cdamap (a)
  local mt = getmetatable(a)
  return mt ~= nil and mt.__obj == _idc
end

local function isa_damap (a)
  local mt = getmetatable(a)
  return mt ~= nil and (mt.__obj == _idr or mt.__obj == _idc)
end

-- ctors ----------------------------------------------------------------------o

local function map_alloc (td, vn, mt)
  local nn = min(#vn, td.nn)
  local ct = mt == MR and tpsa or ctpsa
  local ta = mt == MR and tpsa_arr(td.nn) or ctpsa_arr(td.nn)
  local mv = table.new(td.nn, nn+3) -- + __ta, __td, __vn

  for i=1,td.nv do       -- create variables
    mv[i] = ct(td, td.no[i-1]) ; ta[i-1] = mv[i]
  end

  for i=td.nv+1,td.nn do -- create parameters
    mv[i] = ct(td, 1) ; ta[i-1] = mv[i]:set(i+1,0,1)
  end

  for i=1,nn do          -- create named access
    mv[vn[i]] = mv[i] ; mv[i]:setnam(vn[i])
  end

  mv.__ta, mv.__td, mv.__vn = ta, td, vn

  return setmetatable({__var=mv}, mt)
end

local function map_ctor (arg, mt)
  -- specification of damap by variables orders.
  if arg.mo or arg.no then
    local td = gtpsad(arg)
    local vn = arg.vn and cvname_dup(arg.vn) or cvname[min(td.nv,6)]
    return map_alloc(td, vn, mt)
  end

  -- specification of damap by planes orders (6D damap).
  local xy = arg.xy or 1
  local pt = arg.pt or xy
  local t  = arg.t  or pt
  local vn = arg.vn and cvname_dup(arg.vn) or cvname[6]

  local np = arg.np or 0
  local po = np > 0 and (arg.po or 1) or 0
  local nv, mo, no

  if pt == xy and t == xy then
    -- homogeneous planes
    nv, mo = 6, xy
  else
    -- heterogeneous planes
    nv, mo, no = 6, max(xy,t,pt), {xy, xy, xy, xy, t, pt}
    for i=1,np do no[6+i] = po end
  end

  local td = gtpsad{nv=nv, mo=mo, np=np, no=no, po=po}
  return map_alloc(td, vn, mt)
end

--[=[
  arg content:
    - planes orders: .nv=n or 6, .xy=o or 2, .pt=o or xy
    - otherwise same as gtpsad{}.
--]=]

local function damap (arg)
  arg = arg or {}
  assert(is_mappable(arg), "invalid argument #1 (mappable expected)")
  return map_ctor(arg, MR):eye()
end

local function cdamap (arg)
  arg = arg or {}
  assert(is_mappable(arg), "invalid argument #1 (mappable expected)")
  return map_ctor(arg, MC):eye()
end

-- maxord, maxlen, gtrunc -----------------------------------------------------o

MR.nv     = \x     -> x[1]:nv()
MR.np     = \x     -> x[1]:np()
MR.maxord = \x     -> x[1]:maxord()
MR.maxlen = \x     -> x[1]:maxlen()
MR.ordlen = \x,mo_ -> x[1]:ordlen(mo_)
MR.gtrunc = \x,to_ -> x[1]:gtrunc(to_)

-- same, copy, clear ----------------------------------------------------------o

function MR.__same (x, y_, e_)
  if is_nil(e_) and is_scalar(y_) then -- shift right
    e_, y_ = y_
  end
  assert(is_nil(y_) or isa_damap(y_), "invalid argument #2 (damap expected)")
  return map_alloc(x.__td, x.__vn, (is_complex(e_) or is_cdamap(y_)) and MC or MR)
end

function MC.__same (x, y_, e_)
  if is_nil(e_) and is_scalar(y_) then -- shift right
    e_, y_ = y_
  end
  assert(is_nil(y_) or isa_damap(y_), "invalid argument #2 (damap expected)")
  return map_alloc(x.__td, x.__vn, (is_number(e_) or is_damap(y_)) and MR or MC)
end

function MR.__copy (x, y_)
  if is_nil(y_) then
    y_ = map_alloc(x.__td, x.__vn, getmetatable(x))
  else
    assert(isa_damap(y_), "invalid argument #2 (damap expected)")
    assert(x.__td == y_.__td, "incompatible damaps")
  end
  for i=1,x.__td.nn do x[i]:copy(y_[i]) end
  return y_
end

-- conversion -----------------------------------------------------------------o

function MR.cplx (re_, im_, y_) -- (re,im) -> r
  local re, im = re_ or im_, im_ or re_ -- trick for next checks
  assert(is_damap(re) and is_damap(im), "invalid argument #1 or #2 (damap expected)")
  if is_nil(y_) then
    y_ = map_alloc(re.__td, re.__vn, MC)
  else
    assert(is_cdamap(y_), "invalid argument #2 (cdamap expected)")
    assert(re.__td == y_.__td, "incompatible damaps")
  end
  re_, im_ = re_ or {}, im_ or {}
  for i=1,y.__td.nn do
    _C.mad_ctpsa_cplx(re_[i], im_[i], y_[i])
  end
  return y_
end

function MR.real (x, y_)
  if is_nil(y_) then
    y_ = map_alloc(x.__td, x.__vn, MR)
  else
    assert(is_damap(y_), "invalid argument #2 (damap expected)")
    assert(x.__td == y_.__td, "incompatible damaps")
  end
  for i=1,x.__td.nn do _C.mad_tpsa_copy(x[i], y_[i]) end
  return y_
end

function MC.real (x, y_)
  if is_nil(y_) then
    y_ = map_alloc(x.__td, x.__vn, MR)
  else
    assert(is_damap(y_), "invalid argument #2 (cdamap expected)")
    assert(x.__td == y_.__td, "incompatible damaps")
  end
  for i=1,x.__td.nn do _C.mad_ctpsa_real(x[i], y_[i]) end
  return y_
end

function MR.imag (x, y_)
  if is_nil(y_) then
    y_ = map_alloc(x.__td, x.__vn, MR)
  else
    assert(is_damap(y_), "invalid argument #2 (damap expected)")
    assert(x.__td == y_.__td, "incompatible damaps")
  end
  for i=1,x.__td.nn do _C.mad_tpsa_clear(y_[i]) end
  return y_
end

function MC.imag (x, y_)
  if is_nil(y_) then
    y_ = map_alloc(x.__td, x.__vn, MR)
  else
    assert(is_damap(y_), "invalid argument #2 (cdamap expected)")
    assert(x.__td == y_.__td, "incompatible damaps")
  end
  for i=1,x.__td.nn do _C.mad_ctpsa_imag(x[i], y_[i]) end
  return y_
end

-- getord, cutord -------------------------------------------------------------o

function MR.getord (x, o, y_)
  if is_nil(y_) then
    y_ = map_alloc(x.__td, x.__vn, MR)
  else
    assert(is_damap(y_), "invalid argument #2 (damap expected)")
    assert(x.__td == y_.__td, "incompatible damaps")
  end
  for i=1,min(#x,#y_) do
    _C.mad_tpsa_getord(x[i], y_[i], o)
  end
  return y_
end

function MC.getord (x, o, y_)
  if is_nil(y_) then
    y_ = map_alloc(x.__td, x.__vn, MC)
  else
    assert(is_cdamap(y_), "invalid argument #2 (cdamap expected)")
    assert(x.__td == y_.__td, "incompatible damaps")
  end
  for i=1,min(#x,#y_) do
    _C.mad_ctpsa_getord(x[i], y_[i], o)
  end
  return y_
end

function MR.cutord (x, o, y_)
  if is_nil(y_) then
    y_ = map_alloc(x.__td, x.__vn, MR)
  else
    assert(isa_damap(y_), "invalid argument #2 (damap expected)")
    assert(x.__td == y_.__td, "incompatible damaps")
  end
  for i=1,min(#x,#y_) do
    _C.mad_tpsa_cutord(x[i], y_[i], o)
  end
  return y_
end

function MC.cutord (x, o, y_)
  if is_nil(y_) then
    y_ = map_alloc(x.__td, x.__vn, MC)
  else
    assert(isa_damap(y_), "invalid argument #2 (cdamap expected)")
    assert(x.__td == y_.__td, "incompatible damaps")
  end
  for i=1,min(#x,#y_) do
    _C.mad_ctpsa_cutord(x[i], y_[i], o)
  end
  return y_
end

-- get/set tbl/vec/mat ------------------------------------------------------------o

function MR.get0 (x, v)
  v = v or vector(#x)
  assert(is_iterable(v), "invalid argument #2 (iterable expected)")
  for i=1,#x do v[i] = x[i].coef[0] end
  return v
end

function MC.get0 (x, v)
  v = v or cvector(#x)
  assert(is_iterable(v), "invalid argument #2 (iterable expected)")
  for i=1,#x do v[i] = x[i].coef[0] end
  return v
end

function MR.set0 (x, v, a_)
  assert(is_number(v) or is_iterable(v),
         "invalid argument #2 (number or iterable expected)")
  local a = a_ or 0
  if is_iterable(v) then
    for i=1,min(#x,#v) do
      _C.mad_tpsa_set0(x[i], a, v[i])
    end
  else
    for i=1,#x do
      _C.mad_tpsa_set0(x[i], a, v)
    end
  end
  return x
end

function MC.set0 (x, v, a_)
  assert(is_scalar(v) or is_iterable(v),
         "invalid argument #2 (is_scalar or iterable expected)")
  local a = complex(a_ or 0)
  if is_iterable(v) then
    for i=1,min(#x,#v) do
      local b = complex(v[i])
      _C.mad_ctpsa_set0_r(x[i], a.re, a.im, b.re, b.im)
    end
  else
    local b = complex(v)
    for i=1,#x do
      _C.mad_ctpsa_set0_r(x[i], a.re, a.im, b.re, b.im)
    end
  end
  return x
end

function MR.clr0 (x) -- keep order 0, set I to order 1, clear higher orders
  for i=1,#x do
    _C.mad_tpsa_setvar(x[i], x[i].coef[0], i, 0)
  end
  return x
end

function MC.clr0 (x)
  for i=1,#x do
    local b = x[i].coef[0]
    _C.mad_ctpsa_setvar_r(x[i], b.re, b.im, i, 0, 0)
  end
  return x
end

function MR.get1 (x, m)
  m = m or matrix(#x, x.__td.nv)
  assert(is_matrix(m), "invalid argument #2 (matrix expected)")
  local nr, nc = m:sizes()
  for i=1,min(#x,nr) do
    _C.mad_tpsa_getv(x[i], 1, nc, m.data+(i-1)*nc)
  end
  return m
end

function MC.get1 (x, m)
  m = m or cmatrix(#x, x.__td.nv)
  assert(is_cmatrix(m), "invalid argument #2 (cmatrix expected)")
  local nr, nc = m:sizes()
  for i=1,min(#x,nr) do
    _C.mad_ctpsa_getv(x[i], 1, nc, m.data+(i-1)*nc)
  end
  return m
end

function MR.set1 (x, m)
  assert(is_matrix(m), "invalid argument #2 (matrix expected)")
  local nr, nc = m:sizes()
  for i=1,min(#x,nr) do
    _C.mad_tpsa_setv(x[i], 1, nc, m.data+(i-1)*nc)
  end
  return x
end

function MC.set1 (x, m)
  assert(is_cmatrix(m), "invalid argument #2 (cmatrix expected)")
  local nr, nc = m:sizes()
  for i=1,min(#x,nr) do
    _C.mad_ctpsa_setv(x[i], 1, nc, m.data+(i-1)*nc)
  end
  return x
end

function MR.setvar (x, v)
  assert(is_iterable(v), "invalid argument #2 (iterable expected)")
  for i=1,min(#x,#v) do
    _C.mad_tpsa_setvar(x[i], v[i], i, 0)
  end
  return x
end

function MC.setvar (x, v)
  assert(is_iterable(v), "invalid argument #2 (iterable expected)")
  for i=1,min(#x,#v) do
    local b = complex(v[i])
    _C.mad_ctpsa_setvar_r(x[i], b.re, b.im, i, 0, 0)
  end
  return x
end

function MR.clear (x) -- set everything to zero
  for i=1,#x do _C.mad_tpsa_clear(x[i]) end
  return x
end

function MC.clear (x)
  for i=1,#x do _C.mad_ctpsa_clear(x[i]) end
  return x
end

function MR.eye (x, e_) -- set everything to zero + e in first order diagonal
  local e = e_ or 0
  for i=1,#x do _C.mad_tpsa_setvar(x[i], 0, i, e_ or 0) end
  return x
end

function MC.eye (x, e_) -- set everything to zero + e in first order
  local e = complex(e_ or 0)
  for i=1,#x do _C.mad_ctpsa_setvar_r(x[i], 0, 0, i, e.re, e.im) end
  return x
end

function MR.getm (x, mt, m_)
  local nr, nc = #mt or 0, is_table(mt[1]) and #mt[1] or 1
  assert(nr > 0 and nc > 0, "invalid argument #2 (non-empty table expected)")
  local m = m_ or matrix(nr, nc)
  assert(is_matrix(m), "invalid argument #3 (matrix expected)")
  local nr, nc = m:sizes()
  local get, set = x[1].get, m.set

  for i=1,nr do
    local mti = mt[i]
    local ii  = mti.var or i
    assert(#mti == nc, "invalid argument #2 (rectangular table expected)")
    for j=1,nc do set(m, i,j, get(x[ii], mti[j])) end
  end
  return m
end

function MC.getm (x, mt, m_)
  local nr, nc = #mt or 0, is_table(mt[1]) and #mt[1] or 1
  assert(nr > 0 and nc > 0, "invalid argument #2 (non-empty table expected)")
  local m = m_ or cmatrix(nr, nc)
  assert(is_cmatrix(m), "invalid argument #3 (cmatrix expected)")
  local nr, nc = m:sizes()
  local get, set = x[1].get, m.set

  for i=1,nr do
    local mti = mt[i]
    local ii  = mti.var or i
    assert(#mti == nc, "invalid argument #2 (rectangular table expected)")
    for j=1,nc do set(m, i,j, get(x[ii], mti[j])) end
  end
  return m
end

-- inv, pinv, expb, vfld, compose ---------------------------------------------o

-- map inverse: r = x^-1

function MR.inv (x, r)
  if is_string(r) and r == 'in' then r = x end
  r = r or map_alloc(x.__td, x.__vn, MR)
  assert(is_damap(r), "invalid argument #2 (damap expected)")
  assert(r.__td == x.__td, "incompatible damap (GTPSA descriptors differ)")
  assert(#r == #x, "incompatible damap lengths")
  _C.mad_tpsa_minv(#x, x.__ta, r.__ta)
  return r
end

function MC.inv (x, r)
  if is_string(r) and r == 'in' then r = x end
  r = r or map_alloc(x.__td, x.__vn, MC)
  assert(is_cdamap(r), "invalid argument #2 (cdamap expected)")
  assert(r.__td == x.__td, "incompatible cdamap (GTPSA descriptors differ)")
  assert(#r == #x, "incompatible cdamap lengths")
  _C.mad_ctpsa_minv(#x, x.__ta, r.__ta) return r
end

-- partial map inverse on selected variables (rows)

function MR.pinv (x, sel, r)
  if is_string(r) and r == 'in' then r = x end
  r = r or map_alloc(x.__td, x.__vn, MR)
  assert(is_table(sel), "invalid argument #2 (table expected)")
  assert(is_damap(r)  , "invalid argument #3 (damap expected)")
  assert(r.__td == x.__td, "incompatible damap (GTPSA descriptors differ)")
  assert(#r == #x, "incompatible damap lengths")
  local s = int_arr(#x) ; for i=1,#x do s[i-1] = sel[i] end
  _C.mad_tpsa_pminv(#x, x.__ta, r.__ta, s) return r
end

function MC.pinv (x, sel, r)
  if is_string(r) and r == 'in' then r = x end
  r = r or map_alloc(x.__td, x.__vn, MC)
  assert(is_table(sel), "invalid argument #2 (table expected)")
  assert(is_cdamap(r) , "invalid argument #3 (cdamap expected)")
  assert(r.__td == x.__td, "incompatible cdamap (GTPSA descriptors differ)")
  assert(#r == #x, "incompatible cdamap lengths")
  local s = int_arr(#x) ; for i=1,#x do s[i-1] = sel[i] end
  _C.mad_ctpsa_pminv(#x, x.__ta, r.__ta, s) return r
end

-- map exponential and poisson bracket: r = exp(:x:) y

function MR.exppb (x, y, r)
  if is_string(r) and r == 'in' then r = x end   -- in place
  r = r or map_alloc(x.__td, x.__vn, MR)
  assert(is_damap(y),           "invalid argument #2 (damap expected)")
  assert(is_damap(r),           "invalid argument #3 (damap expected)")
  assert(r.__td == x.__td, "incompatible damap (GTPSA descriptors differ)")
  assert(r.__td == y.__td, "incompatible damap (GTPSA descriptors differ)")
  assert(#r == #x, "incompatible damap lengths")
  assert(#y == #x, "incompatible damap lengths")
  _C.mad_tpsa_exppb(#x, x.__ta, y.__ta, r.__ta) return r
end

function MC.exppb (x, y, r)
  if is_string(r) and r == 'in' then r = x end   -- in place
  r = r or map_alloc(x.__td, x.__vn, MC)
  assert(is_cdamap(y),          "invalid argument #2 (cdamap expected)")
  assert(is_cdamap(r),          "invalid argument #3 (cdamap expected)")
  assert(r.__td == x.__td, "incompatible cdamap (GTPSA descriptors differ)")
  assert(r.__td == y.__td, "incompatible cdamap (GTPSA descriptors differ)")
  assert(#r == #x, "incompatible cdamap lengths")
  assert(#y == #x, "incompatible cdamap lengths")
  _C.mad_ctpsa_exppb(#x, x.__ta, y.__ta, r.__ta) return r
end

-- map logarithm of exponential poisson bracket: r = exp(:log(x):) y

local function fgrad (x, t)
  local r = t:same()
  for i=1,#x do r = r + x[i]*t:deriv(i) end
  return r
end

local function liebra (x, y)
  local r = x:same()
  for i=1,#x do
  for j=1,#x do
    local t1 = y[j] * x[i]:deriv(j)
    local t2 = x[j] * y[i]:deriv(j)
    r[i] = r[i] + t2 - t1
  end end
  return r
end

local function mnrm (x)
  local nrm = 0
  for i=1,#x do nrm = nrm + x[i]:nrm() end
  return nrm
end

local function logpb (x, r, eps) -- c_logf + c_flofacg
  -- c_logf
  local x0 = x:copy():set0(0)

local fid = 1262 -- ..1289
x0:write("fort/fort_n."..fid, "x0") ; fid = fid+1 ; -- 1263

  -- c_flofacg
  local v = x:same():eye() -- identity

x0:write("fort/fort_n."..fid, "x") ; fid = fid+1 ; -- 1264

  -- special case where eps = -no
  if eps and eps <= 0 then
    for k=1,round(eps)-1 do
      local y = (-r):exppb(x0)
      local t = y - v
      r = r+t

t:write("fort/fort_n."..fid, "t_0 @ "..k) ; fid = fid+1 ;
r:write("fort/fort_n."..fid, "r_0 @ "..k) ; fid = fid+1 ;
    end
    return r
  end

  local nrm0 = mnrm(x0)
  local epsone = eps or nrm0/1000
  local xn, xn0 = 1e4, 1e36
  local nrmax = 1000
  local conv = false

  for k=1,nrmax do
    local y = (-r):exppb(x0)
    local t = y - v

t:write("fort/fort_n."..fid, "t_1 @ "..k) ; fid = fid+1 ; -- 1265

    if xn < epsone then -- CBH (* == c_bra_v_ct)
      local e2, e3 = x:same(), x:same()
      for i=1,#x do e2[i] = -0.5*fgrad(t ,t[i]) end
      for i=1,#x do e3[i] = -0.5*fgrad(e2,t[i])-(1/6)*fgrad(t,e2[i]) end
      t = t+e2+e3

t:write("fort/fort_n."..fid, "t_2 @ "..k) ; fid = fid+1 ; -- 1266

      local z  = liebra(r,t) -- <r,t>
      local e2 = liebra(r,z) -- <r,<r,t>>
      local e3 = liebra(t,z) -- <t,<r,t>>
      t = t + 0.5*z + (1/12)*(e2-e3)

t:write("fort/fort_n."..fid, "t_3 @ "..k) ; fid = fid+1 ; -- 1267

      local e4 = liebra(t,e2) -- <t,<r,<r,t>>>
      t = t - (1/24)*e4

t:write("fort/fort_n."..fid, "t_4 @ "..k) ; fid = fid+1 ; -- 1268

    end
    r = r+t

r:write("fort/fort_n."..fid, "r_1 @ "..k) ; fid = fid+1 ;

    local nrm = mnrm(t)
    xn = nrm/nrm0

print("xn=", xn, "epsone=", epsone, "nrm=", nrm, "nrm0=", nrm0)

    -- same scheme as exppb
    if xn < 1e-14 or conv and xn >= xn0 then break end
    if xn < 1e-10 then conv = true end
    xn0 = xn
  end

  return r
end

function MR.logpb (x, y0, r)
  if is_string(r) and r == 'in' then r = x end -- in place
  r = r or map_alloc(x.__td, x.__vn, MR)
  assert(is_damap(r), "invalid argument #2 (damap expected)")
  assert(r.__td == x.__td, "incompatible damap (GTPSA descriptors differ)")
  assert(#r == #x, "incompatible damap lengths")
  if y0 ~= nil then
    assert(y0.__td == x.__td, "incompatible damap (GTPSA descriptors differ)")
    assert(#y0 == #x, "incompatible damap lengths")
  end
  _C.mad_tpsa_logpb(#x, x.__ta, y0 and y0.__ta, r.__ta)
  return r -- logpb(x, r)
end

function MC.logpb (x, y0, r)
  if is_string(r) and r == 'in' then r = x end -- in place
  r = r or map_alloc(x.__td, x.__vn, MC)
  assert(is_cdamap(r),     "invalid argument #3 (cdamap expected)")
  assert(r.__td == x.__td, "incompatible cdamap (GTPSA descriptors differ)")
  assert(#r == #x, "incompatible cdamap lengths")
  if y0 ~= nil then
    assert(y0.__td == x.__td, "incompatible damap (GTPSA descriptors differ)")
    assert(#y0 == #x, "incompatible damap lengths")
  end
  _C.mad_ctpsa_logpb(#x, x.__ta, y0 and y0.__ta, r.__ta)
  return r -- logpb(x, r)
end

-- factorise map x as
--  x = l exp(f.grad)  if dir =  1, return f and l
--  x = exp(f.grad) l  if dir = -1, return f and l

function MR.factor_map (x, y, dir)
  if is_number(y) and is_nil(dir) then dir, y = y end -- right shift
  local l = y or x:getord(1)
  local t = dir == -1 and l^-1 * x or x * l^-1
  local f = t:logpb()
  return f, l
end

function MC.factor_map (x, y, dir)
  if is_number(y) and is_nil(dir) then dir, y = y end -- right shift
  local l = y or x:getord(1)
  local t = dir == -1 and l^-1 * x or x * l^-1
  local f = t:logpb()
  return f, l
end

-- factored Lie of exponential and poisson bracket: r = exp(:y1:) exp(:y2:)... x

function MR.lieexppb (x, y, r, inv)
  if is_number(r) and is_nil(inv) then inv, r = r end -- right shift
  inv, r = inv or 1, r or map_alloc(x.__td, x.__vn, MR)
  assert(is_table(y),           "invalid argument #2 (list of damap expected)")
  assert(is_damap(r),           "invalid argument #3 (damap expected)")
  assert(inv == 1 or inv == -1, "invalid argument #4 (-1 or 1 expected)")
  assert(r.__td == x.__td, "incompatible damap (GTPSA descriptors differ)")
  assert(#r == #x,         "incompatible damap lengths") ; x:copy(r)
  local n0, n1, d = 1, y.n or #y, y.dir or 1
  assert(d == 1 or d == -1, "invalid factored Lie direction (1 or -1 expected)")
  if d < 0 then n0, n1 = n1, n0 end
  for i=n0,n1,d do
    local y = y[i]
    assert(is_damap(y), "invalid argument #2 (list of damap expected)")
    assert(r.__td == y.__td, "incompatible damap (GTPSA descriptors differ)")
    assert(#r == #y, "incompatible damap lengths")
    if inv == -1 then y = -y end
    _C.mad_tpsa_exppb(#y, y.__ta, r.__ta, r.__ta)
  end
  return r
end

function MC.lieexppb (x, y, r, inv)
  if is_number(r) and is_nil(inv) then inv, r = r end -- right shift
  inv, r = inv or 1, r or map_alloc(x.__td, x.__vn, MC)
  assert(is_table (y),          "invalid argument #2 (list of cdamap expected)")
  assert(is_cdamap(r),          "invalid argument #3 (cdamap expected)")
  assert(inv == 1 or inv == -1, "invalid argument #4 (-1 or 1 expected)")
  assert(r.__td == x.__td, "incompatible cdamap (GTPSA descriptors differ)")
  assert(#r == #x,         "incompatible cdamap lengths") x:copy(r)
  local n0, n1, d = 1, y.n or #y, y.dir or 1
  assert(d == 1 or d == -1, "invalid factored Lie direction (1 or -1 expected)")
  if d < 0 then n0, n1 = n1, n0 end
  for i=n0,n1,d do
    local y = y[i]
    assert(is_cdamap(y), "invalid argument #2 (list of cdamap expected)")
    assert(r.__td == y.__td, "incompatible cdamap (GTPSA descriptors differ)")
    assert(#r == #y, "incompatible cdamap lengths")
    if inv == -1 then y = -y end
    _C.mad_ctpsa_exppb(#y, y.__ta, r.__ta, r.__ta)
  end
  return r
end

-- vector to field map:

function MR.vec2fld (x, f, s_)
  assert(f.d == x.__td, "incompatible tpsa and damap (GTPSA descriptors differ)")
  _C.mad_tpsa_vec2fld(#x, f, x.__ta)
  if s_ ~= false then x = -2i*x end
  return x
end

function MC.vec2fld (x, f, s_)
  assert(f.d == x.__td, "incompatible ctpsa and cdamap (GTPSA descriptors differ)")
  _C.mad_ctpsa_vec2fld(#x, f, x.__ta)
  if s_ ~= false then x:mul(-2i, x) end
  return x
end

-- field map to vector:

function MR.fld2vec (x, f_, s_)
  if is_boolean(f_) and is_nil(s_) then f_, s_ = nil, f_ end -- right shift
  local f = f_ or x[1]:same()
  assert(f.d == x.__td, "incompatible tpsa and damap (GTPSA descriptors differ)")
  _C.mad_tpsa_fld2vec(#x, x.__ta, f)
  if s_ ~= false then f = 0.5i*f end
  return f
end

function MC.fld2vec (x, f_, s_)
  if is_boolean(f_) and is_nil(s_) then f_, s_ = nil, f_ end -- right shift
  local f = f_ or x[1]:same()
  assert(f.d == x.__td, "incompatible ctpsa and cdamap (GTPSA descriptors differ)")
  _C.mad_ctpsa_fld2vec(#x, x.__ta, f)
  if s_ ~= false then f:mul(0.5i,f) end
  return f
end

-- maps evaluation r = x(h) (special case of composition)

function MR.eval (x, h, r)
  local v = is_vector(h) and h or vector(#x):fill(h)
  if is_string(r) and r == 'in' then r = v end
  r = r or v:same()
  assert(is_vector(r), "invalid argument #3 (vector expected)")
  _C.mad_tpsa_eval(#x, x.__ta, #v, v.data, r.data) return r
end

function MC.eval (x, h, r)
  local v = is_cvector(h) and h or cvector(#x):fill(h)
  if is_string(r) and r == 'in' then r = v end
  r = r or v:same()
  assert(is_cvector(r), "invalid argument #3 (cvector expected)")
  _C.mad_ctpsa_eval(#x, x.__ta, #v, v.data, r.data) return r
end

-- maps translation r = x(v) (special case of composition)

function MR.translate (x, t, r)
  local v = is_vector(t) and t or vector(#x):fill(t)
  if is_string(r) and r == 'in' then r = x end
  r = r or map_alloc(x.__td, x.__vn, MR)
  assert(is_damap(r), "invalid argument #3 (damap expected)")
  assert(r.__td == x.__td, "incompatible damap (GTPSA descriptors differ)")
  assert(#r == #x, "incompatible damap lengths")
  _C.mad_tpsa_translate(#x, x.__ta, #v, v.data, r.__ta) return r
end

function MC.translate (x, t, r)
  local v = is_cvector(t) and t or cvector(#x):fill(t)
  if is_string(r) and r == 'in' then r = x end
  r = r or map_alloc(x.__td, x.__vn, MC)
  assert(is_cdamap(r), "invalid argument #3 (cdamap expected)")
  assert(r.__td == x.__td, "incompatible cdamap (GTPSA descriptors differ)")
  assert(#r == #x, "incompatible cdamap lengths")
  _C.mad_ctpsa_translate(#x, x.__ta, #v, v.data, r.__ta) return r
end

-- maps composition : r = x(y)

function MR.compose (x, y, r)
  if is_string(r) and r == 'in' then r = x end
  r = r or map_alloc(x.__td, x.__vn, MR)
  assert(is_damap(y), "invalid argument #2 (damap expected)")
  assert(is_damap(r), "invalid argument #3 (damap expected)")
  assert(r.__td == x.__td, "incompatible damap (GTPSA descriptors differ)")
  assert(r.__td == y.__td, "incompatible damap (GTPSA descriptors differ)")
  assert(#r == #x, "incompatible damap lengths")
  _C.mad_tpsa_compose(#x, x.__ta, #y, y.__ta, r.__ta) return r
end

function MC.compose (x, y, r)
  if is_string(r) and r == 'in' then r = x end
  r = r or map_alloc(x.__td, x.__vn, MC)
  assert(is_cdamap(y), "invalid argument #2 (cdamap expected)")
  assert(is_cdamap(r), "invalid argument #3 (cdamap expected)")
  assert(r.__td == x.__td, "incompatible cdamap (GTPSA descriptors differ)")
  assert(r.__td == y.__td, "incompatible cdamap (GTPSA descriptors differ)")
  assert(#r == #x, "incompatible cdamap lengths")
  _C.mad_ctpsa_compose(#x, x.__ta, #y, y.__ta, r.__ta) return r
end

-- maps conversion

function MR.convert (x, r, tbl_, pb_)
  if is_string(r) and r == 'in' then r = x end
  r = r or map_alloc(x.__td, x.__vn, MR)
  assert(is_damap(r), "invalid argument #2 (damap expected)")
  local pb, n, m = pb_ or 0, 0, nil
  if tbl_ then
    assert(is_table(tbl_), "invalid argument #3 (table expected)")
    assert(pb==0 or pb==1 or pb==-1, "invalid argument #4 (-1,0,1 expected)")
    n = #tbl_
    m = int_arr(n) ; for i=1,n do m[i-1] = tbl_[i]-1 end
  end
  _C.mad_tpsa_mconv(#x, x.__ta, #r, r.__ta, n, m, pb)
  return r
end

function MC.convert (x, r, tbl_, pb_)
  if is_string(r) and r == 'in' then r = x end
  r = r or map_alloc(x.__td, x.__vn, MC)
  assert(is_cdamap(r), "invalid argument #2 (cdamap expected)")
  local pb, n, m = pb_ or 0, 0, nil
  if tbl_ then
    assert(is_table(tbl_), "invalid argument #3 (table expected)")
    assert(pb==0 or pb==1 or pb==-1, "invalid argument #4 (-1,0,1 expected)")
    n = #tbl_
    m = int_arr(n) ; for i=1,n do m[i-1] = tbl_[i]-1 end
  end
  _C.mad_ctpsa_mconv(#x, x.__ta, #r, r.__ta, n, m, pb)
  return r
end

function MR.fromptc (x, r)
  return x:nv() >= 6 and x:convert(r, {1,2,3,4,6,5}, 1) or x:copy(r)
end

function MR.toptc (x, r)
  return x:nv() >= 6 and x:convert(r, {1,2,3,4,6,5}, -1) or x:copy(r)
end

-- operators ------------------------------------------------------------------o

-- unm

function MR.__unm (x, _, r) -- note: _ is dummy arg, see Lua specs.
  r = r or map_alloc(x.__td, x.__vn, MR)
  assert(is_damap(r), "invalid argument #3 (damap expected)")
  assert(r.__td == x.__td, "incompatible damap (GTPSA descriptors differ)")
  assert(#r == #x, "incompatible damap lengths")
  for i=1,#x do _C.mad_tpsa_scl(x[i], -1, r[i]) end
  return r
end

function MC.__unm (x, _, r) -- note: _ is dummy arg, see Lua specs.
  r = r or map_alloc(x.__td, x.__vn, MC)
  assert(is_cdamap(r), "invalid argument #3 (cdamap expected)")
  assert(r.__td == x.__td, "incompatible cdamap (GTPSA descriptors differ)")
  assert(#r == #x, "incompatible cdamap lengths")
  for i=1,#x do _C.mad_ctpsa_scl_r(x[i], -1, 0, r[i]) end
  return r
end

-- add

function MR.__add_cpx (x, y, r)                  -- cpx + dam
  r = r or map_alloc(y.__td, y.__vn, MC)
  for i=1,#r do r[i] = x+y[i] end return r
end

function MR.__add (x, y, r)
  if is_number(x) then
    r = r or map_alloc(y.__td, y.__vn, is_damap(y) and MR or MC)
    for i=1,#r do r[i] = x+y[i] end return r     -- num + dam
  elseif is_scalar(y) then
    r = r or map_alloc(x.__td, x.__vn, is_damap(x) and is_number(y) and MR or MC)
    for i=1,#r do r[i] = x[i]+y end return r     -- dam + scl
  elseif isa_damap(y) then
    r = r or map_alloc(x.__td, x.__vn, is_damap(x) and is_damap(y) and MR or MC)
    for i=1,#r do r[i] = x[i]+y[i] end return r  -- dam + dam
  end
  error("invalid arguments (unsupported damap operation '-')")
end

MC.__add = MR.__add -- fully polymorphic

-- sub

function MR.__sub_cpx (x, y, r)                  -- cpx - dam
  r = r or map_alloc(y.__td, y.__vn, MC)
  for i=1,#r do r[i] = x-y[i] end return r
end

function MR.__sub (x, y, r)
  if is_number(x) then
    r = r or map_alloc(y.__td, y.__vn, is_damap(y) and MR or MC)
    for i=1,#r do r[i] = x-y[i] end return r     -- num - dam
  elseif is_scalar(y) then
    r = r or map_alloc(x.__td, x.__vn, is_damap(x) and is_number(y) and MR or MC)
    for i=1,#r do r[i] = x[i]-y end return r     -- dam - scl
  elseif isa_damap(y) then
    r = r or map_alloc(x.__td, x.__vn, is_damap(x) and is_damap(y) and MR or MC)
    for i=1,#r do r[i] = x[i]-y[i] end return r  -- dam - dam
  end
  error("invalid arguments (unsupported damap operation '-')")
end

MC.__sub = MR.__sub  -- fully polymorphic

-- mul

function MR.__rmul_cpx (x, y, r)
  r = r or map_alloc(y.__td, y.__vn, MC)
  for i=1,#r do r[i] = x*y[i] end return r       -- cpx * dam
end

function MR.__mul (x, y, r)
  if is_number(x) then
    r = r or map_alloc(y.__td, y.__vn, is_damap(y) and MR or MC)
    for i=1,#r do r[i] = x*y[i] end return r     -- num * dam
  elseif is_scalar(y) then
    r = r or map_alloc(x.__td, x.__vn, is_damap(x) and is_number(y) and MR or MC)
    for i=1,#r do r[i] = x[i]*y end return r     -- dam * scl
  elseif isa_damap(y) then
    local MM = is_damap(x) and is_damap(y) and MR or MC
    if MM == MC then -- promote to cdamap if needed
      if is_damap(x) then x = x:copy(x:same(1i)) end
      if is_damap(y) then y = y:copy(y:same(1i)) end
    end
    r = r or map_alloc(x.__td, x.__vn, MM)
    return x:compose(y,r)                        -- dam * dam => dam o dam
  end
  error("invalid arguments (unsupported damap operation '*')")
end

MC.__mul = MR.__mul  -- fully polymorphic

-- div

function MR.__rdiv_cpx (x, y, r)
  r = r or map_alloc(y.__td, y.__vn, MC)
  return y:inv(r):mul(x,r)                       -- cpx / dam
end

function MR.__div (x, y, r)
  if is_number(x) then                           --  num / dam => num*dam:inv()
    r = r or map_alloc(y.__td, y.__vn, is_damap(y) and MR or MC)
    return y:inv(r):mul(x,r)
  elseif is_scalar(y) then
    r = r or map_alloc(x.__td, x.__vn, is_damap(x) and is_number(y) and MR or MC)
    for i=1,#x do r[i] = x[i]/y end return r     -- dam / scl
  elseif isa_damap(y) then
    local MM = is_damap(x) and is_damap(y) and MR or MC
    if MM == MC then -- promote to cdamap if needed
      if is_damap(x) then x = x:copy(x:same(1i)) end
      if is_damap(y) then y = y:copy(y:same(1i)) end
    end
    r = r or map_alloc(x.__td, x.__vn, MM)
    return x:compose(y:inv(r),r)                 -- dam / dam => dam o dam:inv()
  end
  error("invalid arguments (unsupported damap operation '/')")
end

MC.__div = MR.__div  -- fully polymorphic

-- pow

function MR.__pow (x, n, r)
  assert(is_integer(n), "invalid argument #2 (integer expected)")
  if n == 0 then                            -- dam^0  => eye
    return r:eye()
  elseif n == 1 then                        -- dam^1  => copy
    return x:copy(r)
  elseif n == 2 then                        -- dam^2  => dam o dam
    return x:compose(x,r)
  elseif n == -1 then                       -- dam^-1 => dam:inv()
    return x:inv(r)
  elseif n == -2 then                       -- dam^-2 => dam:inv()^2
    r = x:inv(r)
    return r:compose(r,r)
  end

  local n, t = abs(n), n < 0 and x:inv() or x:copy()
  r = r or x:same():eye()

  while true do
    if n%2 == 1 then r = r:compose(t,r) end  -- r = r o t
    n = floor(n/2)
    if n == 0 then break end
    t:compose(t,t)                           -- t = t^2
  end

  return r
end

MC.__pow = MR.__pow -- fully polymorphic

-- dif : r_i = (x_i - y_i) / max(|x_i|, 1)

function MR.dif (x, y, r)
  assert(isa_damap(y), "invalid argument #2 (damap expected)")
  r = r or map_alloc(x.__td, x.__vn, is_damap(x) and is_damap(y) and MR or MC)
  for i=1,#r do x[i]:dif(y[i], r[i]) end return r
end

MC.dif = MR.dif  -- fully polymorphic


-- I/O ------------------------------------------------------------------------o
                  --  file  , str  , bool, num
function MR.write (x, filnam, name_, all_, eps_)
  if is_boolean(name_) or is_number(name_) and is_nil(eps_) then
    name_, all_, eps_ = nil, name_, all_ -- right shift
  end
  if is_number(all_) and is_nil(eps_) then
    all_, eps_ = nil, all_               -- right shift
  end

  local file = assert(openfile(filnam, 'w', '.dat'),
                      "unable to open DA map file in write mode")
--  if name_ then
  file:write('[', #x, is_damap(x) and 'R' or 'C', '] ', name_ or "-UNNAMED-", ' =\n\n')
--  end

  local nn = all_ and min(#x.__vn, x.__td.nn) or #x
  for i=1,nn do
    x[i]:write(file, string.upper(x.__vn[i] or x[i].nam), eps_)
  end

  if is_string(filnam) then file:close() else file:flush() end
  return x
end

function MR.print (x, name_, all_, eps_)
  return x:write(nil, name_, all_, eps_)
end

function MR.read (x_, filnam_, kind_, vname_)
  if is_table(filnam_) and is_nil(vname_) then
    vname_, kind_, filnam_ = kind_, filnam_, nil -- right shift
  end
  if is_table(kind_) and is_nil(vname_) then
    vname_, kind_ = kind_, nil                   -- right shift
  end
  local file, x = assert(openfile(filnam_, 'r', '.dat'),
                         "unable to open DA map file in read mode")

  local hdr = file:read() or ""
  local cnt, knd, nam = (kind_ or hdr):match("[[ ]*(%d*)([RC]?)[] ]*([^ =]*)")  -- sub(6,-3)
--io.write("\ndamap read -> cnt=", cnt, ", knd=", knd, ", nam=", nam, ", hdr='", hdr, "'\n")
  local x1 = x_[1]:read(file, knd)
  -- print('\n1', x1) ; if x1 then print("X1=") ; x1:print() end
  if x1 ~= nil then  -- valid input
    local td = x1.d
    local vn = vname_ and cvname_dup(vname_) or cvname[min(td.nv,6)]
    x = map_alloc(td, vn, is_tpsa(x1) and MR or MC)
    x[1] = x1
    --x1:print("X1."..1)
    for i=2,cnt or td.nv do
      x1 = x1:read(file, knd)
      -- print(i, x1)
      if x1 == nil or x1.d ~= td then
        warn("missing/invalid gtpsa in damap reading: '%s' (after '%s')",
             x1 and x1:nam() or 'nil', x[i-1]:nam())
        break
      end
--    x1:print("X1."..i)
      x[i] = x1
    end
  end
  if is_string(filnam_) then file:close() end
--io.write("\ndamap read <- cnt=", cnt, ", knd=", knd, ", nam=", nam, "\n")
  return x, nam
end

-- metamethods ----------------------------------------------------------------o

MR.__len   = \s   -> s.__var.__td.nv

MR.__index = \s,k -> s.__var[k] or MR[k]
MC.__index = \s,k -> s.__var[k] or MC[k]

MR.__tostring = \s -> string.format("damap: %p", s)
MC.__tostring = \s -> string.format("cdamap: %p", s)

function MR.__newindex (s, k, x)
  local v = s.__var[k]

  if rawequal(v,nil) then -- new var
    if is_tpsa(x)
    then s.__var[k] = x   -- keep tpsa under control
    else rawset(s, k, x)  -- uncontrolled variable
    end
  elseif type(x) == "number" then
    _C.mad_tpsa_setvar(v, x, type(k) == "number" and k or s.__vn[k], 0)
  else
    _C.mad_tpsa_copy(x, v)
  end
end

function MC.__newindex (s, k, x)
  local v = s.__var[k]

  if rawequal(v,nil) then  -- new var
    if is_ctpsa(x)
    then s.__var[k] = x    -- keep tpsa under control
    else rawset(s, k, x)   -- uncontrolled variable
    end
  elseif is_scalar(x) then
    x = complex(x)
    _C.mad_ctpsa_setvar_r(v,x.re,x.im, type(k)=="number" and k or s.__vn[k],0,0)
  else
    _C.mad_ctpsa_copy(x, v)
  end
end

local function iter (self, key)
  local k, v = next(self, key)
  if k == '__var' then return next(self, k) end
  return k, v
end

local function pairs_iter (self)
  return iter, self, nil
end

MR.__pairs  =  pairs_iter

MR.  same, MR.  copy, MR.length =
MR.__same, MR.__copy, MR.__len

MC.  same, MC.  copy, MC.length =
MC.__same, MC.__copy, MC.__len

MR.unm = \x,r_ -> MR.__unm(x,nil,r_)
MC.unm = \x,r_ -> MC.__unm(x,nil,r_)

MR.  add, MR.  sub, MR.  mul, MR.  div, MR.  pow =
MR.__add, MR.__sub, MR.__mul, MR.__div, MR.__pow

MC.  add, MC.  sub, MC.  mul, MR.  div, MC.  pow =
MC.__add, MC.__sub, MC.__mul, MR.__div, MC.__pow

-- MR -> MC -------------------------------------------------------------------o

for k,v in pairs(MR) do
  if is_nil(MC[k]) then MC[k] = v end
end

-- TODO: set concepts for MR and MC

-- env ------------------------------------------------------------------------o

MAD.typeid.is_damap  = is_damap
MAD.typeid.is_cdamap = is_cdamap
MAD.typeid.isa_damap = isa_damap

-- end ------------------------------------------------------------------------o
return {
   damap =  damap,
  cdamap = cdamap,
  cvname = wcvname,
}
