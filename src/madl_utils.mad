--[=[
 o-----------------------------------------------------------------------------o
 |
 | Utils module
 |
 | Methodical Accelerator Design - Copyright CERN 2015+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide a set of utility functions

 o-----------------------------------------------------------------------------o
]=]

local M = { __help = {} }

-- help -----------------------------------------------------------------------o

M.__help.self = [=[
NAME
  utils -- provide some utility functions

SYNOPSIS
  is_nil, is_boolean, is_number, is_string, is_function, is_table, (basic types)
  is_cdata, is_complex, is_xrange,                              (extended types)
  is_nan, is_inf, is_integer, is_scalar, is_rawtable,          (specializations)
  bnot, band, bor, bxor, bclr, bset, btst, tobit, tohex,         (bit operators)
  bool, logical_not, logical_and, logical_or, is_equal,      (logical operators)
  is_not_equal, is_lesser, is_lesser_or_equal, is_greater, is_greater_or_equal,
  lnot, land, lor, is_eq, is_ne, is_lt, is_le, is_gt, is_ge, (aliases for logop)
  unm, add, sub, mul, div, mod, pow, get, set, len, cat, call        (operators)
  is_metaname, has_metatable, get_metatable,                       (metamethods)
  has_length, is_iterable, is_indexable, is_callable, is_comparable,  (concepts)
  is_ordered, is_concatenable, is_stringable, is_tableable, is_collectable,
  has_constructor, is_negatable, is_addable, is_substractable, is_multiplicable,
  is_dividable, is_modulable, is_powerable, has_member, has_method,
  is_same, same,                                              (types comparison)
  tostring, totable,                                                (extensions)
  option { format='%.16g' }.                                             (setup)

DESCRIPTION
  The utils module provides useful utility functions:
  - is_nil, is_boolean, is_number, is_string, is_function, is_table, is_cdata,
    is_complex and is_xrange return true if the argument is of expected type,
  - is_nan and is_inf return true if argument is not-a-number or Â±infinity,
  - is_integer returns true if the argument is an integer number within the
    interval of [-2^52, 2^52],
  - is_scalar returns true if the argument is a number or a complex,
  - is_rawtable returns true if the argument is a table without metatable,
  - bnot, band, bor, bxor, tobit and tohex imported are from the bit module,
  - bclr, bset and btst respectively clear, set and test bit 0..31 of an int32,
  - bool, logical_not, logical_and, logical_or, is_equal, is_not_equal,
    is_lesser, is_lesser_or_equal, is_greater and is_greater_or_equal are
    functions wrapping logical operators,
  - unm, add, sub, mul, div, mod, pow, get, set, len, cat, call are functions
    wrapping other operators (i.e. -n, +, -, *, /, %, ^, [], []=, #, .., ()),
  - is_ismetaname returns true if the argument is a valid metamethod name,
  - has_metatable returns true is the argument has a metatable,
  - get_metatable is an extended version of getmetatable that works also with
    cdata,
  - has_length, is_iterable, is_indexable, is_callable, is_comparable,
    is_ordered, is_concatenable, is_stringable, is_tableable, is_collectable,
    has_constructor, is_negatable, is_addable, is_substractable,
    is_multiplicable, is_dividable, is_modulable, is_powerable, has_member and
    has_method return true if the argument fulfills the concept requirements,
  - is_stringable, is_tableable, is_collectable and has_constructor check only
    if the argument supports respectively the __tostring, the __totable, the
    __gc and the __new metamethods because objects are always stringable,
    tableable, collectable and constructible in MAD,
  - has_member and has_method returns true if argument #1 has argument #2 as a
    member and a callable member respectively,
  - tostring is extended to handle option.format and delegation. To let the
    print command uses this version, it must be exported to override the
    global environment one (i.e. MAD.export('tostring', true)),
  - totable support delegation for non-primary types,
  - option is a table that stores various setup.

RETURN VALUES
  Depends on the utility functions.

ERRORS
  None.

SEE ALSO
  None.
]=]

-- locals ---------------------------------------------------------------------o

local istype, typeof, miscmap                  in require 'ffi'
local bnot, band, bor, bxor, rol, tobit, tohex in require 'bit'
local format                                   in string
local abs                                      in math
local type, getmetatable, tostring = type, getmetatable, tostring

-- implementation -------------------------------------------------------------o

-- metatables

assert(miscmap, "missing MAD extension (no cdata metatable access)")

local function get_metatable (a)
  return type(a) == 'cdata' and miscmap[-tonumber(typeof(a))] or getmetatable(a)
end

-- metamethods

local metaname = { -- list of metanames from lj_obj.h + __init + __totable
  '__add', '__call', '__concat', '__div', '__eq', '__gc', '__index', '__init',
  '__ipairs', '__le', '__len', '__lt', '__metatable', '__mod', '__mode',
  '__mul', '__new', '__newindex', '__pairs', '__pow', '__sub', '__tostring',
  '__totable', '__unm',
}
for _,v in ipairs(metaname) do metaname[v]=v end -- build dictionary

-- values

local value_type = { -- list of types that cannot be indirectly modified
  ['nil'] = true, boolean = true, number = true, string = true, -- table = nil
  ['function'] = true, thread = true,
  -- would be nice to have complex and xrange here
}

-- options

local option = {
  format = "%.16g",
}

-- bits

M.bnot  = bnot
M.band  = band
M.bor   = bor
M.bxor  = bxor
M.tobit = tobit
M.tohex = tohex

M.btst = \x,n -> band(x, rol( 1, n)) ~= 0
M.bclr = \x,n -> band(x, rol(-2, n))
M.bset = \x,n -> bor (x, rol( 1, n))

-- logical

M.bool  = \x   -> not not x
M.lnot  = \x   -> not x
M.land  = \x,y -> x and y
M.lor   = \x,y -> x or  y
M.is_eq = \x,y -> x == y
M.is_ne = \x,y -> x ~= y
M.is_lt = \x,y -> x <  y
M.is_le = \x,y -> x <= y
M.is_gt = \x,y -> x >  y
M.is_ge = \x,y -> x >= y

M.logical_not         = M.lnot
M.logical_and         = M.land
M.logical_or          = M.lor
M.is_equal            = M.is_eq
M.is_not_equal        = M.is_ne
M.is_lesser           = M.is_lt
M.is_lesser_or_equal  = M.is_le
M.is_greater          = M.is_gt
M.is_greater_or_equal = M.is_ge

-- operators

M.unm  = \x   -> -x
M.add  = \x,y ->  x + y
M.sub  = \x,y ->  x - y
M.mul  = \x,y ->  x * y
M.div  = \x,y ->  x / y
M.mod  = \x,y ->  x % y
M.pow  = \x,y ->  x ^ y

M.get  = \x,k   -> x[k]
M.set  = \x,k,v => x[k]=v end
M.len  = \x     -> #x
M.cat  = \x,y   -> x..y
M.call = \x,... -> x(...)

-- types

M.is_nil      = \a -> type(a) == 'nil'
M.is_boolean  = \a -> type(a) == 'boolean'
M.is_number   = \a -> type(a) == 'number'
M.is_string   = \a -> type(a) == 'string'
M.is_function = \a -> type(a) == 'function'
M.is_table    = \a -> type(a) == 'table'

-- cdata types

M.is_cdata    = \a -> type(a) == 'cdata'
M.is_complex  = \a -> istype('complex', a)
M.is_xrange   = \a -> istype('xrange' , a)

-- specializations

local is_number, is_complex, is_table in M

M.is_nan      = \a -> is_number(a) and a ~= a
M.is_inf      = \a -> is_number(a) and abs(a) == 1/0
M.is_integer  = \a -> is_number(a) and a>=-2^52 and a<=2^52 and (a%1)==0
M.is_scalar   = \a -> is_number(a) or is_complex(a)
M.is_rawtable = \a -> is_table(a)  and getmetatable(a) == nil

-- metamethods

M.is_metaname   = \a -> metaname[a] == a
M.has_metatable = \a -> get_metatable(a) ~= nil
M.get_metatable = get_metatable

-- concepts

local is_string, is_function in M

M.has_length = function (a)
  if is_string(a) or is_table(a) then return true end
  local mt = get_metatable(a)
  return mt and mt.__len ~= nil or false
end

M.is_iterable = function (a)
  if is_table(a) then return true end
  local mt = get_metatable(a)
  return mt and (mt.__pairs or mt.__ipairs) ~= nil or false
end

M.is_indexable = function (a)
  if is_table(a) then return true end
  local mt = get_metatable(a)
  return mt and (mt.__index or mt.__newindex) ~= nil or false
end

M.is_callable = function (a)
  if is_function(a) then return true end
  local mt = get_metatable(a)
  return mt and mt.__call ~= nil or false
end

M.is_comparable = function (a)
  if is_number(a) or is_string(a) then return true end
  local mt = get_metatable(a)
  return mt and mt.__eq ~= nil or false
end

M.is_ordered = function (a)
  if is_number(a) or is_string(a) then return true end
  local mt = get_metatable(a)
  return mt and (mt.__lt or mt.__le) ~= nil or false
end

M.is_concatenable = function (a)
  if is_string(a) then return true end
  local mt = get_metatable(a)
  return mt and mt.__concat ~= nil or false
end

M.is_stringable = function (a)
  local mt = get_metatable(a)
  return mt and mt.__tostring ~= nil or false
end

M.is_tableable = function (a)
  local mt = get_metatable(a)
  return mt and mt.__totable ~= nil or false
end

M.is_collectable = function (a)
  local mt = get_metatable(a)
  return mt and mt.__gc ~= nil or false
end

M.has_constructor = function (a)
  local mt = get_metatable(a)
  return mt and mt.__new ~= nil or false
end

M.is_negatable = function (a)
  if is_number(a) then return true end
  local mt = get_metatable(a)
  return mt and mt.__unm ~= nil or false
end

M.is_addable = function (a)
  if is_number(a) then return true end
  local mt = get_metatable(a)
  return mt and mt.__add ~= nil or false
end

M.is_substractable = function (a)
  if is_number(a) then return true end
  local mt = get_metatable(a)
  return mt and mt.__sub ~= nil or false
end

M.is_multiplicable = function (a)
  if is_number(a) then return true end
  local mt = get_metatable(a)
  return mt and mt.__mul ~= nil or false
end

M.is_dividable = function (a)
  if is_number(a) then return true end
  local mt = get_metatable(a)
  return mt and mt.__div ~= nil or false
end

M.is_modulable = function (a)
  if is_number(a) then return true end
  local mt = get_metatable(a)
  return mt and mt.__mod ~= nil or false
end

M.is_powerable = function (a)
  if is_number(a) then return true end
  local mt = get_metatable(a)
  return mt and mt.__pow ~= nil or false
end

local is_indexable, is_callable in M

M.has_member = function (a, f)
  return is_indexable(a) and a[f] ~= nil or false
end

M.has_method = function (a, f)
  return is_indexable(a) and is_callable(a[f]) or false
end

-- same

local is_rawtable, has_method in M

M.is_same = function (a, b)
  return type(a) == type(b) and get_metatable(a) == get_metatable(b)
end

M.same = function (a, ...)
  if value_type[type(a)]       then return a
  elseif is_rawtable(a)        then return {}
  elseif has_method(a, 'same') then return a:same(...)
  end
  error("invalid argument #1 (clonable object expected)")
end

-- extensions

local is_stringable, is_tableable in M

local function str2tbl(s)
  local t = table.new(#s,0)
  for i=1,#s do t[i] = s:sub(i,i) end
  return t
end

M.tostring = function (a)
  if     is_string(a)     then return a
  elseif is_number(a)     then return string.format(option.format, a)
  elseif is_stringable(a) then return a:__tostring() -- delegate
  else                         return tostring(a) -- builtin
  end
end

M.totable = function (a)
  if     is_table(a)     then return a
  elseif is_string(a)    then return str2tbl(a)
  elseif is_tableable(a) then return a:__totable() -- delegate
  else                        return {a} -- encapsulate
  end
end

-- options

M.option = option

-- default help

M.defhelp = function (m, name)
  local ref = m.__help and m.__help.self
  assert(ref, "missing help for module "..tostring(m))
  for k in pairs(m) do
    if k ~= '__help' and m.__help[k] == nil then
      if name then
        io.write('defhelp: no help found for '..name..' item: ',tostring(k),'\n')
      end
      m.__help[k] = ref
    end
  end
  return m
end

 -- no help
M.__help.defhelp = ''

-- end ------------------------------------------------------------------------o
return M.defhelp(M)
