--[=[
 o-----------------------------------------------------------------------------o
 |
 | Utils module
 |
 | Methodical Accelerator Design - Copyright CERN 2015+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide a set of utility functions

 o-----------------------------------------------------------------------------o
]=]

local M = { __help = {} }

-- help -----------------------------------------------------------------------o

M.__help.self = [=[
NAME
  utils -- provide some utility functions

SYNOPSIS
  is_nil, is_boolean, is_number, is_string, is_function, is_table, (basic types)
  is_cdata, is_complex, is_xrange,                              (extended types)
  is_nan, is_integer, is_scalar, is_rawtable, is_metaname,     (specializations)
  is_iterable, is_indexable, is_callable, is_comparable, is_ordered,
  is_stringable,                                                      (concepts)
  identity, first, second, swap, compose, compose_bottom,           (functional)
  option { format='.%16g' },                                             (setup)
  tostring, getmetatable.                                            (extension)

DESCRIPTION
  The utils module provides useful single argument utility functions:
  - is_nil, is_boolean, is_number, is_string, is_function, is_table, is_cdata,
    is_complex and is_xrange return true if the argument is of expected type,
  - is_integer returns true if the argument is an integer number within the
    interval of [-2^52, 2^52],
  - is_scalar returns true if the argument is a number or a complex.
  - is_nan returns true if the argument is a not-a-number.
  - is_rawtable returns true if the argument is a table without a metatable set,
  - is_ismetaname returns true if the argument is a valid metamethod name,
  - is_iterable, is_indexable, is_callable, is_comparable, is_ordered and
    is_stringable return true if the argument fulfills the concept requirements.
  - identity returns its arguments.
  - first, second and swap return arguments #1, #2 and #2 #1 respectively
    (i.e. #1 #2 swapped).
  - compose composes two callable objects.
  - compose_bottom allows to compose (right to left) callable objects using ^.
  - option stores various setup.
  - tostring is an extended version that handles option.format and delegation.
    To let the command 'print' to use this version, it must be exported to the
    global environment (i.e. MAD.export('tostring', true)).
  - getmetatable is an extended version that works also with cdata.

RETURN VALUE
  A table constaining these utility functions and the option table.

ERROR
  None.

SEE ALSO
  None.
]=]

-- Hook this help for all functions.
M.__help.is_nil         = M.__help.self
M.__help.is_boolean     = M.__help.self
M.__help.is_number      = M.__help.self
M.__help.is_string      = M.__help.self
M.__help.is_function    = M.__help.self
M.__help.is_table       = M.__help.self
M.__help.is_cdata       = M.__help.self
M.__help.is_xrange      = M.__help.self
M.__help.is_complex     = M.__help.self
M.__help.is_nan         = M.__help.self
M.__help.is_integer     = M.__help.self
M.__help.is_scalar      = M.__help.self
M.__help.is_rawtable    = M.__help.self
M.__help.is_metaname    = M.__help.self
M.__help.is_iterable    = M.__help.self
M.__help.is_indexable   = M.__help.self
M.__help.is_callable    = M.__help.self
M.__help.is_comparable  = M.__help.self
M.__help.is_ordered     = M.__help.self
M.__help.is_stringable  = M.__help.self

M.__help.identity       = M.__help.self
M.__help.first          = M.__help.self
M.__help.second         = M.__help.self
M.__help.swap           = M.__help.self
M.__help.compose        = M.__help.self
M.__help.compose_bottom = M.__help.self

M.__help.option         = M.__help.self
M.__help.tostring       = M.__help.self
M.__help.getmetatable   = M.__help.self

-- locals ---------------------------------------------------------------------o

local istype, typeof, miscmap in require 'ffi'
local format in string
local type, getmetatable, tostring = type, getmetatable, tostring

-- implementation -------------------------------------------------------------o

-- metamethods

local metaname = { -- from lj_obj.h + __init
  '__add', '__call', '__concat', '__div', '__eq', '__gc', '__index', '__init',
  '__ipairs', '__le', '__len', '__lt', '__metatable', '__mod', '__mode',
  '__mul', '__new', '__newindex', '__pairs', '__pow', '__sub', '__tostring',
  '__unm',
}
for _,v in ipairs(metaname) do metaname[v]=v end -- build dictionary

-- types

M.is_nil = function (a)
  return type(a) == 'nil'
end

M.is_boolean = function (a)
  return type(a) == 'boolean'
end

M.is_number = function (a)
  return type(a) == 'number'
end

M.is_string = function (a)
  return type(a) == 'string'
end

M.is_function = function (a)
  return type(a) == 'function'
end

M.is_table = function (a)
  return type(a) == 'table'
end

-- cdata types

M.is_cdata = function (a)
  return type(a) == 'cdata'
end

M.is_xrange = function (a)
  return istype('xrange', a)
end

M.is_complex = function (a)
  return istype('complex', a)
end

-- specializations

M.is_nan = function (a)
  return type(a) == 'number' and a ~= a
end

M.is_integer = function (a)
  return type(a) == 'number' and a >= -2^52 and a <= 2^52 and (a % 1) == 0
end

M.is_scalar = function (a)
  return type(a) == 'number' or istype('complex', a)
end

M.is_rawtable = function (a)
  return type(a) == 'table' and getmetatable(a) == nil
end

-- names

M.is_metaname = function (a)
  return metaname[a] == a
end

-- concepts

assert(miscmap, "missing MAD extension (no cdata metatable access)")

local function getmetatbl (a)
  return type(a) == 'cdata' and miscmap[-tonumber(typeof(a))] or getmetatable(a)
end

M.is_iterable = function (a)
  if type(a) == 'table' then return true end
  local mt = getmetatbl(a)
  return mt and (mt.__pairs or mt.__ipairs) ~= nil or false
end

M.is_indexable = function (a)
  if type(a) == 'table' then return true end
  local mt = getmetatbl(a)
  return mt and (mt.__index or mt.__newindex) ~= nil or false
end

M.is_callable = function (a)
  if type(a) == 'function' then return true end
  local mt = getmetatbl(a)
  return mt and mt.__call ~= nil or false
end

M.is_comparable = function (a)
  if type(a) == 'number' or type(a) == 'string' then return true end
  local mt = getmetatbl(a)
  return mt and mt.__eq ~= nil or false
end

M.is_ordered = function (a)
  if type(a) == 'number' or type(a) == 'string' then return true end
  local mt = getmetatbl(a)
  return mt and (mt.__lt or mt.__le) ~= nil or false
end

M.is_stringable = function (a)
  local mt = getmetatbl(a)
  return mt and (mt.__tostring) ~= nil or false
end

-- functional composition

M.identity = \...  ...
M.first    = \a    a
M.second   = \a,b  b
M.swap     = \a,b (b,a)
M.compose  = \f,g\... f(g(...))

M.compose_bottom = setmetatable({M.identity}, {
    __call = \g,... g[1](...),
    __pow  = \f,g setmetatable(
      { M.compose(assert(M.is_callable(f) and f), g[1]) }, getmetatable(g))
  })

-- options

local option = {
  format = "%.16g",
}

M.tostring = function (a, fmt_)
  fmt_ = fmt_ or option.format
  if type(a) == 'number' then return string.format(fmt_, a)
  elseif M.is_stringable(a) then return a:__tostring(fmt_) -- delegate
  else return tostring(a) -- Lua version
  end
end

-- extensions

M.option       = option
M.getmetatable = getmetatbl

-- end ------------------------------------------------------------------------o
return M
