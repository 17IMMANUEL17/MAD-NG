--[=[
 o-----------------------------------------------------------------------------o
 |
 | Utils module
 |
 | Methodical Accelerator Design - Copyright CERN 2015+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide a set of utility functions

 o-----------------------------------------------------------------------------o
]=]

local M = { __help = {} }

-- help -----------------------------------------------------------------------o

M.__help.self = [=[
NAME
  utils -- provide some utility functions

SYNOPSIS
  is_nil, is_boolean, is_number, is_string, is_function, is_table, (basic types)
  is_cdata, is_complex, is_xrange,                              (extended types)
  is_integer, is_scalar, is_rawtable,                          (specializations)
  is_iterable, is_indexable, is_callable, is_comparable, is_ordered,  (concepts)
  identity, compose, compose_bottom,                                (functional)
  getmetatable.                                                      (extension)

DESCRIPTION
  The utils module provides useful single argument utility functions:
  - is_nil, is_boolean, is_number, is_string, is_function, is_table, is_cdata,
    is_complex and is_xrange return true if the argument is of expected type,
  - is_integer returns true if the argument is an integer number within the
    interval of [-2^52, 2^52],
  - is_scalar returns true if the argument is a number or a complex.
  - is_rawtable returns true if the argument is a table without a metatable set,
  - is_iterable, is_indexable, is_callable, is_comparable and is_ordered return
    true if the argument fulfills the concept requirements.
  - identity return its arguments.
  - compose composes two callable objects.
  - compose_bottom allows to compose (right to left) callable objects using ^.
  - getmetatable is an extended version that works also with cdata.

RETURN VALUE
  A table constaining these utility functions, which all return a boolean,
  except getmetatable that returns the metatable set by the user.

ERROR
  None.

SEE ALSO
  None.
]=]

-- Hook this help for all functions.
M.__help.is_nil         = M.__help.self
M.__help.is_boolean     = M.__help.self
M.__help.is_number      = M.__help.self
M.__help.is_string      = M.__help.self
M.__help.is_function    = M.__help.self
M.__help.is_table       = M.__help.self
M.__help.is_cdata       = M.__help.self
M.__help.is_xrange      = M.__help.self
M.__help.is_complex     = M.__help.self
M.__help.is_integer     = M.__help.self
M.__help.is_scalar      = M.__help.self
M.__help.is_rawtable    = M.__help.self
M.__help.is_iterable    = M.__help.self
M.__help.is_indexable   = M.__help.self
M.__help.is_callable    = M.__help.self
M.__help.is_comparable  = M.__help.self
M.__help.is_ordered     = M.__help.self

M.__help.identity       = M.__help.self
M.__help.compose        = M.__help.self
M.__help.compose_bottom = M.__help.self

M.__help.getmetatable   = M.__help.self

-- locals ---------------------------------------------------------------------o

local istype, typeof, miscmap in require 'ffi'
local type, getmetatable = type, getmetatable

-- implementation -------------------------------------------------------------o

-- metamethods

local metaname = { -- from lj_obj.h + __init
  '__add', '__call', '__concat', '__div', '__eq', '__gc', '__index', '__init',
  '__ipairs', '__le', '__len', '__lt', '__metatable', '__mod', '__mode',
  '__mul', '__new', '__newindex', '__pairs', '__pow', '__sub', '__tostring',
  '__unm',
}
for _,v in ipairs(metaname) do metaname[v]=v end -- build dictionary

-- types

M.is_nil = function (a)
  return type(a) == 'nil'
end

M.is_boolean = function (a)
  return type(a) == 'boolean'
end

M.is_number = function (a)
  return type(a) == 'number'
end

M.is_string = function (a)
  return type(a) == 'string'
end

M.is_function = function (a)
  return type(a) == 'function'
end

M.is_table = function (a)
  return type(a) == 'table'
end

-- cdata types

M.is_cdata = function (a)
  return type(a) == 'cdata'
end

M.is_xrange = function (a)
  return istype('xrange', a)
end

M.is_complex = function (a)
  return istype('complex', a)
end

-- specializations

M.is_integer = function (a)
  return type(a) == 'number' and a >= -2^52 and a <= 2^52 and (a % 1) == 0
end

M.is_scalar = function (a)
  return type(a) == 'number' or istype('complex', a)
end

M.is_rawtable = function (a)
  return type(a) == 'table' and getmetatable(a) == nil
end

-- names

M.is_metaname = function (a)
  return metaname[a] == a
end

-- concepts

assert(miscmap, "missing MAD extension (no cdata metatable access)")

local function gm (a)
  return type(a) == 'cdata' and miscmap[-tonumber(typeof(a))] or getmetatable(a)
end

M.is_iterable = function (a)
  if type(a) == 'table' then return true end
  local mt = gm(a)
  return mt and (mt.__pairs or mt.__ipairs) ~= nil or false
end

M.is_indexable = function (a)
  if type(a) == 'table' then return true end
  local mt = gm(a)
  return mt and (mt.__index or mt.__newindex) ~= nil or false
end

M.is_callable = function (a)
  if type(a) == 'function' then return true end
  local mt = gm(a)
  return mt and mt.__call ~= nil or false
end

M.is_comparable = function (a)
  if type(a) == 'number' or type(a) == 'string' then return true end
  local mt = gm(a)
  return mt and mt.__eq ~= nil or false
end

M.is_ordered = function (a)
  if type(a) == 'number' or type(a) == 'string' then return true end
  local mt = gm(a)
  return mt and (mt.__lt or mt.__le) ~= nil or false
end

-- functional composition

M.identity = \... ...

M.compose  = \f,g\... f(g(...))

M.compose_bottom = setmetatable({M.identity}, {
    __call = \g,... g[1](...),
    __pow  = \f,g setmetatable(
      { M.compose(assert(M.is_callable(f) and f), g[1]) }, getmetatable(g))
  })

-- metatable extension

M.getmetatable = gm

-- end ------------------------------------------------------------------------o
return M
