--[=[
 o-----------------------------------------------------------------------------o
 |
 | Utils module
 |
 | Methodical Accelerator Design - Copyright CERN 2015+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide a set of utility functions

 o-----------------------------------------------------------------------------o
]=]

local M = { __help = {} }

-- help -----------------------------------------------------------------------o

M.__help.self = [=[
NAME
  utils -- provide some utility functions

SYNOPSIS
  is_nil, is_boolean, is_number, is_string, is_function, is_table, (basic types)
  is_cdata, is_complex,
  is_nan, is_inf, is_integer, is_scalar, is_rawtable,          (specializations)
  bnot, band, bor, bxor, bclr, bset, btst, tobit, tohex,         (bit operators)
  bool, logical_not, logical_and, logical_or, is_equal,      (logical operators)
  is_not_equal, is_lesser, is_lesser_or_equal, is_greater, is_greater_or_equal,
  lnot, land, lor, is_eq, is_ne, is_lt, is_le, is_gt, is_ge, (aliases for logop)
  unm, add, sub, mul, div, mod, pow, get, set, len, cat, call        (operators)
  is_metaname, has_metatable, get_metatable,                       (metamethods)
  has_length, is_iterable, is_mappable, is_indexable, is_callable,    (concepts)
  is_comparable, is_ordered, is_concatenable, is_stringable, is_tablable,
  is_negatable, is_addable, is_substractable, is_multiplicable, is_dividable,
  is_modulable, is_powerable, has_member, has_method, has_metamethod,
  is_same, same,                                              (types comparison)
  tostring, totable,                                                (extensions)
  option { format='%.16g' }.                                             (setup)

DESCRIPTION
  The utils module provides useful utility functions:
  - is_nil, is_boolean, is_number, is_string, is_function, is_table, is_cdata,
    and is_complex return true if the argument is of expected type,
  - is_nan and is_inf return true if argument is not-a-number or Â±infinity,
  - is_integer returns true if the argument is an integer number within the
    interval of [-2^52, 2^52],
  - is_scalar returns true if the argument is a number or a complex,
  - is_rawtable returns true if the argument is a table without metatable,
  - bnot, band, bor, bxor, tobit and tohex imported are from the bit module,
  - bclr, bset and btst respectively clear, set and test bit 0..31 of an int32,
  - bool, logical_not, logical_and, logical_or, is_equal, is_not_equal,
    is_lesser, is_lesser_or_equal, is_greater and is_greater_or_equal are
    functions wrapping logical operators,
  - unm, add, sub, mul, div, mod, pow, get, set, len, cat, call are functions
    wrapping other operators (i.e. -n, +, -, *, /, %, ^, [], []=, #, .., ()),
  - is_ismetaname returns true if the argument is a valid metamethod name,
  - has_metatable returns true is the argument has a metatable,
  - get_metatable is an extended version of getmetatable that works also with
    cdata,
  - has_length, is_iterable, is_mappable, is_indexable, is_callable,
    is_comparable, is_ordered, is_concatenable, is_stringable, is_tablable,
    is_negatable, is_addable, is_substractable, is_multiplicable, is_dividable,
    is_modulable, is_powerable, has_member, has_method and has_metamethod return
    true if the argument fulfills the concept requirements,
  - is_stringable and is_tablable check only if the argument supports
    respectively the __tostring and the __totable metamethods because objects
    are always stringable and tableable in MAD,
  - has_member, has_method and has_metamethod returns true if argument #1 has
    argument #2 as a member, a callable member and a meta member respectively,
  - tostring is extended to handle option.format and delegation. To let the
    print command uses this version, it must be exported to override the
    global environment one (i.e. MAD.export('tostring', true)),
  - totable support delegation for non-primary types,
  - option is a table that stores various setup.

RETURN VALUES
  Depends on the utility functions.

ERRORS
  None.

SEE ALSO
  None.
]=]

-- locals ---------------------------------------------------------------------o

local ffi, bit = require 'ffi', require 'bit'
local istype                                   in ffi
local format                                   in string
local abs                                      in math
local bnot, band, bor, bxor, rol, tobit, tohex in bit
local type, getmetatable, tostring = type, getmetatable, tostring

local complex_ctor = ffi.typeof 'complex'

-- implementation -------------------------------------------------------------o

-- metatables

assert(ffi.miscmap, "missing MAD extension (no cdata metatable access)")

local cdata_mt = \a -> ffi.miscmap[ -tonumber(ffi.typeof(a)) ]

-- metamethods

local metaname = { -- list of metanames from lj_obj.h + __init + __totable
  '__add', '__call', '__concat', '__div', '__eq', '__gc', '__index', '__init',
  '__ipairs', '__le', '__len', '__lt', '__metatable', '__mod', '__mode',
  '__mul', '__new', '__newindex', '__pairs', '__pow', '__sub', '__tostring',
  '__totable', '__unm',
}
for _,v in ipairs(metaname) do metaname[v] = v end -- build dictionary

-- values

local value_t = { -- list of types that cannot be modified
  ['nil'] = true, boolean = true, number = true, string = true, -- table = nil
  ['function'] = true, thread = true,
}

-- options

M.option = {

  format = "%.16g",

}

-- operators

M.operator = {

-- bits operators

  bnot  = bnot,
  band  = band,
  bor   = bor,
  bxor  = bxor,
  tobit = tobit,
  tohex = tohex,

  bset = \x,n -> bor (x, rol( 1, n)),
  btst = \x,n -> band(x, rol( 1, n)) ~= 0,
  bclr = \x,n -> band(x, rol(-2, n)),

-- logical operators

  bool  = \x   -> not not x,
  lnot  = \x   -> not x,
  land  = \x,y -> not not (x and y),
  lor   = \x,y -> not not (x or  y),
  is_eq = \x,y -> x == y,
  is_ne = \x,y -> x ~= y,
  is_lt = \x,y -> x <  y,
  is_le = \x,y -> x <= y,
  is_gt = \x,y -> x >  y,
  is_ge = \x,y -> x >= y,

  logical_not         = M.lnot,
  logical_and         = M.land,
  logical_or          = M.lor,
  is_equal            = M.is_eq,
  is_not_equal        = M.is_ne,
  is_lesser           = M.is_lt,
  is_lesser_or_equal  = M.is_le,
  is_greater          = M.is_gt,
  is_greater_or_equal = M.is_ge,

-- math operators

  unm  = \x   -> -x,
  sqr  = \x   ->  x * x,
  add  = \x,y ->  x + y,
  sub  = \x,y ->  x - y,
  mul  = \x,y ->  x * y,
  div  = \x,y ->  x / y,
  mod  = \x,y ->  x % y,
  pow  = \x,y ->  x ^ y,

-- object operators

  get  = \x,k   -> x[k],
  set  = \x,k,v => x[k]=v end,
  len  = \x     -> #x,
  cat  = \x,y   -> x..y,
  call = \x,... -> x(...),
}

M.operator.opstring = {
    ['~' ] = M.operator.unm,
    ['+' ] = M.operator.add,
    ['-' ] = M.operator.sub,
    ['*' ] = M.operator.mul,
    ['/' ] = M.operator.div,
    ['%' ] = M.operator.mod,
    ['^' ] = M.operator.pow,
    ['#' ] = M.operator.len,
    ['..'] = M.operator.cat,
    ['<' ] = M.operator.is_lt,
    ['>' ] = M.operator.is_gt,
    ['<='] = M.operator.is_le,
    ['>='] = M.operator.is_ge,
    ['~='] = M.operator.is_ne,
    ['!='] = M.operator.is_ne,
    ['=='] = M.operator.is_eq,
    ['!' ] = M.operator.lnot,
    ['&&'] = M.operator.land,
    ['||'] = M.operator.lor,
    ['!!'] = M.operator.bool,
}

-- types

M.is_nil      = \a -> type(a) == 'nil'
M.is_boolean  = \a -> type(a) == 'boolean'
M.is_number   = \a -> type(a) == 'number'
M.is_string   = \a -> type(a) == 'string'
M.is_function = \a -> type(a) == 'function'
M.is_table    = \a -> type(a) == 'table'
M.is_cdata    = \a -> type(a) == 'cdata'
M.is_complex  = \a -> istype(complex_ctor, a)

local is_number, is_complex, is_table in M

M.is_nan      = \a -> is_number(a) and a ~= a
M.is_inf      = \a -> is_number(a) and abs(a) == 1/0
M.is_integer  = \a -> is_number(a) and a >= -2^52 and a <= 2^52 and (a%1) == 0
M.is_scalar   = \a -> is_number(a) or is_complex(a)
M.is_rawtable = \a -> is_table(a)  and getmetatable(a) == nil

-- metamethods

local is_cdata in M

M.is_metaname   = \a -> metaname[a] == a
M.get_metatable = \a -> is_cdata(a) and cdata_mt(a) or getmetatable(a)

local get_metatable in M

M.has_metatable = \a -> get_metatable(a) ~= nil

M.has_metamethod = function (a, f, f2)
  local mt = get_metatable(a)
  return mt and (mt[f] or mt[f2]) ~= nil or false
end

-- concepts

local is_string, is_function, has_metamethod in M

M.concept = {

  is_stringable    = \a -> has_metamethod(a, '__tostring'),
  is_tablable      = \a -> has_metamethod(a, '__totable' ),

  is_callable      = \a -> is_function(a) or has_metamethod(a, '__call'  ),
  is_iterable      = \a -> is_table(a)    or has_metamethod(a, '__ipairs'),
  is_mappable      = \a -> is_table(a)    or has_metamethod(a, '__pairs' ),
  is_indexable     = \a -> is_table(a)    or has_metamethod(a, '__index' ),
  is_concatenable  = \a -> is_string(a)   or has_metamethod(a, '__concat'),
  is_negatable     = \a -> is_number(a)   or has_metamethod(a, '__unm'   ),
  is_addable       = \a -> is_number(a)   or has_metamethod(a, '__add'   ),
  is_substractable = \a -> is_number(a)   or has_metamethod(a, '__sub'   ),
  is_multiplicable = \a -> is_number(a)   or has_metamethod(a, '__mul'   ),
  is_dividable     = \a -> is_number(a)   or has_metamethod(a, '__div'   ),
  is_modulable     = \a -> is_number(a)   or has_metamethod(a, '__mod'   ),
  is_powerable     = \a -> is_number(a)   or has_metamethod(a, '__pow'   ),

  is_comparable = \a -> is_number(a) or is_string(a) or has_metamethod(a, '__eq' ),
  is_ordered    = \a -> is_number(a) or is_string(a) or has_metamethod(a, '__le', '__lt'),

  has_length    = \a -> is_table(a)  or is_string(a) or has_metamethod(a, '__len'),

}

-- members

local is_indexable, is_callable in M.concept

M.has_member = \a,f -> is_indexable(a) and a[f] ~= nil       or false
M.has_method = \a,f -> is_indexable(a) and is_callable(a[f]) or false

-- same

local is_rawtable, has_method in M

M.is_same = \a,b -> type(a) == type(b) and get_metatable(a) == get_metatable(b)

M.same = function (a, ...)
  if     value_t[type(a)] or is_complex(a) then return a
  elseif is_rawtable(a)                    then return {}
  elseif has_method(a, 'same')             then return a:same(...)
  end
  error("invalid argument #1 (clonable object expected)")
end

-- extensions

local is_stringable, is_tablable in M.concept
local option in M

local function tbl2str(t)
  if #t == 0 then return '{}' end
  local r = table.new(#t+2,0)
  r[1] = '{'
  for i=1,#t do r[i+1] = M.tostring(t[i]) end
  r[#r+1] = '}'
  return table.concat(r, ', ')
end

local function str2tbl(s)
  local r = table.new(#s,0)
  for i=1,#s do r[i] = s:sub(i,i) end
  return r
end

M.tostring = function (a, ...)
  if     is_string(a)     then return a
  elseif is_number(a)     then return string.format(option.format, a)
  elseif is_rawtable(a)   then return tbl2str(a)
  elseif is_stringable(a) then return get_metatable(a).__tostring(a, ...)
  else                         return tostring(a) -- builtin
  end
end

M.totable = function (a, ...)
  if     is_table(a)    then return a
  elseif is_string(a)   then return str2tbl(a)
  elseif is_tablable(a) then return get_metatable(a).__totable(a, ...)
  else                       return {a} -- encapsulate
  end
end

-- default help

M.utility = {}

M.utility.defhelp = function (m, name)
  local ref = m.__help and m.__help.self
  assert(ref, "missing help for module "..tostring(m))
  for k in pairs(m) do
    if k ~= '__help' and m.__help[k] == nil then
      if name then
        io.write('defhelp: no help found for '..name..' item: ',tostring(k),'\n')
      end
      m.__help[k] = ref
    end
  end
  return m
end

-- todo help
M.__help.operator = {
}

M.__help.concept = {
}

 -- no help
M.__help.utility = {
  defhelp = '',
}

-- end ------------------------------------------------------------------------o
return M.utility.defhelp(M) -- todo: per function help -> 'utils'
