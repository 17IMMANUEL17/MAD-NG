--[=[
 o-----------------------------------------------------------------------------o
 |
 | Utils module
 |
 | Methodical Accelerator Design - Copyright CERN 2015+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide a set of utility functions

 o-----------------------------------------------------------------------------o
]=]

local M = { __help = {} }

-- help -----------------------------------------------------------------------o

M.__help.self = [=[
NAME
  utils -- provide some utility functions

SYNOPSIS
  is_nil, is_boolean, is_number, is_string, is_function, is_table, (basic types)
  is_cdata, is_complex, is_xrange,                              (extended types)
  is_nan, is_integer, is_scalar, is_rawtable, is_metaname,     (specializations)
  is_iterable, is_indexable, is_callable, is_comparable, is_ordered,
  is_concatable, is_stringable,                                       (concepts)
  identity, first, second, swap, compose, compose_bottom,           (functional)
  option { format='%.16g' },                                             (setup)
  tostring, getmetatable.                                            (extension)

DESCRIPTION
  The utils module provides useful single argument utility functions:
  - is_nil, is_boolean, is_number, is_string, is_function, is_table, is_cdata,
    is_complex and is_xrange return true if the argument is of expected type,
  - is_integer returns true if the argument is an integer number within the
    interval of [-2^52, 2^52],
  - is_scalar returns true if the argument is a number or a complex.
  - is_inf and is_nan return true if argument is Â±infinity or not-a-number.
  - is_rawtable returns true if the argument is a table without a metatable set,
  - is_ismetaname returns true if the argument is a valid metamethod name,
  - is_iterable, is_indexable, is_callable, is_comparable, is_ordered,
    is_concatable and is_stringable return true if the argument fulfills the
    concept requirements.
  - is_stringable checks only if the argument supports the __tostring metamethod
    because objects are always stringable in Lua.
  - identity returns its arguments.
  - first, second and swap return arguments #1, #2 and #2 #1 respectively
    (i.e. #1 #2 swapped).
  - compose composes two callable objects.
  - compose_bottom allows to compose (right to left) callable objects using ^.
  - option stores various setup.
  - tostring is extended to handle option.format and delegation, and accepts an
    extra format argument that overrides option.format if provided. To let the
    command print uses this version, it must be exported to override the
    global environment one (i.e. MAD.export('tostring', true)).
  - getmetatable is an extended version that works also with cdata.

RETURN VALUE
  A table constaining these utility functions and the option table.

ERROR
  None.

SEE ALSO
  None.
]=]

-- locals ---------------------------------------------------------------------o

local istype, typeof, miscmap in require 'ffi'
local format                  in string
local abs                     in math
local type, getmetatable, tostring = type, getmetatable, tostring

-- implementation -------------------------------------------------------------o

-- metamethods

local metaname = { -- from lj_obj.h + __init
  '__add', '__call', '__concat', '__div', '__eq', '__gc', '__index', '__init',
  '__ipairs', '__le', '__len', '__lt', '__metatable', '__mod', '__mode',
  '__mul', '__new', '__newindex', '__pairs', '__pow', '__sub', '__tostring',
  '__unm',
}
for _,v in ipairs(metaname) do metaname[v]=v end -- build dictionary

-- types

M.is_nil = function (a)
  return type(a) == 'nil'
end

M.is_boolean = function (a)
  return type(a) == 'boolean'
end

M.is_number = function (a)
  return type(a) == 'number'
end

M.is_string = function (a)
  return type(a) == 'string'
end

M.is_function = function (a)
  return type(a) == 'function'
end

M.is_table = function (a)
  return type(a) == 'table'
end

-- cdata types

M.is_cdata = function (a)
  return type(a) == 'cdata'
end

M.is_complex = function (a)
  return istype('complex', a)
end

M.is_xrange = function (a)
  return istype('xrange', a)
end

-- specializations

M.is_inf = function (a)
  return type(a) == 'number' and abs(a) == 1/0
end

M.is_nan = function (a)
  return type(a) == 'number' and a ~= a
end

M.is_integer = function (a)
  return type(a) == 'number' and a >= -2^52 and a <= 2^52 and (a % 1) == 0
end

M.is_scalar = function (a)
  return type(a) == 'number' or istype('complex', a)
end

M.is_rawtable = function (a)
  return type(a) == 'table' and getmetatable(a) == nil
end

-- names

M.is_metaname = function (a)
  return metaname[a] == a
end

-- concepts

assert(miscmap, "missing MAD extension (no cdata metatable access)")

local function getmetatbl (a)
  return type(a) == 'cdata' and miscmap[-tonumber(typeof(a))] or getmetatable(a)
end

M.is_iterable = function (a)
  if type(a) == 'table' then return true end
  local mt = getmetatbl(a)
  return mt and (mt.__pairs or mt.__ipairs) ~= nil or false
end

M.is_indexable = function (a)
  if type(a) == 'table' then return true end
  local mt = getmetatbl(a)
  return mt and (mt.__index or mt.__newindex) ~= nil or false
end

M.is_callable = function (a)
  if type(a) == 'function' then return true end
  local mt = getmetatbl(a)
  return mt and mt.__call ~= nil or false
end

M.is_comparable = function (a)
  if type(a) == 'number' or type(a) == 'string' then return true end
  local mt = getmetatbl(a)
  return mt and mt.__eq ~= nil or false
end

M.is_ordered = function (a)
  if type(a) == 'number' or type(a) == 'string' then return true end
  local mt = getmetatbl(a)
  return mt and (mt.__lt or mt.__le) ~= nil or false
end

M.is_concatable = function (a)
  if type(a) == 'string' then return true end
  local mt = getmetatbl(a)
  return mt and mt.__concat ~= nil or false
end

M.is_stringable = function (a)
  local mt = getmetatbl(a)
  return mt and mt.__tostring ~= nil or false
end

-- functional composition

M.identity = \...  ...
M.first    = \a    a
M.second   = \a,b  b
M.swap     = \a,b (b,a)
M.compose  = \f,g\... f(g(...))

M.compose_bottom = setmetatable({M.identity}, {
    __call = \g,... g[1](...),
    __pow  = \f,g setmetatable(
      { M.compose(assert(M.is_callable(f) and f), g[1]) }, getmetatable(g))
  })

-- options

local option = {
  format = "%.16g",
}

M.tostring = function (a)
  if type(a) == 'number' then return string.format(option.format, a) end
  if M.is_stringable(a)  then return a:__tostring() end -- delegate
  return tostring(a) -- builtin
end

-- extensions

M.option       = option
M.getmetatable = getmetatbl

-- default help

M.__help.defhelp = '' -- no help

M.defhelp = function (m, trace)
  local ref = m.__help and m.__help.self
  assert(ref, "missing help for module "..tostring(m))
  for k in pairs(m) do
    if k ~= '__help' and m.__help[k] == nil then
      if trace then print('defhelp', m, k) end
      m.__help[k] = ref
    end
  end
  return m
end

-- end ------------------------------------------------------------------------o
return M.defhelp(M)
