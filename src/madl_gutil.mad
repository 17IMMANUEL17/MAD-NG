--[=[
 o-----------------------------------------------------------------------------o
 |
 | Generic utility module
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide a set of generic utilities

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local ffi = require 'ffi'
local bit = require 'bit'

local tostring = tostring

local option, fun, _C in MAD

local band, bor, rol, rshift in bit
local totable, iter          in fun
local abs, min, max          in math

local is_nil, is_boolean, is_number, is_string, is_table, is_emptytable,
      is_value, is_indexable, is_iterable, is_keyrable, is_mappable,
      is_callable, is_stringable, is_tablable, is_copiable, is_sameable,
      is_complex, get_metatable, get_metamethod, wprotect, set_concept,
      concept in MAD.typeid

local not_keyrable, not_extendable, not_mutable in concept

-- implementation -------------------------------------------------------------o

-- operators

local operator = {

  -- bits operators (see http://bitop.luajit.org/api.html)
  tobit   = bit.tobit,
  tohex   = bit.tohex,
  bnot    = bit.bnot,
  bor     = bit.bor,
  band    = bit.band,
  bxor    = bit.bxor,
  lshift  = bit.lshift,
  rshift  = bit.rshift,
  arshift = bit.arshift,
  rol     = bit.rol,
  ror     = bit.ror,
  bswap   = bit.bswap,

  bset    = \x,n -> bor (x, rol( 1, n)),
  btst    = \x,n -> band(x, rol( 1, n)) ~= 0,
  bclr    = \x,n -> band(x, rol(-2, n)),

  -- logical operators
  lfalse  = \    -> false,
  ltrue   = \    -> true,
  lbool   = \x   -> not not x,
  lnot    = \x   -> not x,
  land    = \x,y -> x and y,
  lor     = \x,y -> x or y,
  eq      = \x,y -> x == y,
  ne      = \x,y -> x ~= y,
  lt      = \x,y -> x <  y,
  le      = \x,y -> x <= y,
  gt      = \x,y -> x >  y,
  ge      = \x,y -> x >= y,

  -- math operators
  unm     = \x   -> -x,
  sqr     = \x   -> x * x,
  add     = \x,y -> x + y,
  sub     = \x,y -> x - y,
  mul     = \x,y -> x * y,
  div     = \x,y -> x / y,
  mod     = \x,y -> x % y,
  pow     = \x,y -> x ^ y,

  -- object operators
  get     = \x,k   -> x[k],
  set     = \x,k,v => x[k]=v end,
  len     = \x     -> #x,
  cat     = \x,y   -> x..y,
  call    = \x,... -> x(...),
}

operator.opstr = {
  ['~' ] = operator.unm,
  ['+' ] = operator.add,
  ['-' ] = operator.sub,
  ['*' ] = operator.mul,
  ['/' ] = operator.div,
  ['%' ] = operator.mod,
  ['^' ] = operator.pow,
  ['#' ] = operator.len,
  ['..'] = operator.cat,
  ['<' ] = operator.lt,
  ['>' ] = operator.gt,
  ['<='] = operator.le,
  ['>='] = operator.ge,
  ['~='] = operator.ne,
  ['!='] = operator.ne,
  ['=='] = operator.eq,
  ['!' ] = operator.lnot,
  ['&&'] = operator.land,
  ['||'] = operator.lor,
  ['!!'] = operator.lbool,
}

-- utilities ------------------------------------------------------------------o

local utility = {}

-- sleep

ffi.cdef[[
void Sleep(int ms);
int poll(struct pollfd *fds, unsigned long nfds, int timeout);
]]

if ffi.os == "Windows"
then utility.sleep = \s -> ffi.C.Sleep(s)
else utility.sleep = \s -> ffi.C.poll(nil, 0, s)
end

-- repeater

local _repx, _repn = {}, {}

local rep_it = \s,i => if i < s[_repn] then return i+1, s[_repx] end end
local rep_mt = set_concept({
  __len      = \s   -> s[_repn],
  __index    = \s,i => if 1 <= i and i <= s[_repn] then return s[_repx] end end,
  __ipairs   = \s   -> (rep_it, s, 0),
  __pairs    = \s   -> (rep_it, s, 0),
  __tostring = \s   -> string.format("repeater: %p", s)
}, not_keyrable + not_extendable + not_mutable)

function utility.rep (x, n_) -- repeater
  return setmetatable({[_repx]=x, [_repn]=n_ or 2^30}, rep_mt)
end

-- run once

local runonce_ = setmetatable({}, {__mode='k'})

function utility.runonce (f, ...)
  if runonce_[f] ~= true then
    assert(is_callable(f), "invalid argument #1 (callable expected)")
    runonce_[f]=true
    return f(...)
  end
end

-- key/indexes set

function utility.clearkeys (a, p_)
  assert(is_keyrable(a), "invalid argument #1 (keyrable expected)")
  local it, tb, k0 = kpairs(a)
  if not p_ then
    for k in it,tb,k0 do a[k] = nil end
  else
    assert(is_callable(p_), "invalid argument #2 (callable expected)")
    for k in it,tb,k0 do if p_(k) == true then a[k] = nil end end
  end
  return a
end

function utility.clearidxs (a, i_, j_)
  assert(is_indexable(a), "invalid argument #1 (indexable expected)")
  i_, j_ = i_ or 1, j_ or #a
  assert(is_number(i_)  , "invalid argument #2 (number expected)")
  assert(is_number(j_)  , "invalid argument #3 (number expected)")
  for i=i_,j_ do a[i] = nil end
  return a
end

function utility.setkeys (a, k_, i_, j_)
  if is_number(k_) and is_nil(j_) then
    k_, i_, j_ = nil, k_, i_  -- right shift
  end
  k_ = k_ or a
  assert(is_indexable(a ), "invalid argument #1 (indexable expected)")
  assert(is_indexable(k_), "invalid argument #2 (indexable expected)")
  i_, j_ = i_ or 1, j_ or #a
  assert(is_number(i_)   , "invalid argument #3 (number expected)")
  assert(is_number(j_)   , "invalid argument #4 (number expected)")
  for i=i_,j_ do a[k_[i-i_+1]] = a[i] end
  return a
end

function utility.setidxs (a, k, i_, j_)
  assert(is_indexable(a), "invalid argument #1 (indexable expected)")
  assert(is_indexable(k), "invalid argument #2 (indexable expected)")
  i_, j_ = i_ or 1, j_ or #a
  assert(is_number(i_)  , "invalid argument #3 (number expected)")
  assert(is_number(j_)  , "invalid argument #4 (number expected)")
  for i=i_,j_ do a[i] = a[k[i-i_+1]] end
  return a
end

function utility.countkeys (a)
  assert(is_mappable(a), "invalid argument #1 (mappable expected)")
  local n = 0
  for _ in pairs(a) do n = n+1 end
  return n
end

-- files

function utility.fileexists (fname)
  assert(is_string(fname), "invalid argument #1 (string expected)")
  local file = io.open(fname)
  if is_nil(file) then return false end
  io.close(file)
  return true
end

function utility.printf (str, ...)
  return io.write(str:format(...))
end

function utility.fprintf (fp, str, ...)
  return fp:write(str:format(...))
end

-- table copy

function utility.tblcpy (a, mt_, na_)
  local na = na_ or {}
  for k,v in next, a do na[k] = v end -- shallow copy
  if mt_ == true then setmetatable(na, getmetatable(a)) end
  return na
end

function utility.tbldeepcpy (a, mt_, xr_, na_)
  local na = na_ or {}
  xr_ = xr_ or {}
  xr_[a] = na
  for k,v in next, a do -- deep copy, keep track of self-xref
    na[xr_[k] or k] = xr_[v] or utility.copy(v, mt_, xr_)
  end
  if mt_ == true then setmetatable(na, getmetatable(a)) end
  return na
end

table.copy     = utility.tblcpy
table.deepcopy = utility.tbldeepcpy

-- extensions (conversion, factory)

local tostring_ -- forward ref

function utility.tbl2str(tbl, sep_)
  assert(is_mappable(tbl), "invalid argument #1 (mappable expected)")
  if is_emptytable(tbl) then return '{}' end
  local ir, r = 2, {}
  r[1] = '{'
  for k,v in kpairs(tbl) do
    r[ir], ir = '['..tostring_(k)..']='..tostring_(v), ir+1
  end
  for i,v in ipairs(tbl) do
    r[ir], ir = tostring_(v), ir+1
  end
  r[ir] = '}'
  return table.concat(r, sep_ or ', ')
end

function utility.str2tbl(str, match_, ini_)
  assert(is_string(str), "invalid argument #1 (string expected)")
  if is_string(match_) then
    local r = {n=0}
    for s in string.gmatch(str, match_, ini_) do
      r[r.n+1], r.n = s, r.n+1
    end
    return r
  else
    return {str}
  end
end

function tostring_ (a, ...)      -- to review
  if     is_string(a)     then return a
  elseif is_value(a)      then return (tostring(a))
  elseif is_stringable(a) then return (get_metamethod(a,'__tostring')(a, ...))
  elseif is_mappable(a)   then return  utility.tbl2str(a,...) -- table.concat
  else                         return (tostring(a)) -- builtin tail call...
  end
end

local function totable_ (a, ...) -- to review
  if     is_table(a)      then return a
  elseif is_value(a)      then return {a}
  elseif is_tablable(a)   then return get_metamethod(a,'__totable')(a, ...)
  elseif is_iterable(a)   then return totable(iter(a,...)) -- iterator from lfun
  else                         return {a}
  end
end

function utility.same (a, ...)   -- to review
  if     is_value(a)      then return a
  elseif is_sameable(a)   then return get_metamethod(a,'__same')(a, ...)
  elseif is_table(a)      then return setmetatable({}, getmetatable(a))
  else                         return a -- safe? should try more complex copy?
  end
end

function utility.copy (a, ...)   -- to review
  if     is_value(a)      then return a
  elseif is_copiable(a)   then return get_metamethod(a,'__copy')(a, ...)
  elseif is_table(a)      then return utility.tbldeepcpy(a, ...)
  else                         return a -- safe? should try more complex copy?
  end
end

-- string interpolation

local function interp_fun (arg, tag)
  local key = tag:sub( 3,-2)
  if key == '' then return '$' end -- ${} -> $
  local lst = key:sub(-1,-1)
  if lst == '-' or lst == '+' or lst == '=' then -- policy
    key = key:sub(1,-2)
  else
    lst = nil
  end
  local sub = tonumber(key) or (key:gsub('%$%b{}', arg.fun))
  local val = arg.var[sub]
  if is_nil(val) then
    if (not lst and arg.policy) == '=' then
      return key ~= sub and string.format("${%s}",sub) or nil   -- unchanged
    elseif (lst or  arg.policy) == '-' then
      return ''                                                 -- removed
    elseif (lst or  arg.policy) == '+' then
      error(string.format("Undefined key: '%s'", sub), 2)       -- substituted!
    else
      error(string.format("Invalid policy: '%s'", lst or arg.policy), 2)
    end
  end
  return tostring(val)
end

local bind1st in MAD.gfunc

function utility.strinterp (str, var, policy_)
  policy_ = policy_ or '+'   -- valid policy: [+-=] (see interp_fun)
  assert(is_string   (str ), "invalid argument #1 (string expected)")
  assert(is_indexable(var ), "invalid argument #2 (indexable expected)")
  assert(is_string(policy_), "invalid argument #3 (string expected)")
  local arg = { var=var, policy=policy_} ; arg.fun = bind1st(interp_fun, arg)
  return (str:gsub('%$%b{}', arg.fun))
end

string.interp          = utility.strinterp
getmetatable("").__mod = utility.strinterp

-- strings fast specialized manipulation

local sarg = ffi.new 'ssz_t[6]'

local function tostr (str, ptr, sarg, escq_)
      if sarg[1] == 0    then str = ''  -- empty
  elseif sarg[1] == #str then           -- unchanged
  else str = ffi.string(ptr+sarg[0], sarg[1])
  end
  if escq_ and sarg[4] > 0 then -- remove escaped quotes
    local cnt ; str, cnt = str:gsub('\\"', '"')
    if cnt ~= sarg[4] then
      error("unexpected escaped quote outside quoted string", 2)
    end
  end
  return str
end

local function qsplit (str, seps, sarg)                          -- sarg_in: [0]=ini, [1]=len, [2]=#seps
  local len, lsep = #str, sarg[2]
  local ptr = _C.mad_str_split(str, sarg, seps)                  -- scan for seps
  local ini, qcnt = sarg[0], 0                                   -- backup ini, esc quotes
  while sarg[2] >= 0 and sarg[3] < 2 do                          -- sep is a quote
    sarg[0], sarg[1] = sarg[2], len-sarg[2]                      -- sarg_in: [0]=ini, [1]=len
    local qptr = _C.mad_str_quote(str, sarg)                     -- scan for quotes
    assert(qptr ~= nil, "invalid pair of quotes")
    qcnt = qcnt + sarg[4]                                        -- count esc quotes
    sarg[0], sarg[1], sarg[2] = sarg[2]+1, len-(sarg[2]+1), lsep -- sarg_in: [0]=ini, [1]=len, [2]=#seps
    _C.mad_str_split(str, sarg, seps)                            -- scan for seps
  end
  sarg[0], sarg[1], sarg[4] = ini, sarg[0]+sarg[1]-ini, qcnt     -- adjust length and esc quotes
  return ptr
end

function utility.strtrim (str, ini_) -- remove leading and trailing spaces
  ini_ = ini_ or 1
  assert(is_string(str ), "invalid argument #1 (string expected)")
  assert(is_number(ini_), "invalid argument #2 (number expected)")
  sarg[0], sarg[1] = ini_-1, #str-(ini_-1)                     -- sarg_in: [0]=ini, [1]=len
  local ptr = _C.mad_str_trim(str, sarg)                       -- [0]: index  of str (trimmed)
  -- trimmed str, length                                       -- [1]: length of str (trimmed)
  return tostr(str, ptr, sarg), sarg[1]
end

function utility.strquote (str, ini_) -- remove surrounding quotes (if any)
  ini_ = ini_ or 1
  assert(is_string(str ), "invalid argument #1 (string expected)")
  assert(is_number(ini_), "invalid argument #2 (number expected)")
  sarg[0], sarg[1] = ini_-1,  #str-(ini_-1)                    -- sarg: [0]=ini, [1]=len
  local ptr = _C.mad_str_quote(str, sarg)                      -- [0]: index  of str (trimmed)
  assert(ptr ~= nil, "invalid pair of quotes")                 -- [1]: length of str
  -- unquoted str, index of closing quote or 0, type of quotes -- [2]: index  of closing quote or -1
  return tostr(str, ptr, sarg, true), sarg[2]+1, sarg[3]       -- [3]: type   of quotes 0: none, 1: "", 2: ''
end                                                            -- [4]: number of escaped quotes

function utility.strsplit (str, seps, ini_) -- split at seps (if any)
  ini_ = ini_ or 1
  assert(is_string(str ), "invalid argument #1 (string expected)")
  assert(is_string(seps), "invalid argument #2 (string expected)")
  assert(is_number(ini_), "invalid argument #3 (number expected)")
  sarg[0], sarg[1], sarg[2] = ini_-1, #str-(ini_-1), #seps     -- sarg_in: [0]=ini, [1]=len, [2]=#seps
  local ptr = _C.mad_str_split(str, sarg, seps)                -- [0]: index  of str (trimmed)
  -- trimmed str, index of sep or 0, index of sep in seps or 0 -- [1]: length of str (trimmed if sep)
  return tostr(str, ptr, sarg), sarg[2]+1, sarg[3]+1           -- [2]: index  of sep or -1
end                                                            -- [3]: index  of sep in seps or -1

function utility.strqsplit (str, seps, ini_) -- split at seps (if any outside quoted strings)
  ini_ = ini_ or 1
  assert(is_string(str ), "invalid argument #1 (string expected)")
  assert(is_string(seps), "invalid argument #2 (string expected)")
  assert(is_number(ini_), "invalid argument #3 (number expected)")
  seps = '"'.."'"..seps                                        -- add quotes to seps
  sarg[0], sarg[1], sarg[2] = ini_-1, #str-(ini_-1), #seps     -- sarg_in: [0]=ini, [1]=len, [2]=#seps
  local ptr = qsplit(str, seps, sarg)                          -- [0]: index  of str (trimmed)
  -- trimmed str, index of sep or 0, index of sep in seps or 0 -- [1]: length of str (trimmed if sep)
  return tostr(str, ptr, sarg, true), sarg[2]+1, sarg[3]+1     -- [2]: index  of sep or -1
end                                                            -- [3]: index  of sep in seps or -1
                                                               -- [4]: number of escaped quotes
function utility.strsplitall (str, seps, ini_, res_)
  ini_, res_ = ini_ or 1, res_ or {}
  assert(is_string  (str ), "invalid argument #1 (string expected)")
  assert(is_string  (seps), "invalid argument #2 (string expected)")
  assert(is_number  (ini_), "invalid argument #3 (number expected)")
  assert(is_iterable(res_), "invalid argument #4 (iterable expected)")
  seps = '"'.."'"..seps                            -- add quotes to seps
  local len, lsep, ns = #str, #seps, 0
  sarg[0], sarg[1] = ini_-1, len-(ini_-1)          -- sarg_in: [0]=ini, [1]=len
  _C.mad_str_trim(str, sarg)
  if sarg[1] == 0 then return res_, 0 end
  while true do
    sarg[2], ns = lsep, ns+1                       -- see strqsplit above
    local ptr = qsplit(str, seps, sarg)            -- sarg_in: [0]=ini, [1]=len, [2]=#seps
    res_[ns] = tostr(str, ptr, sarg, true)         -- process esc quotes
    if sarg[2] == -1 then return res_, ns end      -- no more sep
    sarg[0], sarg[1] = sarg[2]+1, len-(sarg[2]+1)  -- sarg_in: [0]=ini, [1]=len
    _C.mad_str_trim(str, sarg)
  end
  error("unexpected error in string.splitall")
end

function utility.strbracket (str, ini_) -- split name[cnt] or name{cnt} (if any)
  ini_ = ini_ or 1
  assert(is_string(str ), "invalid argument #1 (string expected)")
  assert(is_number(ini_), "invalid argument #2 (number expected)")
  sarg[0], sarg[1] = ini_-1, #str-(ini_-1)       -- sarg_in: [0]=ini, [1]=len
  local ptr = _C.mad_str_bracket(str, sarg)      -- [0]: index  of name (trimmed)
  assert(ptr ~= nil, "invalid pair of brackets") -- [1]: length of name (trimmed if brackets)
  local cnt                                      -- [2]: index  of closing bracket or -1
  if sarg[2] > 0 then                            -- [3]: index  of count (trimmed)
    if sarg[4] == 0                              -- [4]: length of count (trimmed)
    then cnt = '' -- empty                       -- [5]: type   of brackets 0: none, 1: [], 2: {}
    else cnt = ffi.string(ptr+sarg[3], sarg[4])
    end
  end
  -- trimmed name, trimmed count, index of closing bracket or 0, type of brackets
  return tostr(str, ptr, sarg), cnt, sarg[2]+1, sarg[5]
end

string.trim     = utility.strtrim
string.quote    = utility.strquote
string.bracket  = utility.strbracket
string.split    = utility.strsplit
string.qsplit   = utility.strqsplit
string.splitall = utility.strsplitall

-- iterator

function utility.kpairs (tbl)
  assert(is_keyrable(tbl), "invalid argument #1 (keyrable expected)")
  local iter = get_metamethod(tbl, '__kpairs')
  if iter then return iter(tbl) end
  local iter, init = pairs(tbl), #tbl -- follow __len and __pairs
  if init == 0 then init = nil end
  return iter, tbl, init
end

_G.kpairs = utility.kpairs -- make it global too...

-- searching

function utility.bsearch (tbl, val, cmp_, low_, high_)
  assert(is_iterable(tbl), "invalid argument #1 (iterable expected)")
  if is_number(cmp_) and is_nil(high_) then
    low_, high_, cmp_ = cmp_, low_ -- right shift
  end
  if not (is_nil(cmp_) or is_callable(cmp_)) then
    error("invalid argument #3 (callable expected)")
  end
  local cmp  = cmp_ or operator.lt -- cmp must be the same used by table.sort
  local low  = is_number(low_ ) and max(low_ , 1   ) or 1
  local high = is_number(high_) and min(high_, #tbl) or #tbl
  local cnt, mid, stp, tst = high-low+1
  while cnt > 0 do
    stp = rshift(cnt,1)
    mid = low+stp
    tst = cmp(tbl[mid], val)
    low = tst and mid+1 or low
    cnt = tst and rshift(cnt-1,1) or stp
  end
  return low -- tbl[low] <= val
end

function utility.lsearch (tbl, val, equ_, low_, high_)
  assert(is_iterable(tbl), "invalid argument #1 (iterable expected)")
  if is_number(equ_) and is_nil(high_) then
    low_, high_, equ_ = equ_, low_ -- right shift
  end
  if not (is_nil(equ_) or is_callable(equ_)) then
    error("invalid argument #3 (callable expected)")
  end
  local equ  = equ_ or operator.eq
  local low  = is_number(low_ ) and max(low_ , 1   ) or 1
  local high = is_number(high_) and min(high_, #tbl) or #tbl
  for idx=low,high do
    if equ(tbl[idx], val) == true then return idx end
  end
  return nil
end

-- end ------------------------------------------------------------------------o
return {
  operator = wprotect(operator),
  utility  = wprotect(utility ),
  totable  = totable_,
  tostring = tostring_,
  __help   = require 'madh_gutil',
}
