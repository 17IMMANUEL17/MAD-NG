--[=[
 o-----------------------------------------------------------------------------o
 |
 | Generic utility module
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide a set of generic utilities

 o-----------------------------------------------------------------------------o
]=]

-- help -----------------------------------------------------------------------o

local __help = {}
__help.gutil = [=[
NAME
  gutil -- provide some utility functions

SYNOPSIS
  is_nil, is_boolean, is_number, is_string, is_function, is_table, (basic types)
  is_cdata, is_complex,
  is_nan, is_infinite, is_positive, is_negative, is_integer,   (specializations)
  is_scalar, is_rawtable, is_file,
  bnot, band, bor, bxor, bclr, bset, btst, tobit, tohex,         (bit operators)
  ltrue, lfalse, lbool, lnot, land, lor, eq, ne, lt, le, gt, ge,
                                                             (logical operators)
  unm, add, sub, mul, div, mod, pow, get, set, len, cat, call        (operators)
  is_metaname, has_metatable, get_metatable,                       (metamethods)
  has_length, is_iterable, is_mappable, is_indexable, is_callable,    (concepts)
  is_comparable, is_ordered, is_concatenable, is_stringable, is_tableable,
  is_negatable, is_addable, is_substractable, is_multiplicable, is_dividable,
  is_modulable, is_powerable, has_member, has_method, has_metamethod,
  is_same, same,                                              (types comparison)
  strtrim, strsplit, strsplitbra, strsplitall,            (strings manipulation)
  tostring, totable,                                                (extensions)
  option { format='%.16g' }.                                             (setup)

DESCRIPTION
  The utils module provides useful utility functions:
  - is_nil, is_boolean, is_number, is_string, is_function, is_table, is_cdata,
    and is_complex return true if the argument is of expected type,
  - is_nan and is_infinite return true if argument is not-a-number or Â±infinity,
  - is_positive and is_negative return true if argument is >0 or <0 respectively,
  - is_integer returns true if the argument is an integer number within the
    interval of [-2^52, 2^52],
  - is_scalar returns true if the argument is a number or a complex,
  - is_rawtable returns true if the argument is a table without metatable,
  - is_empty returns true if the argument is an empty table,
  - bnot, band, bor, bxor, tobit and tohex imported are from the bit module,
  - bclr, bset and btst respectively clear, set and test bit 0..31 of an int32,
  - logical_false, logical_true, logical_bool, logical_not, logical_and,
    logical_or, is_equal, is_not_equal, is_lesser, is_lesser_or_equal,
    is_greater and is_greater_or_equal are functions wrapping logical values and
    operators,
  - unm, add, sub, mul, div, mod, pow, get, set, len, cat, call are functions
    wrapping other operators (i.e. -n, +, -, *, /, %, ^, [], []=, #, .., ()),
  - is_ismetaname returns true if the argument is a valid metamethod name,
  - has_metatable returns true is the argument has a metatable,
  - get_metatable is a generic version of getmetatable that works also with
    cdata,
  - has_length, is_iterable, is_mappable, is_indexable, is_callable,
    is_comparable, is_ordered, is_concatenable, is_stringable, is_tableable,
    is_negatable, is_addable, is_substractable, is_multiplicable, is_dividable,
    is_modulable, is_powerable, has_member, has_method and has_metamethod return
    true if the argument fulfills the concept requirements,
  - is_stringable and is_tableable check only if the argument supports
    respectively the __tostring and the __totable metamethods because objects
    are always stringable and tableable in MAD,
  - has_member, has_method and has_metamethod returns true if argument #1 has
    argument #2 as a member, a callable member and a meta member respectively,
  - tostring is extended to handle option.format and delegation. To let the
    print command uses this version, it must be exported to override the
    global environment one (i.e. MAD.export('tostring', true)),
  - totable support delegation for non-primary types,
  - option is a table that stores various setup.

RETURN VALUES
  Depends on the utility functions.

ERRORS
  None.

SEE ALSO
  None.
]=]
__help.option   = __help.gutil
__help.typeid   = __help.gutil
__help.concept  = __help.gutil
__help.utility  = __help.gutil
__help.operator = __help.gutil
__help.totable  = __help.gutil
__help.tostring = __help.gutil
__help.same     = __help.gutil -- move to gfunc

-- locals ---------------------------------------------------------------------o

-- Note: this module is used by MAD env,
--       hence it cannot rely on MAD env.

local ffi, _C  = require 'ffi', require 'madl_cmad'
local bit, fun = require 'bit', require 'madl_lfun'

local istype, typeof, miscmap                  in ffi
local format                                   in string
local abs, huge, min, max                      in math
local band, bor, rol, rshift                   in bit
local totable, iter                            in fun
local type, getmetatable, tostring = type, getmetatable, tostring

-- implementation -------------------------------------------------------------o

-- metatables & metamethods

assert(miscmap, "missing MAD extension (no cdata metatable access)")

local metaname = {
  -- list of metanames from lj_obj.h + init + exec + copy + kpairs + totable
  '__add', '__call', '__concat', '__copy', '__div', '__eq', '__exec', '__gc',
  '__index', '__init', '__ipairs', '__kpairs', '__le', '__len', '__lt',
  '__metatable', '__mod', '__mode', '__mul', '__new', '__newindex', '__pairs',
  '__pow', '__same', '__sub', '__tostring', '__totable', '__unm',
}
for _,v in ipairs(metaname) do metaname[v] = v end -- build dictionary

local function get_metatable (a)
  return type(a) == 'cdata' and miscmap[-tonumber(typeof(a))] or getmetatable(a)
end

local function has_metatable (a)
  return not not get_metatable(a)
end

local function get_metamethod (a, f)
  local mt = get_metatable(a)
  return mt and rawget(mt,f)
end

local function has_metamethod (a, f)
  local mt = get_metatable(a)
  return (mt and rawget(mt,f)) ~= nil
end

local function has_metamethod2 (a, f, f2)
  local mt = get_metatable(a)
  return (mt and (rawget(mt,f) or rawget(mt,f2))) ~= nil
end

-- values

local value_t = { -- list of types that cannot be modified
  ['nil'] = true, boolean = true, number = true, string = true, -- table = nil
  ['function'] = true, thread = true,
}

-- options

local option = {

  format = "%.16g",
  debug  = false,

}

-- operators

local operator = {

  -- bits operators (see http://bitop.luajit.org/api.html)
  tobit   = bit.tobit,
  tohex   = bit.tohex,
  bnot    = bit.bnot,
  bor     = bit.bor,
  band    = bit.band,
  bxor    = bit.bxor,
  lshift  = bit.lshift,
  rshift  = bit.rshift,
  arshift = bit.arshift,
  rol     = bit.rol,
  ror     = bit.ror,
  bswap   = bit.bswap,

  bset    = \x,n -> bor (x, rol( 1, n)),
  btst    = \x,n -> band(x, rol( 1, n)) ~= 0,
  bclr    = \x,n -> band(x, rol(-2, n)),

  -- logical operators
  lfalse  = \    -> false,
  ltrue   = \    -> true,
  lbool   = \x   -> not not x,
  lnot    = \x   -> not x,
  land    = \x,y -> x and y,
  lor     = \x,y -> x or y,
  eq      = \x,y -> x == y,
  ne      = \x,y -> x ~= y,
  lt      = \x,y -> x <  y,
  le      = \x,y -> x <= y,
  gt      = \x,y -> x >  y,
  ge      = \x,y -> x >= y,

  -- math operators
  unm     = \x   -> -x,
  sqr     = \x   -> x * x,
  add     = \x,y -> x + y,
  sub     = \x,y -> x - y,
  mul     = \x,y -> x * y,
  div     = \x,y -> x / y,
  mod     = \x,y -> x % y,
  pow     = \x,y -> x ^ y,

  -- object operators
  get     = \x,k   -> x[k],
  set     = \x,k,v => x[k]=v end,
  len     = \x     -> #x,
  cat     = \x,y   -> x..y,
  call    = \x,... -> x(...),
}

operator.opstr = {
  ['~' ] = operator.unm,
  ['+' ] = operator.add,
  ['-' ] = operator.sub,
  ['*' ] = operator.mul,
  ['/' ] = operator.div,
  ['%' ] = operator.mod,
  ['^' ] = operator.pow,
  ['#' ] = operator.len,
  ['..'] = operator.cat,
  ['<' ] = operator.lt,
  ['>' ] = operator.gt,
  ['<='] = operator.le,
  ['>='] = operator.ge,
  ['~='] = operator.ne,
  ['!='] = operator.ne,
  ['=='] = operator.eq,
  ['!' ] = operator.lnot,
  ['&&'] = operator.land,
  ['||'] = operator.lor,
  ['!!'] = operator.lbool,
}

-- types

local complex = typeof 'complex'

local typeid = {

  -- primitive types
  is_boolean  = \a -> type(a) == 'boolean',
  is_number   = \a -> type(a) == 'number',
  is_string   = \a -> type(a) == 'string',
  is_function = \a -> type(a) == 'function',
  is_table    = \a -> type(a) == 'table',
  is_cdata    = \a -> type(a) == 'cdata',

  -- specialisations
  is_nil      = \a -> rawequal(a, nil  ),
  is_true     = \a -> rawequal(a, true ),
  is_false    = \a -> rawequal(a, false),
  is_finite   = \a -> type(a) == 'number'  and abs(a) <  huge,
  is_infinite = \a -> type(a) == 'number'  and abs(a) == huge,
  is_nan      = \a -> type(a) == 'number'  and a ~= a,
  is_positive = \a -> type(a) == 'number'  and a > 0,
  is_negative = \a -> type(a) == 'number'  and a < 0,
  is_integer  = \a -> type(a) == 'number'  and a >= -2^52 and a <= 2^52 and (a%1) == 0,
  is_complex  = \a ->                          istype(complex, a),
  is_scalar   = \a -> type(a) == 'number'  or  istype(complex, a),
  is_rawtable = \a -> type(a) == 'table'   and rawequal(getmetatable(a), nil),
  is_empty    = \a -> type(a) == 'table'   and rawequal(next        (a), nil),

  -- file handle (open or closed)
  is_file     = \a -> io.type(a) ~= nil,

  -- comparison
  is_same = \a,b -> type(a) == type(b) and get_metatable(a) == get_metatable(b),

  -- valid metamethods names
  is_metaname = \a -> metaname[a] == a,

}

local is_nil, is_number, is_complex, is_string, is_table, is_rawtable in typeid

-- concepts

local concept = {

  get_metatable    = get_metatable,
  has_metatable    = has_metatable,
  get_metamethod   = get_metamethod,
  has_metamethod   = has_metamethod,

  is_stringable    = \a -> has_metamethod(a, '__tostring'),
  is_tableable     = \a -> has_metamethod(a, '__totable' ),

  is_callable      = \a -> type(a) == 'function' or has_metamethod(a, '__call'  ),
  is_iterable      = \a -> type(a) == 'table'    or has_metamethod(a, '__ipairs'),
  is_keyrable      = \a -> type(a) == 'table'    or has_metamethod(a, '__kpairs'),
  is_mappable      = \a -> type(a) == 'table'    or has_metamethod(a, '__pairs' ),
  is_indexable     = \a -> type(a) == 'table'    or has_metamethod(a, '__index' ),
  is_concatenable  = \a -> type(a) == 'string'   or has_metamethod(a, '__concat'),
  is_negatable     = \a -> type(a) == 'number'   or has_metamethod(a, '__unm'   ),
  is_addable       = \a -> type(a) == 'number'   or has_metamethod(a, '__add'   ),
  is_substractable = \a -> type(a) == 'number'   or has_metamethod(a, '__sub'   ),
  is_multiplicable = \a -> type(a) == 'number'   or has_metamethod(a, '__mul'   ),
  is_dividable     = \a -> type(a) == 'number'   or has_metamethod(a, '__div'   ),
  is_modulable     = \a -> type(a) == 'number'   or has_metamethod(a, '__mod'   ),
  is_powerable     = \a -> type(a) == 'number'   or has_metamethod(a, '__pow'   ),

  is_comparable    = \a -> is_number(a) or is_string(a) or has_metamethod(a, '__eq' ),
  is_ordered       = \a -> is_number(a) or is_string(a) or has_metamethod2(a,'__le','__lt'),

  has_length       = \a -> is_table(a)  or is_string(a) or has_metamethod(a, '__len'),
  has_constructor  = \a -> has_metamethod(a,'__new' ),
  is_collectable   = \a -> has_metamethod(a,'__gc'  ),
  is_copiable      = \a -> has_metamethod(a,'__copy'),
  is_sameable      = \a -> has_metamethod(a,'__same'),

}

local is_indexable, is_iterable, is_mappable, is_callable, is_stringable,
      is_tableable, is_copiable, is_sameable in concept

-- methods

concept.has_member = \a,f -> is_indexable(a) and not is_nil(a[f])  or false
concept.has_method = \a,f -> is_indexable(a) and is_callable(a[f]) or false

local has_method in concept

-- utilities

local utility = {}

local rep_x, rep_n = {}, {}

local rep_it = \s,i => if i < s[rep_n] then return i+1, s[rep_x] end end
local rep_mt = {
  __len      = \s   -> s[rep_n],
  __index    = \s,i => if 1 <= i and i <= s[rep_n] then return s[rep_x] end end,
  __newindex = \    -> error("invalid write access to readonly object", 2),
  __pairs    = \s   -> (rep_it, s, 0),
  __ipairs   = \s   -> (rep_it, s, 0),
}

function utility.rep (x, n_) -- repeater
  return setmetatable({[rep_x]=x, [rep_n]=n_ or 2^30}, rep_mt)
end

function utility.setkeys (a)
  assert(is_iterable(a), "invalid argument #1 (iterable expected)")
  for _,v in ipairs(a) do a[v] = v end
  return a
end

function utility.countkeys (a)
  assert(is_mappable(a), "invalid argument #1 (mappable expected)")
  local n = 0
  for _ in pairs(a) do n = n+1 end
  return n
end

function utility.printf (str, ...)
  return io.write(str:format(...))
end

function utility.fprintf (fp, str, ...)
  return fp:write(str:format(...))
end

function utility.fileexists (fname)
  assert(is_string(fname), "invalid argument #1 (string expected)")
  local file = io.open(fname)
  if is_nil(file) then return false end
  io.close(file)
  return true
end

local tostring_ -- forward ref

function utility.tbl2str(tbl, sep_)
  assert(is_mappable(tbl), "invalid argument #1 (mappable expected)")
  if #tbl == 0 then return '{}' end
  local r = table.new(#tbl+2,0)
  r[1] = '{'
  for i=1,#tbl do r[i+1] = tostring_(tbl[i]) end
  r[#r+1] = '}'
  return table.concat(r, sep_ or ', ')
end

function utility.str2tbl(str, match_, init_)
  assert(is_string(str), "invalid argument #1 (string expected)")
  if is_string(match_) then
    local r = {}
    for s in string.gmatch(str, match_, init_) do r[#r+1] = s end
    return r
  else
    return {str}
  end
end

-- extensions (conversion, factory)

function tostring_ (a, ...)
  if     is_string(a)     then return a
  elseif is_number(a)     then return (string.format(option.format, a))
  elseif is_rawtable(a)   then return  utility.tbl2str(a,...) -- table.concat
  elseif is_stringable(a) then return (rawget(get_metatable(a),'__tostring')(a, ...))
  else                         return (tostring(a)) -- builtin tail call...
  end
end

local function totable_ (a, ...)
  if     is_table(a)     then return a
  elseif is_string(a)    then return utility.str2tbl(a,...) -- table.concat^-1
  elseif select('#',...) == 0 and (value_t[type(a)] or is_complex(a))
                         then return {a}
  elseif is_tableable(a) then return rawget(get_metatable(a),'__totable')(a, ...)
  else                        return totable(iter(a,...)) -- iterator from lfun
  end
end

function utility.same (a, ...)
  if    value_t[type(a)] then return a
  elseif is_sameable(a)  then return rawget(get_metatable(a),'__same')(a, ...)
  elseif is_table(a)     then return setmetatable({}, getmetatable(a))
  end
  error("invalid argument #1 (sameable object expected)")
end

function table_copy (a, mt_, na_)
  local na = na_ or {}
  for k,v in next, a do na[k] = v end -- shallow copy
  if mt_ == true then setmetatable(na, getmetatable(a)) end
  return na
end

function table_deepcopy (a, mt_, xr_)
  local na = {}
  xr_ = xr_ or {}
  xr_[a] = na
  for k,v in next, a do -- deep copy, keep track of self-xref
    na[xr_[k] or k] = xr_[v] or utility.copy(v, mt_, xr_)
  end
  if mt_ == true then setmetatable(na, getmetatable(a)) end
  return na
end

table.copy     = table_copy
table.deepcopy = table_deepcopy

function utility.copy (a, ...)
  if    value_t[type(a)] then return a
  elseif is_copiable(a)  then return rawget(get_metatable(a),'__copy')(a, ...)
  elseif is_table(a)     then return table_deepcopy(a, ...)
  end
  error("invalid argument #1 (copiable object expected)")
end

-- string interpolation

local function interp_fun (var, strict_, tag)
  local key, suffix = tag, ''
  local s = tag:sub( 1, 1)
  if s == '$' then return tag end
  local e = tag:sub(-1,-1)
      if s == '{' and e == '}' then
    key         = key:sub(2, -2)
  elseif s ~= '{' and e == '}' then
    key, suffix = key:sub(1, -2), '}'
  elseif s == '{' and e ~= '}' then
    error("Unclosed brace: $"..tag, 2)
  end
  if key == '' then
    error("Missing key: $"..tag, 2)
  end
  key = tonumber(key) or key -- cases $n or ${n}
  local val = var[key]
  if is_nil(val) then
    if strict_ == false then return nil end -- leave it unchanged
    error("Undefined key: $"..tag, 2)
  end
  return tostring_(val) .. suffix
end

function utility.strinterp (str, var, strict_)
  assert(is_indexable(var), "invalid argument #2 (indexable expected)")
  local bind2st in MAD.gfunc
  return (str:gsub('%$([{$]?[%w_]*}?)', bind2st(interp_fun, var, strict_)))
end

string.interp          = utility.strinterp
getmetatable("").__mod = utility.strinterp

-- string fast specialized manipulation

local sarg = ffi.new 'ssz_t[6]'

function utility.strtrim (str, ini_) -- remove leading and trailing spaces
  ini_ = ini_ or 1
  assert(is_string(str ), "invalid argument #1 (string expected)")
  assert(is_number(ini_), "invalid argument #2 (number expected)")
  local len, str1 = #str
  sarg[0], sarg[1] = ini_-1, len-(ini_-1)
  local ptr = _C.mad_str_trim(str, sarg)                             -- sarg[0]: index  of str
      if sarg[1] == 0   then str1 = ''  -- empty                     -- sarg[1]: length of str
  elseif sarg[1] == len then str1 = str -- unchanged
  else                       str1 = ffi.string(ptr+sarg[0], sarg[1])
  end
  return str1
end

function utility.strquote (str, ini_) -- remove surrounding quotes (if any)
  ini_ = ini_ or 1
  assert(is_string(str ), "invalid argument #1 (string expected)")
  assert(is_number(ini_), "invalid argument #2 (number expected)")
  local len, str1 = #str
  sarg[0], sarg[1] = ini_-1, len-(ini_-1)
  local ptr = _C.mad_str_quote(str, sarg)                            -- sarg[0]: index  of str (trimmed)
  assert(ptr ~= nil, "invalid pair of quotes")                       -- sarg[1]: length of str
      if sarg[1] == 0   then str1 = ''  -- empty                     -- sarg[2]: index  of closing quote or -1
  elseif sarg[1] == len then str1 = str -- unchanged                 -- sarg[3]: type   of quotes
  else                       str1 = ffi.string(ptr+sarg[0], sarg[1]) --          0: none, 1: "", 2: ''
  end
  return str1, sarg[2]+1, sarg[3]
end

function utility.strsplit (str, seps, ini_) -- split at seps (if any)
  ini_ = ini_ or 1
  assert(is_string(str ), "invalid argument #1 (string expected)")
  assert(is_string(seps), "invalid argument #2 (string expected)")
  assert(is_number(ini_), "invalid argument #3 (number expected)")
  local len, str1 = #str
  sarg[0], sarg[1], sarg[2] = ini_-1, len-(ini_-1), #seps
  local ptr = _C.mad_str_split(str, sarg, seps)                      -- sarg[0]: index  of str (trimmed)
      if sarg[1] == 0   then str1 = ''  -- empty                     -- sarg[1]: length of str (trimmed if sep)
  elseif sarg[1] == len then str1 = str -- unchanged                 -- sarg[2]: index  of sep or -1
  else                       str1 = ffi.string(ptr+sarg[0], sarg[1]) -- sarg[3]: index  of sep in seps or -1
  end
  return str1, sarg[2]+1, sarg[3]+1
end

function utility.strsplitall (str, seps, ini_, res_)
  ini_ = ini_ or 1
  assert(is_string(str ), "invalid argument #1 (string expected)")
  assert(is_string(seps), "invalid argument #2 (string expected)")
  assert(is_number(ini_), "invalid argument #3 (number expected)")
  seps = '"'.."'"..seps -- add quotes to seps
  local res, n = res_ or {}, res_ and #res_+1 or 1
  local len, lsep, ptr = #str, #seps
  sarg[0], sarg[1], sarg[2] = ini_-1, len-(ini_-1), 1
  while sarg[2] > 0 do
    ptr = _C.mad_str_quote(str, sarg)             -- try quotes
    assert(ptr ~= nil, "invalid pair of quotes")
    if sarg[2] == -1 then                         -- no quotes
      sarg[2] = lsep
      ptr = _C.mad_str_split(str, sarg, seps)     -- try seps
      if sarg[2] > 0 and sarg[3] < 2 then         -- sep is a quote
        sarg[2] = sarg[2]-1
      end
    end
    if sarg[1] == 0
    then res[n] = ''  -- empty
    else res[n] = ffi.string(ptr+sarg[0], sarg[1])
    end
    n, sarg[0], sarg[1] = n+1, sarg[2]+1, len-(sarg[2]+1)
  end
  if res[n-1] == '' then table.remove(res) end
  return res
end

function utility.strbracket (str, ini_) -- split name[cnt] or name{cnt} (if any)
  ini_ = ini_ or 1
  assert(is_string(str ), "invalid argument #1 (string expected)")
  assert(is_number(ini_), "invalid argument #2 (number expected)")
  local len, str1, str2 = #str
  sarg[0], sarg[1] = ini_-1, len-(ini_-1)
  local ptr = _C.mad_str_bracket(str, sarg)                          -- sarg[0]: index  of name (trimmed)
  assert(ptr ~= nil, "invalid pair of brackets")                     -- sarg[1]: length of name (trimmed if brackets)
      if sarg[1] == 0   then str1 = ''  -- empty                     -- sarg[2]: index  of closing bracket or -1
  elseif sarg[1] == len then str1 = str -- unchanged                 -- sarg[3]: index  of count (trimmed)
  else                       str1 = ffi.string(ptr+sarg[0], sarg[1]) -- sarg[4]: length of count (trimmed)
  end                                                                -- sarg[5]: type   of brackets
  if sarg[2] > 0 then                                                --          0: none, 1: [], 2: {}
      if sarg[4] == 0   then str2 = '' -- empty
      else                   str2 = ffi.string(ptr+sarg[3], sarg[4])
      end
  end
  return str1, str2, sarg[2]+1, sarg[5]
end

string.trim     = utility.strtrim
string.quote    = utility.strquote
string.split    = utility.strsplit
string.bracket  = utility.strbracket
string.splitall = utility.strsplitall

-- iterator

function utility.kpairs (tbl)
  local iter = get_metamethod(tbl, '__kpairs')
  if iter then return iter(tbl) end
  local iter, init = pairs(tbl), #tbl -- follow __len and __pairs
  if init == 0 then init = nil end
  return iter, tbl, init
end

_G.kpairs = utility.kpairs

-- searching

function utility.bsearch (tbl, val, cmp_, low_, high_)
  assert(is_iterable(tbl), "invalid argument #1 (iterable expected)")
  if is_number(cmp_) and is_nil(high_) then
    low_, high_, cmp_ = cmp_, low_ -- right shift
  end
  if not (is_nil(cmp_) or is_callable(cmp_)) then
    error("invalid argument #3 (callable expected)")
  end
  local cmp  = cmp_ or operator.lt -- cmp must be the same used by table.sort
  local low  = is_number(low_ ) and max(low_ , 1   ) or 1
  local high = is_number(high_) and min(high_, #tbl) or #tbl
  local cnt, mid, stp, tst = high-low+1
  while cnt > 0 do
    stp = rshift(cnt,1)
    mid = low+stp
    tst = cmp(tbl[mid], val)
    low = tst and mid+1 or low
    cnt = tst and rshift(cnt-1,1) or stp
  end
  return low -- tbl[low] <= val
end

function utility.lsearch (tbl, val, equ_, low_, high_)
  assert(is_iterable(tbl), "invalid argument #1 (iterable expected)")
  if is_number(equ_) and is_nil(high_) then
    low_, high_, equ_ = equ_, low_ -- right shift
  end
  if not (is_nil(equ_) or is_callable(equ_)) then
    error("invalid argument #3 (callable expected)")
  end
  local equ  = equ_ or operator.eq
  local low  = is_number(low_ ) and max(low_ , 1   ) or 1
  local high = is_number(high_) and min(high_, #tbl) or #tbl
  for idx=low,high do
    if equ(tbl[idx], val) == true then return idx end
  end
  return nil
end

-- end ------------------------------------------------------------------------o
return {
  option    = option,
  typeid    = typeid,
  concept   = concept,
  utility   = utility,
  operator  = operator,

  totable   = totable_,
  tostring  = tostring_,

  __help   = __help,
}
