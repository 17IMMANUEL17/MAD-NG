--[=[
 o-----------------------------------------------------------------------------o
 |
 | Aperture module
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide a catalog of aperture models used to check particle positions
    during tracking (i.e. track). maps have the following calling convention:
      apermap(elm, map, len_weight)
  - Provide an aperture margin estimate n1 (TODO)

 o-----------------------------------------------------------------------------o
]=]

local M = {}

-- locals ---------------------------------------------------------------------o

local abs, max, sin, cos in math
local is_damap           in MAD.typeid
local errorf             in MAD.utility
local minang             in MAD.constant
local is_implicit        in MAD.element.drift

-- aperture models ------------------------------------------------------------o

local apmodel = {
  bbox        = \x,y,ap -> x >= ap[1] or y >= ap[1],
  rectangle   = \x,y,ap -> x >= ap[1] or y >= ap[2],

  circle      = \x,y,ap -> x^2 + y^2 >= ap[1]^2,
  ellipse     = \x,y,ap -> ((x/ap[1])^2 + (y/ap[2])^2 >= 1),

  rectcircle  = \x,y,ap -> x >= ap[1] or y >= ap[2] or x^2 + y^2 >= ap[3]^2,
  rectellipse = \x,y,ap -> x >= ap[1] or y >= ap[2] or (x/ap[3])^2 + (y/ap[4])^2 >= 1,

  racetrack   = \x,y,ap -> x >= ap[1] or y >= ap[2] or
                          (x >= ap[1]-ap[3] and y >= ap[2]-ap[4] and
                           ((x-(ap[1]-ap[3]))/ap[3])^2 +
                           ((y-(ap[2]-ap[4]))/ap[4])^2 >= 1),

  octagon     = \x,y,ap -> x >= ap[1] or y >= ap[2] or
                           y >= (x-(ap[1]-ap[3]))*ap[4]/ap[3] + ap[2],
}

-- aperture check -------------------------------------------------------------o

local function lostpar (idx, mflw, _, islc)
  local npar, clw, spos, ds, turn in mflw
  local lw = islc<0 and -1-islc or clw
  local m = mflw[idx]

  -- information saved in lost particle/damap
  m.spos, m.turn, m.status = spos+ds*lw, turn, "lost"

  -- take care of mflw wrappers (e.g. __edat and __sdat in track)
  m = getmetatable(mflw).__index
  -- swap with last tracked particle/damap
  m[idx], m[m.npar], m.npar = m[m.npar], m[idx], m.npar-1
end

local function checkaper (chkap)
  return function (ap, mflw, lw, islc)
    local tdir, tlt in mflw
    local tilt, offset in ap

    local ang, ca, sa = (tilt or 0)*tdir - tlt

    if abs(ang) < minang then
      ca, sa = 1, 0
    else
      ca, sa = cos(ang), sin(ang)
    end

    local dx, dy = 0, 0
    if offset then
      dx, dy = offset[1]*tdir, offset[2]*tdir
    end

    local i, n = 1, mflw.npar
    while i <= n do
      local x, y in mflw[i]

      if is_damap(mflw[i]) then
        x, y = x:get0(), y:get0()
      end

      -- move to aperture frame
      local nx = abs( ca*x + sa*y - dx)
      local ny = abs(-sa*x + ca*y - dy)

      if chkap(nx,ny,ap) then
        lostpar(i, mflw, lw, islc)
        n = n - 1
      else
        i = i + 1
      end
    end

    return true
  end
end

local apcheck = setmetatable({
  bbox        = checkaper(apmodel.bbox       ),
  rectangle   = checkaper(apmodel.rectangle  ),
  circle      = checkaper(apmodel.circle     ),
  ellipse     = checkaper(apmodel.ellipse    ),
  rectcircle  = checkaper(apmodel.rectcircle ),
  rectellipse = checkaper(apmodel.rectellipse),
  racetrack   = checkaper(apmodel.racetrack  ),
  octagon     = checkaper(apmodel.octagon    ),
}, { __index  = \_,k -> errorf("unknown kind of aperture '%s'", tostring(k))
})

for k,v in pairs(apcheck) do M[k] = v end

function M.apercheck (elm, mflw, lw, islc)
  local aperture in elm
  return apcheck[aperture.kind](aperture, mflw, lw, islc)
end

function M.apersave (mflw)
  error("NYI")
  return mtbl
end

-- end ------------------------------------------------------------------------o
return { aperture = M }
