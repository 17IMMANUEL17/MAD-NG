--[=[
 o-----------------------------------------------------------------------------o
 |
 | Aperture module
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide a catalog of aperture models used to check particle positions
    during tracking (i.e. track). maps have the following calling convention:
      apermap(elm, map, len_weight)
  - Provide an aperture margin estimate n1 (TODO)

 o-----------------------------------------------------------------------------o
]=]

local M = {}

-- locals ---------------------------------------------------------------------o

local abs, max, sin, cos in math
local is_tpsa            in MAD.typeid
local errorf             in MAD.utility
local minang             in MAD.constant


-- aperture models ------------------------------------------------------------o

local apmodel = {
  bbox        = \x,y,ap -> x >= ap[1] or y >= ap[1],
  rectangle   = \x,y,ap -> x >= ap[1] or y >= ap[2],

  circle      = \x,y,ap -> x^2 + y^2 >= ap[1]^2,
  ellipse     = \x,y,ap -> ((x/ap[1])^2 + (y/ap[2])^2 >= 1),

  rectcircle  = \x,y,ap -> x >= ap[1] or y >= ap[2] or x^2 + y^2 >= ap[3]^2,
  rectellipse = \x,y,ap -> x >= ap[1] or y >= ap[2] or (x/ap[3])^2 + (y/ap[4])^2 >= 1,

  racetrack   = \x,y,ap -> x >= ap[1] or y >= ap[2] or
                          (x >= ap[1]-ap[3] and y >= ap[2]-ap[4] and
                           ((x-(ap[1]-ap[3]))/ap[3])^2 +
                           ((y-(ap[2]-ap[4]))/ap[4])^2 >= 1),

  octagon     = \x,y,ap -> x >= ap[1] or y >= ap[2] or
                           y >= (x-(ap[1]-ap[3]))*ap[4]/ap[3] + ap[2],
}

-- aperture check -------------------------------------------------------------o

local function lostpar (i, m, lw, islc)
  local eidx, npar, spos, ds, relative in m

  lw = relative and lw*max(0,min(1,islc)) or islc<0 and 1 or lw*islc
  local dsw = ds*lw

  -- TODO: take care of sub-mflw
  m[i].eidx, m[i].spos, m[i].ds = eidx, spos+dsw, dsw
  m[i], m[npar] = m[npar], m[i] -- swap with last tracked particle
  m.npar = npar - 1
  return npar-1
end

local function checkaper (chkap)
  return \ap, m, lw, islc =>
    local npar, tdir, tlt in m
    local tilt, offset in ap

    local ang, ca, sa = (tilt or 0) - tlt

    if abs(ang) < minang then
      ca, sa = 1, 0
    else
      ca, sa = cos(ang*tdir), sin(ang*tdir)
    end

    local dx, dy = 0, 0
    if offset then
      dx, dy = offset[1], offset[2]
    end

    local i = 1
    while i <= npar do
      local x, y in m[i]

      if is_tpsa(x) then -- check for tpsa
        x, y = x:get0(), y:get0()
      end

      -- move to aperture frame
      local nx = abs( ca*x + sa*y - dx)
      local ny = abs(-sa*x + ca*y - dy)

      if chkap(nx,ny,ap) then
        npar = lostpar(i, m, lw, islc)
      else
        i = i + 1
      end
    end
    return true
  end
end

local apcheck = setmetatable({
  bbox        = checkaper(apmodel.bbox       ),
  rectangle   = checkaper(apmodel.rectangle  ),
  circle      = checkaper(apmodel.circle     ),
  ellipse     = checkaper(apmodel.ellipse    ),
  rectcircle  = checkaper(apmodel.rectcircle ),
  rectellipse = checkaper(apmodel.rectellipse),
  racetrack   = checkaper(apmodel.racetrack  ),
  octagon     = checkaper(apmodel.octagon    ),
}, { __index  = \_,k -> errorf("unknown kind of aperture '%s'", tostring(k))
})

for k,v in pairs(apcheck) do M[k] = v end

function M.apercheck (elm, m, lw, islc)
  local aperture in elm
  return apcheck[aperture.kind](aperture, m, lw, islc)
end

function M.apersave (mflw)
  error("NYI")
  return mtbl
end

-- end ------------------------------------------------------------------------o
return { aperture = M }
