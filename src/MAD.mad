--[=[
 o-----------------------------------------------------------------------------o
 |
 | MAD environement (sandbox)
 |
 | Methodical Accelerator Design - Copyright CERN 2015+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Load in order all the modules of the MAD application and flatten them into
    the MAD environment for direct 1-level access using local 'in' table syntax.

 o-----------------------------------------------------------------------------o
]=]

local M = { __help = {} }

-- help -----------------------------------------------------------------------o

M.__help.self = [=[
NAME
  mad -- Methodical Accelerator Design environment

SYNOPSIS
  local Sequence, Drift, Quadrupole in MAD

DESCRIPTION
  The 'MAD' environement provides direct 1-level access to all embedded modules
  of the MAD application. This module also provides online help for modules and
  other component, and it allows to export/import modules, objects, functions
  etc. from/to the MAD environment. This is the recommended way to
  extract/extend the MAD environment with things not embedded in the
  application.

REMARK
  The MAD environment is automatically loaded in the global environment (i.e.
  _G) when the MAD application is started, unless the -M option is used. Hence,
  all components of MAD can be accessed using MAD table access like in
  MAD.component or retieved in local variables (recommended) using <local in
  table> syntax extension as in the example above.

  To clear the global environment from mad, just set it to nil:
  MAD = nil                 -- release global reference
  local mad = require 'MAD' -- retain  local  reference

RETURN VALUES
  A table containing all modules flatten.

SEE ALSO
  None
]=]

-- locals ---------------------------------------------------------------------o

local modules = {
-- order matters
  'utils',
--  'gmath',
--  'xrange',
  'object',

-- 'cmad',
-- 'complex',
-- 'matrix',
--
-- 'mono',
-- 'tpsa',
-- 'ctpsa',
--
-- 'beam',
-- 'element',
-- 'line',
-- 'sequence',
-- 'table',
--
-- 'mflow',
-- 'survey',
-- 'track',
}

local is_boolean, is_string, is_table, is_rawtable, is_iterable, is_indexable
      in require 'madl_utils'

-- implementation -------------------------------------------------------------o

M.__help.import = [[
NAME
  import -- import modules, tables, functions, etc. to MAD environment

SYNOPSIS
  MAD.import 'module'                -- import module (load and flatten)
  MAD.import('module', true)         -- import module but allow override
  MAD.import(func, 'fname')          -- import function
  MAD.import(func, 'fname', true)    -- import function but allow override

DESCRIPTION

  The 'import' function import modules, tables, functions, objects, etc. into
  the MAD environment. If the argument #1 is a string, it will be treated as the
  name of a module and replaced by the value returned by 'require' before
  further processing. If the argument #1 is a raw table (eventually after the
  require) and the argument #2 is not a string, it will be imported flat, that
  is each members will be added individually to the MAD environment. If the
  argument #2 is a string, the argument #1 will be inserted as-is even if it is
  a raw table.

  If the symbol already exists, import will report an error
  and stop loading.

RETURN VALUES
  None.

SEE ALSO
  None.
]]

M.import = function (a, b, override)
  if is_boolean(b) then
    override, b = b -- shift args right
  end
  if is_string(a) then
    b, a = a, require('madl_'..a) or require(a); -- shift args right
    assert(a ~= nil, "module not found: "..b)
  end
  assert(is_string(b), "invalid argument #2 (string expected)")

  -- Now: a is an object/module, b is its name, override is true/false or nil.
  local t = { obj = {}, hlp = {} } -- make a local copy first in case of error
  if is_rawtable(a) then -- flatten raw table
    for k,v in pairs(a) do
      assert(M[k] == nil or override, "cannot override definition for "..k)
      t.obj[k] = v
      if is_indexable(v) and v.__help and v.__help.self then
        t.hlp[k] = v.__help.self
      end
    end
  else
    assert(M[b] == nil or override, "cannot override definition for "..b)
    t.obj[b] = a
    if is_indexable(a) and a.__help and a.__help.self then
      t.hlp[b] = a.__help.self
    end
  end

  -- finalize the transaction
  for k,v in pairs(t.obj) do M[k] = v end
  for k,v in pairs(t.hlp) do M.__help[k] = v end
end

M.__help.export = [[
]]

M.export = function (pat_, ctx_, override)
  local pat = pat_ or '.*'
  local ctx = ctx_ or _G
  assert(is_string(pat), "invalid argument #1 (string expected)")
  assert(is_indexable(ctx), "invalid argument #2 (table expected)")
  for k,v in pairs(M) do
    if is_string(k) then
        if string.find(k, pat) and
           ctx[k] == nil or override then ctx[k] = v end
    else
        if ctx[k] == nil or override then ctx[k] = v end
    end
  end
  return ctx
end

M.__help.help = [[
NAME
  help -- display help for modules and functions

SYNOPSIS
  MAD.help 'help'   -- help on help
  MAD.help 'Object' -- help on root object 'Object'
  MAD.help 'gmath'  -- help on gmath module

DESCRIPTION
  The 'help' function looks for embedded helps for modules and functions and
  tries to build a list of related topics automatically.

REMARK
  If the 'help' function is exported from the MAD environment, it can be used
  directly:
    MAD.export 'help'
    help 'Object'

RETURN VALUES
  None.

SEE ALSO
  MAD.export.
]]

M.help = function (a)
  assert(is_string(a), "invalid argument #1 (string expected)")
  local dot = string.find(a, '.', 1, true)
  local mod = dot and string.sub(a, 1, dot-1) or a
  local fun = dot and string.sub(a, dot+1) or 'self'
  local ctx = package.loaded[mod] or package.loaded['madl_'..mod] or M[mod]

  -- find help context
  if is_indexable(ctx) and ctx.__help and ctx.__help[fun] then
  elseif is_iterable(ctx) then
    for k,v in pairs(ctx) do
      if is_indexable(v) and v.__help and v.__help[fun] then
        ctx = v ; break
      end
    end
  else
    io.write("  No help found for '"..a.."'.\n")
    return
  end
  io.write(ctx.__help[fun]);

  -- find related (sub) topics
  if is_indexable(ctx[fun]) and ctx[fun].__help then
    ctx = ctx[fun]
  end
  local sub = {}
  for k,_ in pairs(ctx.__help) do
    if k ~= 'self' then sub[#sub+1] = k end
  end
  table.sort(sub)
  local len = 2 -- tab
  for i,v in ipairs(sub) do
    len = len + #v + 2 -- sep
    if len > 80 then sub[i] = '\n  '..v ; len = #v + 2 end
  end
  local str = table.concat(sub, ', ')
  if str ~= '' then
    io.write("\nRelated topics:\n  ", str, '.\n')
  end
end

-- environment ----------------------------------------------------------------o

-- load MAD modules
for _,v in ipairs(modules) do
  M.import(v)
end

-- protect MAD environment (foolproof protection, no more)
local mad = setmetatable({},{__index=M})

-- set global
MAD = mad

-- end ------------------------------------------------------------------------o
return mad
