--[=[
 o-----------------------------------------------------------------------------o
 |
 | MAD environment (sandbox)
 |
 | Methodical Accelerator Design - Copyright CERN 2015+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Load in order all the modules of the MAD application and flatten them into
    the MAD environment for direct 1-level access using local 'in' table syntax.

 o-----------------------------------------------------------------------------o
]=]

local M = { __help = {} }

-- modules --------------------------------------------------------------------o

-- list of modules to import at start in MAD
local modules = {
  'utils', 'object', 'gmath', 'xrange',

-- 'cmad', 'complex', 'matrix',
-- 'mono', 'tpsa', 'ctpsa',
-- 'beam', 'element', 'line', 'sequence', 'table',
-- 'mflow', 'survey', 'track',
}

-- help -----------------------------------------------------------------------o

M.__help.self = [=[
NAME
  MAD -- Methodical Accelerator Design environment

SYNOPSIS
  local component_list in MAD

DESCRIPTION
  The MAD environement provides direct 1-level access to all embedded modules
  of the MAD application. This module also provides online help for modules and
  other components, and it allows to export/import modules, objects, functions
  etc. from/to the MAD environment. This is the recommended way to
  extract/extend the MAD environment with components not embedded in the
  application.

  The MAD environment is automatically loaded in the global environment (i.e.
  _G) when the MAD application is started, unless the -M option is used. Hence,
  all components of MAD can be accessed using table access on the MAD
  environment or retieved in local variables (recommended) using <local in
  table> syntax extension as in the example below.

RETURN VALUE
  A table containing all MAD components.

ERRORS
  None.

EXAMPLES
  local Sequence, Drift, Multipole in MAD    -- local in table syntax
  local quad = MAD.Quadrupole                -- local assignment

  To clear the global environment from MAD, set it to nil:
  local mad = MAD  MAD = nil                 -- retain local and release global
  local Drift in mad                         -- retrieve Drift from local mad

  To clear MAD extensions from the global environment (backup in MAD),
  set them to nil (arg is a Lua feature, not an extension):
  arg, path, warn, trace, trace_setlevel, trace_setlocation = nil
  local argv, path, warn, trace, trace_setlevel, trace_setlocation in MAD

SEE ALSO
  None.
]=]

-- locals ---------------------------------------------------------------------o

local _C in require 'madl_cmad'

local is_nil, is_boolean, is_string, is_rawtable, is_iterable, is_indexable
      in require 'madl_utils'

-- implementation -------------------------------------------------------------o

-- special fields and backup
M._C    = _C     -- C access
M.argv  = arg    -- backup of arg
M.path  = path
M.warn  = warn
M.trace = trace
M.trace_setlevel    = trace_setlevel
M.trace_setlocation = trace_setlocation

M.__help.import = [=[
NAME
  import -- import modules and components to MAD environment

SYNOPSIS
  import('module' [, override])
  import({...} [, override])

DESCRIPTION
  The import function imports modules, tables, functions, objects, etc. into the
  MAD environment. If the argument #1 is a string, it will be treated as the
  name of a module and replaced by the value returned by require before further
  processing. If the argument #1 or the value returned by require is a raw
  table, each key-value pairs of this table will be added individually to the
  MAD environment (i.e. flatten).

RETURN VALUE
  None.

ERRORS
  The import function trigs an error in the following conditions:
    - If argument #1 is not a string or a raw table,
    - If the module to load is not found,
    - If a key already exists in the MAD environment before insertion and
      overriding is not allowed by argument #2 of the forms above.

EXAMPLES
  local import in MAD
  import('module')             -- import module (load and flatten)
  import('module', true)       -- import module but allow override
  import({name=func})          -- import named function
  import({name=func}, true)    -- import function but allow override
  import({...})                -- import anonymous raw table (flatten)
  import({...}, true)          -- import raw table but allow override
  import({constants={}})       -- import raw table (flatten) with a named table

SEE ALSO
  MAD.export.
]=]

M.import = function (a, override)
  assert(is_string(a) or is_rawtable(a),
                           "invalid argument #1 (string or raw table expected)")
  local tbl = is_string(a) and (require('madl_'..a) or require(a)) or a
  assert(tbl ~= nil, "module not found: " .. tostring(a))
  if not is_rawtable(tbl) then tbl = {a=tbl} end -- simplify further processing

  -- collect and check
  local tmp = { obj = {}, hlp = {} } -- make a local copy first in case of error
  for k,v in pairs(tbl) do
    if k ~= '__help' then
      assert(is_nil(M[k]) or override == true,
             "cannot override definition for " .. tostring(k))
      tmp.obj[k] = v
      if is_indexable(v) and v.__help and v.__help.self then
        tmp.hlp[k] = v.__help.self
      end
    end
  end

  -- finalize the import
  for k,v in pairs(tmp.obj) do M[k] = v end
  for k,v in pairs(tmp.hlp) do M.__help[k] = v end
end

M.__help.export = [=[
NAME
  export -- export components from MAD environment

SYNOPSIS
  export(['pattern' [, context [, override]]])
  export({key_list} [, context [, override]]])

DESCRIPTION
  The export function exports tables, functions, objects, etc. from the MAD
  environment to the specified context or global context if none is specified.
  The argument #1 provides a matching pattern or a list of keys to select the
  components to export. The argument #2 specifies the destination context or _G
  if none is specified. The argument #3 override is 'false' by default.

RETURN VALUE
  The destination context.

ERRORS
  The export function trigs an error in the following conditions:
    - If the pattern argument #1 is not a string,
    - If the table argument #1 is not a raw table,
    - If the destination context argument #2 is not indexable,
    - If a key already exists in the destination context before insertion and
      overriding is not allowed by argument #3.

EXAMPLES
  local export in MAD
  export()                       -- export all MAD components to _G
  export('.*')                   -- export all MAD components to _G
  export('.*',_G)                -- export all MAD components to _G
  export('help')                 -- export help function to _G
  export('^is_.*$')              -- export all is_* functions to _G
  ctx = export('^is_.*$',{})     -- export all is_* functions to table
  export 'sin'                   -- export all *sin* function to _G
  export '^sin$'                 -- export only sin function to _G (slow)
  export({'sin'},true)           -- export only sin function to _G (fast)
  export {'sin','cos','tan'}     -- export all these functions to _G (fast)

SEE ALSO
  MAD.import.
]=]

M.export = function (pat, ctx, override)
  if is_boolean(ctx) then
    override, ctx = ctx -- shift args right
  end
  pat, ctx = pat or '.*', ctx or _G -- default
  assert(is_string(pat) or is_rawtable(pat),
                           "invalid argument #1 (string or raw table expected)")
  assert(is_indexable(ctx),"invalid argument #2 (indexable expected)")
  local tbl = is_string(pat) and {} or pat

   -- record matching keys
  if is_string(pat) then
    for k in pairs(M) do
      if is_string(k) and string.find(k, pat) then
        tbl[#tbl+1] = k
      end
    end
  end

  -- process export
  for _,k in ipairs(tbl) do
    if M[k] then
      assert(ctx[k] == nil or override == true,
             "cannot override definition for " .. tostring(k))
      ctx[k] = M[k]
    end
  end
  return ctx
end

M.__help.help = [=[
NAME
  help -- display help for modules and functions

SYNOPSIS
  help('topic')

DESCRIPTION
  The help function looks for embedded helps for modules and functions and tries
  to build a list of 'Related topics' automatically.

  If the help function is exported from the MAD environment, it can be used
  directly, as follow:
    MAD.export 'help'
    help 'topic'

RETURN VALUE
  None.

ERROR
  None.

EXAMPLES
  local help in MAD
  help 'help'   -- help on help
  help 'Object' -- help on root object 'Object'
  help 'gmath'  -- help on gmath module

SEE ALSO
  MAD.export.
]=]

M.help = function (a)
  assert(is_string(a), "invalid argument #1 (string expected)")
  local dot = string.find(a, '.', 1, true)
  local mod = dot and string.sub(a, 1, dot-1) or a
  local fun = dot and string.sub(a, dot+1) or 'self'
  local ctx = package.loaded[mod] or package.loaded['madl_'..mod] or M[mod]
  local ref

  -- find help context
  if is_indexable(ctx) and ctx.__help and ctx.__help[fun] then
    ref = ctx
  elseif is_iterable(ctx) then
    for k,v in pairs(ctx) do
      if is_indexable(v) and v.__help and v.__help[fun] then
        ref = v ; break
      end
    end
  end
  if not ref then
    io.write("  No help found for '" .. a .. "'.\n")
    return
  end
  io.write(ref.__help[fun]);

  -- find related (sub) topics, sort items, and wrap ouput at 80 columns
  if is_indexable(ref[fun]) and ref[fun].__help then
    ref = ref[fun]
  end
  local sub = {}
  for k,_ in pairs(ref.__help) do
    if k ~= 'self' then sub[#sub+1] = k end
  end
  table.sort(sub)
  local len = 2 -- tab
  for i,v in ipairs(sub) do
    len = len + #v + 2 -- sep
    if len > 80 then sub[i] = '\n  '..v ; len = #v + 2 end
  end
  local str = table.concat(sub, ', ')
  if str ~= '' then
    io.write("\nRelated topics:\n  ", str, '.\n')
  end
end

-- environment ----------------------------------------------------------------o

-- load MAD modules
for _,v in ipairs(modules) do
  M.import(v)
end

-- protect MAD environment (foolproof protection, no more)
local mad = setmetatable({},{__index=M})

-- set global
MAD = mad

-- end ------------------------------------------------------------------------o
return mad
