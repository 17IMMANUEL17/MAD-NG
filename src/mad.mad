--[=[
 o-----------------------------------------------------------------------------o
 |
 | MAD environement (sandbox)
 |
 | Methodical Accelerator Design - Copyright CERN 2015
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Load in order all the modules of the MAD application and flatten them in
    the mad module for direct 1-level access using local 'in' table syntax.

 o-----------------------------------------------------------------------------o
]=]

local M = { __help = {} }

-- help -----------------------------------------------------------------------o

M.__help.self = [[
NAME
  mad -- Methodical Accelerator Design environment

SYNOPSIS
  local mad = require 'mad'

DESCRIPTION
  The 'mad' module provides direct 1-level access to all the modules content of
  the MAD application. This is the recommended way to load the MAD environment.

RETURN VALUES
  The table containing all modules returned content flatten.

SEE ALSO
  None
]]

-- locals ---------------------------------------------------------------------o

local modules = {
-- order matters
  'utils',
  'object',

-- 'cmad',
-- 'gmath',
-- 'range',
-- 'complex',
-- 'matrix',
--
-- 'mono',
-- 'tpsa',
-- 'ctpsa',
--
-- 'beam',
-- 'element',
-- 'line',
-- 'sequence',
-- 'table',
--
-- 'mflow',
-- 'survey',
-- 'track',
}

local is_string, is_table, is_iterable, is_indexable in require 'madl_utils'

-- implementation -------------------------------------------------------------o

M.import = function (a, override)
  local m = a
  if is_string(a) then
    m = require('madl_'..a) or require(a);
    assert(m ~= nil, "module not found: "..a)
  end

  if is_iterable(m) then
    for k,v in pairs(m) do
      assert(M[k] == nil or override, "overriding definition: "..k.." ["..a.."]")
      M[k] = v
    end
  else
    assert(M[a] == nil or override, "overriding definition: "..a)
    M[a] = m
  end
end

M.export = function (a, pat, override)
  a = a or _G
  pat = pat or '.*'
  assert(is_table(a)   , "invalid argument #1 (table expected)")
  assert(is_string(pat), "invalid argument #2 (string expected)")
  for k,v in pairs(M) do
    if is_string(k) then
        if string.find(k, pat) and
           a[k] == nil or override then a[k] = v end
    else
        if a[k] == nil or override then a[k] = v end
    end
  end
  return a
end

M.help = function (a)
  assert(is_string(a), "invalid argument #1 (string expected)")
  local dot = string.find(a, '.', 1, true)
  local mod = dot and string.sub(a, 1, dot-1) or a
  local fun = dot and string.sub(a, dot+1) or 'self'
  local ctx = package.loaded[mod] or package.loaded['madl_'..mod] or
							package.loaded['mad'][mod] -- or?
  local str = "  No help found\n"
  if is_indexable(ctx) and ctx.__help and ctx.__help[fun] then
      str = ctx.__help[fun]
  elseif is_iterable(ctx) then
  	for k,v in pairs(ctx) do
  		if is_indexable(v) and v.__help and v.__help[fun] then
      	str = v.__help[fun]
      end
    end
  end
  io.write(str)
end

-- self ref
M.mad = M

-- load MAD modules
for _,v in ipairs(modules) do
  M.import(v)
end

-- end ------------------------------------------------------------------------o
return M
