--[=[
 o-----------------------------------------------------------------------------o
 |
 | MAD environement (sandbox)
 |
 | Methodical Accelerator Design - Copyright CERN 2015
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Load in order all the modules of the MAD application and flatten them in
    the mad module for direct 1-level access using local 'in' table syntax.

 o-----------------------------------------------------------------------------o
]=]

local M = { __help = {} }

-- help -----------------------------------------------------------------------o

M.__help.self = [[
NAME
  mad -- Methodical Accelerator Design environment

SYNOPSIS
  local mad = require 'mad'

DESCRIPTION
  The 'mad' module provides direct 1-level access to all the modules content of
  the MAD application. This is the recommended way to load the MAD environment.

RETURN VALUES
  The table containing all modules and their content flatten.

SEE ALSO
  None
]]

-- implementation -------------------------------------------------------------o

local function is_table (a)
  return type(a) == 'table' and getmetatable(a) == nil
end

local function load_modules (modules)
  for i=1,#modules do
    local modname = modules[i]
    assert(M[modname] == nil, "overriding mad definition: "..modname)

    local modref = require ("madl_"..modname);
    assert(modref ~= nil, "module not found: "..modname)
--    assert(type(modref.__help) == 'table', "module without help: "..modname)

    if is_table(modref) then
      for k,v in pairs(modref) do
        assert(M[k] == nil,"overriding mad definition: "..k.." ["..modname.."]")
        M[k] = v
      end
    else
      M[modname] = modref
    end
  end
end

-- modules to load ------------------------------------------------------------o

-- order matters.
load_modules {
  'object',

--  'helper',
--  'beam',
--  'element',
--  'sequence',
}

-------------------------------------------------------------------------------o
return M
