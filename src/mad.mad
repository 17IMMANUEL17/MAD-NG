--[=[
 o-----------------------------------------------------------------------------o
 |
 | MAD environement (sandbox)
 |
 | Methodical Accelerator Design - Copyright CERN 2015+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Load in order all the modules of the MAD application and flatten them into
    the MAD environment for direct 1-level access using local 'in' table syntax.

 o-----------------------------------------------------------------------------o
]=]

local M = { __help = {} }

-- help -----------------------------------------------------------------------o

M.__help.self = [[
NAME
  mad -- Methodical Accelerator Design environment

SYNOPSIS
  local mad = require 'mad'

DESCRIPTION
  The 'mad' module provides direct 1-level access to all modules of the MAD
  application. This is the recommended way to load the MAD environment. This
  module also provides online help for modules and functions, and it allows to
  export/import modules, tables, functions etc. from/into the MAD environment.

RETURN VALUES
  A table containing all modules flatten.

SEE ALSO
  None
]]

-- locals ---------------------------------------------------------------------o

local modules = {
-- order matters
  'utils',
  'object',

-- 'cmad',
-- 'gmath',
'xrange',
-- 'complex',
-- 'matrix',
--
-- 'mono',
-- 'tpsa',
-- 'ctpsa',
--
-- 'beam',
-- 'element',
-- 'line',
-- 'sequence',
-- 'table',
--
-- 'mflow',
-- 'survey',
-- 'track',
}

local is_string, is_table, is_rawtable, is_iterable, is_indexable
      in require 'madl_utils'

-- implementation -------------------------------------------------------------o

M.import = function (a, override)
  local m = a
  if is_string(a) then
    m = require('madl_'..a) or require(a);
    assert(m ~= nil, "module not found: "..a)
  end

  if is_rawtable(m) then
    for k,v in pairs(m) do
      assert(M[k] == nil or override, "overriding definition: "..k.." ["..a.."]")
      M[k] = v
      if is_indexable(v) and v.__help and v.__help.self then
        M.__help[k] = v.__help.self
      end
    end
  else
    assert(M[a] == nil or override, "overriding definition: "..a)
    M[a] = m
    if is_indexable(m) and m.__help and m.__help.self then
      M.__help[a] = m.__help.self
    end
  end
end

M.export = function (pat_, ctx_, override)
  local pat = pat_ or '.*'
  local ctx = ctx_ or _G
  assert(is_string(pat), "invalid argument #1 (string expected)")
  assert(is_indexable(ctx), "invalid argument #2 (table expected)")
  for k,v in pairs(M) do
    if is_string(k) then
        if string.find(k, pat) and
           ctx[k] == nil or override then ctx[k] = v end
    else
        if ctx[k] == nil or override then ctx[k] = v end
    end
  end
  return ctx
end

M.help = function (a)
  assert(is_string(a), "invalid argument #1 (string expected)")
  local dot = string.find(a, '.', 1, true)
  local mod = dot and string.sub(a, 1, dot-1) or a
  local fun = dot and string.sub(a, dot+1) or 'self'
  local ctx = package.loaded[mod] or package.loaded['madl_'..mod] or
              package.loaded['mad'][mod] -- or?

  -- find help context
  if is_indexable(ctx) and ctx.__help and ctx.__help[fun] then
  elseif is_iterable(ctx) then
    for k,v in pairs(ctx) do
      if is_indexable(v) and v.__help and v.__help[fun] then
        ctx = v ; break
      end
    end
  else
    io.write("  No help found for '"..a.."'\n")
    return
  end
  io.write(ctx.__help[fun]);

  -- find related (sub) topics
  if is_indexable(ctx[fun]) and ctx[fun].__help then
    ctx = ctx[fun]
  end
  local sub = {}
  for k,_ in pairs(ctx.__help) do
    if k ~= 'self' then sub[#sub+1] = k end
  end
  table.sort(sub)
  local len = 2 -- tab
  for i,v in ipairs(sub) do
    len = len + #v + 2 -- sep
    if len > 80 then sub[i] = '\n  '..v ; len = #v + 2 end
  end
  local str = table.concat(sub, ', ')
  if str ~= '' then
    io.write("\nRelated topics:\n  ", str, '\n')
  end
end

-- end ------------------------------------------------------------------------o

-- load MAD modules
for _,v in ipairs(modules) do
  M.import(v)
end

-- set global
mad = M

return M
