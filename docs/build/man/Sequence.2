.\" Man page generated from reStructuredText.
.
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.TH "SEQUENCE" "2" "Aug 30, 2022" "" "MAD-NG"
.SH NAME
Sequence \- Object man page
.sp
The MAD Sequences are objects convenient to describe accelerators lattices built from a \fIlist\fP of elements with increasing \fBs\fP\-positions. The sequences are also containers that provide fast access to their elements by referring to their indexes, \fBs\fP\-positions, or (mangled) names, or by running iterators constrained with ranges and predicates.
The \fBsequence\fP object is the \fIroot object\fP of sequences that store information relative to lattices.
.sp
The \fBsequence\fP module extends the \fI\%typeid\fP module with the \fBis_sequence\fP function, which returns \fBtrue\fP if its argument is a \fBsequence\fP object, \fBfalse\fP otherwise.
.SH ATTRIBUTES
.sp
The \fBsequence\fP object provides the following attributes:
.INDENT 0.0
.TP
\fBl\fP
A \fInumber\fP specifying the length of the sequence \fB[m]\fP\&. A \fBnil\fP will be replaced by the computed lattice length. A value greater or equal to the computed lattice length will be used to place the \fB$end\fP marker. Other values will raise an error. (default: \fBnil\fP).
.TP
\fBdir\fP
A \fInumber\fP holding one of \fB1\fP (forward) or \fB\-1\fP (backward) and specifying the direction of the sequence. [1] (default:~ \fB1\fP)
.TP
\fBrefer\fP
A \fIstring\fP holding one of \fB"entry"\fP, \fB"centre"\fP or    return true \fB"exit"\fP to specify the default reference position in the elements to use for their placement. An element can override it with its \fBrefpos\fP attribute, see \fI\%element positions\fP details. (default: \fBnil\fP \eequiv \fB"centre"\fP).
.TP
\fBowner\fP
A \fIlogical\fP specifying if an \fIempty\fP sequence is a view with no data \fB(owner ~= true)\fP, or a sequence holding data \fB(owner == true)\fP\&. (default: \fBnil\fP)
.TP
\fBminlen\fP
A \fInumber\fP specifying the minimal length \fB[m]\fP to generate \fIimplicit\fP drifts between elements in s\-iterators generated by the method \fB:siter\fP\&. This attribute is automatically set to 10^{\-6} m when a sequence is created within the MADX environment. (default: \fBnil\fP)
.TP
\fBbeam\fP
An attached \fBbeam\fP\&. (default: \fBnil\fP)
.UNINDENT
.sp
\fBWarning\fP: the following private and read\-only attributes are present in all sequences and should \fInever be used, set or changed\fP; breaking this rule would lead to an \fIundefined behavior\fP:
.INDENT 0.0
.TP
\fB__dat\fP
A \fItable\fP containing all the private data of sequences.
.TP
\fB__cycle\fP
A \fIreference\fP to the element registered with the \fB:cycle\fP method. (default: \fBnil\fP)
.UNINDENT
.SH METHODS
.sp
The \fBsequence\fP object provides the following methods:
.INDENT 0.0
.TP
\fBelem\fP
A \fImethod\fP \fB(idx)\fP returning the element stored at the positive index \fBidx\fP in the sequence, or \fBnil\fP\&.
.TP
\fBspos\fP
A \fImethod\fP \fB(idx)\fP returning the s\-position at the entry of the element stored at the positive index \fBidx\fP in the sequence, or \fBnil\fP\&.
.TP
\fBupos\fP
A \fImethod\fP \fB(idx)\fP returning the s\-position at the user\-defined \fBrefpos\fP offset of the element stored at the positive index \fBidx\fP
in the sequence, or \fBnil\fP\&.
.TP
\fBds\fP
A \fImethod\fP \fB(idx)\fP returning the length of the element stored at the positive index \fBidx\fP in the sequence, or \fBnil\fP\&.
.TP
\fBalign\fP
A \fImethod\fP \fB(idx)\fP returning a \fIset\fP specifying the misalignment of the element stored at the positive index \fBidx\fP in the sequence, or \fBnil\fP\&.
.TP
\fBindex\fP
A \fImethod\fP \fB(idx)\fP returning a positive index, or \fBnil\fP\&. If \fBidx\fP is negative, it is reflected versus the size of the sequence, e.g. \fB\-1\fP
becomes \fB#self\fP, the index of the \fB$end\fP marker.
.TP
\fBname_of\fP
A \fImethod\fP \fB(idx, [ref])\fP returning a \fIstring\fP corresponding to the (mangled) name of the element at the index \fBidx\fP or \fBnil\fP\&. An element
name appearing more than once in the sequence will be mangled with an absolute count, e.g. \fBmq[3]\fP, or a relative count versus the optional
reference element \fBref\fP determined by \fB:index_of\fP, e.g. \fBmq{\-2}\fP\&.
.TP
\fBindex_of\fP
A \fImethod\fP \fB(a, [ref], [dir])\fP returning a \fInumber\fP corresponding to the positive index of the element determined by the first argument or \fBnil\fP\&.
If \fBa\fP is a \fInumber\fP (or a \fIstring\fP representing a \fInumber\fP), it is interpreted as the s\-position of an element and returned as a second
\fInumber\fP\&. If \fBa\fP is a \fIstring\fP, it is interpreted as the (mangled) name of an element as returned by \fB:name_of\fP\&. Finally, \fBa\fP can be a \fIreference\fP
to an element to search for. The argument \fBref\fP (default: \fBnil)\fP specifies the reference element determined by \fB:index_of(ref)\fP to use for
relative s\-positions, for decoding mangled names with relative counts, or as the element to start searching from. The argument \fBdir\fP
(default: \fB1)\fP specifies the direction of the search with values \fB1\fP (forward), \fB\-1\fP (backward), or \fB0\fP (no direction). The \fBdir=0\fP
case may return an index at half\-integer if \fBa\fP is interpreted as an s\-position pointing to an \fIimplicit drift\fP\&.
.TP
\fBrange_of\fP
A \fImethod\fP \fB([rng], [ref], [dir]\fP) returning three \fInumbers\fP corresponding to the positive indexes \fIstart\fP and \fIend\fP of the range and
its direction \fIdir\fP, or \fBnil\fP for an empty range. If \fBrng\fP is omitted, it returns \fB1\fP, \fB#self\fP, \fB1\fP, or \fB#self\fP, \fB1\fP, \fB\-1\fP
if \fBdir\fP is negative. If \fBrng\fP is a \fInumber\fP or a \fIstring\fP with no \fB\(aq/\(aq\fP separator, it is interpreted as both \fIstart\fP and \fIend\fP and
determined by \fBindex_of\fP\&. If \fBrng\fP is a \fIstring\fP containing the separator \fB\(aq/\(aq\fP, it is split in two \fIstrings\fP interpreted as \fIstart\fP
and \fIend\fP, both determined by \fB:index_of\fP\&. If \fBrng\fP is a \fIlist\fP, it will be interpreted as {\fIstart\fP, \fIend\fP, \fB[ref]\fP, \fB[dir]\fP},
both determined by \fB:index_of\fP, unless \fBref\fP equals \fB\(aqidx\(aq\fP then both are determined by \fB:index\fP (i.e. a \fInumber\fP is interpreted as an
index instead of a s\-position). The arguments \fBref\fP (default: \fBnil\fP) and \fBdir\fP (default: \fB1\fP) are forwarded to all invocations
of \fB:index_of\fP with a higher precedence than ones in the \fIlist\fP \fBrng\fP, and a runtime error is raised if the method returns \fBnil\fP, i.e.
to disambiguate between a valid empty range and an invalid range.
.TP
\fBlength_of\fP
A \fImethod\fP \fB([rng], [ntrn], [dir]\fP) returning a \fInumber\fP specifying the length of the range optionally including \fBntrn\fP extra turns (default: \fB0\fP),
and calculated from the indexes returned by \fB:range_of([rng], nil, [dir])\fP\&.
.TP
\fBiter\fP
A \fImethod\fP \fB([rng], [ntrn], [dir])\fP returning an iterator over the sequence elements. The optional range is determined by
TT{:range_of(rng, [dir])}, optionally including \fBntrn\fP turns (default: \fB0\fP). The optional direction \fBdir\fP specifies the forward \fB1\fP
or the backward \fB\-1\fP direction of the iterator. If \fBrng\fP is not provided and the ?sequence? is cycled, the \fIstart\fP and \fIend\fP indexes are
determined by \fB:index_of(self.__cycle)\fP\&. When used with a generic \fBfor\fP loop, the iterator returns at each element: its index,
the element itself, its s\-position over the running loop and its signed length depending on the direction.
.TP
\fBsiter\fP
A \fImethod\fP \fB([rng], [ntrn], [dir])\fP returning an s\-iterator over the sequence elements. The optional range is determined by
\fB:range_of([rng], nil, [dir])\fP, optionally including \fBntrn\fP turns (default: \fB0\fP). The optional direction \fBdir\fP specifies the
forward \fB1\fP or the backward \fB\-1\fP direction of the iterator. When used with a generic \fBfor\fP loop, the iterator returns at each
iteration: its index, the element itself or an \fIimplicit\fP \fBdrift\fP, its s\-position over the running loop and its signed length
depending on the direction. Each \fIimplicit\fP drift is built on\-the\-fly by the iterator with a length equal to the gap between the elements
surrounding it and a half\-integer index equal to the average of their indexes. The length of \fIimplicit\fP drifts is bounded by the maximum
between the sequence attribute \fBminlen\fP and the \fBminlen\fP from the \fI\%constant\fP module.
.TP
\fBforeach\fP
A \fImethod\fP \fB(act, [rng], [sel], [not])\fP returning the sequence itself after applying the action \fBact\fP on the selected elements. If \fBact\fP
is a \fIset\fP representing the arguments in the packed form, the missing arguments will be extracted from the attributes \fBaction\fP,
\fBrange\fP, \fBselect\fP and \fBdefault\fP\&. The action \fBact\fP must be a \fIcallable\fP \fB(elm, idx, [midx])\fP applied to an element passed as
first argument and its index as second argument, the optional third argument being the index of the main element in case \fBelm\fP is a sub\-element.
The optional range is used to generate the loop iterator \fB:iter([rng])\fP\&. The optional selector \fBsel\fP is a \fIcallable\fP \fB(elm, idx, [midx])\fP
predicate selecting eligible elements for the action using the same arguments. The selector \fBsel\fP can be specified in other ways,
see \fI\%element selections\fP for details. The optional \fIlogical\fP \fBnot\fP (default: \fBfalse\fP) indicates how to interpret default selection, as
\fIall\fP or \fInone\fP, depending on the semantic of the action. [2]
.TP
\fBselect\fP
A \fImethod\fP \fB([flg], [rng], [sel], [not])\fP returning the sequence itself after applying the action \fB:select([flg])\fP to the elements using
\fB:foreach(act, [rng], [sel], [not])\fP\&. By default sequence have all their elements deselected with only the \fB$end\fP marker \fBobserved\fP\&.
.TP
\fBdeselect\fP
A \fImethod\fP \fB([flg], [rng], [sel], [not])\fP returning the sequence itself after applying the action \fB:deselect([flg])\fP to the elements
using \fB:foreach(act, [rng], [sel], [not])\fP\&. By default sequence have all their elements deselected with only the \fB$end\fP marker \fBobserved\fP\&.
.TP
\fBfilter\fP
A \fImethod\fP \fB([rng], [sel], [not])\fP returning a \fIlist\fP containing the positive indexes of the elements determined by \fB:foreach(act, [rng], [sel], [not])\fP,
and its size. The \fIlogical\fP \fBsel.subelem\fP specifies to select sub\-elements too, and the \fIlist\fP may contain non\-integer indexes encoding their main element
index added to their relative position, i.e. \fBmidx.sat\fP\&. The builtin \fIfunction\fP \fBmath.modf(num)\fP allows to retrieve easily the main element \fBmidx\fP and
the sub\-element \fBsat\fP, e.g. \fBmidx,sat = math.modf(val)\fP\&.
.TP
\fBinstall\fP
A \fImethod\fP \fB(elm, [rng], [sel], [cmp])\fP returning the sequence itself after installing the elements in the \fIlist\fP \fBelm\fP at their
\fI\%element positions\fP; unless \fBfrom="selected"\fP is defined meaning multiple installations at positions relative to each element determined by the method
\fB:filter([rng], [sel], true)\fP\&. The \fIlogical\fP \fBsel.subelem\fP is ignored. If the arguments are passed in the packed form, the extra attribute \fBelements\fP
will be used as a replacement for the argument \fBelm\fP\&. The \fIlogical\fP \fBelm.subelem\fP specifies to install elements with s\-position falling inside
sequence elements as sub\-elements, and set their \fBsat\fP attribute accordingly. The optional \fIcallable\fP \fBcmp(elmspos, spos[idx])\fP (default: \fB"<"\fP) is used
to search for the s\-position of the installation, where equal s\-position are installed after (i.e. before with \fB"<="\fP), see \fBbsearch\fP from
the \fI\%utility\fP module for details. The \fIimplicit\fP drifts are checked after each element installation.
.TP
\fBreplace\fP
A \fImethod\fP \fB(elm, [rng], [sel])\fP returning the \fIlist\fP of replaced elements by the elements in the \fIlist\fP \fBelm\fP placed at their \fI\%element positions\fP, and the
\fIlist\fP of their respective indexes, both determined by \fB:filter([rng], [sel], true)\fP\&. The \fIlist\fP \fBelm\fP cannot contain instances of \fBsequence\fP or \fBbline\fP
elements and will be recycled as many times as needed to replace all selected elements. If the arguments are passed in the packed form, the extra attribute
\fBelements\fP will be used as a replacement for the argument \fBelm\fP\&. The \fIlogical\fP \fBsel.subelem\fP specifies to replace selected sub\-elements too and set
their \fBsat\fP attribute to the same value. The \fIimplicit\fP drifts are checked only once all elements have been replaced.
.TP
\fBremove\fP
A \fImethod\fP \fB([rng], [sel])\fP returning the \fIlist\fP of removed elements and the \fIlist\fP of their respective indexes, both determined by \fB:filter([rng], [sel], true)\fP\&.
The \fIlogical\fP \fBsel.subelem\fP specifies to remove selected sub\-elements too.
.TP
\fBmove\fP
A \fImethod\fP \fB([rng], [sel])\fP returning the sequence itself after updating the \fI\%element positions\fP at the indexes determined by \fB:filter([rng], [sel], true)\fP\&.
The \fIlogical\fP \fBsel.subelem\fP is ignored. The elements must keep their order in the sequence and surrounding \fIimplicit\fP drifts are checked only once all elements
have been moved. [3]
.TP
\fBmisalign\fP
A \fImethod\fP \fB(algn, [rng], [sel])\fP returning the sequence itself after setting the \fI\%element misalignments\fP from
\fBalgn\fP at the indexes determined by \fB:filter([rng], [sel], true)\fP\&. If \fBalgn\fP is a \fImappable\fP, it will be used to misalign the filtered elements.
If \fBalgn\fP is a \fIiterable\fP, it will be accessed using the filtered elements indexes to retrieve their specific misalignment.
If \fBalgn\fP is a \fIcallable\fP \fB(idx)\fP, it will be invoked for each filtered element with their index as solely argument to retrieve their specific misalignment.
.TP
\fBreflect\fP
A \fImethod\fP \fB([name])\fP returning a new sequence from the sequence reversed, and named from the optional \fIstring\fP \fBname\fP (default: \fBself.name..\(aq_rev\(aq\fP).
.TP
\fBcycle\fP
A \fImethod\fP \fB(a)\fP returning the sequence itself after checking that \fBa\fP is a valid reference using \fB:index_of(a)\fP, and storing it in the \fB__cycle\fP attribute,
itself erased by the methods editing the sequence like \fB:install\fP, \fB:replace\fP, \fB:remove\fP, \fB:share\fP, and \fB:unique\fP\&.
.TP
\fBshare\fP
A \fImethod\fP \fB(seq2)\fP returning the \fIlist\fP of elements removed from the \fBseq2\fP and the \fIlist\fP of their respective indexes, and replaced by the elements from the
sequence with the same name when they are unique in both sequences.
.TP
\fBunique\fP
A \fImethod\fP \fB([fmt])\fP returning the sequence itself after replacing all non\-unique elements by new instances sharing the same parents.
The optional \fBfmt\fP must be a \fIcallable\fP \fB(name, cnt, idx)\fP that returns the mangled name of the new instance build from the element \fBname\fP,
its count \fBcnt\fP and its index \fBidx\fP in the sequence. If the optional \fBfmt\fP is a \fIstring\fP, the mangling \fIcallable\fP is built by binding \fBfmt\fP
as first argument to the function \fBstring.format\fP from the standard library, see
\fI\%Lua 5.2\fP §6.4 for details.
.TP
\fBpublish\fP
A \fImethod\fP \fB(env, [keep])\fP returning the sequence after publishing all its elements in the environment \fBenv\fP\&. If the \fIlogical\fP \fBkeep\fP is
\fBtrue\fP, the method will preserve existing elements from being overridden. This method is automatically invoked with \fBkeep=true\fP when sequences
are created within the \fBMADX\fP environment.
.TP
\fBcopy\fP
A \fImethod\fP \fB([name], [owner])\fP returning a new sequence from a copy of \fBself\fP, with the optional \fBname\fP and the optional attribute \fBowner\fP set.
If the sequence is a view, so will be the copy unless \fBowner == true\fP\&.
.TP
\fBis_view\fP
A \fImethod\fP () returning \fBtrue\fP if the sequence is a view over another sequence data, \fBfalse\fP otherwise.
.TP
\fBset_readonly\fP
Set the sequence as read\-only, including its columns.
.TP
\fBsave_flags\fP
A \fImethod\fP \fB([flgs])\fP saving the flags of all the elements to the optional \fIiterable\fP \fBflgs\fP (default: \fB{}\fP) and return it.
.TP
\fBrestore_flags\fP
A \fImethod\fP \fB(flgs)\fP restoring the flags of all the elements from the \fIiterable\fP \fBflgs\fP\&. The indexes of the flags must match the indexes of the elements
in the sequence.
.TP
\fBdumpseq\fP
A \fImethod\fP \fB([fil], [info])\fP} displaying on the optional file \fBfil\fP (default: \fBio.stdout\fP) information related to the position and length of the elements.
Useful to identify negative drifts and badly positioned elements. The optional argument \fBinfo\fP indicates to display extra information like elements misalignments.
.TP
\fBcheck_sequ\fP
A \fImethod\fP () checking the integrity of the sequence and its dictionary, for debugging purpose only.
.UNINDENT
.SH METAMETHODS
.sp
The \fBsequence\fP object provides the following metamethods:
.INDENT 0.0
.TP
\fB__len\fP
A \fImethod\fP () called by the length operator \fB#\fP to return the size of the sequence, i.e. the number of elements stored including the \fB"\e$start"\fP and
\fB"\e$end"\fP markers.
.TP
\fB__index\fP
A \fImethod\fP \fB(key)\fP called by the indexing operator \fB[key]\fP to return the \fIvalue\fP of an attribute determined by \fIkey\fP\&. The \fIkey\fP is interpreted differently depending
on its type with the following precedence:
1. A \fInumber\fP is interpreted as an element index and returns the element or \fBnil\fP\&.
#. Other \fIkey\fP types are interpreted as \fIobject\fP attributes subject to object model lookup.
#. If the \fIvalue\fP associated with \fIkey\fP is \fBnil\fP, then \fIkey\fP is interpreted as an element name and returns either the element or an \fIiterable\fP on the elements with the same name. [4]
#. Otherwise returns \fBnil\fP\&.
.TP
\fB__newindex\fP
A \fImethod\fP \fB(key, val)\fP called by the assignment operator \fB[key]=val\fP to create new attributes for the pairs (\fIkey\fP, \fIvalue\fP).
If \fIkey\fP is a \fInumber\fP specifying the index or a \fIstring\fP specifying the name of an existing element, the following error is raised:
\fB"invalid sequence write access (use replace method)"\fP
.TP
\fB__init\fP
A \fImethod\fP () called by the constructor to compute the elements positions.
.TP
\fB__copy\fP
A \fImethod\fP () similar to the \fB:copy\fP \fImethod\fP\&.
.UNINDENT
.sp
The following attribute is stored with metamethods in the metatable, but has different purpose:
.sp
\fB__sequ\fP A unique private \fIreference\fP that characterizes sequences.
.SH SEQUENCES CREATION
.sp
During its creation as an \fIobject\fP, a sequence can defined its attributes as any object, and the \fIlist\fP of its elements that must form a
\fIsequence\fP of increasing s\-positions. When subsequences are part of this \fIlist\fP, they are replaced by their respective elements as a
sequence \fIelement\fP cannot be present inside other sequences. If the length of the sequence is not provided, it will be computed and set automatically.
During their creation, sequences compute the s\-positions of their elements as described in the section \fI\%element positions\fP, and check for overlapping
elements that would raise a “negative drift” runtime error.
.sp
The following example shows how to create a sequence form a \fIlist\fP of elements and subsequences:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
local sequence, drift, marker in MAD.element
local df, mk = drift \(aqdf\(aq {l=1}, marker \(aqmk\(aq {}
local seq = sequence \(aqseq\(aq {
df \(aqdf1\(aq {}, mk \(aqmk1\(aq {},
sequence {
   sequence { mk \(aqmk0\(aq {} },
   df \(aqdf.s\(aq {}, mk \(aqmk.s\(aq {}
},
df \(aqdf2\(aq {}, mk \(aqmk2\(aq {},
} :dumpseq()
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Displays
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
sequence: seq, l=3
idx  kind     name         l          dl       spos       upos    uds
001  marker   (*$start*)   0.000       0       0.000      0.000   0.000
002  drift    df1          1.000       0       0.000      0.500   0.500
003  marker   mk1          0.000       0       1.000      1.000   0.000
004  marker   mk0          0.000       0       1.000      1.000   0.000
005  drift    df.s         1.000       0       1.000      1.500   0.500
006  marker   mk.s         0.000       0       2.000      2.000   0.000
007  drift    df2          1.000       0       2.000      2.500   0.500
008  marker   mk2          0.000       0       3.000      3.000   0.000
009  marker   (*$end*)     0.000       0       3.000      3.000   0.000
.ft P
.fi
.UNINDENT
.UNINDENT
.SH ELEMENT POSITIONS
.sp
A sequence looks at the following attributes of an element, including sub\-sequences, when installing it, \fIand only at that time\fP, to determine its position:
.INDENT 0.0
.TP
\fBat\fP
A \fInumber\fP holding the position in [m] of the element in the sequence relative to the position specified by the \fBfrom\fP attribute.
.TP
\fBfrom\fP
A \fIstring\fP holding one of \fB"start"\fP, \fB"prev"\fP, \fB"next"\fP, \fB"end"\fP or \fB"selected"\fP, or the (mangled) name of another element to use as the reference position,
or a \fInumber\fP holding a position in [m] from the start of the sequence. (default: \fB"start"\fP if \fBat\fP\egeq 0, \fB"end"\fP if \fBat\fP<0, and \fB"prev"\fP
otherwise)
.TP
\fBrefpos\fP
A \fIstring\fP holding one of \fB"entry"\fP, \fB"centre"\fP or \fB"exit"\fP,  or the (mangled) name of a sequence sub\-element to use as the reference position,
or a \fInumber\fP specifying a position [m] from the start of the element, all of them resulting in an offset to substract to the \fBat\fP attribute to find the
s\-position of the element entry. (default: \fBnil\fP \eequiv \fBself.refer\fP).
.TP
\fBshared\fP
A \fIlogical\fP specifying if an element is used at different positions in the same sequence definition, i.e. shared multiple times,
through temporary instances to store the many \fBat\fP and \fBfrom\fP attributes needed to specify its positions.
Once built, the sequence will drop these temporary instances in favor of their common parent, i.e. the original shared element.
.TP
\fBWarning:\fP
The \fBat\fP and \fBfrom\fP attributes are not considered as intrinsic properties of the elements and are used only once during installation.
Any reuse of these attributes is the responsibility of the user, including the consistency between \fBat\fP and \fBfrom\fP after updates.
.UNINDENT
.SH ELEMENT SELECTIONS
.sp
The element selection in sequence use predicates in combination with iterators. The sequence iterator manages the range of elements where to apply the selection,
while the predicate says if an element in this range is illegible for the selection. In order to ease the use of methods based on the \fB:foreach\fP method,
the selector predicate \fBsel\fP can be built from different types of information provided in a \fIset\fP with the following attributes:
.INDENT 0.0
.TP
\fBflag\fP
A \fInumber\fP interpreted as a flags mask to pass to the element method \fB:is_selected\fP\&. It should not be confused with the flags passed as argument to methods
\fB:select\fP and \fB:deselect\fP, as both flags can be used together but with different meanings!
.TP
\fBpattern\fP
A \fIstring\fP interpreted as a pattern to match the element name using \fBstring.match\fP from the standard library, see
\fI\%Lua 5.2\fP §6.4 for details.
.TP
\fBclass\fP
An \fIelement\fP interpreted as a \fIclass\fP to pass to the element method \fB:is_instansceOf\fP\&.
.TP
\fBlist\fP
An \fIiterable\fP interpreted as a \fIlist\fP used to build a \fIset\fP and select the elements by their name, i.e. the built predicate will use \fBtbl[elm.name]\fP
as a \fIlogical\fP\&. If the \fIiterable\fP is a single item, e.g. a \fIstring\fP, it will be converted first to a \fIlist\fP\&.
.TP
\fBtable\fP
A \fImappable\fP interpreted as a \fIset\fP used to select the elements by their name, i.e. the built predicate will use \fBtbl[elm.name]\fP as a \fIlogical\fP\&.
If the \fImappable\fP contains a \fIlist\fP or is a single item, it will be converted first to a \fIlist\fP and its \fIset\fP part will be discarded.
.TP
\fBselect\fP
A \fIcallable\fP interpreted as the selector itself, which allows to build any kind of predicate or to complete the restrictions already built above.
.TP
\fBsubelem\fP
A \fIboolean\fP indicating to include or not the sub\-elements in the scanning loop. The predicate and the action receive the sub\-element and its sub\-index as
first and second argument, and the main element index as third argument.
.UNINDENT
.sp
All these attributes are used in the aforementioned order to incrementally build predicates that are combined with logical conjunctions, i.e. \fBand\fP’ed,
to give the final predicate used by the \fB:foreach\fP method. If only one of these attributes is needed, it is possible to pass it directly in \fBsel\fP,
not as an attribute in a \fIset\fP, and its type will be used to determine the kind of predicate to build. For example, \fBself:foreach(act, monitor)\fP is equivalent
to \fBself:foreach\e{action=act, class=monitor}\fP\&.
.SH INDEXES, NAMES AND COUNTS
.sp
Indexing a sequence triggers a complex look up mechanism where the arguments will be interpreted in various ways as described in the \fB:__index\fP metamethod.
A \fInumber\fP will be interpreted as a relative slot index in the list of elements, and a negative index will be considered as relative to the end of the sequence,
i.e. \fB\-1\fP is the \fB$end\fP marker. Non\- \fInumber\fP will be interpreted first as an object key (can be anything), looking for sequence methods or attributes;
then as an element name if nothing was found.
.sp
If an element exists but its name is not unique in the sequence, an \fIiterable\fP is returned. An \fIiterable\fP supports the length \fB#\fP operator to retrieve the
number of elements with the same name, the indexing operator \fB[]\fP waiting for a count $n$ to retrieve the n\-th element from the start with that name,
and the iterator \fBipairs\fP to use with generic \fBfor\fP loops.
.sp
The returned \fIiterable\fP is in practice a proxy, i.e. a fake intermediate object that emulates the expected behavior, and any attempt to access the proxy in
another manner should raise a runtime error.
.sp
\fBWarning:\fP The indexing operator \fB[]\fP interprets a \fInumber\fP as a (relative) element index as the method \fB:index\fP, while the method \fB:index_of\fP} interprets a
\fInumber\fP as a (relative) element s\-position [m].
.sp
The following example shows how to access to the elements through indexing and the \fIiterable\fP::
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
local sequence, drift, marker in MAD.element
local seq = sequence {
drift \(aqdf\(aq { id=1 }, marker \(aqmk\(aq { id=2 },
drift \(aqdf\(aq { id=3 }, marker \(aqmk\(aq { id=4 },
drift \(aqdf\(aq { id=5 }, marker \(aqmk\(aq { id=6 },
}
print(seq[ 1].name) \-\- display: (*\e$start*) (start marker)
print(seq[\-1].name) \-\- display: (*\e$end*)   (end   marker)

print(#seq.df, seq.df[3].id)                        \-\- display: 3   5
for _,e in ipairs(seq.df) do io.write(e.id," ") end \-\- display: 1 3 5
for _,e in ipairs(seq.mk) do io.write(e.id," ") end \-\- display: 2 4 6

\-\- print name of drift with id=3 in absolute and relative to id=6.
print(seq:name_of(4))       \-\- display: df[2]  (2nd df from start)
print(seq:name_of(2, \-2))   \-\- display: df{\-3} (3rd df before last mk)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The last two lines of code display the name of the same element but mangled with absolute and relative counts.
.sp
section{Iterators and ranges}
.sp
Ranging a sequence triggers a complex look up mechanism where the arguments will be interpreted in various ways as described in the \fB:range_of\fP method,
itself based on the methods \fB:index_of\fP} and \fB:index\fP\&. The number of elements selected by a sequence range can be computed by the \fB:length_of\fP} method,
which accepts an extra \fInumber\fP of turns to consider in the calculation.
.sp
The sequence iterators are created by the methods \fB:iter\fP and \fB:siter\fP, and both are based on the \fB:range_of\fP method as mentioned in their descriptions
and includes an extra \fInumber\fP of turns as for the method \fB:length_of\fP, and a direction \fB1\fP (forward) or \fB\-1\fP (backward) for the iteration.
The \fB:siter\fP differs from the \fB:iter\fP by its loop, which returns not only the sequence elements but also \fIimplicit\fP drifts built on\-the\-fly when a gap
>10^{\-10} m is detected between two sequence elements. Such implicit drift have half\-integer indexes and make the iterator “continuous” in s\-positions.
.sp
The method \fB:foreach\fP uses the iterator returned by \fB:iter\fP with a range as its sole argument to loop over the elements where to apply the predicate before
executing the action. The methods \fB:select\fP, \fB:deselect\fP, \fB:filter\fP, \fB:install\fP, \fB:replace\fP, \fB:remove\fP, \fB:move\fP, and \fB:misalign\fP are all based
directly or indirectly on the \fB:foreach\fP method. Hence, to iterate backward over a sequence range, these methods have to use either its \fIlist\fP form or a numerical range.
For example the invocation \fBseq:foreach(\ee \-> print(e.name), {2, 2, \(aqidx\(aq, \-1)\fP will iterate backward over the entire sequence \fBseq\fP excluding the \fB$start\fP
and \fB$end\fP markers, while the invocation \fBseq:foreach(\ee \-> print(e.name), 5..2..\-1)\fP will iterate backward over the elements with s\-positions sitting in the
interval [2,5] m.
.sp
The tracking commands \fBsurvey\fP and \fBtrack\fP use the iterator returned by \fB:siter\fP for their main loop, with their \fBrange\fP, \fBnturn\fP and \fBdir\fP attributes
as arguments. These commands also save the iterator states in their \fBmflw\fP to allow the users to run them \fBnstep\fP by \fBnstep\fP, see commands \fI\%survey\fP
and \fI\%track\fP for details.
.sp
The following example shows how to access to the elements with the \fB:foreach\fP method::
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
local sequence, drift, marker in MAD.element
local observed in MAD.element.flags
local seq = sequence {
drift \(aqdf\(aq { id=1 }, marker \(aqmk\(aq { id=2 },
drift \(aqdf\(aq { id=3 }, marker \(aqmk\(aq { id=4 },
drift \(aqdf\(aq { id=5 }, marker \(aqmk\(aq { id=6 },
}

local act = \ee \-> print(e.name,e.id)
seq:foreach(act, "df[2]/mk[3]")
\-\- display:
df   3
mk   4
df   5
mk   6

seq:foreach{action=act, range="df[2]/mk[3]", class=marker}
\-\- display: markers at ids 4 and 6
seq:foreach{action=act, pattern=(*\everb+"^[^$]"+*)}
\-\- display: all elements except (*\everb+$start and $end+*) markers
seq:foreach{action=\ee \-> e:select(observed), pattern="mk"}
\-\- same as: seq:select(observed, {pattern="mk"})

local act = \ee \-> print(e.name, e.id, e:is_observed())
seq:foreach{action=act, range=(*\everb+"#s/#e"+*)}
\-\- display:
(*\e$start*)   nil  false
df       1    false
mk       2    true
df       3    false
mk       4    true
df       5    false
mk       6    true
(*\e$end*)     nil  true
.ft P
.fi
.UNINDENT
.UNINDENT
.SH EXAMPLES
.SS FODO cell
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
local sequence, sbend, quadrupole, sextupole, hkicker, vkicker, marker in MAD.element
local mkf = marker \(aqmkf\(aq {}
local ang=2*math.pi/80
local fodo = sequence \(aqfodo\(aq { refer=\(aqentry\(aq,
mkf             { at=0, shared=true      }, \-\- mark the start of the fodo
quadrupole \(aqqf\(aq { at=0, l=1  , k1=0.3    },
sextupole  \(aqsf\(aq {       l=0.3, k2=0      },
hkicker    \(aqhk\(aq {       l=0.2, kick=0    },
sbend      \(aqmb\(aq { at=2, l=2  , angle=ang },

quadrupole \(aqqd\(aq { at=5, l=1  , k1=\-0.3   },
sextupole  \(aqsd\(aq {       l=0.3, k2=0      },
vkicker    \(aqvk\(aq {       l=0.2, kick=0    },
sbend      \(aqmb\(aq { at=7, l=2  , angle=ang },
}
local arc = sequence \(aqarc\(aq { refer=\(aqentry\(aq, 10*fodo }
fodo:dumpseq() ; print(fodo.mkf, mkf)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Display:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
sequence: fodo, l=9
idx  kind          name          l          dl       spos       upos    uds
001  marker        $start  0.000       0       0.000      0.000   0.000
002  marker        mkf     0.000       0       0.000      0.000   0.000
003  quadrupole    qf      1.000       0       0.000      0.000   0.000
004  sextupole     sf      0.300       0       1.000      1.000   0.000
005  hkicker       hk      0.200       0       1.300      1.300   0.000
006  sbend         mb      2.000       0       2.000      2.000   0.000
007  quadrupole    qd      1.000       0       5.000      5.000   0.000
008  sextupole     sd      0.300       0       6.000      6.000   0.000
009  vkicker       vk      0.200       0       6.300      6.300   0.000
010  sbend         mb      2.000       0       7.000      7.000   0.000
011  marker        $end    0.000       0       9.000      9.000   0.000
marker : \(aqmkf\(aq 0x01015310e8  marker: \(aqmkf\(aq 0x01015310e8 \-\- same marker
.ft P
.fi
.UNINDENT
.UNINDENT
.SS SPS compact description
.sp
The following dummy example shows a compact definition of the SPS mixing elements, beam lines and sequence definitions.
The elements are zero\-length, so the lattice is too.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
local drift, sbend, quadrupole, bline, sequence in MAD.element

\-\- elements (empty!)
local ds = drift      \(aqds\(aq {}
local dl = drift      \(aqdl\(aq {}
local dm = drift      \(aqdm\(aq {}
local b1 = sbend      \(aqb1\(aq {}
local b2 = sbend      \(aqb2\(aq {}
local qf = quadrupole \(aqqf\(aq {}
local qd = quadrupole \(aqqd\(aq {}

\-\- subsequences
local pf  = bline \(aqpf\(aq  {qf,2*b1,2*b2,ds}           \-\- #: 6
local pd  = bline \(aqpd\(aq  {qd,2*b2,2*b1,ds}           \-\- #: 6
local p24 = bline \(aqp24\(aq {qf,dm,2*b2,ds,pd}          \-\- #: 11 (5+6)
local p42 = bline \(aqp42\(aq {pf,qd,2*b2,dm,ds}          \-\- #: 11 (6+5)
local p00 = bline \(aqp00\(aq {qf,dl,qd,dl}               \-\- #: 4
local p44 = bline \(aqp44\(aq {pf,pd}                     \-\- #: 12 (6+6)
local insert = bline \(aqinsert\(aq {p24,2*p00,p42}       \-\- #: 30 (11+2*4+11)
local super  = bline \(aqsuper\(aq  {7*p44,insert,7*p44}  \-\- #: 198 (7*12+30+7*12)

\-\- final sequence
local SPS = sequence \(aqSPS\(aq {6*super}                \-\- # = 1188 (6*198)

\-\- check number of elements and length
print(#SPS, SPS.l)  \-\- display: 1190  0 (no element length provided)
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Installing elements I
.sp
The following example shows how to install elements and subsequences in an empty initial sequence::
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
local sequence, drift in MAD.element
local seq   = sequence "seq" { l=16, refer="entry", owner=true }
local sseq1 = sequence "sseq1" {
at=5, l=6 , refpos="centre", refer="entry",
drift "df1\(aq" {l=1, at=\-4, from="end"},
drift "df2\(aq" {l=1, at=\-2, from="end"},
drift "df3\(aq" {     at= 5            },
}
local sseq2 = sequence "sseq2" {
at=14, l=6, refpos="exit", refer="entry",
drift "df1\(aq\(aq" { l=1, at=\-4, from="end"},
drift "df2\(aq\(aq" { l=1, at=\-2, from="end"},
drift "df3\(aq\(aq" {      at= 5            },
}
seq:install {
drift "df1" {l=1, at=1},
sseq1, sseq2,
drift "df2" {l=1, at=15},
} :dumpseq()
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Display:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
sequence: seq, l=16
idx  kind          name       l          dl       spos       upos    uds
001  marker        $start*    0.000       0       0.000      0.000   0.000
002  drift         df1        1.000       0       1.000      1.000   0.000
003  drift         df1\(aq       1.000       0       4.000      4.000   0.000
004  drift         df2\(aq       1.000       0       6.000      6.000   0.000
005  drift         df3\(aq       0.000       0       7.000      7.000   0.000
006  drift         df1\(aq\(aq      1.000       0      10.000     10.000   0.000
007  drift         df2\(aq\(aq      1.000       0      12.000     12.000   0.000
008  drift         df3\(aq\(aq      0.000       0      13.000     13.000   0.000
009  drift         df2        1.000       0      15.000     15.000   0.000
010  marker        $end       0.000       0      16.000     16.000   0.000
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Installing elements II
.sp
The following more complex example shows how to install elements and subsequences in a sequence using a selection and the packed form for arguments::
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
local mk   = marker   "mk"  { }
local seq  = sequence "seq" { l = 10, refer="entry",
mk "mk1" { at = 2 },
mk "mk2" { at = 4 },
mk "mk3" { at = 8 },
}
local sseq = sequence "sseq" { l = 3 , at = 5, refer="entry",
drift "df1\(aq" { l = 1, at = 0 },
drift "df2\(aq" { l = 1, at = 1 },
drift "df3\(aq" { l = 1, at = 2 },
}
seq:install {
class    = mk,
elements = {
   drift "df1" { l = 0.1, at = 0.1, from="selected" },
   drift "df2" { l = 0.1, at = 0.2, from="selected" },
   drift "df3" { l = 0.1, at = 0.3, from="selected" },
   sseq,
   drift "df4" { l = 1, at = 9 },
}
}

seq:dumpseq()
.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
sequence: seq, l=10
idx  kind          name      l          dl       spos       upos    uds
001  marker        $start    0.000       0       0.000      0.000   0.000
002  marker        mk1       0.000       0       2.000      2.000   0.000
003  drift         df1       0.100       0       2.100      2.100   0.000
004  drift         df2       0.100       0       2.200      2.200   0.000
005  drift         df3       0.100       0       2.300      2.300   0.000
006  marker        mk2       0.000       0       4.000      4.000   0.000
007  drift         df1       0.100       0       4.100      4.100   0.000
008  drift         df2       0.100       0       4.200      4.200   0.000
009  drift         df3       0.100       0       4.300      4.300   0.000
010  drift         df1\(aq      1.000       0       5.000      5.000   0.000
011  drift         df2\(aq      1.000       0       6.000      6.000   0.000
012  drift         df3\(aq      1.000       0       7.000      7.000   0.000
013  marker        mk3       0.000       0       8.000      8.000   0.000
014  drift         df1       0.100       0       8.100      8.100   0.000
015  drift         df2       0.100       0       8.200      8.200   0.000
016  drift         df3       0.100       0       8.300      8.300   0.000
017  drift         df4       1.000       0       9.000      9.000   0.000
018  marker        $end      0.000       0      10.000     10.000   0.000
.ft P
.fi
.UNINDENT
.UNINDENT
.SH RANDOM MATHS
.sp
.ce
\enabla \ecdot \etextbf{E} = \efrac{\erho}{\eepsilon_0}\e\e\e\e
\enabla \ecdot \etextbf{B} = 0\e\e\e\e
\enabla \etimes \etextbf{E} =\- \efrac{\epartial \etextbf{B}}{\epartial t}\e\e\e\e
\enabla \etimes \etextbf{B} = \emu_0 \etextbf{J} + \emu_0 \eepsilon_0 \efrac{\epartial \etextbf{E}}{\epartial t}
.ce 0
.SH FOOTNOTES
.IP [1] 5
This is equivalent to the MAD\-X \fBbv\fP flag.
.IP [2] 5
For example, the \fB:remove\fP method needs \fBnot=true\fP to \fInot\fP remove all elements if no selector is provided.
.IP [3] 5
Updating directly the positions attributes of an element has no effect.
.IP [4] 5
An \fIiterable\fP supports the length operator \fB#\fP, the indexing operator \fB[]\fP and generic \fBfor\fP loops with \fBipairs\fP\&.
.IP [5] 5
MAD\-NG does not have a MAD\-X like \fB"USE"\fP command to finalize this computation.
.SH AUTHOR
Laurent Deniau
.SH COPYRIGHT
2022, Laurent Deniau
.\" Generated by docutils manpage writer.
.
