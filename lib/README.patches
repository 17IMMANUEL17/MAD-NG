Patch for local 'in' table
==========================

With the patch of local 'in' table extension the following syntax is supported:
[-DLUAJIT_LOCAL_INTABLE]

local sin, cos, tan in math

becomes _strictly_ equivalent to the Lua syntax

local sin, cos, tan in math.sin, math.cos, math.tan

This syntax extension is particularly useful with LuaJIT considering the
frequent needs to have local copiesof variables for performance reason.


Patch for lambda syntax
=======================

With the patch of lamdba syntax extension the following syntaxes are
supported: [-DLUAJIT_LAMBDA_SYNTAX]

\(arg_list) (expr)
\(arg_list) (expr_list)

become _strictly_ equivalent to the Lua syntaxes

function (arg_list) return expr      end
function (arg_list) return expr_list end

+ Parenthesis around arg_list and non-emtpy expr are optional for lambda.
+ Parenthesis around expr_list and empty expr are required for lambda.
+ Following the function syntax, arg_list, expr and expr_list can be empty.
+ The first lambda parameter name (if any) or parenthesis (if any) must “touch”
  the lambda sign (backslash). Any space or tab between the lambda sign and a
  token will be understood as a lambda with void parameter.

With the patch for lamdba syntax with arrow support, the following syntaxes are
also supported: [-DLUAJIT_LAMBDA_SYNTAX]

\(arg_list) -> (expr)
\(arg_list) -> (expr_list)
\(arg_list) => function_body

which is _strictly_ equivalent to the Lua syntaxes (as above)

function (arg_list) return expr      end
function (arg_list) return expr_list end
function (arg_list) function_body

+ Single arrow is optional, but fat arrow is required.
+ Parenthesis around arg_list is optional for the three lambda forms.
+ Function_body must include the closing 'end' as it _is_ the Lua function body.

With the patch of lamdba syntax with direct call support, the following syntaxes
are also supported: [-DLUAJIT_LAMBDA_DCALL]

func \(arg_list) (expr)
func \(arg_list) (expr_list)

become _strictly_ equivalent to the Lua syntaxes (as above)

func( \(arg_list) (expr)      )
func( \(arg_list) (expr_list) )

where func is a function syntax. This is an extension of the table and string
call syntax.

---

Examples of equivalent forms in Lua and Lambda syntaxes:

> f=function (x) return x*x end
> f=\(x) (x*x)
> f=\(x) x*x
> f=\x (x*x)
> f=\x x*x
> =f(2)
4 

> f=function (...) return ... end
> f=\... ...                   -- identity
> =f(4)
4

> f=function (...) return {...} end
> f=\... {...}                 -- pack
> =f(4)[1]
4

> f=function () return end     -- skip parameter(s)
> f=\ ()
> =f(3)
> =f(4,5)

> sqrt=math.sqrt
> f=function (x,y) return sqrt(x*x+y*y) end
> f=\x,y sqrt(x*x+y*y)         -- hypotenuse
> =f(2,3)
3.605551275464

> f=function (x) return function (y) return x+y,x-y end end
> f=\x\y (x+y,x-y)
> =f(2)(3)
5   -1

> f=function () return  x end  -- free variable x
> f=\ x                        -- note the space
> x=10
> =f()
10
> x=20
> =f()
20

> f=function () return -x end  -- free variable x
> f=\ -x                       -- note the space
> x=10
> =f()
-10
> x=20
> =f()
-20

> a={ f=function (x,y) return x+y,x-y end, 3 } 
> a={ f=\x,y (x+y,x-y), 3 }
> =a.f(2,3)
5   -1
> =a[1]
3

> x,y=4,6
> a={ f=function (x,y) return x+y end, x-y, 3 }
> a={ f=\x,y x+y, x-y, 3 }
> =a.f(2,3)
5
> =a[1]
-2
> =a[2]
3

> z=10
> a={ f=function (s,y) return s.x*y+z end, x=3 } 
> a={ f=\s,y s.x*y+z, x=3 }
> =a:f(2)
16
> a.x=5
> =a:f(2)
20

Example: Fibonacci sequence (2nd is more readable)

fib=\n n<2 and n or fib(n-1)+fib(n-2)

fib=\(n) n<2 and n or fib(n-1)+fib(n-2)

Example: composition of lambda

> id=\... ...
> f=\x x^2
> g=\x (x,x)
> h=\x,y (x+y,x-y)
> cat=\f,g \... f(g(...))

> f(2)
4
> gf=cat(g,f)
> =gf(2)
4  4
> hgf=cat(h,gf)
> =hgf(2)
8  0

> sm, gm = setmetatable, getmetatable
> -- let’s define ^ and bottom for function composition
> _ = sm({id}, { __pow  = \f,g sm({cat(f,g[1])}, gm(g)),
>>               __call = \g,... g[1](...) })

> hgf= h^g^f^_  -- = cat(h,cat(g,f)) but no () mismatch
> =hgf(2)
8  0

> f=\x,y (x+y,x-y)
> g=\x,y x*y
> p1=\x,y ( (g^f^_)(x,y) == (\x,y x^2-y^2)(x,y) )
> =assert(p1(2,3)) 
true
> p2=\x,y ( (\x,y(x*y) ^ \x,y(x+y,x-y) ^_)(x,y) == (\x,y x^2-y^2)(x,y) )
> =assert(p2(2,3)) 
true

Example: direct call syntax 

> _ = \f f()
> x=3
> = _\ x*x
9

*Note on performance*
p1 and p2 are creating lambda functions in each call, but if we redefine the
lamda creation outside:

sm, gm = setmetatable, getmetatable
id=\... ...
cat=\f,g \... f(g(...))
_ = sm({id}, { __pow  = \f,g sm({cat(f,g[1])}, gm(g)),
               __call = \g,... g[1](...) })
f=\x,y (x+y,x-y)
g=\x,y x*y
h=\x,y x^2-y^2
gf = g^f^_
p3=\x,y gf(x,y) - h(x,y)
for i=1,1e9 do p3(i,i+1) end

The performance is improved by a factor 2000 (!) The reason is that creation of
lambda function are not compiled... Same problem for composition as it
also creates a lambda function (i.e. the composed function in cat).

