--- luajit/src/lj_parse.c	2016-04-09 15:07:22.000000000 +0200
+++ patches/lj_parse_lmbd.c	2016-04-09 14:54:29.000000000 +0200
@@ -1803,15 +1803,16 @@
   }
 }
 
-/* Parse function parameters. */
-static BCReg parse_params(LexState *ls, int needself)
+/* Parse function parameters. */                           /* LD: 2016.04.07 */
+static BCReg parse_params(LexState *ls, int needself, int islambda)
 {
   FuncState *fs = ls->fs;
   BCReg nparams = 0;
-  lex_check(ls, '(');
-  if (needself)
-    var_new_lit(ls, nparams++, "self");
-  if (ls->tok != ')') {
+  int has_param = islambda && ls->c != ' ' && ls->c != '\t';
+  if (islambda) lj_lex_next(ls); else lex_check(ls, '(');
+  int has_paren = !islambda || (has_param && lex_opt(ls, '('));
+  if (needself) var_new_lit(ls, nparams++, "self");
+  if ((has_paren && ls->tok != ')') || (!has_paren && has_param)) {
     do {
       if (ls->tok == TK_name || (!LJ_52 && ls->tok == TK_goto)) {
 	var_new(ls, nparams++, lex_str(ls));
@@ -1827,15 +1828,16 @@
   var_add(ls, nparams);
   lua_assert(fs->nactvar == nparams);
   bcreg_reserve(fs, nparams);
-  lex_check(ls, ')');
+  if (has_paren) lex_check(ls, ')');
   return nparams;
 }
 
 /* Forward declaration. */
 static void parse_chunk(LexState *ls);
+static void parse_return(LexState *ls, int islambda);
 
-/* Parse body of a function. */
-static void parse_body(LexState *ls, ExpDesc *e, int needself, BCLine line)
+/* Parse body of a function. */                            /* LD: 2016.04.07 */
+static void parse_body(LexState *ls, ExpDesc *e, int needself, int islambda, BCLine line)
 {
   FuncState fs, *pfs = ls->fs;
   FuncScope bl;
@@ -1844,12 +1846,15 @@
   fs_init(ls, &fs);
   fscope_begin(&fs, &bl, 0);
   fs.linedefined = line;
-  fs.numparams = (uint8_t)parse_params(ls, needself);
+  fs.numparams = (uint8_t)parse_params(ls, needself, islambda);
   fs.bcbase = pfs->bcbase + pfs->pc;
   fs.bclim = pfs->bclim - pfs->pc;
   bcemit_AD(&fs, BC_FUNCF, 0, 0);  /* Placeholder. */
-  parse_chunk(ls);
-  if (ls->tok != TK_end) lex_match(ls, TK_end, TK_function, line);
+  if (islambda) parse_return(ls, islambda);
+  else {
+    parse_chunk(ls);
+    if (ls->tok != TK_end) lex_match(ls, TK_end, TK_function, line);
+  }
   pt = fs_finish(ls, (ls->lastline = ls->linenumber));
   pfs->bcbase = ls->bcstack + oldbase;  /* May have been reallocated. */
   pfs->bclim = (BCPos)(ls->sizebcstack - oldbase);
@@ -1864,7 +1869,7 @@
       pfs->flags |= PROTO_FIXUP_RETURN;
     pfs->flags |= PROTO_CHILD;
   }
-  lj_lex_next(ls);
+  if (!islambda) lj_lex_next(ls);
 }
 
 /* Parse expression list. Last expression is left open. */
@@ -2003,8 +2008,13 @@
     return;
   case TK_function:
     lj_lex_next(ls);
-    parse_body(ls, v, 0, ls->linenumber);
+    parse_body(ls, v, 0, 0, ls->linenumber);
     return;
+#ifdef LUAJIT_LAMBDA_SYNTAX /* LD: 2016.04.07 */
+  case '\\':
+    parse_body(ls, v, 0, 1, ls->linenumber);
+    return;
+#endif
   default:
     expr_primary(ls, v);
     return;
@@ -2243,7 +2253,7 @@
     v.u.s.aux = fs->varmap[fs->freereg];
     bcreg_reserve(fs, 1);
     var_add(ls, 1);
-    parse_body(ls, &b, 0, ls->linenumber);
+    parse_body(ls, &b, 0, 0, ls->linenumber);
     /* bcemit_store(fs, &v, &b) without setting VSTACK_VAR_RW. */
     expr_free(fs, &b);
     expr_toreg(fs, &b, v.u.s.info);
@@ -2281,7 +2291,7 @@
     needself = 1;
     expr_field(ls, &v);
   }
-  parse_body(ls, &b, needself, line);
+  parse_body(ls, &b, needself, 0, line);
   fs = ls->fs;
   bcemit_store(fs, &v, &b);
   fs->bcbase[fs->pc - 1].line = line;  /* Set line for the store. */
@@ -2300,18 +2310,19 @@
   }
 }
 
-/* Parse 'return' statement. */
-static void parse_return(LexState *ls)
+/* Parse 'return' statement. */                            /* LD: 2016.04.07 */
+static void parse_return(LexState *ls, int islambda)
 {
   BCIns ins;
   FuncState *fs = ls->fs;
-  lj_lex_next(ls);  /* Skip 'return'. */
+  int has_list = islambda && lex_opt(ls, '(');
+  if (!islambda) lj_lex_next(ls); /* Skip 'return'. */
   fs->flags |= PROTO_HAS_RETURN;
   if (parse_isend(ls->tok) || ls->tok == ';') {  /* Bare return. */
     ins = BCINS_AD(BC_RET0, 0, 1);
   } else {  /* Return with one or more values. */
     ExpDesc e;  /* Receives the _last_ expression in the list. */
-    BCReg nret = expr_list(ls, &e);
+    BCReg nret = !islambda || has_list ? expr_list(ls,&e) : (expr(ls,&e),1);
     if (nret == 1) {  /* Return one result. */
       if (e.k == VCALL) {  /* Check for tail call. */
 	BCIns *ip = bcptr(fs, &e);
@@ -2333,6 +2344,7 @@
       }
     }
   }
+  if (islambda && has_list) lex_check(ls, ')');
   if (fs->flags & PROTO_CHILD)
     bcemit_AJ(fs, BC_UCLO, 0, 0);  /* May need to close upvalues first. */
   bcemit_INS(fs, ins);
@@ -2646,7 +2658,7 @@
     parse_local(ls);
     break;
   case TK_return:
-    parse_return(ls);
+    parse_return(ls, 0);
     return 1;  /* Must be last. */
   case TK_break:
     lj_lex_next(ls);
