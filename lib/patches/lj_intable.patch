diff --git a/src/Makefile b/src/Makefile
index 3f25192..66637a3 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -110,6 +110,9 @@ XCFLAGS=
 #XCFLAGS+= -DLUAJIT_NUMMODE=1
 #XCFLAGS+= -DLUAJIT_NUMMODE=2
 #
+# Support for local 'in' table syntax
+XCFLAGS+= -DLUAJIT_LOCAL_INTABLE
+#
 ##############################################################################
 
 ##############################################################################
diff --git a/src/lj_parse.c b/src/lj_parse.c
index 610c861..e242cc4 100644
--- a/src/lj_parse.c
+++ b/src/lj_parse.c
@@ -2257,6 +2257,32 @@ static void parse_local(LexState *ls)
     } while (lex_opt(ls, ','));
     if (lex_opt(ls, '=')) {  /* Optional RHS. */
       nexps = expr_list(ls, &e);
+#ifdef LUAJIT_LOCAL_INTABLE                                /* LD: 2016.04.29 */
+    } else if (lex_opt(ls, TK_in)) { /* Optional RHS. */
+      FuncState *fs = ls->fs;
+      BCReg vars = fs->nactvar, regs = fs->freereg;
+      lua_assert(vars == regs);     /* sanity check */
+      bcreg_reserve(fs, nvars);     /* reserve regs for n vars */
+      var_new_lit(ls, nvars, "(in)");   /* create hidden '(in)' var */
+      expr(ls, &e);       /* parse table expr */
+      assign_adjust(ls, nvars+1, nvars+1, &e);  /* discharge expr to '(in)' */
+      var_add(ls, nvars+1);     /* expose vars + '(in)' */
+      for (nexps=0; nexps < nvars; nexps++) {
+  ExpDesc k, v;
+  expr_init(&e, VNONRELOC, vars+nvars); /* load table expr */
+  expr_init(&k, VKSTR, 0);    /* set key from var name */
+  k.u.sval = strref(var_get(ls, fs, vars+nexps).name);
+  expr_index(fs, &e, &k);     /* set key index in table */
+  expr_init(&v, VLOCAL, vars+nexps);  /* set dest. var */
+  v.u.s.aux = fs->varmap[regs+nexps]; /* VLOCAL vstack index */
+  bcemit_store(fs, &v, &e);   /* store value to var */
+      }
+      var_remove(ls, vars+nvars);   /* drop hidden '(in)' var */
+      fs->freereg--, ls->vtop--;    /* optional, see parse_chunk */
+      lua_assert(fs->nactvar == vars+nvars);  /* sanity checks */
+      lua_assert(fs->freereg == regs+nvars);
+      return;
+#endif
     } else {  /* Or implicitly set to nil. */
       e.k = VVOID;
       nexps = 0;
