diff --git a/src/Makefile b/src/Makefile
index 3f25192..a9479ec 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -99,7 +99,7 @@ XCFLAGS=
 # enabled by default. Some other features that *might* break some existing
 # code (e.g. __pairs or os.execute() return values) can be enabled here.
 # Note: this does not provide full compatibility with Lua 5.2 at this time.
-#XCFLAGS+= -DLUAJIT_ENABLE_LUA52COMPAT
+XCFLAGS+= -DLUAJIT_ENABLE_LUA52COMPAT
 #
 # Disable the JIT compiler, i.e. turn LuaJIT into a pure interpreter.
 #XCFLAGS+= -DLUAJIT_DISABLE_JIT
@@ -110,6 +110,18 @@ XCFLAGS=
 #XCFLAGS+= -DLUAJIT_NUMMODE=1
 #XCFLAGS+= -DLUAJIT_NUMMODE=2
 #
+# Support for lambda function syntax, deferred expr and direct arg call
+XCFLAGS+= -DLUAJIT_LAMBDA_SYNTAX -DLUAJIT_LAMBDA_DEFER -DLUAJIT_LAMBDA_DCALL
+#
+# Support for local 'in' table syntax
+XCFLAGS+= -DLUAJIT_LOCAL_INTABLE
+#
+# Support for xrange cdata type (complex-like), generated by num..num[..num]
+XCFLAGS+= -DLUAJIT_CTYPE_XRANGE
+#
+# Support for '!' single line comment
+XCFLAGS+= -DLUAJIT_COMMENT_EMARK
+#
 ##############################################################################
 
 ##############################################################################
diff --git a/src/lib_ffi.c b/src/lib_ffi.c
index 1feee21..89ad1ea 100644
--- a/src/lib_ffi.c
+++ b/src/lib_ffi.c
@@ -773,7 +773,7 @@ LJLIB_CF(ffi_metatype)
   TValue *tv;
   GCcdata *cd;
   if (!(ctype_isstruct(ct->info) || ctype_iscomplex(ct->info) ||
-	ctype_isvector(ct->info)))
+	ctype_isvector(ct->info) || ctype_isxrange (ct->info) ))
     lj_err_arg(L, 1, LJ_ERR_FFI_INVTYPE);
   tv = lj_tab_setinth(L, t, -(int32_t)id);
   if (!tvisnil(tv))
diff --git a/src/lib_init.c b/src/lib_init.c
index 63c2ace..a28d438 100644
--- a/src/lib_init.c
+++ b/src/lib_init.c
@@ -26,11 +26,14 @@ static const luaL_Reg lj_lib_load[] = {
   { LUA_DBLIBNAME,	luaopen_debug },
   { LUA_BITLIBNAME,	luaopen_bit },
   { LUA_JITLIBNAME,	luaopen_jit },
+#if LJ_HASFFI && defined(LUAJIT_CTYPE_XRANGE)              /* LD: 2016.05.14 */
+  { LUA_FFILIBNAME,	luaopen_ffi },
+#endif
   { NULL,		NULL }
 };
 
 static const luaL_Reg lj_lib_preload[] = {
-#if LJ_HASFFI
+#if LJ_HASFFI && !defined(LUAJIT_CTYPE_XRANGE)             /* LD: 2016.05.14 */
   { LUA_FFILIBNAME,	luaopen_ffi },
 #endif
   { NULL,		NULL }
diff --git a/src/lj_cdata.c b/src/lj_cdata.c
index 05e27da..963d4fc 100644
--- a/src/lj_cdata.c
+++ b/src/lj_cdata.c
@@ -146,6 +146,11 @@ collect_attrib:
       } else if ((ct->info & (CTF_VECTOR|CTF_COMPLEX))) {
 	if ((ct->info & CTF_COMPLEX)) idx &= 1;
 	*qual |= CTF_CONST;  /* Valarray elements are constant. */
+#ifdef LUAJIT_CTYPE_XRANGE                                 /* LD: 2016.05.14 */
+      } else if ((ct->info & CTF_XRANGE)) {
+        *qual |= 1;  /* Block num index to emulate struct-like fields. */
+        return ct;  /* But return the resolved raw type. */
+#endif
       }
       *pp = p + idx*(int32_t)sz;
       return ct;
@@ -165,8 +170,8 @@ collect_attrib:
       CTSize ofs;
       CType *fct = lj_ctype_getfieldq(cts, ct, name, &ofs, qual);
       if (fct) {
-	*pp = p + ofs;
-	return fct;
+        *pp = p + ofs;
+        return fct;
       }
     } else if (ctype_iscomplex(ct->info)) {
       if (name->len == 2) {
@@ -179,6 +184,17 @@ collect_attrib:
 	  return ct;
 	}
       }
+#ifdef LUAJIT_CTYPE_XRANGE                                 /* LD: 2016.05.14 */
+    } else if (ctype_isxrange(ct->info)) { /* See also recff_cdata_index */
+        if ((name->len == 5 && !memcmp(strdata(name), "start", 5)) ||
+            (name->len == 4 && !memcmp(strdata(name), "stop" , 4)) ||
+            (name->len == 4 && !memcmp(strdata(name), "step" , 4))) {
+          *qual |= CTF_CONST;  /* XRange fields are constant. */
+          *pp = p + (strdata(name)[2] == 'o') *   sizeof(double)
+                  + (strdata(name)[2] == 'e') * 2*sizeof(double);
+          return ct;
+        }
+#endif
     } else if (cd->ctypeid == CTID_CTYPEID) {
       /* Allow indexing a (pointer to) struct constructor to get constants. */
       CType *sct = ctype_raw(cts, *(CTypeID *)p);
diff --git a/src/lj_char.c b/src/lj_char.c
index 11f23ef..0f9576e 100644
--- a/src/lj_char.c
+++ b/src/lj_char.c
@@ -23,14 +23,23 @@
 
 LJ_DATADEF const uint8_t lj_char_bits[257] = {
     0,
+/*                                     \t  \n  \v  \f  \r         */
     1,  1,  1,  1,  1,  1,  1,  1,  1,  3,  3,  3,  3,  3,  1,  1,
+/*                                                                */
     1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
+/*spc   !   "   #   $   %   &   '   (   )   *   +   ,   -   .   / */
     2,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,
+/*  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ? */
   152,152,152,152,152,152,152,152,152,152,  4,  4,  4,  4,  4,  4,
+/*  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O */
     4,176,176,176,176,176,176,160,160,160,160,160,160,160,160,160,
+/*  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _ */
   160,160,160,160,160,160,160,160,160,160,160,  4,  4,  4,  4,132,
+/*  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o */
     4,208,208,208,208,208,208,192,192,192,192,192,192,192,192,192,
+/*  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~ del */
   192,192,192,192,192,192,192,192,192,192,192,  4,  4,  4,  4,  1,
+
   128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,
   128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,
   128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,
diff --git a/src/lj_cparse.c b/src/lj_cparse.c
index 16d2cb6..9d36bcc 100644
--- a/src/lj_cparse.c
+++ b/src/lj_cparse.c
@@ -789,7 +789,7 @@ static void cp_push_type(CPDecl *decl, CTypeID id)
     cp_push(decl, info & ~CTMASK_CID, size);  /* Copy type. */
     break;
   case CT_ARRAY:
-    if ((ct->info & (CTF_VECTOR|CTF_COMPLEX))) {
+    if ((ct->info & (CTF_VECTOR|CTF_COMPLEX|CTF_XRANGE))) {
       info |= (decl->attr & CTF_QUAL);
       decl->attr &= ~CTF_QUAL;
     }
@@ -1481,7 +1481,7 @@ static CPscl cp_decl_spec(CPState *cp, CPDecl *decl, CPscl scl)
       continue;
     }
     if (sz || tdef ||
-	(cds & (CDF_SHORT|CDF_LONG|CDF_SIGNED|CDF_UNSIGNED|CDF_COMPLEX)))
+    	(cds & (CDF_SHORT|CDF_LONG|CDF_SIGNED|CDF_UNSIGNED|CDF_COMPLEX|CDF_XRANGE)))
       break;
     switch (cp->tok) {
     case CTOK_STRUCT:
@@ -1513,6 +1513,10 @@ end_decl:
 
   if ((cds & CDF_COMPLEX))  /* Use predefined complex types. */
     tdef = sz == 4 ? CTID_COMPLEX_FLOAT : CTID_COMPLEX_DOUBLE;
+#ifdef LUAJIT_CTYPE_XRANGE                                 /* LD: 2016.05.14 */
+  else if ((cds & CDF_XRANGE))  /* Use predefined xrange type. */
+    tdef = CTID_XRANGE;
+#endif
 
   if (tdef) {
     cp_push_type(decl, tdef);
diff --git a/src/lj_crecord.c b/src/lj_crecord.c
index c0f7e3d..29c08f1 100644
--- a/src/lj_crecord.c
+++ b/src/lj_crecord.c
@@ -115,6 +115,10 @@ static IRType crec_ct2irt(CTState *cts, CType *ct)
       return IRT_NUM;
     else if (ct->size == 2*sizeof(float))
       return IRT_FLOAT;
+#ifdef LUAJIT_CTYPE_XRANGE				   /* LD: 2016.05.14 */
+  } else if (ctype_isxrange(ct->info)) {
+    return IRT_NUM;
+#endif
   }
   return IRT_CDATA;
 }
@@ -123,10 +127,13 @@ static IRType crec_ct2irt(CTState *cts, CType *ct)
 
 /* Maximum length and unroll of inlined copy/fill. */
 #define CREC_COPY_MAXUNROLL		16
-#define CREC_COPY_MAXLEN		128
+#define CREC_COPY_MAXLEN		512	/* LD: 2016.05.09, was 128 */
 
 #define CREC_FILL_MAXUNROLL		16
 
+/* Maximum size for sunk alloc */
+#define CREC_SINK_MAXSIZE		512	/* LD: 2016.05.09, was 128 */
+
 /* Number of windowed registers used for optimized memory copy. */
 #if LJ_TARGET_X86
 #define CREC_COPY_REGWIN		2
@@ -169,6 +176,18 @@ static MSize crec_copy_struct(CRecMemList *ml, CTState *cts, CType *ct)
 	ml[mlp].tp = tp;
 	mlp++;
       }
+#ifdef LUAJIT_CTYPE_XRANGE				   /* LD: 2016.05.14 */
+      if (ctype_isxrange(cct->info)) {
+        if (mlp >= CREC_COPY_MAXUNROLL) return 0;
+        ml[mlp].ofs = df->size + sizeof(double);
+        ml[mlp].tp = tp;
+        mlp++;
+        if (mlp >= CREC_COPY_MAXUNROLL) return 0;
+        ml[mlp].ofs = df->size + 2*sizeof(double);
+        ml[mlp].tp = tp;
+        mlp++;
+      }
+#endif
     } else if (!ctype_isconstval(df->info)) {
       /* NYI: bitfields and sub-structures. */
       return 0;
@@ -575,15 +594,35 @@ static TRef crec_tv_ct(jit_State *J, CType *s, CTypeID sid, TRef sp)
   } else if (ctype_iscomplex(sinfo)) {  /* Unbox/box complex. */
     ptrdiff_t esz = (ptrdiff_t)(s->size >> 1);
     TRef ptr, tr1, tr2, dp;
-    dp = emitir(IRTG(IR_CNEW, IRT_CDATA), lj_ir_kint(J, sid), TREF_NIL);
+    dp  = emitir(IRTG(IR_CNEW, IRT_CDATA), lj_ir_kint(J, sid), TREF_NIL);
     tr1 = emitir(IRT(IR_XLOAD, t), sp, 0);
-    ptr = emitir(IRT(IR_ADD, IRT_PTR), sp, lj_ir_kintp(J, esz));
+    ptr = emitir(IRT(IR_ADD  , IRT_PTR), sp, lj_ir_kintp(J, esz));
     tr2 = emitir(IRT(IR_XLOAD, t), ptr, 0);
-    ptr = emitir(IRT(IR_ADD, IRT_PTR), dp, lj_ir_kintp(J, sizeof(GCcdata)));
-    emitir(IRT(IR_XSTORE, t), ptr, tr1);
-    ptr = emitir(IRT(IR_ADD, IRT_PTR), dp, lj_ir_kintp(J, sizeof(GCcdata)+esz));
-    emitir(IRT(IR_XSTORE, t), ptr, tr2);
+
+    ptr = emitir(IRT(IR_ADD   , IRT_PTR), dp, lj_ir_kintp(J, sizeof(GCcdata)));
+          emitir(IRT(IR_XSTORE, t), ptr, tr1);
+    ptr = emitir(IRT(IR_ADD   , IRT_PTR), dp, lj_ir_kintp(J, sizeof(GCcdata)+esz));
+          emitir(IRT(IR_XSTORE, t), ptr, tr2);
+    return dp;
+#ifdef LUAJIT_CTYPE_XRANGE                                 /* LD: 2016.05.14 */
+  } else if (ctype_isxrange(sinfo)) {  /* Unbox/box xrange. */
+    ptrdiff_t esz = sizeof(double);
+    TRef ptr, tr1, tr2, tr3, dp;
+    dp  = emitir(IRTG(IR_CNEW, IRT_CDATA), lj_ir_kint(J, sid), TREF_NIL);
+    tr1 = emitir(IRT(IR_XLOAD, IRT_NUM), sp, 0);
+    ptr = emitir(IRT(IR_ADD  , IRT_PTR), sp, lj_ir_kintp(J, esz));
+    tr2 = emitir(IRT(IR_XLOAD, IRT_NUM), ptr, 0);
+    ptr = emitir(IRT(IR_ADD  , IRT_PTR), sp, lj_ir_kintp(J, 2*esz));
+    tr3 = emitir(IRT(IR_XLOAD, IRT_NUM), ptr, 0);
+
+    ptr = emitir(IRT(IR_ADD   , IRT_PTR), dp, lj_ir_kintp(J, sizeof(GCcdata)));
+          emitir(IRT(IR_XSTORE, IRT_NUM), ptr, tr1);
+    ptr = emitir(IRT(IR_ADD   , IRT_PTR), dp, lj_ir_kintp(J, sizeof(GCcdata)+esz));
+          emitir(IRT(IR_XSTORE, IRT_NUM), ptr, tr2);
+    ptr = emitir(IRT(IR_ADD   , IRT_PTR), dp, lj_ir_kintp(J, sizeof(GCcdata)+2*esz));
+          emitir(IRT(IR_XSTORE, IRT_NUM), ptr, tr3);
     return dp;
+#endif
   } else {
     /* NYI: copyval of vectors. */
   err_nyi:
@@ -760,8 +799,8 @@ void LJ_FASTCALL recff_cdata_index(jit_State *J, RecordFFData *rd)
 again:
   idx = J->base[1];
   if (tref_isnumber(idx)) {
-    idx = lj_opt_narrow_cindex(J, idx);
-    if (ctype_ispointer(ct->info)) {
+    idx = lj_opt_narrow_cindex(J, idx);                    /* LD: 2016.05.14 */
+    if (ctype_ispointer(ct->info) && !(ct->info & CTF_XRANGE)) {
       CTSize sz;
   integer_key:
       if ((ct->info & CTF_COMPLEX))
@@ -813,23 +852,23 @@ again:
       CType *fct;
       fct = lj_ctype_getfield(cts, ct, name, &fofs);
       if (fct) {
-	/* Always specialize to the field name. */
-	emitir(IRTG(IR_EQ, IRT_STR), idx, lj_ir_kstr(J, name));
-	if (ctype_isconstval(fct->info)) {
-	  if (fct->size >= 0x80000000u &&
-	      (ctype_child(cts, fct)->info & CTF_UNSIGNED)) {
-	    J->base[0] = lj_ir_knum(J, (lua_Number)(uint32_t)fct->size);
-	    return;
-	  }
-	  J->base[0] = lj_ir_kint(J, (int32_t)fct->size);
-	  return;  /* Interpreter will throw for newindex. */
-	} else if (ctype_isbitfield(fct->info)) {
-	  lj_trace_err(J, LJ_TRERR_NYICONV);
-	} else {
-	  lua_assert(ctype_isfield(fct->info));
-	  sid = ctype_cid(fct->info);
-	}
-	ofs += (ptrdiff_t)fofs;
+        /* Always specialize to the field name. */
+        emitir(IRTG(IR_EQ, IRT_STR), idx, lj_ir_kstr(J, name));
+        if (ctype_isconstval(fct->info)) {
+          if (fct->size >= 0x80000000u &&
+              (ctype_child(cts, fct)->info & CTF_UNSIGNED)) {
+            J->base[0] = lj_ir_knum(J, (lua_Number)(uint32_t)fct->size);
+            return;
+          }
+          J->base[0] = lj_ir_kint(J, (int32_t)fct->size);
+          return;  /* Interpreter will throw for newindex. */
+        } else if (ctype_isbitfield(fct->info)) {
+          lj_trace_err(J, LJ_TRERR_NYICONV);
+        } else {
+          lua_assert(ctype_isfield(fct->info));
+          sid = ctype_cid(fct->info);
+        }
+        ofs += (ptrdiff_t)fofs;
       }
     } else if (ctype_iscomplex(ct->info)) {
       if (name->len == 2 &&
@@ -840,6 +879,18 @@ again:
 	if (strdata(name)[0] == 'i') ofs += (ct->size >> 1);
 	sid = ctype_cid(ct->info);
       }
+#ifdef LUAJIT_CTYPE_XRANGE                                 /* LD: 2016.05.14 */
+    } else if (ctype_isxrange(ct->info)) { /* See also lj_cdata_index */
+      if ((name->len == 5 && !memcmp(strdata(name), "start", 5)) ||
+          (name->len == 4 && !memcmp(strdata(name), "stop" , 4)) ||
+          (name->len == 4 && !memcmp(strdata(name), "step" , 4))) {
+        /* Always specialize to the field name. */
+        emitir(IRTG(IR_EQ, IRT_STR), idx, lj_ir_kstr(J, name));
+        ofs += (strdata(name)[2] == 'o') *   sizeof(double) +
+               (strdata(name)[2] == 'e') * 2*sizeof(double);
+        sid = ctype_cid(ct->info);
+      }
+#endif
     }
   }
   if (!sid) {
@@ -927,7 +978,7 @@ static void crec_alloc(jit_State *J, RecordFFData *rd, CTypeID id)
       trsz = lj_ir_kint(J, sz);
     }
     trcd = emitir(IRTG(IR_CNEW, IRT_CDATA), trid, trsz);
-    if (sz > 128 || (info & CTF_VLA)) {
+    if (sz > CREC_SINK_MAXSIZE || (info & CTF_VLA)) {	    /* LD: 2016.05.09 */
       TRef dp;
       CTSize align;
     special:  /* Only handle bulk zero-fill for large/VLA/VLS types. */
diff --git a/src/lj_ctype.c b/src/lj_ctype.c
index bc47cc5..5100ca3 100644
--- a/src/lj_ctype.c
+++ b/src/lj_ctype.c
@@ -67,6 +67,7 @@
   _("__signed",		0,	CTOK_SIGNED) \
   _("__signed__",	0,	CTOK_SIGNED) \
   _("unsigned",		0,	CTOK_UNSIGNED) \
+  _("xrange",		0,	CTOK_XRANGE) \
   /* Type qualifiers. */ \
   _("const",		0,	CTOK_CONST) \
   _("__const",		0,	CTOK_CONST) \
@@ -515,6 +516,11 @@ static void ctype_repr(CTRepr *ctr, CTypeID id)
 	if (size == 2*sizeof(float)) ctype_preplit(ctr, "float");
 	ctype_preplit(ctr, "complex");
 	return;
+#ifdef LUAJIT_CTYPE_XRANGE                                  /* LD: 2016.05.14 */
+      } else if ((info & CTF_XRANGE)) {
+        ctype_preplit(ctr, "xrange");
+        return;
+#endif
       } else {
 	ctype_preplit(ctr, ")))");
 	ctype_prepnum(ctr, size);
diff --git a/src/lj_ctype.h b/src/lj_ctype.h
index e9b426f..8ff3ddf 100644
--- a/src/lj_ctype.h
+++ b/src/lj_ctype.h
@@ -42,25 +42,25 @@ LJ_STATIC_ASSERT(((int)CT_STRUCT & (int)CT_ARRAY) == CT_STRUCT);
 **  ---------- info ------------
 ** |type      flags...  A   cid | size   |  sib  | next  | name  |
 ** +----------------------------+--------+-------+-------+-------+--
-** |NUM       BFvcUL..  A       | size   |       | type  |       |
-** |STRUCT    ..vcU..V  A       | size   | field | name? | name? |
-** |PTR       ..vcR...  A   cid | size   |       | type  |       |
-** |ARRAY     VCvc...V  A   cid | size   |       | type  |       |
-** |VOID      ..vc....  A       | size   |       | type  |       |
+** |NUM       BFcvUL..  A       | size   |       | type  |       |
+** |STRUCT    ..cvU..V  A       | size   | field | name? | name? |
+** |PTR       ..cvR...  A   cid | size   |       | type  |       |
+** |ARRAY     VCcvDX.V  A   cid | size   |       | type  |       |
+** |VOID      ..cv....  A       | size   |       | type  |       |
 ** |ENUM                A   cid | size   | const | name? | name? |
 ** |FUNC      ....VS.. cc   cid | nargs  | field | name? | name? |
 ** |TYPEDEF                 cid |        |       | name  | name  |
 ** |ATTRIB        attrnum   cid | attr   | sib?  | type? |       |
 ** |FIELD                   cid | offset | field |       | name? |
-** |BITFIELD  B.vcU csz bsz pos | offset | field |       | name? |
-** |CONSTVAL     c          cid | value  | const | name  | name  |
+** |BITFIELD  B.cvU csz bsz pos | offset | field |       | name? |
+** |CONSTVAL    c           cid | value  | const | name  | name  |
 ** |EXTERN                  cid |        | sib?  | name  | name  |
 ** |KW                      tok | size   |       | name  | name  |
 ** +----------------------------+--------+-------+-------+-------+--
 **        ^^  ^^--- bits used for C type conversion dispatch
 */
 
-/* C type info flags.     TFFArrrr  */
+/* C type info flags.     TFFArrrr  CType[4], Flags[8], Align[4], ChildID[16] */
 #define CTF_BOOL	0x08000000u	/* Boolean: NUM, BITFIELD. */
 #define CTF_FP		0x04000000u	/* Floating-point: NUM. */
 #define CTF_CONST	0x02000000u	/* Const qualifier. */
@@ -71,6 +71,8 @@ LJ_STATIC_ASSERT(((int)CT_STRUCT & (int)CT_ARRAY) == CT_STRUCT);
 #define CTF_REF		0x00800000u	/* Reference: PTR. */
 #define CTF_VECTOR	0x08000000u	/* Vector: ARRAY. */
 #define CTF_COMPLEX	0x04000000u	/* Complex: ARRAY. */
+#define CTF_DUALNUM	0x00800000u	/* Dual number: ARRAY. */
+#define CTF_XRANGE	0x00400000u	/* XRange: ARRAY. */
 #define CTF_UNION	0x00800000u	/* Union: STRUCT. */
 #define CTF_VARARG	0x00800000u	/* Vararg: FUNC. */
 #define CTF_SSEREGPARM	0x00400000u	/* SSE register parameters: FUNC. */
@@ -78,6 +80,7 @@ LJ_STATIC_ASSERT(((int)CT_STRUCT & (int)CT_ARRAY) == CT_STRUCT);
 #define CTF_QUAL	(CTF_CONST|CTF_VOLATILE)
 #define CTF_ALIGN	(CTMASK_ALIGN<<CTSHIFT_ALIGN)
 #define CTF_UCHAR	((char)-1 > 0 ? CTF_UNSIGNED : 0)
+#define CTF_VALARR      (CTF_VECTOR|CTF_COMPLEX|CTF_DUALNUM|CTF_XRANGE)
 
 /* Flags used in parser.  .F.Ammvf   cp->attr  */
 #define CTFP_ALIGNED	0x00000001u	/* cp->attr + ALIGN */
@@ -230,11 +233,15 @@ typedef struct CTState {
   (((info) & (CTMASK_NUM|CTF_REF)) == CTINFO(CT_PTR, CTF_REF))
 
 #define ctype_isrefarray(info) \
-  (((info) & (CTMASK_NUM|CTF_VECTOR|CTF_COMPLEX)) == CTINFO(CT_ARRAY, 0))
+  (((info) & (CTMASK_NUM|CTF_VALARR)) == CTINFO(CT_ARRAY, 0))
 #define ctype_isvector(info) \
   (((info) & (CTMASK_NUM|CTF_VECTOR)) == CTINFO(CT_ARRAY, CTF_VECTOR))
 #define ctype_iscomplex(info) \
   (((info) & (CTMASK_NUM|CTF_COMPLEX)) == CTINFO(CT_ARRAY, CTF_COMPLEX))
+#define ctype_isdualnum(info) \
+  (((info) & (CTMASK_NUM|CTF_DUALNUM)) == CTINFO(CT_ARRAY, CTF_DUALNUM))
+#define ctype_isxrange(info) \
+  (((info) & (CTMASK_NUM|CTF_XRANGE)) == CTINFO(CT_ARRAY, CTF_XRANGE))
 
 #define ctype_isvltype(info) \
   (((info) & ((CTMASK_NUM|CTF_VLA) - (2u<<CTSHIFT_NUM))) == \
@@ -289,6 +296,8 @@ typedef struct CTState {
   _(DOUBLE,		8,	CT_NUM, CTF_FP|CTALIGN(3)) \
   _(COMPLEX_FLOAT,	8,	CT_ARRAY, CTF_COMPLEX|CTALIGN(2)|CTID_FLOAT) \
   _(COMPLEX_DOUBLE,	16,	CT_ARRAY, CTF_COMPLEX|CTALIGN(3)|CTID_DOUBLE) \
+  _(DUALNUM,		16,	CT_ARRAY, CTF_DUALNUM|CTALIGN(3)|CTID_DOUBLE) \
+  _(XRANGE,             24,     CT_ARRAY, CTF_XRANGE |CTALIGN(3)|CTID_DOUBLE) \
   _(P_VOID,	CTSIZE_PTR,	CT_PTR, CTALIGN_PTR|CTID_VOID) \
   _(P_CVOID,	CTSIZE_PTR,	CT_PTR, CTALIGN_PTR|CTID_CVOID) \
   _(P_CCHAR,	CTSIZE_PTR,	CT_PTR, CTALIGN_PTR|CTID_CCHAR) \
@@ -335,7 +344,8 @@ CTTYDEF(CTTYIDDEF)
 /* Simple declaration specifiers. */
 #define CDSDEF(_) \
   _(VOID) _(BOOL) _(CHAR) _(INT) _(FP) \
-  _(LONG) _(LONGLONG) _(SHORT) _(COMPLEX) _(SIGNED) _(UNSIGNED) \
+  _(LONG) _(LONGLONG) _(SHORT) _(SIGNED) _(UNSIGNED) \
+  _(COMPLEX) _(DUALNUM) _(XRANGE) \
   _(CONST) _(VOLATILE) _(RESTRICT) _(INLINE) \
   _(TYPEDEF) _(EXTERN) _(STATIC) _(AUTO) _(REGISTER)
 
diff --git a/src/lj_lex.c b/src/lj_lex.c
index 0187c42..01b8f9a 100644
--- a/src/lj_lex.c
+++ b/src/lj_lex.c
@@ -53,6 +53,12 @@ static LJ_NOINLINE LexChar lex_more(LexState *ls)
   return (LexChar)(uint8_t)p[0];
 }
 
+/* Check next character. */
+static LJ_AINLINE LexChar lex_lookahead(LexState *ls)      /* LD: 2016.05.02 */
+{                                   /* --ls->p is always valid, see lex_more */
+  return (LexChar)(uint8_t)*(ls->p < ls->pe ? ls->p : (lex_more(ls), --ls->p));
+}
+
 /* Get next character. */
 static LJ_AINLINE LexChar lex_next(LexState *ls)
 {
@@ -93,8 +99,8 @@ static void lex_number(LexState *ls, TValue *tv)
   lua_assert(lj_char_isdigit(ls->c));
   if ((c = ls->c) == '0' && (lex_savenext(ls) | 0x20) == 'x')
     xp = 'p';
-  while (lj_char_isident(ls->c) || ls->c == '.' ||
-	 ((ls->c == '-' || ls->c == '+') && (c | 0x20) == xp)) {
+  while (lj_char_isident(ls->c) || (ls->c == '.' && lex_lookahead(ls) != '.') ||
+	 ((ls->c == '-' || ls->c == '+') && (c | 0x20) == xp)) {     /* '..' */
     c = ls->c;
     lex_savenext(ls);
   }
@@ -317,6 +323,9 @@ static LexToken lex_scan(LexState *ls, TValue *tv)
       continue;
     case '-':
       lex_next(ls);
+#ifdef LUAJIT_LAMBDA_SYNTAX                                /* LD: 2016.05.02 */
+      if (ls->c == '>') { lex_next(ls); return TK_arrow; }
+#endif
       if (ls->c != '-') return '-';
       lex_next(ls);
       if (ls->c == '[') {  /* Long comment "--[=*[...]=*]". */
@@ -328,6 +337,9 @@ static LexToken lex_scan(LexState *ls, TValue *tv)
 	  continue;
 	}
       }
+#ifdef LUAJIT_COMMENT_EMARK                                /* LD: 2016.05.02 */
+    case '!':
+#endif
       /* Short comment "--.*\n". */
       while (!lex_iseol(ls) && ls->c != LEX_EOF)
 	lex_next(ls);
@@ -346,6 +358,9 @@ static LexToken lex_scan(LexState *ls, TValue *tv)
       }
     case '=':
       lex_next(ls);
+#ifdef LUAJIT_LAMBDA_SYNTAX                                /* LD: 2016.05.02 */
+      if (ls->c == '>') { lex_next(ls); return TK_fatarrow; }
+#endif
       if (ls->c != '=') return '='; else { lex_next(ls); return TK_eq; }
     case '<':
       lex_next(ls);
@@ -358,6 +373,9 @@ static LexToken lex_scan(LexState *ls, TValue *tv)
       if (ls->c != '=') return '~'; else { lex_next(ls); return TK_ne; }
     case ':':
       lex_next(ls);
+#ifdef LUAJIT_LAMBDA_DEFER                                 /* LD: 2016.05.02 */
+      if (ls->c == '=') { lex_next(ls); return TK_deferred; }
+#endif
       if (ls->c != ':') return ':'; else { lex_next(ls); return TK_label; }
     case '"':
     case '\'':
diff --git a/src/lj_lex.h b/src/lj_lex.h
index 7fed1fd..f456ba1 100644
--- a/src/lj_lex.h
+++ b/src/lj_lex.h
@@ -17,6 +17,7 @@
   _(for) _(function) _(goto) _(if) _(in) _(local) _(nil) _(not) _(or) \
   _(repeat) _(return) _(then) _(true) _(until) _(while) \
   __(concat, ..) __(dots, ...) __(eq, ==) __(ge, >=) __(le, <=) __(ne, ~=) \
+  __(arrow, ->) __(fatarrow, =>) __(deferred, :=) \
   __(label, ::) __(number, <number>) __(name, <name>) __(string, <string>) \
   __(eof, <eof>)
 
diff --git a/src/lj_meta.c b/src/lj_meta.c
index c7993ad..a5be460 100644
--- a/src/lj_meta.c
+++ b/src/lj_meta.c
@@ -239,6 +239,21 @@ TValue *lj_meta_cat(lua_State *L, TValue *top, int left)
 {
   int fromc = 0;
   if (left < 0) { left = -left; fromc = 1; }
+#if LJ_HASFFI && defined(LUAJIT_CTYPE_XRANGE)              /* LD: 2016.05.14 */
+  if (tvisnumber(top) && tvisnumber(top-1)) {
+    /* Convert 2-3 concatenated numbers into a xrange, see also rec_cat. */
+    const int has_step = left > 1 && tvisnumber(top-2);
+    CTState *cts = ctype_cts(L);
+    /* Allocate cdata xrange. */
+    GCcdata *cd = lj_cdata_new(cts, CTID_XRANGE, 3*sizeof(double));
+    /* Copy start, stop[, step], default step is 1. */
+    top = has_step ? top-2 : top-1;
+    ((double *)cdataptr(cd))[0] = numV(top);
+    ((double *)cdataptr(cd))[1] = numV(top+1);
+    ((double *)cdataptr(cd))[2] = has_step ? numV(top+2) : 1;
+    setcdataV(L, top, cd);
+  } else
+#endif
   do {
     if (!(tvisstr(top) || tvisnumber(top)) ||
 	!(tvisstr(top-1) || tvisnumber(top-1))) {
diff --git a/src/lj_opt_fold.c b/src/lj_opt_fold.c
index e1d1369..802cf7e 100644
--- a/src/lj_opt_fold.c
+++ b/src/lj_opt_fold.c
@@ -711,7 +711,8 @@ LJFOLDF(kfold_add_kgc)
     CType *ct = ctype_raw(ctype_ctsG(J2G(J)), gco2cd(o)->ctypeid);
     if (ctype_isnum(ct->info) || ctype_isenum(ct->info) ||
 	ctype_isptr(ct->info) || ctype_isfunc(ct->info) ||
-	ctype_iscomplex(ct->info) || ctype_isvector(ct->info))
+	ctype_iscomplex(ct->info) || ctype_isxrange(ct->info) ||
+        ctype_isvector(ct->info))
       return lj_ir_kkptr(J, (char *)o + ofs);
   }
 #endif
diff --git a/src/lj_parse.c b/src/lj_parse.c
index 610c861..906d06b 100644
--- a/src/lj_parse.c
+++ b/src/lj_parse.c
@@ -1695,13 +1695,16 @@ static void expr_kvalue(TValue *v, ExpDesc *e)
   }
 }
 
+/* Forward declaration. */
+static void parse_body(LexState *ls, ExpDesc *e, int needself, int islambda, BCLine line);
+
 /* Parse table constructor expression. */
 static void expr_table(LexState *ls, ExpDesc *e)
 {
   FuncState *fs = ls->fs;
   BCLine line = ls->linenumber;
   GCtab *t = NULL;
-  int vcall = 0, needarr = 0, fixt = 0;
+  int vcall = 0, needarr = 0, fixt = 0, islambda = 0;
   uint32_t narr = 1;  /* First array index. */
   uint32_t nhash = 0;  /* Number of hash entries. */
   BCReg freg = fs->freereg;
@@ -1717,11 +1720,11 @@ static void expr_table(LexState *ls, ExpDesc *e)
       expr_bracket(ls, &key);  /* Already calls expr_toval. */
       if (!expr_isk(&key)) expr_index(fs, e, &key);
       if (expr_isnumk(&key) && expr_numiszero(&key)) needarr = 1; else nhash++;
-      lex_check(ls, '=');
+      if (lex_opt(ls, TK_deferred)) islambda = 1; else lex_check(ls, '=');
     } else if ((ls->tok == TK_name || (!LJ_52 && ls->tok == TK_goto)) &&
-	       lj_lex_lookahead(ls) == '=') {
+	       (lj_lex_lookahead(ls) == '=' || ls->lookahead == TK_deferred)) {
       expr_str(ls, &key);
-      lex_check(ls, '=');
+      if (lex_opt(ls, TK_deferred)) islambda = 1; else lex_check(ls, '=');
       nhash++;
     } else {
       expr_init(&key, VKNUM, 0);
@@ -1729,6 +1732,9 @@ static void expr_table(LexState *ls, ExpDesc *e)
       narr++;
       needarr = vcall = 1;
     }
+#ifdef LUAJIT_LAMBDA_DEFER /* LD: 2016.05.02 */
+    if (islambda) parse_body(ls, &val, 0, -1, ls->linenumber); else
+#endif
     expr(ls, &val);
     if (expr_isk(&key) && key.k != VKNIL &&
 	(key.k == VKSTR || expr_isk_nojump(&val))) {
@@ -1803,15 +1809,16 @@ static void expr_table(LexState *ls, ExpDesc *e)
   }
 }
 
-/* Parse function parameters. */
-static BCReg parse_params(LexState *ls, int needself)
+/* Parse function parameters. */                           /* LD: 2016.04.07 */
+static BCReg parse_params(LexState *ls, int needself, int islambda)
 {
   FuncState *fs = ls->fs;
   BCReg nparams = 0;
-  lex_check(ls, '(');
-  if (needself)
-    var_new_lit(ls, nparams++, "self");
-  if (ls->tok != ')') {
+  int has_param = islambda && (ls->c == '(' || lj_char_isident(ls->c));
+  lex_check(ls, islambda ? '\\' : '(');
+  int has_paren = !islambda || (has_param && lex_opt(ls, '('));
+  if (needself) var_new_lit(ls, nparams++, "self");
+  if ((has_paren && ls->tok != ')') || (!has_paren && has_param)) {
     do {
       if (ls->tok == TK_name || (!LJ_52 && ls->tok == TK_goto)) {
 	var_new(ls, nparams++, lex_str(ls));
@@ -1827,15 +1834,16 @@ static BCReg parse_params(LexState *ls, int needself)
   var_add(ls, nparams);
   lua_assert(fs->nactvar == nparams);
   bcreg_reserve(fs, nparams);
-  lex_check(ls, ')');
+  if (has_paren) lex_check(ls, ')');
   return nparams;
 }
 
 /* Forward declaration. */
 static void parse_chunk(LexState *ls);
+static void parse_return(LexState *ls, int islambda);
 
-/* Parse body of a function. */
-static void parse_body(LexState *ls, ExpDesc *e, int needself, BCLine line)
+/* Parse body of a function. */                            /* LD: 2016.04.07 */
+static void parse_body(LexState *ls, ExpDesc *e, int needself, int islambda, BCLine line)
 {
   FuncState fs, *pfs = ls->fs;
   FuncScope bl;
@@ -1844,12 +1852,19 @@ static void parse_body(LexState *ls, ExpDesc *e, int needself, BCLine line)
   fs_init(ls, &fs);
   fscope_begin(&fs, &bl, 0);
   fs.linedefined = line;
-  fs.numparams = (uint8_t)parse_params(ls, needself);
+  fs.numparams = islambda < 0 ? 0 : (uint8_t)parse_params(ls, needself, islambda);
   fs.bcbase = pfs->bcbase + pfs->pc;
   fs.bclim = pfs->bclim - pfs->pc;
   bcemit_AD(&fs, BC_FUNCF, 0, 0);  /* Placeholder. */
+  if (islambda > 0) {
+    if (lex_opt(ls, TK_fatarrow)) { islambda=0; goto body; }
+    else { lex_opt(ls, TK_arrow); parse_return(ls, 1); }
+  } else if (islambda < 0) { parse_return(ls, 1);
+  } else {
+  body:
   parse_chunk(ls);
   if (ls->tok != TK_end) lex_match(ls, TK_end, TK_function, line);
+  }
   pt = fs_finish(ls, (ls->lastline = ls->linenumber));
   pfs->bcbase = ls->bcstack + oldbase;  /* May have been reallocated. */
   pfs->bclim = (BCPos)(ls->sizebcstack - oldbase);
@@ -1864,7 +1879,7 @@ static void parse_body(LexState *ls, ExpDesc *e, int needself, BCLine line)
       pfs->flags |= PROTO_FIXUP_RETURN;
     pfs->flags |= PROTO_CHILD;
   }
-  lj_lex_next(ls);
+  if (!islambda) lj_lex_next(ls);
 }
 
 /* Parse expression list. Last expression is left open. */
@@ -1880,6 +1895,10 @@ static BCReg expr_list(LexState *ls, ExpDesc *v)
   return n;
 }
 
+
+/* Forward declaration. */
+static void expr_simple(LexState *ls, ExpDesc *v);
+
 /* Parse function argument list. */
 static void parse_args(LexState *ls, ExpDesc *e)
 {
@@ -1908,6 +1927,10 @@ static void parse_args(LexState *ls, ExpDesc *e)
     expr_init(&args, VKSTR, 0);
     args.u.sval = strV(&ls->tokval);
     lj_lex_next(ls);
+#ifdef LUAJIT_LAMBDA_CALL /* LD: 2016.04.20 */
+  } else if (ls->tok == '\\') {
+    expr_simple(ls, &args);
+#endif
   } else {
     err_syntax(ls, LJ_ERR_XFUNARG);
     return;  /* Silence compiler. */
@@ -1957,7 +1980,11 @@ static void expr_primary(LexState *ls, ExpDesc *v)
       expr_str(ls, &key);
       bcemit_method(fs, v, &key);
       parse_args(ls, v);
-    } else if (ls->tok == '(' || ls->tok == TK_string || ls->tok == '{') {
+    } else if (ls->tok == '(' || ls->tok == TK_string || ls->tok == '{'
+#ifdef LUAJIT_LAMBDA_CALL /* LD: 2016.04.20 */
+                                                      || ls->tok == '\\'
+#endif
+              ) {
       expr_tonextreg(fs, v);
       if (LJ_FR2) bcreg_reserve(fs, 1);
       parse_args(ls, v);
@@ -2003,8 +2030,13 @@ static void expr_simple(LexState *ls, ExpDesc *v)
     return;
   case TK_function:
     lj_lex_next(ls);
-    parse_body(ls, v, 0, ls->linenumber);
+    parse_body(ls, v, 0, 0, ls->linenumber);
+    return;
+#ifdef LUAJIT_LAMBDA_SYNTAX /* LD: 2016.04.07 */
+  case '\\':
+    parse_body(ls, v, 0, 1, ls->linenumber);
     return;
+#endif
   default:
     expr_primary(ls, v);
     return;
@@ -2243,7 +2275,7 @@ static void parse_local(LexState *ls)
     v.u.s.aux = fs->varmap[fs->freereg];
     bcreg_reserve(fs, 1);
     var_add(ls, 1);
-    parse_body(ls, &b, 0, ls->linenumber);
+    parse_body(ls, &b, 0, 0, ls->linenumber);
     /* bcemit_store(fs, &v, &b) without setting VSTACK_VAR_RW. */
     expr_free(fs, &b);
     expr_toreg(fs, &b, v.u.s.info);
@@ -2257,6 +2289,28 @@ static void parse_local(LexState *ls)
     } while (lex_opt(ls, ','));
     if (lex_opt(ls, '=')) {  /* Optional RHS. */
       nexps = expr_list(ls, &e);
+#ifdef LUAJIT_LOCAL_INTABLE                                /* LD: 2016.04.29 */
+    } else if (lex_opt(ls, TK_in)) { /* Optional RHS. */
+      FuncState *fs = ls->fs;
+      BCReg vars = fs->nactvar;
+      bcreg_reserve(fs, nvars);                  /* reserve regs for n vars */
+      var_new_lit(ls, nvars, "(in)");            /* create hidden '(in)' var */
+      expr(ls, &e);                              /* parse table expr */
+      assign_adjust(ls, nvars+1, nvars+1, &e);   /* discharge expr to '(in)' */
+      var_add(ls, nvars+1);                      /* expose vars + '(in)' */
+      for (nexps=0; nexps < nvars; nexps++) {
+      	ExpDesc k, v;
+      	expr_init(&e, VNONRELOC, fs->freereg-1); /* load table expr */
+	expr_init(&k, VKSTR, 0);                 /* set key from var name */
+	k.u.sval = strref(var_get(ls, fs, vars+nexps).name);
+	expr_index(fs, &e, &k);                  /* set key index in table */
+      	expr_init(&v, VLOCAL, vars+nexps);       /* set dest. var */
+	bcemit_store(fs, &v, &e);                /* store value to var */
+      }
+      var_remove(ls, vars+nvars);                /* drop hidden '(in)' var */
+      /* parse_chunk frees regs after each stmt., no need to drop table expr */
+      return;
+#endif
     } else {  /* Or implicitly set to nil. */
       e.k = VVOID;
       nexps = 0;
@@ -2281,7 +2335,7 @@ static void parse_func(LexState *ls, BCLine line)
     needself = 1;
     expr_field(ls, &v);
   }
-  parse_body(ls, &b, needself, line);
+  parse_body(ls, &b, needself, 0, line);
   fs = ls->fs;
   bcemit_store(fs, &v, &b);
   fs->bcbase[fs->pc - 1].line = line;  /* Set line for the store. */
@@ -2300,18 +2354,20 @@ static int parse_isend(LexToken tok)
   }
 }
 
-/* Parse 'return' statement. */
-static void parse_return(LexState *ls)
+/* Parse 'return' statement. */                            /* LD: 2016.04.07 */
+static void parse_return(LexState *ls, int islambda)
 {
   BCIns ins;
   FuncState *fs = ls->fs;
-  lj_lex_next(ls);  /* Skip 'return'. */
+  int has_list = islambda && lex_opt(ls, '(');
+  if (!islambda) lj_lex_next(ls); /* Skip 'return'. */
   fs->flags |= PROTO_HAS_RETURN;
-  if (parse_isend(ls->tok) || ls->tok == ';') {  /* Bare return. */
+  if (parse_isend(ls->tok) || ls->tok == ';'     /* Bare return. */
+                           || (has_list && ls->tok == ')')) {
     ins = BCINS_AD(BC_RET0, 0, 1);
   } else {  /* Return with one or more values. */
     ExpDesc e;  /* Receives the _last_ expression in the list. */
-    BCReg nret = expr_list(ls, &e);
+    BCReg nret = !islambda || has_list ? expr_list(ls,&e) : (expr(ls,&e),1);
     if (nret == 1) {  /* Return one result. */
       if (e.k == VCALL) {  /* Check for tail call. */
 	BCIns *ip = bcptr(fs, &e);
@@ -2333,6 +2389,7 @@ static void parse_return(LexState *ls)
       }
     }
   }
+  if (islambda && has_list) lex_check(ls, ')');
   if (fs->flags & PROTO_CHILD)
     bcemit_AJ(fs, BC_UCLO, 0, 0);  /* May need to close upvalues first. */
   bcemit_INS(fs, ins);
@@ -2646,7 +2703,7 @@ static int parse_stmt(LexState *ls)
     parse_local(ls);
     break;
   case TK_return:
-    parse_return(ls);
+    parse_return(ls, 0);
     return 1;  /* Must be last. */
   case TK_break:
     lj_lex_next(ls);
diff --git a/src/lj_record.c b/src/lj_record.c
index 8a72b0c..ba9027d 100644
--- a/src/lj_record.c
+++ b/src/lj_record.c
@@ -1823,9 +1823,36 @@ static TRef rec_cat(jit_State *J, BCReg baseslot, BCReg topslot)
   lua_assert(baseslot < topslot);
   for (s = baseslot; s <= topslot; s++)
     (void)getslot(J, s);  /* Ensure all arguments have a reference. */
+#if LJ_HASFFI && defined(LUAJIT_CTYPE_XRANGE)              /* LD: 2016.05.14 */
+  if (tref_isnumber (top[0]) && tref_isnumber (top[-1])) {
+    /* Convert 2-3 concatenated numbers into a xrange, see also lj_meta_cat. */
+    TRef dp, tr, *base = &J->base[baseslot];
+    const int has_step = top-2 >= base && tref_isnumber(top[-2]);
+    const int esz = sizeof(double);
+    /* Allocate cdata xrange. */
+    dp  = emitir(IRTG(IR_CNEW, IRT_CDATA), lj_ir_kint(J, CTID_XRANGE), TREF_NIL);
+    /* First convert integers to numbers. */
+    top = has_step ? top-2 : top-1;
+    if (tref_isinteger(top[0])) top[0]=emitir(IRTN(IR_CONV), top[0], IRCONV_NUM_INT);
+    if (tref_isinteger(top[1])) top[1]=emitir(IRTN(IR_CONV), top[1], IRCONV_NUM_INT);
+    if (has_step)
+    if (tref_isinteger(top[2])) top[2]=emitir(IRTN(IR_CONV), top[2], IRCONV_NUM_INT);
+    /* Copy start, stop[, step]; default step is 1. */
+    tr = emitir(IRT(IR_ADD   , IRT_PTR), dp, lj_ir_kintp(J, sizeof(GCcdata)));
+         emitir(IRT(IR_XSTORE, IRT_NUM), tr, top[0]);
+    tr = emitir(IRT(IR_ADD   , IRT_PTR), dp, lj_ir_kintp(J, sizeof(GCcdata)+esz));
+         emitir(IRT(IR_XSTORE, IRT_NUM), tr, top[1]);
+    tr = emitir(IRT(IR_ADD   , IRT_PTR), dp, lj_ir_kintp(J, sizeof(GCcdata)+2*esz));
+         emitir(IRT(IR_XSTORE, IRT_NUM), tr, has_step ? top[2] : lj_ir_knum(J, 1));
+    J->maxslot = (BCReg)(top - J->base);
+    lua_assert(base == top);
+    /* rec_check_ir(J); rec_check_slots(J); */
+    return dp;
+  } else
+#endif
   if (tref_isnumber_str(top[0]) && tref_isnumber_str(top[-1])) {
-    TRef tr, hdr, *trp, *xbase, *base = &J->base[baseslot];
-    /* First convert numbers to strings. */
+    TRef tr, hdr, *trp, *xbase, *base = &J->base[baseslot]; 
+    /* First convert numbers to strings. */               
     for (trp = top; trp >= base; trp--) {
       if (tref_isnumber(*trp))
 	*trp = emitir(IRT(IR_TOSTR, IRT_STR), *trp,
