diff --git a/src/Makefile b/src/Makefile
index 3f25192..5f3183a 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -99,7 +99,7 @@ XCFLAGS=
 # enabled by default. Some other features that *might* break some existing
 # code (e.g. __pairs or os.execute() return values) can be enabled here.
 # Note: this does not provide full compatibility with Lua 5.2 at this time.
-#XCFLAGS+= -DLUAJIT_ENABLE_LUA52COMPAT
+XCFLAGS+= -DLUAJIT_ENABLE_LUA52COMPAT
 #
 # Disable the JIT compiler, i.e. turn LuaJIT into a pure interpreter.
 #XCFLAGS+= -DLUAJIT_DISABLE_JIT
@@ -110,6 +110,12 @@ XCFLAGS=
 #XCFLAGS+= -DLUAJIT_NUMMODE=1
 #XCFLAGS+= -DLUAJIT_NUMMODE=2
 #
+# Support for lambda function syntax and direct arg call
+XCFLAGS+= -DLUAJIT_LAMBDA_SYNTAX -DLUAJIT_LAMBDA_CALL
+#
+# Support for local 'in' table syntax
+XCFLAGS+= -DLUAJIT_LOCAL_INTABLE
+#
 ##############################################################################
 
 ##############################################################################
diff --git a/src/lj_cparse.c b/src/lj_cparse.c
index 16d2cb6..24b827b 100644
--- a/src/lj_cparse.c
+++ b/src/lj_cparse.c
@@ -1480,8 +1480,8 @@ static CPscl cp_decl_spec(CPState *cp, CPDecl *decl, CPscl scl)
       cp_next(cp);
       continue;
     }
-    if (sz || tdef ||
-	(cds & (CDF_SHORT|CDF_LONG|CDF_SIGNED|CDF_UNSIGNED|CDF_COMPLEX)))
+    if (sz || tdef ||                                     /* LD: 2016.05.02 */
+	(cds & (CDF_SHORT|CDF_LONG|CDF_SIGNED|CDF_UNSIGNED|CDF_COMPLEX|CDF_XRANGE)))
       break;
     switch (cp->tok) {
     case CTOK_STRUCT:
@@ -1513,6 +1513,8 @@ end_decl:
 
   if ((cds & CDF_COMPLEX))  /* Use predefined complex types. */
     tdef = sz == 4 ? CTID_COMPLEX_FLOAT : CTID_COMPLEX_DOUBLE;
+  else if ((cds & CDF_XRANGE))  /* Use predefined xrange types. */
+    tdef = CTID_XRANGE;                                   /* LD: 2016.05.02 */
 
   if (tdef) {
     cp_push_type(decl, tdef);
diff --git a/src/lj_ctype.c b/src/lj_ctype.c
index bc47cc5..7c41bae 100644
--- a/src/lj_ctype.c
+++ b/src/lj_ctype.c
@@ -67,6 +67,7 @@
   _("__signed",		0,	CTOK_SIGNED) \
   _("__signed__",	0,	CTOK_SIGNED) \
   _("unsigned",		0,	CTOK_UNSIGNED) \
+  _("xrange",		0,	CTOK_XRANGE) \
   /* Type qualifiers. */ \
   _("const",		0,	CTOK_CONST) \
   _("__const",		0,	CTOK_CONST) \
@@ -515,6 +516,8 @@ static void ctype_repr(CTRepr *ctr, CTypeID id)
 	if (size == 2*sizeof(float)) ctype_preplit(ctr, "float");
 	ctype_preplit(ctr, "complex");
 	return;
+      } else if (id == CTID_XRANGE) { /* LD: 2016.05.02 */
+	ctype_preplit(ctr, "xrange");
       } else {
 	ctype_preplit(ctr, ")))");
 	ctype_prepnum(ctr, size);
diff --git a/src/lj_ctype.h b/src/lj_ctype.h
index e9b426f..cf5427f 100644
--- a/src/lj_ctype.h
+++ b/src/lj_ctype.h
@@ -289,6 +289,7 @@ typedef struct CTState {
   _(DOUBLE,		8,	CT_NUM, CTF_FP|CTALIGN(3)) \
   _(COMPLEX_FLOAT,	8,	CT_ARRAY, CTF_COMPLEX|CTALIGN(2)|CTID_FLOAT) \
   _(COMPLEX_DOUBLE,	16,	CT_ARRAY, CTF_COMPLEX|CTALIGN(3)|CTID_DOUBLE) \
+  _(XRANGE,		24, 	CT_ARRAY, CTF_VECTOR|CTALIGN(3)|CTID_DOUBLE) \
   _(P_VOID,	CTSIZE_PTR,	CT_PTR, CTALIGN_PTR|CTID_VOID) \
   _(P_CVOID,	CTSIZE_PTR,	CT_PTR, CTALIGN_PTR|CTID_CVOID) \
   _(P_CCHAR,	CTSIZE_PTR,	CT_PTR, CTALIGN_PTR|CTID_CCHAR) \
@@ -335,7 +336,7 @@ CTTYDEF(CTTYIDDEF)
 /* Simple declaration specifiers. */
 #define CDSDEF(_) \
   _(VOID) _(BOOL) _(CHAR) _(INT) _(FP) \
-  _(LONG) _(LONGLONG) _(SHORT) _(COMPLEX) _(SIGNED) _(UNSIGNED) \
+  _(LONG) _(LONGLONG) _(SHORT) _(COMPLEX) _(XRANGE) _(SIGNED) _(UNSIGNED) \
   _(CONST) _(VOLATILE) _(RESTRICT) _(INLINE) \
   _(TYPEDEF) _(EXTERN) _(STATIC) _(AUTO) _(REGISTER)
 
diff --git a/src/lj_lex.c b/src/lj_lex.c
index 0187c42..e0909aa 100644
--- a/src/lj_lex.c
+++ b/src/lj_lex.c
@@ -53,6 +53,12 @@ static LJ_NOINLINE LexChar lex_more(LexState *ls)
   return (LexChar)(uint8_t)p[0];
 }
 
+/* Check next character. */
+static LJ_AINLINE LexChar lex_nextahead(LexState *ls)      /* LD: 2016.05.02 */
+{                                   /* --ls->p is always valid, see lex_more */
+  return (LexChar)(uint8_t)*(ls->p < ls->pe ? ls->p : (lex_more(ls), --ls->p));
+}
+
 /* Get next character. */
 static LJ_AINLINE LexChar lex_next(LexState *ls)
 {
@@ -93,8 +99,8 @@ static void lex_number(LexState *ls, TValue *tv)
   lua_assert(lj_char_isdigit(ls->c));
   if ((c = ls->c) == '0' && (lex_savenext(ls) | 0x20) == 'x')
     xp = 'p';
-  while (lj_char_isident(ls->c) || ls->c == '.' ||
-	 ((ls->c == '-' || ls->c == '+') && (c | 0x20) == xp)) {
+  while (lj_char_isident(ls->c) || (ls->c == '.' && lex_nextahead(ls) != '.') ||
+	 ((ls->c == '-' || ls->c == '+') && (c | 0x20) == xp)) {     /* '..' */
     c = ls->c;
     lex_savenext(ls);
   }
@@ -317,6 +323,7 @@ static LexToken lex_scan(LexState *ls, TValue *tv)
       continue;
     case '-':
       lex_next(ls);
+      if (ls->c == '>') { lex_next(ls); return TK_arrow; }
       if (ls->c != '-') return '-';
       lex_next(ls);
       if (ls->c == '[') {  /* Long comment "--[=*[...]=*]". */
@@ -328,6 +335,7 @@ static LexToken lex_scan(LexState *ls, TValue *tv)
 	  continue;
 	}
       }
+    case '!':
       /* Short comment "--.*\n". */
       while (!lex_iseol(ls) && ls->c != LEX_EOF)
 	lex_next(ls);
@@ -346,6 +354,7 @@ static LexToken lex_scan(LexState *ls, TValue *tv)
       }
     case '=':
       lex_next(ls);
+      if (ls->c == '>') { lex_next(ls); return TK_fatarrow; }
       if (ls->c != '=') return '='; else { lex_next(ls); return TK_eq; }
     case '<':
       lex_next(ls);
@@ -358,6 +367,7 @@ static LexToken lex_scan(LexState *ls, TValue *tv)
       if (ls->c != '=') return '~'; else { lex_next(ls); return TK_ne; }
     case ':':
       lex_next(ls);
+      if (ls->c == '=') { lex_next(ls); return TK_deferred; }
       if (ls->c != ':') return ':'; else { lex_next(ls); return TK_label; }
     case '"':
     case '\'':
diff --git a/src/lj_lex.h b/src/lj_lex.h
index 7fed1fd..f456ba1 100644
--- a/src/lj_lex.h
+++ b/src/lj_lex.h
@@ -17,6 +17,7 @@
   _(for) _(function) _(goto) _(if) _(in) _(local) _(nil) _(not) _(or) \
   _(repeat) _(return) _(then) _(true) _(until) _(while) \
   __(concat, ..) __(dots, ...) __(eq, ==) __(ge, >=) __(le, <=) __(ne, ~=) \
+  __(arrow, ->) __(fatarrow, =>) __(deferred, :=) \
   __(label, ::) __(number, <number>) __(name, <name>) __(string, <string>) \
   __(eof, <eof>)
 
diff --git a/src/lj_meta.c b/src/lj_meta.c
index c7993ad..299579a 100644
--- a/src/lj_meta.c
+++ b/src/lj_meta.c
@@ -268,6 +268,24 @@ TValue *lj_meta_cat(lua_State *L, TValue *top, int left)
       setcont(top-1, lj_cont_cat);
       if (LJ_FR2) { setnilV(top); setnilV(top+2); top += 2; }
       return top+1;  /* Trigger metamethod call. */
+#if LJ_HASFFI
+    } else if (tvisnumber(top) && tvisnumber(top-1)) {
+      /* convert 2-3 concatenated numbers into a range */ /* LD: 2016.05.02 */
+      double start, stop, step;
+      if (left > 1 && tvisnumber(top-2)) {
+	top -= 2; left -= 2;
+	start = numV(top); stop = numV(top+1); step = numV(top+2);
+      } else {
+	top -= 1; left -= 1;
+	start = numV(top); stop = numV(top+1);
+	step = start > stop ? -1 : 1;
+      }
+      GCcdata *cd = lj_cdata_new_(L, CTID_XRANGE, 3*sizeof(double));
+      ((double *)cdataptr(cd))[0] = start;
+      ((double *)cdataptr(cd))[1] = stop;
+      ((double *)cdataptr(cd))[2] = step;
+      setcdataV(L, top, cd);
+#endif
     } else {
       /* Pick as many strings as possible from the top and concatenate them:
       **
diff --git a/src/lj_parse.c b/src/lj_parse.c
index 610c861..d41c449 100644
--- a/src/lj_parse.c
+++ b/src/lj_parse.c
@@ -1695,13 +1695,16 @@ static void expr_kvalue(TValue *v, ExpDesc *e)
   }
 }
 
+/* Forward declaration. */
+static void parse_body(LexState *ls, ExpDesc *e, int needself, int islambda, BCLine line);
+
 /* Parse table constructor expression. */
 static void expr_table(LexState *ls, ExpDesc *e)
 {
   FuncState *fs = ls->fs;
   BCLine line = ls->linenumber;
   GCtab *t = NULL;
-  int vcall = 0, needarr = 0, fixt = 0;
+  int vcall = 0, needarr = 0, fixt = 0, islambda = 0;
   uint32_t narr = 1;  /* First array index. */
   uint32_t nhash = 0;  /* Number of hash entries. */
   BCReg freg = fs->freereg;
@@ -1717,11 +1720,11 @@ static void expr_table(LexState *ls, ExpDesc *e)
       expr_bracket(ls, &key);  /* Already calls expr_toval. */
       if (!expr_isk(&key)) expr_index(fs, e, &key);
       if (expr_isnumk(&key) && expr_numiszero(&key)) needarr = 1; else nhash++;
-      lex_check(ls, '=');
+      if (lex_opt(ls, TK_deferred)) islambda = 1; else lex_check(ls, '=');
     } else if ((ls->tok == TK_name || (!LJ_52 && ls->tok == TK_goto)) &&
-	       lj_lex_lookahead(ls) == '=') {
+	       (lj_lex_lookahead(ls) == '=' || ls->lookahead == TK_deferred)) {
       expr_str(ls, &key);
-      lex_check(ls, '=');
+      if (lex_opt(ls, TK_deferred)) islambda = 1; else lex_check(ls, '=');
       nhash++;
     } else {
       expr_init(&key, VKNUM, 0);
@@ -1729,7 +1732,8 @@ static void expr_table(LexState *ls, ExpDesc *e)
       narr++;
       needarr = vcall = 1;
     }
-    expr(ls, &val);
+    if (islambda) parse_body(ls, &val, 0, -1, ls->linenumber);
+    else expr(ls, &val);
     if (expr_isk(&key) && key.k != VKNIL &&
 	(key.k == VKSTR || expr_isk_nojump(&val))) {
       TValue k, *v;
@@ -1803,15 +1807,16 @@ static void expr_table(LexState *ls, ExpDesc *e)
   }
 }
 
-/* Parse function parameters. */
-static BCReg parse_params(LexState *ls, int needself)
+/* Parse function parameters. */                           /* LD: 2016.04.07 */
+static BCReg parse_params(LexState *ls, int needself, int islambda)
 {
   FuncState *fs = ls->fs;
   BCReg nparams = 0;
-  lex_check(ls, '(');
-  if (needself)
-    var_new_lit(ls, nparams++, "self");
-  if (ls->tok != ')') {
+  int has_param = islambda && ls->c != ' ' && ls->c != '\t';
+  if (islambda) lj_lex_next(ls); else lex_check(ls, '(');
+  int has_paren = !islambda || (has_param && lex_opt(ls, '('));
+  if (needself) var_new_lit(ls, nparams++, "self");
+  if ((has_paren && ls->tok != ')') || (!has_paren && has_param)) {
     do {
       if (ls->tok == TK_name || (!LJ_52 && ls->tok == TK_goto)) {
 	var_new(ls, nparams++, lex_str(ls));
@@ -1827,15 +1832,16 @@ static BCReg parse_params(LexState *ls, int needself)
   var_add(ls, nparams);
   lua_assert(fs->nactvar == nparams);
   bcreg_reserve(fs, nparams);
-  lex_check(ls, ')');
+  if (has_paren) lex_check(ls, ')');
   return nparams;
 }
 
 /* Forward declaration. */
 static void parse_chunk(LexState *ls);
+static void parse_return(LexState *ls, int islambda);
 
-/* Parse body of a function. */
-static void parse_body(LexState *ls, ExpDesc *e, int needself, BCLine line)
+/* Parse body of a function. */                            /* LD: 2016.04.07 */
+static void parse_body(LexState *ls, ExpDesc *e, int needself, int islambda, BCLine line)
 {
   FuncState fs, *pfs = ls->fs;
   FuncScope bl;
@@ -1844,12 +1850,19 @@ static void parse_body(LexState *ls, ExpDesc *e, int needself, BCLine line)
   fs_init(ls, &fs);
   fscope_begin(&fs, &bl, 0);
   fs.linedefined = line;
-  fs.numparams = (uint8_t)parse_params(ls, needself);
+  fs.numparams = islambda < 0 ? 0 : (uint8_t)parse_params(ls, needself, islambda);
   fs.bcbase = pfs->bcbase + pfs->pc;
   fs.bclim = pfs->bclim - pfs->pc;
   bcemit_AD(&fs, BC_FUNCF, 0, 0);  /* Placeholder. */
+  if (islambda > 0) {
+    if (lex_opt(ls, TK_fatarrow)) { islambda=0; goto body; }
+    else { lex_opt(ls, TK_arrow); parse_return(ls, 1); }
+  } else if (islambda < 0) { parse_return(ls, 1);
+  } else {
+  body:
   parse_chunk(ls);
   if (ls->tok != TK_end) lex_match(ls, TK_end, TK_function, line);
+  }
   pt = fs_finish(ls, (ls->lastline = ls->linenumber));
   pfs->bcbase = ls->bcstack + oldbase;  /* May have been reallocated. */
   pfs->bclim = (BCPos)(ls->sizebcstack - oldbase);
@@ -1864,7 +1877,7 @@ static void parse_body(LexState *ls, ExpDesc *e, int needself, BCLine line)
       pfs->flags |= PROTO_FIXUP_RETURN;
     pfs->flags |= PROTO_CHILD;
   }
-  lj_lex_next(ls);
+  if (!islambda) lj_lex_next(ls);
 }
 
 /* Parse expression list. Last expression is left open. */
@@ -1880,6 +1893,10 @@ static BCReg expr_list(LexState *ls, ExpDesc *v)
   return n;
 }
 
+
+/* Forward declaration. */
+static void expr_simple(LexState *ls, ExpDesc *v);
+
 /* Parse function argument list. */
 static void parse_args(LexState *ls, ExpDesc *e)
 {
@@ -1908,6 +1925,10 @@ static void parse_args(LexState *ls, ExpDesc *e)
     expr_init(&args, VKSTR, 0);
     args.u.sval = strV(&ls->tokval);
     lj_lex_next(ls);
+#ifdef LUAJIT_LAMBDA_CALL /* LD: 2016.04.20 */
+  } else if (ls->tok == '\\') {
+    expr_simple(ls, &args);
+#endif
   } else {
     err_syntax(ls, LJ_ERR_XFUNARG);
     return;  /* Silence compiler. */
@@ -1957,7 +1978,11 @@ static void expr_primary(LexState *ls, ExpDesc *v)
       expr_str(ls, &key);
       bcemit_method(fs, v, &key);
       parse_args(ls, v);
-    } else if (ls->tok == '(' || ls->tok == TK_string || ls->tok == '{') {
+    } else if (ls->tok == '(' || ls->tok == TK_string || ls->tok == '{'
+#ifdef LUAJIT_LAMBDA_CALL /* LD: 2016.04.20 */
+                                                      || ls->tok == '\\'
+#endif
+              ) {
       expr_tonextreg(fs, v);
       if (LJ_FR2) bcreg_reserve(fs, 1);
       parse_args(ls, v);
@@ -2003,8 +2028,13 @@ static void expr_simple(LexState *ls, ExpDesc *v)
     return;
   case TK_function:
     lj_lex_next(ls);
-    parse_body(ls, v, 0, ls->linenumber);
+    parse_body(ls, v, 0, 0, ls->linenumber);
     return;
+#ifdef LUAJIT_LAMBDA_SYNTAX /* LD: 2016.04.07 */
+  case '\\':
+    parse_body(ls, v, 0, 1, ls->linenumber);
+    return;
+#endif
   default:
     expr_primary(ls, v);
     return;
@@ -2243,7 +2273,7 @@ static void parse_local(LexState *ls)
     v.u.s.aux = fs->varmap[fs->freereg];
     bcreg_reserve(fs, 1);
     var_add(ls, 1);
-    parse_body(ls, &b, 0, ls->linenumber);
+    parse_body(ls, &b, 0, 0, ls->linenumber);
     /* bcemit_store(fs, &v, &b) without setting VSTACK_VAR_RW. */
     expr_free(fs, &b);
     expr_toreg(fs, &b, v.u.s.info);
@@ -2257,6 +2287,28 @@ static void parse_local(LexState *ls)
     } while (lex_opt(ls, ','));
     if (lex_opt(ls, '=')) {  /* Optional RHS. */
       nexps = expr_list(ls, &e);
+#ifdef LUAJIT_LOCAL_INTABLE                                /* LD: 2016.04.29 */
+    } else if (lex_opt(ls, TK_in)) { /* Optional RHS. */
+      FuncState *fs = ls->fs;
+      BCReg vars = fs->nactvar;
+      bcreg_reserve(fs, nvars);                  /* reserve regs for n vars */
+      var_new_lit(ls, nvars, "(in)");            /* create hidden '(in)' var */
+      expr(ls, &e);                              /* parse table expr */
+      assign_adjust(ls, nvars+1, nvars+1, &e);   /* discharge expr to '(in)' */
+      var_add(ls, nvars+1);                      /* expose vars + '(in)' */
+      for (nexps=0; nexps < nvars; nexps++) {
+      	ExpDesc k, v;
+      	expr_init(&e, VNONRELOC, fs->freereg-1); /* load table expr */
+	expr_init(&k, VKSTR, 0);                 /* set key from var name */
+	k.u.sval = strref(var_get(ls, fs, vars+nexps).name);
+	expr_index(fs, &e, &k);                  /* set key index in table */
+      	expr_init(&v, VLOCAL, vars+nexps);       /* set dest. var */
+	bcemit_store(fs, &v, &e);                /* store value to var */
+      }
+      var_remove(ls, vars+nvars);                /* drop hidden '(in)' var */
+      /* parse_chunk frees regs after each stmt., no need to drop table expr */
+      return;
+#endif
     } else {  /* Or implicitly set to nil. */
       e.k = VVOID;
       nexps = 0;
@@ -2281,7 +2333,7 @@ static void parse_func(LexState *ls, BCLine line)
     needself = 1;
     expr_field(ls, &v);
   }
-  parse_body(ls, &b, needself, line);
+  parse_body(ls, &b, needself, 0, line);
   fs = ls->fs;
   bcemit_store(fs, &v, &b);
   fs->bcbase[fs->pc - 1].line = line;  /* Set line for the store. */
@@ -2300,18 +2352,20 @@ static int parse_isend(LexToken tok)
   }
 }
 
-/* Parse 'return' statement. */
-static void parse_return(LexState *ls)
+/* Parse 'return' statement. */                            /* LD: 2016.04.07 */
+static void parse_return(LexState *ls, int islambda)
 {
   BCIns ins;
   FuncState *fs = ls->fs;
-  lj_lex_next(ls);  /* Skip 'return'. */
+  int has_list = islambda && lex_opt(ls, '(');
+  if (!islambda) lj_lex_next(ls); /* Skip 'return'. */
   fs->flags |= PROTO_HAS_RETURN;
-  if (parse_isend(ls->tok) || ls->tok == ';') {  /* Bare return. */
+  if (parse_isend(ls->tok) || ls->tok == ';'     /* Bare return. */
+                           || (has_list && ls->tok == ')')) {
     ins = BCINS_AD(BC_RET0, 0, 1);
   } else {  /* Return with one or more values. */
     ExpDesc e;  /* Receives the _last_ expression in the list. */
-    BCReg nret = expr_list(ls, &e);
+    BCReg nret = !islambda || has_list ? expr_list(ls,&e) : (expr(ls,&e),1);
     if (nret == 1) {  /* Return one result. */
       if (e.k == VCALL) {  /* Check for tail call. */
 	BCIns *ip = bcptr(fs, &e);
@@ -2333,6 +2387,7 @@ static void parse_return(LexState *ls)
       }
     }
   }
+  if (islambda && has_list) lex_check(ls, ')');
   if (fs->flags & PROTO_CHILD)
     bcemit_AJ(fs, BC_UCLO, 0, 0);  /* May need to close upvalues first. */
   bcemit_INS(fs, ins);
@@ -2646,7 +2701,7 @@ static int parse_stmt(LexState *ls)
     parse_local(ls);
     break;
   case TK_return:
-    parse_return(ls);
+    parse_return(ls, 0);
     return 1;  /* Must be last. */
   case TK_break:
     lj_lex_next(ls);
