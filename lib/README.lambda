README.lambda

The extension is a direct parsing of the lambda syntaxes:

\(arg_list) (expr)
\(arg_list) (expr_list)

which is equivalent to the Lua syntax

function (arg_list) return expr      end
function (arg_list) return expr_list end

+ Parenthesis around arg_list are optional
+ Parenthesis around expr_list are required, but optional for expr 
+ The first lambda parameter name (if any) or parameter parenthesis (if any)
  must “touch” the lambda sign (backslash). Any space or tab between the lambda
  sign and a token will be understood as a void lambda.

Examples of equivalent forms in Lua and Lambda syntaxes:

> f=function (x) return x*x end
> f=\(x) (x*x)
> f=\(x) x*x
> f=\x (x*x)
> f=\x x*x
> =f(2)
4 

> f=function (...) return {...} end
> f=\... {...}
> =f(4)[1]
4

> f=function (x,y) return math.sqrt(x*x+y*y) end
> f=\x,y math.sqrt(x*x+y*y)
> =f(2,3)
3.605551275464

> f=function (x) return function (y) return x+y,x-y end end
> f=\x\y (x+y,x-y)
> =f(2)(3)
5   -1

> f=function () return  x end  -- free variable x
> f=\ x                        -- note the space
> x=10
> =f()
10
> x=20
> =f()
20

> f=function () return -x end  -- free variable x
> f=\ -x                       -- note the space
> x=10
> =f()
-10
> x=20
> =f()
-20

> a={ f=function (x,y) return x+y,x-y end, 3 } 
> a={ f=\x,y (x+y,x-y), 3 }
> =a.f(2,3)
5   -1
> =a[1]
3

> x,y=4,6
> a={ f=function (x,y) return x+y end, x-y, 3 }
> a={ f=\x,y x+y, x-y, 3 }
> =a.f(2,3)
5
> =a[1]
-2
> =a[2]
3

> z=10
> a={ f=function (s,y) return s.x*y+z end, x=3 } 
> a={ f=\s,y s.x*y+z, x=3 }
> =a:f(2)
16
> a.x=5
> =a:f(2)
20

Example: Fibonacci sequence (2nd is more readable)

fib=\n n<2 and n or fib(n-1)+fib(n-2)

fib=\(n) n<2 and n or fib(n-1)+fib(n-2)

Example: composition of lambda

> id=\... ...
> f=\x x^2
> g=\x (x,x)
> h=\x,y (x+y,x-y)
> cat=\f,g \... f(g(...))

> f(2)
4
> gf=cat(g,f)
> =gf(2)
4  4
> hgf=cat(h,gf)
> =hgf(2)
8  0

> sm, gm = setmetatable, getmetatable
> -- let’s define ^ and bottom for function composition
> _ = sm({id}, { __pow  = \f,g sm({cat(f,g[1])}, gm(g)),
>>               __call = \g,... g[1](...) })

> hgf= h^g^f^_  -- = cat(h,cat(g,f)) but no () mismatch
> =hgf(2)
8  0
